_BYTE *re::ResourceFetchManager::removeOnConnectionAddedHandler(_BYTE *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE v14[24];
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 34);
  if (*(_QWORD *)(v2 + 80))
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = 48 * v5;
      while (1)
      {
        v7 = (uint64_t *)(*(_QWORD *)(v2 + 96) + v6);
        v13 = *v7;
        v15 = v7[4];
        v16 = 0;
        re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v14, (uint64_t)(v7 + 1));
        this = v16;
        if (v16)
        {
          this = (_BYTE *)(**(uint64_t (***)(_BYTE *))v16)(v16);
          if (v16 != v14)
            this = (_BYTE *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
          v16 = 0;
        }
        if (v13 != a2)
          break;
        ++v5;
        v8 = *(_QWORD *)(v2 + 80);
        v6 += 48;
        if (v5 >= v8)
          goto LABEL_14;
      }
      if (v4 != v5)
      {
        v9 = *(_QWORD *)(v2 + 96);
        v10 = (_QWORD *)(v9 + 48 * v4);
        *v10 = *(_QWORD *)(v9 + v6);
        this = (_BYTE *)re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)(v10 + 1), v9 + v6 + 8);
      }
      ++v5;
      ++v4;
      v8 = *(_QWORD *)(v2 + 80);
    }
    while (v5 < v8);
LABEL_14:
    if (v4 != v8)
    {
      v11 = 48 * v8 - 48 * v4;
      v12 = *(_QWORD *)(v2 + 96) + 48 * v4 + 8;
      do
      {
        this = re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v12);
        v12 += 48;
        v11 -= 48;
      }
      while (v11);
      *(_QWORD *)(v2 + 80) = v4;
      ++*(_DWORD *)(v2 + 88);
    }
  }
  return this;
}

uint64_t re::ResourceFetchManager::addOnConnectionInterruptedOrInvalidatedHandler(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _anonymous_namespace_ *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _BYTE v15[24];
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 280);
  *(_QWORD *)(a1 + 280) = v3 + 1;
  v16 = *(_QWORD *)(a2 + 24);
  v17 = 0;
  v4 = (_anonymous_namespace_ *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v15, a2);
  v5 = *(_QWORD *)(a1 + 272);
  v6 = *(_QWORD *)(v5 + 112);
  v7 = *(_QWORD *)(v5 + 120);
  if (v7 >= v6)
  {
    v8 = v7 + 1;
    if (v6 < v7 + 1)
    {
      if (*(_QWORD *)(v5 + 104))
      {
        v9 = 2 * v6;
        v10 = v6 == 0;
        v11 = 8;
        if (!v10)
          v11 = v9;
        if (v11 <= v8)
          v12 = v8;
        else
          v12 = v11;
        re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::setCapacity((_QWORD *)(v5 + 104), v12);
      }
      else
      {
        re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::setCapacity((_QWORD *)(v5 + 104), v8);
        ++*(_DWORD *)(v5 + 128);
      }
    }
    v7 = *(_QWORD *)(v5 + 120);
  }
  v13 = (_QWORD *)(*(_QWORD *)(v5 + 136) + 48 * v7);
  *v13 = v3;
  v13[4] = v16;
  v13[5] = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)(v13 + 1), (uint64_t)v15);
  ++*(_QWORD *)(v5 + 120);
  ++*(_DWORD *)(v5 + 128);
  if (v17)
  {
    (**(void (***)(_BYTE *))v17)(v17);
    if (v17 != v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
  }
  return v3;
}

_BYTE *re::ResourceFetchManager::removeOnConnectionInterruptedOrInvalidatedHandler(_BYTE *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE v14[24];
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 34);
  if (*(_QWORD *)(v2 + 120))
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = 48 * v5;
      while (1)
      {
        v7 = (uint64_t *)(*(_QWORD *)(v2 + 136) + v6);
        v13 = *v7;
        v15 = v7[4];
        v16 = 0;
        re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v14, (uint64_t)(v7 + 1));
        this = v16;
        if (v16)
        {
          this = (_BYTE *)(**(uint64_t (***)(_BYTE *))v16)(v16);
          if (v16 != v14)
            this = (_BYTE *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
          v16 = 0;
        }
        if (v13 != a2)
          break;
        ++v5;
        v8 = *(_QWORD *)(v2 + 120);
        v6 += 48;
        if (v5 >= v8)
          goto LABEL_14;
      }
      if (v4 != v5)
      {
        v9 = *(_QWORD *)(v2 + 136);
        v10 = (_QWORD *)(v9 + 48 * v4);
        *v10 = *(_QWORD *)(v9 + v6);
        this = (_BYTE *)re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)(v10 + 1), v9 + v6 + 8);
      }
      ++v5;
      ++v4;
      v8 = *(_QWORD *)(v2 + 120);
    }
    while (v5 < v8);
LABEL_14:
    if (v4 != v8)
    {
      v11 = 48 * v8 - 48 * v4;
      v12 = *(_QWORD *)(v2 + 136) + 48 * v4 + 8;
      do
      {
        this = re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v12);
        v12 += 48;
        v11 -= 48;
      }
      while (v11);
      *(_QWORD *)(v2 + 120) = v4;
      ++*(_DWORD *)(v2 + 128);
    }
  }
  return this;
}

void re::ResourceFetchManager::setShaderGraphLoader(uint64_t a1, void *aBlock)
{
  void *v3;
  void *v4;

  v3 = _Block_copy(aBlock);
  v4 = *(void **)(a1 + 296);
  *(_QWORD *)(a1 + 296) = v3;

}

void re::ResourceFetchManager::tryGetShaderGraph(uint64_t a1, uint64_t a2, unint64_t a3, void *a4)
{
  void (**v7)(id, _QWORD, double);
  os_unfair_lock_s *v8;
  uint64_t v9;
  id *v10;
  uint64_t v11;
  id v12;
  id v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  int v34;
  int v35;
  int v36;

  v7 = a4;
  v8 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  v9 = *(_QWORD *)(a1 + 88);
  if (v9)
  {
    v10 = (id *)(*(_QWORD *)(a1 + 104) + 8);
    v11 = v9 << 6;
    while (objc_msgSend(*v10, "hash") != a2)
    {
      v10 += 8;
      v11 -= 64;
      if (!v11)
        goto LABEL_5;
    }
    v12 = *v10;
    os_unfair_lock_unlock(v8);
    if (v12)
    {
      v13 = v12;
      objc_sync_enter(v13);
      objc_msgSend(v13, "pendingShaderGraphs");
      if (v30)
      {
        v14 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) >> 27));
        v15 = v14 ^ (v14 >> 31);
        v16 = *(unsigned int *)(v31 + 4 * (v15 % v33));
        if ((_DWORD)v16 != 0x7FFFFFFF)
        {
          if (*(_QWORD *)(v32 + 32 * v16 + 16) == a3)
          {
LABEL_12:
            v17 = v32 + 32 * v16;
            v18 = re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(&v30);
            v7[2](v7, *(_QWORD *)(v17 + 24), v18);
            objc_msgSend(v13, "pendingShaderGraphs");
            if (v30)
            {
              v19 = v15 % v33;
              v20 = *(unsigned int *)(v31 + 4 * v19);
              if ((_DWORD)v20 != 0x7FFFFFFF)
              {
                v21 = v32 + 32 * v20;
                if (*(_QWORD *)(v21 + 16) == a3)
                {
                  *(_DWORD *)(v31 + 4 * v19) = *(_DWORD *)(v21 + 8) & 0x7FFFFFFF;
LABEL_19:
                  v25 = v32 + 32 * v20;
                  v26 = *(_DWORD *)(v25 + 8);
                  if (v26 < 0)
                  {
                    *(_DWORD *)(v25 + 8) = v26 & 0x7FFFFFFF;
                    v29 = *(_QWORD *)(v25 + 24);
                    v28 = (_QWORD *)(v25 + 24);
                    v27 = v29;
                    if (v29)
                    {

                      *v28 = 0;
                    }
                  }
                  *(_DWORD *)(v32 + 32 * v20 + 8) = *(_DWORD *)(v32 + 32 * v20 + 8) & 0x80000000 | v35;
                  --v34;
                  v35 = v20;
                  ++v36;
                }
                else
                {
                  while (1)
                  {
                    v22 = v20;
                    v23 = *(_DWORD *)(v32 + 32 * v20 + 8);
                    v20 = v23 & 0x7FFFFFFF;
                    if ((v23 & 0x7FFFFFFF) == 0x7FFFFFFF)
                      break;
                    v24 = v32 + 32 * v20;
                    if (*(_QWORD *)(v24 + 16) == a3)
                    {
                      *(_DWORD *)(v32 + 32 * v22 + 8) = *(_DWORD *)(v32 + 32 * v22 + 8) & 0x80000000 | *(_DWORD *)(v24 + 8) & 0x7FFFFFFF;
                      goto LABEL_19;
                    }
                  }
                }
              }
            }
          }
          else
          {
            while (1)
            {
              v16 = *(_DWORD *)(v32 + 32 * v16 + 8) & 0x7FFFFFFF;
              if ((_DWORD)v16 == 0x7FFFFFFF)
                break;
              if (*(_QWORD *)(v32 + 32 * v16 + 16) == a3)
                goto LABEL_12;
            }
          }
        }
      }
      re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(&v30);
      objc_sync_exit(v13);

    }
  }
  else
  {
LABEL_5:
    os_unfair_lock_unlock(v8);
  }

}

uint64_t re::ResourceFetchManager::Request::dispose(_BOOL8 this)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v1 = this;
  v8 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(this + 16))
  {
    if (!*(_BYTE *)(this + 104))
    {
      v2 = re::resourceSharingLogObjects((re *)this)[1];
      this = os_log_type_enabled(v2, OS_LOG_TYPE_FAULT);
      if (this)
      {
        if ((*(_BYTE *)(v1 + 40) & 1) != 0)
          v5 = *(_QWORD *)(v1 + 48);
        else
          v5 = v1 + 41;
        v6 = 136315138;
        v7 = v5;
        _os_log_fault_impl(&dword_224FE9000, v2, OS_LOG_TYPE_FAULT, "Resource request for '%s' was not cancelled before being released", (uint8_t *)&v6, 0xCu);
      }
    }
  }
  v3 = re::globalAllocators((re *)this)[2];
  re::ResourceFetchManager::Request::~Request((re::ResourceFetchManager::Request *)v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, v1);
}

void re::ResourceFetchManager::Request::~Request(re::ResourceFetchManager::Request *this)
{
  re::ResourceFetchManager::Request::~Request(this);
  JUMPOUT(0x2276933B8);
}

{
  uint64_t v2;

  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 64);
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    if ((*((_BYTE *)this + 40) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 6));
    *((_OWORD *)this + 2) = 0u;
    *((_OWORD *)this + 3) = 0u;
  }

}

_QWORD *re::DynamicArray<re::ResourceFetchManager::Connection>::setCapacity(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  __int128 *v8;
  uint64_t v9;
  __int128 *v10;
  _QWORD *v11;
  __int128 v12;
  void *v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::ResourceFetchManager::Connection>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 58)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 64, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = a2 << 6;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, a2 << 6, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (__int128 *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[4 * v9];
        v11 = v7;
        do
        {
          v12 = *v8;
          *(_QWORD *)v8 = 0;
          *((_QWORD *)v8 + 1) = 0;
          *(_OWORD *)v11 = v12;
          *((_OWORD *)v11 + 2) = 0u;
          *((_DWORD *)v11 + 12) = 0;
          *((_OWORD *)v11 + 1) = 0u;
          *(_QWORD *)((char *)v11 + 52) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v11 + 2, (uint64_t *)v8 + 2);
          re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v8 + 2);

          v13 = *(void **)v8;
          v8 += 4;

          v11 += 8;
        }
        while (v8 != v10);
        v8 = (__int128 *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

double re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 88;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  _OWORD *v4;

  v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    v2 = result;
    v4 = (_OWORD *)(result + 16);
    v3 = *(_QWORD *)(result + 16);
    *((_DWORD *)v4 - 2) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if ((*(_BYTE *)(v2 + 24) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(v2 + 32));
      *v4 = 0u;
      v4[1] = 0u;
    }
    result = *(_QWORD *)(v2 + 48);
    if (result)
    {
      if (*(_QWORD *)(v2 + 80))
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
      *(_QWORD *)(v2 + 80) = 0;
      *(_QWORD *)(v2 + 56) = 0;
      *(_QWORD *)(v2 + 64) = 0;
      *(_QWORD *)(v2 + 48) = 0;
      ++*(_DWORD *)(v2 + 72);
    }
  }
  return result;
}

void re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + v3);
        ++v4;
        v3 += 88;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

uint64_t re::DynamicArray<re::SharedPtr<re::ResourceFetchManager::Request>>::deinit(uint64_t a1)
{
  uint64_t result;
  unsigned int **v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(unsigned int ***)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 8 * v4;
        do
        {
          if (*v3)
          {
            re::details::release<re::ResourceRequest>(*v3);
            *v3 = 0;
          }
          ++v3;
          v5 -= 8;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(unsigned int ***)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, unsigned int **))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::ResourceFetchManager::Connection>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = (uint64_t *)(v3 + 16);
        v6 = v4 << 6;
        do
        {
          re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v5);

          v5 += 8;
          v6 -= 64;
        }
        while (v6);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

__int128 *re::PeerIDValidator::instance(re::PeerIDValidator *this)
{
  unsigned __int8 v1;

  {
    re::PeerIDValidator::instance(void)::instance = 0u;
    *(_OWORD *)algn_255800410 = 0u;
    dword_255800420 = 1065353216;
  }
  return &re::PeerIDValidator::instance(void)::instance;
}

void re::PeerIDValidator::remove_impl(re::PeerIDValidator *this, unint64_t a2)
{
  re *v3;
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  NSObject *v7;
  unint64_t v8;
  uint8_t buf[4];
  unint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = a2;
  v3 = (re *)std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(this, &v8);
  if (v3)
  {
    v4 = *((_DWORD *)v3 + 17) - 1;
    *((_DWORD *)v3 + 17) = v4;
    v5 = *re::resourceSharingLogObjects(v3);
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
    if (v4)
    {
      if (v6)
      {
        *(_DWORD *)buf = 134217984;
        v10 = v8;
        _os_log_debug_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEBUG, "PeerIDValidator: Decrementing count for Entry with PeerID %llu.", buf, 0xCu);
      }
    }
    else
    {
      if (v6)
      {
        *(_DWORD *)buf = 134217984;
        v10 = v8;
        _os_log_debug_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEBUG, "PeerIDValidator: Removing Entry with PeerID %llu.", buf, 0xCu);
      }
      std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::__erase_unique<unsigned long long>(this, &v8);
    }
  }
  else
  {
    v7 = *re::resourceSharingLogObjects(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v10 = v8;
      _os_log_error_impl(&dword_224FE9000, v7, OS_LOG_TYPE_ERROR, "PeerIDValidator: Error removing Entry for PeerID %llu -- not found.", buf, 0xCu);
    }
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::__erase_unique<unsigned long long>(_QWORD *a1, unint64_t *a2)
{
  uint64_t *result;

  result = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  void *v3;
  void *__p;

  v2 = *a2;
  std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::remove(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0;
  if (v3)
    operator delete(v3);
  return v2;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::remove@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  unsigned int *v2;

  v2 = *(unsigned int **)(a1 + 48);
  if (v2)
  {
    re::details::release<re::ResourceRequest>(v2);
    *(_QWORD *)(a1 + 48) = 0;
  }
}

void ___ZZN2re20ResourceFetchManager13fetchResourceEPKcRKNS_9AssetPathENS_8FunctionIFvNS_6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEEEEEENK3__0clERNS0_14SharedXPCStateE_block_invoke(uint64_t a1, void *a2)
{
  re *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  unsigned int *v7;
  re *v8;
  re *v9;
  unsigned int *v10;
  uint64_t v11;
  re *v12;
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  re *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 40);
  v5 = re::resourceSharingLogObjects(v3)[1];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if ((*(_BYTE *)(a1 + 56) & 1) != 0)
      v6 = *(_QWORD *)(a1 + 64);
    else
      v6 = a1 + 57;
    *(_DWORD *)buf = 136315394;
    v14 = v6;
    v15 = 2112;
    v16 = v3;
    _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEFAULT, "Encountered an error communicating with the remote object proxy, which will cause a load failure for asset '%s'. If the error domain is NSCocoaErrorDomain and the code is 4101 (NSXPCConnectionReplyInvalid), then the underlying issue might have been been logged from Foundation (see NSXPCConnection.m) with subsystem com.apple.Foundation and category xpc.exceptions. The error is: %@", buf, 0x16u);
  }
  v7 = *(unsigned int **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48);
  v10 = v7;
  if (v7)
  {
    re::details::retain<re::ResourceFetchManager::Request>(v7);
    v11 = 0;
    v12 = v3;
    v8 = v3;
    re::ResourceFetchManager::receiveFetchResponse(v4, (uint64_t)&v10);

    re::details::release<re::ResourceRequest>(v7);
  }
  else
  {
    v11 = 0;
    v12 = v3;
    v9 = v3;
    re::ResourceFetchManager::receiveFetchResponse(v4, (uint64_t)&v10);

  }
}

re::DynamicString *__copy_helper_block_a8_48c24_ZTSN2re13DynamicStringE(uint64_t a1, uint64_t a2)
{
  return re::DynamicString::DynamicString((re::DynamicString *)(a1 + 48), (const re::DynamicString *)(a2 + 48));
}

double __destroy_helper_block_a8_48c24_ZTSN2re13DynamicStringE(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;

  v3 = (_OWORD *)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 56) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 64));
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  return result;
}

void ___ZZN2re20ResourceFetchManager13fetchResourceEPKcRKNS_9AssetPathENS_8FunctionIFvNS_6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEEEEEENK3__0clERNS0_14SharedXPCStateE_block_invoke_159(uint64_t a1, void *a2, void *a3)
{
  id v5;
  void *v6;
  uint64_t v7;
  unsigned int *v8;
  id v9;
  id v10;
  id v11;
  unsigned int *v12;
  id v13;
  id v14;

  v11 = a2;
  v5 = a3;
  v6 = v5;
  v7 = *(_QWORD *)(a1 + 40);
  v8 = *(unsigned int **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48);
  v12 = v8;
  if (v8)
  {
    re::details::retain<re::ResourceFetchManager::Request>(v8);
    v13 = v11;
    v14 = v6;
    v9 = v6;
    v10 = v11;
    re::ResourceFetchManager::receiveFetchResponse(v7, (uint64_t)&v12);

    re::details::release<re::ResourceRequest>(v8);
  }
  else
  {
    v13 = v11;
    v14 = v5;
    re::ResourceFetchManager::receiveFetchResponse(v7, (uint64_t)&v12);
  }

}

re::DynamicString *re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t a5)
{
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  re::DynamicString *result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v10 = *(_DWORD *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    v10 = *(_DWORD *)(a1 + 32);
    v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 88 * v10 + 8) = v13 | 0x80000000;
  v14 = 88 * v10;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v14) = a3;
  result = re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + v14 + 16), a4);
  v16 = *(_QWORD *)(a1 + 16) + 88 * v10;
  *(_QWORD *)(v16 + 80) = 0;
  *(_DWORD *)(v16 + 72) = 0;
  *(_QWORD *)(v16 + 56) = 0;
  *(_QWORD *)(v16 + 64) = 0;
  *(_QWORD *)(v16 + 48) = 0;
  v17 = *(_QWORD *)(a5 + 8);
  *(_QWORD *)(v16 + 48) = *(_QWORD *)a5;
  *(_QWORD *)(v16 + 56) = v17;
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(a5 + 8) = 0;
  v18 = *(_QWORD *)(v16 + 64);
  *(_QWORD *)(v16 + 64) = *(_QWORD *)(a5 + 16);
  *(_QWORD *)(a5 + 16) = v18;
  v19 = *(_QWORD *)(v16 + 80);
  *(_QWORD *)(v16 + 80) = *(_QWORD *)(a5 + 32);
  *(_QWORD *)(a5 + 32) = v19;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(v16 + 72);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

void re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  signed int v13;
  _BYTE v14[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v14, 0, 36);
      *(_QWORD *)&v14[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::RigDataTypeClass,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v14, v4, a2);
      v5 = *(_OWORD *)v14;
      *(_OWORD *)v14 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v14[16];
      v7 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)&v14[16] = v7;
      *(_QWORD *)(a1 + 16) = v6;
      v9 = *(_OWORD *)&v14[24];
      *(_OWORD *)&v14[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v14[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = v7 + 48;
        do
        {
          if ((*(_DWORD *)(v12 - 40) & 0x80000000) != 0)
            re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(v12 - 48) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v12 - 48), (re::DynamicString *)(v12 - 32));
          ++v11;
          v12 += 88;
        }
        while (v11 < v10);
      }
      re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v14);
    }
  }
  else
  {
    if (a2)
      v13 = a2;
    else
      v13 = 3;
  }
}

void re::details::retain<re::ResourceFetchManager::Request>(unsigned int *a1)
{
  unsigned int *v2;
  unsigned int v4;
  const void *v5;

  v2 = a1 + 2;
  if (!atomic_load(a1 + 2))
  {
    v5 = (const void *)atomic_load(v2);
    re::internal::refCountCheckFailHandler((re::internal *)1, a1, v5);
  }
  do
    v4 = __ldxr(v2);
  while (__stxr(v4 + 1, v2));
  if (v4 - 0x100000 <= 0xFFEFFFFE)
    re::internal::refCountCheckFailHandler((re::internal *)1, a1, (const void *)(v4 + 1));
}

id re::ResourceFetchManager::Connection::remoteObjectProxy(id *this)
{
  id v1;
  id v3;

  re::xpc::Connection::remoteObjectProxy(this, &v3);
  v1 = v3;

  return v1;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v8, a2);
  if (!*(_QWORD *)a1)
    return 0;
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v6 + 88 * v5 + 16, a2))
  {
    v5 = *(_DWORD *)(v6 + 88 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF)
      return 0;
  }
  return v6 + 88 * v5 + 48;
}

unint64_t re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(uint64_t a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v12;
  char v13;

  result = re::Hash<re::DynamicString>::operator()((uint64_t)&v13, a2);
  if (*(_QWORD *)a1)
  {
    v5 = result % *(unsigned int *)(a1 + 24);
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(unsigned int *)(v6 + 4 * v5);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *(_QWORD *)(a1 + 16);
      result = re::DynamicString::operator==(v8 + 88 * v7 + 16, a2);
      if ((result & 1) != 0)
      {
        *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v8 + 88 * v7 + 8) & 0x7FFFFFFF;
LABEL_8:
        result = re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + 88 * v7);
        v11 = *(_QWORD *)(a1 + 16) + 88 * v7;
        v12 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v11 + 8) = *(_DWORD *)(v11 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v7;
        *(_DWORD *)(a1 + 40) = v12 + 1;
      }
      else
      {
        while (1)
        {
          v9 = v7;
          v10 = *(_DWORD *)(v8 + 88 * v7 + 8);
          v7 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          result = re::DynamicString::operator==(v8 + 88 * v7 + 16, a2);
          if ((result & 1) != 0)
          {
            *(_DWORD *)(v8 + 88 * v9 + 8) = *(_DWORD *)(v8 + 88 * v9 + 8) & 0x80000000 | *(_DWORD *)(v8 + 88 * v7 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

uint64_t re::DynamicOverflowArray<re::SharedPtr<re::ResourceFetchManager::Request>,1ul>::setCapacity(uint64_t *a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t result;
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;

  result = *a1;
  if (a2 && !result)
  {
    result = re::DynamicOverflowArray<re::SharedPtr<re::ResourceFetchManager::Request>,1ul>::setCapacity(a1, a2);
    v6 = *((_DWORD *)a1 + 4) + 2;
LABEL_4:
    *((_DWORD *)a1 + 4) = v6;
    return result;
  }
  v7 = *((_DWORD *)a1 + 4);
  if ((v7 & 1) != 0)
    v8 = 1;
  else
    v8 = a1[3];
  if (v8 != a2)
  {
    v9 = a1[1];
    if (v9 <= a2 && (a2 > 1 || (v7 & 1) == 0))
    {
      if (a2 < 2)
      {
        v14 = a1[4];
        if (v9)
        {
          if ((v7 & 1) != 0)
            v15 = a1 + 3;
          else
            v15 = (uint64_t *)a1[4];
          a1[3] = *v15;
          *v15 = 0;
        }
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v14);
        v6 = *((_DWORD *)a1 + 4) | 1;
        goto LABEL_4;
      }
      if (a2 >> 61)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 646, 8, a2);
        _os_crash();
        __break(1u);
      }
      else
      {
        v2 = 8 * a2;
        result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)result + 32))(result, 8 * a2, 8);
        if (result)
        {
          v11 = result;
          v12 = *((_DWORD *)a1 + 4);
          if ((v12 & 1) != 0)
            v13 = a1 + 3;
          else
            v13 = (_QWORD *)a1[4];
          v16 = a1[1];
          if (v16)
          {
            v17 = 8 * v16;
            v18 = (_QWORD *)result;
            do
            {
              *v18++ = *v13;
              *v13++ = 0;
              v17 -= 8;
            }
            while (v17);
            v12 = *((_DWORD *)a1 + 4);
          }
          if ((v12 & 1) == 0)
          {
            result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)*a1 + 40))(*a1, a1[4]);
            v12 = *((_DWORD *)a1 + 4);
          }
          *((_DWORD *)a1 + 4) = v12 & 0xFFFFFFFE;
          a1[3] = a2;
          a1[4] = v11;
          return result;
        }
      }
      re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, v2, *(_QWORD *)(*a1 + 8));
      result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

BOOL re::PeerIDValidator::validateOrAdd_impl(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  NSObject *v9;
  _BOOL8 result;
  uint64_t v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  NSObject *v15;
  __int128 v16;
  char v17;
  NSObject *v18;
  uint64_t v19;
  int v20;
  int v21;
  NSObject *v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  _BYTE v26[24];
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v4 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(a1, (unint64_t *)a2);
  if (v4)
  {
    v5 = v4;
    if (*(_DWORD *)(a2 + 8) != *((_DWORD *)v4 + 8))
    {
      v18 = *re::resourceSharingLogObjects((re *)v4);
      result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      v19 = v5[3];
      v20 = *(_DWORD *)(a2 + 8);
      v21 = *((_DWORD *)v5 + 8);
      *(_DWORD *)v26 = 134218496;
      *(_QWORD *)&v26[4] = v19;
      *(_WORD *)&v26[12] = 1024;
      *(_DWORD *)&v26[14] = v20;
      *(_WORD *)&v26[18] = 1024;
      *(_DWORD *)&v26[20] = v21;
      v12 = "PeerIDValidator: Attempting to add Entry with invalid pid for PeerID %llu: %u != %u.";
      v13 = v18;
      v14 = 24;
      goto LABEL_20;
    }
    if (*(_QWORD *)((char *)v4 + 36) != *(_QWORD *)(a2 + 12)
      || *(_QWORD *)((char *)v4 + 44) != *(_QWORD *)(a2 + 20)
      || *(_QWORD *)((char *)v4 + 52) != *(_QWORD *)(a2 + 28)
      || *(_QWORD *)((char *)v4 + 60) != *(_QWORD *)(a2 + 36))
    {
      v9 = *re::resourceSharingLogObjects((re *)v4);
      result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      v11 = v5[3];
      *(_DWORD *)v26 = 134217984;
      *(_QWORD *)&v26[4] = v11;
      v12 = "PeerIDValidator: Attempting to add Entry with invalid auditToken for PeerID: %llu.";
      v13 = v9;
      v14 = 12;
LABEL_20:
      _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, v12, v26, v14);
      return 0;
    }
    ++*((_DWORD *)v4 + 17);
    v22 = *re::resourceSharingLogObjects((re *)v4);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      v24 = v5[3];
      v25 = *((_DWORD *)v5 + 17);
      *(_DWORD *)v26 = 134218240;
      *(_QWORD *)&v26[4] = v24;
      *(_WORD *)&v26[12] = 1024;
      *(_DWORD *)&v26[14] = v25;
      _os_log_debug_impl(&dword_224FE9000, v22, OS_LOG_TYPE_DEBUG, "PeerIDValidator: Incrementing count for Entry with PeerID %llu to %u.", v26, 0x12u);
    }
    return 1;
  }
  else
  {
    *(_DWORD *)(a2 + 44) = 1;
    v15 = *re::resourceSharingLogObjects(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v23 = *(_QWORD *)a2;
      *(_DWORD *)v26 = 134217984;
      *(_QWORD *)&v26[4] = v23;
      _os_log_debug_impl(&dword_224FE9000, v15, OS_LOG_TYPE_DEBUG, "PeerIDValidator: Adding new Entry with PeerID %llu.", v26, 0xCu);
    }
    *(_QWORD *)v26 = *(_QWORD *)a2;
    v16 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)&v26[8] = *(_OWORD *)a2;
    v27 = v16;
    v28 = *(_OWORD *)(a2 + 32);
    std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,re::PeerIDValidator::Entry>>((uint64_t)a1, (unint64_t *)v26, (uint64_t)v26);
    return v17 & 1;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,re::PeerIDValidator::Entry>>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  __int128 v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (v10[2] == v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x48uLL);
  *v10 = 0;
  v10[1] = v6;
  v12 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v10 + 1) = *(_OWORD *)a3;
  *((_OWORD *)v10 + 2) = v12;
  *((_OWORD *)v10 + 3) = *(_OWORD *)(a3 + 32);
  v10[8] = *(_QWORD *)(a3 + 48);
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *v10 = *v20;
LABEL_38:
    *v20 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v19 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v21 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void re::ResourceFetchManager::ConnectionEventHandlers::~ConnectionEventHandlers(re::ResourceFetchManager::ConnectionEventHandlers *this)
{
  char *v2;

  *(_QWORD *)this = &off_24ED2D6A0;
  v2 = (char *)this + 24;
  re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::deinit((uint64_t)this + 104);
  re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::deinit((uint64_t)this + 64);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)v2);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  char *v2;

  *(_QWORD *)this = &off_24ED2D6A0;
  v2 = (char *)this + 24;
  re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::deinit((uint64_t)this + 104);
  re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::deinit((uint64_t)this + 64);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)v2);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          v2 = 48 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v8 + 48 * v9;
        v11 = (uint64_t)(v7 + 1);
        v12 = v8 + 8;
        do
        {
          *(_QWORD *)(v11 - 8) = *(_QWORD *)(v12 - 8);
          *(_QWORD *)(v11 + 24) = *(_QWORD *)(v12 + 24);
          *(_QWORD *)(v11 + 32) = 0;
          re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(v11, v12);
          re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v12);
          v11 += 48;
          v13 = v12 + 40;
          v12 += 48;
        }
        while (v13 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::HashTable<unsigned long long,re::SharedPtr<re::SharedObject>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  id v18;

  re::HashTable<unsigned long long,re::SharedPtr<re::SharedObject>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<unsigned long long,re::SharedPtr<re::SharedObject>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = (unint64_t *)(*(_QWORD *)(a2 + 16) + v6);
      if ((v8[1] & 0x80000000) != 0)
      {
        v9 = *v8;
        v10 = *(unsigned int *)(a1 + 24);
        v11 = *v8 % v10;
        v12 = *(unsigned int *)(a1 + 36);
        if ((_DWORD)v12 == 0x7FFFFFFF)
        {
          v12 = *(unsigned int *)(a1 + 32);
          v13 = v12;
          if ((_DWORD)v12 == (_DWORD)v10)
          {
            re::HashTable<unsigned long long,re::SharedPtr<re::SharedObject>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
            v11 = v9 % *(unsigned int *)(a1 + 24);
            v13 = *(_DWORD *)(a1 + 32);
          }
          *(_DWORD *)(a1 + 32) = v13 + 1;
          v14 = *(_QWORD *)(a1 + 16);
          v15 = *(_DWORD *)(v14 + 32 * v12 + 8);
        }
        else
        {
          v14 = *(_QWORD *)(a1 + 16);
          v15 = *(_DWORD *)(v14 + 32 * v12 + 8);
          *(_DWORD *)(a1 + 36) = v15 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v14 + 32 * v12 + 8) = v15 | 0x80000000;
        v16 = *(_QWORD *)(a1 + 8);
        *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v12 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v12 + 8) & 0x80000000 | *(_DWORD *)(v16 + 4 * v11);
        *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v12) = v9;
        v17 = v8[3];
        *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v12 + 16) = v8[2];
        *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v12 + 24) = v17;
        if (v17)
        {
          v18 = (id)(v17 + 8);
          v16 = *(_QWORD *)(a1 + 8);
        }
        *(_DWORD *)(v16 + 4 * v11) = v12;
        ++*(_DWORD *)(a1 + 28);
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 32;
    }
  }
}

void re::HashTable<unsigned long long,re::SharedPtr<re::SharedObject>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 24);
          if (v8)
          {

            *(_QWORD *)(v6 + 24) = 0;
            v3 = *(unsigned int *)(a1 + 32);
          }
        }
        v4 += 32;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v9 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v9;
  }
}

void re::HashTable<unsigned long long,re::SharedPtr<re::SharedObject>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphNode>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_QWORD *)(v6 + 24);
        do
        {
          if ((*(_DWORD *)(v13 - 2) & 0x80000000) != 0)
          {
            v14 = *(v13 - 3);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<unsigned long long,re::SharedPtr<re::SharedObject>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 16) = *(v13 - 1);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 24) = *v13;
            *v13 = 0;
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 4;
          --v10;
        }
        while (v10);
      }
      re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

uint64_t *re::allocInfo_PrereleaseVersionInfo(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FBA38);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBA38))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FBDF0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540FBE00 = 0;
    qword_2540FBE10 = 0;
    qword_2540FBE18 = 0xFFFFFFFFLL;
    qword_2540FBDF0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FBE20 = (uint64_t)"PrereleaseVersionInfo";
    dword_2540FBE28 = 0;
    xmmword_2540FBE30 = 0u;
    xmmword_2540FBE40 = 0u;
    xmmword_2540FBE50 = 0u;
    qword_2540FBE60 = 0;
    __cxa_guard_release(&qword_2540FBA38);
  }
  return &qword_2540FBDF0;
}

void re::initInfo_PrereleaseVersionInfo(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  __int128 v14;
  _QWORD v15[2];
  __int128 v16;

  v15[0] = 0x1EE93697053F1DC4;
  v15[1] = "PrereleaseVersionInfo";
  re::StringID::destroyString((re::StringID *)v15);
  *((_OWORD *)this + 2) = v16;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FBA40);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FBA40);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicString>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "id";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FBB70 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::IntrospectionInfo<re::DynamicString>::get(1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "frameworkVersion";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x2000000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540FBB78 = v13;
      __cxa_guard_release(&qword_2540FBA40);
    }
  }
  *((_QWORD *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_2540FBB70;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::PrereleaseVersionInfo>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::PrereleaseVersionInfo>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::PrereleaseVersionInfo>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::PrereleaseVersionInfo>;
  re::IntrospectionRegistry::add(this, v3);
  v14 = v16;
}

_QWORD *re::internal::defaultConstruct<re::PrereleaseVersionInfo>(_anonymous_namespace_ *a1, uint64_t a2, _OWORD *a3)
{
  _OWORD *v3;
  _anonymous_namespace_ *v4;

  v3 = a3;
  *a3 = 0u;
  a3[1] = 0u;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v3, 0);
  v3[2] = 0u;
  v3[3] = 0u;
  v3 += 2;
  return re::DynamicString::setCapacity(v3, 0);
}

double re::internal::defaultDestruct<re::PrereleaseVersionInfo>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  _OWORD *v5;
  double result;

  v5 = a3 + 4;
  v4 = a3[4];
  if (v4)
  {
    if ((a3[5] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, a3[6]);
    result = 0.0;
    *v5 = 0u;
    v5[1] = 0u;
  }
  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::PrereleaseVersionInfo>(_anonymous_namespace_ *a1)
{
  _anonymous_namespace_ *v1;
  _anonymous_namespace_ *v2;

  v1 = a1;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v1, 0);
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  v1 = (_anonymous_namespace_ *)((char *)v1 + 32);
  return re::DynamicString::setCapacity(v1, 0);
}

double re::internal::defaultDestructV2<re::PrereleaseVersionInfo>(_QWORD *a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;

  v3 = a1 + 4;
  v2 = a1[4];
  if (v2)
  {
    if ((a1[5] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, a1[6]);
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  if (*a1)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

uint64_t *re::allocInfo_PrereleaseSchemaVersion(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FBA50);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBA50))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FBE68, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540FBE78 = 0;
    qword_2540FBE88 = 0;
    qword_2540FBE90 = 0xFFFFFFFFLL;
    qword_2540FBE68 = (uint64_t)&off_24ED7DAA8;
    qword_2540FBE98 = (uint64_t)"PrereleaseSchemaVersion";
    dword_2540FBEA0 = 0;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    qword_2540FBED8 = 0;
    __cxa_guard_release(&qword_2540FBA50);
  }
  return &qword_2540FBE68;
}

void re::initInfo_PrereleaseSchemaVersion(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  __int128 v14;
  _QWORD v15[2];
  __int128 v16;

  v15[0] = 0xC639F5DA5C92FC66;
  v15[1] = "PrereleaseSchemaVersion";
  re::StringID::destroyString((re::StringID *)v15);
  *((_OWORD *)this + 2) = v16;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FBA58);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FBA58);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicString>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "id";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FBB80 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_int((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "sdk";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x2000000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540FBB88 = v13;
      __cxa_guard_release(&qword_2540FBA58);
    }
  }
  *((_QWORD *)this + 2) = 0x2800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_2540FBB80;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::PrereleaseSchemaVersion>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::PrereleaseSchemaVersion>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::PrereleaseSchemaVersion>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::PrereleaseSchemaVersion>;
  re::IntrospectionRegistry::add(this, v3);
  v14 = v16;
}

_QWORD *re::internal::defaultConstruct<re::PrereleaseSchemaVersion>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  return re::DynamicString::setCapacity((_QWORD *)a3, 0);
}

double re::internal::defaultDestruct<re::PrereleaseSchemaVersion>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;

  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::PrereleaseSchemaVersion>(_anonymous_namespace_ *a1)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  return re::DynamicString::setCapacity(a1, 0);
}

double re::internal::defaultDestructV2<re::PrereleaseSchemaVersion>(uint64_t *a1)
{
  uint64_t v2;
  double result;

  v2 = *a1;
  if (v2)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

uint64_t *re::allocInfo_PrereleaseHeader(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FBA68);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBA68))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FBEE0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540FBEF0 = 0;
    qword_2540FBF00 = 0;
    qword_2540FBF08 = 0xFFFFFFFFLL;
    qword_2540FBEE0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FBF10 = (uint64_t)"PrereleaseHeader";
    dword_2540FBF18 = 0;
    xmmword_2540FBF20 = 0u;
    xmmword_2540FBF30 = 0u;
    xmmword_2540FBF40 = 0u;
    qword_2540FBF50 = 0;
    __cxa_guard_release(&qword_2540FBA68);
  }
  return &qword_2540FBEE0;
}

void re::initInfo_PrereleaseHeader(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  re::IntrospectionBase *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  re::IntrospectionBase *v14;
  uint64_t v15;
  uint64_t *v16;
  const re::IntrospectionBase *v17;
  void *v18;
  uint64_t v19;
  __int128 v20;
  _QWORD v21[2];
  __int128 v22;

  v21[0] = 0xDD9D25828C678FA2;
  v21[1] = "PrereleaseHeader";
  re::StringID::destroyString((re::StringID *)v21);
  *((_OWORD *)this + 2) = v22;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FBA70);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FBA70);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v7 = v6;
      v8 = (uint64_t *)qword_2540FBA60;
      if (!qword_2540FBA60)
      {
        v8 = re::allocInfo_PrereleaseSchemaVersion((re *)v6);
        qword_2540FBA60 = (uint64_t)v8;
        re::initInfo_PrereleaseSchemaVersion((re *)v8, v9);
      }
      v10 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v7 + 32))(v7, 72, 8);
      *(_DWORD *)v10 = 1;
      *(_QWORD *)(v10 + 8) = "schemaVersion";
      *(_QWORD *)(v10 + 16) = v8;
      *(_QWORD *)(v10 + 24) = 0;
      *(_QWORD *)(v10 + 32) = 0x1800000001;
      *(_DWORD *)(v10 + 40) = 0;
      *(_QWORD *)(v10 + 48) = 0;
      *(_QWORD *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_2540FBBB0 = v10;
      v11 = re::introspectionAllocator((re *)v10);
      v12 = v11;
      v13 = (uint64_t *)qword_2540FBA48;
      if (!qword_2540FBA48)
      {
        v13 = re::allocInfo_PrereleaseVersionInfo((re *)v11);
        qword_2540FBA48 = (uint64_t)v13;
        re::initInfo_PrereleaseVersionInfo((re *)v13, v14);
      }
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "versionInfo";
      *(_QWORD *)(v15 + 16) = v13;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x4000000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FBBB8 = v15;
      v16 = re::introspectionAllocator((re *)v15);
      v18 = re::IntrospectionInfo<re::DynamicString>::get(1, v17);
      v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 72, 8);
      *(_DWORD *)v19 = 1;
      *(_QWORD *)(v19 + 8) = "identifier";
      *(_QWORD *)(v19 + 16) = v18;
      *(_QWORD *)(v19 + 24) = 0;
      *(_QWORD *)(v19 + 32) = 0x8000000003;
      *(_DWORD *)(v19 + 40) = 0;
      *(_QWORD *)(v19 + 48) = 0;
      *(_QWORD *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_2540FBBC0 = v19;
      __cxa_guard_release(&qword_2540FBA70);
    }
  }
  *((_QWORD *)this + 2) = 0xA000000008;
  *((_DWORD *)this + 6) = 8;
  *((_DWORD *)this + 14) = 3;
  *((_QWORD *)this + 8) = &qword_2540FBBB0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::PrereleaseHeader>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::PrereleaseHeader>;
  *((_QWORD *)this + 11) = re::internal::defaultRetain<re::PrereleaseHeader>(void)::{lambda(void *)#1}::__invoke;
  *((_WORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = re::internal::defaultRelease<re::PrereleaseHeader>(void)::{lambda(void *)#1}::__invoke;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::PrereleaseHeader>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::PrereleaseHeader>;
  re::IntrospectionRegistry::add(this, v3);
  v20 = v22;
}

uint64_t re::internal::defaultConstruct<re::PrereleaseHeader>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return re::make::shared::unsafelyInplace<re::PrereleaseHeader>(a3);
}

uint64_t re::internal::defaultDestruct<re::PrereleaseHeader>(uint64_t a1, uint64_t a2, uint64_t (***a3)(_QWORD))
{
  return (**a3)(a3);
}

uint64_t re::internal::defaultDestructV2<re::PrereleaseHeader>(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

_QWORD *re::internal::defaultConstruct<re::SceneCompatibilityVariant>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;

  *(_OWORD *)(a3 + 8) = 0u;
  v3 = (_QWORD *)(a3 + 8);
  *(_OWORD *)(a3 + 24) = 0u;
  return re::DynamicString::setCapacity(v3, 0);
}

double re::internal::defaultDestruct<re::SceneCompatibilityVariant>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _OWORD *v4;
  double result;

  v4 = (_OWORD *)(a3 + 8);
  v3 = *(_QWORD *)(a3 + 8);
  if (v3)
  {
    if ((*(_BYTE *)(a3 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a3 + 24));
    result = 0.0;
    *v4 = 0u;
    v4[1] = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::SceneCompatibilityVariant>(uint64_t a1)
{
  _QWORD *v1;

  *(_OWORD *)(a1 + 8) = 0u;
  v1 = (_QWORD *)(a1 + 8);
  *(_OWORD *)(a1 + 24) = 0u;
  return re::DynamicString::setCapacity(v1, 0);
}

double re::internal::defaultDestructV2<re::SceneCompatibilityVariant>(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;

  v3 = (_OWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 24));
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  return result;
}

uint64_t *re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionOptionalBase::IntrospectionOptionalBase((re::IntrospectionOptionalBase *)&re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::info);
    re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::info = (uint64_t)&off_24ED2D898;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::IntrospectionInfo<re::DynamicString>::get(1, a2);
  if (re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::info, 0);
    qword_255800468 = 0x280000000DLL;
    dword_255800470 = v11;
    word_255800474 = 0;
    *(_QWORD *)&xmmword_255800478 = 0;
    *((_QWORD *)&xmmword_255800478 + 1) = 0xFFFFFFFFLL;
    qword_255800488 = v10;
    unk_255800490 = 0;
    re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::info = (uint64_t)&off_24ED2D898;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_255800478 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(BOOL)::info;
}

void re::IntrospectionInfo<re::DynamicArray<re::SceneCompatibilityVariant>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24[2];
  __int128 v25;
  const char *v26;
  __int128 v27;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FBB50);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBB50))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540FBCA8);
    qword_2540FBCA8 = (uint64_t)&off_24ED2D918;
    __cxa_guard_release(&qword_2540FBB50);
  }
  if ((byte_2540FBA31 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540FBA90;
    if (qword_2540FBA90)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540FBA80);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBA80))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FBF58, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540FBF68 = 0;
      *(_QWORD *)&xmmword_2540FBF78 = 0;
      *((_QWORD *)&xmmword_2540FBF78 + 1) = 0xFFFFFFFFLL;
      qword_2540FBF58 = (uint64_t)&off_24ED7DAA8;
      qword_2540FBF88 = (uint64_t)"SceneCompatibilityVariant";
      dword_2540FBF90 = 0;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      qword_2540FBFC8 = 0;
      __cxa_guard_release(&qword_2540FBA80);
    }
    qword_2540FBA90 = (uint64_t)&qword_2540FBF58;
    *(_QWORD *)&v27 = 0x181C570854B9A702;
    *((_QWORD *)&v27 + 1) = "SceneCompatibilityVariant";
    re::StringID::destroyString((re::StringID *)&v27);
    xmmword_2540FBF78 = v25;
    v4 = atomic_load((unsigned __int8 *)&qword_2540FBA88);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540FBA88);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::introspect_int((re *)1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "version";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 1;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_2540FBB90 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::IntrospectionInfo<re::DynamicString>::get(1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "fileName";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x800000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540FBB98 = v21;
        __cxa_guard_release(&qword_2540FBA88);
      }
    }
    qword_2540FBF68 = 0x2800000008;
    v1 = &qword_2540FBF58;
    dword_2540FBF70 = 8;
    word_2540FBF74 = 0;
    dword_2540FBF90 = 2;
    qword_2540FBF98 = (uint64_t)&qword_2540FBB90;
    qword_2540FBFA0 = (uint64_t)re::internal::defaultConstruct<re::SceneCompatibilityVariant>;
    qword_2540FBFA8 = (uint64_t)re::internal::defaultDestruct<re::SceneCompatibilityVariant>;
    qword_2540FBFB8 = 0;
    qword_2540FBFB0 = 0;
    qword_2540FBFC0 = (uint64_t)re::internal::defaultConstructV2<re::SceneCompatibilityVariant>;
    qword_2540FBFC8 = (uint64_t)re::internal::defaultDestructV2<re::SceneCompatibilityVariant>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FBF58, v3);
    v27 = v25;
    if ((byte_2540FBA31 & 1) == 0)
    {
LABEL_7:
      byte_2540FBA31 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FBCA8, 0);
      qword_2540FBCB8 = 0x2800000003;
      dword_2540FBCC0 = v5;
      word_2540FBCC4 = 0;
      *(_QWORD *)&xmmword_2540FBCC8 = 0;
      *((_QWORD *)&xmmword_2540FBCC8 + 1) = 0xFFFFFFFFLL;
      qword_2540FBCD8 = (uint64_t)v1;
      qword_2540FBCE0 = 0;
      qword_2540FBCA8 = (uint64_t)&off_24ED2D918;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540FBCA8, (const re::IntrospectionBase *)&v25);
      if ((BYTE8(v25) & 1) != 0)
        v8 = v26;
      else
        v8 = (char *)&v25 + 9;
      if ((_QWORD)v25 && (BYTE8(v25) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v25 + 40))();
      v23 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v24);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v22 + 1) = v10;
      }
      else
      {
        v27 = v23;
        re::TypeBuilder::beginListType((uint64_t)&v25, v24, 1, 0x28uLL, 8uLL, &v27);
        re::TypeBuilder::setConstructor((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v25, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v25, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v25, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v25, v11);
      }
      xmmword_2540FBCC8 = v22;
      re::StringID::destroyString((re::StringID *)v24);
    }
  }
}

re::SceneDescriptor *re::internal::defaultConstruct<re::SceneDescriptor>(int a1, int a2, re::SceneDescriptor *this)
{
  *((_QWORD *)this + 24) = 0;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return re::SceneDescriptor::SceneDescriptor(this);
}

uint64_t re::internal::defaultDestruct<re::SceneDescriptor>(uint64_t a1, uint64_t a2, uint64_t (***a3)(_QWORD))
{
  return (**a3)(a3);
}

re::SceneDescriptor *re::internal::defaultConstructV2<re::SceneDescriptor>(re::SceneDescriptor *this)
{
  *((_QWORD *)this + 24) = 0;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return re::SceneDescriptor::SceneDescriptor(this);
}

uint64_t re::internal::defaultDestructV2<re::SceneDescriptor>(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::info = (uint64_t)&off_24ED2D9B0;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::IntrospectionInfo<re::DynamicString>::get(1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::info, 0);
    qword_2558004B8 = 0x2800000003;
    dword_2558004C0 = v11;
    word_2558004C4 = 0;
    *(_QWORD *)&xmmword_2558004C8 = 0;
    *((_QWORD *)&xmmword_2558004C8 + 1) = 0xFFFFFFFFLL;
    qword_2558004D8 = v10;
    unk_2558004E0 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::info = (uint64_t)&off_24ED2D9B0;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_2558004C8 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  _OWORD *v7;
  const re::IntrospectionBase *v8;
  re *v9;
  std::__shared_mutex_base *v10;
  uint64_t v12;
  int v13;
  re::IntrospectionRegistry *v14;
  const re::IntrospectionBase *v15;
  const char *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  const char *v21;
  uint64_t v22[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionHashTableBase::IntrospectionHashTableBase((re::IntrospectionHashTableBase *)&re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::info);
    re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::info = (uint64_t)&off_24ED2DA48;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    v4 = re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    if (v4)
      return &re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = re::IntrospectionInfo<re::StringID>::get(1, a2);
  v9 = (re *)re::IntrospectionInfo<re::DynamicString>::get(1, v8);
  if (re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v10 = re::introspectionSharedMutex(v9);
      std::__shared_mutex_base::unlock(v10);
    }
  }
  else
  {
    v12 = (uint64_t)v9;
    re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::isInitialized = 1;
    v13 = *((_DWORD *)v9 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::info, 0);
    qword_255800508 = 0x3000000007;
    dword_255800510 = v13;
    word_255800514 = 0;
    *(_QWORD *)&xmmword_255800518 = 0;
    *((_QWORD *)&xmmword_255800518 + 1) = 0xFFFFFFFFLL;
    qword_255800528 = (uint64_t)v7;
    unk_255800530 = 0;
    qword_255800538 = v12;
    unk_255800540 = 0;
    re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::info = (uint64_t)&off_24ED2DA48;
    re::IntrospectionRegistry::add(v14, v15);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::info, (const re::IntrospectionBase *)&v20);
    if ((BYTE8(v20) & 1) != 0)
      v16 = v21;
    else
      v16 = (char *)&v20 + 9;
    if ((_QWORD)v20 && (BYTE8(v20) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v20 + 40))();
    v17 = v7[2];
    v19 = *(_OWORD *)(v12 + 32);
    v20 = v17;
    xmmword_255800518 = v18;
    re::StringID::destroyString((re::StringID *)v22);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::AssetMapAssetDescriptor>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 72) = 0;
  *(_BYTE *)(a3 + 80) = 0;
  *(_OWORD *)(a3 + 120) = 0u;
  *(_OWORD *)(a3 + 136) = 0u;
  *(_DWORD *)(a3 + 152) = 0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_QWORD *)&result = 0x7FFFFFFFLL;
  *(_QWORD *)(a3 + 156) = 0x7FFFFFFFLL;
  return result;
}

uint64_t re::internal::defaultDestruct<re::AssetMapAssetDescriptor>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 v4;
  uint64_t v5;
  uint64_t v6;

  v4.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(a3 + 120));
  if (*(_BYTE *)(a3 + 80))
  {
    v5 = *(_QWORD *)(a3 + 88);
    if (v5)
    {
      if ((*(_BYTE *)(a3 + 96) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a3 + 104), v4.n128_f64[0]);
      v4 = 0uLL;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
    }
  }
  v6 = *(_QWORD *)(a3 + 40);
  if (v6)
  {
    if (*(_QWORD *)(a3 + 72))
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v6 + 40))(v6, v4);
    *(_QWORD *)(a3 + 72) = 0;
    *(_QWORD *)(a3 + 48) = 0;
    *(_QWORD *)(a3 + 56) = 0;
    *(_QWORD *)(a3 + 40) = 0;
    ++*(_DWORD *)(a3 + 64);
  }
  return re::DynamicArray<re::DynamicString>::deinit(a3);
}

double re::internal::defaultConstructV2<re::AssetMapAssetDescriptor>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_DWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)&result = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 156) = 0x7FFFFFFFLL;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::AssetMapAssetDescriptor>(uint64_t a1)
{
  __n128 v2;
  uint64_t v3;
  uint64_t v4;

  v2.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(a1 + 120));
  if (*(_BYTE *)(a1 + 80))
  {
    v3 = *(_QWORD *)(a1 + 88);
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 104), v2.n128_f64[0]);
      v2 = 0uLL;
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
    }
  }
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 72))
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v4 + 40))(v4, v2);
    *(_QWORD *)(a1 + 72) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    ++*(_DWORD *)(a1 + 64);
  }
  return re::DynamicArray<re::DynamicString>::deinit(a1);
}

uint64_t *re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionFixedArrayBase::IntrospectionFixedArrayBase((re::IntrospectionFixedArrayBase *)&re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::info);
    re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::info = (uint64_t)&off_24ED2DAE8;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::IntrospectionInfo<re::DynamicString>::get(1, a2);
  if (re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::info, 0);
    qword_255800568 = 0x1800000004;
    dword_255800570 = v11;
    word_255800574 = 0;
    *(_QWORD *)&xmmword_255800578 = 0;
    *((_QWORD *)&xmmword_255800578 + 1) = 0xFFFFFFFFLL;
    qword_255800588 = v10;
    unk_255800590 = 0;
    re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::info = (uint64_t)&off_24ED2DAE8;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_255800578 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(BOOL)::info;
}

void re::internal::defaultConstruct<re::RealityFileConfigurationEntryDescriptor>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
}

_QWORD *re::internal::defaultDestruct<re::RealityFileConfigurationEntryDescriptor>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return re::FixedArray<re::DynamicString>::deinit((_QWORD *)(a3 + 8));
}

_QWORD *re::internal::defaultConstructV2<re::RealityFileConfigurationEntryDescriptor>(_QWORD *result)
{
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

_QWORD *re::internal::defaultDestructV2<re::RealityFileConfigurationEntryDescriptor>(uint64_t a1)
{
  return re::FixedArray<re::DynamicString>::deinit((_QWORD *)(a1 + 8));
}

uint64_t *re::allocInfo_AssetMap(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FBAE0);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBAE0))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC138, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540FC148 = 0;
    qword_2540FC158 = 0;
    qword_2540FC160 = 0xFFFFFFFFLL;
    qword_2540FC138 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC168 = (uint64_t)"AssetMap";
    dword_2540FC170 = 0;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    qword_2540FC1A8 = 0;
    __cxa_guard_release(&qword_2540FBAE0);
  }
  return &qword_2540FC138;
}

void re::initInfo_AssetMap(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  const re::IntrospectionBase *v21;
  uint64_t *v22;
  uint64_t v23;
  __int128 v24;
  _QWORD v25[2];
  __int128 v26;

  v25[0] = 0x371DB3700D8;
  v25[1] = "AssetMap";
  re::StringID::destroyString((re::StringID *)v25);
  *((_OWORD *)this + 2) = v26;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FBAE8);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FBAE8);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<re::DynamicArray<re::SceneDescriptor>>::get();
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "scenes";
      *(_QWORD *)(v7 + 16) = &qword_2540FBCE8;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 0x1800000001;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FBC48 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      re::IntrospectionInfo<re::DynamicArray<re::AssetMapAssetDescriptor>>::get();
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "assets";
      *(_QWORD *)(v9 + 16) = &qword_2540FBD28;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0x4000000002;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FBC50 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_BOOL((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "certifiedFreeOfChangeSceneActions";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x6800000003;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540FBC58 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v16 = re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(1, v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = "configurationSetNames";
      *(_QWORD *)(v17 + 16) = v16;
      *(_QWORD *)(v17 + 24) = 0;
      *(_QWORD *)(v17 + 32) = 0x7000000004;
      *(_DWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_2540FBC60 = v17;
      v18 = re::introspectionAllocator((re *)v17);
      re::IntrospectionInfo<re::FixedArray<re::RealityFileConfigurationEntryDescriptor>>::get();
      v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
      *(_DWORD *)v19 = 1;
      *(_QWORD *)(v19 + 8) = "configurationEntryDescriptors";
      *(_QWORD *)(v19 + 16) = &qword_2540FBD68;
      *(_QWORD *)(v19 + 24) = 0;
      *(_QWORD *)(v19 + 32) = 0xA000000005;
      *(_DWORD *)(v19 + 40) = 0;
      *(_QWORD *)(v19 + 48) = 0;
      *(_QWORD *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_2540FBC68 = v19;
      v20 = re::introspectionAllocator((re *)v19);
      v22 = re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(1, v21);
      v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v20 + 32))(v20, 72, 8);
      *(_DWORD *)v23 = 1;
      *(_QWORD *)(v23 + 8) = "defaultConfigurationNames";
      *(_QWORD *)(v23 + 16) = v22;
      *(_QWORD *)(v23 + 24) = 0;
      *(_QWORD *)(v23 + 32) = 0x8800000006;
      *(_DWORD *)(v23 + 40) = 0;
      *(_QWORD *)(v23 + 48) = 0;
      *(_QWORD *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_2540FBC70 = v23;
      __cxa_guard_release(&qword_2540FBAE8);
    }
  }
  *((_QWORD *)this + 2) = 0x1B800000008;
  *((_DWORD *)this + 6) = 8;
  *((_DWORD *)this + 14) = 6;
  *((_QWORD *)this + 8) = &qword_2540FBC48;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::AssetMap>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::AssetMap>;
  *((_QWORD *)this + 11) = re::internal::defaultRetain<re::AssetMap>(void)::{lambda(void *)#1}::__invoke;
  *((_WORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = re::internal::defaultRelease<re::AssetMap>(void)::{lambda(void *)#1}::__invoke;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::AssetMap>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::AssetMap>;
  re::IntrospectionRegistry::add(this, v3);
  v24 = v26;
}

void re::IntrospectionInfo<re::DynamicArray<re::SceneDescriptor>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  uint64_t *v22;
  const re::IntrospectionBase *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30[2];
  __int128 v31;
  const char *v32;
  __int128 v33;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FBB58);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBB58))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540FBCE8);
    qword_2540FBCE8 = (uint64_t)&off_24ED2DB80;
    __cxa_guard_release(&qword_2540FBB58);
  }
  if ((byte_2540FBA32 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540FBAA8;
    if (qword_2540FBAA8)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540FBA98);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBA98))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FBFD0, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540FBFE0 = 0;
      *(_QWORD *)&xmmword_2540FBFF0 = 0;
      *((_QWORD *)&xmmword_2540FBFF0 + 1) = 0xFFFFFFFFLL;
      qword_2540FBFD0 = (uint64_t)&off_24ED7DAA8;
      qword_2540FC000 = (uint64_t)"SceneDescriptor";
      dword_2540FC008 = 0;
      xmmword_2540FC010 = 0u;
      xmmword_2540FC020 = 0u;
      xmmword_2540FC030 = 0u;
      qword_2540FC040 = 0;
      __cxa_guard_release(&qword_2540FBA98);
    }
    qword_2540FBAA8 = (uint64_t)&qword_2540FBFD0;
    *(_QWORD *)&v33 = 0xABFCACCDD6C081F6;
    *((_QWORD *)&v33 + 1) = "SceneDescriptor";
    re::StringID::destroyString((re::StringID *)&v33);
    xmmword_2540FBFF0 = v31;
    v4 = atomic_load((unsigned __int8 *)&qword_2540FBAA0);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540FBAA0);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::IntrospectionInfo<re::DynamicString>::get(1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "fileName";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 0x1800000001;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_2540FBBE0 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::IntrospectionInfo<re::DynamicString>::get(1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "sceneName";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x3800000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540FBBE8 = v21;
        v22 = re::introspectionAllocator((re *)v21);
        v24 = re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(1, v23);
        v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
        *(_DWORD *)v25 = 1;
        *(_QWORD *)(v25 + 8) = "sceneIdentifier";
        *(_QWORD *)(v25 + 16) = v24;
        *(_QWORD *)(v25 + 24) = 0;
        *(_QWORD *)(v25 + 32) = 0x5800000003;
        *(_DWORD *)(v25 + 40) = 0;
        *(_QWORD *)(v25 + 48) = 0;
        *(_QWORD *)(v25 + 56) = 0;
        *(_DWORD *)(v25 + 64) = 0;
        qword_2540FBBF0 = v25;
        v26 = re::introspectionAllocator((re *)v25);
        re::IntrospectionInfo<re::DynamicArray<re::SceneCompatibilityVariant>>::get();
        v27 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v26 + 32))(v26, 72, 8);
        *(_DWORD *)v27 = 1;
        *(_QWORD *)(v27 + 8) = "sceneCompatibilityVariants";
        *(_QWORD *)(v27 + 16) = &qword_2540FBCA8;
        *(_QWORD *)(v27 + 24) = 0;
        *(_QWORD *)(v27 + 32) = 0xA000000004;
        *(_DWORD *)(v27 + 40) = 0;
        *(_QWORD *)(v27 + 48) = 0;
        *(_QWORD *)(v27 + 56) = 0;
        *(_DWORD *)(v27 + 64) = 0;
        qword_2540FBBF8 = v27;
        __cxa_guard_release(&qword_2540FBAA0);
      }
    }
    qword_2540FBFE0 = 0xC800000008;
    v1 = &qword_2540FBFD0;
    dword_2540FBFE8 = 8;
    word_2540FBFEC = 0;
    dword_2540FC008 = 4;
    *(_QWORD *)&xmmword_2540FC010 = &qword_2540FBBE0;
    *((_QWORD *)&xmmword_2540FC010 + 1) = re::internal::defaultConstruct<re::SceneDescriptor>;
    *(_QWORD *)&xmmword_2540FC020 = re::internal::defaultDestruct<re::SceneDescriptor>;
    *((_QWORD *)&xmmword_2540FC020 + 1) = re::internal::defaultRetain<re::SceneDescriptor>(void)::{lambda(void *)#1}::__invoke;
    *(_QWORD *)&xmmword_2540FC030 = re::internal::defaultRelease<re::SceneDescriptor>(void)::{lambda(void *)#1}::__invoke;
    *((_QWORD *)&xmmword_2540FC030 + 1) = re::internal::defaultConstructV2<re::SceneDescriptor>;
    qword_2540FC040 = (uint64_t)re::internal::defaultDestructV2<re::SceneDescriptor>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FBFD0, v3);
    v33 = v31;
    if ((byte_2540FBA32 & 1) == 0)
    {
LABEL_7:
      byte_2540FBA32 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FBCE8, 0);
      qword_2540FBCF8 = 0x2800000003;
      dword_2540FBD00 = v5;
      word_2540FBD04 = 0;
      *(_QWORD *)&xmmword_2540FBD08 = 0;
      *((_QWORD *)&xmmword_2540FBD08 + 1) = 0xFFFFFFFFLL;
      qword_2540FBD18 = (uint64_t)v1;
      qword_2540FBD20 = 0;
      qword_2540FBCE8 = (uint64_t)&off_24ED2DB80;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540FBCE8, (const re::IntrospectionBase *)&v31);
      if ((BYTE8(v31) & 1) != 0)
        v8 = v32;
      else
        v8 = (char *)&v31 + 9;
      if ((_QWORD)v31 && (BYTE8(v31) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v31 + 40))();
      v29 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v30);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v28 + 1) = v10;
      }
      else
      {
        v33 = v29;
        re::TypeBuilder::beginListType((uint64_t)&v31, v30, 1, 0x28uLL, 8uLL, &v33);
        re::TypeBuilder::setConstructor((uint64_t)&v31, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v31, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v31, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v31, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v31, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v31, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v31, v11);
      }
      xmmword_2540FBD08 = v28;
      re::StringID::destroyString((re::StringID *)v30);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::AssetMapAssetDescriptor>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  const re::IntrospectionBase *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  const re::IntrospectionBase *v27;
  uint64_t *v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32[2];
  __int128 v33;
  const char *v34;
  __int128 v35;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FBB60);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBB60))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540FBD28);
    qword_2540FBD28 = (uint64_t)&off_24ED2DC18;
    __cxa_guard_release(&qword_2540FBB60);
  }
  if ((byte_2540FBA33 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540FBAC0;
    if (qword_2540FBAC0)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540FBAB0);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBAB0))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC048, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540FC058 = 0;
      *(_QWORD *)&xmmword_2540FC068 = 0;
      *((_QWORD *)&xmmword_2540FC068 + 1) = 0xFFFFFFFFLL;
      qword_2540FC048 = (uint64_t)&off_24ED7DAA8;
      qword_2540FC078 = (uint64_t)"AssetMapAssetDescriptor";
      dword_2540FC080 = 0;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      qword_2540FC0B8 = 0;
      __cxa_guard_release(&qword_2540FBAB0);
    }
    qword_2540FBAC0 = (uint64_t)&qword_2540FC048;
    *(_QWORD *)&v35 = 0xF2989CE2313F00E6;
    *((_QWORD *)&v35 + 1) = "AssetMapAssetDescriptor";
    re::StringID::destroyString((re::StringID *)&v35);
    xmmword_2540FC068 = v33;
    v4 = atomic_load((unsigned __int8 *)&qword_2540FBAB8);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540FBAB8);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "fileNames";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 1;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_2540FBC00 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "internalDependencies";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x2800000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540FBC08 = v21;
        v22 = re::introspectionAllocator((re *)v21);
        v24 = re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(1, v23);
        v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
        *(_DWORD *)v25 = 1;
        *(_QWORD *)(v25 + 8) = "label";
        *(_QWORD *)(v25 + 16) = v24;
        *(_QWORD *)(v25 + 24) = 0;
        *(_QWORD *)(v25 + 32) = 0x5000000003;
        *(_DWORD *)(v25 + 40) = 0;
        *(_QWORD *)(v25 + 48) = 0;
        *(_QWORD *)(v25 + 56) = 0;
        *(_DWORD *)(v25 + 64) = 0;
        qword_2540FBC10 = v25;
        v26 = re::introspectionAllocator((re *)v25);
        v28 = re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(1, v27);
        v29 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v26 + 32))(v26, 72, 8);
        *(_DWORD *)v29 = 1;
        *(_QWORD *)(v29 + 8) = "metadata";
        *(_QWORD *)(v29 + 16) = v28;
        *(_QWORD *)(v29 + 24) = 0;
        *(_QWORD *)(v29 + 32) = 0x7800000004;
        *(_DWORD *)(v29 + 40) = 0;
        *(_QWORD *)(v29 + 48) = 0;
        *(_QWORD *)(v29 + 56) = 0;
        *(_DWORD *)(v29 + 64) = 0;
        qword_2540FBC18 = v29;
        __cxa_guard_release(&qword_2540FBAB8);
      }
    }
    qword_2540FC058 = 0xA800000008;
    v1 = &qword_2540FC048;
    dword_2540FC060 = 8;
    word_2540FC064 = 0;
    dword_2540FC080 = 4;
    qword_2540FC088 = (uint64_t)&qword_2540FBC00;
    qword_2540FC090 = (uint64_t)re::internal::defaultConstruct<re::AssetMapAssetDescriptor>;
    qword_2540FC098 = (uint64_t)re::internal::defaultDestruct<re::AssetMapAssetDescriptor>;
    qword_2540FC0A8 = 0;
    qword_2540FC0A0 = 0;
    qword_2540FC0B0 = (uint64_t)re::internal::defaultConstructV2<re::AssetMapAssetDescriptor>;
    qword_2540FC0B8 = (uint64_t)re::internal::defaultDestructV2<re::AssetMapAssetDescriptor>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FC048, v3);
    v35 = v33;
    if ((byte_2540FBA33 & 1) == 0)
    {
LABEL_7:
      byte_2540FBA33 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FBD28, 0);
      qword_2540FBD38 = 0x2800000003;
      dword_2540FBD40 = v5;
      word_2540FBD44 = 0;
      *(_QWORD *)&xmmword_2540FBD48 = 0;
      *((_QWORD *)&xmmword_2540FBD48 + 1) = 0xFFFFFFFFLL;
      qword_2540FBD58 = (uint64_t)v1;
      qword_2540FBD60 = 0;
      qword_2540FBD28 = (uint64_t)&off_24ED2DC18;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540FBD28, (const re::IntrospectionBase *)&v33);
      if ((BYTE8(v33) & 1) != 0)
        v8 = v34;
      else
        v8 = (char *)&v33 + 9;
      if ((_QWORD)v33 && (BYTE8(v33) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v33 + 40))();
      v31 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v32);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v30 + 1) = v10;
      }
      else
      {
        v35 = v31;
        re::TypeBuilder::beginListType((uint64_t)&v33, v32, 1, 0x28uLL, 8uLL, &v35);
        re::TypeBuilder::setConstructor((uint64_t)&v33, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v33, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v33, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v33, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v33, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v33, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v33, v11);
      }
      xmmword_2540FBD48 = v30;
      re::StringID::destroyString((re::StringID *)v32);
    }
  }
}

void re::IntrospectionInfo<re::FixedArray<re::RealityFileConfigurationEntryDescriptor>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  uint64_t *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24[2];
  __int128 v25;
  const char *v26;
  __int128 v27;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FBB68);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBB68))
  {
    re::IntrospectionFixedArrayBase::IntrospectionFixedArrayBase((re::IntrospectionFixedArrayBase *)&qword_2540FBD68);
    qword_2540FBD68 = (uint64_t)&off_24ED2DCB0;
    __cxa_guard_release(&qword_2540FBB68);
  }
  if ((byte_2540FBA34 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540FBAD8;
    if (qword_2540FBAD8)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540FBAC8);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBAC8))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC0C0, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540FC0D0 = 0;
      *(_QWORD *)&xmmword_2540FC0E0 = 0;
      *((_QWORD *)&xmmword_2540FC0E0 + 1) = 0xFFFFFFFFLL;
      qword_2540FC0C0 = (uint64_t)&off_24ED7DAA8;
      qword_2540FC0F0 = (uint64_t)"RealityFileConfigurationEntryDescriptor";
      dword_2540FC0F8 = 0;
      xmmword_2540FC100 = 0u;
      xmmword_2540FC110 = 0u;
      xmmword_2540FC120 = 0u;
      qword_2540FC130 = 0;
      __cxa_guard_release(&qword_2540FBAC8);
    }
    qword_2540FBAD8 = (uint64_t)&qword_2540FC0C0;
    *(_QWORD *)&v27 = 0x45B4E41531619F2ELL;
    *((_QWORD *)&v27 + 1) = "RealityFileConfigurationEntryDescriptor";
    re::StringID::destroyString((re::StringID *)&v27);
    xmmword_2540FC0E0 = v25;
    v4 = atomic_load((unsigned __int8 *)&qword_2540FBAD0);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540FBAD0);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::introspect_size_t((re *)1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "assetIndex";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 1;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_2540FBBA0 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::IntrospectionInfo<re::FixedArray<re::DynamicString>>::get(1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "configurations";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x800000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540FBBA8 = v21;
        __cxa_guard_release(&qword_2540FBAD0);
      }
    }
    qword_2540FC0D0 = 0x2000000008;
    v1 = &qword_2540FC0C0;
    dword_2540FC0D8 = 8;
    word_2540FC0DC = 0;
    dword_2540FC0F8 = 2;
    *(_QWORD *)&xmmword_2540FC100 = &qword_2540FBBA0;
    *((_QWORD *)&xmmword_2540FC100 + 1) = re::internal::defaultConstruct<re::RealityFileConfigurationEntryDescriptor>;
    *(_QWORD *)&xmmword_2540FC110 = re::internal::defaultDestruct<re::RealityFileConfigurationEntryDescriptor>;
    *(_QWORD *)&xmmword_2540FC120 = 0;
    *((_QWORD *)&xmmword_2540FC110 + 1) = 0;
    *((_QWORD *)&xmmword_2540FC120 + 1) = re::internal::defaultConstructV2<re::RealityFileConfigurationEntryDescriptor>;
    qword_2540FC130 = (uint64_t)re::internal::defaultDestructV2<re::RealityFileConfigurationEntryDescriptor>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FC0C0, v3);
    v27 = v25;
    if ((byte_2540FBA34 & 1) == 0)
    {
LABEL_7:
      byte_2540FBA34 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FBD68, 0);
      qword_2540FBD78 = 0x1800000004;
      dword_2540FBD80 = v5;
      word_2540FBD84 = 0;
      *(_QWORD *)&xmmword_2540FBD88 = 0;
      *((_QWORD *)&xmmword_2540FBD88 + 1) = 0xFFFFFFFFLL;
      qword_2540FBD98 = (uint64_t)v1;
      qword_2540FBDA0 = 0;
      qword_2540FBD68 = (uint64_t)&off_24ED2DCB0;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540FBD68, (const re::IntrospectionBase *)&v25);
      if ((BYTE8(v25) & 1) != 0)
        v8 = v26;
      else
        v8 = (char *)&v25 + 9;
      if ((_QWORD)v25 && (BYTE8(v25) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v25 + 40))();
      v23 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v24);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v22 + 1) = v10;
      }
      else
      {
        v27 = v23;
        re::TypeBuilder::beginListType((uint64_t)&v25, v24, 1, 0x18uLL, 8uLL, &v27);
        re::TypeBuilder::setConstructor((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v25, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v25, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v25, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v25, v11);
      }
      xmmword_2540FBD88 = v22;
      re::StringID::destroyString((re::StringID *)v24);
    }
  }
}

double re::internal::defaultConstruct<re::AssetMap>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return re::make::shared::unsafelyInplace<re::AssetMap>(a3);
}

uint64_t re::internal::defaultDestruct<re::AssetMap>(uint64_t a1, uint64_t a2, uint64_t (***a3)(_QWORD))
{
  return (**a3)(a3);
}

uint64_t re::internal::defaultDestructV2<re::AssetMap>(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t re::introspect_AssetMap(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AssetMap", (uint64_t (*)(re::internal *))re::allocInfo_AssetMap, (re::IntrospectionBase *(*)(void))re::initInfo_AssetMap, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AssetMap>, this);
}

uint64_t *re::allocInfo_RealityFileVersionInfo(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FBAF0);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBAF0))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC1B0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540FC1C0 = 0;
    qword_2540FC1D0 = 0;
    qword_2540FC1D8 = 0xFFFFFFFFLL;
    qword_2540FC1B0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC1E0 = (uint64_t)"RealityFileVersionInfo";
    dword_2540FC1E8 = 0;
    xmmword_2540FC1F0 = 0u;
    xmmword_2540FC200 = 0u;
    xmmword_2540FC210 = 0u;
    qword_2540FC220 = 0;
    __cxa_guard_release(&qword_2540FBAF0);
  }
  return &qword_2540FC1B0;
}

void re::initInfo_RealityFileVersionInfo(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  uint64_t v16;
  __int128 v17;
  _QWORD v18[2];
  __int128 v19;

  v18[0] = 0x3B095B3399DAFC74;
  v18[1] = "RealityFileVersionInfo";
  re::StringID::destroyString((re::StringID *)v18);
  *((_OWORD *)this + 2) = v19;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FBAF8);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FBAF8);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicString>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "id";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FBBC8 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::IntrospectionInfo<re::DynamicString>::get(1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "frameworkVersion";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x2000000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540FBBD0 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      re::introspect_RealityFilePlatform((re *)v14, v15);
      v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v16 = 1;
      *(_QWORD *)(v16 + 8) = "originPlatform";
      *(_QWORD *)(v16 + 16) = &qword_2540FBDA8;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)(v16 + 32) = 0x4000000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 48) = 0;
      *(_QWORD *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_2540FBBD8 = v16;
      __cxa_guard_release(&qword_2540FBAF8);
    }
  }
  *((_QWORD *)this + 2) = 0x4800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((_QWORD *)this + 8) = &qword_2540FBBC8;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::RealityFileVersionInfo>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::RealityFileVersionInfo>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::RealityFileVersionInfo>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::RealityFileVersionInfo>;
  re::IntrospectionRegistry::add(this, v3);
  v17 = v19;
}

_QWORD *re::internal::defaultConstruct<re::RealityFileVersionInfo>(_anonymous_namespace_ *a1, uint64_t a2, _OWORD *a3)
{
  _OWORD *v3;
  _anonymous_namespace_ *v4;
  _QWORD *result;

  v3 = a3;
  *a3 = 0u;
  a3[1] = 0u;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v3, 0);
  v3[2] = 0u;
  v3[3] = 0u;
  v3 += 2;
  result = re::DynamicString::setCapacity(v3, 0);
  *((_DWORD *)v3 + 8) = 2;
  return result;
}

double re::internal::defaultDestruct<re::RealityFileVersionInfo>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  _OWORD *v5;
  double result;

  v5 = a3 + 4;
  v4 = a3[4];
  if (v4)
  {
    if ((a3[5] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, a3[6]);
    result = 0.0;
    *v5 = 0u;
    v5[1] = 0u;
  }
  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::RealityFileVersionInfo>(_anonymous_namespace_ *a1)
{
  _anonymous_namespace_ *v1;
  _anonymous_namespace_ *v2;
  _QWORD *result;

  v1 = a1;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v1, 0);
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  v1 = (_anonymous_namespace_ *)((char *)v1 + 32);
  result = re::DynamicString::setCapacity(v1, 0);
  *((_DWORD *)v1 + 8) = 2;
  return result;
}

double re::internal::defaultDestructV2<re::RealityFileVersionInfo>(_QWORD *a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;

  v3 = a1 + 4;
  v2 = a1[4];
  if (v2)
  {
    if ((a1[5] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, a1[6]);
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  if (*a1)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

void re::introspect_RealityFilePlatform(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  re *v34;
  uint64_t *v35;
  re *v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  StringID v42;
  _QWORD v43[2];
  _QWORD v44[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540FBB08);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540FBB08);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "RealityFilePlatformNone";
      qword_2540FBC78 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "RealityFilePlatformAll";
      qword_2540FBC80 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "RealityFilePlatformIOS";
      qword_2540FBC88 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *((_QWORD *)v34 + 1) = 3;
      *((_QWORD *)v34 + 2) = "RealityFilePlatformMacOS";
      qword_2540FBC90 = (uint64_t)v34;
      v35 = re::introspectionAllocator(v34);
      v36 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v35 + 32))(v35, 24, 8);
      *(_DWORD *)v36 = 1;
      *((_QWORD *)v36 + 1) = 4;
      *((_QWORD *)v36 + 2) = "RealityFilePlatformVisionOS";
      qword_2540FBC98 = (uint64_t)v36;
      v37 = re::introspectionAllocator(v36);
      v38 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v37 + 32))(v37, 24, 8);
      *(_DWORD *)v38 = 2;
      *(_QWORD *)(v38 + 8) = 4;
      *(_QWORD *)(v38 + 16) = "RealityFilePlatformXROS";
      qword_2540FBCA0 = v38;
      __cxa_guard_release(&qword_2540FBB08);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540FBB10);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBB10))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540FBDA8, "RealityFilePlatform", 4, 4, 1, 1);
    qword_2540FBDA8 = (uint64_t)&off_24ED7D9E8;
    qword_2540FBDE8 = (uint64_t)&re::introspect_RealityFilePlatform(BOOL)::enumTable;
    dword_2540FBDB8 = 9;
    __cxa_guard_release(&qword_2540FBB10);
  }
  if ((_MergedGlobals_47 & 1) == 0)
  {
    _MergedGlobals_47 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FBDA8, a2);
    v40 = 0xCED4E9B28AD038BELL;
    v41 = "RealityFilePlatform";
    v44[0] = 0x607DD0F01DCLL;
    v44[1] = "uint32_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v44);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v44);
      v6 = (unsigned int *)qword_2540FBDE8;
      v43[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v44, &v40, 1, 1, (uint64_t)v43);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v42.var0 = 2 * v12;
            v42.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v44, v16, &v42);
            re::StringID::destroyString((re::StringID *)&v42);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v42.var0 = 2 * v20;
              v42.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v44, v24, &v42);
              re::StringID::destroyString((re::StringID *)&v42);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v44, v25);
      xmmword_2540FBDC8 = (__int128)v42;
      re::StringID::destroyString((re::StringID *)&v40);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v44);
      re::internal::assertLog((re::internal *)5, v39, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RealityFilePlatform", v40, v41);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t *re::allocInfo_RealityFileHeader(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FBB18);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBB18))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC228, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540FC238 = 0;
    qword_2540FC248 = 0;
    qword_2540FC250 = 0xFFFFFFFFLL;
    qword_2540FC228 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC258 = (uint64_t)"RealityFileHeader";
    dword_2540FC260 = 0;
    xmmword_2540FC268 = 0u;
    xmmword_2540FC278 = 0u;
    xmmword_2540FC288 = 0u;
    qword_2540FC298 = 0;
    __cxa_guard_release(&qword_2540FBB18);
  }
  return &qword_2540FC228;
}

void re::initInfo_RealityFileHeader(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  re::IntrospectionBase *v9;
  uint64_t v10;
  uint64_t *v11;
  const re::IntrospectionBase *v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  const re::IntrospectionBase *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  const re::IntrospectionBase *v20;
  uint64_t v21;
  uint64_t *v22;
  const re::IntrospectionBase *v23;
  void *v24;
  uint64_t v25;
  __int128 v26;
  _QWORD v27[2];
  __int128 v28;

  v27[0] = 0x6061B851532742F2;
  v27[1] = "RealityFileHeader";
  re::StringID::destroyString((re::StringID *)v27);
  *((_OWORD *)this + 2) = v28;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FBB20);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FBB20);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v7 = v6;
      v8 = (uint64_t *)qword_2540FBB00;
      if (!qword_2540FBB00)
      {
        v8 = re::allocInfo_RealityFileVersionInfo((re *)v6);
        qword_2540FBB00 = (uint64_t)v8;
        re::initInfo_RealityFileVersionInfo((re *)v8, v9);
      }
      v10 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v7 + 32))(v7, 72, 8);
      *(_DWORD *)v10 = 1;
      *(_QWORD *)(v10 + 8) = "versionInfo";
      *(_QWORD *)(v10 + 16) = v8;
      *(_QWORD *)(v10 + 24) = 0;
      *(_QWORD *)(v10 + 32) = 0x1800000001;
      *(_DWORD *)(v10 + 40) = 0;
      *(_QWORD *)(v10 + 48) = 0;
      *(_QWORD *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_2540FBC20 = v10;
      v11 = re::introspectionAllocator((re *)v10);
      v13 = re::introspect_int((re *)1, v12);
      v14 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v11 + 32))(v11, 72, 8);
      *(_DWORD *)v14 = 1;
      *(_QWORD *)(v14 + 8) = "minVersion";
      *(_QWORD *)(v14 + 16) = v13;
      *(_QWORD *)(v14 + 24) = 0;
      *(_QWORD *)(v14 + 32) = 0x6000000002;
      *(_DWORD *)(v14 + 40) = 0;
      *(_QWORD *)(v14 + 48) = 0;
      *(_QWORD *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_2540FBC28 = v14;
      v15 = re::introspectionAllocator((re *)v14);
      v17 = re::IntrospectionInfo<re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::get(1, v16);
      v18 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v15 + 32))(v15, 72, 8);
      *(_DWORD *)v18 = 1;
      *(_QWORD *)(v18 + 8) = "metadata";
      *(_QWORD *)(v18 + 16) = v17;
      *(_QWORD *)(v18 + 24) = 0;
      *(_QWORD *)(v18 + 32) = 0x6800000004;
      *(_DWORD *)(v18 + 40) = 0;
      *(_QWORD *)(v18 + 48) = 0;
      *(_QWORD *)(v18 + 56) = 0;
      *(_DWORD *)(v18 + 64) = 0;
      qword_2540FBC30 = v18;
      v19 = re::introspectionAllocator((re *)v18);
      re::introspect_RealityFilePlatform((re *)v19, v20);
      v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v19 + 32))(v19, 72, 8);
      *(_DWORD *)v21 = 1;
      *(_QWORD *)(v21 + 8) = "targetPlatform";
      *(_QWORD *)(v21 + 16) = &qword_2540FBDA8;
      *(_QWORD *)(v21 + 24) = 0;
      *(_QWORD *)(v21 + 32) = 0x9800000005;
      *(_DWORD *)(v21 + 40) = 0;
      *(_QWORD *)(v21 + 48) = 0;
      *(_QWORD *)(v21 + 56) = 0;
      *(_DWORD *)(v21 + 64) = 0;
      qword_2540FBC38 = v21;
      v22 = re::introspectionAllocator((re *)v21);
      v24 = re::introspect_int((re *)1, v23);
      v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
      *(_DWORD *)v25 = 1;
      *(_QWORD *)(v25 + 8) = "restrictedSeedVersion";
      *(_QWORD *)(v25 + 16) = v24;
      *(_QWORD *)(v25 + 24) = 0;
      *(_QWORD *)(v25 + 32) = 0x6400000006;
      *(_DWORD *)(v25 + 40) = 0;
      *(_QWORD *)(v25 + 48) = 0;
      *(_QWORD *)(v25 + 56) = 0;
      *(_DWORD *)(v25 + 64) = 0;
      qword_2540FBC40 = v25;
      __cxa_guard_release(&qword_2540FBB20);
    }
  }
  *((_QWORD *)this + 2) = 0xA000000008;
  *((_DWORD *)this + 6) = 8;
  *((_DWORD *)this + 14) = 5;
  *((_QWORD *)this + 8) = &qword_2540FBC20;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::RealityFileHeader>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::RealityFileHeader>;
  *((_QWORD *)this + 11) = re::internal::defaultRetain<re::RealityFileHeader>(void)::{lambda(void *)#1}::__invoke;
  *((_WORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = re::internal::defaultRelease<re::RealityFileHeader>(void)::{lambda(void *)#1}::__invoke;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::RealityFileHeader>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::RealityFileHeader>;
  re::IntrospectionRegistry::add(this, v3);
  v26 = v28;
}

uint64_t re::internal::defaultConstruct<re::RealityFileHeader>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return re::make::shared::unsafelyInplace<re::RealityFileHeader>(a3);
}

uint64_t re::internal::defaultDestruct<re::RealityFileHeader>(uint64_t a1, uint64_t a2, uint64_t (***a3)(_QWORD))
{
  return (**a3)(a3);
}

uint64_t re::internal::defaultDestructV2<re::RealityFileHeader>(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t re::introspect_RealityFileHeader(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RealityFileHeader", (uint64_t (*)(re::internal *))re::allocInfo_RealityFileHeader, (re::IntrospectionBase *(*)(void))re::initInfo_RealityFileHeader, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RealityFileHeader>, this);
}

uint64_t *re::allocInfo_DeduplicationInformation(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FBB28);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBB28))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC2A0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540FC2B0 = 0;
    qword_2540FC2C0 = 0;
    qword_2540FC2C8 = 0xFFFFFFFFLL;
    qword_2540FC2A0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC2D0 = (uint64_t)"DeduplicationInformation";
    dword_2540FC2D8 = 0;
    xmmword_2540FC2E0 = 0u;
    xmmword_2540FC2F0 = 0u;
    xmmword_2540FC300 = 0u;
    qword_2540FC310 = 0;
    __cxa_guard_release(&qword_2540FBB28);
  }
  return &qword_2540FC2A0;
}

void re::initInfo_DeduplicationInformation(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0x60185639ABC815FELL;
  v11[1] = "DeduplicationInformation";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FBB38);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FBB38);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "originalAssetToDuplicates";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FBB30 = v9;
      __cxa_guard_release(&qword_2540FBB38);
    }
  }
  *((_QWORD *)this + 2) = 0x3000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 8) = &qword_2540FBB30;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::DeduplicationInformation>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::DeduplicationInformation>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::DeduplicationInformation>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::DeduplicationInformation>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

uint64_t *re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  _OWORD *v7;
  const re::IntrospectionBase *v8;
  uint64_t *v9;
  std::__shared_mutex_base *v10;
  uint64_t v12;
  int v13;
  re::IntrospectionRegistry *v14;
  const re::IntrospectionBase *v15;
  const char *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  const char *v21;
  uint64_t v22[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionHashTableBase::IntrospectionHashTableBase((re::IntrospectionHashTableBase *)&re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::info);
    re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::info = (uint64_t)&off_24ED2DD48;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    v4 = re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    if (v4)
      return &re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = re::IntrospectionInfo<re::DynamicString>::get(1, a2);
  v9 = re::IntrospectionInfo<re::DynamicArray<re::DynamicString>>::get(1, v8);
  if (re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v10 = re::introspectionSharedMutex((re *)v9);
      std::__shared_mutex_base::unlock(v10);
    }
  }
  else
  {
    v12 = (uint64_t)v9;
    re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::isInitialized = 1;
    v13 = *((_DWORD *)v9 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::info, 0);
    qword_2558005B8 = 0x3000000007;
    dword_2558005C0 = v13;
    word_2558005C4 = 0;
    *(_QWORD *)&xmmword_2558005C8 = 0;
    *((_QWORD *)&xmmword_2558005C8 + 1) = 0xFFFFFFFFLL;
    qword_2558005D8 = (uint64_t)v7;
    unk_2558005E0 = 0;
    qword_2558005E8 = v12;
    unk_2558005F0 = 0;
    re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::info = (uint64_t)&off_24ED2DD48;
    re::IntrospectionRegistry::add(v14, v15);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::info, (const re::IntrospectionBase *)&v20);
    if ((BYTE8(v20) & 1) != 0)
      v16 = v21;
    else
      v16 = (char *)&v20 + 9;
    if ((_QWORD)v20 && (BYTE8(v20) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v20 + 40))();
    v17 = v7[2];
    v19 = *(_OWORD *)(v12 + 32);
    v20 = v17;
    xmmword_2558005C8 = v18;
    re::StringID::destroyString((re::StringID *)v22);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::DeduplicationInformation>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_QWORD *)&result = 0x7FFFFFFFLL;
  *(_QWORD *)(a3 + 36) = 0x7FFFFFFFLL;
  return result;
}

double re::internal::defaultDestruct<re::DeduplicationInformation>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a3);
}

double re::internal::defaultConstructV2<re::DeduplicationInformation>(uint64_t a1)
{
  double result;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)&result = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  return result;
}

uint64_t re::introspect_DeduplicationInformation(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"DeduplicationInformation", (uint64_t (*)(re::internal *))re::allocInfo_DeduplicationInformation, (re::IntrospectionBase *(*)(void))re::initInfo_DeduplicationInformation, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::DeduplicationInformation>, this);
}

re::RealityFile *re::RealityFile::RealityFile(re::RealityFile *this, re *a2)
{
  _anonymous_namespace_ *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v8;
  char v9;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED2D6E8;
  re::filePathWithURL(a2, (re::RealityFile *)((char *)this + 24));
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  re::DynamicString::setCapacity((_QWORD *)this + 7, 0);
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 24) = 1;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  v5 = *((_QWORD *)this + 4);
  if ((v5 & 1) != 0)
    v6 = v5 >> 1;
  else
    v6 = v5 >> 1;
  if (!v6)
  {
    re::DynamicString::format((re::DynamicString *)"Failed to create a file path from URL %s.", (re::DynamicString *)&v8, a2);
    re::DynamicString::operator=((re::RealityFile *)((char *)this + 56), (re::DynamicString *)&v8);
    if (v8)
    {
      if ((v9 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
  }
  return this;
}

re::RealityFile *re::RealityFile::RealityFile(re::RealityFile *this, id *a2)
{
  _anonymous_namespace_ *v4;
  _anonymous_namespace_ *v5;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED2D6E8;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 3, 0);
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  re::DynamicString::setCapacity((_QWORD *)this + 7, 0);
  *((_QWORD *)this + 11) = *a2;
  *((_DWORD *)this + 24) = 2;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  return this;
}

void re::RealityFile::~RealityFile(re::RealityFile *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)this = &off_24ED2D6E8;
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {

    *((_QWORD *)this + 16) = 0;
  }
  v3 = *((_QWORD *)this + 15);
  if (v3)
  {

    *((_QWORD *)this + 15) = 0;
  }
  v4 = *((_QWORD *)this + 14);
  if (v4)
  {

    *((_QWORD *)this + 14) = 0;
  }
  v5 = *((_QWORD *)this + 13);
  if (v5)
  {

    *((_QWORD *)this + 13) = 0;
  }

  v6 = *((_QWORD *)this + 7);
  if (v6)
  {
    if ((*((_BYTE *)this + 64) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)this + 9));
    *(_OWORD *)((char *)this + 56) = 0u;
    *(_OWORD *)((char *)this + 72) = 0u;
  }
  v7 = *((_QWORD *)this + 3);
  if (v7)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *((_QWORD *)this + 5));
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::RealityFile::~RealityFile(this);
  JUMPOUT(0x2276933B8);
}

void re::RealityFile::makeByOpeningFileAtURL(re::RealityFile *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v5;
  uint64_t v6;
  re::RealityFile *v7;
  uint64_t v8;
  id v9;
  uint64_t v10;
  id v11;
  uint64_t *v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (this)
  {
    v5 = re::globalAllocators(this);
    v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5[2] + 32))(v5[2], 136, 8);
    v7 = re::RealityFile::RealityFile((re::RealityFile *)v6, this);
    re::RealityFile::init(v7, v8, (uint64_t)&v12);
    if ((_BYTE)v12)
    {
      if (v6)
        v9 = (id)(v6 + 8);
      *(_BYTE *)a2 = 1;
      *(_QWORD *)(a2 + 8) = v6;
      if (!v6)
        return;
    }
    else
    {
      v11 = v13;
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = v11;

      if (!v6)
        return;
    }

    return;
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  re::DynamicString::setCapacity(&v12, 0);
  v10 = v16;
  v16 = 0;
  *(_BYTE *)a2 = 0;
  *(_QWORD *)(a2 + 8) = v10;

  if (v12 && (v13 & 1) != 0)
    (*(void (**)(void))(*v12 + 40))();
}

uint64_t re::RealityFile::init@<X0>(re::RealityFile *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3;
  unint64_t v4;
  size_t v5;
  unint64_t v6;
  unint64_t v7;
  int v9;
  uint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  re::RealityArchive *v13;
  const char *v14;
  int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  unsigned __int8 v18;
  _anonymous_namespace_ *v19;
  _DWORD *v20;
  int v21;
  __int128 v22;
  void *v23;
  void *v24;
  _OWORD *v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  _anonymous_namespace_ *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  const __CFData *v38;
  unsigned __int8 v39;
  _anonymous_namespace_ *v40;
  _QWORD *v41;
  _QWORD *v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  char v47;
  void *v48;
  void *v49;
  unint64_t v50;
  uint64_t v51;
  char v52;
  void *v53;
  _anonymous_namespace_ *v54;
  CFDictionaryRef v55;
  uint64_t v56;
  const __CFData *v57;
  unsigned __int8 v58;
  _anonymous_namespace_ *v59;
  _QWORD *v60;
  _DWORD *v61;
  char *v62;
  int v63;
  const char *v64;
  uint64_t v65;
  __int128 v66;
  _DWORD *v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  _anonymous_namespace_ *v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  _DWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  re *v80;
  uint64_t v81;
  uint64_t *v82;
  re::SceneDescriptor *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  const char *v88;
  uint64_t *v89;
  re::AssetDescriptor *v90;
  uint64_t v91;
  uint64_t v92;
  _anonymous_namespace_ *v93;
  unint64_t v94;
  unint64_t v95;
  _DWORD *v96;
  BOOL v97;
  _BOOL4 v98;
  const char *v100;
  uint64_t v101;
  uint64_t *v102;
  re::AssetDescriptor *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  re::RealityArchive *v107;
  _QWORD *v108;
  uint64_t v109;
  uint64_t v110;
  _anonymous_namespace_ *v111;
  void *v112;
  char *v113;
  unint64_t v114;
  char *v115;
  uint64_t v116;
  id v117;
  unint64_t v118;
  unint64_t v119;
  unsigned int v120;
  unsigned int v121;
  uint64_t v122;
  int v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  void *v129;
  void *v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t *v133;
  uint64_t v134;
  uint64_t v135;
  id v136;
  _anonymous_namespace_ *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  _DWORD *v143;
  void *v144;
  uint64_t v145;
  double v146;
  void *v147;
  void *v148;
  uint64_t v149;
  unint64_t v150;
  uint64_t v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  double v155;
  _QWORD *v156;
  uint64_t v157;
  _QWORD *v158;
  size_t v159;
  _QWORD *v160;
  unint64_t v161;
  _OWORD *v162;
  int *v163;
  int v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  uint64_t v168;
  unsigned int v169;
  unint64_t v170;
  _OWORD *v171;
  uint64_t v172;
  unint64_t *v173;
  char *v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  unint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  int v184;
  uint64_t v185;
  int v186;
  uint64_t v187;
  uint64_t v188;
  id v189;
  uint64_t v190;
  id v191;
  char *v192;
  char *v193;
  char *v195;
  int v196;
  const char *v197;
  _DWORD *v198;
  uint64_t v199;
  _DWORD *v200;
  re::DynamicString *v201;
  _QWORD *v202;
  re::RealityArchive *v203;
  re::RealityArchive *v204;
  re::RealityArchive *v205;
  unint64_t v206;
  uint64_t v207;
  char v208[8];
  unint64_t v209;
  int valuePtr;
  char v211;
  _BYTE v212[32];
  void *v213;
  _OWORD v214[2];
  void *v215;
  _DWORD *v216;
  CFTypeRef cf;
  char v218;
  uint64_t v219;
  uint64_t v220;
  __int128 v221;
  void *v222;
  void *values[4];
  __int128 v224;
  uint64_t v225;
  _BYTE v226[40];
  _BYTE v227[28];
  __int16 v228;
  _BYTE v229[10];
  void *keys[4];
  __int128 v231;
  __int128 v232;
  __int128 v233;
  uint64_t v234;

  v7 = (unint64_t)this;
  v234 = *MEMORY[0x24BDAC8D0];
  v9 = *((_DWORD *)this + 24);
  if (v9 == 1)
  {
    v11 = *((_QWORD *)this + 4);
    v12 = v11 >> 1;
    if ((v11 & 1) == 0)
      v12 = v11 >> 1;
    if (!v12)
    {
      if ((*((_BYTE *)this + 64) & 1) != 0)
        v14 = (const char *)*((_QWORD *)this + 9);
      else
        v14 = (char *)this + 65;
      v6 = (unint64_t)values[0];
      values[0] = 0;
      v208[0] = 0;
      v209 = v6;

      if (keys[0] && ((uint64_t)keys[1] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)keys[0] + 40))();
      goto LABEL_32;
    }
    if ((v11 & 1) != 0)
      v13 = (re::RealityArchive *)*((_QWORD *)this + 5);
    else
      v13 = (re::RealityFile *)((char *)this + 33);
    v10 = (uint64_t *)(v7 + 120);
    re::RealityArchive::makeByOpeningFileAtPath(v13, *(const char **)(v7 + 120), (uint64_t)keys);
  }
  else
  {
    if (v9 != 2)
      goto LABEL_375;
    v10 = (uint64_t *)((char *)this + 120);
    re::RealityArchive::makeByReadingBuffer((id *)this + 11, *((const re::Data **)this + 15), (uint64_t)keys);
  }
  if (LOBYTE(keys[0]))
  {
    if (!*(_QWORD *)(v7 + 128))
      re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(v7 + 128), (uint64_t)keys[1]);
    if (!*v10)
      re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(v10, *((_QWORD *)keys[1] + 4));
    v6 = (unint64_t)keys[1];
    keys[1] = 0;
    v15 = 1;
    v208[0] = 1;
    v209 = v6;
  }
  else
  {
    v6 = (unint64_t)values[0];
    values[0] = 0;
    v208[0] = 0;
    v209 = v6;

    v15 = 0;
  }
  v16 = re::Result<re::SharedPtr<re::RealityArchive>,re::DynamicString>::~Result((unsigned __int8 *)keys);
  if (!v15)
  {
LABEL_32:
    v26 = (id)v6;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v26;
    return re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v208);
  }
  v4 = (unint64_t)&v220;
  v220 = 0;
  valuePtr = 0;
  memset(v214, 0, sizeof(v214));
  re::DynamicString::setCapacity(v214, 0);
  v17 = re::RealityArchive::newDataByLoadingEntryWithName((re::RealityArchive *)v6, "header.json", (uint64_t)v227);
  if (v227[0])
  {
    v5 = *(_QWORD *)&v227[8];
    if ((v18 & 1) == 0)
      goto LABEL_378;
    goto LABEL_23;
  }
  v20 = keys[0];
  keys[0] = 0;

  v21 = 0;
  while (1)
  {
    if (!v227[0] && *(_QWORD *)&v227[8] && (v227[16] & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v227[8] + 40))();
    if (*(_QWORD *)&v214[0] && (BYTE8(v214[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v214[0] + 40))();
    if (v220)

    if (!v21)
    {
      v61 = v20;
      *(_BYTE *)a3 = 0;
      *(_QWORD *)(a3 + 8) = v61;

      return re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v208);
    }
    re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(v7 + 104), (uint64_t)v20);
    v56 = re::RealityArchive::newDataByLoadingEntryWithName((re::RealityArchive *)v6, "assetMap.json", (uint64_t)&v216);
    if (!(_BYTE)v216)
    {
      v62 = (char *)keys[0];
      keys[0] = 0;

      v63 = 0;
      goto LABEL_341;
    }
    v57 = (const __CFData *)cf;
    if ((v58 & 1) == 0)
    {
      if ((_DWORD)v56)
      {
        re::introspect<re::AssetMap>(void)::info = (_UNKNOWN *)re::internal::getOrCreateInfo((re::internal *)"AssetMap", (uint64_t (*)(re::internal *))re::allocInfo_AssetMap, (re::IntrospectionBase *(*)(void))re::initInfo_AssetMap, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AssetMap>, 0);
      }
    }
    *(_OWORD *)(v4 + 96) = *((_OWORD *)re::introspect<re::AssetMap>(void)::info + 2);
    if (!*(_QWORD *)v226)
    {
      v66 = *(_OWORD *)(v4 + 192);
      LOBYTE(v214[0]) = 0;
      *(_OWORD *)((char *)v214 + 8) = v66;
      *((void **)&v214[1] + 1) = keys[2];
      v215 = keys[3];
      CFRelease(cf);
LABEL_243:
      v62 = (char *)keys[0];
      keys[0] = 0;

      v63 = 0;
      goto LABEL_335;
    }
    v203 = (re::RealityArchive *)v6;
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v212);
    re::TypeRegistry::typeInfo(*(re **)v226, (re **)v226, keys);
    v6 = (unint64_t)&keys[1];
    v59 = (_anonymous_namespace_ *)re::TypeInfo::TypeInfo((uint64_t)v227, (uint64_t)&keys[1]);
    v3 = LOBYTE(keys[0]);
    if (LOBYTE(keys[0]))
    {
      v60 = keys[1];
      LOBYTE(values[0]) = 1;
      LOBYTE(v214[0]) = 1;
      *((void **)&v214[0] + 1) = keys[1];
      v5 = (size_t)&v220;
    }
    else
    {
      v67 = v20;
      v68 = *((_QWORD *)&v231 + 1);
      v69 = keys[3];
      v4 = v231;
      LOBYTE(values[0]) = 0;
      v5 = (size_t)&v220;
      *(_OWORD *)&values[1] = *(_OWORD *)&keys[1];
      v225 = v232;
      values[3] = keys[3];
      v224 = v231;
      re::DynamicString::DynamicString((re::DynamicString *)keys, (const re::DynamicString *)&values[3]);
      LOBYTE(v214[0]) = 0;
      v60 = keys[0];
      *((void **)&v214[0] + 1) = keys[0];
      v215 = keys[3];
      v214[1] = *(_OWORD *)&keys[1];
      if (v69 && (v4 & 1) != 0)
        (*(void (**)(void *, uint64_t))(*(_QWORD *)v69 + 40))(v69, v68);
      v20 = v67;
    }
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v212);
    CFRelease(cf);
    if (!(_DWORD)v3)
      goto LABEL_243;
    v200 = v20;
    v206 = v7;
    v207 = a3;
    LODWORD(v224) = 0;
    memset(values, 0, sizeof(values));
    *(_QWORD *)((char *)&v224 + 4) = 0x7FFFFFFFLL;
    *(_QWORD *)v212 = 0;
    if (v60[25])
    {
      v3 = 0;
      v6 = (unint64_t)(v60 + 34);
      v4 = 0x7FFFFFFFLL;
      a3 = 48;
      do
      {
        v71 = *(_QWORD *)(v60[27] + 8 * v3);
        v72 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v71 + 40))(v71);
        v73 = re::Hash<re::DynamicString>::operator()((uint64_t)v227, (uint64_t)keys);
        v7 = v73;
        if (LODWORD(values[3]))
        {
          v74 = v73 % LODWORD(values[3]);
          v75 = *((unsigned int *)values[1] + v74);
          if ((_DWORD)v75 != 0x7FFFFFFF)
          {
            v76 = values[2];
            while (!re::DynamicString::operator==((uint64_t)&v76[12 * v75 + 4], (uint64_t)keys))
            {
              v75 = v76[12 * v75 + 2] & 0x7FFFFFFF;
              if (v75 == 0x7FFFFFFF)
                goto LABEL_124;
            }
            goto LABEL_125;
          }
        }
        else
        {
          LODWORD(v74) = 0;
        }
LABEL_124:
        re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove((uint64_t)values, v74, v7, (uint64_t)keys, keys);
        ++DWORD2(v224);
LABEL_125:
        if (keys[0] && ((uint64_t)keys[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)keys[0] + 40))();
        v5 = v60[25];
        if (v5 <= v3)
        {
          *(_QWORD *)v226 = 0;
          v232 = 0u;
          v233 = 0u;
          v231 = 0u;
          memset(keys, 0, sizeof(keys));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v227 = 136315906;
          *(_QWORD *)&v227[4] = "operator[]";
          *(_WORD *)&v227[12] = 1024;
          *(_DWORD *)&v227[14] = 789;
          *(_WORD *)&v227[18] = 2048;
          *(_QWORD *)&v227[20] = v3;
          v228 = 2048;
          *(_QWORD *)v229 = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_370:
          *(_QWORD *)v226 = 0;
          v232 = 0u;
          v233 = 0u;
          v231 = 0u;
          memset(keys, 0, sizeof(keys));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v227 = 136315906;
          *(_QWORD *)&v227[4] = "operator[]";
          *(_WORD *)&v227[12] = 1024;
          *(_DWORD *)&v227[14] = 789;
          *(_WORD *)&v227[18] = 2048;
          *(_QWORD *)&v227[20] = v3;
          v228 = 2048;
          *(_QWORD *)v229 = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_371;
        }
        v77 = *(_QWORD *)(v60[27] + 8 * v3);
        keys[0] = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v77 + 40))(v77);
        re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add<unsigned long &>((uint64_t)(v60 + 28), (char **)keys, v212);
        v5 = v60[25];
        if (v5 <= v3)
          goto LABEL_370;
        v78 = *(_QWORD *)(v60[27] + 8 * v3);
        keys[0] = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v78 + 32))(v78);
        re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add<unsigned long &>((uint64_t)(v60 + 34), (char **)keys, v212);
        *(_QWORD *)v212 = ++v3;
      }
      while (v3 < v60[25]);
    }
    v79 = v60[5];
    if (v79)
    {
      v6 = v60[7];
      v3 = v6 + 200 * v79;
      do
      {
        v80 = (re *)re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)values, (re::DynamicString *)(v6 + 24));
        v81 = *(_QWORD *)(v6 + 176);
        if (v81)
        {
          v4 = 40 * v81;
          v5 = *(_QWORD *)(v6 + 192) + 8;
          do
          {
            v80 = (re *)re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)values, (re::DynamicString *)v5);
            v5 += 40;
            v4 -= 40;
          }
          while (v4);
        }
        v82 = re::globalAllocators(v80);
        v83 = (re::SceneDescriptor *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v82[2] + 32))(v82[2], 200, 8);
        keys[0] = re::SceneDescriptor::SceneDescriptor(v83, (const re::SceneDescriptor *)v6);
        re::DynamicArray<re::SharedPtr<re::internal::AssetReference>>::add((_anonymous_namespace_ *)(v60 + 23), keys);
        if (keys[0])

        v84 = *(_QWORD *)(v60[27] + 8 * v60[25] - 8);
        keys[0] = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v84 + 40))(v84);
        *(_QWORD *)v227 = v60[25] - 1;
        re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add((uint64_t)(v60 + 28), (char **)keys, v227);
        v85 = *(_QWORD *)(v60[27] + 8 * v60[25] - 8);
        keys[0] = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v85 + 32))(v85);
        *(_QWORD *)v227 = v60[25] - 1;
        v70 = re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add((uint64_t)(v60 + 34), (char **)keys, v227);
        v6 += 200;
      }
      while (v6 != v3);
    }
    v86 = v60[10];
    if (v86)
      break;
LABEL_155:
    v93 = (_anonymous_namespace_ *)re::RealityArchive::entryNames(v203, (uint64_t)keys);
    *(_QWORD *)&v229[2] = 0;
    memset(v227, 0, sizeof(v227));
    if (keys[2])
    {
      v3 = 32 * (uint64_t)keys[2];
      v4 = v231 + 16;
      v6 = 1702064993;
      do
      {
        v94 = *(_QWORD *)(v4 - 8);
        v95 = v94 >> 1;
        if ((v94 & 1) == 0)
          v95 = v94 >> 1;
        if (v95 >= 7)
        {
          v96 = (v94 & 1) != 0 ? *(_DWORD **)v4 : (_DWORD *)(v4 - 7);
          v97 = *v96 == 1702064993 && *(_DWORD *)((char *)v96 + 3) == 796095589;
          v98 = !v97;
          v5 = v95 - 7;
          if (v95 != 7 && !v98)
          {
            v100 = (char *)v96 + 7;
            re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)v227, (re::DynamicString *)v226);
            v93 = *(_anonymous_namespace_ **)v226;
            if (*(_QWORD *)v226)
            {
              if ((v226[8] & 1) != 0)
                v93 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(_QWORD **)v226 + 40))();
            }
          }
        }
        v4 += 32;
        v3 -= 32;
      }
      while (v3);
    }
    v101 = re::DynamicArray<re::DynamicString>::deinit((uint64_t)keys);
    if (*(_QWORD *)&v227[16])
    {
      a3 = *(_QWORD *)&v229[2];
      v6 = (unint64_t)(v60 + 28);
      v3 = 32 * *(_QWORD *)&v227[16];
      do
      {
        v101 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::contains((uint64_t)values, a3);
        if ((v101 & 1) == 0)
        {
          if ((*(_BYTE *)(a3 + 8) & 1) != 0)
            v5 = *(_QWORD *)(a3 + 16);
          else
            v5 = a3 + 9;
          v102 = re::globalAllocators((re *)v101);
          v103 = (re::AssetDescriptor *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v102[2] + 32))(v102[2], 88, 8);
          keys[0] = re::AssetDescriptor::AssetDescriptor(v103, (const char *)v5, 0);
          re::DynamicArray<re::SharedPtr<re::internal::AssetReference>>::add((_anonymous_namespace_ *)(v60 + 23), keys);
          if (keys[0])

          v104 = *(_QWORD *)(v60[27] + 8 * v60[25] - 8);
          keys[0] = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v104 + 40))(v104);
          *(_QWORD *)v226 = v60[25] - 1;
          re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add((uint64_t)(v60 + 28), (char **)keys, v226);
          v105 = *(_QWORD *)(v60[27] + 8 * v60[25] - 8);
          keys[0] = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v105 + 32))(v105);
          *(_QWORD *)v226 = v60[25] - 1;
          re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add((uint64_t)(v60 + 34), (char **)keys, v226);
          v101 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)values, (re::DynamicString *)a3);
        }
        a3 += 32;
        v3 -= 32;
      }
      while (v3);
    }
    v106 = v60[10];
    if (v106)
    {
      v107 = (re::RealityArchive *)v60[12];
      v108 = v60 + 40;
      a3 = 0x7FFFFFFFLL;
      v204 = (re::RealityArchive *)((char *)v107 + 168 * v106);
      do
      {
        if (!*((_QWORD *)v107 + 2))
          goto LABEL_363;
        v6 = *((_QWORD *)v107 + 4);
        *(_QWORD *)&v231 = 0;
        memset(keys, 0, 28);
        v109 = *((_QWORD *)v107 + 7);
        if (v109)
        {
          v3 = *((_QWORD *)v107 + 9);
          v110 = 8 * v109;
          while (1)
          {
            re::AssetMap::assetDescriptorFromAssetsIndex((re::AssetMap *)v226, (re::AssetMap *)v60, *(_QWORD *)v3);
            if (!v226[0])
              break;
            v112 = keys[2];
            if (keys[2] >= keys[1])
            {
              v113 = (char *)keys[2] + 1;
              if (keys[1] < (char *)keys[2] + 1)
              {
                if (keys[0])
                {
                  v114 = 2 * (uint64_t)keys[1];
                  if (!keys[1])
                    v114 = 8;
                  if (v114 <= (unint64_t)v113)
                    v115 = (char *)keys[2] + 1;
                  else
                    v115 = (char *)v114;
                  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(keys, (unint64_t)v115);
                }
                else
                {
                  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(keys, (unint64_t)v113);
                  ++LODWORD(keys[3]);
                }
              }
              v112 = keys[2];
            }
            v116 = *(_QWORD *)&v226[8];
            *(_QWORD *)(v231 + 8 * (_QWORD)v112) = *(_QWORD *)&v226[8];
            if (v116)
            {
              v117 = (id)(v116 + 8);
              v112 = keys[2];
            }
            keys[2] = (char *)v112 + 1;
            ++LODWORD(keys[3]);
            re::Result<re::SharedPtr<re::RealityArchive>,re::DynamicString>::~Result(v226);
            v3 += 8;
            v110 -= 8;
            if (!v110)
              goto LABEL_208;
          }
          re::DynamicString::DynamicString((re::DynamicString *)&v220, (const re::DynamicString *)&v226[8]);
          v212[0] = 0;
          *(_QWORD *)&v212[8] = v220;
          v213 = v222;
          *(_OWORD *)&v212[16] = v221;
          re::Result<re::SharedPtr<re::RealityArchive>,re::DynamicString>::~Result(v226);
          re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)keys);
          goto LABEL_245;
        }
LABEL_208:
        v118 = re::Hash<re::DynamicString>::operator()((uint64_t)v226, v6);
        v119 = v118;
        if (*v108)
        {
          v5 = v118 % *((unsigned int *)v60 + 86);
          v3 = *(unsigned int *)(v60[41] + 4 * v5);
          if ((_DWORD)v3 != 0x7FFFFFFF)
          {
            v4 = v60[42];
            while (!re::DynamicString::operator==(v4 + 88 * v3 + 16, v6))
            {
              v3 = *(_DWORD *)(v4 + 88 * v3 + 8) & 0x7FFFFFFF;
              if (v3 == 0x7FFFFFFF)
                goto LABEL_215;
            }
            goto LABEL_235;
          }
        }
        else
        {
          v5 = 0;
        }
LABEL_215:
        v120 = *((_DWORD *)v60 + 89);
        if (v120 == 0x7FFFFFFF)
        {
          v120 = *((_DWORD *)v60 + 88);
          v121 = v120;
          if (v120 == *((_DWORD *)v60 + 86))
          {
            re::HashTable<re::DynamicString,re::DynamicArray<re::SharedPtr<re::AssetDescriptorBase const>>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)v108, 2 * *((_DWORD *)v60 + 87));
            v5 = v119 % *((unsigned int *)v60 + 86);
            v121 = *((_DWORD *)v60 + 88);
          }
          *((_DWORD *)v60 + 88) = v121 + 1;
          v122 = v60[42];
          v123 = *(_DWORD *)(v122 + 88 * v120 + 8);
        }
        else
        {
          v122 = v60[42];
          v123 = *(_DWORD *)(v122 + 88 * v120 + 8);
          *((_DWORD *)v60 + 89) = v123 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v122 + 88 * v120 + 8) = v123 | 0x80000000;
        v124 = v60[42] + 88 * v120;
        *(_DWORD *)(v124 + 8) = *(_DWORD *)(v124 + 8) & 0x80000000 | *(_DWORD *)(v60[41] + 4 * v5);
        *(_QWORD *)(v60[42] + 88 * v120) = v119;
        re::DynamicString::DynamicString((re::DynamicString *)(v60[42] + 88 * v120 + 16), (const re::DynamicString *)v6);
        v125 = v60[42];
        v126 = v125 + 88 * v120;
        *(_QWORD *)(v126 + 48) = 0;
        v127 = v126 + 48;
        *(_QWORD *)(v127 + 32) = 0;
        v4 = v127 + 32;
        *(_QWORD *)(v127 + 8) = 0;
        *(_QWORD *)(v127 + 16) = 0;
        *(_DWORD *)(v127 + 24) = 0;
        if (keys[0])
        {
          v128 = v125 + 88 * v120;
          v129 = keys[2];
          *(void **)v127 = keys[0];
          re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((_QWORD *)v127, (unint64_t)v129);
          v130 = *(void **)(v128 + 64);
          v3 = v128 + 64;
          ++*(_DWORD *)(v3 + 8);
          v6 = (unint64_t)keys[2];
          if (keys[2] >= v130)
          {
            re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((_QWORD *)v127, (unint64_t)keys[2]);
            std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,0>((uint64_t *)v231, (uint64_t *)(v231 + 8 * *(_QWORD *)v3), *(uint64_t **)v4);
            v132 = *(_QWORD *)v3;
            if (*(_QWORD *)v3 != v6)
            {
              v133 = (uint64_t *)(v231 + 8 * v132);
              v4 = *(_QWORD *)v4 + 8 * v132;
              v134 = 8 * v6 - 8 * v132;
              do
              {
                v135 = *v133;
                *(_QWORD *)v4 = *v133;
                if (v135)
                  v136 = (id)(v135 + 8);
                ++v133;
                v4 += 8;
                v134 -= 8;
              }
              while (v134);
            }
          }
          else
          {
            std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,0>((uint64_t *)v231, (uint64_t *)(v231 + 8 * (uint64_t)keys[2]), *(uint64_t **)v4);
            if (v6 != *(_QWORD *)v3)
            {
              v4 = *(_QWORD *)v4 + 8 * v6;
              v131 = 8 * *(_QWORD *)v3 - 8 * v6;
              do
              {
                if (*(_QWORD *)v4)
                {

                  *(_QWORD *)v4 = 0;
                }
                v4 += 8;
                v131 -= 8;
              }
              while (v131);
            }
          }
          *(_QWORD *)v3 = v6;
        }
        *(_DWORD *)(v60[41] + 4 * v5) = v120;
        ++*((_DWORD *)v60 + 87);
        ++*((_DWORD *)v60 + 90);
        v108 = v60 + 40;
        a3 = 0x7FFFFFFFLL;
LABEL_235:
        v101 = re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)keys);
        v107 = (re::RealityArchive *)((char *)v107 + 168);
      }
      while (v107 != v204);
    }
    v7 = v60[15];
    if (v7)
    {
      if (v7 >= 0x555555555555556)
        goto LABEL_372;
      if (!v139)
      {
LABEL_373:
        re::internal::assertLog((re::internal *)4, v140, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
        _os_crash();
        __break(1u);
        re::internal::assertLog((re::internal *)6, v199, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 24, v7);
        _os_crash();
        __break(1u);
        goto LABEL_374;
      }
      a3 = v139;
      v141 = v7 - 1;
      if (v7 == 1)
      {
        v143 = (_DWORD *)(v139 + 36);
        v142 = v139;
      }
      else
      {
        v142 = v139;
        do
        {
          *(_OWORD *)(v142 + 16) = 0uLL;
          *(_OWORD *)(v142 + 32) = 0uLL;
          *(_OWORD *)v142 = 0uLL;
          *(_DWORD *)(v142 + 36) = 0x7FFFFFFF;
          v142 += 48;
          --v141;
        }
        while (v141);
        v143 = (_DWORD *)(v142 + 36);
      }
      *(_OWORD *)(v142 + 16) = 0u;
      *(_OWORD *)(v142 + 32) = 0u;
      *(_OWORD *)v142 = 0u;
      v3 = 0x7FFFFFFFLL;
      *v143 = 0x7FFFFFFF;
      if (v7 <= 1)
        v4 = 1;
      else
        v4 = v7;
      v145 = v139;
      do
      {
        v146 = 0.0;
        v231 = 0u;
        memset(keys, 0, sizeof(keys));
        DWORD1(v231) = 0x7FFFFFFF;
        if ((void **)v145 != keys)
        {
          if (*(_QWORD *)v145)
          {
            re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(v145);
          }
          else
          {
            *(_QWORD *)v145 = 0;
            keys[0] = 0;
            v147 = *(void **)(v145 + 8);
            *(void **)(v145 + 8) = keys[1];
            keys[1] = v147;
            v148 = *(void **)(v145 + 16);
            *(void **)(v145 + 16) = keys[2];
            keys[2] = v148;
            LODWORD(v148) = *(_DWORD *)(v145 + 24);
            *(_DWORD *)(v145 + 24) = keys[3];
            LODWORD(keys[3]) = (_DWORD)v148;
            LODWORD(v148) = *(_DWORD *)(v145 + 28);
            *(_DWORD *)(v145 + 28) = HIDWORD(keys[3]);
            HIDWORD(keys[3]) = (_DWORD)v148;
            LODWORD(v148) = *(_DWORD *)(v145 + 32);
            *(_DWORD *)(v145 + 32) = v231;
            LODWORD(v231) = (_DWORD)v148;
            LODWORD(v148) = *(_DWORD *)(v145 + 36);
            *(_DWORD *)(v145 + 36) = DWORD1(v231);
            DWORD1(v231) = (_DWORD)v148;
          }
        }
        re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)keys, v146);
        v145 += 48;
        --v4;
      }
      while (v4);
    }
    else
    {
      a3 = 0;
    }
    v149 = v60[21];
    if (!v149)
      goto LABEL_271;
    v3 = v60[22];
    v150 = v3 + 32 * v149;
    if (v7 <= 1)
      v151 = 1;
    else
      v151 = v7;
    v152 = v7;
    do
    {
      if (!v152)
        goto LABEL_270;
      v153 = 0;
      v4 = 0;
      v154 = a3;
      do
      {
        v6 = *(_QWORD *)(v3 + 16);
        if (v6 <= v4)
        {
          *(_QWORD *)v212 = 0;
          v232 = 0u;
          v233 = 0u;
          v231 = 0u;
          memset(keys, 0, sizeof(keys));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v226 = 136315906;
          *(_QWORD *)&v226[4] = "operator[]";
          *(_WORD *)&v226[12] = 1024;
          *(_DWORD *)&v226[14] = 476;
          *(_WORD *)&v226[18] = 2048;
          *(_QWORD *)&v226[20] = v4;
          *(_WORD *)&v226[28] = 2048;
          *(_QWORD *)&v226[30] = v6;
          _os_log_send_and_compose_impl();
          v101 = _os_crash_msg();
          __break(1u);
LABEL_363:
          v212[0] = 0;
          *(_OWORD *)&v212[8] = *(_OWORD *)keys;
          *(void **)&v212[24] = keys[2];
          v213 = keys[3];
LABEL_245:
          v7 = v206;
          v20 = v200;
          goto LABEL_325;
        }
        v137 = (_anonymous_namespace_ *)re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add(v154, (re::DynamicString *)(*(_QWORD *)(v3 + 24) + v153));
        ++v4;
        v153 += 32;
        v154 += 48;
      }
      while (v151 != v4);
      v152 = v7;
LABEL_270:
      v3 += 32;
    }
    while (v3 != v150);
LABEL_271:
    v60[53] = v7;
    v205 = (re::RealityArchive *)v7;
    if (!v7)
    {
LABEL_296:
      v172 = v60[21];
      v7 = v206;
      if (v172)
      {
        v173 = (unint64_t *)v60[22];
        v201 = (re::DynamicString *)&v173[4 * v172];
        v202 = v60 + 46;
        do
        {
          re::AssetMap::assetDescriptorFromAssetsIndex((re::AssetMap *)keys, (re::AssetMap *)v60, *v173);
          if (!LOBYTE(keys[0]))
          {
            re::DynamicString::DynamicString((re::DynamicString *)v226, (const re::DynamicString *)&keys[1]);
            v212[0] = 0;
            *(_QWORD *)&v212[8] = *(_QWORD *)v226;
            v213 = *(void **)&v226[24];
            *(_OWORD *)&v212[16] = *(_OWORD *)&v226[8];
            re::Result<re::SharedPtr<re::RealityArchive>,re::DynamicString>::~Result((unsigned __int8 *)keys);
            goto LABEL_321;
          }
          *(void **)v226 = keys[1];
          if (keys[1])
            v174 = (char *)keys[1] + 8;
          re::FixedArray<re::DynamicString>::FixedArray((re::DynamicString *)&v226[8], (uint64_t)(v173 + 1));
          v175 = v173[2];
          *(_QWORD *)v212 = v173[3];
          *(_QWORD *)&v212[8] = v175;
          v176 = re::Hash<re::Slice<re::DynamicString>>::operator()((uint64_t)&v220, (uint64_t *)v212);
          v177 = v176;
          v178 = 0x94D049BB133111EBLL
               * ((0xBF58476D1CE4E5B9 * (v176 ^ (v176 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v176 ^ (v176 >> 30))) >> 27));
          v179 = v178 ^ (v178 >> 31);
          if (*v202)
          {
            v180 = v179 % *((unsigned int *)v60 + 98);
            v181 = *(unsigned int *)(v60[47] + 4 * v180);
            if ((_DWORD)v181 != 0x7FFFFFFF)
            {
              v182 = v60[48];
              while (*(_QWORD *)(v182 + 56 * v181 + 16) != v176)
              {
                LODWORD(v181) = *(_DWORD *)(v182 + 56 * v181 + 8) & 0x7FFFFFFF;
                if ((_DWORD)v181 == 0x7FFFFFFF)
                  goto LABEL_308;
              }
              goto LABEL_316;
            }
          }
          else
          {
            v180 = 0;
          }
LABEL_308:
          v183 = *((unsigned int *)v60 + 101);
          if ((_DWORD)v183 == 0x7FFFFFFF)
          {
            v183 = *((unsigned int *)v60 + 100);
            v184 = v183;
            if ((_DWORD)v183 == *((_DWORD *)v60 + 98))
            {
              re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::setCapacity((uint64_t)v202, 2 * *((_DWORD *)v60 + 99));
              v180 = v179 % *((unsigned int *)v60 + 98);
              v184 = *((_DWORD *)v60 + 100);
            }
            *((_DWORD *)v60 + 100) = v184 + 1;
            v185 = v60[48];
            v186 = *(_DWORD *)(v185 + 56 * v183 + 8);
          }
          else
          {
            v185 = v60[48];
            v186 = *(_DWORD *)(v185 + 56 * v183 + 8);
            *((_DWORD *)v60 + 101) = v186 & 0x7FFFFFFF;
          }
          *(_DWORD *)(v185 + 56 * v183 + 8) = v186 | 0x80000000;
          *(_DWORD *)(v60[48] + 56 * v183 + 8) = *(_DWORD *)(v60[48] + 56 * v183 + 8) & 0x80000000 | *(_DWORD *)(v60[47] + 4 * v180);
          *(_QWORD *)(v60[48] + 56 * v183) = v179;
          *(_QWORD *)(v60[48] + 56 * v183 + 16) = v177;
          v187 = v60[48];
          v188 = *(_QWORD *)v226;
          *(_QWORD *)(v187 + 56 * v183 + 24) = *(_QWORD *)v226;
          if (v188)
            v189 = (id)(v188 + 8);
          re::FixedArray<re::DynamicString>::FixedArray((re::DynamicString *)(v187 + 56 * v183 + 32), (uint64_t)&v226[8]);
          *(_DWORD *)(v60[47] + 4 * v180) = v183;
          ++*((_DWORD *)v60 + 99);
          ++*((_DWORD *)v60 + 102);
LABEL_316:
          re::FixedArray<re::DynamicString>::deinit(&v226[8]);
          if (*(_QWORD *)v226)

          re::Result<re::SharedPtr<re::RealityArchive>,re::DynamicString>::~Result((unsigned __int8 *)keys);
          v173 += 4;
          v7 = v206;
        }
        while (v173 != (unint64_t *)v201);
      }
      v212[0] = 1;
LABEL_321:
      v20 = v200;
      if (v205)
      {
        v190 = 0;
        do
        {
          v155 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a3 + v190), v155);
          v190 += 48;
        }
        while (48 * (_QWORD)v205 != v190);
      }
LABEL_325:
      re::DynamicArray<re::DynamicString>::deinit((uint64_t)v227);
      a3 = v207;
      goto LABEL_326;
    }
    v5 = 24 * v7;
    v60[54] = v156;
    if (v156)
    {
      v158 = v156;
      if (v7 != 1)
      {
        v159 = v5 - 24;
        bzero(v156, v159);
        v158 = (_QWORD *)((char *)v158 + v159);
      }
      v6 = 0;
      *v158 = 0;
      v158[1] = 0;
      v158[2] = 0;
      while (1)
      {
        v5 = v60[53];
        if (v5 <= v6)
          break;
        v160 = (_QWORD *)(v60[54] + 24 * v6);
        v7 = a3 + 48 * v6;
        v161 = *(unsigned int *)(v7 + 28);
        v162 = (_OWORD *)*(unsigned int *)(v7 + 32);
        if ((_DWORD)v162)
        {
          v25 = 0;
          v163 = (int *)(*(_QWORD *)(v7 + 16) + 8);
          while (1)
          {
            v164 = *v163;
            v163 += 12;
            if (v164 < 0)
              break;
            v25 = (_OWORD *)((char *)v25 + 1);
            if (v162 == v25)
            {
              v25 = (_OWORD *)*(unsigned int *)(v7 + 32);
              break;
            }
          }
        }
        else
        {
          v25 = 0;
        }
        if ((_DWORD)v162 != (_DWORD)v25)
        {
          v165 = 0;
          v166 = v25;
          while (1)
          {
            v167 = v60[53];
            if (v167 <= v6)
              break;
            v168 = v60[54];
            v167 = *(_QWORD *)(v168 + 24 * v6 + 8);
            if (v167 <= v165)
              goto LABEL_365;
            v156 = re::DynamicString::operator=((re::DynamicString *)(*(_QWORD *)(v168 + 24 * v6 + 16) + 32 * v165), (re::DynamicString *)(*(_QWORD *)(v7 + 16) + 48 * v166 + 16));
            v169 = *(_DWORD *)(v7 + 32);
            if (v169 <= (int)v25 + 1)
              v170 = ((_DWORD)v25 + 1);
            else
              v170 = v169;
            while (1)
            {
              v166 = ((_DWORD)v25 + 1);
              if ((_DWORD)v170 - 1 == (_DWORD)v25)
                break;
              LODWORD(v25) = (_DWORD)v25 + 1;
              v171 = (_OWORD *)v166;
              if ((*(_DWORD *)(*(_QWORD *)(v7 + 16) + 48 * v166 + 8) & 0x80000000) != 0)
                goto LABEL_294;
            }
            v171 = (_OWORD *)v170;
LABEL_294:
            v25 = v171;
            ++v165;
            if ((_DWORD)v162 == (_DWORD)v171)
              goto LABEL_295;
          }
          *(_QWORD *)v212 = 0;
          v232 = 0u;
          v233 = 0u;
          v231 = 0u;
          memset(keys, 0, sizeof(keys));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v226 = 136315906;
          *(_QWORD *)&v226[4] = "operator[]";
          *(_WORD *)&v226[12] = 1024;
          *(_DWORD *)&v226[14] = 468;
          *(_WORD *)&v226[18] = 2048;
          *(_QWORD *)&v226[20] = v6;
          *(_WORD *)&v226[28] = 2048;
          *(_QWORD *)&v226[30] = v167;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_365:
          *(_QWORD *)v212 = 0;
          v4 = (unint64_t)&v220;
          v232 = 0u;
          v233 = 0u;
          v231 = 0u;
          memset(keys, 0, sizeof(keys));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v226 = 136315906;
          *(_QWORD *)&v226[4] = "operator[]";
          *(_WORD *)&v226[12] = 1024;
          *(_DWORD *)&v226[14] = 468;
          *(_WORD *)&v226[18] = 2048;
          *(_QWORD *)&v226[20] = v165;
          *(_WORD *)&v226[28] = 2048;
          *(_QWORD *)&v226[30] = v167;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_366;
        }
LABEL_295:
        if ((re::RealityArchive *)++v6 == v205)
          goto LABEL_296;
      }
LABEL_371:
      *(_QWORD *)v212 = 0;
      v4 = (unint64_t)&v220;
      v232 = 0u;
      v233 = 0u;
      v231 = 0u;
      memset(keys, 0, sizeof(keys));
      v3 = MEMORY[0x24BDACB70];
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v226 = 136315906;
      *(_QWORD *)&v226[4] = "operator[]";
      *(_WORD *)&v226[12] = 1024;
      *(_DWORD *)&v226[14] = 468;
      *(_WORD *)&v226[18] = 2048;
      *(_QWORD *)&v226[20] = v6;
      *(_WORD *)&v226[28] = 2048;
      *(_QWORD *)&v226[30] = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_372:
      re::internal::assertLog((re::internal *)6, v138, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 48, v7);
      _os_crash();
      __break(1u);
      goto LABEL_373;
    }
LABEL_374:
    re::internal::assertLog((re::internal *)4, v157, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
LABEL_375:
    if (!v9)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) The RealityFile does not have a valid file URL or file pointer.", "!\"Unreachable code\"", "parseArchive", 448);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "parseArchive", 485);
    _os_crash();
    __break(1u);
LABEL_378:
    if ((_DWORD)v17)
    {
      *(_QWORD *)(v3 + 368) = re::internal::getOrCreateInfo((re::internal *)"RealityFileHeader", (uint64_t (*)(re::internal *))re::allocInfo_RealityFileHeader, (re::IntrospectionBase *(*)(void))re::initInfo_RealityFileHeader, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RealityFileHeader>, 0);
    }
LABEL_23:
    *(_OWORD *)v212 = *(_OWORD *)(*(_QWORD *)(v3 + 368) + 32);
    if (!*(_QWORD *)v212)
    {
      v22 = *(_OWORD *)(v4 + 192);
      v23 = keys[2];
      v24 = keys[3];
      v226[0] = 0;
      v25 = &v226[8];
      *(_OWORD *)(v4 + 104) = v22;
      *(_QWORD *)&v226[24] = v23;
      *(_QWORD *)&v226[32] = v24;
LABEL_49:
      v31 = re::DynamicString::operator=((re::DynamicString *)v214, (re::DynamicString *)&v226[8]);
      v37 = 2;
      goto LABEL_51;
    }
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v211);
    re::TypeRegistry::typeInfo(*(re **)v212, (re **)v212, keys);
    v19 = (_anonymous_namespace_ *)re::TypeInfo::TypeInfo((uint64_t)&v216, (uint64_t)&keys[1]);
    if (LOBYTE(keys[0]))
    {
      LOBYTE(values[0]) = 1;
      v226[0] = 1;
      *(void **)&v226[8] = keys[1];
    }
    else
    {
      v28 = *((_QWORD *)&v231 + 1);
      v27 = v232;
      v30 = keys[3];
      v29 = v231;
      LOBYTE(values[0]) = 0;
      *(_OWORD *)(v4 + 40) = *(_OWORD *)&keys[1];
      *((_QWORD *)&v224 + 1) = v28;
      v225 = v27;
      values[3] = v30;
      *(_QWORD *)&v224 = v29;
      re::DynamicString::DynamicString((re::DynamicString *)keys, (const re::DynamicString *)&values[3]);
      v226[0] = 0;
      *(void **)&v226[8] = keys[0];
      *(void **)&v226[32] = keys[3];
      *(_OWORD *)(v4 + 112) = *(_OWORD *)(v4 + 200);
      if (v30 && (v29 & 1) != 0)
        (*(void (**)(void *, uint64_t))(*(_QWORD *)v30 + 40))(v30, v28);
    }
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v211);
    v25 = &v226[8];
    if (!v226[0])
      goto LABEL_49;
    re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(&v220, *(uint64_t *)&v226[8]);
    v20 = (_DWORD *)v220;
    v32 = *(_QWORD *)(v220 + 32);
    if ((v32 & 1) != 0)
      v33 = v32 >> 1;
    else
      v33 = v32 >> 1;
    if (!v33
      || ((v34 = *(_QWORD *)(v220 + 64), (v34 & 1) != 0) ? (v35 = v34 >> 1) : (v35 = v34 >> 1),
          !v35 || !*(_DWORD *)(v220 + 88) || (v36 = *(_DWORD *)(v220 + 96), v36 < 1)))
    {
      v37 = 3;
      goto LABEL_51;
    }
    if (v36 < 0xD)
    {
      if (*(_DWORD *)(v220 + 100))
      {
        valuePtr = *(_DWORD *)(v220 + 100);
        v37 = 21;
        goto LABEL_51;
      }
      CFRelease(*(CFTypeRef *)&v227[8]);
      v196 = v20[38];
      if (v196 == 3)
      {
LABEL_366:
        v197 = "macOS";
      }
      else
      {
        if (v196 != 4)
        {
          v198 = v20 + 2;
          v21 = 1;
          goto LABEL_78;
        }
        v197 = "visionOS";
      }
      re::DynamicString::format((re::DynamicString *)"Cannot load reality file using OS '%s' because the reality file may only be opened on platform '%s'.", (re::DynamicString *)keys, "iOS", v197);
      v65 = 15;
      goto LABEL_106;
    }
    valuePtr = *(_DWORD *)(v220 + 96);
    v37 = 8;
LABEL_51:
    v38 = *(const __CFData **)&v227[8];
    v39 = atomic_load((unsigned __int8 *)&qword_2540FBB48);
    if ((v39 & 1) == 0)
    {
      v31 = (_anonymous_namespace_ *)__cxa_guard_acquire(&qword_2540FBB48);
      if ((_DWORD)v31)
      {
        qword_2540FBB40 = re::internal::getOrCreateInfo((re::internal *)"PrereleaseHeader", (uint64_t (*)(re::internal *))re::allocInfo_PrereleaseHeader, (re::IntrospectionBase *(*)(void))re::initInfo_PrereleaseHeader, (void (*)(re::IntrospectionBase *))&unk_2540FBA78, 0);
        __cxa_guard_release(&qword_2540FBB48);
      }
    }
    *(_OWORD *)v212 = *(_OWORD *)(qword_2540FBB40 + 32);
    if (!*(_QWORD *)v212)
    {
      v47 = (char)keys[1];
      v48 = keys[2];
      v49 = keys[0];
      if (!keys[0])
        goto LABEL_74;
      goto LABEL_72;
    }
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v211);
    re::TypeRegistry::typeInfo(*(re **)v212, (re **)v212, keys);
    v40 = (_anonymous_namespace_ *)re::TypeInfo::TypeInfo((uint64_t)&v216, (uint64_t)&keys[1]);
    if (LOBYTE(keys[0]))
    {
      v41 = keys[1];
      re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v211);
      if (v41)
        v42 = v41 + 1;
      v43 = v41[4];
      if ((v43 & 1) != 0)
        v44 = v43 >> 1;
      else
        v44 = v43 >> 1;
      if (v44)
      {
        v45 = v41[17];
        if ((v45 & 1) != 0 ? v45 >> 1 : v45 >> 1)
        {
          valuePtr = 0;
          v37 = 8;
        }
      }

      goto LABEL_74;
    }
    v50 = v6;
    v51 = *((_QWORD *)&v231 + 1);
    v53 = keys[3];
    v52 = v231;
    LOBYTE(values[0]) = 0;
    *(_OWORD *)&values[1] = *(_OWORD *)&keys[1];
    v225 = v232;
    values[3] = keys[3];
    v224 = v231;
    re::DynamicString::DynamicString((re::DynamicString *)keys, (const re::DynamicString *)&values[3]);
    v47 = (char)keys[1];
    v48 = keys[2];
    v49 = keys[0];
    if (v53 && (v52 & 1) != 0)
      (*(void (**)(void *, uint64_t))(*(_QWORD *)v53 + 40))(v53, v51);
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v211);
    v4 = (unint64_t)&v220;
    v6 = v50;
    v25 = &v226[8];
    if (v49)
    {
LABEL_72:
      if ((v47 & 1) != 0)
        (*(void (**)(void *, void *))(*(_QWORD *)v49 + 40))(v49, v48);
    }
LABEL_74:
    CFRelease(*(CFTypeRef *)&v227[8]);
    if (v37 == 21 || v37 == 8)
    {
      keys[0] = CFSTR("RERealityFileUnsupportedVersionKey");
      values[0] = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      v55 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      CFRelease(values[0]);
      re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), (const __CFString *)v37, (uint64_t)v55, &v216);
      v20 = v216;
      v216 = 0;

      goto LABEL_77;
    }
    if ((BYTE8(v214[0]) & 1) != 0)
      v64 = *(const char **)&v214[1];
    else
      v64 = (const char *)((unint64_t)v214 | 9);
    v65 = v37;
LABEL_106:
    v20 = values[0];
    values[0] = 0;

    if (keys[0] && ((uint64_t)keys[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)keys[0] + 40))();
LABEL_77:
    v21 = 0;
LABEL_78:
    if (v226[0])
    {
      if (*(_QWORD *)&v226[8])
      {

        *(_QWORD *)&v226[8] = 0;
      }
    }
    else if (*(_QWORD *)&v226[8])
    {
      if ((v226[16] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v226[8] + 40))();
      *v25 = 0u;
      v25[1] = 0u;
    }
  }
  v6 = (unint64_t)(v60 + 28);
  v3 = v60[12] + 104;
  v4 = 168 * v86;
  while (*(_QWORD *)(v3 - 88))
  {
    v87 = *(_QWORD *)(v3 - 72);
    v70 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::contains((uint64_t)values, v87);
    if ((v70 & 1) == 0)
    {
      if ((*(_BYTE *)(v87 + 8) & 1) != 0)
        v88 = *(const char **)(v87 + 16);
      else
        v88 = (const char *)(v87 + 9);
      if (*(_BYTE *)(v3 - 24))
      {
        if ((*(_BYTE *)(v3 - 8) & 1) != 0)
          v5 = *(_QWORD *)v3;
        else
          v5 = v3 - 7;
      }
      else
      {
        v5 = 0;
      }
      v89 = re::globalAllocators((re *)v70);
      v90 = (re::AssetDescriptor *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v89[2] + 32))(v89[2], 88, 8);
      keys[0] = re::AssetDescriptor::AssetDescriptor(v90, v88, (const char *)v5);
      re::DynamicArray<re::SharedPtr<re::internal::AssetReference>>::add((_anonymous_namespace_ *)(v60 + 23), keys);
      if (keys[0])

      v91 = *(_QWORD *)(v60[27] + 8 * v60[25] - 8);
      keys[0] = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v91 + 40))(v91);
      *(_QWORD *)v227 = v60[25] - 1;
      re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add((uint64_t)(v60 + 28), (char **)keys, v227);
      v92 = *(_QWORD *)(v60[27] + 8 * v60[25] - 8);
      keys[0] = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v92 + 32))(v92);
      *(_QWORD *)v227 = v60[25] - 1;
      re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add((uint64_t)(v60 + 34), (char **)keys, v227);
      v70 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)values, (re::DynamicString *)v87);
    }
    v3 += 168;
    v4 -= 168;
    if (!v4)
      goto LABEL_155;
  }
  v144 = keys[0];
  v212[0] = 0;
  *(_OWORD *)&v212[8] = *(_OWORD *)keys;
  *(void **)&v212[24] = keys[2];
  v213 = keys[3];
  v7 = v206;
  a3 = v207;
LABEL_326:
  re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)values, *(double *)&v144);
  if (v212[0])
  {
    v62 = (char *)*((_QWORD *)&v214[0] + 1);
    if (*((_QWORD *)&v214[0] + 1))
    {
      v191 = (id)(*((_QWORD *)&v214[0] + 1) + 8);
      v63 = 1;
      goto LABEL_330;
    }
    v63 = 1;
  }
  else
  {
    v62 = (char *)keys[0];
    keys[0] = 0;

    v63 = 0;
LABEL_330:
    if (!v212[0] && *(_QWORD *)&v212[8] && (v212[16] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)&v212[8] + 40))(*(_QWORD *)&v212[8], *(_QWORD *)&v212[24]);
  }
LABEL_335:
  if (LOBYTE(v214[0]))
  {
    if (*((_QWORD *)&v214[0] + 1))

  }
  else if (*((_QWORD *)&v214[0] + 1) && (v214[1] & 1) != 0)
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)&v214[0] + 1) + 40))(*((_QWORD *)&v214[0] + 1), *((_QWORD *)&v214[1] + 1));
  }
LABEL_341:
  if (!(_BYTE)v216 && cf && (v218 & 1) != 0)
    (*(void (**)(CFTypeRef, uint64_t))(*(_QWORD *)cf + 40))(cf, v219);
  if (v63)
  {
    v192 = *(char **)(v7 + 112);
    if (v192 != v62)
    {
      if (v62)
      {
        v193 = v62 + 8;
        v192 = *(char **)(v7 + 112);
      }
      if (v192)

      *(_QWORD *)(v7 + 112) = v62;
    }
    *(_BYTE *)a3 = 1;
    if (v62)

    if (v20)
LABEL_352:

  }
  else
  {
    v195 = v62;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v195;

    if (v20)
      goto LABEL_352;
  }
  return re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v208);
}

void re::RealityFile::makeByReadingBuffer(re::RealityFile *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v5;
  uint64_t v6;
  re::RealityFile *v7;
  uint64_t v8;
  id v9;
  uint64_t v10;
  id v11;
  uint64_t v12;
  id v13;
  uint64_t v14;

  if (*(_QWORD *)this)
  {
    v5 = re::globalAllocators(this);
    v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5[2] + 32))(v5[2], 136, 8);
    v7 = re::RealityFile::RealityFile((re::RealityFile *)v6, (id *)this);
    re::RealityFile::init(v7, v8, (uint64_t)&v12);
    if ((_BYTE)v12)
    {
      if (v6)
        v9 = (id)(v6 + 8);
      *(_BYTE *)a2 = 1;
      *(_QWORD *)(a2 + 8) = v6;
      if (!v6)
        return;
    }
    else
    {
      v11 = v13;
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = v11;

      if (!v6)
        return;
    }

    return;
  }
  v10 = v14;
  v14 = 0;
  *(_BYTE *)a2 = 0;
  *(_QWORD *)(a2 + 8) = v10;

  if (v12 && (v13 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v12 + 40))();
}

void re::RealityFile::verifyRealityFileIntegrityAtURL(re::RealityFile *this@<X0>, _BYTE *a2@<X8>)
{
  char v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (this)
  {
    re::RealityArchive::verifyRealityArchiveAtFilePath(this, (uint64_t)&v9);
    if ((_BYTE)v9)
    {
      v4 = (char)v10;
      *a2 = 1;
      a2[8] = v4;
      return;
    }
    v8 = v13;
    v13 = 0;
    *a2 = 0;
    *((_QWORD *)a2 + 1) = v8;

    if (!(_BYTE)v9)
    {
      v6 = v10;
      if (v10)
      {
        if ((v11 & 1) != 0)
        {
          v7 = v12;
          goto LABEL_7;
        }
      }
    }
  }
  else
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    re::DynamicString::setCapacity(&v9, 0);
    v5 = v13;
    v13 = 0;
    *a2 = 0;
    *((_QWORD *)a2 + 1) = v5;

    v6 = v9;
    if (v9 && (v10 & 1) != 0)
    {
      v7 = v11;
LABEL_7:
      (*(void (**)(uint64_t *, uint64_t))(*v6 + 40))(v6, v7);
    }
  }
}

unsigned __int8 *re::RealityFile::makeArchiveReader@<X0>(re::RealityFile *this@<X0>, uint64_t a2@<X8>)
{
  re::RealityArchive *v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  unsigned __int8 *result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = (re::RealityArchive *)*((_QWORD *)this + 16);
  if (v3)
  {
    re::RealityArchive::copy(v3, (uint64_t)&v8);
    if ((_BYTE)v8)
    {
      v4 = v9;
      v9 = 0;
      v5 = 1;
    }
    else
    {
      v4 = v10;
      v10 = 0;

      v5 = 0;
    }
    *(_BYTE *)a2 = v5;
    *(_QWORD *)(a2 + 8) = v4;
    return re::Result<re::SharedPtr<re::RealityArchive>,re::DynamicString>::~Result((unsigned __int8 *)&v8);
  }
  else
  {
    v6 = v10;
    v10 = 0;
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = v6;

    result = (unsigned __int8 *)v8;
    if (v8 && (v9 & 1) != 0)
      return (unsigned __int8 *)(*(uint64_t (**)(void))(*(_QWORD *)v8 + 40))();
  }
  return result;
}

uint64_t re::RealityFile::newDataByLoading@<X0>(re::RealityFile *this@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  id v6;
  uint64_t v7;
  uint64_t v9;
  _BYTE v10[8];
  uint64_t v11;
  char v12;
  _BYTE v13[8];
  id v14;

  re::RealityFile::makeArchiveReader(this, (uint64_t)v13);
  if (v13[0])
  {
    re::RealityArchive::newDataByLoadingEntryWithName((re::RealityArchive *)v14, a2, (uint64_t)v10);
    if (v10[0])
    {
      v5 = v11;
      *(_BYTE *)a3 = 1;
      *(_QWORD *)(a3 + 8) = v5;
    }
    else
    {
      v7 = v9;
      v9 = 0;
      *(_BYTE *)a3 = 0;
      *(_QWORD *)(a3 + 8) = v7;

      if (!v10[0] && v11 && (v12 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v11 + 40))();
    }
  }
  else
  {
    v6 = v14;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v6;
  }
  return re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v13);
}

uint64_t re::RealityFile::newDataByLoading@<X0>(re::RealityFile *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  char v10;
  _BYTE v11[23];
  uint64_t v12;

  if (a2)
  {
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v9, "assets/", v5);
    if ((v10 & 1) != 0)
      v6 = *(char **)&v11[7];
    else
      v6 = v11;
    re::RealityFile::newDataByLoading(a1, v6, a3);
  }
  else
  {
    v7 = v12;
    v12 = 0;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v7;

  }
  result = v9;
  if (v9)
  {
    if ((v10 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v9 + 40))();
  }
  return result;
}

uint64_t re::RealityFile::getInputStream@<X0>(re::RealityFile *this@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  re::RealityArchive *v6;
  const char *v7;
  re::RealityArchive *v8;
  uint64_t v9;
  _BYTE v11[8];
  CFTypeRef cf;
  char v13;
  _QWORD v14[4];
  uint64_t v15;
  _BYTE v16[216];
  int v17;
  unsigned int v18[54];
  int v19;
  unint64_t v20;
  unint64_t v21;
  _BYTE v22[8];
  re::RealityArchive *v23;
  char v24;

  re::RealityFile::makeArchiveReader(this, (uint64_t)v22);
  v6 = v23;
  if (v22[0])
  {
    v20 = 0;
    v21 = 0;
    if (re::RealityArchive::uncompressedEntryRange(v23, a2, &v21, &v20))
    {
      if ((*((_BYTE *)this + 32) & 1) != 0)
        v7 = (const char *)*((_QWORD *)this + 5);
      else
        v7 = (char *)this + 33;
      re::FileSeekableInputStream::FileSeekableInputStream((re::FileSeekableInputStream *)v14, v7, v21, v20);
      re::FileSeekableInputStream::FileSeekableInputStream((uint64_t)v16, (uint64_t)v14);
      v17 = 0;
      LOBYTE(v18[0]) = 0;
      v19 = -1;
      std::__variant_detail::__ctor<std::__variant_detail::__traits<re::FileSeekableInputStream,re::CFDataSeekableInputStream>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::FileSeekableInputStream,re::CFDataSeekableInputStream>,(std::__variant_detail::_Trait)1>>(v18, (uint64_t)v16);
      *(_BYTE *)a3 = 1;
      *(_BYTE *)(a3 + 8) = 0;
      *(_DWORD *)(a3 + 224) = -1;
      std::__variant_detail::__ctor<std::__variant_detail::__traits<re::FileSeekableInputStream,re::CFDataSeekableInputStream>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::FileSeekableInputStream,re::CFDataSeekableInputStream>,(std::__variant_detail::_Trait)1>>((unsigned int *)(a3 + 8), (uint64_t)v18);
      if (v19 != -1)
        off_24ED2D830[v19]((int)v11, (re::FileSeekableInputStream *)v18);
      v19 = -1;
      if (v17 != -1)
        off_24ED2D830[v17]((int)v11, (re::FileSeekableInputStream *)v16);
      v17 = -1;
      re::FileSeekableInputStream::~FileSeekableInputStream((re::FileSeekableInputStream *)v14);
    }
    else
    {
      re::RealityArchive::newDataByLoadingEntryWithName(v6, a2, (uint64_t)v11);
      if (v11[0])
      {
        re::CFDataSeekableInputStream::CFDataSeekableInputStream((re::CFDataSeekableInputStream *)v14, (CFDataRef)cf, 1, 0);
        CFRelease(cf);
        re::CFDataSeekableInputStream::CFDataSeekableInputStream((uint64_t)v16, (uint64_t)v14);
        v17 = 1;
        LOBYTE(v18[0]) = 0;
        v19 = -1;
        std::__variant_detail::__ctor<std::__variant_detail::__traits<re::FileSeekableInputStream,re::CFDataSeekableInputStream>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::FileSeekableInputStream,re::CFDataSeekableInputStream>,(std::__variant_detail::_Trait)1>>(v18, (uint64_t)v16);
        *(_BYTE *)a3 = 1;
        *(_BYTE *)(a3 + 8) = 0;
        *(_DWORD *)(a3 + 224) = -1;
        std::__variant_detail::__ctor<std::__variant_detail::__traits<re::FileSeekableInputStream,re::CFDataSeekableInputStream>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::FileSeekableInputStream,re::CFDataSeekableInputStream>,(std::__variant_detail::_Trait)1>>((unsigned int *)(a3 + 8), (uint64_t)v18);
        if (v19 != -1)
          off_24ED2D830[v19]((int)&v24, (re::FileSeekableInputStream *)v18);
        v19 = -1;
        if (v17 != -1)
          off_24ED2D830[v17]((int)&v24, (re::FileSeekableInputStream *)v16);
        v14[0] = &off_24ED7BEC0;
        re::CFDataSeekableInputStream::postDetachCleanup((re::CFDataSeekableInputStream *)v14);
        v14[0] = &off_24ED7BDD0;
        re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)&v15);
      }
      else
      {
        v9 = *(_QWORD *)v18;
        *(_QWORD *)v18 = 0;
        *(_BYTE *)a3 = 0;
        *(_QWORD *)(a3 + 8) = v9;

      }
      if (!v11[0] && cf && (v13 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)cf + 40))();
    }
  }
  else
  {
    v8 = v23;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v8;
  }
  return re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v22);
}

uint64_t re::RealityFile::getInputStream@<X0>(re::RealityFile *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  char v10;
  _BYTE v11[23];
  uint64_t v12;

  if (a2)
  {
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v9, "assets/", v5);
    if ((v10 & 1) != 0)
      v6 = *(char **)&v11[7];
    else
      v6 = v11;
    re::RealityFile::getInputStream(a1, v6, a3);
  }
  else
  {
    v7 = v12;
    v12 = 0;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v7;

  }
  result = v9;
  if (v9)
  {
    if ((v10 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v9 + 40))();
  }
  return result;
}

uint64_t re::RealityFile::findAssetDescriptorWithEntryName(re::RealityFile *this, char *a2)
{
  re::AssetMap *v2;
  uint64_t v3;
  uint64_t v5;

  v2 = (re::AssetMap *)*((_QWORD *)this + 14);
  if (!v2)
    return 0;
  re::AssetMap::assetDescriptorWithFileName(v2, a2, &v5);
  v3 = v5;
  if (v5)

  return v3;
}

unint64_t *re::AssetMap::assetDescriptorWithFileName@<X0>(re::AssetMap *this@<X0>, char *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t *result;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9[2];
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  unint64_t v15;
  __int16 v16;
  unint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v9[0] = a2;
  result = (unint64_t *)re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::tryGet((uint64_t)this + 224, v9);
  if (result)
  {
    v6 = *result;
    v7 = *((_QWORD *)this + 25);
    if (v7 <= *result)
    {
      v9[1] = 0;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v18 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v10 = 136315906;
      v11 = "operator[]";
      v12 = 1024;
      v13 = 797;
      v14 = 2048;
      v15 = v6;
      v16 = 2048;
      v17 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v8 = *(_QWORD *)(*((_QWORD *)this + 27) + 8 * v6);
    *a3 = v8;
    if (v8)
      return (unint64_t *)(id)(v8 + 8);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t re::RealityFile::findAssetDescriptorWithAssetName(re::RealityFile *this, char *a2)
{
  re::AssetMap *v2;
  uint64_t v3;
  uint64_t v5;

  v2 = (re::AssetMap *)*((_QWORD *)this + 14);
  if (!v2 || !*a2)
    return 0;
  re::AssetMap::assetDescriptorWithAssetName(v2, a2, &v5);
  v3 = v5;
  if (v5)

  return v3;
}

unint64_t *re::AssetMap::assetDescriptorWithAssetName@<X0>(re::AssetMap *this@<X0>, char *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t *result;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9[2];
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  unint64_t v15;
  __int16 v16;
  unint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v9[0] = a2;
  result = (unint64_t *)re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::tryGet((uint64_t)this + 272, v9);
  if (result)
  {
    v6 = *result;
    v7 = *((_QWORD *)this + 25);
    if (v7 <= *result)
    {
      v9[1] = 0;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v18 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v10 = 136315906;
      v11 = "operator[]";
      v12 = 1024;
      v13 = 797;
      v14 = 2048;
      v15 = v6;
      v16 = 2048;
      v17 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v8 = *(_QWORD *)(*((_QWORD *)this + 27) + 8 * v6);
    *a3 = v8;
    if (v8)
      return (unint64_t *)(id)(v8 + 8);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

re::SceneDescriptor *re::SceneDescriptor::SceneDescriptor(re::SceneDescriptor *this, const re::SceneDescriptor *a2)
{
  _anonymous_namespace_ *v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = off_24ED2D718;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 3, 0);
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 7, 0);
  *((_BYTE *)this + 88) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 8) = 0u;
  re::DynamicString::setCapacity((_QWORD *)this + 16, 0);
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_QWORD *)this + 20) = 0;
  re::DynamicString::operator=((re::SceneDescriptor *)((char *)this + 24), (const re::SceneDescriptor *)((char *)a2 + 24));
  re::DynamicString::operator=((re::SceneDescriptor *)((char *)this + 56), (const re::SceneDescriptor *)((char *)a2 + 56));
  re::Optional<re::DynamicString>::operator=((unsigned __int8 *)this + 88, (unsigned __int8 *)a2 + 88);
  re::DynamicArray<re::SceneCompatibilityVariant>::operator=((uint64_t)this + 160, (uint64_t *)a2 + 20);
  return this;
}

unsigned __int8 *re::Optional<re::DynamicString>::operator=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3;
  int v4;
  BOOL v5;
  BOOL v6;
  re::DynamicString *v7;
  BOOL v8;
  uint64_t v9;
  _OWORD *v10;

  v3 = *a1;
  v4 = *a2;
  if (*a1)
    v5 = 0;
  else
    v5 = v4 == 0;
  if (!v5)
  {
    if (*a1)
      v6 = v4 == 0;
    else
      v6 = 0;
    if (v6)
    {
      v10 = a1 + 8;
      v9 = *((_QWORD *)a1 + 1);
      if (v9)
      {
        if ((a1[16] & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *((_QWORD *)a1 + 3));
        *v10 = 0u;
        *(_OWORD *)(a1 + 24) = 0u;
      }
      *a1 = 0;
    }
    else
    {
      v7 = (re::DynamicString *)(a1 + 8);
      if (v3)
        v8 = 1;
      else
        v8 = v4 == 0;
      if (v8)
      {
        re::DynamicString::operator=(v7, (re::DynamicString *)(a2 + 8));
      }
      else
      {
        *a1 = 1;
        re::DynamicString::DynamicString(v7, (const re::DynamicString *)(a2 + 8));
      }
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::SceneCompatibilityVariant>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::SceneCompatibilityVariant>::copy(a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::SceneCompatibilityVariant>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::SceneCompatibilityVariant>::copy(a1, (uint64_t)a2);
    }
  }
  return a1;
}

BOOL re::SceneDescriptor::operator==(uint64_t a1, uint64_t a2)
{
  if (re::DynamicString::operator==(a1 + 24, a2 + 24) && re::DynamicString::operator==(a1 + 56, a2 + 56))
  {
    if (*(_BYTE *)(a1 + 88) && *(_BYTE *)(a2 + 88))
    {
      if (re::DynamicString::operator==(a1 + 96, a2 + 96))
        return re::DynamicArray<re::SceneCompatibilityVariant>::operator==(a1 + 160, a2 + 160);
    }
    else if (!(*(unsigned __int8 *)(a2 + 88) | *(unsigned __int8 *)(a1 + 88)))
    {
      return re::DynamicArray<re::SceneCompatibilityVariant>::operator==(a1 + 160, a2 + 160);
    }
  }
  return 0;
}

BOOL re::DynamicArray<re::SceneCompatibilityVariant>::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _DWORD *v3;
  _DWORD *v4;
  _DWORD *v5;
  _DWORD *v6;
  _DWORD *v7;
  _BOOL8 result;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 == *(_QWORD *)(a2 + 16))
  {
    if (!v2)
      return 1;
    v3 = *(_DWORD **)(a1 + 32);
    v4 = &v3[10 * v2];
    v5 = *(_DWORD **)(a2 + 32);
    while (*v3 == *v5)
    {
      v6 = v3 + 2;
      v7 = v5 + 2;
      result = re::DynamicString::operator==((uint64_t)(v3 + 2), (uint64_t)(v5 + 2));
      if (!result)
        return result;
      v3 = v6 + 8;
      v5 = v7 + 8;
      if (v6 + 8 == v4)
        return 1;
    }
  }
  return 0;
}

uint64_t re::SceneDescriptor::getName(re::SceneDescriptor *this)
{
  if ((*((_BYTE *)this + 64) & 1) != 0)
    return *((_QWORD *)this + 9);
  else
    return (uint64_t)this + 65;
}

uint64_t re::SceneDescriptor::getFileName(re::SceneDescriptor *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;
  int v7;

  if ((*((_BYTE *)this + 32) & 1) != 0)
    result = *((_QWORD *)this + 5);
  else
    result = (uint64_t)this + 33;
  v3 = *((_QWORD *)this + 22);
  if (v3)
  {
    v4 = (uint64_t *)(*((_QWORD *)this + 24) + 24);
    v5 = 40 * v3;
    v6 = -1;
    do
    {
      v7 = *((_DWORD *)v4 - 6);
      if (v7 <= 12 && v7 >= v6)
      {
        if ((*(_BYTE *)(v4 - 1) & 1) != 0)
          result = *v4;
        else
          result = (uint64_t)v4 - 7;
        v6 = *((_DWORD *)v4 - 6);
      }
      v4 += 5;
      v5 -= 40;
    }
    while (v5);
  }
  return result;
}

re::AssetDescriptor *re::AssetDescriptor::AssetDescriptor(re::AssetDescriptor *this, const char *a2, const char *a3)
{
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = off_24ED2D758;
  if (!a3)
    a3 = "";
  return this;
}

uint64_t re::AssetDescriptor::getName(re::AssetDescriptor *this)
{
  if ((*((_BYTE *)this + 64) & 1) != 0)
    return *((_QWORD *)this + 9);
  else
    return (uint64_t)this + 65;
}

uint64_t re::AssetDescriptor::getFileName(re::AssetDescriptor *this)
{
  if ((*((_BYTE *)this + 32) & 1) != 0)
    return *((_QWORD *)this + 5);
  else
    return (uint64_t)this + 33;
}

void re::AssetMap::~AssetMap(re::AssetMap *this)
{
  char *v2;

  *(_QWORD *)this = &off_24ED2D798;
  v2 = (char *)this + 24;
  re::FixedArray<re::FixedArray<re::DynamicString>>::deinit((_QWORD *)this + 52);
  re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit((uint64_t *)this + 46);
  re::HashTable<re::DynamicString,re::DynamicArray<re::SharedPtr<re::AssetDescriptorBase const>>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 40);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 34);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 28);
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)this + 184);
  re::FixedArray<re::RealityFileConfigurationEntryDescriptor>::deinit((_QWORD *)this + 20);
  re::FixedArray<re::DynamicString>::deinit((_QWORD *)this + 17);
  re::FixedArray<re::DynamicString>::deinit((_QWORD *)this + 14);
  re::DynamicArray<re::AssetMapAssetDescriptor>::deinit((uint64_t)this + 64);
  re::DynamicArray<re::SceneDescriptor>::deinit((uint64_t)v2);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::AssetMap::~AssetMap(this);
  JUMPOUT(0x2276933B8);
}

void re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add<unsigned long &>(uint64_t a1, char **a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  char v18;

  v6 = re::CaseInsensitiveStringHash::operator()((int)&v18, *a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v13 == 0x7FFFFFFF)
    {
      v13 = *(unsigned int *)(a1 + 32);
      v14 = v13;
      if ((_DWORD)v13 == *(_DWORD *)(a1 + 24))
      {
        re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
        LODWORD(v8) = v7 % *(unsigned int *)(a1 + 24);
        v14 = *(_DWORD *)(a1 + 32);
      }
      *(_DWORD *)(a1 + 32) = v14 + 1;
      v15 = *(_QWORD *)(a1 + 16);
      v16 = *(_DWORD *)(v15 + 32 * v13 + 8);
    }
    else
    {
      v15 = *(_QWORD *)(a1 + 16);
      v16 = *(_DWORD *)(v15 + 32 * v13 + 8);
      *(_DWORD *)(a1 + 36) = v16 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v15 + 32 * v13 + 8) = v16 | 0x80000000;
    *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v13 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v13 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8);
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v13) = v7;
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v13 + 16) = *a2;
    v17 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v13 + 24) = *a3;
    *(_DWORD *)(v17 + 4 * v8) = v13;
    ++*(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 40);
    return;
  }
  v10 = *(_QWORD *)(a1 + 16);
  v11 = *a2;
  while (1)
  {
    v12 = v10 + 32 * v9;
    if (!strcasecmp(*(const char **)(v12 + 16), v11))
      break;
    v9 = *(_DWORD *)(v12 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

uint64_t re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add(uint64_t a1, char **a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t result;
  char v14;

  v6 = re::CaseInsensitiveStringHash::operator()((int)&v14, *a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    result = re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::addAsMove(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return result;
  }
  v10 = *(_QWORD *)(a1 + 16);
  v11 = *a2;
  while (1)
  {
    v12 = v10 + 32 * v9;
    result = strcasecmp(*(const char **)(v12 + 16), v11);
    if (!(_DWORD)result)
      return result;
    v9 = *(_DWORD *)(v12 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

BOOL re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::contains(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  char v9;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v9, a2);
  v5 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v5)
    return 0;
  v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % v5));
  if ((_DWORD)v6 == 0x7FFFFFFF)
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  do
  {
    result = re::DynamicString::operator==(v8 + 48 * v6 + 16, a2);
    if (result)
      break;
    v6 = *(_DWORD *)(v8 + 48 * v6 + 8) & 0x7FFFFFFF;
  }
  while (v6 != 0x7FFFFFFF);
  return result;
}

void re::AssetMap::assetDescriptorFromAssetsIndex(re::AssetMap *this, re::AssetMap *a2, unint64_t a3)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *((_QWORD *)a2 + 10);
  if (v4 <= a3)
  {
    re::DynamicString::format((re::DynamicString *)"Index %lu is not in bounds of the assetMap assets array, which has size %zu.", (re::DynamicString *)&v15, a3, v4);
  }
  else
  {
    v5 = *((_QWORD *)a2 + 12) + 168 * a3;
    if (*(_QWORD *)(v5 + 16))
    {
      v6 = *(_QWORD *)(v5 + 32);
      if ((*(_BYTE *)(v6 + 8) & 1) != 0)
        v7 = *(char **)(v6 + 16);
      else
        v7 = (char *)(v6 + 9);
      re::AssetMap::assetDescriptorWithFileName(a2, v7, &v14);
      v11 = v14;
      if (v14)
      {
        v12 = (id)(v14 + 8);
        *(_BYTE *)this = 1;
        *((_QWORD *)this + 1) = v11;

        return;
      }
      if ((*(_BYTE *)(v6 + 8) & 1) != 0)
        v13 = *(_QWORD *)(v6 + 16);
      else
        v13 = v6 + 9;
      re::DynamicString::format((re::DynamicString *)"No entry for fileName %s", (re::DynamicString *)&v15, v13);
    }
    else
    {
    }
  }
  v8 = v15;
  v9 = v16;
  v10 = v17;
  *(_BYTE *)this = 0;
  *(_OWORD *)((char *)this + 8) = v8;
  *((_QWORD *)this + 3) = v9;
  *((_QWORD *)this + 4) = v10;
}

unint64_t re::Hash<re::Slice<re::DynamicString>>::operator()(uint64_t a1, uint64_t *a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  char v7;

  if (!a2[1])
    return 0;
  v3 = re::Hash<re::DynamicString>::operator()((uint64_t)&v7, *a2);
  if ((unint64_t)a2[1] >= 2)
  {
    v4 = 1;
    v5 = 32;
    do
    {
      v3 ^= (v3 << 6)
          + (v3 >> 2)
          - 0x61C8864680B583E9
          + re::Hash<re::DynamicString>::operator()((uint64_t)&v7, *a2 + v5);
      ++v4;
      v5 += 32;
    }
    while (v4 < a2[1]);
  }
  return v3;
}

uint64_t re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::tryGet(uint64_t a1, char **a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  char v10;

  v4 = re::CaseInsensitiveStringHash::operator()((int)&v10, *a2);
  if (!*(_QWORD *)a1)
    return 0;
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *a2;
  while (1)
  {
    v8 = v6 + 32 * v5;
    if (!strcasecmp(*(const char **)(v8 + 16), v7))
      break;
    v5 = *(_DWORD *)(v8 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF)
      return 0;
  }
  return v8 + 24;
}

uint64_t re::AssetMap::assetDependenciesWithFileName(re::AssetMap *this, const char *a2)
{
  char *v3;
  uint64_t v4;
  uint64_t v6;
  char v7;

  v3 = (char *)this + 320;
  v4 = re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v3, (uint64_t)&v6);
  if (v6 && (v7 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v6 + 40))();
  return v4;
}

uint64_t re::AssetMap::metadataForFileName(re::AssetMap *this, const re::DynamicString *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 10);
  if (!v2)
    return 0;
  v4 = *((_QWORD *)this + 12) + 120;
  v5 = 168 * v2;
  while (1)
  {
    if (!*(_QWORD *)(v4 - 104))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (re::DynamicString::operator==(*(_QWORD *)(v4 - 88), (uint64_t)a2))
      break;
    v4 += 168;
    v5 -= 168;
    if (!v5)
      return 0;
  }
  return v4;
}

_QWORD *re::AssetMap::assetDescriptorFromConfigurationNames@<X0>(_QWORD *result@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7[2];
  char v8;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4 == result[15]
    && (v5 = result,
        v7[0] = *(_QWORD *)(a2 + 16),
        v7[1] = v4,
        v7[0] = re::Hash<re::Slice<re::DynamicString>>::operator()((uint64_t)&v8, v7),
        (result = (_QWORD *)re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::tryGet((uint64_t)(v5 + 46), v7)) != 0))
  {
    v6 = *result;
    *a3 = *result;
    if (v6)
      return (id)(v6 + 8);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + 56 * v4 + 16) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 56 * v4 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v4 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v6 + 56 * v4 + 16) == v2)
        return v6 + 56 * v4 + 24;
    }
    return 0;
  }
  return v6 + 56 * v4 + 24;
}

void re::SceneDescriptor::~SceneDescriptor(re::SceneDescriptor *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = off_24ED2D718;
  re::DynamicArray<re::SceneCompatibilityVariant>::deinit((uint64_t)this + 160);
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {
    if ((*((_BYTE *)this + 136) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 18));
    *((_OWORD *)this + 8) = 0u;
    *((_OWORD *)this + 9) = 0u;
  }
  if (*((_BYTE *)this + 88))
  {
    v3 = *((_QWORD *)this + 12);
    if (v3)
    {
      if ((*((_BYTE *)this + 104) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 14));
      *((_OWORD *)this + 6) = 0u;
      *((_OWORD *)this + 7) = 0u;
    }
  }
  v4 = *((_QWORD *)this + 7);
  if (v4)
  {
    if ((*((_BYTE *)this + 64) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 9));
    *(_OWORD *)((char *)this + 56) = 0u;
    *(_OWORD *)((char *)this + 72) = 0u;
  }
  v5 = *((_QWORD *)this + 3);
  if (v5)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 5));
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = off_24ED2D718;
  re::DynamicArray<re::SceneCompatibilityVariant>::deinit((uint64_t)this + 160);
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {
    if ((*((_BYTE *)this + 136) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 18));
    *((_OWORD *)this + 8) = 0u;
    *((_OWORD *)this + 9) = 0u;
  }
  if (*((_BYTE *)this + 88))
  {
    v3 = *((_QWORD *)this + 12);
    if (v3)
    {
      if ((*((_BYTE *)this + 104) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 14));
      *((_OWORD *)this + 6) = 0u;
      *((_OWORD *)this + 7) = 0u;
    }
  }
  v4 = *((_QWORD *)this + 7);
  if (v4)
  {
    if ((*((_BYTE *)this + 64) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 9));
    *(_OWORD *)((char *)this + 56) = 0u;
    *(_OWORD *)((char *)this + 72) = 0u;
  }
  v5 = *((_QWORD *)this + 3);
  if (v5)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 5));
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::AssetDescriptor::~AssetDescriptor(re::AssetDescriptor *this)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;

  *(_QWORD *)this = off_24ED2D758;
  v3 = (_OWORD *)((char *)this + 56);
  v2 = *((_QWORD *)this + 7);
  if (v2)
  {
    if ((*((_BYTE *)this + 64) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 9));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *((_QWORD *)this + 3);
  if (v4)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 5));
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;

  *(_QWORD *)this = off_24ED2D758;
  v3 = (_OWORD *)((char *)this + 56);
  v2 = *((_QWORD *)this + 7);
  if (v2)
  {
    if ((*((_BYTE *)this + 64) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 9));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *((_QWORD *)this + 3);
  if (v4)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 5));
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2re23FileSeekableInputStreamENS8_25CFDataSeekableInputStreamEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_EEEEEEDcSE_DpT0_(int a1, re::FileSeekableInputStream *this)
{
  re::FileSeekableInputStream::~FileSeekableInputStream(this);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2re23FileSeekableInputStreamENS8_25CFDataSeekableInputStreamEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_EEEEEEDcSE_DpT0_(int a1, re::CFDataSeekableInputStream *this)
{
  *(_QWORD *)this = &off_24ED7BEC0;
  re::CFDataSeekableInputStream::postDetachCleanup(this);
  *(_QWORD *)this = &off_24ED7BDD0;
  return re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)this + 32);
}

void re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  __n128 v6;
  uint64_t v7;
  __n128 *v8;
  int v9;
  uint64_t v10;
  __n128 *v11;
  uint64_t v12;
  int v13;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_138, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 0;
      v6 = 0uLL;
      do
      {
        v7 = *(_QWORD *)(a1 + 16);
        v8 = (__n128 *)(v7 + v4);
        v9 = *(_DWORD *)(v7 + v4 + 8);
        if (v9 < 0)
        {
          v8->n128_u32[2] = v9 & 0x7FFFFFFF;
          v12 = v8[1].n128_i64[0];
          v11 = v8 + 1;
          v10 = v12;
          if (v12)
          {
            if ((*(_BYTE *)(v7 + v4 + 24) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v10 + 40))(v10, *(_QWORD *)(v7 + v4 + 32), v6);
              v6 = 0uLL;
            }
            *v11 = v6;
            v11[1] = v6;
            v3 = *(unsigned int *)(a1 + 32);
          }
        }
        ++v5;
        v4 += 48;
      }
      while (v5 < v3);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v13 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v13;
  }
}

uint64_t re::make::shared::unsafelyInplace<re::PrereleaseHeader>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;
  _anonymous_namespace_ *v8;

  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  v2 = (_QWORD *)(a1 + 128);
  *(_OWORD *)(a1 + 96) = 0u;
  v3 = (_QWORD *)(a1 + 96);
  *(_OWORD *)(a1 + 64) = 0u;
  v4 = (_QWORD *)(a1 + 64);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = off_24ED2D850;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)(a1 + 24), 0);
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)v4 = 0u;
  v7 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v4, 0);
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)v3 = 0u;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v3, 0);
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)v2 = 0u;
  re::DynamicString::setCapacity(v2, 0);
  return a1;
}

void re::PrereleaseHeader::~PrereleaseHeader(re::PrereleaseHeader *this)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  *(_QWORD *)this = off_24ED2D850;
  v3 = (_OWORD *)((char *)this + 128);
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {
    if ((*((_BYTE *)this + 136) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 18));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *((_QWORD *)this + 12);
  v5 = (_QWORD *)((char *)this + 64);
  if (v4)
  {
    if ((*((_BYTE *)this + 104) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 14));
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
  }
  if (*v5)
  {
    if ((*((_BYTE *)this + 72) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, *((_QWORD *)this + 10));
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)this + 5) = 0u;
  }
  v6 = *((_QWORD *)this + 3);
  if (v6)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)this + 5));
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  *(_QWORD *)this = off_24ED2D850;
  v3 = (_OWORD *)((char *)this + 128);
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {
    if ((*((_BYTE *)this + 136) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 18));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *((_QWORD *)this + 12);
  v5 = (_QWORD *)((char *)this + 64);
  if (v4)
  {
    if ((*((_BYTE *)this + 104) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 14));
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
  }
  if (*v5)
  {
    if ((*((_BYTE *)this + 72) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, *((_QWORD *)this + 10));
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)this + 5) = 0u;
  }
  v6 = *((_QWORD *)this + 3);
  if (v6)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)this + 5));
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

id re::internal::defaultRetain<re::PrereleaseHeader>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::PrereleaseHeader>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{

}

void re::TypeBuilderHelper::registerOptional<re::DynamicString>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginOptionalType((uint64_t)v12, a2, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setOptionalAccessors((uint64_t)v12, (void *(*)(void *))re::TypeBuilderHelper::registerOptional<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (void (*)(void *, const void *))re::TypeBuilderHelper::registerOptional<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

re::IntrospectionOptionalBase *re::IntrospectionOptionalBase::IntrospectionOptionalBase(re::IntrospectionOptionalBase *this)
{
  _QWORD *v2;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)((char *)v2 + 22) = 0;
  v2[2] = 0;
  v2[4] = 0;
  v2[5] = 0xFFFFFFFFLL;
  *v2 = &off_24ED2DDF8;
  *((_QWORD *)this + 7) = 0;
  re::SerializedReference<re::IntrospectionBase const*>::reset(v2 + 6);
  return this;
}

_QWORD *re::IntrospectionOptional<re::DynamicString>::~IntrospectionOptional(_QWORD *a1)
{
  *a1 = &off_24ED2DDF8;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionOptional<re::DynamicString>::~IntrospectionOptional(_QWORD *a1)
{
  *a1 = &off_24ED2DDF8;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::IntrospectionOptionalBase::childInfoCount(re::IntrospectionOptionalBase *this)
{
  return 1;
}

uint64_t re::IntrospectionOptionalBase::childInfo(re::IntrospectionOptionalBase *this, uint64_t a2)
{
  uint64_t result;

  if (!a2)
    return *((_QWORD *)this + 6);
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Index out of range.", "index == 0", "childInfo", 1366);
  result = _os_crash();
  __break(1u);
  return result;
}

void re::IntrospectionOptional<re::DynamicString>::construct(uint64_t a1, _BYTE *a2)
{
  *a2 = 0;
}

uint64_t re::IntrospectionOptional<re::DynamicString>::hasValue(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

unsigned __int8 *re::IntrospectionOptional<re::DynamicString>::setHasValue(_anonymous_namespace_ *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *result;
  uint64_t *v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  __int128 v10;
  uint64_t v11;

  if (a3)
  {
    v6 = 0uLL;
    v7 = 0;
    re::DynamicString::setCapacity(&v5, 0);
    LOBYTE(v8) = 1;
    v9 = v5;
    v11 = v7;
    v10 = v6;
  }
  else
  {
    LOBYTE(v8) = 0;
  }
  result = re::Optional<re::DynamicString>::operator=(a2, &v8);
  if ((_BYTE)v8)
  {
    result = (unsigned __int8 *)v9;
    if (v9)
    {
      if ((v10 & 1) != 0)
        return (unsigned __int8 *)(*(uint64_t (**)(void))(*v9 + 40))();
    }
  }
  return result;
}

uint64_t re::IntrospectionOptional<re::DynamicString>::value(uint64_t a1, uint64_t a2)
{
  return a2 + 8;
}

{
  return a2 + 8;
}

void re::IntrospectionOptionalBase::~IntrospectionOptionalBase(re::IntrospectionOptionalBase *this)
{
  *(_QWORD *)this = &off_24ED2DDF8;
  re::SerializedReference<re::IntrospectionBase const*>::reset((_QWORD *)this + 6);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED2DDF8;
  re::SerializedReference<re::IntrospectionBase const*>::reset((_QWORD *)this + 6);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionOptionalBase::hasValue(re::IntrospectionOptionalBase *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "hasValue", 1358);
  _os_crash();
  __break(1u);
}

void re::IntrospectionOptionalBase::setHasValue(re::IntrospectionOptionalBase *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "setHasValue", 1359);
  _os_crash();
  __break(1u);
}

void re::IntrospectionOptionalBase::value(re::IntrospectionOptionalBase *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "value", 1360);
  _os_crash();
  __break(1u);
}

{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "value", 1361);
  _os_crash();
  __break(1u);
}

unsigned __int8 *re::TypeBuilderHelper::registerOptional<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(unsigned __int8 *a1)
{
  unsigned __int8 *result;
  int v2;

  v2 = *a1;
  result = a1 + 8;
  if (!v2)
    return 0;
  return result;
}

unsigned __int8 *re::TypeBuilderHelper::registerOptional<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke(unsigned __int8 *a1, const re::DynamicString *a2)
{
  unsigned __int8 *result;
  uint64_t v4;
  unsigned __int8 *v5;
  char v6;

  if (a2)
  {
    LOBYTE(v4) = 1;
    re::DynamicString::DynamicString((re::DynamicString *)&v5, a2);
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  result = re::Optional<re::DynamicString>::operator=(a1, &v4);
  if ((_BYTE)v4)
  {
    result = v5;
    if (v5)
    {
      if ((v6 & 1) != 0)
        return (unsigned __int8 *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
    }
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::SceneCompatibilityVariant>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::SceneCompatibilityVariant>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::SceneCompatibilityVariant>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::SceneCompatibilityVariant>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::SceneCompatibilityVariant>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::SceneCompatibilityVariant>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::SceneCompatibilityVariant>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

_anonymous_namespace_ *re::IntrospectionDynamicArray<re::SceneCompatibilityVariant>::resize(_anonymous_namespace_ *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _anonymous_namespace_ *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = (_anonymous_namespace_ *)re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::SceneCompatibilityVariant>::resize((_anonymous_namespace_ *)a4, a5);
  }
  else
  {
    result = (_anonymous_namespace_ *)re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::SceneCompatibilityVariant>::addElement(re::Allocator **a1, re *a2, int a3, _anonymous_namespace_ *a4)
{
  double v8;
  re::IntrospectionBase *v9;
  uint64_t v11;
  uint64_t *v12;
  __int128 v13;
  uint64_t v14;

  v14 = 0;
  v11 = 0;
  v13 = 0u;
  re::DynamicString::setCapacity(&v12, 0);
  v8 = re::DynamicArray<re::SceneCompatibilityVariant>::add(a4, (uint64_t)&v11);
  if (v12 && (v13 & 1) != 0)
    (*(void (**)(double))(*v12 + 40))(v8);
  v9 = (re::IntrospectionBase *)(*((_QWORD *)a4 + 4) + 40 * *((_QWORD *)a4 + 2) - 40);
  re::introspectionInitElement(a2, a3, a1[6], v9);
  return v9;
}

uint64_t re::IntrospectionDynamicArray<re::SceneCompatibilityVariant>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::SceneCompatibilityVariant>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 40 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 40 * a3;
}

_anonymous_namespace_ *re::DynamicArray<re::SceneCompatibilityVariant>::resize(_anonymous_namespace_ *result, unint64_t a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __n128 v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = result;
  v4 = *((_QWORD *)result + 2);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = 40 * a2;
    v9 = 0uLL;
    v10 = a2;
    do
    {
      v11 = *((_QWORD *)v3 + 4);
      v12 = v11 + v8 + 8;
      result = *(_anonymous_namespace_ **)v12;
      if (*(_QWORD *)v12)
      {
        if ((*(_BYTE *)(v11 + v8 + 16) & 1) != 0)
        {
          result = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, _QWORD, __n128))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v11 + v8 + 24), v9);
          v9 = 0uLL;
        }
        *(__n128 *)v12 = v9;
        *(__n128 *)(v12 + 16) = v9;
        v4 = *((_QWORD *)v3 + 2);
      }
      ++v10;
      v8 += 40;
    }
    while (v10 < v4);
  }
  else
  {
    if (*((_QWORD *)result + 1) < a2)
    {
      result = (_anonymous_namespace_ *)re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity(result, a2);
      v4 = *((_QWORD *)v3 + 2);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 40 * v4;
      do
      {
        v7 = *((_QWORD *)v3 + 4) + v6;
        *(_DWORD *)v7 = 0;
        *(_OWORD *)(v7 + 24) = 0u;
        *(_OWORD *)(v7 + 8) = 0u;
        v7 += 8;
        result = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)v7, 0);
        v6 += 40;
        --v5;
      }
      while (v5);
    }
  }
  *((_QWORD *)v3 + 2) = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::SceneCompatibilityVariant>::clear((_QWORD *)a1);
  }
  else
  {
    re::DynamicArray<re::SceneCompatibilityVariant>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  v8 = re::DynamicArray<re::SceneCompatibilityVariant>::resize((_anonymous_namespace_ *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = 40 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 40;
        v11 -= 40;
      }
      while (v11);
    }
  }
}

_QWORD *re::DynamicArray<re::SceneCompatibilityVariant>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __n128 v5;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = result[4] + 16;
    v4 = 40 * v2;
    v5 = 0uLL;
    do
    {
      result = *(_QWORD **)(v3 - 8);
      if (result)
      {
        if ((*(_BYTE *)v3 & 1) != 0)
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD, __n128))(*result + 40))(result, *(_QWORD *)(v3 + 8), v5);
          v5 = 0uLL;
        }
        *(__n128 *)(v3 - 8) = v5;
        *(__n128 *)(v3 + 8) = v5;
      }
      v3 += 40;
      v4 -= 40;
    }
    while (v4);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 40 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 40 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SceneCompatibilityVariant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

id re::internal::defaultRetain<re::SceneDescriptor>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::SceneDescriptor>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{

}

void re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionDynamicArray<re::DynamicString>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::DynamicString>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::DynamicString>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::DynamicString>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::DynamicString>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::DynamicString>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::DynamicString>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::DynamicString>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

_anonymous_namespace_ *re::IntrospectionDynamicArray<re::DynamicString>::resize(_anonymous_namespace_ *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _anonymous_namespace_ *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicString>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::DynamicString>::resize((_anonymous_namespace_ *)a4, a5);
  }
  else
  {
    result = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicString>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::DynamicString>::addElement(re::Allocator **a1, re *a2, int a3, _anonymous_namespace_ *a4)
{
  double v8;
  re::IntrospectionBase *v9;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v12 = 0;
  v13 = 0;
  v14 = 0;
  re::DynamicString::setCapacity(&v11, 0);
  v8 = re::DynamicArray<re::DynamicString>::add(a4, &v11);
  if (v11 && (v12 & 1) != 0)
    (*(void (**)(double))(*v11 + 40))(v8);
  v9 = (re::IntrospectionBase *)(*((_QWORD *)a4 + 4) + 32 * *((_QWORD *)a4 + 2) - 32);
  re::introspectionInitElement(a2, a3, a1[6], v9);
  return v9;
}

uint64_t re::IntrospectionDynamicArray<re::DynamicString>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::DynamicString>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 32 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 32 * a3;
}

_anonymous_namespace_ *re::DynamicArray<re::DynamicString>::resize(_anonymous_namespace_ *result, unint64_t a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __n128 v9;
  unint64_t v10;
  uint64_t v11;
  __n128 *v12;

  v3 = result;
  v4 = *((_QWORD *)result + 2);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = 32 * a2;
    v9 = 0uLL;
    v10 = a2;
    do
    {
      v11 = *((_QWORD *)v3 + 4);
      v12 = (__n128 *)(v11 + v8);
      result = *(_anonymous_namespace_ **)(v11 + v8);
      if (result)
      {
        if ((v12->n128_u8[8] & 1) != 0)
        {
          result = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, _QWORD, __n128))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v11 + v8 + 16), v9);
          v9 = 0uLL;
        }
        *v12 = v9;
        v12[1] = v9;
        v4 = *((_QWORD *)v3 + 2);
      }
      ++v10;
      v8 += 32;
    }
    while (v10 < v4);
  }
  else
  {
    if (*((_QWORD *)result + 1) < a2)
    {
      result = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicString>::setCapacity(result, a2);
      v4 = *((_QWORD *)v3 + 2);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 32 * v4;
      do
      {
        v7 = *((_QWORD *)v3 + 4) + v6;
        *(_OWORD *)v7 = 0u;
        *(_OWORD *)(v7 + 16) = 0u;
        result = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)v7, 0);
        v6 += 32;
        --v5;
      }
      while (v5);
    }
  }
  *((_QWORD *)v3 + 2) = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::DynamicString>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  char v4;

  re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()((uint64_t)&v4, a1, a2, a3, a4);
}

void re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, re::Allocator *a4, unint64_t a5)
{
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  if (*(re::Allocator **)a2 == a4)
  {
    re::DynamicArray<re::DynamicString>::clear((_QWORD *)a2);
  }
  else
  {
    re::DynamicArray<re::DynamicString>::deinit(a2);
    *(_QWORD *)a2 = a4;
    re::DynamicArray<re::DynamicString>::setCapacity((_QWORD *)a2, a5);
    ++*(_DWORD *)(a2 + 24);
  }
  v9 = re::DynamicArray<re::DynamicString>::resize((_anonymous_namespace_ *)a2, a5);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a3, *(_QWORD *)(*(_QWORD *)(a3 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a2 + 16);
    if (v10)
    {
      v11 = *(char **)(a2 + 32);
      v12 = 32 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a4, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a4, 0);
        v11 += 32;
        v12 -= 32;
      }
      while (v12);
    }
  }
}

_QWORD *re::DynamicArray<re::DynamicString>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __n128 v5;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = result[4];
    v4 = 32 * v2;
    v5 = 0uLL;
    do
    {
      result = *(_QWORD **)v3;
      if (*(_QWORD *)v3)
      {
        if ((*(_BYTE *)(v3 + 8) & 1) != 0)
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD, __n128))(*result + 40))(result, *(_QWORD *)(v3 + 16), v5);
          v5 = 0uLL;
        }
        *(__n128 *)v3 = v5;
        *(__n128 *)(v3 + 16) = v5;
      }
      v3 += 32;
      v4 -= 32;
    }
    while (v4);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 32 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 32 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

void re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re *a1@<X0>, uint64_t *a2@<X1>, re **a3@<X2>, __int128 *a4@<X3>, re **a5@<X8>)
{
  uint64_t v10;
  re **v11;
  re *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  _anonymous_namespace_ *v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  const char *v23;
  int v24;
  _QWORD v25[2];
  __int128 v26;
  StringID v27;
  const char **v28;

  v10 = (uint64_t)a1 + 200;
  v11 = (re **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v11)
  {
    v12 = *v11;
    *a5 = a1;
    a5[1] = v12;
    return;
  }
  v22 = 0x449AD97C4B77BED4;
  v23 = "_CompareFunc";
  v13 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v10, &v22);
  if (v13)
  {
    v14 = *v13;
    re::StringID::destroyString((re::StringID *)&v22);
    if (a1)
    {
      v15 = (uint64_t)a1;
      goto LABEL_9;
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v22);
  }
  *(_QWORD *)&v27.var0 = 0x449AD97C4B77BED4;
  v27.var1 = "_CompareFunc";
  re::TypeRegistry::declareType((uint64_t)a1, 8, &v27, 1u, 0, &v22);
  v15 = v22;
  v14 = (uint64_t)v23;
  re::StringID::destroyString((re::StringID *)&v27);
LABEL_9:
  re::TypeRegistry::typeInfo(a1, a3, &v22);
  re::TypeInfo::TypeInfo((uint64_t)&v27, (uint64_t)&v23);
  if (!v15
    || (v16 = *v28,
        v22 = v14,
        v23 = v16,
        v24 = -1,
        (v17 = (_anonymous_namespace_ *)re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(*(_QWORD *)&v27.var0 + 768, &v22)) == 0)|| !*(_QWORD *)v17)
  {
    v26 = *(_OWORD *)a3;
    v25[0] = v15;
    v25[1] = v14;
    v17 = (_anonymous_namespace_ *)re::TypeRegistry::addAttribute((uint64_t)a1, &v26, -1, (uint64_t)v25, (uint64_t)re::internal::less<re::StringID>, 0);
  }
  v18 = *(_OWORD *)a3;
  v20 = *a4;
  v21 = v18;
  re::TypeBuilder::beginDictionaryType((uint64_t)&v22, a2, 1, 0x30uLL, 8uLL, &v21, &v20);
  re::TypeBuilder::setConstructor((uint64_t)&v22, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
  re::TypeBuilder::setDestructor((uint64_t)&v22, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
  re::TypeBuilder::setDictionaryAccessors((uint64_t)&v22, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#3}::__invoke, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
  re::TypeBuilder::setDictionaryIterator((uint64_t)&v22, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (BOOL (*)(void *))re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (const void *(*)(void *))re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#3}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#4}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
  re::TypeBuilder::commitTo((re::TypeBuilder *)&v22, a1, a5);
  re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v22, v19);
}

_QWORD *re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::~IntrospectionHashTable(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_24ED202D8;
  v2 = a1 + 6;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 8);
  re::SerializedReference<re::IntrospectionBase const*>::reset(v2);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::~IntrospectionHashTable(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_24ED202D8;
  v2 = a1 + 6;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 8);
  re::SerializedReference<re::IntrospectionBase const*>::reset(v2);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

double re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::construct(uint64_t a1, uint64_t a2)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_DWORD *)(a2 + 36) = 0x7FFFFFFF;
  return result;
}

double re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::destroy(uint64_t a1, uint64_t *a2)
{
  return re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(a2);
}

void re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  signed int v7;

  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(a2);
  if (a4 <= 3)
    v7 = 3;
  else
    v7 = a4;
  re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)a2, a3, v7);
}

void re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(uint64_t a1, uint64_t a2, unsigned int a3)
{
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a2, a3);
}

uint64_t re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::size(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 28);
}

void re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a2);
}

re::IntrospectionBase *re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4, StringID *a5)
{
  re::IntrospectionBase *v10;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v13 = 0;
  v14 = 0;
  v15 = 0;
  re::DynamicString::setCapacity(&v12, 0);
  v10 = (re::IntrospectionBase *)re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addOrReplace(a4, a5, (re::DynamicString *)&v12);
  if (v12 && (v13 & 1) != 0)
    (*(void (**)(void))(*v12 + 40))();
  re::introspectionInitElement(a2, a3, a1[8], v10);
  return v10;
}

uint64_t re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::iterate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t result;
  uint64_t v10;
  int v11;
  int v12;

  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = *(int **)(a2 + 16);
    while (1)
    {
      v8 = *v7;
      v7 += 14;
      if (v8 < 0)
        break;
      if (v5 == ++v6)
      {
        LODWORD(v6) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)v5 == (_DWORD)v6)
    return 1;
  v10 = v6;
  do
  {
    result = std::function<BOOL ()(void const*,void *)>::operator()(a3, *(_QWORD *)(a2 + 16) + 56 * v10 + 8, *(_QWORD *)(a2 + 16) + 56 * v10 + 24);
    if (!(_DWORD)result)
      break;
    v11 = *(_DWORD *)(a2 + 32) <= (v6 + 1) ? v6 + 1 : *(_DWORD *)(a2 + 32);
    while (1)
    {
      v10 = (v6 + 1);
      if (v11 - 1 == (_DWORD)v6)
        break;
      LODWORD(v6) = v6 + 1;
      v12 = v10;
      if ((*(_DWORD *)(*(_QWORD *)(a2 + 16) + 56 * v10) & 0x80000000) != 0)
        goto LABEL_18;
    }
    v12 = v11;
LABEL_18:
    LODWORD(v6) = v12;
  }
  while ((_DWORD)v5 != v12);
  return result;
}

void re::IntrospectionHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::destroyKey(int a1, re::StringID *this)
{
  re::StringID::destroyString(this);
}

void re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
  re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init(a1, a3, 3);
}

double re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t *a1)
{
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(a1);
  return re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(a1);
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(unsigned int *)(a1 + 28);
}

void re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *)#1}::__invoke(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (*a1 == a3)
  {
    re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear((uint64_t)a1);
  }
  else
  {
    re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(a1);
    re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)a1, a3, 3);
  }
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#3}::__invoke(uint64_t a1, _QWORD **a2, re::Allocator *a3, StringID *a4)
{
  void **Instance;
  uint64_t v9;
  _BYTE v11[32];
  _BYTE v12[8];
  _BYTE v13[32];

  re::TypeRegistry::typeInfo(*a2, a2[2][10], v12);
  re::TypeInfo::TypeInfo((uint64_t)v11, (uint64_t)v13);
  Instance = re::TypeInfo::createInstance((re::TypeInfo *)v11, a3, 0);
  v9 = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addOrReplace(a1, a4, (re::DynamicString *)Instance);
  re::TypeRegistry::typeInfo(*a2, a2[2][10], v12);
  re::TypeInfo::TypeInfo((uint64_t)v11, (uint64_t)v13);
  re::TypeInfo::releaseInstance((re::TypeInfo *)v11, Instance, a3, 0);
  return v9;
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 40, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 40);
  *(_BYTE *)(result + 16) = 0;
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  uint64_t result;

  v2 = *a1;
  if (*((_DWORD *)a1 + 2) == *(_DWORD *)(*a1 + 40))
  {
    v3 = *(unsigned int *)(v2 + 32);
    if (*((_BYTE *)a1 + 16))
    {
      v4 = *((_DWORD *)a1 + 8);
      if (v4 == (_DWORD)v3)
      {
        LODWORD(v5) = *(_DWORD *)(v2 + 32);
      }
      else
      {
        v8 = a1[3];
        v9 = *(_DWORD *)(v8 + 32);
        v10 = v4 + 1;
        do
        {
          LODWORD(v5) = v10;
          *((_DWORD *)a1 + 8) = v10;
          if (v10 >= v9)
            break;
          v11 = *(_DWORD *)(*(_QWORD *)(v8 + 16) + 56 * v10++);
        }
        while ((v11 & 0x80000000) == 0);
      }
    }
    else
    {
      v5 = 0;
      if ((_DWORD)v3)
      {
        v6 = *(int **)(v2 + 16);
        while (1)
        {
          v7 = *v6;
          v6 += 14;
          if (v7 < 0)
            break;
          if (v3 == ++v5)
          {
            LODWORD(v5) = *(_DWORD *)(v2 + 32);
            break;
          }
        }
      }
      *((_BYTE *)a1 + 16) = 1;
      a1[3] = v2;
      a1[4] = v5;
      LODWORD(v3) = *(_DWORD *)(v2 + 32);
    }
    return (_DWORD)v5 != (_DWORD)v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 583);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#3}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(*(_QWORD *)a1 + 40))
    return *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) + 56 * *(unsigned int *)(a1 + 32) + 8;
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 598);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#4}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(*(_QWORD *)a1 + 40))
    return *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) + 56 * *(unsigned int *)(a1 + 32) + 24;
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 607);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t result;

  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 40))
    return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)a2 + 40))(a2, a1);
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 616);
  result = _os_crash();
  __break(1u);
  return result;
}

void re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x18uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionFixedArray<re::DynamicString>::~IntrospectionFixedArray(_QWORD *a1)
{
  *a1 = &off_24ED20258;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionFixedArray<re::DynamicString>::~IntrospectionFixedArray(_QWORD *a1)
{
  *a1 = &off_24ED20258;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionFixedArray<re::DynamicString>::construct(uint64_t a1, _QWORD *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

_QWORD *re::IntrospectionFixedArray<re::DynamicString>::destroy(uint64_t a1, _QWORD *a2)
{
  return re::FixedArray<re::DynamicString>::deinit(a2);
}

void *re::IntrospectionFixedArray<re::DynamicString>::init(uint64_t a1, _QWORD *a2, re *a3, int a4, unint64_t a5)
{
  void *result;
  uint64_t v11;
  unint64_t v12;

  result = re::FixedArray<re::DynamicString>::init<>(a2, (uint64_t)a3, a5);
  if (a5)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      if (a2[1] <= v12)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      result = re::introspectionInitElement(a3, a4, *(re::Allocator **)(a1 + 48), (re::IntrospectionBase *)(a2[2] + v11));
      ++v12;
      v11 += 32;
    }
    while (a5 != v12);
  }
  return result;
}

_QWORD *re::IntrospectionFixedArray<re::DynamicString>::deinit(uint64_t a1, _QWORD *a2)
{
  return re::FixedArray<re::DynamicString>::deinit(a2);
}

uint64_t re::IntrospectionFixedArray<re::DynamicString>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 8);
}

BOOL re::IntrospectionFixedArray<re::DynamicString>::isInitialized(uint64_t a1, _QWORD *a2)
{
  return *a2 != 0;
}

uint64_t re::IntrospectionFixedArray<re::DynamicString>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 16) + 32 * a3;
}

{
  if (*(_QWORD *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 16) + 32 * a3;
}

_QWORD *re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(_QWORD *result, uint64_t a2, uint64_t a3)
{
  result[1] = 0;
  result[2] = 0;
  *result = a3;
  return result;
}

_QWORD *re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(_QWORD *a1)
{
  re::FixedArray<re::DynamicString>::deinit(a1);
  return re::FixedArray<re::DynamicString>::deinit(a1);
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(_QWORD *a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  re::FixedArray<re::DynamicString>::deinit(a1);
  v8 = (_anonymous_namespace_ *)re::FixedArray<re::DynamicString>::init<>(a1, (uint64_t)a3, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = a1[1];
    if (v9)
    {
      v10 = (char *)a1[2];
      v11 = 32 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 32;
        v11 -= 32;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 16) + 32 * a2;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1)
{
  int v1;
  uint64_t v2;
  unint64_t v3;

  v1 = a1[2];
  v2 = *(_QWORD *)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  if (v1 < (int)v3)
    a1[2] = ++v1;
  if (v3 <= v1)
    return 0;
  else
    return *(_QWORD *)(v2 + 16) + 32 * v1;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::DynamicString>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::SceneDescriptor>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::SceneDescriptor>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::SceneDescriptor>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::SceneDescriptor>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::SceneDescriptor>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::SceneDescriptor>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::SceneDescriptor>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::SceneDescriptor>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::SceneDescriptor>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::SceneDescriptor>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::SceneDescriptor>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::SceneDescriptor>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::SceneDescriptor>::addElement(uint64_t a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  re::IntrospectionBase *v9;
  _OWORD v11[6];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _OWORD v16[2];
  uint64_t v17;

  v17 = 0;
  memset(v16, 0, sizeof(v16));
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  memset(v11, 0, sizeof(v11));
  re::SceneDescriptor::SceneDescriptor((re::SceneDescriptor *)v11);
  v8 = *(_QWORD *)(a4 + 16);
  if (v8 >= *(_QWORD *)(a4 + 8))
  {
    re::DynamicArray<re::SceneDescriptor>::growCapacity((_QWORD *)a4, v8 + 1);
    v8 = *(_QWORD *)(a4 + 16);
  }
  re::SceneDescriptor::SceneDescriptor((re::SceneDescriptor *)(*(_QWORD *)(a4 + 32) + 200 * v8), (const re::SceneDescriptor *)v11);
  ++*(_QWORD *)(a4 + 16);
  ++*(_DWORD *)(a4 + 24);
  *(_QWORD *)&v11[0] = off_24ED2D718;
  re::DynamicArray<re::SceneCompatibilityVariant>::deinit((uint64_t)v16);
  if ((_QWORD)v14)
  {
    if ((BYTE8(v14) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v14 + 40))();
    v14 = 0u;
    v15 = 0u;
  }
  if (BYTE8(v11[5]) && (_QWORD)v12)
  {
    if ((BYTE8(v12) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v12 + 40))();
    v12 = 0u;
    v13 = 0u;
  }
  if (*((_QWORD *)&v11[3] + 1))
  {
    if ((v11[4] & 1) != 0)
      (*(void (**)(void))(**((_QWORD **)&v11[3] + 1) + 40))();
    memset((char *)&v11[3] + 8, 0, 32);
  }
  if (*((_QWORD *)&v11[1] + 1))
  {
    if ((v11[2] & 1) != 0)
      (*(void (**)(void))(**((_QWORD **)&v11[1] + 1) + 40))();
    memset((char *)&v11[1] + 8, 0, 32);
  }
  *(_QWORD *)&v11[0] = &off_24ED426B8;
  objc_destructInstance((char *)v11 + 8);
  v9 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 200 * *(_QWORD *)(a4 + 16) - 200);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v9);
  return v9;
}

uint64_t re::IntrospectionDynamicArray<re::SceneDescriptor>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::SceneDescriptor>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 200 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 200 * a3;
}

uint64_t re::DynamicArray<re::SceneDescriptor>::deinit(uint64_t a1)
{
  uint64_t result;
  void (***v3)(_QWORD);
  uint64_t v4;
  uint64_t v5;
  void (***v6)(_QWORD);
  void (**v7)(_QWORD);

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(void (****)(_QWORD))(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 200 * v4;
        v6 = *(void (****)(_QWORD))(a1 + 32);
        do
        {
          v7 = *v6;
          v6 += 25;
          (*v7)(v3);
          v3 = v6;
          v5 -= 200;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(void (****)(_QWORD))(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::SceneDescriptor>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = 200 * a2;
    v9 = a2;
    do
    {
      result = (_QWORD *)(**(uint64_t (***)(uint64_t))(v3[4] + v8))(v3[4] + v8);
      ++v9;
      v8 += 200;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::SceneDescriptor>::setCapacity(result, a2);
      v4 = v3[2];
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 200 * v4;
      do
      {
        v7 = v3[4] + v6;
        *(_QWORD *)(v7 + 192) = 0;
        *(_OWORD *)(v7 + 160) = 0u;
        *(_OWORD *)(v7 + 176) = 0u;
        *(_OWORD *)(v7 + 128) = 0u;
        *(_OWORD *)(v7 + 144) = 0u;
        *(_OWORD *)(v7 + 96) = 0u;
        *(_OWORD *)(v7 + 112) = 0u;
        *(_OWORD *)(v7 + 64) = 0u;
        *(_OWORD *)(v7 + 80) = 0u;
        *(_OWORD *)(v7 + 32) = 0u;
        *(_OWORD *)(v7 + 48) = 0u;
        *(_OWORD *)v7 = 0u;
        *(_OWORD *)(v7 + 16) = 0u;
        result = re::SceneDescriptor::SceneDescriptor((re::SceneDescriptor *)v7);
        v6 += 200;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::SceneDescriptor>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  void (***v10)(void);
  void (**v11)(void);
  _anonymous_namespace_ *v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  _BYTE v16[32];
  _BYTE v17[8];
  uint64_t v18;

  if (*(re::Allocator **)a1 == a3)
  {
    v8 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = 0;
    if (v8)
    {
      v9 = 200 * v8;
      v10 = *(void (****)(void))(a1 + 32);
      do
      {
        v11 = *v10;
        v10 += 25;
        (*v11)();
        v9 -= 200;
      }
      while (v9);
    }
  }
  else
  {
    re::DynamicArray<re::SceneDescriptor>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::SceneDescriptor>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v12 = (_anonymous_namespace_ *)re::DynamicArray<re::SceneDescriptor>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v17);
    re::TypeInfo::TypeInfo((uint64_t)v16, (uint64_t)&v18);
    v13 = *(_QWORD *)(a1 + 16);
    if (v13)
    {
      v14 = *(char **)(a1 + 32);
      v15 = 200 * v13;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v16, v14, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v16, (void **)v14, a3, 0);
        v14 += 200;
        v15 -= 200;
      }
      while (v15);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 200 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 200 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::SceneDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::AssetMapAssetDescriptor>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::AssetMapAssetDescriptor>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::AssetMapAssetDescriptor>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::AssetMapAssetDescriptor>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::AssetMapAssetDescriptor>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::AssetMapAssetDescriptor>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::AssetMapAssetDescriptor>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::AssetMapAssetDescriptor>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::AssetMapAssetDescriptor>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::AssetMapAssetDescriptor>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::AssetMapAssetDescriptor>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::AssetMapAssetDescriptor>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::AssetMapAssetDescriptor>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  __int128 v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __n128 v14;
  re::IntrospectionBase *v15;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  v8 = 0uLL;
  v27 = 0u;
  v26 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v19 = 0u;
  v9 = *((_QWORD *)this + 2);
  if (v9 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::AssetMapAssetDescriptor>::growCapacity(this, v9 + 1);
    v8 = 0uLL;
    v9 = *((_QWORD *)this + 2);
  }
  v10 = *((_QWORD *)this + 4) + 168 * v9;
  *(_OWORD *)v10 = v8;
  v17 = v8;
  *(_QWORD *)(v10 + 16) = 0;
  v18 = 0;
  *(_QWORD *)(v10 + 32) = 0;
  *((_QWORD *)&v19 + 1) = 0;
  LODWORD(v19) = 1;
  *(_DWORD *)(v10 + 24) = 1;
  *(_QWORD *)(v10 + 40) = 0;
  *(_OWORD *)(v10 + 48) = v8;
  *(_DWORD *)(v10 + 64) = 0;
  v20 = v8;
  v11 = *(_QWORD *)(v10 + 56);
  *(_QWORD *)(v10 + 56) = 0;
  *(_QWORD *)&v21 = v11;
  *(_QWORD *)(v10 + 72) = 0;
  *(_QWORD *)&v22 = 0;
  DWORD2(v21) = 1;
  ++*(_DWORD *)(v10 + 64);
  *(_BYTE *)(v10 + 80) = 0;
  *(_OWORD *)(v10 + 136) = v8;
  *(_DWORD *)(v10 + 152) = 0;
  *(_DWORD *)(v10 + 160) = 0;
  *(_QWORD *)(v10 + 120) = 0;
  *(_QWORD *)(v10 + 128) = 0;
  *(_QWORD *)&v25 = 0;
  v12 = *(_QWORD *)(v10 + 128);
  *(_QWORD *)(v10 + 128) = 0;
  *((_QWORD *)&v25 + 1) = v12;
  v13 = *(_QWORD *)(v10 + 136);
  *(_QWORD *)(v10 + 136) = 0;
  *(_QWORD *)&v26 = v13;
  LODWORD(v13) = *(_DWORD *)(v10 + 144);
  *(_DWORD *)(v10 + 144) = 0;
  DWORD2(v26) = v13;
  LODWORD(v13) = *(_DWORD *)(v10 + 148);
  *(_DWORD *)(v10 + 148) = 0;
  HIDWORD(v26) = v13;
  LODWORD(v13) = *(_DWORD *)(v10 + 152);
  *(_DWORD *)(v10 + 152) = 0;
  LODWORD(v27) = v13;
  *(_DWORD *)(v10 + 156) = 0x7FFFFFFF;
  DWORD1(v27) = 0x7FFFFFFF;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  v14.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v25);
  if (BYTE8(v22) && (_QWORD)v23)
  {
    if ((BYTE8(v23) & 1) != 0)
      (*(void (**)(double))(*(_QWORD *)v23 + 40))(v14.n128_f64[0]);
    v14 = 0uLL;
    v23 = 0u;
    v24 = 0u;
  }
  if ((_QWORD)v20)
  {
    if ((_QWORD)v22)
      (*(void (**)(__n128))(*(_QWORD *)v20 + 40))(v14);
    *(_QWORD *)&v22 = 0;
    *(_QWORD *)&v21 = 0;
    v20 = 0uLL;
    ++DWORD2(v21);
  }
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v17);
  v15 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 168 * *((_QWORD *)this + 2) - 168);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v15);
  return v15;
}

uint64_t re::IntrospectionDynamicArray<re::AssetMapAssetDescriptor>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::AssetMapAssetDescriptor>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 168 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 168 * a3;
}

uint64_t re::DynamicArray<re::AssetMapAssetDescriptor>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __n128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 0;
        v6 = 168 * v4;
        do
        {
          v7 = v3 + v5;
          v8.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(v3 + v5 + 120));
          if (*(_BYTE *)(v3 + v5 + 80))
          {
            v9 = *(_QWORD *)(v7 + 88);
            if (v9)
            {
              if ((*(_BYTE *)(v3 + v5 + 96) & 1) != 0)
                (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v9 + 40))(v9, *(_QWORD *)(v3 + v5 + 104), v8.n128_f64[0]);
              v8 = 0uLL;
              *(_OWORD *)(v7 + 88) = 0u;
              *(_OWORD *)(v7 + 104) = 0u;
            }
          }
          v10 = *(_QWORD *)(v7 + 40);
          if (v10)
          {
            v11 = v3 + v5;
            if (*(_QWORD *)(v3 + v5 + 72))
              (*(void (**)(uint64_t, __n128))(*(_QWORD *)v10 + 40))(v10, v8);
            *(_QWORD *)(v11 + 72) = 0;
            *(_QWORD *)(v7 + 48) = 0;
            *(_QWORD *)(v7 + 56) = 0;
            *(_QWORD *)(v7 + 40) = 0;
            ++*(_DWORD *)(v11 + 64);
          }
          re::DynamicArray<re::DynamicString>::deinit(v3 + v5);
          v5 += 168;
        }
        while (v6 != v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::AssetMapAssetDescriptor>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 v12;
  uint64_t v13;
  uint64_t v14;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = 168 * a2 + 64;
    v9 = a2;
    do
    {
      v10 = v3[4];
      v11 = v10 + v8;
      v12.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(v10 + v8 + 56));
      if (*(_BYTE *)(v10 + v8 + 16))
      {
        v13 = *(_QWORD *)(v11 + 24);
        if (v13)
        {
          if ((*(_BYTE *)(v10 + v8 + 32) & 1) != 0)
            (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v13 + 40))(v13, *(_QWORD *)(v10 + v8 + 40), v12.n128_f64[0]);
          v12 = 0uLL;
          *(_OWORD *)(v11 + 24) = 0u;
          *(_OWORD *)(v11 + 40) = 0u;
        }
      }
      v14 = *(_QWORD *)(v11 - 24);
      if (v14)
      {
        if (*(_QWORD *)(v10 + v8 + 8))
          (*(void (**)(uint64_t, __n128))(*(_QWORD *)v14 + 40))(v14, v12);
        *(_QWORD *)(v10 + v8 + 8) = 0;
        *(_QWORD *)(v11 - 16) = 0;
        *(_QWORD *)(v11 - 8) = 0;
        *(_QWORD *)(v11 - 24) = 0;
        ++*(_DWORD *)(v10 + v8);
      }
      result = (_QWORD *)re::DynamicArray<re::DynamicString>::deinit(v11 - 64);
      ++v9;
      v8 += 168;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::AssetMapAssetDescriptor>::setCapacity(result, a2);
      v4 = v3[2];
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 168 * v4;
      do
      {
        v7 = v3[4] + v6;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(_QWORD *)(v7 + 16) = 0;
        *(_QWORD *)(v7 + 72) = 0;
        *(_BYTE *)(v7 + 80) = 0;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_DWORD *)(v7 + 64) = 0;
        *(_OWORD *)(v7 + 152) = 0uLL;
        *(_OWORD *)(v7 + 120) = 0uLL;
        *(_OWORD *)(v7 + 136) = 0uLL;
        v6 += 168;
        *(_DWORD *)(v7 + 156) = 0x7FFFFFFF;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::AssetMapAssetDescriptor>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __n128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _anonymous_namespace_ *v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  _BYTE v21[32];
  _BYTE v22[8];
  uint64_t v23;

  if (*(re::Allocator **)a1 == a3)
  {
    v8 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = 0;
    if (v8)
    {
      v9 = 0;
      v10 = *(_QWORD *)(a1 + 32);
      v11 = 168 * v8;
      do
      {
        v12 = v10 + v9;
        v13.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(v10 + v9 + 120));
        if (*(_BYTE *)(v10 + v9 + 80))
        {
          v14 = *(_QWORD *)(v12 + 88);
          if (v14)
          {
            if ((*(_BYTE *)(v10 + v9 + 96) & 1) != 0)
              (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v14 + 40))(v14, *(_QWORD *)(v10 + v9 + 104), v13.n128_f64[0]);
            v13 = 0uLL;
            *(_OWORD *)(v12 + 88) = 0u;
            *(_OWORD *)(v12 + 104) = 0u;
          }
        }
        v15 = *(_QWORD *)(v12 + 40);
        if (v15)
        {
          v16 = v10 + v9;
          if (*(_QWORD *)(v10 + v9 + 72))
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v15 + 40))(v15, v13);
          *(_QWORD *)(v16 + 72) = 0;
          *(_QWORD *)(v12 + 48) = 0;
          *(_QWORD *)(v12 + 56) = 0;
          *(_QWORD *)(v12 + 40) = 0;
          ++*(_DWORD *)(v16 + 64);
        }
        re::DynamicArray<re::DynamicString>::deinit(v10 + v9);
        v9 += 168;
      }
      while (v11 != v9);
    }
  }
  else
  {
    re::DynamicArray<re::AssetMapAssetDescriptor>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::AssetMapAssetDescriptor>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v17 = (_anonymous_namespace_ *)re::DynamicArray<re::AssetMapAssetDescriptor>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v22);
    re::TypeInfo::TypeInfo((uint64_t)v21, (uint64_t)&v23);
    v18 = *(_QWORD *)(a1 + 16);
    if (v18)
    {
      v19 = *(char **)(a1 + 32);
      v20 = 168 * v18;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v21, v19, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v21, (void **)v19, a3, 0);
        v19 += 168;
        v20 -= 168;
      }
      while (v20);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 168 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 168 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::AssetMapAssetDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionFixedArray<re::RealityFileConfigurationEntryDescriptor>::~IntrospectionFixedArray(_QWORD *a1)
{
  *a1 = &off_24ED20258;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionFixedArray<re::RealityFileConfigurationEntryDescriptor>::~IntrospectionFixedArray(_QWORD *a1)
{
  *a1 = &off_24ED20258;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionFixedArray<re::RealityFileConfigurationEntryDescriptor>::construct(uint64_t a1, _QWORD *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

_QWORD *re::IntrospectionFixedArray<re::RealityFileConfigurationEntryDescriptor>::destroy(uint64_t a1, _QWORD *a2)
{
  return re::FixedArray<re::RealityFileConfigurationEntryDescriptor>::deinit(a2);
}

void re::IntrospectionFixedArray<re::RealityFileConfigurationEntryDescriptor>::init(uint64_t a1, uint64_t *a2, re *a3, int a4, unint64_t a5)
{
  uint64_t v10;
  unint64_t v11;

  re::FixedArray<re::RealityFileConfigurationEntryDescriptor>::init<>(a2, (uint64_t)a3, a5);
  if (a5)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      if (a2[1] <= v11)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      re::introspectionInitElement(a3, a4, *(re::Allocator **)(a1 + 48), (re::IntrospectionBase *)(a2[2] + v10));
      ++v11;
      v10 += 32;
    }
    while (a5 != v11);
  }
}

_QWORD *re::IntrospectionFixedArray<re::RealityFileConfigurationEntryDescriptor>::deinit(uint64_t a1, _QWORD *a2)
{
  return re::FixedArray<re::RealityFileConfigurationEntryDescriptor>::deinit(a2);
}

uint64_t re::IntrospectionFixedArray<re::RealityFileConfigurationEntryDescriptor>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 8);
}

BOOL re::IntrospectionFixedArray<re::RealityFileConfigurationEntryDescriptor>::isInitialized(uint64_t a1, _QWORD *a2)
{
  return *a2 != 0;
}

uint64_t re::IntrospectionFixedArray<re::RealityFileConfigurationEntryDescriptor>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 16) + 32 * a3;
}

{
  if (*(_QWORD *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 16) + 32 * a3;
}

_QWORD *re::FixedArray<re::RealityFileConfigurationEntryDescriptor>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = 32 * v2;
      v5 = (_QWORD *)(result[2] + 8);
      do
      {
        re::FixedArray<re::DynamicString>::deinit(v5);
        v5 += 4;
        v4 -= 32;
      }
      while (v4);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

_QWORD *re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(_QWORD *result, uint64_t a2, uint64_t a3)
{
  result[1] = 0;
  result[2] = 0;
  *result = a3;
  return result;
}

_QWORD *re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(_QWORD *a1)
{
  re::FixedArray<re::RealityFileConfigurationEntryDescriptor>::deinit(a1);
  return re::FixedArray<re::RealityFileConfigurationEntryDescriptor>::deinit(a1);
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t *a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  char v13[8];
  uint64_t v14;

  re::FixedArray<re::RealityFileConfigurationEntryDescriptor>::deinit(a1);
  re::FixedArray<re::RealityFileConfigurationEntryDescriptor>::init<>(a1, (uint64_t)a3, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = a1[1];
    if (v9)
    {
      v10 = (char *)a1[2];
      v11 = 32 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 32;
        v11 -= 32;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 16) + 32 * a2;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1)
{
  int v1;
  uint64_t v2;
  unint64_t v3;

  v1 = a1[2];
  v2 = *(_QWORD *)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  if (v1 < (int)v3)
    a1[2] = ++v1;
  if (v3 <= v1)
    return 0;
  else
    return *(_QWORD *)(v2 + 16) + 32 * v1;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::RealityFileConfigurationEntryDescriptor>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

double re::make::shared::unsafelyInplace<re::AssetMap>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double result;

  *(_QWORD *)(a1 + 432) = 0;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  v2 = a1 + 368;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v3 = a1 + 320;
  v4 = a1 + 272;
  *(_OWORD *)(a1 + 224) = 0u;
  v5 = a1 + 224;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24ED2D798;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 104) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_DWORD *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 244) = 0u;
  *(_QWORD *)(v5 + 36) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_DWORD *)(a1 + 304) = 0;
  *(_QWORD *)(v4 + 36) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_DWORD *)(a1 + 352) = 0;
  *(_QWORD *)(v3 + 36) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_DWORD *)(a1 + 400) = 0;
  *(_QWORD *)(v2 + 36) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 424) = 0;
  *(_QWORD *)(a1 + 432) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  return result;
}

id re::internal::defaultRetain<re::AssetMap>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::AssetMap>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{

}

uint64_t re::make::shared::unsafelyInplace<re::RealityFileHeader>(uint64_t a1)
{
  _anonymous_namespace_ *v2;
  _anonymous_namespace_ *v3;

  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = off_24ED2CCB0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)(a1 + 24), 0);
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  re::DynamicString::setCapacity((_QWORD *)(a1 + 56), 0);
  *(_DWORD *)(a1 + 88) = 2;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_DWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 140) = 0x7FFFFFFFLL;
  *(_DWORD *)(a1 + 152) = 0;
  return a1;
}

id re::internal::defaultRetain<re::RealityFileHeader>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::RealityFileHeader>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{

}

void re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re *a1@<X0>, uint64_t *a2@<X1>, re **a3@<X2>, __int128 *a4@<X3>, re **a5@<X8>)
{
  uint64_t v10;
  re **v11;
  re *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  _anonymous_namespace_ *v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  const char *v23;
  int v24;
  _QWORD v25[2];
  __int128 v26;
  StringID v27;
  const char **v28;

  v10 = (uint64_t)a1 + 200;
  v11 = (re **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v11)
  {
    v12 = *v11;
    *a5 = a1;
    a5[1] = v12;
    return;
  }
  v22 = 0x449AD97C4B77BED4;
  v23 = "_CompareFunc";
  v13 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v10, &v22);
  if (v13)
  {
    v14 = *v13;
    re::StringID::destroyString((re::StringID *)&v22);
    if (a1)
    {
      v15 = (uint64_t)a1;
      goto LABEL_9;
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v22);
  }
  *(_QWORD *)&v27.var0 = 0x449AD97C4B77BED4;
  v27.var1 = "_CompareFunc";
  re::TypeRegistry::declareType((uint64_t)a1, 8, &v27, 1u, 0, &v22);
  v15 = v22;
  v14 = (uint64_t)v23;
  re::StringID::destroyString((re::StringID *)&v27);
LABEL_9:
  re::TypeRegistry::typeInfo(a1, a3, &v22);
  re::TypeInfo::TypeInfo((uint64_t)&v27, (uint64_t)&v23);
  if (!v15
    || (v16 = *v28,
        v22 = v14,
        v23 = v16,
        v24 = -1,
        (v17 = (_anonymous_namespace_ *)re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(*(_QWORD *)&v27.var0 + 768, &v22)) == 0)|| !*(_QWORD *)v17)
  {
    v26 = *(_OWORD *)a3;
    v25[0] = v15;
    v25[1] = v14;
    v17 = (_anonymous_namespace_ *)re::TypeRegistry::addAttribute((uint64_t)a1, &v26, -1, (uint64_t)v25, (uint64_t)re::internal::less<re::DynamicString>, 0);
  }
  v18 = *(_OWORD *)a3;
  v20 = *a4;
  v21 = v18;
  re::TypeBuilder::beginDictionaryType((uint64_t)&v22, a2, 1, 0x30uLL, 8uLL, &v21, &v20);
  re::TypeBuilder::setConstructor((uint64_t)&v22, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
  re::TypeBuilder::setDestructor((uint64_t)&v22, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
  re::TypeBuilder::setDictionaryAccessors((uint64_t)&v22, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#3}::__invoke, (uint64_t)re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
  re::TypeBuilder::setDictionaryIterator((uint64_t)&v22, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (BOOL (*)(void *))re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (const void *(*)(void *))re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#3}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#4}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
  re::TypeBuilder::commitTo((re::TypeBuilder *)&v22, a1, a5);
  re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v22, v19);
}

_QWORD *re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::~IntrospectionHashTable(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_24ED202D8;
  v2 = a1 + 6;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 8);
  re::SerializedReference<re::IntrospectionBase const*>::reset(v2);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::~IntrospectionHashTable(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_24ED202D8;
  v2 = a1 + 6;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 8);
  re::SerializedReference<re::IntrospectionBase const*>::reset(v2);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

double re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::construct(uint64_t a1, uint64_t a2)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_DWORD *)(a2 + 36) = 0x7FFFFFFF;
  return result;
}

double re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::destroy(uint64_t a1, uint64_t *a2)
{
  return re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a2);
}

void re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  signed int v7;

  re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a2);
  if (a4 <= 3)
    v7 = 3;
  else
    v7 = a4;
  re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)a2, a3, v7);
}

void re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, uint64_t a2, unsigned int a3)
{
  re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a2, a3);
}

uint64_t re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::size(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 28);
}

void re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a2);
}

re::IntrospectionBase *re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addElement(uint64_t a1, re *a2, int a3, uint64_t a4, re::DynamicString *a5)
{
  re::IntrospectionBase *v8;
  _QWORD v10[3];
  int v11;
  uint64_t v12;

  v12 = 0;
  memset(v10, 0, sizeof(v10));
  v11 = 0;
  v8 = (re::IntrospectionBase *)re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace(a4, a5, (uint64_t)v10);
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)v10);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 64), v8);
  return v8;
}

uint64_t re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::iterate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t result;
  uint64_t v10;
  int v11;
  int v12;

  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = (int *)(*(_QWORD *)(a2 + 16) + 8);
    while (1)
    {
      v8 = *v7;
      v7 += 22;
      if (v8 < 0)
        break;
      if (v5 == ++v6)
      {
        LODWORD(v6) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)v5 == (_DWORD)v6)
    return 1;
  v10 = v6;
  do
  {
    result = std::function<BOOL ()(void const*,void *)>::operator()(a3, *(_QWORD *)(a2 + 16) + 88 * v10 + 16, *(_QWORD *)(a2 + 16) + 88 * v10 + 48);
    if (!(_DWORD)result)
      break;
    v11 = *(_DWORD *)(a2 + 32) <= (v6 + 1) ? v6 + 1 : *(_DWORD *)(a2 + 32);
    while (1)
    {
      v10 = (v6 + 1);
      if (v11 - 1 == (_DWORD)v6)
        break;
      LODWORD(v6) = v6 + 1;
      v12 = v10;
      if ((*(_DWORD *)(*(_QWORD *)(a2 + 16) + 88 * v10 + 8) & 0x80000000) != 0)
        goto LABEL_18;
    }
    v12 = v11;
LABEL_18:
    LODWORD(v6) = v12;
  }
  while ((_DWORD)v5 != v12);
  return result;
}

double re::IntrospectionHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::destroyKey(uint64_t a1, _QWORD *a2)
{
  double result;

  if (*a2)
  {
    if ((a2[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 40))(*a2, a2[2]);
    result = 0.0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
  }
  return result;
}

void re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_138, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + v3);
        ++v4;
        v3 += 88;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

uint64_t re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace(uint64_t a1, re::DynamicString *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char v14;

  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 88 * v11;
    return v12 + 48;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 88 * v9 + 16, (uint64_t)a2))
  {
    v9 = *(_DWORD *)(v10 + 88 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v10 + 88 * v9 + 48, a3);
  ++*(_DWORD *)(a1 + 40);
  v12 = *(_QWORD *)(a1 + 16) + 88 * v9;
  return v12 + 48;
}

void re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
  re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(a1, a3, 3);
}

double re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t *a1)
{
  re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a1);
  return re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a1);
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(unsigned int *)(a1 + 28);
}

void re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *)#1}::__invoke(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (*a1 == a3)
  {
    re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear((uint64_t)a1);
  }
  else
  {
    re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a1);
    re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)a1, a3, 3);
  }
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#3}::__invoke(uint64_t a1, _QWORD **a2, re::Allocator *a3, re::DynamicString *a4)
{
  void **Instance;
  uint64_t v9;
  _BYTE v11[32];
  _BYTE v12[8];
  _BYTE v13[32];

  re::TypeRegistry::typeInfo(*a2, a2[2][10], v12);
  re::TypeInfo::TypeInfo((uint64_t)v11, (uint64_t)v13);
  Instance = re::TypeInfo::createInstance((re::TypeInfo *)v11, a3, 0);
  v9 = re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace(a1, a4, (uint64_t)Instance);
  re::TypeRegistry::typeInfo(*a2, a2[2][10], v12);
  re::TypeInfo::TypeInfo((uint64_t)v11, (uint64_t)v13);
  re::TypeInfo::releaseInstance((re::TypeInfo *)v11, Instance, a3, 0);
  return v9;
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 40, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 40);
  *(_BYTE *)(result + 16) = 0;
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  uint64_t result;

  v2 = *a1;
  if (*((_DWORD *)a1 + 2) == *(_DWORD *)(*a1 + 40))
  {
    v3 = *(unsigned int *)(v2 + 32);
    if (*((_BYTE *)a1 + 16))
    {
      v4 = *((_DWORD *)a1 + 8);
      if (v4 == (_DWORD)v3)
      {
        LODWORD(v5) = *(_DWORD *)(v2 + 32);
      }
      else
      {
        v8 = a1[3];
        v9 = *(_DWORD *)(v8 + 32);
        v10 = v4 + 1;
        do
        {
          LODWORD(v5) = v10;
          *((_DWORD *)a1 + 8) = v10;
          if (v10 >= v9)
            break;
          v11 = *(_DWORD *)(*(_QWORD *)(v8 + 16) + 88 * v10++ + 8);
        }
        while ((v11 & 0x80000000) == 0);
      }
    }
    else
    {
      v5 = 0;
      if ((_DWORD)v3)
      {
        v6 = (int *)(*(_QWORD *)(v2 + 16) + 8);
        while (1)
        {
          v7 = *v6;
          v6 += 22;
          if (v7 < 0)
            break;
          if (v3 == ++v5)
          {
            LODWORD(v5) = *(_DWORD *)(v2 + 32);
            break;
          }
        }
      }
      *((_BYTE *)a1 + 16) = 1;
      a1[3] = v2;
      a1[4] = v5;
      LODWORD(v3) = *(_DWORD *)(v2 + 32);
    }
    return (_DWORD)v5 != (_DWORD)v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 583);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#3}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(*(_QWORD *)a1 + 40))
    return *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) + 88 * *(unsigned int *)(a1 + 32) + 16;
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 598);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#4}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(*(_QWORD *)a1 + 40))
    return *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) + 88 * *(unsigned int *)(a1 + 32) + 48;
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 607);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t result;

  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 40))
    return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)a2 + 40))(a2, a1);
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 616);
  result = _os_crash();
  __break(1u);
  return result;
}

unsigned __int8 *re::Result<re::SharedPtr<re::RealityArchive>,re::DynamicString>::~Result(unsigned __int8 *a1)
{
  int v2;
  uint64_t v3;
  unsigned __int8 *v4;

  v2 = *a1;
  v4 = a1 + 8;
  v3 = *((_QWORD *)a1 + 1);
  if (v2)
  {
    if (v3)
    {

      *(_QWORD *)v4 = 0;
    }
  }
  else if (v3)
  {
    if ((a1[16] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)a1 + 3));
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
  }
  return a1;
}

unsigned int *std::__variant_detail::__ctor<std::__variant_detail::__traits<re::FileSeekableInputStream,re::CFDataSeekableInputStream>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::FileSeekableInputStream,re::CFDataSeekableInputStream>,(std::__variant_detail::_Trait)1>>(unsigned int *result, uint64_t a2)
{
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;

  v3 = result;
  v4 = result[54];
  if ((_DWORD)v4 != -1)
    result = (unsigned int *)off_24ED2D830[v4]((int)&v7, (re::FileSeekableInputStream *)result);
  v3[54] = -1;
  v5 = *(unsigned int *)(a2 + 216);
  if ((_DWORD)v5 != -1)
  {
    result = (unsigned int *)((uint64_t (*)(char *, unsigned int *, uint64_t))off_24ED2DDD8[v5])(&v6, v3, a2);
    v3[54] = v5;
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re23FileSeekableInputStreamENS8_25CFDataSeekableInputStreamEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSQ_EEEDcSI_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return re::FileSeekableInputStream::FileSeekableInputStream(a2, a3);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re23FileSeekableInputStreamENS8_25CFDataSeekableInputStreamEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSQ_EEEDcSI_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return re::CFDataSeekableInputStream::CFDataSeekableInputStream(a2, a3);
}

double re::HashTable<re::DynamicString,re::DynamicArray<re::SharedPtr<re::AssetDescriptorBase const>>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicArray<re::SharedPtr<re::AssetDescriptorBase const>>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 88;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicArray<re::SharedPtr<re::AssetDescriptorBase const>>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  _OWORD *v4;

  v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    v2 = result;
    v4 = (_OWORD *)(result + 16);
    v3 = *(_QWORD *)(result + 16);
    *((_DWORD *)v4 - 2) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if ((*(_BYTE *)(v2 + 24) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(v2 + 32));
      *v4 = 0u;
      v4[1] = 0u;
    }
    return re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit(v2 + 48);
  }
  return result;
}

double re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 56;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  uint64_t v3;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(a1 + 8) = v1 & 0x7FFFFFFF;
    re::FixedArray<re::DynamicString>::deinit((_QWORD *)(a1 + 32));
    v3 = *(_QWORD *)(a1 + 24);
    if (v3)
    {

      *(_QWORD *)(a1 + 24) = 0;
    }
  }
}

_QWORD *re::FixedArray<re::FixedArray<re::DynamicString>>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = (_QWORD *)result[2];
      v5 = 24 * v2;
      do
      {
        re::FixedArray<re::DynamicString>::deinit(v4);
        v4 += 3;
        v5 -= 24;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

unint64_t re::CaseInsensitiveStringHash::operator()(int a1, char *__s)
{
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  uint64_t i;
  unint64_t v12;
  unint64_t __dst;

  v3 = strlen(__s);
  if (v3 >= 8)
  {
    v5 = 0;
    v4 = 0;
    v6 = 8;
    do
    {
      v7 = 0;
      v8 = *(_QWORD *)&__s[v4];
      v4 = v6;
      __dst = v8;
      do
      {
        *((_BYTE *)&__dst + v7) = __tolower(*((char *)&__dst + v7));
        ++v7;
      }
      while (v7 != 8);
      v9 = 0x94D049BB133111EBLL
         * ((0xBF58476D1CE4E5B9 * (__dst ^ (__dst >> 30))) ^ ((0xBF58476D1CE4E5B9 * (__dst ^ (__dst >> 30))) >> 27));
      v5 = (v5 - 0x61C8864680B583E9 + ((v9 ^ (v9 >> 31)) << 6) + ((v9 ^ (v9 >> 31)) >> 2)) ^ v9 ^ (v9 >> 31);
      v6 = v4 + 8;
    }
    while (v4 + 8 <= v3);
  }
  else
  {
    v4 = 0;
    v5 = 0;
  }
  v10 = v3 - v4;
  if (v10)
  {
    __dst = 0;
    memcpy(&__dst, &__s[v4], v10);
    for (i = 0; i != v10; ++i)
      *((_BYTE *)&__dst + i) = __tolower(*((char *)&__dst + i));
    v12 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (__dst ^ (__dst >> 30))) ^ ((0xBF58476D1CE4E5B9 * (__dst ^ (__dst >> 30))) >> 27));
    return (v5 - 0x61C8864680B583E9 + ((v12 ^ (v12 >> 31)) << 6) + ((v12 ^ (v12 >> 31)) >> 2)) ^ v12 ^ (v12 >> 31);
  }
  return v5;
}

void re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  signed int v13;
  _BYTE v14[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v14, 0, 36);
      *(_QWORD *)&v14[36] = 0x7FFFFFFFLL;
      re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::init((uint64_t)v14, v4, a2);
      v5 = *(_OWORD *)v14;
      *(_OWORD *)v14 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v14[16];
      v7 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)&v14[16] = v7;
      *(_QWORD *)(a1 + 16) = v6;
      v9 = *(_OWORD *)&v14[24];
      *(_OWORD *)&v14[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v14[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = (_QWORD *)(v7 + 16);
        do
        {
          if ((*(_DWORD *)(v12 - 1) & 0x80000000) != 0)
            re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::addAsMove(a1, *(v12 - 2) % (unint64_t)*(unsigned int *)(a1 + 24), *(v12 - 2), v12, v12 + 1);
          ++v11;
          v12 += 4;
        }
        while (v11 < v10);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v14);
    }
  }
  else
  {
    if (a2)
      v13 = a2;
    else
      v13 = 3;
  }
}

uint64_t re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  v13 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<char const*,unsigned long,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_138, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  id v8;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      v6 = *v5;
      v7 = *a3;
      if (*a3 != *v5)
      {
        if (v6)
        {
          v8 = (id)(v6 + 8);
          v7 = *a3;
        }
        if (v7)

        *a3 = v6;
      }
      ++v5;
      ++a3;
    }
    while (v5 != a2);
  }
}

void re::HashTable<re::DynamicString,re::DynamicArray<re::SharedPtr<re::AssetDescriptorBase const>>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  signed int v26;
  _BYTE v27[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v27, 0, 36);
      *(_QWORD *)&v27[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::DynamicArray<re::SharedPtr<re::AssetDescriptorBase const>>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v27, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v27;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v27[8];
      *(_OWORD *)v27 = v5;
      *(_QWORD *)&v27[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v27[24];
      *(_OWORD *)&v27[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v27[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = DWORD1(v9);
        v13 = v7;
        v14 = (_QWORD *)(v6 + 80);
        do
        {
          if ((*(_DWORD *)(v14 - 9) & 0x80000000) != 0)
          {
            v15 = *(v14 - 10);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(_DWORD *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              v18 = *(_DWORD *)(a1 + 32);
              v19 = v18;
              if (v18 == (_DWORD)v16)
              {
                re::HashTable<re::DynamicString,re::DynamicArray<re::SharedPtr<re::AssetDescriptorBase const>>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v12));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 88 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 88 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 88 * v18 + 8) = v21 | 0x80000000;
            v22 = *(_QWORD *)(a1 + 16) + 88 * v18;
            *(_DWORD *)(v22 + 8) = *(_DWORD *)(v22 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 88 * v18) = v15;
            re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 88 * v18 + 16), (const re::DynamicString *)(v14 - 8));
            v23 = *(_QWORD *)(a1 + 16) + 88 * v18;
            *(_QWORD *)(v23 + 80) = 0;
            *(_DWORD *)(v23 + 72) = 0;
            *(_QWORD *)(v23 + 56) = 0;
            *(_QWORD *)(v23 + 64) = 0;
            *(_QWORD *)(v23 + 48) = 0;
            *(_QWORD *)(v23 + 48) = *(v14 - 4);
            *(v14 - 4) = 0;
            *(_QWORD *)(v23 + 56) = *(v14 - 3);
            *(v14 - 3) = 0;
            v24 = *(_QWORD *)(v23 + 64);
            *(_QWORD *)(v23 + 64) = *(v14 - 2);
            *(v14 - 2) = v24;
            v25 = *(_QWORD *)(v23 + 80);
            *(_QWORD *)(v23 + 80) = *v14;
            *v14 = v25;
            ++*((_DWORD *)v14 - 2);
            ++*(_DWORD *)(v23 + 72);
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 11;
        }
        while (v11 < v10);
      }
      re::HashTable<re::DynamicString,re::DynamicArray<re::SharedPtr<re::AssetDescriptorBase const>>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v27);
    }
  }
  else
  {
    if (a2)
      v26 = a2;
    else
      v26 = 3;
  }
}

void re::HashTable<re::DynamicString,re::DynamicArray<re::SharedPtr<re::AssetDescriptorBase const>>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 88 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_138, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  _QWORD *v22;
  uint64_t v23;
  signed int v24;
  _BYTE v25[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(_QWORD *)&v25[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::init((uint64_t)v25, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v25;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v25[8];
      *(_OWORD *)v25 = v5;
      *(_QWORD *)&v25[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v25[24];
      *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = DWORD1(v9);
        v13 = v7;
        v14 = (_QWORD *)(v6 + 24);
        do
        {
          if ((*(_DWORD *)(v14 - 2) & 0x80000000) != 0)
          {
            v15 = *(v14 - 3);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::setCapacity(a1, (2 * v12));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 56 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 56 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 56 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v18 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v18) = v15;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v18 + 16) = *(v14 - 1);
            v22 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v18);
            v22[3] = *v14;
            *v14 = 0;
            v22[4] = 0;
            v22[5] = 0;
            v22[6] = 0;
            v22[4] = v14[1];
            v14[1] = 0;
            v22[5] = v14[2];
            v14[2] = 0;
            v23 = v22[6];
            v22[6] = v14[3];
            v14[3] = v23;
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          v14 += 7;
          ++v11;
        }
        while (v11 < v10);
      }
      re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit((uint64_t *)v25);
    }
  }
  else
  {
    if (a2)
      v24 = a2;
    else
      v24 = 3;
  }
}

void re::HashTable<unsigned long,re::AssetMap::ConfigurationEntry,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_138, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t *re::allocInfo_NetworkAssetLoadDescriptorParameters(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_48);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_48))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC330, 0);
    *(uint64_t *)((char *)&qword_2540FC340 + 6) = 0;
    qword_2540FC340 = 0;
    qword_2540FC350 = 0;
    qword_2540FC358 = 0xFFFFFFFFLL;
    qword_2540FC330 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC360 = (uint64_t)"NetworkAssetLoadDescriptorParameters";
    dword_2540FC368 = 0;
    unk_2540FC370 = 0u;
    unk_2540FC380 = 0u;
    unk_2540FC390 = 0u;
    qword_2540FC3A0 = 0;
    __cxa_guard_release(&_MergedGlobals_48);
  }
  return &qword_2540FC330;
}

void re::initInfo_NetworkAssetLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0xA7193B92A74838C2;
  v11[1] = "NetworkAssetLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FC328);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FC328);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_uint64_t((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "networkAssetId";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FC320 = v9;
      __cxa_guard_release(&qword_2540FC328);
    }
  }
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 8) = &qword_2540FC320;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::NetworkAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::NetworkAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::NetworkAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::NetworkAssetLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

uint64_t re::introspect_NetworkAssetLoadDescriptorParameters(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"NetworkAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_NetworkAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_NetworkAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NetworkAssetLoadDescriptorParameters>, this);
}

re::DynamicString *re::NetworkAssetLoadDescriptor::init(uint64_t a1, const re::IntrospectionBase *a2, re::DynamicString *a3)
{
  char **v6;
  const re::IntrospectionBase *v8[2];

  v8[0] = (const re::IntrospectionBase *)"NetworkAsset";
  v8[1] = (const re::IntrospectionBase *)12;
  v6 = (char **)re::DynamicString::operator=((re::DynamicString *)a1, (uint64_t)v8);
  v8[0] = a2;
  re::AssetLoadDescriptor::setIntrospectableData(v6, (const re::IntrospectionBase *)re::NetworkAssetProvider::s_loadDescriptorParametersIntrospect, v8, 0);
  return re::DynamicString::operator=((re::DynamicString *)(a1 + 112), a3);
}

_anonymous_namespace_ *re::NetworkAssetProvider::NetworkAssetProvider(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v8;
  __guard *v9;
  int v11;

  ArcSharedObject::ArcSharedObject(a1, 0);
  *(_QWORD *)a1 = &off_24ED2DE78;
  *((_QWORD *)a1 + 5) = 0;
  if ((v8 & 1) == 0)
  {
    if (v11)
    {
      re::introspect<re::NetworkAssetLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"NetworkAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_NetworkAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_NetworkAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NetworkAssetLoadDescriptorParameters>, 0);
    }
  }
  re::NetworkAssetProvider::s_loadDescriptorParametersIntrospect = v9[50];
  *((_QWORD *)a1 + 4) = a4;
  *((_QWORD *)a1 + 5) = a2;
  *((_QWORD *)a1 + 3) = a3;
  return a1;
}

void re::NetworkAssetProvider::~NetworkAssetProvider(re::NetworkAssetProvider *this)
{
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::NetworkAssetProvider::load(uint64_t a1, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) load for network providers should never be called", "!\"Unreachable code\"", "load", 58);
  _os_crash();
  __break(1u);
}

uint64_t re::NetworkAssetProvider::resolveChild@<X0>(re::NetworkAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, const char *a3@<X2>, const char *a4@<X3>, uint64_t a5@<X8>)
{
  const char *v10;
  uint64_t result;
  __int128 v12;
  __int128 v13;
  uint64_t *v14;
  _anonymous_namespace_ *v15;
  const re::IntrospectionBase *v16;
  _anonymous_namespace_ *v17;
  _anonymous_namespace_ *v18;
  __n128 v19;
  char *v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  _OWORD v35[2];
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  __int128 v42;
  __int128 v43;
  int v44;
  _QWORD v45[6];
  uint64_t *v46;

  if ((*((_BYTE *)a2 + 8) & 1) != 0)
    v10 = (const char *)*((_QWORD *)a2 + 2);
  else
    v10 = (char *)a2 + 9;
  if (strcmp(v10, "NetworkAsset"))
  {
    result = re::DynamicString::format((re::DynamicString *)"Cannot resolve with a parent AssetLoadDescriptor of scheme %s. Expected scheme %s.", (re::DynamicString *)&v36, v10, "NetworkAsset");
LABEL_6:
    v12 = v36;
    v13 = v37;
    *(_BYTE *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v12;
    *(_OWORD *)(a5 + 24) = v13;
    return result;
  }
  re::AssetLoadDescriptor::getIntrospectableData<re::NetworkAssetLoadDescriptorParameters>(a2, &v46, 0);
  v14 = v46;
  (*(void (**)(__int128 *__return_ptr, _QWORD, uint64_t *, const char *))(**((_QWORD **)this + 5) + 96))(&v36, *((_QWORD *)this + 5), v46, a3);
  if (!(_BYTE)v36)
  {
    result = re::DynamicString::format((re::DynamicString *)"Could not find AssetId for dependency with relative path %s from parent asset with AssetId %lu.", (re::DynamicString *)&v36, a3, v14);
    goto LABEL_6;
  }
  v15 = (_anonymous_namespace_ *)(*(_QWORD *(**)(__int128 *__return_ptr, _QWORD, uint64_t *, const char *))(**((_QWORD **)this + 5) + 96))(&v36, *((_QWORD *)this + 5), v14, a3);
  if (!(_BYTE)v36)
  {
    if ((*((_BYTE *)a2 + 8) & 1) != 0)
      v20 = (char *)*((_QWORD *)a2 + 2);
    else
      v20 = (char *)a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Dependent asset %s not found for Parent { scheme: %s, AssetId %llu. }", (re::DynamicString *)&v36, a3, v20, v14);
    goto LABEL_6;
  }
  v16 = (const re::IntrospectionBase *)*((_QWORD *)&v36 + 1);
  v36 = 0u;
  v37 = 0u;
  v17 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v36, 0);
  v38 = 0;
  v39 = 0;
  v41 = 0;
  v40 = 0;
  v42 = 0u;
  v43 = 0u;
  v44 = 0;
  memset(v45, 0, 40);
  v18 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v45[1], 0);
  re::NetworkAssetLoadDescriptor::init((uint64_t)&v36, v16, (re::DynamicString *)v35);
  if (*(_QWORD *)&v35[0])
  {
    if ((BYTE8(v35[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v35[0] + 40))();
    memset(v35, 0, sizeof(v35));
  }
  re::AssetLoadDescriptor::AssetLoadDescriptor((re::AssetLoadDescriptor *)&v21, (const re::AssetLoadDescriptor *)&v36);
  v19.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a5, (uint64_t)&v21);
  if ((_QWORD)v33)
  {
    if ((BYTE8(v33) & 1) != 0)
      (*(void (**)(double))(*(_QWORD *)v33 + 40))(v19.n128_f64[0]);
    v19 = 0uLL;
    v33 = 0u;
    v34 = 0u;
  }
  if (v28)
  {
    if (v32)
      (*(void (**)(__n128))(*(_QWORD *)v28 + 40))(v19);
    v32 = 0;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    ++v31;
  }
  if (v23)
  {
    if (v27)
      (*(void (**)(__n128))(*(_QWORD *)v23 + 40))(v19);
    v27 = 0;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    ++v26;
  }
  if (v21 && (v22 & 1) != 0)
    (*(void (**)(__n128))(*(_QWORD *)v21 + 40))(v19);
  if (v45[1])
  {
    if ((v45[2] & 1) != 0)
      (*(void (**)(__n128))(*(_QWORD *)v45[1] + 40))(v19);
    v19 = 0uLL;
    memset(&v45[1], 0, 32);
  }
  if (*((_QWORD *)&v42 + 1))
  {
    if (v45[0])
      (*(void (**)(__n128))(**((_QWORD **)&v42 + 1) + 40))(v19);
    v45[0] = 0;
    v43 = 0uLL;
    *((_QWORD *)&v42 + 1) = 0;
    ++v44;
  }
  if (v38)
  {
    if ((_QWORD)v42)
      (*(void (**)(__n128))(*(_QWORD *)v38 + 40))(v19);
    *(_QWORD *)&v42 = 0;
    v39 = 0;
    v40 = 0;
    v38 = 0;
    ++v41;
  }
  result = v36;
  if ((_QWORD)v36)
  {
    if ((BYTE8(v36) & 1) != 0)
      return (*(uint64_t (**)(__n128))(*(_QWORD *)v36 + 40))(v19);
  }
  return result;
}

uint64_t re::NetworkAssetProvider::getDescription(re::NetworkAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  uint64_t result;
  uint64_t v5;
  char v6;
  uint64_t *v7;

  re::AssetLoadDescriptor::getIntrospectableData<re::NetworkAssetLoadDescriptorParameters>(a2, &v7, 0);
  re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)&v5, v7);
  re::DynamicString::operator=(a3, (re::DynamicString *)&v5);
  result = v5;
  if (v5)
  {
    if ((v6 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
  }
  return result;
}

const char *re::NetworkAssetProvider::schemeName(re::NetworkAssetProvider *this)
{
  return "NetworkAsset";
}

uint64_t re::AssetType::generateCompiledExtension(re::AssetType *this)
{
  size_t v2;
  const char *v3;
  uint64_t v4;
  char *v5;
  char *v6;
  const char *v7;
  size_t v8;
  char *v9;
  const char *v10;
  uint64_t result;
  uint64_t v12;
  unint64_t v13;
  const char *v14;

  v2 = strlen(*(const char **)this);
  re::DynamicString::append((re::DynamicString *)&v12, *(const char **)this, v2);
  v3 = v14;
  v4 = v13 & 1;
  if ((v13 & 1) != 0)
    v5 = (char *)&v14[v13 >> 1];
  else
    v5 = (char *)&v13 + (v13 >> 1) + 1;
  if ((v13 & 1) != 0)
    v6 = (char *)v14;
  else
    v6 = (char *)&v13 + 1;
  if (v6 != v5)
  {
    do
    {
      *v6 = __tolower(*v6);
      ++v6;
    }
    while (v6 != v5);
    v3 = v14;
    v4 = v13 & 1;
  }
  if (v4)
    v7 = v3;
  else
    v7 = (char *)&v13 + 1;
  v8 = strlen(v7);
  v9 = (char *)malloc_type_malloc(v8 + 1, 0xC8E4EC82uLL);
  if ((v13 & 1) != 0)
    v10 = v14;
  else
    v10 = (char *)&v13 + 1;
  *((_QWORD *)this + 1) = strcpy(v9, v10);
  result = v12;
  if (v12)
  {
    if ((v13 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v12 + 40))();
  }
  return result;
}

void re::internal::AssetTypeRegistry::deinit(re::internal::AssetTypeRegistry *this)
{
  uint64_t v2;
  _QWORD **v3;
  uint64_t v4;
  _QWORD *v5;

  re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::clear((uint64_t)this);
  re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::clear((uint64_t)this + 48);
  v2 = *((_QWORD *)this + 14);
  if (v2)
  {
    v3 = (_QWORD **)*((_QWORD *)this + 16);
    v4 = 8 * v2;
    do
    {
      v5 = *v3++;
      re::internal::destroyPersistent<re::internal::AssetTypeRegistry::OwnedAssetType>((re *)"deinit", 26, v5);
      v4 -= 8;
    }
    while (v4);
  }
  *((_QWORD *)this + 14) = 0;
  ++*((_DWORD *)this + 30);
}

void re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_5, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)(v6 + 24));
          v3 = *(unsigned int *)(a1 + 32);
        }
        v4 += 64;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_13, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 32 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 32;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

re *re::internal::destroyPersistent<re::internal::AssetTypeRegistry::OwnedAssetType>(re *result, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;

  if (a3)
  {
    v4 = re::globalAllocators(result)[2];
    re::internal::destroyPersistent<re::AssetType>((re *)"~OwnedAssetType", 119, a3[4]);
    if (*a3)
    {
      if ((a3[1] & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
      *(_OWORD *)a3 = 0u;
      *((_OWORD *)a3 + 1) = 0u;
    }
    return (re *)(*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 40))(v4, a3);
  }
  return result;
}

void re::internal::AssetTypeRegistry::~AssetTypeRegistry(re::internal::AssetTypeRegistry *this)
{
  uint64_t v2;

  re::internal::AssetTypeRegistry::deinit(this);
  v2 = *((_QWORD *)this + 12);
  if (v2)
  {
    if (*((_QWORD *)this + 16))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 12) = 0;
    ++*((_DWORD *)this + 30);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 6);
  re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)this);
}

uint64_t re::internal::AssetTypeRegistry::registerAssetType(uint64_t a1, char **a2, uint64_t *a3)
{
  char *v5;
  char **v6;

  v6 = a2;
  re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::add(a1, (uint64_t *)&v6, a3);
  v5 = *v6;
  return re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add<re::AssetType const*&>(a1 + 48, &v5, &v6);
}

unint64_t re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::add(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + ((unint64_t)v13 << 6);
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + (v10 << 6) + 16) != v6)
  {
    v10 = *(_DWORD *)(v11 + (v10 << 6) + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + (v10 << 6);
  return v12 + 24;
}

uint64_t re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::add<re::AssetType const*&>(uint64_t a1, char **a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  unsigned int v13;
  char v15;

  v6 = re::CaseInsensitiveStringHash::operator()((int)&v15, *a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::addEmplace<re::AssetType const*&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return *(_QWORD *)(a1 + 16) + 32 * v13 + 24;
  }
  v10 = *(_QWORD *)(a1 + 16);
  v11 = *a2;
  while (1)
  {
    v12 = v10 + 32 * v9;
    if (!strcasecmp(*(const char **)(v12 + 16), v11))
      return v12 + 24;
    v9 = *(_DWORD *)(v12 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

void re::internal::AssetTypeRegistry::registerOwnedAssetType(char *a1@<X1>, uint64_t a2@<X0>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t *v16;
  re::internal::AssetTypeRegistry::OwnedAssetType *v17;
  char **v18;
  uint64_t v19;
  re::internal::AssetTypeRegistry::OwnedAssetType *v20;
  re::internal::AssetTypeRegistry::OwnedAssetType *v21;
  uint64_t v22[6];

  v6 = a2;
  v22[5] = *MEMORY[0x24BDAC8D0];
  v8 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = (int *)(*(_QWORD *)(a2 + 16) + 8);
    while (1)
    {
      v11 = *v10;
      v10 += 16;
      if (v11 < 0)
        break;
      if (v8 == ++v9)
      {
        LODWORD(v9) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if ((_DWORD)v8 == (_DWORD)v9)
  {
LABEL_18:
    v16 = re::globalAllocators((re *)a2);
    v17 = (re::internal::AssetTypeRegistry::OwnedAssetType *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v16[2] + 32))(v16[2], 40, 8);
    v21 = re::internal::AssetTypeRegistry::OwnedAssetType::OwnedAssetType(v17, a1);
    re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)(v6 + 96), &v21);
    v18 = (char **)*((_QWORD *)v21 + 4);
    std::unique_ptr<void,std::function<void ()(void *)>>::unique_ptr[abi:nn180100](v22, a3);
    re::internal::AssetTypeRegistry::registerAssetType(v6, v18, v22);
    std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](v22);
    v19 = *((_QWORD *)v21 + 4);
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = v19;
  }
  else
  {
    v12 = v9;
    v13 = *(_QWORD *)(a2 + 16);
    while (1)
    {
      a2 = strcasecmp(a1, **(const char ***)(v13 + (v12 << 6) + 16));
      if (!(_DWORD)a2)
        break;
      if (v8 <= (int)v9 + 1)
        v14 = v9 + 1;
      else
        v14 = v8;
      while (1)
      {
        v12 = (v9 + 1);
        if (v14 - 1 == (_DWORD)v9)
          break;
        LODWORD(v9) = v9 + 1;
        v15 = v12;
        if ((*(_DWORD *)(v13 + (v12 << 6) + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      v15 = v14;
LABEL_17:
      LODWORD(v9) = v15;
      if ((_DWORD)v8 == v15)
        goto LABEL_18;
    }
    re::WrappedError::make((re::WrappedError *)CFSTR("REAssetTypeRegistrationErrorDomain"), (const __CFString *)5, 0, &v21);
    v20 = v21;
    v21 = 0;
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = v20;

  }
}

uint64_t re::internal::AssetTypeRegistry::assetLoaderWithAssetType(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  LODWORD(v2) = 0x7FFFFFFF;
  if (*(_QWORD *)a1)
  {
    v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24)));
    if ((_DWORD)v4 != 0x7FFFFFFF)
    {
      v5 = *(_QWORD *)(a1 + 16);
      if (*(_QWORD *)(v5 + (v4 << 6) + 16) == a2)
      {
        LODWORD(v2) = v4;
      }
      else
      {
        v2 = v4;
        while (1)
        {
          v2 = *(_DWORD *)(v5 + (v2 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v2 == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v5 + (v2 << 6) + 16) == a2)
            return *(_QWORD *)(*(_QWORD *)(a1 + 16) + ((unint64_t)v2 << 6) + 24);
        }
        LODWORD(v2) = 0x7FFFFFFF;
      }
    }
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + ((unint64_t)v2 << 6) + 24);
}

uint64_t re::internal::AssetTypeRegistry::assetTypeWithExtension(re::internal::AssetTypeRegistry *this, const char *a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;

  v4 = *((unsigned int *)this + 8);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*((_QWORD *)this + 2) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 16;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *((_DWORD *)this + 8);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 == (_DWORD)v5)
    return 0;
  v8 = v5;
  while (1)
  {
    v9 = *((_QWORD *)this + 2) + (v8 << 6);
    if ((*(unsigned int (**)(_QWORD, const char *))(**(_QWORD **)(v9 + 24) + 96))(*(_QWORD *)(v9 + 24), a2))
    {
      return *(_QWORD *)(v9 + 16);
    }
    if (*((_DWORD *)this + 8) <= (v5 + 1))
      v10 = v5 + 1;
    else
      v10 = *((_DWORD *)this + 8);
    while (1)
    {
      v8 = (v5 + 1);
      if (v10 - 1 == (_DWORD)v5)
        break;
      LODWORD(v5) = v5 + 1;
      v11 = v8;
      if ((*(_DWORD *)(*((_QWORD *)this + 2) + (v8 << 6) + 8) & 0x80000000) != 0)
        goto LABEL_17;
    }
    v11 = v10;
LABEL_17:
    LODWORD(v5) = v11;
    if ((_DWORD)v4 == v11)
      return 0;
  }
}

uint64_t re::internal::AssetTypeRegistry::assetTypeWithName(re::internal::AssetTypeRegistry *this, char *a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  int v10;
  char *__s;
  char v13;

  __s = a2;
  v3 = (_QWORD *)((char *)this + 48);
  if (!re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::containsKey((uint64_t)this + 48, &__s))return 0;
  v4 = re::CaseInsensitiveStringHash::operator()((int)&v13, __s);
  v5 = 0x7FFFFFFFLL;
  if (*v3)
  {
    v6 = *(unsigned int *)(*((_QWORD *)this + 7) + 4 * (v4 % *((unsigned int *)this + 18)));
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *((_QWORD *)this + 8);
      v8 = __s;
      do
      {
        v9 = v7 + 32 * v6;
        v10 = strcasecmp(*(const char **)(v9 + 16), v8);
        v5 = v6;
        if (!v10)
          break;
        v6 = *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
        v5 = 0x7FFFFFFFLL;
      }
      while (v6 != 0x7FFFFFFF);
    }
  }
  return *(_QWORD *)(*((_QWORD *)this + 8) + 32 * v5 + 24);
}

BOOL re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::containsKey(uint64_t a1, char **a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  int v10;
  char v12;

  v4 = re::CaseInsensitiveStringHash::operator()((int)&v12, *a2);
  v5 = 0x7FFFFFFFLL;
  if (*(_QWORD *)a1)
  {
    v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a1 + 16);
      v8 = *a2;
      do
      {
        v9 = v7 + 32 * v6;
        v10 = strcasecmp(*(const char **)(v9 + 16), v8);
        v5 = v6;
        if (!v10)
          break;
        v6 = *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
        v5 = 0x7FFFFFFFLL;
      }
      while (v6 != 0x7FFFFFFF);
    }
  }
  return v5 != 0x7FFFFFFF;
}

uint64_t re::internal::AssetTypeRegistry::assetTypeWithCompiledExtension(re::internal::AssetTypeRegistry *this, const char *__s2)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;

  v3 = *((unsigned int *)this + 8);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = (int *)(*((_QWORD *)this + 2) + 8);
    while (1)
    {
      v6 = *v5;
      v5 += 16;
      if (v6 < 0)
        break;
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 8);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if ((_DWORD)v3 == (_DWORD)v4)
    return 0;
  v7 = v4;
  v8 = *((_QWORD *)this + 2);
  while (1)
  {
    v9 = *(_QWORD *)(v8 + (v7 << 6) + 16);
    if (!strcmp(*(const char **)(v9 + 8), __s2))
      return v9;
    if (v3 <= (int)v4 + 1)
      v10 = v4 + 1;
    else
      v10 = v3;
    while (1)
    {
      v7 = (v4 + 1);
      if (v10 - 1 == (_DWORD)v4)
        break;
      LODWORD(v4) = v4 + 1;
      v11 = v7;
      if ((*(_DWORD *)(v8 + (v7 << 6) + 8) & 0x80000000) != 0)
        goto LABEL_17;
    }
    v11 = v10;
LABEL_17:
    LODWORD(v4) = v11;
    if ((_DWORD)v3 == v11)
      return 0;
  }
}

re::internal::AssetTypeRegistry::OwnedAssetType *re::internal::AssetTypeRegistry::OwnedAssetType::OwnedAssetType(re::internal::AssetTypeRegistry::OwnedAssetType *this, const char *a2)
{
  re *v4;
  uint64_t *v5;
  re::AssetType *v6;
  re::AssetType *v7;
  char *v8;

  v5 = re::globalAllocators(v4);
  v6 = (re::AssetType *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5[2] + 32))(v5[2], 24, 8);
  v7 = v6;
  if ((*((_BYTE *)this + 8) & 1) != 0)
    v8 = (char *)*((_QWORD *)this + 2);
  else
    v8 = (char *)this + 9;
  *(_QWORD *)v6 = v8;
  *((_QWORD *)v6 + 2) = 0;
  re::AssetType::generateCompiledExtension(v6);
  *((_QWORD *)this + 4) = v7;
  return this;
}

re *re::internal::destroyPersistent<re::AssetType>(re *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  if (a3)
  {
    v4 = re::globalAllocators(result)[2];
    free(*(void **)(a3 + 8));
    return (re *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 40))(v4, a3);
  }
  return result;
}

double re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)(v6 + 24));
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 64;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, uint64_t *a5)
{
  uint64_t v10;
  int v11;
  int v12;
  signed int v13;
  uint64_t v14;
  BOOL v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  __int128 v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  signed int v26;
  _BYTE v28[44];

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      v12 = *(_DWORD *)(a1 + 28);
      v13 = 2 * v12;
      v14 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v13)
          v15 = (_DWORD)v10 == v13;
        else
          v15 = 1;
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v28, 0, 36);
          *(_QWORD *)&v28[36] = 0x7FFFFFFFLL;
          re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::init((uint64_t)v28, v14, v13);
          v16 = *(_OWORD *)v28;
          *(_OWORD *)v28 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          v17 = *(_QWORD *)&v28[16];
          v18 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v28[16] = v18;
          *(_QWORD *)(a1 + 16) = v17;
          v20 = *(_OWORD *)&v28[24];
          *(_OWORD *)&v28[24] = *(_OWORD *)(a1 + 24);
          v19 = *(_DWORD *)&v28[32];
          *(_OWORD *)(a1 + 24) = v20;
          v21 = v19;
          if (v19)
          {
            v22 = 0;
            v23 = v18 + 16;
            do
            {
              if ((*(_DWORD *)(v23 - 8) & 0x80000000) != 0)
                re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addAsMove(a1, *(_QWORD *)(v23 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v23 - 16), v23, v23 + 8);
              ++v22;
              v23 += 64;
            }
            while (v22 < v21);
          }
          re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)v28);
        }
      }
      else
      {
        if (v13)
          v26 = 2 * v12;
        else
          v26 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v24 = *(_QWORD *)(a1 + 16);
    v25 = *(_DWORD *)(v24 + (v10 << 6) + 8);
  }
  else
  {
    v24 = *(_QWORD *)(a1 + 16);
    v25 = *(_DWORD *)(v24 + (v10 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v25 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v24 + (v10 << 6) + 8) = v25 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6)) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 16) = *a4;
  std::unique_ptr<void,std::function<void ()(void *)>>::unique_ptr[abi:nn180100]((_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 24), a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::AssetType const*,std::unique_ptr<re::AssetLoader,std::function<void ()(re::AssetLoader*)>>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + (v10 << 6), 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_13, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::addEmplace<re::AssetType const*&>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  signed int v22;
  _BYTE v23[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(_QWORD *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::init((uint64_t)v23, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v23;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)v23 = v5;
      *(_QWORD *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = DWORD1(v9);
        v13 = v7;
        v14 = (_QWORD *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v14 - 1) & 0x80000000) != 0)
          {
            v15 = *(v14 - 2);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::setCapacity(a1, (2 * v12));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 32 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18) = v15;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 16) = *v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 24) = v14[1];
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 4;
        }
        while (v11 < v10);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2)
      v22 = a2;
    else
      v22 = 3;
  }
}

void re::HashTable<char const*,re::AssetType const*,re::CaseInsensitiveStringHash,re::CaseInsensitiveStringEqualTo,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_13, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::internal::SharedAssetPointer::makeSharedAssetPointer(re::internal::SharedAssetPointer *this@<X0>, _anonymous_namespace_ **a2@<X8>)
{
  uint64_t *v5;
  _anonymous_namespace_ *v6;

  v5 = re::globalAllocators(this);
  v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5[2] + 32))(v5[2], 32, 8);
  ArcSharedObject::ArcSharedObject(v6, 0);
  *(_QWORD *)v6 = &off_24ED2DF18;
  *((_QWORD *)v6 + 3) = this;
  *a2 = v6;
}

re *re::internal::SharedAssetPointer::dispose(re *this)
{
  re *v1;
  uint64_t v2;

  if (this)
  {
    v1 = this;
    v2 = re::globalAllocators(this)[2];
    (**(void (***)(re *))v1)(v1);
    return (re *)(*(uint64_t (**)(uint64_t, re *))(*(_QWORD *)v2 + 40))(v2, v1);
  }
  return this;
}

void `anonymous namespace'::assetEntryAllocator(_anonymous_namespace_ *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
      byte_255827220 = 0;
      *(_QWORD *)algn_255827218 = "AssetEntry allocator";
    }
  }
}

void re::internal::AssetEntry::makeAssetEntry(re::internal::AssetEntry *this@<X0>, void *a2@<X1>, const re::AssetType *a3@<X2>, uint64_t *a4@<X8>)
{
  char v4;
  uint64_t v8;
  uint64_t v9;
  __uint64_t v10;
  _anonymous_namespace_ *v11;

  v4 = (char)a3;
  v9 = re::internal::AssetEntry::AssetEntry(v8, 1, 0);
  *a4 = v9;
  v10 = v9 + 704;
  re::internal::SharedAssetPointer::makeSharedAssetPointer(this, &v11);
  re::internal::AssetEntry::LoadState::setAssetPointer(v10, (uint64_t *)&v11);
  if (v11)

  *(_QWORD *)(v8 + 264) = a2;
  *(_BYTE *)(v8 + 258) = v4;
}

void re::internal::AssetEntry::LoadState::setAssetPointer(__uint64_t a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;

  v4 = *(os_unfair_lock_s **)(a1 + 24);
  os_unfair_lock_lock(v4);
  re::internal::AssetEntry::LoadState::setAssetPointer_locked(a1, a2);
  os_unfair_lock_unlock(v4);
}

uint64_t re::internal::AssetEntry::AssetEntry(uint64_t a1, char a2, int a3)
{
  _anonymous_namespace_ *v6;
  unint64_t v7;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24ED2DF48;
  *(_QWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 256) = 0;
  *(_BYTE *)(a1 + 257) = a2;
  *(_QWORD *)(a1 + 304) = 0;
  *(_BYTE *)(a1 + 312) = 0;
  *(_BYTE *)(a1 + 320) = 0;
  *(_BYTE *)(a1 + 336) = 0;
  *(_BYTE *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 384) = 0;
  *(_OWORD *)(a1 + 258) = 0u;
  *(_OWORD *)(a1 + 274) = 0u;
  *(_OWORD *)(a1 + 284) = 0u;
  re::internal::AssetEntry::State::State((re::internal::AssetEntry::State *)(a1 + 392));
  *(_DWORD *)(a1 + 420) = a3;
  *(_BYTE *)(a1 + 640) = 0;
  *(_DWORD *)(a1 + 704) = 0;
  *(_QWORD *)(a1 + 720) = 0;
  *(_QWORD *)(a1 + 712) = 0;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_OWORD *)(a1 + 676) = 0u;
  *(_QWORD *)(a1 + 728) = a1 + 384;
  *(_BYTE *)(a1 + 736) = 0;
  *(_BYTE *)(a1 + 744) = 0;
  *(_BYTE *)(a1 + 752) = 0;
  *(_BYTE *)(a1 + 760) = 0;
  *(_BYTE *)(a1 + 768) = 0;
  *(_BYTE *)(a1 + 776) = 0;
  objc_initWeak((id *)(a1 + 832), 0);
  *(_DWORD *)(a1 + 840) = 0;
  *(_BYTE *)(a1 + 848) = 0;
  do
    v7 = __ldaxr(&re::internal::AssetEntry::AssetEntry(BOOL,re::AssetNetworkSharingMode)::uniqueHashID);
  while (__stlxr(v7 + 1, &re::internal::AssetEntry::AssetEntry(BOOL,re::AssetNetworkSharingMode)::uniqueHashID));
  *(_QWORD *)(a1 + 664) = v7;
  return a1;
}

void re::internal::AssetEntry::~AssetEntry(re::internal::AssetEntry *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)this = &off_24ED2DF48;
  objc_destroyWeak((id *)this + 104);
  *((_QWORD *)this + 104) = 0;
  v2 = *((_QWORD *)this + 90);
  if (v2)
  {

    *((_QWORD *)this + 90) = 0;
  }
  v3 = *((_QWORD *)this + 89);
  if (v3)
  {

    *((_QWORD *)this + 89) = 0;
  }
  if (*((_BYTE *)this + 592))
  {
    v4 = *((_QWORD *)this + 75);
    if (v4)
    {
      if ((*((_BYTE *)this + 608) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 77));
      *(_OWORD *)((char *)this + 600) = 0u;
      *(_OWORD *)((char *)this + 616) = 0u;
    }
  }
  v5 = *((_QWORD *)this + 65);
  if (v5)
  {
    v6 = *((_DWORD *)this + 134);
    if ((v6 & 1) == 0)
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 69));
      v6 = *((_DWORD *)this + 134);
    }
    *((_QWORD *)this + 65) = 0;
    *((_QWORD *)this + 66) = 0;
    *((_DWORD *)this + 134) = (v6 | 1) + 2;
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 59);
  re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 53);
  v7 = (unsigned int *)*((_QWORD *)this + 49);
  if (v7)
  {
    re::details::release<re::ResourceRequest>(v7);
    *((_QWORD *)this + 49) = 0;
  }
  re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::deinit((uint64_t)this + 272);
  v8 = *((_QWORD *)this + 28);
  v9 = (_QWORD *)((char *)this + 160);
  if (v8)
  {
    if ((*((_BYTE *)this + 232) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *((_QWORD *)this + 30));
    *((_OWORD *)this + 14) = 0u;
    *((_OWORD *)this + 15) = 0u;
  }
  v10 = *((_QWORD *)this + 24);
  if (v10)
  {
    if ((*((_BYTE *)this + 200) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *((_QWORD *)this + 26));
    *((_OWORD *)this + 12) = 0u;
    *((_OWORD *)this + 13) = 0u;
  }
  if (*v9)
  {
    if ((*((_BYTE *)this + 168) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v9 + 40))(*v9, *((_QWORD *)this + 22));
    *(_OWORD *)v9 = 0u;
    *((_OWORD *)this + 11) = 0u;
  }
  v11 = *((_QWORD *)this + 16);
  if (v11)
  {
    if ((*((_BYTE *)this + 136) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 40))(v11, *((_QWORD *)this + 18));
    *((_OWORD *)this + 8) = 0u;
    *((_OWORD *)this + 9) = 0u;
  }
  v12 = *((_QWORD *)this + 9);
  if (v12)
  {
    if ((*((_BYTE *)this + 80) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 40))(v12, *((_QWORD *)this + 11));
    *(_OWORD *)((char *)this + 72) = 0u;
    *(_OWORD *)((char *)this + 88) = 0u;
  }
  v13 = *((_QWORD *)this + 5);
  if (v13)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 40))(v13, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::internal::AssetEntry::~AssetEntry(this);
  JUMPOUT(0x2276933ACLL);
}

uint64_t re::internal::AssetEntry::LoadState::unloadAssetPointer_locked(uint64_t this, re::AssetLoader *a2)
{
  uint64_t v2;
  __uint64_t v4;
  int v5;
  uint64_t v6;

  v2 = *(_QWORD *)(this + 8);
  if (v2 && *(_QWORD *)(v2 + 24))
  {
    v4 = this;
    v5 = objc_msgSend((id)(v2 + 8), "retainCount");
    v6 = *(_QWORD *)(v4 + 8);
    if (v5 == 1)
    {
      (*(void (**)(re::AssetLoader *, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)(v6 + 24));
      v6 = *(_QWORD *)(v4 + 8);
      *(_QWORD *)(v6 + 24) = 0;
    }
    else if (!v6)
    {
      return re::internal::AssetEntry::LoadState::refreshLoadState_locked(v4);
    }

    *(_QWORD *)(v4 + 8) = 0;
    return re::internal::AssetEntry::LoadState::refreshLoadState_locked(v4);
  }
  return this;
}

uint64_t re::internal::AssetEntry::assetPointer(re::internal::AssetEntry *this)
{
  uint64_t v1;
  void *v2;
  id v3;

  v1 = *((_QWORD *)this + 89);
  if (v1)
  {
    v2 = (void *)(v1 + 8);
    v3 = (id)(v1 + 8);
    v1 = *(_QWORD *)(v1 + 24);

  }
  return v1;
}

uint64_t re::internal::AssetEntry::LoadState::clearAndReturnAssetPointer_locked(re::internal::AssetEntry::LoadState *this)
{
  uint64_t v1;
  re *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v8[16];

  v1 = *((_QWORD *)this + 1);
  if (v1)
  {
    v3 = (re *)objc_msgSend((id)(v1 + 8), "retainCount");
    if ((int)v3 < 2)
    {
      v6 = *((_QWORD *)this + 1);
      v5 = *(_QWORD *)(v6 + 24);
      *(_QWORD *)(v6 + 24) = 0;

      *((_QWORD *)this + 1) = 0;
      re::internal::AssetEntry::LoadState::refreshLoadState_locked((__uint64_t)this);
      return v5;
    }
    v4 = *re::assetsLogObjects(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v8 = 0;
      _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "clearAndReturnAssetPointer() not supported for Assets that share AssetPointer", v8, 2u);
    }
  }
  return 0;
}

uint64_t re::internal::AssetEntry::hasAssetPointer(re::internal::AssetEntry *this)
{
  uint64_t v1;
  void *v2;
  id v3;

  v1 = *((_QWORD *)this + 89);
  if (v1)
  {
    v2 = (void *)(v1 + 8);
    v3 = (id)(v1 + 8);
    v1 = *(_QWORD *)(v1 + 24) != 0;

  }
  return v1;
}

uint64_t re::internal::AssetEntry::hasLoadingAssetPointer(re::internal::AssetEntry *this)
{
  uint64_t v1;
  void *v2;
  id v3;

  v1 = *((_QWORD *)this + 90);
  if (v1)
  {
    v2 = (void *)(v1 + 8);
    v3 = (id)(v1 + 8);
    v1 = *(_QWORD *)(v1 + 24) != 0;

  }
  return v1;
}

uint64_t re::internal::AssetEntry::ownerPeerID@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v3;
  const char *v4;
  char v5;
  uint64_t v6;

  v3 = atomic_load((unint64_t *)(this + 672));
  if (v3)
  {
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v3;
  }
  else if (*(_DWORD *)(this + 120) == 4)
  {
    if ((*(_QWORD *)(this + 48) & 1) != 0)
      v4 = *(const char **)(this + 56);
    else
      v4 = (const char *)(this + 49);
    v6 = 0;
    this = sscanf(v4, "%llu", &v6);
    if ((_DWORD)this == 1)
    {
      *(_QWORD *)(a2 + 8) = v6;
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
    *(_BYTE *)a2 = v5;
  }
  else
  {
    *(_BYTE *)a2 = 0;
  }
  return this;
}

uint64_t re::internal::AssetEntry::fromPeerID@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v3;
  const char *v4;
  char v5;
  uint64_t v6;

  v3 = atomic_load((unint64_t *)(this + 680));
  if (v3)
  {
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v3;
  }
  else if (*(_DWORD *)(this + 120) == 4)
  {
    if ((*(_QWORD *)(this + 48) & 1) != 0)
      v4 = *(const char **)(this + 56);
    else
      v4 = (const char *)(this + 49);
    v6 = 0;
    this = sscanf(v4, "%llu", &v6);
    if ((_DWORD)this == 1)
    {
      *(_QWORD *)(a2 + 8) = v6;
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
    *(_BYTE *)a2 = v5;
  }
  else
  {
    *(_BYTE *)a2 = 0;
  }
  return this;
}

void re::internal::AssetEntry::setOwnerPeerID(re::internal::AssetEntry *this, unint64_t a2)
{
  unint64_t *v2;
  NSObject *v4;
  uint8_t v5[16];

  v2 = (unint64_t *)((char *)this + 672);
  while (!__ldaxr(v2))
  {
    if (!__stlxr(a2, v2))
      return;
  }
  __clrex();
  v4 = *re::assetsLogObjects(this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v5 = 0;
    _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "m_ownerPeerID was assigned a new value after it was already set.", v5, 2u);
  }
}

void re::internal::AssetEntry::setFromPeerID(re::internal::AssetEntry *this, unint64_t a2)
{
  unint64_t *v2;
  NSObject *v4;
  uint8_t v5[16];

  v2 = (unint64_t *)((char *)this + 680);
  while (!__ldaxr(v2))
  {
    if (!__stlxr(a2, v2))
      return;
  }
  __clrex();
  v4 = *re::assetsLogObjects(this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v5 = 0;
    _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "m_fromPeerID was assigned a new value after it was already set.", v5, 2u);
  }
}

void re::internal::AssetEntry::setResourceClientLoadState(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned __int8 *a5)
{
  os_unfair_lock_s *v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  int v15;
  BOOL v16;
  BOOL v17;
  __int128 v18;
  uint64_t v19;
  int v21;

  v10 = (os_unfair_lock_s *)(a1 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 384));
  if ((*(_BYTE *)(a1 + 536) & 1) != 0)
    v11 = a1 + 544;
  else
    v11 = *(_QWORD *)(a1 + 552);
  v12 = *(_QWORD *)(a1 + 528);
  if (v12)
  {
    v13 = (_DWORD *)(v11 + 28);
    v14 = 32 * v12;
    while (*(_QWORD *)(v13 - 7) != a2)
    {
      v13 += 8;
      v14 -= 32;
      if (!v14)
        goto LABEL_8;
    }
    *(v13 - 5) = a3;
    *(_QWORD *)(v13 - 3) = a4;
    v15 = *a5;
    if (*((_BYTE *)v13 - 4))
      v16 = 0;
    else
      v16 = v15 == 0;
    if (!v16)
    {
      if (*((_BYTE *)v13 - 4))
        v17 = v15 == 0;
      else
        v17 = 0;
      if (v17)
      {
        *((_BYTE *)v13 - 4) = 0;
      }
      else
      {
        if (!*((_BYTE *)v13 - 4) && *a5)
          *((_BYTE *)v13 - 4) = 1;
        *v13 = *((_DWORD *)a5 + 1);
      }
    }
  }
  else
  {
LABEL_8:
    *(_QWORD *)&v18 = a2;
    DWORD2(v18) = a3;
    v19 = a4;
    if (*a5)
      v21 = *((_DWORD *)a5 + 1);
    re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::add(a1 + 520, &v18);
  }
  os_unfair_lock_unlock(v10);
}

uint64_t re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::add(uint64_t a1, __int128 *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  int v8;

  result = re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::ensureCapacity(a1);
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v5 = a1 + 24;
  else
    v5 = *(_QWORD *)(a1 + 32);
  v6 = v5 + 32 * *(_QWORD *)(a1 + 8);
  v7 = *a2;
  *(_QWORD *)(v6 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)v6 = v7;
  v8 = *((unsigned __int8 *)a2 + 24);
  *(_BYTE *)(v6 + 24) = v8;
  if (v8)
    *(_DWORD *)(v6 + 28) = *((_DWORD *)a2 + 7);
  ++*(_QWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 16) += 2;
  return result;
}

void `anonymous namespace'::assetManagerDetachLock(_anonymous_namespace_ *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
    }
  }
}

void re::internal::AssetEntry::addToAssetManager_assetTablesLocked(re::internal::AssetEntry *this, re::AssetManager *a2, const re::AssetPath *a3, char a4)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  _BYTE v10[23];

  *((_BYTE *)this + 257) = a4;
  *((_QWORD *)this + 3) = a2;
  *((_QWORD *)this + 33) = *((_QWORD *)a3 + 9);
  re::ExistingAssetInformation::setupFromPath((re::internal::AssetEntry *)((char *)this + 32), a3);
  re::AssetManager::getDescription_assetTablesLocked(*((re::AssetManager **)this + 3), this, 0, (uint64_t)&v8);
  if ((v9 & 1) != 0)
    v6 = *(const char **)&v10[7];
  else
    v6 = v10;
  re::ExistingAssetInformation::CachedLogName::setDescription((re::internal::AssetEntry *)((char *)this + 160), v6);
  if (v8 && (v9 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v8 + 40))();
  if (*((_QWORD *)a2 + 151))
  {
    v7 = *((_QWORD *)this + 14);
    if ((unint64_t)(v7 + 1) >= 2)
      re::NetworkActionQueue::queueSyncActionShareLoadState((re::AssetManager *)((char *)a2 + 768), v7);
  }
}

void re::internal::AssetEntry::removeFromAssetManager(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this + 96);
  atomic_load(&this[176]._os_unfair_lock_opaque);
  *(_QWORD *)&this[6]._os_unfair_lock_opaque = 0;
  re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::clear((uint64_t)&this[68]);
  os_unfair_lock_unlock(this + 96);
}

void re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::clear(uint64_t a1)
{
  uint64_t v2;
  id *v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = *(id **)(a1 + 32);
    v4 = 8 * v2;
    do
    {
      objc_destroyWeak(v3);
      *v3++ = 0;
      v4 -= 8;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void re::internal::AssetEntry::cancelResourceRequest_stateLocked(re::internal::AssetEntry *this)
{
  unsigned int *v2;

  if (*((_QWORD *)this + 49))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 3) + 1128) + 80))(*(_QWORD *)(*((_QWORD *)this + 3) + 1128));
    v2 = (unsigned int *)*((_QWORD *)this + 49);
    if (v2)
    {
      re::details::release<re::ResourceRequest>(v2);
      *((_QWORD *)this + 49) = 0;
    }
  }
}

void re::internal::AssetEntry::addExplicitParentDependency(re::internal::AssetEntry *this, re::internal::AssetEntry *a2)
{
  _anonymous_namespace_ *v2;
  char *v3;
  id location;

  v2 = (re::internal::AssetEntry *)((char *)this + 272);
  if (a2)
    v3 = (char *)a2 + 8;
  else
    v3 = 0;
  objc_initWeak(&location, v3);
  re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::add(v2, &location);
  objc_destroyWeak(&location);
}

uint64_t re::internal::AssetEntry::getMetadataString@<X0>(os_unfair_lock_s *a1@<X0>, const char *a2@<X1>, int a3@<W2>, _BYTE *a4@<X8>)
{
  os_unfair_lock_s *v8;
  unsigned __int8 *v9;
  int v10;
  const re::DynamicString *v11;
  uint64_t v12;
  int v13;
  uint64_t result;
  uint64_t v15;
  char v16;

  v8 = a1 + 96;
  if (a3)
    os_unfair_lock_lock(a1 + 96);
  v9 = (unsigned __int8 *)re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&a1[106], (uint64_t)&v15);
  if (!v9)
  {
    v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&a1[118], (uint64_t)&v15);
    v13 = 1;
    if (!v12)
      goto LABEL_10;
    v11 = (const re::DynamicString *)v12;
    *a4 = 1;
    goto LABEL_8;
  }
  v10 = *v9;
  *a4 = v10;
  if (v10)
  {
    v11 = (const re::DynamicString *)(v9 + 8);
LABEL_8:
    re::DynamicString::DynamicString((re::DynamicString *)(a4 + 8), v11);
  }
  v13 = 0;
LABEL_10:
  if (a3)
    os_unfair_lock_unlock(v8);
  result = v15;
  if (v15 && (v16 & 1) != 0)
    result = (*(uint64_t (**)(void))(*(_QWORD *)v15 + 40))();
  if (v13)
    *a4 = 0;
  return result;
}

uint64_t *re::internal::AssetEntry::setOrClearMetadata_stateLocked(re::internal::AssetEntry *this, const re::StringID *a2, const char *a3)
{
  const char *v6;
  _anonymous_namespace_ *v7;
  size_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _anonymous_namespace_ *v30;
  const char *v31;
  uint64_t v32;
  uint64_t *result;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _anonymous_namespace_ *v40;
  NSObject *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  const char *v50;
  _anonymous_namespace_ *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char v58;

  v6 = (const char *)*((_QWORD *)a2 + 1);
  v7 = (_anonymous_namespace_ *)strlen(v6);
  v50 = v6;
  v51 = v7;
  v56 = 0;
  v57 = 0;
  if (v7)
    v8 = (size_t)v7 + 1;
  else
    v8 = 0;
  v55 = 0;
  re::DynamicString::setCapacity(&v54, v8);
  re::DynamicString::operator=((re::DynamicString *)&v54, (uint64_t)&v50);
  v9 = strcmp(*((const char **)a2 + 1), "__RuntimeAssetSize");
  if ((_DWORD)v9
    || (v9 = re::Hash<re::DynamicString>::operator()((uint64_t)&v50, (uint64_t)&v54), !*((_QWORD *)this + 53))
    || (v16 = *(unsigned int *)(*((_QWORD *)this + 54) + 4 * (v9 % *((unsigned int *)this + 112))),
        (_DWORD)v16 == 0x7FFFFFFF))
  {
LABEL_5:
    v10 = (_QWORD *)((char *)this + 424);
    if (a3)
    {
      v11 = re::Hash<re::DynamicString>::operator()((uint64_t)&v58, (uint64_t)&v54);
      v12 = v11;
      if (*v10)
      {
        v13 = v11 % *((unsigned int *)this + 112);
        v14 = *(unsigned int *)(*((_QWORD *)this + 54) + 4 * v13);
        if ((_DWORD)v14 != 0x7FFFFFFF)
        {
          v15 = *((_QWORD *)this + 55);
          while (!re::DynamicString::operator==(v15 + 88 * v14 + 16, (uint64_t)&v54))
          {
            v14 = *(_DWORD *)(v15 + 88 * v14 + 8) & 0x7FFFFFFF;
            if (v14 == 0x7FFFFFFF)
              goto LABEL_25;
          }
          if (*(_BYTE *)(v15 + 88 * v14 + 48))
          {
            v34 = v15 + 88 * v14;
            v37 = *(_QWORD *)(v34 + 56);
            v36 = v34 + 56;
            v35 = v37;
            if (v37)
            {
              if ((*(_BYTE *)(v36 + 8) & 1) != 0)
                (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v35 + 40))(v35, *(_QWORD *)(v36 + 16));
              *(_OWORD *)v36 = 0u;
              *(_OWORD *)(v36 + 16) = 0u;
              v15 = *((_QWORD *)this + 55);
            }
          }
          v38 = v15 + 88 * v14;
          *(_BYTE *)(v38 + 48) = 1;
          *(_OWORD *)(v38 + 56) = 0u;
          *(_OWORD *)(v38 + 72) = 0u;
          *(_QWORD *)(v38 + 56) = v50;
          v50 = 0;
          v39 = *(_QWORD *)(v38 + 72);
          *(_QWORD *)(v38 + 72) = v52;
          v52 = v39;
          *(_QWORD *)(v38 + 80) = v53;
          v53 = 0;
          v40 = *(_anonymous_namespace_ **)(v38 + 64);
          *(_QWORD *)(v38 + 64) = v51;
          v51 = v40;
LABEL_31:
          ++*((_DWORD *)this + 116);
          v31 = v50;
          if (v50 && (v51 & 1) != 0)
          {
            v32 = v52;
LABEL_40:
            (*(void (**)(const char *, uint64_t))(*(_QWORD *)v31 + 40))(v31, v32);
            goto LABEL_41;
          }
          goto LABEL_41;
        }
      }
      else
      {
        LODWORD(v13) = 0;
      }
LABEL_25:
      v23 = *((_DWORD *)this + 115);
      if (v23 == 0x7FFFFFFF)
      {
        v23 = *((_DWORD *)this + 114);
        v24 = v23;
        if (v23 == *((_DWORD *)this + 112))
        {
          re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)this + 424, 2 * *((_DWORD *)this + 113));
          LODWORD(v13) = v12 % *((unsigned int *)this + 112);
          v24 = *((_DWORD *)this + 114);
        }
        *((_DWORD *)this + 114) = v24 + 1;
        v25 = *((_QWORD *)this + 55);
        v26 = *(_DWORD *)(v25 + 88 * v23 + 8);
      }
      else
      {
        v25 = *((_QWORD *)this + 55);
        v26 = *(_DWORD *)(v25 + 88 * v23 + 8);
        *((_DWORD *)this + 115) = v26 & 0x7FFFFFFF;
      }
      *(_DWORD *)(v25 + 88 * v23 + 8) = v26 | 0x80000000;
      v27 = 88 * v23;
      *(_DWORD *)(*((_QWORD *)this + 55) + v27 + 8) = *(_DWORD *)(*((_QWORD *)this + 55) + v27 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 54) + 4 * v13);
      *(_QWORD *)(*((_QWORD *)this + 55) + v27) = v12;
      re::DynamicString::DynamicString((re::DynamicString *)(*((_QWORD *)this + 55) + v27 + 16), (const re::DynamicString *)&v54);
      v28 = *((_QWORD *)this + 55) + 88 * v23;
      *(_BYTE *)(v28 + 48) = 1;
      *(_OWORD *)(v28 + 72) = 0u;
      *(_OWORD *)(v28 + 56) = 0u;
      *(_QWORD *)(v28 + 56) = v50;
      v50 = 0;
      v29 = *(_QWORD *)(v28 + 72);
      *(_QWORD *)(v28 + 72) = v52;
      v52 = v29;
      *(_QWORD *)(v28 + 80) = v53;
      v53 = 0;
      v30 = *(_anonymous_namespace_ **)(v28 + 64);
      *(_QWORD *)(v28 + 64) = v51;
      v51 = v30;
      *(_DWORD *)(*((_QWORD *)this + 54) + 4 * v13) = v23;
      ++*((_DWORD *)this + 113);
      goto LABEL_31;
    }
    LOBYTE(v50) = 0;
    v18 = re::Hash<re::DynamicString>::operator()((uint64_t)&v58, (uint64_t)&v54);
    v19 = v18;
    if (*v10)
    {
      v20 = v18 % *((unsigned int *)this + 112);
      v21 = *(unsigned int *)(*((_QWORD *)this + 54) + 4 * v20);
      if ((_DWORD)v21 != 0x7FFFFFFF)
      {
        v22 = *((_QWORD *)this + 55);
        while (!re::DynamicString::operator==(v22 + 88 * v21 + 16, (uint64_t)&v54))
        {
          v21 = *(_DWORD *)(v22 + 88 * v21 + 8) & 0x7FFFFFFF;
          if (v21 == 0x7FFFFFFF)
            goto LABEL_35;
        }
        re::Optional<re::DynamicString>::operator=((unsigned __int8 *)(v22 + 88 * v21 + 48), &v50);
LABEL_36:
        ++*((_DWORD *)this + 116);
        if ((_BYTE)v50)
        {
          v31 = (const char *)v51;
          if (v51)
          {
            if ((v52 & 1) != 0)
            {
              v32 = v53;
              goto LABEL_40;
            }
          }
        }
LABEL_41:
        if (re::StringID::operator==(a2, re::internal::AssetEntry::kDebugNameMetadataKeyID))
          re::ExistingAssetInformation::CachedLogName::setDebugMetadata((re::internal::AssetEntry *)((char *)this + 160), a3);
        goto LABEL_43;
      }
    }
    else
    {
      LODWORD(v20) = 0;
    }
LABEL_35:
    re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove((uint64_t)this + 424, v20, v19, (re::DynamicString *)&v54, &v50);
    goto LABEL_36;
  }
  v17 = *((_QWORD *)this + 55);
  while (1)
  {
    v9 = re::DynamicString::operator==(v17 + 88 * v16 + 16, (uint64_t)&v54);
    if ((v9 & 1) != 0)
      break;
    v16 = *(_DWORD *)(v17 + 88 * v16 + 8) & 0x7FFFFFFF;
    if (v16 == 0x7FFFFFFF)
      goto LABEL_5;
  }
  if (a3)
  {
    v41 = *re::assetsLogObjects((re *)v9);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v50) = 0;
      _os_log_impl(&dword_224FE9000, v41, OS_LOG_TYPE_DEFAULT, "Can't override runtime asset size if it was automatically set during load.", (uint8_t *)&v50, 2u);
    }
  }
  else
  {
    v42 = re::Hash<re::DynamicString>::operator()((uint64_t)&v50, (uint64_t)&v54);
    if (*((_QWORD *)this + 53))
    {
      v43 = v42 % *((unsigned int *)this + 112);
      v44 = *((_QWORD *)this + 54);
      v45 = *(unsigned int *)(v44 + 4 * v43);
      if ((_DWORD)v45 != 0x7FFFFFFF)
      {
        v46 = *((_QWORD *)this + 55);
        if (re::DynamicString::operator==(v46 + 88 * v45 + 16, (uint64_t)&v54))
        {
          *(_DWORD *)(v44 + 4 * v43) = *(_DWORD *)(v46 + 88 * v45 + 8) & 0x7FFFFFFF;
LABEL_64:
          re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*((_QWORD *)this + 55) + 88 * v45);
          v49 = *((_QWORD *)this + 55) + 88 * v45;
          *(_DWORD *)(v49 + 8) = *(_DWORD *)(v49 + 8) & 0x80000000 | *((_DWORD *)this + 115);
          *((_DWORD *)this + 115) = v45;
          --*((_DWORD *)this + 113);
          ++*((_DWORD *)this + 116);
        }
        else
        {
          while (1)
          {
            v47 = v45;
            v48 = *(_DWORD *)(v46 + 88 * v45 + 8);
            v45 = v48 & 0x7FFFFFFF;
            if ((v48 & 0x7FFFFFFF) == 0x7FFFFFFF)
              break;
            if (re::DynamicString::operator==(v46 + 88 * v45 + 16, (uint64_t)&v54))
            {
              *(_DWORD *)(v46 + 88 * v47 + 8) = *(_DWORD *)(v46 + 88 * v47 + 8) & 0x80000000 | *(_DWORD *)(v46 + 88 * v45 + 8) & 0x7FFFFFFF;
              goto LABEL_64;
            }
          }
        }
      }
    }
  }
LABEL_43:
  result = v54;
  if (v54)
  {
    if ((v55 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v54 + 40))();
  }
  return result;
}

double re::internal::AssetEntry::updateMetadata(re::internal::AssetEntry *this, char a2)
{
  uint64_t v3;
  _anonymous_namespace_ *v5;
  unsigned int v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _anonymous_namespace_ *v13;
  const char *v14;
  unsigned int v15;
  unsigned int v16;
  double result;
  uint64_t v18;
  char v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  unsigned int v26;
  uint64_t v27;

  if (*(_QWORD *)(*((_QWORD *)this + 3) + 1208))
  {
    v3 = *((_QWORD *)this + 14);
    if ((unint64_t)(v3 + 1) >= 2)
    {
      v26 = 0;
      v24 = 0u;
      v25 = 0u;
      v27 = 0x7FFFFFFFLL;
      if ((a2 & 1) == 0)
        os_unfair_lock_lock((os_unfair_lock_t)this + 96);
      re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=((uint64_t)&v24, (uint64_t *)&v20);
      re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v20);
      v6 = v26;
      if (v26)
      {
        v7 = 0;
        v8 = (int *)v25;
        while (1)
        {
          v9 = *v8;
          v8 += 16;
          if (v9 < 0)
            break;
          if (v26 == ++v7)
          {
            LODWORD(v7) = v26;
            break;
          }
        }
      }
      else
      {
        LODWORD(v7) = 0;
      }
      if (v26 != (_DWORD)v7)
      {
        v10 = v7;
        v11 = v25;
        do
        {
          v12 = v11 + (v10 << 6);
          v21 = 0;
          v22 = 0;
          v23 = 0;
          v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v20, 0);
          if (*(_BYTE *)(v12 + 24))
            v13 = re::DynamicString::operator=((re::DynamicString *)&v20, (re::DynamicString *)(v12 + 32));
          v14 = *(const char **)(v12 + 16);
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>((uint64_t)this + 472, (re::DynamicString *)&v18, (const re::DynamicString *)&v20);
          if (v18 && (v19 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v18 + 40))();
          v5 = (_anonymous_namespace_ *)v20;
          if (v20 && (v21 & 1) != 0)
            v5 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*v20 + 40))();
          v11 = v25;
          if (v26 <= (int)v7 + 1)
            v15 = v7 + 1;
          else
            v15 = v26;
          while (1)
          {
            v10 = (v7 + 1);
            if (v15 - 1 == (_DWORD)v7)
              break;
            LODWORD(v7) = v7 + 1;
            v16 = v10;
            if ((*(_DWORD *)(v25 + (v10 << 6)) & 0x80000000) != 0)
              goto LABEL_28;
          }
          v16 = v15;
LABEL_28:
          LODWORD(v7) = v16;
        }
        while (v6 != v16);
      }
      if ((a2 & 1) == 0)
        os_unfair_lock_unlock((os_unfair_lock_t)this + 96);
      re::NetworkActionQueue::queueSyncActionShareMetadata((re::NetworkActionQueue *)(*((_QWORD *)this + 3) + 768), v3);
      return re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v24);
    }
  }
  return result;
}

void `anonymous namespace'::convertOut(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  int v12;
  int v13;
  StringID v14;

  *(_DWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 36) = 0x7FFFFFFFLL;
  v4 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(a1 + 16) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 22;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a1 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    v9 = *(_QWORD *)(a1 + 16);
    do
    {
      v10 = v9 + 88 * v8;
      v11 = (unsigned __int8 *)(v10 + 48);
      re::StringID::StringID((re::StringID *)&v14, (const re::DynamicString *)(v10 + 16));
      re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<re::Optional<re::DynamicString>&>(a2, &v14, v11);
      re::StringID::destroyString((re::StringID *)&v14);
      v9 = *(_QWORD *)(a1 + 16);
      if (*(_DWORD *)(a1 + 32) <= (v5 + 1))
        v12 = v5 + 1;
      else
        v12 = *(_DWORD *)(a1 + 32);
      v13 = v5;
      while (1)
      {
        v8 = (v13 + 1);
        if (v12 - 1 == v13)
          break;
        ++v13;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(v9 + 88 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v5) = v12;
LABEL_17:
      ;
    }
    while ((_DWORD)v4 != (_DWORD)v5);
  }
}

uint64_t re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(_QWORD *)a1 || *(_QWORD *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
    }
  }
  return a1;
}

double re::internal::AssetEntry::copyMetadataToNetworkAssetService(re::internal::AssetEntry *this)
{
  uint64_t v2;
  uint64_t v4[6];
  _OWORD v5[2];
  int v6;
  uint64_t v7;

  re::AssetManager::assertOnEngineQueue(*((re::AssetManager **)this + 3));
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v7 = 0x7FFFFFFFLL;
  os_unfair_lock_lock((os_unfair_lock_t)this + 96);
  re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=((uint64_t)v5, v4);
  re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v4);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 96);
  if (*((_QWORD *)this + 14) == -1)
    v2 = 0;
  else
    v2 = *((_QWORD *)this + 14);
  (*(void (**)(_QWORD, uint64_t, _OWORD *))(**(_QWORD **)(*((_QWORD *)this + 3) + 1208) + 48))(*(_QWORD *)(*((_QWORD *)this + 3) + 1208), v2, v5);
  return re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)v5);
}

void re::internal::AssetEntry::setMetadata(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  _anonymous_namespace_ *v15;
  unint64_t v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  int v22;
  int v23;
  _QWORD v24[2];
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _anonymous_namespace_ *v29;
  char v30;

  re::AssetManager::assertOnEngineQueue(*(re::AssetManager **)(a1 + 24));
  if (*(_QWORD *)(*(_QWORD *)(a1 + 24) + 1208) && (unint64_t)(*(_QWORD *)(a1 + 112) + 1) >= 2)
  {
    v4 = (os_unfair_lock_s *)(a1 + 384);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 384));
    v5 = a1 + 472;
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(v5);
    v7 = *(unsigned int *)(a2 + 32);
    if ((_DWORD)v7)
    {
      v8 = 0;
      v9 = *(int **)(a2 + 16);
      while (1)
      {
        v10 = *v9;
        v9 += 14;
        if (v10 < 0)
          break;
        if (v7 == ++v8)
        {
          LODWORD(v8) = *(_DWORD *)(a2 + 32);
          break;
        }
      }
    }
    else
    {
      LODWORD(v8) = 0;
    }
    if ((_DWORD)v7 != (_DWORD)v8)
    {
      v11 = v8;
      v12 = *(_QWORD *)(a2 + 16);
      do
      {
        v13 = (_QWORD *)(v12 + 56 * v11);
        v14 = (const char *)v13[2];
        v16 = v13[4];
        v17 = (char *)v13[5];
        if ((v16 & 1) == 0)
          v17 = (char *)v13 + 33;
        v18 = v16 >> 1;
        v19 = v16 >> 1;
        if ((v13[4] & 1) != 0)
          v20 = v18;
        else
          v20 = v19;
        v24[0] = v17;
        v24[1] = v20;
        v26 = 0;
        v27 = 0;
        v28 = 0;
        if (v20)
          v21 = v20 + 1;
        else
          v21 = 0;
        re::DynamicString::setCapacity(&v25, v21);
        re::DynamicString::operator=((re::DynamicString *)&v25, (uint64_t)v24);
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add(v5, (re::DynamicString *)&v29, &v25);
        if (v25 && (v26 & 1) != 0)
          (*(void (**)(void))(*v25 + 40))();
        v6 = v29;
        if (v29 && (v30 & 1) != 0)
          v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v29 + 40))();
        v12 = *(_QWORD *)(a2 + 16);
        if (*(_DWORD *)(a2 + 32) <= (v8 + 1))
          v22 = v8 + 1;
        else
          v22 = *(_DWORD *)(a2 + 32);
        while (1)
        {
          v11 = (v8 + 1);
          if (v22 - 1 == (_DWORD)v8)
            break;
          LODWORD(v8) = v8 + 1;
          v23 = v11;
          if ((*(_DWORD *)(v12 + 56 * v11) & 0x80000000) != 0)
            goto LABEL_32;
        }
        v23 = v22;
LABEL_32:
        LODWORD(v8) = v23;
      }
      while ((_DWORD)v7 != v23);
    }
    os_unfair_lock_unlock(v4);
  }
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add(uint64_t a1, re::DynamicString *a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char v14;

  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 80 * v11;
    return v12 + 48;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 80 * v9 + 16, (uint64_t)a2))
  {
    v9 = *(_DWORD *)(v10 + 80 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v10 + 80 * v9;
  return v12 + 48;
}

void re::internal::AssetEntry::updateMutatedRuntimeAssetSize(os_unfair_lock_s *this)
{
  re::AssetManager *v2;
  int v3;
  std::string *v4;
  std::string *v5;
  NSObject *v6;
  char *v7;
  _QWORD v8[2];
  std::string v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)&this[6]._os_unfair_lock_opaque)
  {
    v9.__r_.__value_.__r.__words[0] = 0;
    v9.__r_.__value_.__l.__size_ = (std::string::size_type)&str_110;
    os_unfair_lock_lock(this + 96);
    re::internal::AssetEntry::setOrClearMetadata_stateLocked((re::internal::AssetEntry *)this, (const re::StringID *)&v9, 0);
    os_unfair_lock_unlock(this + 96);
    re::StringID::destroyString((re::StringID *)&v9);
    if (LOBYTE(this[80]._os_unfair_lock_opaque))
      LOBYTE(this[80]._os_unfair_lock_opaque) = 0;
    v2 = *(re::AssetManager **)&this[6]._os_unfair_lock_opaque;
    if (*((_BYTE *)v2 + 1424))
    {
      os_unfair_lock_lock(this + 96);
      v3 = re::AssetManager::assetByteSize_entryLocked(v2, (re::internal::AssetEntry *)this);
      os_unfair_lock_unlock(this + 96);
      v4 = std::to_string(&v9, v3);
      v8[0] = 0;
      v8[1] = &str_110;
      if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v5 = &v9;
      else
        v5 = (std::string *)v9.__r_.__value_.__r.__words[0];
      os_unfair_lock_lock(this + 96);
      re::internal::AssetEntry::setOrClearMetadata_stateLocked((re::internal::AssetEntry *)this, (const re::StringID *)v8, (const char *)v5);
      os_unfair_lock_unlock(this + 96);
      re::StringID::destroyString((re::StringID *)v8);
      re::internal::AssetEntry::updateMetadata((re::internal::AssetEntry *)this, 0);
      if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v9.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    v6 = *re::assetsLogObjects((re *)this);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      if ((this[42]._os_unfair_lock_opaque & 1) != 0)
        v7 = *(char **)&this[44]._os_unfair_lock_opaque;
      else
        v7 = (char *)&this[42]._os_unfair_lock_opaque + 1;
      LODWORD(v9.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v9.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_error_impl(&dword_224FE9000, v6, OS_LOG_TYPE_ERROR, "Updating mutated asset size failed. Asset isn't in an asset manager '%s'.", (uint8_t *)&v9, 0xCu);
    }
  }
}

void re::internal::AssetEntry::updateMutatedAssetNonSharedDataSize(re::internal::AssetEntry *this)
{
  re::AssetManager *v2;
  NSObject *v3;
  char *v4;
  int v5;
  char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = (re::AssetManager *)*((_QWORD *)this + 3);
  if (v2)
  {
    if (*((_BYTE *)this + 336))
      *((_BYTE *)this + 336) = 0;
    if (*((_BYTE *)this + 352))
      *((_BYTE *)this + 352) = 0;
    if (*((_BYTE *)v2 + 1441))
    {
      os_unfair_lock_lock((os_unfair_lock_t)this + 96);
      re::AssetManager::assetNonSharedDataByteSize_entryStateLocked(v2, this);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 96);
    }
  }
  else
  {
    v3 = *re::assetsLogObjects(this);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      if ((*((_BYTE *)this + 168) & 1) != 0)
        v4 = (char *)*((_QWORD *)this + 22);
      else
        v4 = (char *)this + 169;
      v5 = 136315138;
      v6 = v4;
      _os_log_error_impl(&dword_224FE9000, v3, OS_LOG_TYPE_ERROR, "Updating mutated asset size failed. Asset isn't in an asset manager '%s'.", (uint8_t *)&v5, 0xCu);
    }
  }
}

re::internal::AssetEntry::State *re::internal::AssetEntry::State::State(re::internal::AssetEntry::State *this)
{
  _anonymous_namespace_ *v2;

  *((_DWORD *)this + 7) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = 0;
  *((_WORD *)this + 12) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_QWORD *)((char *)this + 68) = 0x7FFFFFFFLL;
  *((_DWORD *)this + 28) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_QWORD *)((char *)this + 116) = 0x7FFFFFFFLL;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_DWORD *)this + 36) = 1;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_BYTE *)this + 184) = 0;
  *((_BYTE *)this + 188) = 0;
  *((_BYTE *)this + 200) = 0;
  return this;
}

void re::internal::AssetEntry::LoadState::setAssetPointer_locked(__uint64_t a1, uint64_t *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;

  v5 = *(_QWORD *)(a1 + 8);
  v3 = (uint64_t *)(a1 + 8);
  v4 = v5;
  if (v5)
    v6 = *(_QWORD *)(v4 + 24) != 0;
  else
    v6 = 0;
  v7 = *a2;
  v8 = *(_QWORD *)(v7 + 24) != 0;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(v3, v7);
  if (v6 != v8)
    re::internal::AssetEntry::LoadState::refreshLoadState_locked(a1);
}

__uint64_t re::internal::AssetEntry::LoadState::refreshLoadState_locked(__uint64_t this)
{
  __uint64_t v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;

  v1 = this;
  v2 = *(_QWORD *)(this + 24);
  if (*(_BYTE *)(v2 + 192))
  {
    v3 = 1;
LABEL_5:
    atomic_store(v3, (unsigned int *)this);
    return this;
  }
  if (*(_BYTE *)(v2 + 208))
  {
    v3 = 3;
    goto LABEL_5;
  }
  v4 = *(_QWORD *)(this + 8);
  if (v4 && *(_QWORD *)(v4 + 24) && !*(_QWORD *)(this + 16))
  {
    atomic_store(2u, (unsigned int *)this);
    this = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
    *(_QWORD *)(v1 + 48) = this;
    *(_BYTE *)(v1 + 56) = 1;
  }
  else
  {
    atomic_store(0, (unsigned int *)this);
  }
  return this;
}

void re::internal::AssetEntry::LoadState::clearAndResetAssetPointer_locked(re::internal::AssetEntry::LoadState *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 1);
  v3 = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(v2 + 24) = 0;

  *((_QWORD *)this + 1) = 0;
  if (v3)
    re::internal::AssetEntry::LoadState::refreshLoadState_locked((__uint64_t)this);
}

void re::internal::AssetEntry::LoadState::resetAssetPointer_locked(re::internal::AssetEntry::LoadState *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 1);
  if (v1)
  {
    v3 = *(_QWORD *)(v1 + 24);

    *((_QWORD *)this + 1) = 0;
    if (v3)
      re::internal::AssetEntry::LoadState::refreshLoadState_locked((__uint64_t)this);
  }
}

void re::internal::AssetEntry::LoadState::setLoadingAssetPointer_locked(__uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  re *refreshed;
  _BOOL4 v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v7 = *(_QWORD *)(a1 + 16);
  v5 = (uint64_t *)(a1 + 16);
  v6 = v7;
  if (v7)
    v8 = *(_QWORD *)(v6 + 24) != 0;
  else
    v8 = 0;
  v9 = *a2;
  v10 = *(_QWORD *)(v9 + 24);
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(v5, v9);
  if (v8 != (v10 != 0))
    refreshed = (re *)re::internal::AssetEntry::LoadState::refreshLoadState_locked(a1);
  if (v10)
    v12 = v8;
  else
    v12 = 0;
  if (v12)
  {
    v13 = *re::assetsLogObjects(refreshed);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = 134217984;
      v15 = a3;
      _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, "setLoadingAssetPointer_locked is being called on AssetEntry %llu while it already has a loading asset pointer. This could cause a crash, or cause the AssetEntry to end up with the wrong data loaded. This might be caused by high-frequency mutations of an asset.", (uint8_t *)&v14, 0xCu);
    }
  }
}

void re::internal::AssetEntry::LoadState::clearAndResetLoadingAssetPointer_locked(re::internal::AssetEntry::LoadState *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 2);
  v3 = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(v2 + 24) = 0;

  *((_QWORD *)this + 2) = 0;
  if (v3)
    re::internal::AssetEntry::LoadState::refreshLoadState_locked((__uint64_t)this);
}

void re::internal::AssetEntry::LoadState::resetLoadingAssetPointer_locked(re::internal::AssetEntry::LoadState *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 2);
  if (v1)
  {
    v3 = *(_QWORD *)(v1 + 24);

    *((_QWORD *)this + 2) = 0;
    if (v3)
      re::internal::AssetEntry::LoadState::refreshLoadState_locked((__uint64_t)this);
  }
}

__uint64_t re::internal::AssetEntry::LoadState::clearLoadFailure_locked(re::internal::AssetEntry::LoadState *this)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  char v6;

  v2 = *((_QWORD *)this + 3);
  if (*(_BYTE *)(v2 + 196))
    *(_BYTE *)(v2 + 196) = 0;
  LOBYTE(v4) = 0;
  re::Optional<re::DynamicString>::operator=((unsigned __int8 *)(v2 + 208), &v4);
  if ((_BYTE)v4 && v5 && (v6 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v5 + 40))();
  return re::internal::AssetEntry::LoadState::refreshLoadState_locked((__uint64_t)this);
}

__uint64_t re::internal::AssetEntry::LoadState::setLoadFailure_locked(__uint64_t a1, int a2, re::DynamicString *a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  char v8;

  v4 = *(_QWORD *)(a1 + 24);
  if (!*(_BYTE *)(v4 + 196))
    *(_BYTE *)(v4 + 196) = 1;
  *(_DWORD *)(v4 + 200) = a2;
  LOBYTE(v6) = 1;
  re::DynamicString::DynamicString((re::DynamicString *)&v7, a3);
  re::Optional<re::DynamicString>::operator=((unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 208), &v6);
  if ((_BYTE)v6 && v7 && (v8 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v7 + 40))();
  return re::internal::AssetEntry::LoadState::refreshLoadState_locked(a1);
}

void re::internal::AssetEntry::setIsLoading_locked(re::internal::AssetEntry *this, int a2)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;

  if (re::internal::AssetEntry::LoadState::setIsLoading_locked((re::internal::AssetEntry *)((char *)this + 704), a2))
  {
    v3 = *((_QWORD *)this + 3);
    if (v3)
    {
      v4 = atomic_load((unsigned int *)this + 176);
      v5 = v4;
      re::AssetManager::entryLoadStateChanged(v3, (uint64_t)this, (int *)&v5);
    }
  }
}

BOOL re::internal::AssetEntry::LoadState::setIsLoading_locked(re::internal::AssetEntry::LoadState *this, int a2)
{
  uint64_t v3;
  int v4;

  v3 = *((_QWORD *)this + 3);
  v4 = *(unsigned __int8 *)(v3 + 192);
  if (v4 != a2)
  {
    *(_BYTE *)(v3 + 192) = a2;
    if (a2 && !*((_BYTE *)this + 40))
    {
      *((_QWORD *)this + 4) = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
      *((_BYTE *)this + 40) = 1;
    }
    re::internal::AssetEntry::LoadState::refreshLoadState_locked((__uint64_t)this);
  }
  return v4 != a2;
}

void re::internal::AssetEntry::makeAssetReference(re::internal::AssetEntry *this@<X0>, re::internal::AssetReference **a2@<X8>)
{
  id *v4;
  char *WeakRetained;
  re::internal::AssetReference *v6;
  char *v7;
  re::internal::AssetReference *v8;
  re::internal::AssetReference *v9;
  re::internal::AssetReference *v10;
  void *v11;

  v4 = (id *)((char *)this + 832);
  WeakRetained = (char *)objc_loadWeakRetained((id *)this + 104);
  v6 = (re::internal::AssetReference *)(WeakRetained - 8);
  if (!WeakRetained)
    v6 = 0;
  *a2 = v6;
  if (!WeakRetained)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 210);
    v7 = (char *)objc_loadWeakRetained(v4);
    v8 = (re::internal::AssetReference *)(v7 - 8);
    if (!v7)
      v8 = 0;
    *a2 = v8;
    if (!v7)
    {
      v9 = (re::internal::AssetReference *)re::internal::AssetEntry::AssetReferenceStorage::allocate((re::internal::AssetEntry *)((char *)this + 848));
      v10 = re::internal::AssetReference::AssetReference(v9, this);
      *a2 = v10;
      if (v10)
        v11 = (char *)v10 + 8;
      else
        v11 = 0;
      objc_storeWeak(v4, v11);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 210);
  }
}

uint64_t re::internal::AssetEntry::AssetReferenceStorage::allocate(re::internal::AssetEntry::AssetReferenceStorage *this)
{
  uint64_t *v1;

  if (*(_BYTE *)this)
  {
    v1 = re::globalAllocators(this);
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v1[2] + 32))(v1[2], 32, 0);
  }
  else
  {
    *(_BYTE *)this = 1;
    return (uint64_t)this + 8;
  }
}

void re::internal::AssetReference::dispose(re::internal::AssetReference *this)
{
  uint64_t v2;
  re *v3;
  uint64_t *v4;
  _anonymous_namespace_ *v5;
  os_unfair_lock_s *v6;

  v2 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  (**(void (***)(re::internal::AssetReference *))this)(this);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 840));
  if ((re::internal::AssetReference *)(v2 + 856) == this)
  {
    *(_BYTE *)(v2 + 848) = 0;
  }
  else
  {
    v4 = re::globalAllocators(v3);
    (*(void (**)(uint64_t, re::internal::AssetReference *))(*(_QWORD *)v4[2] + 40))(v4[2], this);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 840));
  v6 = *(os_unfair_lock_s **)(v2 + 24);
  if (v6)
    re::AssetManager::enqueueUnreferencedUnloadRequest(v6, (re::internal::AssetEntry *)v2);

}

void re::internal::AssetReference::~AssetReference(re::internal::AssetReference *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24ED2DF88;
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {

    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_24ED2DF88;
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {

    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::internal::SharedAssetPointer::~SharedAssetPointer(re::internal::SharedAssetPointer *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

unint64_t re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<re::Optional<re::DynamicString>&>(uint64_t a1, StringID *a2, unsigned __int8 *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;

  v6 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)&a2->var0 >> 31) ^ (*(_QWORD *)&a2->var0 >> 1));
  v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v7 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v12 == 0x7FFFFFFF)
    {
      v12 = *(unsigned int *)(a1 + 32);
      v13 = v12;
      if ((_DWORD)v12 == *(_DWORD *)(a1 + 24))
      {
        re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
        LODWORD(v8) = v7 % *(unsigned int *)(a1 + 24);
        v13 = *(_DWORD *)(a1 + 32);
      }
      *(_DWORD *)(a1 + 32) = v13 + 1;
      v14 = *(_QWORD *)(a1 + 16);
      v15 = *(_DWORD *)(v14 + (v12 << 6));
    }
    else
    {
      v14 = *(_QWORD *)(a1 + 16);
      v15 = *(_DWORD *)(v14 + (v12 << 6));
      *(_DWORD *)(a1 + 36) = v15 & 0x7FFFFFFF;
    }
    v16 = v12 << 6;
    *(_DWORD *)(v14 + v16) = v15 | 0x80000000;
    *(_DWORD *)(*(_QWORD *)(a1 + 16) + v16) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v12 << 6)) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8);
    re::StringID::StringID((re::StringID *)(*(_QWORD *)(a1 + 16) + (v12 << 6) + 8), a2);
    v17 = *(_QWORD *)(a1 + 16) + (v12 << 6);
    v18 = *a3;
    *(_BYTE *)(v17 + 24) = v18;
    if (v18)
      re::DynamicString::DynamicString((re::DynamicString *)(v17 + 32), (const re::DynamicString *)(a3 + 8));
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8) = v12;
    ++*(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 40);
    return *(_QWORD *)(a1 + 16) + ((unint64_t)v12 << 6) + 24;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v11 = v10 + (v9 << 6);
    if (re::StringID::operator==((_QWORD *)(v11 + 8), a2))
      return v11 + 24;
    v9 = *(_DWORD *)(v10 + (v9 << 6)) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

void re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  signed int v28;
  _BYTE v29[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v29, 0, 36);
      *(_QWORD *)&v29[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v29, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v29;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v29[8];
      *(_OWORD *)v29 = v5;
      *(_QWORD *)&v29[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v29[24];
      *(_OWORD *)&v29[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v29[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = DWORD1(v9);
        v13 = v7;
        v14 = (_QWORD *)(v6 + 32);
        do
        {
          if ((*(_DWORD *)(v14 - 4) & 0x80000000) != 0)
          {
            v15 = 0xBF58476D1CE4E5B9 * ((*(v14 - 3) >> 31) ^ (*(v14 - 3) >> 1));
            v16 = (0x94D049BB133111EBLL * (v15 ^ (v15 >> 27))) ^ ((0x94D049BB133111EBLL * (v15 ^ (v15 >> 27))) >> 31);
            v17 = *(unsigned int *)(a1 + 24);
            v18 = v16 % v17;
            v19 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v19 == 0x7FFFFFFF)
            {
              v19 = *(unsigned int *)(a1 + 32);
              v20 = v19;
              if ((_DWORD)v19 == (_DWORD)v17)
              {
                re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, (2 * v12));
                v18 = v16 % *(unsigned int *)(a1 + 24);
                v20 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v20 + 1;
              v21 = *(_QWORD *)(a1 + 16);
              v22 = *(_DWORD *)(v21 + (v19 << 6));
            }
            else
            {
              v21 = *(_QWORD *)(a1 + 16);
              v22 = *(_DWORD *)(v21 + (v19 << 6));
              *(_DWORD *)(a1 + 36) = v22 & 0x7FFFFFFF;
            }
            v23 = v19 << 6;
            *(_DWORD *)(v21 + v23) = v22 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + v23) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v19 << 6)) & 0x80000000 | *(_DWORD *)(v13 + 4 * v18);
            re::StringID::StringID((re::StringID *)(*(_QWORD *)(a1 + 16) + (v19 << 6) + 8), (const StringID *)(v14 - 3));
            v24 = *(_QWORD *)(a1 + 16) + (v19 << 6);
            v25 = *((unsigned __int8 *)v14 - 8);
            *(_BYTE *)(v24 + 24) = v25;
            if (v25)
            {
              *(_OWORD *)(v24 + 32) = 0u;
              *(_OWORD *)(v24 + 48) = 0u;
              *(_QWORD *)(v24 + 32) = *v14;
              *v14 = 0;
              v26 = *(_QWORD *)(v24 + 48);
              *(_QWORD *)(v24 + 48) = v14[2];
              v14[2] = v26;
              *(_QWORD *)(v24 + 56) = v14[3];
              v14[3] = 0;
              v27 = *(_QWORD *)(v24 + 40);
              *(_QWORD *)(v24 + 40) = v14[1];
              v14[1] = v27;
            }
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v18) = v19;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 8;
        }
        while (v11 < v10);
      }
      re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)v29);
    }
  }
  else
  {
    if (a2)
      v28 = a2;
    else
      v28 = 3;
  }
}

void re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + (v10 << 6), 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_25, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

re::internal::AssetReference *re::internal::AssetReference::AssetReference(re::internal::AssetReference *this, re::internal::AssetEntry *a2)
{
  char *v4;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED2DF88;
  *((_QWORD *)this + 3) = a2;
  if (a2)
    v4 = (char *)a2 + 8;
  return this;
}

double re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::EntryWithoutHash::free(a1[2] + v3);
        ++v4;
        v3 += 64;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::EntryWithoutHash::free(uint64_t a1)
{
  double result;
  uint64_t v3;

  if ((*(_DWORD *)a1 & 0x80000000) != 0)
  {
    *(_DWORD *)a1 &= ~0x80000000;
    re::StringID::destroyString((re::StringID *)(a1 + 8));
    if (*(_BYTE *)(a1 + 24))
    {
      v3 = *(_QWORD *)(a1 + 32);
      if (v3)
      {
        if ((*(_BYTE *)(a1 + 40) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 48));
        result = 0.0;
        *(_OWORD *)(a1 + 32) = 0u;
        *(_OWORD *)(a1 + 48) = 0u;
      }
    }
  }
  return result;
}

double re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 88;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  uint64_t v3;
  _OWORD *v4;
  double result;
  uint64_t v6;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    v4 = (_OWORD *)(a1 + 16);
    v3 = *(_QWORD *)(a1 + 16);
    *((_DWORD *)v4 - 2) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 32));
      result = 0.0;
      *v4 = 0u;
      v4[1] = 0u;
    }
    if (*(_BYTE *)(a1 + 48))
    {
      v6 = *(_QWORD *)(a1 + 56);
      if (v6)
      {
        if ((*(_BYTE *)(a1 + 64) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(_QWORD *)(a1 + 72));
        result = 0.0;
        *(_OWORD *)(a1 + 56) = 0u;
        *(_OWORD *)(a1 + 72) = 0u;
      }
    }
  }
  return result;
}

uint64_t re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::ensureCapacity(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v1 = result;
  if (*(_QWORD *)result)
  {
    v2 = *(_QWORD *)(result + 8);
    if ((*(_BYTE *)(result + 16) & 1) != 0)
      v3 = 1;
    else
      v3 = *(_QWORD *)(result + 24);
    if (v2 >= v3)
      return re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::growCapacity(result, v2 + 1);
  }
  else
  {
    v4 = *(_QWORD *)(v1 + 8) + 1;
    result = re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::setCapacity((uint64_t *)v1, v4);
    *(_DWORD *)(v1 + 16) += 2;
  }
  return result;
}

uint64_t re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::growCapacity(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;

  v2 = a2;
  v3 = result;
  if (!*(_QWORD *)result)
  {
    result = re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::setCapacity((uint64_t *)v3, v2);
    *(_DWORD *)(v3 + 16) += 2;
    return result;
  }
  if ((*(_BYTE *)(result + 16) & 1) != 0)
  {
    if (a2 <= 1)
      return result;
    v5 = 2;
  }
  else
  {
    v4 = *(_QWORD *)(result + 24);
    if (v4 >= a2)
      return result;
    v5 = 2 * v4;
  }
  if (v5 > a2)
    a2 = v5;
  return re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::setCapacity((uint64_t *)result, a2);
}

uint64_t re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::setCapacity(uint64_t *a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t result;
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _QWORD *v13;
  _QWORD *v14;
  __int128 v15;
  int v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  __int128 v20;
  int v21;

  result = *a1;
  if (a2 && !result)
  {
    result = re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::setCapacity(a1, a2);
    v6 = *((_DWORD *)a1 + 4) + 2;
LABEL_4:
    *((_DWORD *)a1 + 4) = v6;
    return result;
  }
  v7 = *((_DWORD *)a1 + 4);
  if ((v7 & 1) != 0)
    v8 = 1;
  else
    v8 = a1[3];
  if (v8 != a2)
  {
    v9 = a1[1];
    if (v9 <= a2 && (a2 > 1 || (v7 & 1) == 0))
    {
      if (a2 < 2)
      {
        if ((v7 & 1) != 0)
          v14 = a1 + 3;
        else
          v14 = (_QWORD *)a1[4];
        if (v9)
        {
          v15 = *(_OWORD *)v14;
          a1[5] = v14[2];
          *(_OWORD *)(a1 + 3) = v15;
          v16 = *((unsigned __int8 *)v14 + 24);
          *((_BYTE *)a1 + 48) = v16;
          if (v16)
            *((_DWORD *)a1 + 13) = *((_DWORD *)v14 + 7);
        }
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
        v6 = *((_DWORD *)a1 + 4) | 1;
        goto LABEL_4;
      }
      if (a2 >> 59)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 646, 32, a2);
        _os_crash();
        __break(1u);
      }
      else
      {
        v2 = 32 * a2;
        result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)result + 32))(result, 32 * a2, 8);
        if (result)
        {
          v11 = result;
          v12 = *((_DWORD *)a1 + 4);
          if ((v12 & 1) != 0)
            v13 = a1 + 3;
          else
            v13 = (_QWORD *)a1[4];
          v17 = a1[1];
          if (v17)
          {
            v18 = &v13[4 * v17];
            v19 = result;
            do
            {
              v20 = *(_OWORD *)v13;
              *(_QWORD *)(v19 + 16) = v13[2];
              *(_OWORD *)v19 = v20;
              v21 = *((unsigned __int8 *)v13 + 24);
              *(_BYTE *)(v19 + 24) = v21;
              if (v21)
                *(_DWORD *)(v19 + 28) = *((_DWORD *)v13 + 7);
              v13 += 4;
              v19 += 32;
            }
            while (v13 != v18);
            v12 = *((_DWORD *)a1 + 4);
          }
          if ((v12 & 1) == 0)
          {
            result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)*a1 + 40))(*a1, a1[4]);
            v12 = *((_DWORD *)a1 + 4);
          }
          *((_DWORD *)a1 + 4) = v12 & 0xFFFFFFFE;
          a1[3] = a2;
          a1[4] = v11;
          return result;
        }
      }
      re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, v2, *(_QWORD *)(*a1 + 8));
      result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

void re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (re::DynamicString *)(*(_QWORD *)&v13[16] + v10 + 16), (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 48));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 88;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

re::DynamicString *re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, _QWORD *a5)
{
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  re::DynamicString *result;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v9 = *(_DWORD *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    v9 = *(_DWORD *)(a1 + 32);
    v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 88 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 88 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  v13 = 88 * v9;
  *(_DWORD *)(v11 + v13 + 8) = v12 | 0x80000000;
  v14 = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v13) = a3;
  result = re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + v13 + 16), a4);
  v16 = *(_QWORD *)(a1 + 16);
  v17 = *(unsigned __int8 *)a5;
  *(_BYTE *)(v16 + 88 * v9 + 48) = v17;
  if (v17)
  {
    v18 = v16 + 88 * v9;
    *(_OWORD *)(v18 + 72) = 0u;
    *(_OWORD *)(v18 + 56) = 0u;
    *(_QWORD *)(v18 + 80) = a5[4];
    v19 = a5[2];
    *(_QWORD *)(v18 + 56) = a5[1];
    a5[1] = 0;
    v20 = a5[3];
    a5[4] = 0;
    v22 = *(_QWORD *)(v18 + 64);
    v21 = *(_QWORD *)(v18 + 72);
    *(_QWORD *)(v18 + 64) = v19;
    *(_QWORD *)(v18 + 72) = v20;
    a5[2] = v22;
    a5[3] = v21;
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v14) = v9;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

void re::HashTable<re::DynamicString,re::Optional<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 88 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_6, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_25, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::EntryWithoutHash::free(*(_QWORD *)(a1 + 16) + v3);
        ++v4;
        v3 += 64;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

void re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;

  re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16);
      if ((*(_DWORD *)(v8 + v6) & 0x80000000) != 0)
      {
        v9 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)(v8 + v6 + 8) >> 31) ^ (*(_QWORD *)(v8 + v6 + 8) >> 1));
        v10 = (0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) ^ ((0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) >> 31);
        re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsCopy(a1, v10 % *(unsigned int *)(a1 + 24), v10, (StringID *)(v8 + v6 + 8), (unsigned __int8 *)(v8 + v6 + 24));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 64;
    }
  }
}

uint64_t re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, unsigned __int8 *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,re::Optional<re::DynamicString>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + (v8 << 6));
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + (v8 << 6));
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  v13 = v8 << 6;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  v14 = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v8 << 6)) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(_QWORD *)(a1 + 16) + (v8 << 6) + 8), a4);
  v15 = *(_QWORD *)(a1 + 16) + (v8 << 6);
  v16 = *a5;
  *(_BYTE *)(v15 + 24) = v16;
  if (v16)
    re::DynamicString::DynamicString((re::DynamicString *)(v15 + 32), (const re::DynamicString *)(a5 + 8));
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v14) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::NetworkActionQueue::queueSyncAction(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint8_t v9[16];

  if (*(_BYTE *)a1)
  {
    v4 = (os_unfair_lock_s *)(a1 + 64);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
    v5 = *(_QWORD *)(a1 + 88);
    if (v5 >= *(_QWORD *)(a1 + 80))
    {
      re::DynamicArray<re::NetworkActionQueue::Action>::growCapacity((_QWORD *)(a1 + 72), v5 + 1);
      v5 = *(_QWORD *)(a1 + 88);
    }
    v6 = *(_QWORD *)(a1 + 104) + 168 * v5;
    *(_BYTE *)v6 = 0;
    *(_DWORD *)(v6 + 144) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>,(std::__variant_detail::_Trait)1> const&>(v6, a2);
    v7 = *(_QWORD *)(a2 + 152);
    *(_DWORD *)(v6 + 160) = *(_DWORD *)(a2 + 160);
    *(_QWORD *)(v6 + 152) = v7;
    ++*(_QWORD *)(a1 + 88);
    ++*(_DWORD *)(a1 + 96);
    os_unfair_lock_unlock(v4);
  }
  else
  {
    v8 = *re::assetsLogObjects((re *)a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v9 = 0;
      _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "Attempt to queue a network action when the queue is disabled.", v9, 2u);
    }
  }
}

void re::NetworkActionQueue::queueSyncActionShareAsset(uint64_t a1, uint64_t a2, int a3)
{
  _DWORD v3[36];
  int v4;
  uint64_t v5;
  int v6;
  char v7;

  v3[0] = a3;
  v4 = 0;
  v5 = a2;
  v6 = 0;
  re::NetworkActionQueue::queueSyncAction(a1, (uint64_t)v3);
  if (v4 != -1)
    ((void (*)(char *, _DWORD *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v4])(&v7, v3);
}

void re::NetworkActionQueue::queueSyncActionShareDependencies(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BYTE v5[144];
  int v6;
  uint64_t v7;
  int v8;
  char v9;

  re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v5, a3);
  v6 = 1;
  v7 = a2;
  v8 = 1;
  re::NetworkActionQueue::queueSyncAction(a1, (uint64_t)v5);
  if (v6 != -1)
    ((void (*)(char *, _BYTE *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v6])(&v9, v5);
}

void re::NetworkActionQueue::queueSyncActionShareLoadState(re::NetworkActionQueue *this, uint64_t a2)
{
  _DWORD v2[36];
  int v3;
  uint64_t v4;
  int v5;
  char v6;

  v2[0] = 0;
  v3 = 0;
  v4 = a2;
  v5 = 2;
  re::NetworkActionQueue::queueSyncAction((uint64_t)this, (uint64_t)v2);
  if (v3 != -1)
    ((void (*)(char *, _DWORD *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v3])(&v6, v2);
}

void re::NetworkActionQueue::queueSyncActionShareMetadata(re::NetworkActionQueue *this, uint64_t a2)
{
  _DWORD v2[36];
  int v3;
  uint64_t v4;
  int v5;
  char v6;

  v2[0] = 0;
  v3 = 0;
  v4 = a2;
  v5 = 3;
  re::NetworkActionQueue::queueSyncAction((uint64_t)this, (uint64_t)v2);
  if (v3 != -1)
    ((void (*)(char *, _DWORD *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v3])(&v6, v2);
}

void re::NetworkActionQueue::queueSyncActionRestrictAssetShareMode(uint64_t a1, uint64_t a2, int a3)
{
  _DWORD v3[36];
  int v4;
  uint64_t v5;
  int v6;
  char v7;

  v3[0] = a3;
  v4 = 0;
  v5 = a2;
  v6 = 4;
  re::NetworkActionQueue::queueSyncAction(a1, (uint64_t)v3);
  if (v4 != -1)
    ((void (*)(char *, _DWORD *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v4])(&v7, v3);
}

void re::NetworkActionQueue::queueSyncActionNetworkLoad(re::NetworkActionQueue *this, uint64_t a2, const re::DynamicString *a3)
{
  _BYTE v5[144];
  int v6;
  uint64_t v7;
  int v8;
  char v9;

  re::DynamicString::DynamicString((re::DynamicString *)v5, a3);
  v6 = 3;
  v7 = a2;
  v8 = 5;
  re::NetworkActionQueue::queueSyncAction((uint64_t)this, (uint64_t)v5);
  if (v6 != -1)
    ((void (*)(char *, _BYTE *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v6])(&v9, v5);
}

void re::NetworkActionQueue::queueSyncActionPeerLoad(uint64_t a1, uint64_t a2, const re::AssetLoadDescriptor *a3)
{
  _BYTE v5[144];
  int v6;
  uint64_t v7;
  int v8;
  char v9;

  re::AssetLoadDescriptor::AssetLoadDescriptor((re::AssetLoadDescriptor *)v5, a3);
  v6 = 2;
  v7 = a2;
  v8 = 6;
  re::NetworkActionQueue::queueSyncAction(a1, (uint64_t)v5);
  if (v6 != -1)
    ((void (*)(char *, _BYTE *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v6])(&v9, v5);
}

void re::NetworkActionQueue::queueSyncActionPreloadOnLocalPeer(re::NetworkActionQueue *this, uint64_t a2)
{
  _DWORD v2[36];
  int v3;
  uint64_t v4;
  int v5;
  char v6;

  v2[0] = 0;
  v3 = 0;
  v4 = a2;
  v5 = 7;
  re::NetworkActionQueue::queueSyncAction((uint64_t)this, (uint64_t)v2);
  if (v3 != -1)
    ((void (*)(char *, _DWORD *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v3])(&v6, v2);
}

void re::NetworkActionQueue::readActions(re::NetworkActionQueue *this@<X0>, uint64_t a2@<X8>)
{
  os_unfair_lock_s *v4;

  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v4 = (os_unfair_lock_s *)((char *)this + 64);
  *(_DWORD *)(a2 + 24) = 0;
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  re::DynamicArray<re::NetworkActionQueue::Action>::operator=(a2, (uint64_t *)this + 9);
  os_unfair_lock_unlock(v4);
}

void re::NetworkActionQueue::removeActions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  unint64_t v28;
  __int16 v29;
  unint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v6 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  v21 = 0;
  v19 = 0uLL;
  v18 = 0;
  v20 = 0;
  v7 = *(_QWORD *)(a1 + 88);
  if (v7)
    re::DynamicArray<re::NetworkActionQueue::Action>::setCapacity(&v18, v7);
  v8 = *(_QWORD *)(a2 + 8);
  if (v8)
  {
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *(_QWORD *)(a3 + 8);
      if (v11 <= v10)
        break;
      if (!*(_BYTE *)(*(_QWORD *)(a3 + 16) + v10) && !*(_BYTE *)(*(_QWORD *)(a2 + 16) + v10))
      {
        v11 = *(_QWORD *)(a1 + 88);
        if (v11 <= v10)
          goto LABEL_34;
        re::DynamicArray<re::NetworkActionQueue::Action>::add((_anonymous_namespace_ *)&v18, *(_QWORD *)(a1 + 104) + v9);
        v8 = *(_QWORD *)(a2 + 8);
      }
      ++v10;
      v9 += 168;
      if (v8 <= v10)
      {
        v12 = (int)v8;
        goto LABEL_13;
      }
    }
    v22 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v23 = 136315906;
    v24 = "operator[]";
    v25 = 1024;
    v26 = 476;
    v27 = 2048;
    v28 = v10;
    v29 = 2048;
    v30 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_32;
  }
  v12 = 0;
LABEL_13:
  if (*(_QWORD *)(a1 + 88) > v12)
  {
    v13 = 168 * (int)v12;
    do
    {
      re::DynamicArray<re::NetworkActionQueue::Action>::add((_anonymous_namespace_ *)&v18, *(_QWORD *)(a1 + 104) + v13);
      ++v12;
      v13 += 168;
    }
    while (*(_QWORD *)(a1 + 88) > v12);
    v8 = *(_QWORD *)(a2 + 8);
  }
  if (v8)
  {
    v14 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *(_QWORD *)(a3 + 8);
      if (v11 <= v10)
        break;
      if (*(_BYTE *)(*(_QWORD *)(a3 + 16) + v10) && !*(_BYTE *)(*(_QWORD *)(a2 + 16) + v10))
      {
        v11 = *(_QWORD *)(a1 + 88);
        if (v11 <= v10)
          goto LABEL_33;
        re::DynamicArray<re::NetworkActionQueue::Action>::add((_anonymous_namespace_ *)&v18, *(_QWORD *)(a1 + 104) + v14);
        v8 = *(_QWORD *)(a2 + 8);
      }
      ++v10;
      v14 += 168;
      if (v8 <= v10)
        goto LABEL_25;
    }
LABEL_32:
    v22 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v23 = 136315906;
    v24 = "operator[]";
    v25 = 1024;
    v26 = 476;
    v27 = 2048;
    v28 = v10;
    v29 = 2048;
    v30 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_33:
    v22 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v23 = 136315906;
    v24 = "operator[]";
    v25 = 1024;
    v26 = 789;
    v27 = 2048;
    v28 = v10;
    v29 = 2048;
    v30 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_34:
    v22 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v23 = 136315906;
    v24 = "operator[]";
    v25 = 1024;
    v26 = 789;
    v27 = 2048;
    v28 = v10;
    v29 = 2048;
    v30 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_35:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
    _os_crash();
    __break(1u);
  }
LABEL_25:
  if ((uint64_t *)(a1 + 72) != &v18)
  {
    v15 = *(_QWORD *)(a1 + 72);
    if (v15 && v18 && v15 != v18)
      goto LABEL_35;
    *(_QWORD *)(a1 + 72) = v18;
    v18 = v15;
    v16 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)(a1 + 80) = v19;
    v19 = v16;
    v17 = *(_QWORD *)(a1 + 104);
    *(_QWORD *)(a1 + 104) = v21;
    v21 = v17;
    ++v20;
    ++*(_DWORD *)(a1 + 96);
  }
  re::DynamicArray<re::NetworkActionQueue::Action>::deinit((uint64_t)&v18);
  os_unfair_lock_unlock(v6);
}

void re::NetworkActionQueue::removeLoadActions(os_unfair_lock_s *this, uint64_t a2)
{
  os_unfair_lock_s *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _OWORD v19[5];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v4 = this + 16;
  os_unfair_lock_lock(this + 16);
  v5 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
  if ((int)v5 >= 1)
  {
    v6 = *(_QWORD *)&this[22]._os_unfair_lock_opaque + 1;
    while (1)
    {
      v7 = (v6 - 2);
      if (v5 <= v7)
      {
        memset(v19, 0, sizeof(v19));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v8 = *(_QWORD *)&this[26]._os_unfair_lock_opaque;
      v9 = v8 + 168 * v7;
      v11 = *(_QWORD *)(v9 + 152);
      v10 = v9 + 152;
      if (v11 != a2 || (*(_DWORD *)(v8 + 168 * v7 + 160) - 5) > 1)
        goto LABEL_16;
      if (v5 - 1 > v7)
        break;
LABEL_13:
      v17 = v8 + 168 * v5;
      v18 = *(unsigned int *)(v17 - 24);
      if ((_DWORD)v18 != -1)
      {
        ((void (*)(_OWORD *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v18])(v19, v17 - 168);
        v5 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
      }
      *(_DWORD *)(v17 - 24) = -1;
      *(_QWORD *)&this[22]._os_unfair_lock_opaque = --v5;
      ++this[24]._os_unfair_lock_opaque;
LABEL_16:
      if ((unint64_t)--v6 <= 1)
        goto LABEL_17;
    }
    v12 = v8 + 168 * v5;
    v13 = v8 + 168 * v7;
    v14 = *(unsigned int *)(v13 + 144);
    v15 = *(unsigned int *)(v12 - 24);
    if ((_DWORD)v14 == -1)
    {
      if ((_DWORD)v15 == -1)
        goto LABEL_12;
    }
    else if ((_DWORD)v15 == -1)
    {
      ((void (*)(_OWORD *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v14])(v19, v13);
      *(_DWORD *)(v13 + 144) = -1;
LABEL_12:
      v16 = *(_QWORD *)(v12 - 16);
      *(_DWORD *)(v10 + 8) = *(_DWORD *)(v12 - 8);
      *(_QWORD *)v10 = v16;
      v5 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
      v8 = *(_QWORD *)&this[26]._os_unfair_lock_opaque;
      goto LABEL_13;
    }
    *(_QWORD *)&v19[0] = v13;
    ((void (*)(_OWORD *, uint64_t, uint64_t))off_24ED2E070[v15])(v19, v13, v12 - 168);
    goto LABEL_12;
  }
LABEL_17:
  os_unfair_lock_unlock(v4);
}

BOOL re::NetworkActionQueue::hasLoadActions(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  _BOOL8 v7;
  BOOL v8;

  v2 = this + 16;
  os_unfair_lock_lock(this + 16);
  v3 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
  if (v3)
  {
    v4 = 168 * v3 - 168;
    v5 = (int *)(*(_QWORD *)&this[26]._os_unfair_lock_opaque + 160);
    do
    {
      v6 = *v5;
      v5 += 42;
      v7 = (v6 - 5) < 2;
      v8 = (v6 - 5) < 2 || v4 == 0;
      v4 -= 168;
    }
    while (!v8);
  }
  else
  {
    v7 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v7;
}

uint64_t re::DynamicArray<re::NetworkActionQueue::Action>::clear(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;

  v1 = result;
  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = 0;
  if (v2)
  {
    v3 = *(_QWORD *)(result + 32);
    v4 = 168 * v2;
    do
    {
      v5 = *(unsigned int *)(v3 + 144);
      if ((_DWORD)v5 != -1)
        result = ((uint64_t (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v5])(&v6, v3);
      *(_DWORD *)(v3 + 144) = -1;
      v3 += 168;
      v4 -= 168;
    }
    while (v4);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

_QWORD *re::DynamicArray<re::NetworkActionQueue::Action>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::NetworkActionQueue::Action>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::NetworkActionQueue::Action>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::NetworkActionQueue::Action>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::NetworkActionQueue::Action>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA8uLL))
        {
          v2 = 168 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 168 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_18;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 168, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 168 * v9;
        v11 = (uint64_t)v7;
        do
        {
          *(_BYTE *)v11 = 0;
          *(_DWORD *)(v11 + 144) = -1;
          std::__variant_detail::__ctor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>,(std::__variant_detail::_Trait)1>>(v11, v8);
          v12 = *(_QWORD *)(v8 + 152);
          *(_DWORD *)(v11 + 160) = *(_DWORD *)(v8 + 160);
          *(_QWORD *)(v11 + 152) = v12;
          v13 = *(unsigned int *)(v8 + 144);
          if ((_DWORD)v13 != -1)
            ((void (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v13])(&v14, v8);
          *(_DWORD *)(v8 + 144) = -1;
          v8 += 168;
          v11 += 168;
          v10 -= 168;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;

  v3 = result;
  v4 = *(unsigned int *)(result + 144);
  if ((_DWORD)v4 != -1)
    result = ((uint64_t (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v4])(&v7, result);
  *(_DWORD *)(v3 + 144) = -1;
  v5 = *(unsigned int *)(a2 + 144);
  if ((_DWORD)v5 != -1)
  {
    result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_24ED2E010[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 144) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_DWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 36) = 0x7FFFFFFFLL;
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a2, a3);
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__variant_detail::__alt<2ul,re::AssetLoadDescriptor>::__alt[abi:nn180100]<re::AssetLoadDescriptor>(a2, a3);
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 24) = a3[3];
  v4 = a3[1];
  *(_QWORD *)a2 = *a3;
  *a3 = 0;
  v5 = a3[2];
  a3[3] = 0;
  v7 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = v4;
  *(_QWORD *)(a2 + 16) = v5;
  a3[1] = v7;
  a3[2] = v6;
  return result;
}

double std::__variant_detail::__alt<2ul,re::AssetLoadDescriptor>::__alt[abi:nn180100]<re::AssetLoadDescriptor>(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  v4 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 24) = 0;
  v6 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a2 + 8) = v6;
  *(_QWORD *)(a2 + 16) = v5;
  *(_QWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v7 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v7;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v8 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v8;
  v9 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v9;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  v10 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 80) = v10;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  v11 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = v11;
  v12 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v12;
  ++*(_DWORD *)(a2 + 96);
  ++*(_DWORD *)(a1 + 96);
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  v13 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 112) = 0;
  v14 = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 136) = 0;
  v16 = *(_QWORD *)(a1 + 120);
  v15 = *(_QWORD *)(a1 + 128);
  *(_QWORD *)(a1 + 120) = v13;
  *(_QWORD *)(a1 + 128) = v14;
  *(_QWORD *)(a2 + 120) = v16;
  *(_QWORD *)(a2 + 128) = v15;
  return result;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;

  v3 = result;
  v4 = *(unsigned int *)(result + 144);
  if ((_DWORD)v4 != -1)
    result = ((uint64_t (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v4])(&v7, result);
  *(_DWORD *)(v3 + 144) = -1;
  v5 = *(unsigned int *)(a2 + 144);
  if ((_DWORD)v5 != -1)
  {
    result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_24ED2E030[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 144) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(a2, a3);
}

re::AssetLoadDescriptor *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEERKSZ_EEEDcSR_DpT0_(int a1, re::AssetLoadDescriptor *this, re::AssetLoadDescriptor *a3)
{
  return re::AssetLoadDescriptor::AssetLoadDescriptor(this, a3);
}

re::DynamicString *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEERKSZ_EEEDcSR_DpT0_(int a1, re::DynamicString *this, re::DynamicString *a3)
{
  return re::DynamicString::DynamicString(this, a3);
}

uint64_t re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u)
      v5 = 3;
    else
      v5 = *(_DWORD *)(a2 + 28);
    re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init(a1, v4, v5);
    re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::NetworkActionQueue::Action>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::NetworkActionQueue::Action>::copy((_QWORD *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::NetworkActionQueue::Action>::clear(a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::NetworkActionQueue::Action>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::NetworkActionQueue::Action>::copy((_QWORD *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::NetworkActionQueue::Action>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::NetworkActionQueue::Action>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::NetworkActionQueue::Action *,re::NetworkActionQueue::Action *,re::NetworkActionQueue::Action *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 168 * a1[2], a1[4]);
    v10 = a1[2];
    if (v10 != v4)
    {
      v11 = *(_QWORD *)(a2 + 32);
      v12 = v11 + 168 * v4;
      v13 = 168 * v10;
      v14 = v11 + v13;
      v15 = a1[4] + v13;
      do
      {
        *(_BYTE *)v15 = 0;
        *(_DWORD *)(v15 + 144) = -1;
        result = std::__variant_detail::__ctor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>,(std::__variant_detail::_Trait)1> const&>(v15, v14);
        v16 = *(_QWORD *)(v14 + 152);
        *(_DWORD *)(v15 + 160) = *(_DWORD *)(v14 + 160);
        *(_QWORD *)(v15 + 152) = v16;
        v14 += 168;
        v15 += 168;
      }
      while (v14 != v12);
    }
  }
  else
  {
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::NetworkActionQueue::Action *,re::NetworkActionQueue::Action *,re::NetworkActionQueue::Action *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 168 * v4, a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = a1[4] + 168 * v4;
      v8 = -168 * v4 + 168 * v6;
      do
      {
        v9 = *(unsigned int *)(v7 + 144);
        if ((_DWORD)v9 != -1)
          result = ((uint64_t (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v9])(&v17, v7);
        *(_DWORD *)(v7 + 144) = -1;
        v7 += 168;
        v8 -= 168;
      }
      while (v8);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::NetworkActionQueue::Action *,re::NetworkActionQueue::Action *,re::NetworkActionQueue::Action *,0>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;

  if (result != a2)
  {
    v13 = v3;
    v14 = v4;
    for (i = result; i != a2; i += 168)
    {
      v8 = *(unsigned int *)(a3 + 144);
      v9 = *(unsigned int *)(i + 144);
      if ((_DWORD)v8 == -1)
      {
        if ((_DWORD)v9 != -1)
        {
LABEL_7:
          v11 = a3;
          result = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))off_24ED2E050[v9])(&v11, a3, i);
        }
      }
      else
      {
        if ((_DWORD)v9 != -1)
          goto LABEL_7;
        result = ((uint64_t (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v8])(&v12, a3);
        *(_DWORD *)(a3 + 144) = -1;
      }
      v10 = *(_QWORD *)(i + 152);
      *(_DWORD *)(a3 + 160) = *(_DWORD *)(i + 160);
      *(_QWORD *)(a3 + 152) = v10;
      a3 += 168;
    }
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSQ_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEERKSY_EEEDcSQ_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4;
  uint64_t v5;
  char v6;

  v4 = *(_DWORD **)result;
  v5 = *(unsigned int *)(*(_QWORD *)result + 144);
  if ((_DWORD)v5 != -1)
  {
    if (!(_DWORD)v5)
    {
      *a2 = *a3;
      return result;
    }
    result = ((uint64_t (*)(char *, _DWORD *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v5])(&v6, v4);
  }
  *v4 = *a3;
  v4[36] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSQ_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEERKSY_EEEDcSQ_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  char v7;

  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 144);
  if ((_DWORD)v5 != -1)
  {
    if ((_DWORD)v5 == 1)
      return re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a2, a3);
    ((void (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v5])(&v7, v4);
  }
  *(_DWORD *)(v4 + 144) = -1;
  result = re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v4, a3);
  *(_DWORD *)(v4 + 144) = 1;
  return result;
}

re::AssetLoadDescriptor *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSQ_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEERKSY_EEEDcSQ_DpT0_(re::AssetLoadDescriptor **a1, re::DynamicString *this, re::AssetLoadDescriptor *a3)
{
  re::AssetLoadDescriptor *v4;
  uint64_t v5;
  re::AssetLoadDescriptor *result;
  char v8;

  v4 = *a1;
  v5 = *((unsigned int *)*a1 + 36);
  if ((_DWORD)v5 != -1)
  {
    if ((_DWORD)v5 == 2)
    {
      re::DynamicString::operator=(this, a3);
      re::DynamicArray<BOOL>::operator=((uint64_t)this + 32, (uint64_t *)a3 + 4);
      re::DynamicArray<BOOL>::operator=((uint64_t)this + 72, (uint64_t *)a3 + 9);
      return re::DynamicString::operator=((re::DynamicString *)((char *)this + 112), (re::AssetLoadDescriptor *)((char *)a3 + 112));
    }
    ((void (*)(char *, re::AssetLoadDescriptor *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v5])(&v8, v4);
  }
  *((_DWORD *)v4 + 36) = -1;
  result = re::AssetLoadDescriptor::AssetLoadDescriptor(v4, a3);
  *((_DWORD *)v4 + 36) = 2;
  return result;
}

re::DynamicString *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSQ_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEERKSY_EEEDcSQ_DpT0_(re::DynamicString **a1, re::DynamicString *this, re::DynamicString *a3)
{
  re::DynamicString *v4;
  uint64_t v5;
  re::DynamicString *result;
  char v7;

  v4 = *a1;
  v5 = *((unsigned int *)*a1 + 36);
  if ((_DWORD)v5 != -1)
  {
    if ((_DWORD)v5 == 3)
      return re::DynamicString::operator=(this, a3);
    ((void (*)(char *, re::DynamicString *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v5])(&v7, v4);
  }
  *((_DWORD *)v4 + 36) = -1;
  result = re::DynamicString::DynamicString(v4, a3);
  *((_DWORD *)v4 + 36) = 3;
  return result;
}

uint64_t re::DynamicArray<re::NetworkActionQueue::Action>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::NetworkActionQueue::Action>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 168 * v4;
  *(_BYTE *)v5 = 0;
  *(_DWORD *)(v5 + 144) = -1;
  result = std::__variant_detail::__ctor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::AssetNetworkSharingMode,re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>,re::AssetLoadDescriptor,re::DynamicString>,(std::__variant_detail::_Trait)1>>(v5, a2);
  v7 = *(_QWORD *)(a2 + 152);
  *(_DWORD *)(v5 + 160) = *(_DWORD *)(a2 + 160);
  *(_QWORD *)(v5 + 152) = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEEOSW_EEEDcSO_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4;
  uint64_t v5;
  char v6;

  v4 = *(_DWORD **)result;
  v5 = *(unsigned int *)(*(_QWORD *)result + 144);
  if ((_DWORD)v5 != -1)
  {
    if (!(_DWORD)v5)
    {
      *a2 = *a3;
      return result;
    }
    result = ((uint64_t (*)(char *, _DWORD *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v5])(&v6, v4);
  }
  *v4 = *a3;
  v4[36] = 0;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  char v7;

  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 144);
  if ((_DWORD)v5 == -1)
    goto LABEL_9;
  if ((_DWORD)v5 != 1)
  {
    ((void (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v5])(&v7, v4);
LABEL_9:
    *(_DWORD *)(v4 + 144) = -1;
    *(_OWORD *)v4 = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    *(_DWORD *)(v4 + 32) = 0;
    *(_QWORD *)(v4 + 36) = 0x7FFFFFFFLL;
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v4, a3);
    *(_DWORD *)(v4 + 144) = 1;
    return;
  }
  if ((uint64_t *)a2 != a3)
  {
    if (!*(_QWORD *)a2 || *(_QWORD *)a2 == *a3)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a2, a3);
    }
    else if (*a3)
    {
      re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a2, (uint64_t)a3);
      ++*(_DWORD *)(a2 + 40);
    }
    else
    {
      re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a2);
    }
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, re::DynamicString *this, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  char v7;

  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 144);
  if ((_DWORD)v5 != -1)
  {
    if ((_DWORD)v5 == 2)
    {
      re::DynamicString::operator=(this, (re::DynamicString *)a3);
      re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)this + 32, a3 + 32);
      re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)this + 72, a3 + 72);
      re::DynamicString::operator=((re::DynamicString *)((char *)this + 112), (re::DynamicString *)(a3 + 112));
      return;
    }
    ((void (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v5])(&v7, v4);
  }
  *(_DWORD *)(v4 + 144) = -1;
  std::__variant_detail::__alt<2ul,re::AssetLoadDescriptor>::__alt[abi:nn180100]<re::AssetLoadDescriptor>(v4, a3);
  *(_DWORD *)(v4 + 144) = 2;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJS9_SG_SH_SB_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, re::DynamicString *this, re::DynamicString *a3)
{
  uint64_t v4;
  uint64_t v5;
  double result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;

  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 144);
  if ((_DWORD)v5 != -1)
  {
    if ((_DWORD)v5 == 3)
    {
      re::DynamicString::operator=(this, a3);
      return result;
    }
    ((void (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS6_9HashTableINS6_13DynamicStringEyNS6_4HashIS9_EENS6_7EqualToIS9_EELb1ELb0EEENS6_19AssetLoadDescriptorES9_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSI_EEEDcOSJ_DpOT0____fmatrix[v5])(&v11, v4);
  }
  result = 0.0;
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_QWORD *)(v4 + 24) = *((_QWORD *)a3 + 3);
  v7 = *((_QWORD *)a3 + 1);
  *(_QWORD *)v4 = *(_QWORD *)a3;
  *(_QWORD *)a3 = 0;
  v8 = *((_QWORD *)a3 + 2);
  *((_QWORD *)a3 + 3) = 0;
  v10 = *(_QWORD *)(v4 + 8);
  v9 = *(_QWORD *)(v4 + 16);
  *(_QWORD *)(v4 + 8) = v7;
  *(_QWORD *)(v4 + 16) = v8;
  *((_QWORD *)a3 + 1) = v10;
  *((_QWORD *)a3 + 2) = v9;
  *(_DWORD *)(v4 + 144) = 3;
  return result;
}

uint64_t *re::allocInfo_AssetLoadDescriptor(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_49);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_49))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC3D0, 0);
    *(uint64_t *)((char *)&qword_2540FC3E0 + 6) = 0;
    qword_2540FC3E0 = 0;
    qword_2540FC3F0 = 0;
    qword_2540FC3F8 = 0xFFFFFFFFLL;
    qword_2540FC3D0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC400 = (uint64_t)"AssetLoadDescriptor";
    dword_2540FC408 = 0;
    *(_OWORD *)&algn_2540FC40C[4] = 0u;
    *(_OWORD *)&algn_2540FC40C[20] = 0u;
    *(_OWORD *)&algn_2540FC40C[36] = 0u;
    qword_2540FC440 = 0;
    __cxa_guard_release(&_MergedGlobals_49);
  }
  return &qword_2540FC3D0;
}

void re::initInfo_AssetLoadDescriptor(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  __int128 v18;
  _QWORD v19[2];
  __int128 v20;

  v19[0] = 0xBD52FE729D2D4FCALL;
  v19[1] = "AssetLoadDescriptor";
  re::StringID::destroyString((re::StringID *)v19);
  *((_OWORD *)this + 2) = v20;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FC3B0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FC3B0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicString>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "scheme";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FC3B8 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "data";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x2000000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540FC3C0 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v16 = re::IntrospectionInfo<re::DynamicString>::get(1, v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = "assetType";
      *(_QWORD *)(v17 + 16) = v16;
      *(_QWORD *)(v17 + 24) = 0;
      *(_QWORD *)(v17 + 32) = 0x7000000003;
      *(_DWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_2540FC3C8 = v17;
      __cxa_guard_release(&qword_2540FC3B0);
    }
  }
  *((_QWORD *)this + 2) = 0x9000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((_QWORD *)this + 8) = &qword_2540FC3B8;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::AssetLoadDescriptor>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::AssetLoadDescriptor>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::AssetLoadDescriptor>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::AssetLoadDescriptor>;
  re::IntrospectionRegistry::add(this, v3);
  v18 = v20;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::info = (uint64_t)&off_24ED2E0A0;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::introspect_uint8_t((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::info, 0);
    qword_255800628 = 0x2800000003;
    dword_255800630 = v11;
    word_255800634 = 0;
    *(_QWORD *)&xmmword_255800638 = 0;
    *((_QWORD *)&xmmword_255800638 + 1) = 0xFFFFFFFFLL;
    qword_255800648 = v10;
    unk_255800650 = 0;
    re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::info = (uint64_t)&off_24ED2E0A0;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_255800638 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<unsigned char>>::get(BOOL)::info;
}

_QWORD *re::internal::defaultConstruct<re::AssetLoadDescriptor>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  _anonymous_namespace_ *v4;

  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a3, 0);
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_DWORD *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(_QWORD *)(a3 + 136) = 0;
  return re::DynamicString::setCapacity((_QWORD *)(a3 + 112), 0);
}

double re::internal::defaultDestruct<re::AssetLoadDescriptor>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  _OWORD *v5;
  double result;
  uint64_t v7;
  uint64_t v8;

  v5 = a3 + 14;
  v4 = a3[14];
  if (v4)
  {
    if ((a3[15] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, a3[16]);
    result = 0.0;
    *v5 = 0u;
    v5[1] = 0u;
  }
  v7 = a3[9];
  if (v7)
  {
    if (a3[13])
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    a3[13] = 0;
    a3[10] = 0;
    a3[11] = 0;
    a3[9] = 0;
    ++*((_DWORD *)a3 + 24);
  }
  v8 = a3[4];
  if (v8)
  {
    if (a3[8])
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
    a3[8] = 0;
    a3[5] = 0;
    a3[6] = 0;
    a3[4] = 0;
    ++*((_DWORD *)a3 + 14);
  }
  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::AssetLoadDescriptor>(uint64_t a1)
{
  _anonymous_namespace_ *v2;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a1, 0);
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_QWORD *)(a1 + 136) = 0;
  return re::DynamicString::setCapacity((_QWORD *)(a1 + 112), 0);
}

double re::internal::defaultDestructV2<re::AssetLoadDescriptor>(_QWORD *a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;
  uint64_t v5;
  uint64_t v6;

  v3 = a1 + 14;
  v2 = a1[14];
  if (v2)
  {
    if ((a1[15] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, a1[16]);
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  v5 = a1[9];
  if (v5)
  {
    if (a1[13])
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    a1[13] = 0;
    a1[10] = 0;
    a1[11] = 0;
    a1[9] = 0;
    ++*((_DWORD *)a1 + 24);
  }
  v6 = a1[4];
  if (v6)
  {
    if (a1[8])
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    a1[8] = 0;
    a1[5] = 0;
    a1[6] = 0;
    a1[4] = 0;
    ++*((_DWORD *)a1 + 14);
  }
  if (*a1)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

uint64_t re::introspect_AssetLoadDescriptor(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AssetLoadDescriptor", (uint64_t (*)(re::internal *))re::allocInfo_AssetLoadDescriptor, (re::IntrospectionBase *(*)(void))re::initInfo_AssetLoadDescriptor, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AssetLoadDescriptor>, this);
}

uint64_t re::AssetLoadDescriptor::setIntrospectableData(char **this, const re::IntrospectionBase *a2, const re::IntrospectionBase **a3, re::Allocator *a4)
{
  uint64_t *v4;
  size_t v8;
  char *v9;
  void *v10;
  void *v11;
  size_t v13;
  void *__src;

  v4 = (uint64_t *)a4;
  if (!a4)
  {
  }
  v13 = 0;
  __src = 0;
  re::serializeBinaryToBuffer(a2, a3, 0, (uint64_t)v4, (uint64_t)v4, (uint64_t *)&__src, (uint64_t *)&v13);
  v8 = v13;
  this[6] = 0;
  ++*((_DWORD *)this + 14);
  re::DynamicArray<BOOL>::resize((uint64_t)(this + 4), v8 + 22);
  strcpy(this[8], "Z9T4");
  this[8][5] = 0;
  v9 = this[8];
  *(_QWORD *)(v9 + 6) = 0;
  *(_QWORD *)(v9 + 14) = v8;
  v10 = this[8] + 22;
  v11 = __src;
  memcpy(v10, __src, v8);
  return (*(uint64_t (**)(uint64_t *, void *))(*v4 + 40))(v4, v11);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData(re::AssetLoadDescriptor *this, re **a2, uint64_t **a3, re::Allocator *a4)
{
  uint64_t *v4;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v13;
  uint64_t *v14;
  _anonymous_namespace_ *v15;
  _anonymous_namespace_ *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint8_t buf[8];
  const char *v31;
  uint64_t v32;
  uint64_t *v33;
  __int128 v34;
  __int128 v35;
  _BYTE v36[12];
  int v37;
  uint64_t v38;
  uint64_t v39;
  void (**v40)(re::MemoryStreamReader *__hidden);
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v4 = (uint64_t *)a4;
  if (!a4)
  {
  }
  v8 = *((_QWORD *)this + 8);
  if (*(_DWORD *)v8 == 877934938)
  {
    if (*(_BYTE *)(v8 + 4))
    {
      v9 = *re::assetsLogObjects(this);
      v10 = 0;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v11 = "Failed getIntrospectableData: Incoming Asset Load Descriptor newer than current version";
LABEL_9:
        _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEFAULT, v11, buf, 2u);
        return 0;
      }
      return v10;
    }
    if (*(_BYTE *)(v8 + 5))
    {
      if (*(_BYTE *)(v8 + 5) == 1)
      {
        v27 = 0;
        v28 = 0;
        v29 = 0;
        v13 = v8 + 22;
        v14 = *(uint64_t **)(v8 + 14);
        *(_QWORD *)buf = &off_24ED7BDD0;
        LOBYTE(v31) = 0;
        v32 = v8 + 22;
        v33 = v14;
        *((_QWORD *)v15 + 1) = 0;
        *((_QWORD *)v15 + 2) = 0;
        *(_QWORD *)v15 = 0;
        WORD4(v34) = 256;
        *(_QWORD *)&v34 = &off_24ED7C2E0;
        *(_QWORD *)&v35 = v15;
        *((_QWORD *)&v35 + 1) = &unk_24ED1E828;
        *(_QWORD *)v36 = v13;
        *(_DWORD *)&v36[8] = (_DWORD)v14;
        v37 = (int)v14;
        v38 = 0;
        v39 = (int)v14;
        *(_QWORD *)buf = &off_24ED7BDD0;
        re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)&v34);
        return 1;
      }
      v9 = *re::assetsLogObjects(this);
      v10 = 0;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        return v10;
      *(_WORD *)buf = 0;
      v11 = "Failed getIntrospectableData: unsupported serialization method for AssetLoadDescriptor";
      goto LABEL_9;
    }
    v17 = *(_QWORD *)(v8 + 6);
    if (!v17)
    {
      v25 = re::DynamicArray<unsigned char>::slice((uint64_t)this + 32, 0x16uLL, *((_QWORD *)this + 6) - 22);
      *(_QWORD *)buf = &off_24ED7C9D0;
      v31 = (const char *)v25;
      v32 = v26;
      v33 = 0;
    }
    v18 = re::DynamicArray<unsigned char>::slice((uint64_t)this + 32, 0x16uLL, *(_QWORD *)(v8 + 6));
    v20 = v19;
    LOBYTE(v32) = 0;
    *(_QWORD *)buf = &off_24ED42538;
    v31 = "schema";
    v33 = v4;
    v34 = 0u;
    v35 = 0u;
    *(_DWORD *)v36 = 0;
    *(_QWORD *)&v36[4] = 0x7FFFFFFFLL;
    re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)&v34, (uint64_t)v4, 3);
    v40 = &off_24ED7C9D0;
    v41 = v18;
    v42 = v20;
    v43 = 0;
    if ((_BYTE)v27)
    {
      v21 = v17 + 22;
      v22 = v28;
      v23 = re::DynamicArray<unsigned char>::slice((uint64_t)this + 32, v21, *((_QWORD *)this + 6) - v21);
      v40 = &off_24ED7C9D0;
      v41 = v23;
      v42 = v24;
      v43 = 0;
      if ((_BYTE)v27)
      {
LABEL_25:
        re::AutoFreeAllocator::~AutoFreeAllocator((re::AutoFreeAllocator *)buf);
        return v10;
      }
    }
    else
    {
      v10 = 0;
    }
    if (v28 && (v29 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v28 + 40))();
    goto LABEL_25;
  }
  v9 = *re::assetsLogObjects(this);
  v10 = 0;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    v11 = "Failed getIntrospectableData: Incoming Asset Load Descriptor does not have the proper tag";
    goto LABEL_9;
  }
  return v10;
}

unint64_t re::DynamicArray<unsigned char>::slice(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v6;
  __int128 v7;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 + 1 <= a2)
  {
    v6 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v7) = 136315906;
    *(_QWORD *)((char *)&v7 + 4) = "slice";
    WORD6(v7) = 1024;
    HIWORD(v7) = 1119;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_6;
  }
  if (__CFADD__(a2, a3))
  {
LABEL_6:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::slice(size_t,size_t). index, %zu, count = %zu, array size = %zu", "!overflow", "slice", 1125, a2, a3, v4, v6, v7);
    _os_crash();
    __break(1u);
LABEL_7:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Invalid count. index = %zu, count = %zu, array size = %zu", "endIndexExclusive <= m_size", "slice", 1129, a2, a3, v4);
    _os_crash();
    __break(1u);
  }
  if (a2 + a3 > v4)
    goto LABEL_7;
  return *(_QWORD *)(a1 + 32) + a2;
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionDynamicArray<unsigned char>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<unsigned char>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<unsigned char>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<unsigned char>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<unsigned char>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<BOOL>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

void re::IntrospectionDynamicArray<unsigned char>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<BOOL>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<BOOL>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<BOOL>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<unsigned char>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  char v10;

  v10 = 0;
  re::DynamicArray<unsigned char>::add(this, &v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 2) + *((_QWORD *)this + 4) - 1);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<unsigned char>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

unint64_t re::IntrospectionDynamicArray<unsigned char>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + a3;
}

_QWORD *re::DynamicArray<unsigned char>::add(_QWORD *this, _BYTE *a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<BOOL>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  *(_BYTE *)(v3[4] + v4) = *a2;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<BOOL>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  char v4;

  re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()((uint64_t)&v4, a1, a2, a3, a4);
}

unint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned char>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

uint64_t *re::allocInfo_PeerAssetLoadDescriptorParameters(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_50);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_50))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC468, 0);
    *(uint64_t *)((char *)&qword_2540FC478 + 6) = 0;
    qword_2540FC478 = 0;
    qword_2540FC488 = 0;
    qword_2540FC490 = 0xFFFFFFFFLL;
    qword_2540FC468 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC498 = (uint64_t)"PeerAssetLoadDescriptorParameters";
    dword_2540FC4A0 = 0;
    xmmword_2540FC4A8 = 0u;
    unk_2540FC4B8 = 0u;
    xmmword_2540FC4C8 = 0u;
    qword_2540FC4D8 = 0;
    __cxa_guard_release(&_MergedGlobals_50);
  }
  return &qword_2540FC468;
}

void re::initInfo_PeerAssetLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  __int128 v14;
  _QWORD v15[2];
  __int128 v16;

  v15[0] = 0xEB1ACE70333D9ADALL;
  v15[1] = "PeerAssetLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v15);
  *((_OWORD *)this + 2) = v16;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FC450);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FC450);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_uint64_t((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "fromPeerId";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FC458 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::IntrospectionInfo<re::DynamicString>::get(1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "assetPathOnPeer";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x800000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540FC460 = v13;
      __cxa_guard_release(&qword_2540FC450);
    }
  }
  *((_QWORD *)this + 2) = 0x2800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_2540FC458;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::PeerAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::PeerAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::PeerAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::PeerAssetLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  v14 = v16;
}

_QWORD *re::internal::defaultConstruct<re::PeerAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;

  *(_OWORD *)(a3 + 8) = 0u;
  v3 = (_QWORD *)(a3 + 8);
  *(_OWORD *)(a3 + 24) = 0u;
  return re::DynamicString::setCapacity(v3, 0);
}

double re::internal::defaultDestruct<re::PeerAssetLoadDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _OWORD *v4;
  double result;

  v4 = (_OWORD *)(a3 + 8);
  v3 = *(_QWORD *)(a3 + 8);
  if (v3)
  {
    if ((*(_BYTE *)(a3 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a3 + 24));
    result = 0.0;
    *v4 = 0u;
    v4[1] = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::PeerAssetLoadDescriptorParameters>(uint64_t a1)
{
  _QWORD *v1;

  *(_OWORD *)(a1 + 8) = 0u;
  v1 = (_QWORD *)(a1 + 8);
  *(_OWORD *)(a1 + 24) = 0u;
  return re::DynamicString::setCapacity(v1, 0);
}

double re::internal::defaultDestructV2<re::PeerAssetLoadDescriptorParameters>(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;

  v3 = (_OWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 24));
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  return result;
}

uint64_t re::introspect_PeerAssetLoadDescriptorParameters(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"PeerAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_PeerAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_PeerAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::PeerAssetLoadDescriptorParameters>, this);
}

re::PeerAssetProvider *re::PeerAssetProvider::PeerAssetProvider(re::PeerAssetProvider *this)
{
  unsigned __int8 v2;
  __guard *v3;
  int v5;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED2E138;
  if ((v2 & 1) == 0)
  {
    if (v5)
    {
      re::introspect<re::PeerAssetLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"PeerAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_PeerAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_PeerAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::PeerAssetLoadDescriptorParameters>, 0);
    }
  }
  re::PeerAssetProvider::s_loadDescriptorParametersIntrospect = v3[52];
  return this;
}

uint64_t re::PeerAssetProvider::makeDescriptor@<X0>(re::PeerAssetProvider *this@<X0>, const re::DynamicString *a2@<X2>, re::DynamicString *a3@<X1>, uint64_t a4@<X8>)
{
  _anonymous_namespace_ *v9;
  size_t v10;
  _anonymous_namespace_ *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  const re::IntrospectionBase *v16;
  _QWORD v17[4];
  re::PeerAssetProvider *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  v18 = (re::PeerAssetProvider *)"PeerAsset";
  v19 = 9;
  re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v18);
  v10 = strlen((const char *)a2);
  v18 = a2;
  v19 = v10;
  v11 = re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v18);
  v20 = 0;
  v21 = 0;
  v22 = 0;
  re::DynamicString::setCapacity(&v19, 0);
  re::DynamicString::operator=((re::DynamicString *)&v19, a3);
  v18 = this;
  v16 = this;
  re::DynamicString::DynamicString((re::DynamicString *)v17, (const re::DynamicString *)&v19);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)re::PeerAssetProvider::s_loadDescriptorParametersIntrospect, &v16, 0);
  if (v17[0])
  {
    if ((v17[1] & 1) != 0)
      (*(void (**)(_QWORD))(*(_QWORD *)v17[0] + 40))(v17[0]);
    memset(v17, 0, sizeof(v17));
  }
  result = v19;
  if (v19)
  {
    if ((v20 & 1) != 0)
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v19 + 40))(v19, v21, v12, v13, v14);
  }
  return result;
}

__n128 re::PeerAssetProvider::load@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

uint64_t re::PeerAssetProvider::resolveChild@<X0>(const re::AssetLoadDescriptor *a1@<X1>, re::AssetProvider *a2@<X2>, const re::DynamicString *a3@<X3>, uint64_t a4@<X8>)
{
  const char *v9;
  _anonymous_namespace_ *v10;
  uint64_t result;
  __int128 v12;
  __int128 v13;
  uint64_t Descriptor;
  re::PathBuffer *v15;
  uint64_t v16;
  __n128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  int v24;
  __int128 v25;
  __int128 v26;
  int v27;
  _BYTE v28[24];
  __int128 v29;
  _BYTE v30[40];
  __int128 v31;
  int v32;
  __int128 v33;
  __int128 v34;
  int v35;
  _BYTE v36[24];
  __int128 v37;
  uint64_t v38;
  char v39;
  re::PeerAssetProvider *v40;
  uint64_t *v41;
  uint64_t v42;
  re::PathBuffer *v43;
  uint64_t v44;

  if ((*((_BYTE *)a1 + 8) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a1 + 2);
  else
    v9 = (char *)a1 + 9;
  v10 = (_anonymous_namespace_ *)strcmp(v9, "PeerAsset");
  if ((_DWORD)v10)
  {
    result = re::DynamicString::format((re::DynamicString *)"Scheme %s does not match scheme %s.", (re::DynamicString *)v30, v9, "PeerAsset");
    v12 = *(_OWORD *)v30;
    v13 = *(_OWORD *)&v30[16];
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v12;
    *(_OWORD *)(a4 + 24) = v13;
  }
  else
  {
    v42 = 0;
    v43 = 0;
    v44 = 0;
    re::DynamicString::setCapacity(&v41, 0);
    Descriptor = re::AssetLoadDescriptor::getIntrospectableData<re::PeerAssetLoadDescriptorParameters>(a1, (uint64_t **)&v40, 0);
    if ((Descriptor & 1) != 0)
    {
      if ((v42 & 1) != 0)
        v15 = v43;
      else
        v15 = (re::PathBuffer *)((char *)&v42 + 1);
      re::AssetProvider::resolveChildPath(a2, v15, &v38);
      re::PeerAssetProvider::makeDescriptor(v40, a3, (re::DynamicString *)&v38, (uint64_t)&v20);
      v16 = v20;
      v20 = 0;
      *(_QWORD *)v30 = v16;
      *(_OWORD *)&v30[24] = v22;
      v22 = 0u;
      *(_OWORD *)&v30[8] = v21;
      v21 = 0u;
      v31 = v23;
      v23 = 0u;
      ++v24;
      v32 = 1;
      v33 = v25;
      v34 = v26;
      v25 = 0u;
      v26 = 0u;
      ++v27;
      v35 = 1;
      *(_OWORD *)v36 = *(_OWORD *)v28;
      memset(v28, 0, sizeof(v28));
      v37 = v29;
      *(_QWORD *)&v36[16] = *(_QWORD *)&v28[16];
      v29 = 0uLL;
      v17.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a4, (uint64_t)v30);
      if (*(_QWORD *)&v36[8])
      {
        if ((v36[16] & 1) != 0)
          (*(void (**)(double))(**(_QWORD **)&v36[8] + 40))(v17.n128_f64[0]);
        v17 = 0uLL;
        *(_OWORD *)&v36[8] = 0u;
        v37 = 0u;
      }
      if (*((_QWORD *)&v33 + 1))
      {
        if (*(_QWORD *)v36)
          (*(void (**)(__n128))(**((_QWORD **)&v33 + 1) + 40))(v17);
        *(_QWORD *)v36 = 0;
        v34 = 0uLL;
        *((_QWORD *)&v33 + 1) = 0;
        ++v35;
      }
      if (*(_QWORD *)&v30[32])
      {
        if ((_QWORD)v33)
          (*(void (**)(__n128))(**(_QWORD **)&v30[32] + 40))(v17);
        *(_QWORD *)&v33 = 0;
        v31 = 0uLL;
        *(_QWORD *)&v30[32] = 0;
        ++v32;
      }
      if (*(_QWORD *)v30)
      {
        if ((v30[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v30 + 40))(v17);
        v17 = 0uLL;
        memset(v30, 0, 32);
      }
      if (*(_QWORD *)&v28[8])
      {
        if ((v28[16] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)&v28[8] + 40))(v17);
        v17 = 0uLL;
        *(_OWORD *)&v28[8] = 0u;
        v29 = 0u;
      }
      if (*((_QWORD *)&v25 + 1))
      {
        if (*(_QWORD *)v28)
          (*(void (**)(__n128))(**((_QWORD **)&v25 + 1) + 40))(v17);
        *(_QWORD *)v28 = 0;
        v26 = 0uLL;
        *((_QWORD *)&v25 + 1) = 0;
        ++v27;
      }
      if (*((_QWORD *)&v22 + 1))
      {
        if ((_QWORD)v25)
          (*(void (**)(__n128))(**((_QWORD **)&v22 + 1) + 40))(v17);
        *(_QWORD *)&v25 = 0;
        v23 = 0uLL;
        *((_QWORD *)&v22 + 1) = 0;
        ++v24;
      }
      if (v20 && (v21 & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v20 + 40))(v17);
      if (v38 && (v39 & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v38 + 40))(v17);
    }
    else
    {
      v17 = *(__n128 *)v30;
      v18 = *(_QWORD *)&v30[16];
      v19 = *(_QWORD *)&v30[24];
      *(_BYTE *)a4 = 0;
      *(__n128 *)(a4 + 8) = v17;
      *(_QWORD *)(a4 + 24) = v18;
      *(_QWORD *)(a4 + 32) = v19;
    }
    result = (uint64_t)v41;
    if (v41)
    {
      if ((v42 & 1) != 0)
        return (*(uint64_t (**)(__n128))(*v41 + 40))(v17);
    }
  }
  return result;
}

uint64_t *re::PeerAssetProvider::getDescription(re::PeerAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  char *v5;
  uint64_t *result;
  const char *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;

  v11 = 0;
  v12 = 0;
  v13 = 0;
  re::DynamicString::setCapacity(&v10, 0);
  if (re::AssetLoadDescriptor::getIntrospectableData<re::PeerAssetLoadDescriptorParameters>(a2, &v9, 0))
  {
    if ((v11 & 1) != 0)
      v5 = v12;
    else
      v5 = (char *)&v11 + 1;
    re::DynamicString::format((re::DynamicString *)"peer:%llu / %s", (re::DynamicString *)&v7, v9, v5);
    re::DynamicString::operator=(a3, (re::DynamicString *)&v7);
    if (v7 && (v8 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v7 + 40))();
  }
  else
  {
    v7 = "mangled";
    v8 = 7;
    re::DynamicString::operator=(a3, (uint64_t)&v7);
  }
  result = v10;
  if (v10)
  {
    if ((v11 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v10 + 40))();
  }
  return result;
}

uint64_t re::PeerAssetProvider::getAssetPathForRelease@<X0>(_anonymous_namespace_ *a1@<X0>, char *a2@<X1>, const re::internal::AssetTypeRegistry *a3@<X2>, os_unfair_lock_s *a4@<X3>, unsigned int a5@<W4>, uint64_t a6@<X8>)
{
  uint64_t v11;
  _anonymous_namespace_ *v12;
  char *v13;
  _anonymous_namespace_ *v14;
  double v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  _anonymous_namespace_ *v22;
  _anonymous_namespace_ *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  const char *v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t result;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  _BYTE v44[23];
  _BYTE v45[24];
  __int128 v46;
  __int128 v47;
  _BYTE v48[24];
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;

  v55 = 0;
  v56 = 0;
  v57 = 0;
  re::DynamicString::setCapacity(&v54, 0);
  v11 = re::AssetLoadDescriptor::getIntrospectableData<re::PeerAssetLoadDescriptorParameters>((re::AssetLoadDescriptor *)a2, &v53, 0);
  if ((v11 & 1) != 0)
  {
    *(_DWORD *)v48 = 0;
    *(_OWORD *)&v48[8] = 0u;
    v49 = 0u;
    v12 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v48[8], 0);
    v51 = 0u;
    v50 = 0u;
    re::DynamicString::setCapacity(&v50, 0);
    v52 = 0;
    if ((v55 & 1) != 0)
      v13 = v56;
    else
      v13 = (char *)&v55 + 1;
    v15 = re::AssetPath::parse((re::AssetPath *)v48, v13, 0, a3, a4, v45);
    if (!v45[0])
    {
      v14 = (_anonymous_namespace_ *)v46;
      if ((_QWORD)v46)
      {
        if ((BYTE8(v46) & 1) != 0)
          v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(double))(*(_QWORD *)v46 + 40))(v15);
        v46 = 0u;
        v47 = 0u;
      }
    }
    if (a5 > 9 || *(_DWORD *)v48 == 3)
    {
      v22 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)&v42, v53);
      LODWORD(v35) = 0;
      v37 = 0;
      v38 = 0;
      v36 = 0;
      v23 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)&v35 + 1, 0);
      *((_QWORD *)&v39 + 1) = 0;
      v40 = 0uLL;
      re::DynamicString::setCapacity(&v39, 0);
      v41 = 0;
      if ((*((_QWORD *)a2 + 15) & 1) != 0)
        v24 = (char *)*((_QWORD *)a2 + 16);
      else
        v24 = a2 + 121;
      v25 = re::internal::AssetTypeRegistry::assetTypeWithName(a3, v24);
      if ((v43 & 1) != 0)
        v26 = *(char **)&v44[7];
      else
        v26 = v44;
      if ((BYTE8(v50) & 1) != 0)
        v27 = (const char *)v51;
      else
        v27 = (char *)&v50 + 9;
      re::AssetPath::initPeerAssetPath((uint64_t)&v35, v26, v27, v25);
      v33 = 0;
      v34 = 0;
      v32 = *((unint64_t *)&v35 + 1);
      re::DynamicString::setCapacity(&v32, 0);
      re::AssetPath::fullAssetPath((re::DynamicString *)&v35, (re::DynamicString *)&v32);
      v28 = v32;
      v29 = v33;
      v30 = v34;
      *(_BYTE *)a6 = 1;
      *(_OWORD *)(a6 + 8) = v28;
      *(_QWORD *)(a6 + 24) = v29;
      *(_QWORD *)(a6 + 32) = v30;
      if ((_QWORD)v39)
      {
        if ((BYTE8(v39) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v39 + 40))();
        v39 = 0u;
        v40 = 0u;
      }
      if (*((_QWORD *)&v35 + 1) && (v36 & 1) != 0)
        (*(void (**)(void))(**((_QWORD **)&v35 + 1) + 40))();
      if (v42 && (v43 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v42 + 40))();
    }
    else
    {
      v16 = v35;
      v17 = v36;
      v18 = v37;
      *(_BYTE *)a6 = 0;
      *(_OWORD *)(a6 + 8) = v16;
      *(_QWORD *)(a6 + 24) = v17;
      *(_QWORD *)(a6 + 32) = v18;
    }
    if ((_QWORD)v50)
    {
      if ((BYTE8(v50) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v50 + 40))();
      v50 = 0u;
      v51 = 0u;
    }
    if (*(_QWORD *)&v48[8] && (v48[16] & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v48[8] + 40))();
  }
  else
  {
    *(_QWORD *)&v48[8] = 0;
    *(_QWORD *)&v48[16] = 0;
    *(_QWORD *)&v49 = 0;
    re::DynamicString::setCapacity(v48, 0);
    v19 = *(_OWORD *)v48;
    v20 = *(_QWORD *)&v48[16];
    v21 = v49;
    *(_BYTE *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v19;
    *(_QWORD *)(a6 + 24) = v20;
    *(_QWORD *)(a6 + 32) = v21;
  }
  result = (uint64_t)v54;
  if (v54)
  {
    if ((v55 & 1) != 0)
      return (*(uint64_t (**)(void))(*v54 + 40))();
  }
  return result;
}

uint64_t *re::PeerAssetProvider::makeDescriptorFromAssetPath@<X0>(re::PeerAssetProvider *this@<X0>, const re::AssetPath *a2@<X1>, uint64_t a3@<X8>)
{
  const char *v5;
  const re::DynamicString *v6;
  _anonymous_namespace_ *v7;
  re::PeerAssetProvider *v8;
  _anonymous_namespace_ *v9;
  __n128 v10;
  uint64_t *result;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  __int128 v21;
  int v22;
  _BYTE v23[40];
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  __int128 v32;
  __int128 v33;
  int v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  if ((*((_QWORD *)a2 + 2) & 1) != 0)
    v5 = (const char *)*((_QWORD *)a2 + 3);
  else
    v5 = (char *)a2 + 17;
  v6 = (const re::DynamicString *)**((_QWORD **)a2 + 9);
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v7 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v24, 0);
  v28 = 0;
  v29 = 0;
  v31 = 0;
  v30 = 0;
  v32 = 0u;
  v33 = 0u;
  v34 = 0;
  v35 = 0u;
  v36 = 0u;
  v37 = 0;
  re::DynamicString::setCapacity((_QWORD *)&v35 + 1, 0);
  v8 = (re::PeerAssetProvider *)strtoull_l(v5, 0, 10, 0);
  if (v8)
  {
    re::PeerAssetProvider::makeDescriptor(v8, v6, (const re::AssetPath *)((char *)a2 + 40), (uint64_t)&v12);
  }
  else
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v12, 0);
    v16 = 0;
    v17 = 0;
    v19 = 0;
    v18 = 0;
    v20 = 0u;
    v21 = 0u;
    v22 = 0;
    memset(v23, 0, sizeof(v23));
    re::DynamicString::setCapacity(&v23[8], 0);
  }
  if (*((_QWORD *)&v35 + 1) && (v36 & 1) != 0)
    (*(void (**)(void))(**((_QWORD **)&v35 + 1) + 40))();
  if (*((_QWORD *)&v32 + 1) && (_QWORD)v35)
    (*(void (**)(void))(**((_QWORD **)&v32 + 1) + 40))();
  if (v28 && (_QWORD)v32)
    (*(void (**)(void))(*(_QWORD *)v28 + 40))();
  if (v24 && (v25 & 1) != 0)
    (*(void (**)(void))(*v24 + 40))();
  v10.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a3, (uint64_t)&v12);
  if (*(_QWORD *)&v23[8])
  {
    if ((v23[16] & 1) != 0)
      (*(void (**)(double))(**(_QWORD **)&v23[8] + 40))(v10.n128_f64[0]);
    v10 = 0uLL;
    memset(&v23[8], 0, 32);
  }
  if (*((_QWORD *)&v20 + 1))
  {
    if (*(_QWORD *)v23)
      (*(void (**)(__n128))(**((_QWORD **)&v20 + 1) + 40))(v10);
    *(_QWORD *)v23 = 0;
    v21 = 0uLL;
    *((_QWORD *)&v20 + 1) = 0;
    ++v22;
  }
  if (v16)
  {
    if ((_QWORD)v20)
      (*(void (**)(__n128))(*(_QWORD *)v16 + 40))(v10);
    *(_QWORD *)&v20 = 0;
    v17 = 0;
    v18 = 0;
    v16 = 0;
    ++v19;
  }
  result = v12;
  if (v12)
  {
    if ((v13 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(__n128))(*v12 + 40))(v10);
  }
  return result;
}

void re::PeerAssetProvider::~PeerAssetProvider(re::PeerAssetProvider *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

const char *re::PeerAssetProvider::schemeName(re::PeerAssetProvider *this)
{
  return "PeerAsset";
}

void re::AssetErrorCategoryImpl::~AssetErrorCategoryImpl(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x2276933B8);
}

const char *re::AssetErrorCategoryImpl::name(re::AssetErrorCategoryImpl *this)
{
  return "REAssets error";
}

_QWORD *re::AssetErrorCategoryImpl::message@<X0>(int a1@<W1>, _QWORD *a2@<X8>)
{
  const char *v4;
  char *v5;

  v4 = "Unknown REAssets error";
  if (a1 == 200)
    v4 = "Invalid asset path";
  if (a1 == 100)
    v5 = "Unexpected error";
  else
    v5 = (char *)v4;
  return std::string::basic_string[abi:nn180100]<0>(a2, v5);
}

void re::RawAssetProvider::load(re::RawAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  re::internal::AssetTypeRegistry *v10;
  char *v11;
  unint64_t v12;
  void *v13;
  re::AssetLoader *v14;
  re::internal::AssetEntry *v15;
  os_unfair_lock_s *v16;
  re::internal::AssetReference *v17;
  uint64_t v18;
  void *v19;
  id v20;
  _anonymous_namespace_ *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  char *v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  id v36;
  id v37;
  _anonymous_namespace_ *v38;
  char *v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  char v43[8];
  uint64_t v44;
  uint64_t v45;
  __int128 v46;
  char *v47;
  uint64_t v48[3];
  re::internal::AssetEntry *v49;
  id v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;
  __int128 v54;
  char v55;
  re::internal::AssetReference *v56;

  v10 = (re::internal::AssetTypeRegistry *)*((_QWORD *)this + 23);
  if ((*((_BYTE *)a2 + 120) & 1) != 0)
    v11 = (char *)*((_QWORD *)a2 + 16);
  else
    v11 = (char *)a2 + 121;
  v12 = re::internal::AssetTypeRegistry::assetTypeWithName(v10, v11);
  if (!v12)
  {
    if ((*((_BYTE *)a2 + 120) & 1) != 0)
      v22 = (char *)*((_QWORD *)a2 + 16);
    else
      v22 = (char *)a2 + 121;
    if ((*((_BYTE *)a2 + 8) & 1) != 0)
      v28 = (char *)*((_QWORD *)a2 + 2);
    else
      v28 = (char *)a2 + 9;
    re::DynamicString::format((re::DynamicString *)"Invalid AssetType: %s, specified for AssetDescriptor scheme: %s", (re::DynamicString *)&v51, v22, v28);
    goto LABEL_25;
  }
  v13 = (void *)v12;
  if (*((_QWORD *)this + 12))
  {
    v14 = (re::AssetLoader *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 23), v12);
    v15 = (re::internal::AssetEntry *)(*(uint64_t (**)(re::AssetLoader *))(*(_QWORD *)v14 + 120))(v14);
    re::internal::AssetEntry::makeAssetEntry(v15, v13, (const re::AssetType *)1, (uint64_t *)&v49);
    v16 = (os_unfair_lock_s *)v49;
    re::internal::AssetEntry::makeAssetReference(v49, &v56);
    v17 = v56;
    *(_QWORD *)&v51 = a2;
    v45 = a3;
    v48[0] = (uint64_t)v56;
    v18 = (*(uint64_t (**)(_QWORD, __int128 *, uint64_t *, uint64_t *))(**((_QWORD **)this + 12) + 16))(*((_QWORD *)this + 12), &v51, &v45, v48);
    if (v18)
    {
      v19 = (void *)v18;
      os_unfair_lock_lock(v16 + 96);
      re::internal::AssetEntry::LoadState::unloadAssetPointer_locked((uint64_t)&v16[176], v14);
      os_unfair_lock_unlock(v16 + 96);
      objc_msgSend(v19, "description");
      v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v21 = (_anonymous_namespace_ *)objc_msgSend(v20, "UTF8String");

      re::DynamicString::DynamicString((re::DynamicString *)&v45, (const re::DynamicString *)&v51);
      *(_BYTE *)a4 = 0;
      *(_QWORD *)(a4 + 8) = v45;
      *(_QWORD *)(a4 + 32) = v47;
      *(_OWORD *)(a4 + 16) = v46;
      if ((_QWORD)v51 && (BYTE8(v51) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v51 + 40))();

      if (!v17)
        goto LABEL_12;
    }
    else
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v51, (const re::AssetLoadDescriptor *)((char *)a2 + 112));
      os_unfair_lock_lock(v16 + 96);
      v32 = re::internal::AssetEntry::LoadState::clearAndReturnAssetPointer_locked((re::internal::AssetEntry::LoadState *)&v16[176]);
      os_unfair_lock_unlock(v16 + 96);
      *(_QWORD *)&v54 = v32;
      BYTE8(v54) = 0;
      v33 = v51;
      v34 = v52;
      v35 = v53;
      *(_BYTE *)(a4 + 56) = 0;
      *(_OWORD *)(a4 + 40) = v54;
      *(_BYTE *)a4 = 1;
      *(_OWORD *)(a4 + 8) = v33;
      *(_QWORD *)(a4 + 24) = v34;
      *(_QWORD *)(a4 + 32) = v35;
      if (!v17)
      {
LABEL_12:
        if (v16)

        return;
      }
    }

    goto LABEL_12;
  }
  v23 = *((_QWORD *)this + 7);
  if (!v23)
  {
LABEL_25:
    v29 = v51;
    v30 = v52;
    v31 = v53;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v29;
    *(_QWORD *)(a4 + 24) = v30;
    *(_QWORD *)(a4 + 32) = v31;
    return;
  }
  *(_QWORD *)&v51 = a2;
  v45 = a3;
  (*(void (**)(re::internal::AssetEntry **__return_ptr, uint64_t, __int128 *, uint64_t *))(*(_QWORD *)v23 + 16))(&v49, v23, &v51, &v45);
  if ((_BYTE)v49)
  {
    v56 = (re::internal::AssetReference *)v50;

    v24 = *((_QWORD *)this + 23);
    v48[1] = 0;
    v48[2] = 0;
    v48[0] = v24;
    v43[0] = 1;
    v44 = a3;
    re::AssetUtilities::loadCompiledAssetFromData((id *)&v56, v48, (const char **)v13, 0, 0, (uint64_t)v43, (uint64_t)&v45);
    if ((_BYTE)v45)
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v51, (const re::AssetLoadDescriptor *)((char *)a2 + 112));
      *(_QWORD *)&v54 = v46;
      BYTE8(v54) = 0;
      v55 = 0;
      v25 = v52;
      v26 = v53;
      v27 = v51;
      v52 = 0;
      v53 = 0;
      v51 = 0uLL;
      *(_BYTE *)(a4 + 56) = 0;
      *(_OWORD *)(a4 + 40) = v54;
      *(_BYTE *)a4 = 1;
      *(_QWORD *)(a4 + 24) = v25;
      *(_QWORD *)(a4 + 32) = v26;
      *(_OWORD *)(a4 + 8) = v27;
    }
    else
    {
      if ((BYTE8(v46) & 1) != 0)
        v39 = v47;
      else
        v39 = (char *)&v46 + 9;
      re::DynamicString::format((re::DynamicString *)"Error loading compiled asset '%llu': %s", (re::DynamicString *)&v51, a3, v39);
      v40 = v51;
      v41 = v52;
      v42 = v53;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v40;
      *(_QWORD *)(a4 + 24) = v41;
      *(_QWORD *)(a4 + 32) = v42;
    }
    if (!(_BYTE)v45 && (_QWORD)v46 && (BYTE8(v46) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v46 + 40))();

  }
  else
  {
    v36 = v50;
    objc_msgSend(v50, "description");
    v37 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v38 = (_anonymous_namespace_ *)objc_msgSend(v37, "UTF8String");

    re::DynamicString::DynamicString((re::DynamicString *)&v45, (const re::DynamicString *)&v51);
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = v45;
    *(_QWORD *)(a4 + 32) = v47;
    *(_OWORD *)(a4 + 16) = v46;
    if ((_QWORD)v51 && (BYTE8(v51) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v51 + 40))();

  }
}

re::DynamicString *re::RawAssetProvider::resolveChild@<X0>(re::RawAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, const char *a3@<X2>, const char *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  uint64_t v9;
  __n128 v10;
  re::DynamicString *result;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  id v16;
  _anonymous_namespace_ *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[24];
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  const re::AssetLoadDescriptor *v35;
  unint64_t v36;
  _QWORD v37[2];
  uint64_t v38;
  int v39;
  uint64_t v40;
  _QWORD v41[3];
  int v42;
  uint64_t v43;
  _QWORD v44[4];
  __int128 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48[5];
  uint64_t v49[5];
  uint64_t v50;
  const char *v51;

  v6 = *((_QWORD *)this + 17);
  if (!v6)
  {
    v12 = v45;
    v13 = v46;
    v14 = v47;
    *(_BYTE *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v12;
    *(_QWORD *)(a5 + 24) = v13;
    *(_QWORD *)(a5 + 32) = v14;
    return result;
  }
  v35 = a2;
  *(_QWORD *)v21 = a3;
  v51 = a4;
  (*(void (**)(__int128 *__return_ptr, uint64_t, const re::AssetLoadDescriptor **, _BYTE *, const char **))(*(_QWORD *)v6 + 16))(&v45, v6, &v35, v21, &v51);
  if (!(_BYTE)v45)
  {
    v15 = (void *)*((_QWORD *)&v45 + 1);
    objc_msgSend(*((id *)&v45 + 1), "description");
    v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v17 = (_anonymous_namespace_ *)objc_msgSend(v16, "UTF8String");

    re::DynamicString::DynamicString((re::DynamicString *)v21, (const re::DynamicString *)&v35);
    *(_BYTE *)a5 = 0;
    *(_QWORD *)(a5 + 8) = *(_QWORD *)v21;
    *(_QWORD *)(a5 + 32) = v22;
    *(_OWORD *)(a5 + 16) = *(_OWORD *)&v21[8];
    if (v35 && (v36 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v35 + 40))();

    return (re::DynamicString *)re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)&v45);
  }
  re::DynamicString::DynamicString((re::DynamicString *)&v35, (const re::DynamicString *)((char *)&v45 + 8));
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v37, v48);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v41, v49);
  v7 = re::DynamicString::DynamicString((re::DynamicString *)v44, (const re::DynamicString *)&v50);
  if ((v36 & 1) != 0)
    v8 = v36 >> 1;
  else
    v8 = v36 >> 1;
  if (v8)
  {
    if (v38)
    {
      if ((v44[1] & 1) != 0)
        v9 = v44[1] >> 1;
      else
        v9 = LOBYTE(v44[1]) >> 1;
      if (v9)
      {
        re::AssetLoadDescriptor::AssetLoadDescriptor((re::AssetLoadDescriptor *)v21, (const re::AssetLoadDescriptor *)&v35);
        v10.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a5, (uint64_t)v21);
        if ((_QWORD)v33)
        {
          if ((BYTE8(v33) & 1) != 0)
            (*(void (**)(double))(*(_QWORD *)v33 + 40))(v10.n128_f64[0]);
          v10 = 0uLL;
          v33 = 0u;
          v34 = 0u;
        }
        if (v28)
        {
          if (v32)
            (*(void (**)(__n128))(*(_QWORD *)v28 + 40))(v10);
          v32 = 0;
          v29 = 0;
          v30 = 0;
          v28 = 0;
          ++v31;
        }
        if (v23)
        {
          if (v27)
            (*(void (**)(__n128))(*(_QWORD *)v23 + 40))(v10);
          v27 = 0;
          v24 = 0;
          v25 = 0;
          v23 = 0;
          ++v26;
        }
        if (*(_QWORD *)v21 && (v21[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v21 + 40))(v10);
        goto LABEL_36;
      }
      v18 = "The child AssetDescriptor's assetType was not set via CoreRE API.";
    }
    else
    {
      v18 = "The child AssetDescriptor's data was not set via CoreRE API.";
    }
  }
  else
  {
    v18 = "The child AssetDescriptor's scheme name was not set via CoreRE API.";
  }
  v10 = *(__n128 *)v21;
  v19 = *(_QWORD *)&v21[16];
  v20 = v22;
  *(_BYTE *)a5 = 0;
  *(__n128 *)(a5 + 8) = v10;
  *(_QWORD *)(a5 + 24) = v19;
  *(_QWORD *)(a5 + 32) = v20;
LABEL_36:
  if (v44[0])
  {
    if ((v44[1] & 1) != 0)
      (*(void (**)(__n128))(*(_QWORD *)v44[0] + 40))(v10);
    v10 = 0uLL;
    memset(v44, 0, sizeof(v44));
  }
  if (v41[0])
  {
    if (v43)
      (*(void (**)(__n128))(*(_QWORD *)v41[0] + 40))(v10);
    v43 = 0;
    memset(v41, 0, sizeof(v41));
    ++v42;
  }
  if (v37[0])
  {
    if (v40)
      (*(void (**)(__n128))(*(_QWORD *)v37[0] + 40))(v10);
    v40 = 0;
    v37[1] = 0;
    v38 = 0;
    v37[0] = 0;
    ++v39;
  }
  if (v35)
  {
    if ((v36 & 1) != 0)
      (*(void (**)(__n128))(*(_QWORD *)v35 + 40))(v10);
  }
  return (re::DynamicString *)re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)&v45);
}

void re::RawAssetProvider::~RawAssetProvider(re::RawAssetProvider *this)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24ED2E278;
  v3 = (_OWORD *)((char *)this + 144);
  v2 = *((_QWORD *)this + 18);
  if (v2)
  {
    if ((*((_BYTE *)this + 152) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 20));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 104);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 64);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 24);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24ED2E278;
  v3 = (_OWORD *)((char *)this + 144);
  v2 = *((_QWORD *)this + 18);
  if (v2)
  {
    if ((*((_BYTE *)this + 152) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 20));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 104);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 64);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 24);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::RawAssetProvider::schemeName(re::RawAssetProvider *this)
{
  if ((*((_BYTE *)this + 152) & 1) != 0)
    return *((_QWORD *)this + 20);
  else
    return (uint64_t)this + 153;
}

re::DynamicString *re::RawAssetProvider::getDescription(re::RawAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  _QWORD v4[2];

  v4[0] = "custom";
  v4[1] = 6;
  return re::DynamicString::operator=(a3, (uint64_t)v4);
}

void re::introspect_AssetNetworkMessageType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  StringID v34;
  _QWORD v35[2];
  _QWORD v36[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540FC4E8);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540FC4E8);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 100;
      *((_QWORD *)v28 + 2) = "Request";
      qword_2540FC508 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *(_QWORD *)(v30 + 8) = 101;
      *(_QWORD *)(v30 + 16) = "Response";
      qword_2540FC510 = v30;
      __cxa_guard_release(&qword_2540FC4E8);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC4F0);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC4F0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540FC540, "AssetNetworkMessageType", 4, 4, 1, 1);
    qword_2540FC540 = (uint64_t)&off_24ED7D9E8;
    qword_2540FC580 = (uint64_t)&re::introspect_AssetNetworkMessageType(BOOL)::enumTable;
    dword_2540FC550 = 9;
    __cxa_guard_release(&qword_2540FC4F0);
  }
  if ((_MergedGlobals_51 & 1) == 0)
  {
    _MergedGlobals_51 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FC540, a2);
    v32 = 0x721F4BEB80401F86;
    v33 = "AssetNetworkMessageType";
    v36[0] = 208862;
    v36[1] = "int";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v36);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v36);
      v6 = (unsigned int *)qword_2540FC580;
      v35[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v36, &v32, 1, 1, (uint64_t)v35);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v34.var0 = 2 * v12;
            v34.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v36, v16, &v34);
            re::StringID::destroyString((re::StringID *)&v34);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v34.var0 = 2 * v20;
              v34.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v36, v24, &v34);
              re::StringID::destroyString((re::StringID *)&v34);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v36, v25);
      xmmword_2540FC560 = (__int128)v34;
      re::StringID::destroyString((re::StringID *)&v32);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v36);
      re::internal::assertLog((re::internal *)5, v31, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "AssetNetworkMessageType", v32, v33);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t *re::allocInfo_AssetSimpleMessage(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FC4F8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC4F8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC588, 0);
    *(uint64_t *)((char *)&qword_2540FC598 + 6) = 0;
    qword_2540FC598 = 0;
    qword_2540FC5A8 = 0;
    qword_2540FC5B0 = 0xFFFFFFFFLL;
    qword_2540FC588 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC5B8 = (uint64_t)"AssetSimpleMessage";
    dword_2540FC5C0 = 0;
    xmmword_2540FC5C8 = 0u;
    unk_2540FC5D8 = 0u;
    xmmword_2540FC5E8 = 0u;
    qword_2540FC5F8 = 0;
    __cxa_guard_release(&qword_2540FC4F8);
  }
  return &qword_2540FC588;
}

void re::initInfo_AssetSimpleMessage(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  uint64_t *v9;
  const re::IntrospectionBase *v10;
  void *v11;
  uint64_t v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  void *v19;
  uint64_t v20;
  uint64_t *v21;
  const re::IntrospectionBase *v22;
  void *v23;
  uint64_t v24;
  __int128 v25;
  _QWORD v26[2];
  __int128 v27;

  v26[0] = 0x1F5266FA5945820ALL;
  v26[1] = "AssetSimpleMessage";
  re::StringID::destroyString((re::StringID *)v26);
  *((_OWORD *)this + 2) = v27;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FC500);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FC500);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::introspect_AssetNetworkMessageType((re *)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "messageType";
      *(_QWORD *)(v8 + 16) = &qword_2540FC540;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_2540FC518 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v11 = re::IntrospectionInfo<re::DynamicString>::get(1, v10);
      v12 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 72, 8);
      *(_DWORD *)v12 = 1;
      *(_QWORD *)(v12 + 8) = "assetPath";
      *(_QWORD *)(v12 + 16) = v11;
      *(_QWORD *)(v12 + 24) = 0;
      *(_QWORD *)(v12 + 32) = 0x800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(_QWORD *)(v12 + 48) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_2540FC520 = v12;
      v13 = re::introspectionAllocator((re *)v12);
      v15 = re::introspect_uint32_t((re *)1, v14);
      v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
      *(_DWORD *)v16 = 1;
      *(_QWORD *)(v16 + 8) = "assetSize";
      *(_QWORD *)(v16 + 16) = v15;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)(v16 + 32) = 0x2800000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 48) = 0;
      *(_QWORD *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_2540FC528 = v16;
      v17 = re::introspectionAllocator((re *)v16);
      v19 = re::introspect_uint32_t((re *)1, v18);
      v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
      *(_DWORD *)v20 = 1;
      *(_QWORD *)(v20 + 8) = "currentFragment";
      *(_QWORD *)(v20 + 16) = v19;
      *(_QWORD *)(v20 + 24) = 0;
      *(_QWORD *)(v20 + 32) = 0x2C00000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(_QWORD *)(v20 + 48) = 0;
      *(_QWORD *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_2540FC530 = v20;
      v21 = re::introspectionAllocator((re *)v20);
      v23 = re::introspect_uint32_t((re *)1, v22);
      v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
      *(_DWORD *)v24 = 1;
      *(_QWORD *)(v24 + 8) = "numFragments";
      *(_QWORD *)(v24 + 16) = v23;
      *(_QWORD *)(v24 + 24) = 0;
      *(_QWORD *)(v24 + 32) = 0x3000000005;
      *(_DWORD *)(v24 + 40) = 0;
      *(_QWORD *)(v24 + 48) = 0;
      *(_QWORD *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_2540FC538 = v24;
      __cxa_guard_release(&qword_2540FC500);
    }
  }
  *((_QWORD *)this + 2) = 0x3800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 5;
  *((_QWORD *)this + 8) = &qword_2540FC518;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::AssetSimpleMessage>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::AssetSimpleMessage>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::AssetSimpleMessage>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::AssetSimpleMessage>;
  re::IntrospectionRegistry::add(this, v3);
  v25 = v27;
}

_QWORD *re::internal::defaultConstruct<re::AssetSimpleMessage>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;

  *(_OWORD *)(a3 + 8) = 0u;
  v3 = (_QWORD *)(a3 + 8);
  *(_OWORD *)(a3 + 24) = 0u;
  return re::DynamicString::setCapacity(v3, 0);
}

double re::internal::defaultDestruct<re::AssetSimpleMessage>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _OWORD *v4;
  double result;

  v4 = (_OWORD *)(a3 + 8);
  v3 = *(_QWORD *)(a3 + 8);
  if (v3)
  {
    if ((*(_BYTE *)(a3 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a3 + 24));
    result = 0.0;
    *v4 = 0u;
    v4[1] = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::AssetSimpleMessage>(uint64_t a1)
{
  _QWORD *v1;

  *(_OWORD *)(a1 + 8) = 0u;
  v1 = (_QWORD *)(a1 + 8);
  *(_OWORD *)(a1 + 24) = 0u;
  return re::DynamicString::setCapacity(v1, 0);
}

double re::internal::defaultDestructV2<re::AssetSimpleMessage>(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;

  v3 = (_OWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 24));
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  return result;
}

uint64_t re::introspect_AssetSimpleMessage(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AssetSimpleMessage", (uint64_t (*)(re::internal *))re::allocInfo_AssetSimpleMessage, (re::IntrospectionBase *(*)(void))re::initInfo_AssetSimpleMessage, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AssetSimpleMessage>, this);
}

uint64_t re::AssetSimpleMessage::maxBytesPerPacket(re::AssetSimpleMessage *this)
{
  unsigned __int8 v1;
  _QWORD *v2;
  int v4;
  const char *v5;
  uint64_t v6;
  _BYTE v7[4];
  unsigned int v8;

  v2 = &re::introspect_REStateCommandID(BOOL)::info;
  if ((v1 & 1) == 0)
  {
    v2 = (_QWORD *)&re::introspect_REStateCommandID(BOOL)::info;
    if (v4)
    {
      re::Defaults::uintValue((re::Defaults *)"networkAssetMaxBytesPerPacket", v5, (uint64_t)v7);
      v6 = v8;
      if (!v7[0])
        v6 = 0xFFFFLL;
      re::AssetSimpleMessage::maxBytesPerPacket(void)::value = v6;
      v2 = (_QWORD *)&re::introspect_REStateCommandID(BOOL)::info;
    }
  }
  return v2[73];
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SerializerV2(uint64_t a1, const StringID *a2)
{
  *(_QWORD *)a1 = &off_24ED2E770;
  re::StringID::StringID((re::StringID *)(a1 + 8), a2);
  re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::Encoder(a1 + 24, 12);
  *(_QWORD *)(a1 + 256) = 0x7FFFFFFF00000000;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(_QWORD *)a1 = &off_24ED2E708;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 332) = 0u;
  *(_QWORD *)(a1 + 348) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 360) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_DWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 420) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_QWORD *)(a1 + 436) = 0x7FFFFFFFLL;
  return a1;
}

void re::serializeAssetBinary(uint64_t a1@<X0>, uint64_t a2@<X1>, re **a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, uint64_t a7@<X8>)
{
  _BYTE *v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  __int128 v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  char v25;
  _BYTE v26[23];
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t (**v30)();
  char v31;
  _BYTE v32[15];
  uint64_t v33;
  char v34;
  __int128 v35;
  _QWORD v36[13];
  _DWORD *v37;
  int v38;
  uint64_t v39;
  uint64_t v40[6];
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  __int128 v56;
  _QWORD *v57;
  _QWORD v58[4];
  __int16 v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD v64[3];
  int v65;
  uint64_t v66;
  uint64_t v67;
  _BYTE v68[8];
  _BYTE v69[39];
  char v70;

  re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v70);
  if (v68[0])
  {
    v58[1] = 0;
    v58[2] = &off_24ED1E8F0;
    WORD4(v56) = 0;
    v58[3] = v58;
    v59 = 0;
    v61 = 0;
    v60 = 0;
    v62 = 0x2000;
    memset(v64, 0, sizeof(v64));
    v63 = 0;
    *(_QWORD *)&v56 = &off_24ED7C7D8;
    v57 = v64;
    v58[0] = &unk_24ED7C830;
    v65 = 0;
    v66 = 0;
    v67 = a1;
    v22 = 0x7F36B44A9D0F5EC6;
    *(_QWORD *)&v23 = "AssetBinarySerializer";
    re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::SerializerV1((uint64_t)&v30, (const StringID *)&v22);
    re::StringID::destroyString((re::StringID *)&v22);
    v30 = (uint64_t (**)())&off_24ED2E318;
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)&v39);
    re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFuncs(&v30);
    ((void (*)(uint64_t (***)()))v30[4])(&v30);
    v38 = v37[6];
    v36[12] = a4;
    re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::open(&v30, (uint64_t)&v56, a5, a6);
    if (!v34)
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v30[9])((uint64_t)&v30, (uint64_t)"asset", 1, a2, (re::TypeInfo *)v69, (uint64_t)v69, 0);
    ((void (*)(uint64_t))v30[7])((uint64_t)&v30);
    re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::close((uint64_t)&v33);
    if (v34)
    {
      LOBYTE(v22) = 1;
      v23 = v35;
      re::DynamicString::DynamicString((re::DynamicString *)&v24, (const re::DynamicString *)v36);
      if ((v25 & 1) != 0)
        v14 = *(_BYTE **)&v26[7];
      else
        v14 = v26;
      re::DynamicString::format((re::DynamicString *)"Asset serialization failed. Details: %s", (re::DynamicString *)&v27, v14);
      v15 = v27;
      v16 = v28;
      v17 = v29;
      *(_BYTE *)a7 = 0;
      *(_OWORD *)(a7 + 8) = v15;
      *(_QWORD *)(a7 + 24) = v16;
      *(_QWORD *)(a7 + 32) = v17;
      if ((_BYTE)v22 && v24 && (v25 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v24 + 40))();
    }
    else
    {
      *(_BYTE *)a7 = 1;
    }
    v30 = &off_24ED2B590;
    if (v51)
    {
      if (v55)
        (*(void (**)(void))(*(_QWORD *)v51 + 40))();
      v55 = 0;
      v52 = 0;
      v53 = 0;
      v51 = 0;
      ++v54;
    }
    if (v46)
    {
      if (v50)
        (*(void (**)(void))(*(_QWORD *)v46 + 40))();
      v50 = 0;
      v47 = 0;
      v48 = 0;
      v46 = 0;
      ++v49;
    }
    if (v41)
    {
      if (v45)
        (*(void (**)(void))(*(_QWORD *)v41 + 40))();
      v45 = 0;
      v42 = 0;
      v43 = 0;
      v41 = 0;
      ++v44;
    }
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v40);
    re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(&v30);
    re::StreamWriterCopyingOutputStream::~StreamWriterCopyingOutputStream((re::StreamWriterCopyingOutputStream *)&v56);
  }
  else
  {
    re::getPrettyTypeName((re *)a3, (const re::IntrospectionBase *)&v30);
    if ((v31 & 1) != 0)
      v18 = *(_BYTE **)&v32[7];
    else
      v18 = v32;
    re::DynamicString::format((re::DynamicString *)"Asset serialization failed. Type info \"%s\" not found.", (re::DynamicString *)&v56, v18);
    v19 = v56;
    v20 = v57;
    v21 = v58[0];
    *(_BYTE *)a7 = 0;
    *(_OWORD *)(a7 + 8) = v19;
    *(_QWORD *)(a7 + 24) = v20;
    *(_QWORD *)(a7 + 32) = v21;
    if (v30 && (v31 & 1) != 0)
      (*((void (**)(void))*v30 + 5))();
  }
  re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v70);
}

void re::deserializeAssetBinary(uint64_t a1@<X0>, uint64_t a2@<X1>, re **a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X5>, re::Allocator *a7@<X6>, uint64_t a8@<X8>)
{
  re::internal::TypeTranslationTable **TypeRegistry;
  re::internal::TypeTranslationTable **v16;
  _BYTE *v17;
  uint64_t v18;
  char *v19;
  __int128 v20;
  __int128 v21;
  _anonymous_namespace_ *v22;
  re::TypeRegistry *v23;
  uint64_t *v24;
  unsigned __int8 v25;
  _anonymous_namespace_ *v26;
  uint64_t v27;
  char *v28;
  uint64_t *v29;
  __int128 v30;
  re::Allocator *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  char v43[8];
  _BYTE v44[32];
  char v45[8];
  _BYTE v46[39];
  char v47;
  _OWORD v48[3];
  __int128 v49;
  re::Allocator *v50;
  uint64_t v51;
  _OWORD *v52;
  int v53;
  uint64_t *v54;
  re::Allocator *v55;
  char v56[8];
  __int128 v57;
  uint64_t v58;
  _QWORD v59[3];
  int v60;
  uint64_t v61;
  int v62;
  char v63;
  uint64_t v64;
  uint64_t v65;
  _DWORD *v66;
  int v67;
  _BYTE v68[32];
  int v69;
  uint64_t v70;
  __int16 v71;
  uint64_t v72[4];
  int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  __int128 v79;
  __int128 v80;
  int v81;
  __int128 v82;
  __int128 v83;
  int v84;
  uint64_t v85;
  re::internal::TypeTranslationTable **v86;
  _BYTE v87[24];
  _BYTE *v88;
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v47);
  if (!v45[0])
  {
    re::getPrettyTypeName((re *)a3, (const re::IntrospectionBase *)&v49);
    if ((BYTE8(v49) & 1) != 0)
      v19 = (char *)v50;
    else
      v19 = (char *)&v49 + 9;
    re::DynamicString::format((re::DynamicString *)"Asset serialization failed. Type info \"%s\" not found.", (re::DynamicString *)v48, v19);
    v20 = v48[0];
    v21 = v48[1];
    *(_BYTE *)a8 = 0;
    *(_OWORD *)(a8 + 8) = v20;
    *(_OWORD *)(a8 + 24) = v21;
    if ((_QWORD)v49 && (BYTE8(v49) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v49 + 40))();
    goto LABEL_66;
  }
  v86 = 0;
  v88 = 0;
  v43[0] = 1;
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)v46);
  if (!a4)
    goto LABEL_25;
  TypeRegistry = (re::internal::TypeTranslationTable **)re::createTypeRegistry(a4, a7, a7);
  v52 = (__int128 *)((char *)&v49 + 8);
  *((_QWORD *)&v49 + 1) = &off_24ED2E978;
  v50 = a7;
  *(_QWORD *)&v49 = 0;
  v16 = v86;
  v86 = TypeRegistry;
  if (!v16)
  {
LABEL_6:
    v17 = v88;
    v88 = 0;
    if (v17 == v87)
    {
      v18 = 4;
      v17 = v87;
    }
    else
    {
      if (!v17)
        goto LABEL_17;
      v18 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_17:
    if (v52)
    {
      if (v52 == (__int128 *)((char *)&v49 + 8))
      {
        v88 = v87;
        (*(void (**)(char *, _BYTE *))(*((_QWORD *)&v49 + 1) + 24))((char *)&v49 + 8, v87);
      }
      else
      {
        v88 = v52;
        v52 = 0;
      }
    }
    else
    {
      v88 = 0;
    }
    v22 = (_anonymous_namespace_ *)std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v49);
    v23 = (re::TypeRegistry *)v86;
    if (v86)
    {
      v24 = re::TypeInfo::name((re::TypeInfo *)v46);
      re::TypeRegistry::typeInfo(v23, (const re::StringID *)v24, &v49);
      re::Optional<re::TypeInfo>::operator=(v43, (unsigned __int8 *)&v49);
      if (v43[0])
      {
LABEL_25:
        *(_QWORD *)&v48[0] = 0x81C6E49267FF3CC8;
        *((_QWORD *)&v48[0] + 1) = "AssetBinaryDeserializer";
        *(_QWORD *)&v49 = &off_24ED2E6A0;
        re::StringID::StringID((re::StringID *)((char *)&v49 + 8), (const StringID *)v48);
        v61 = 0;
        memset(v59, 0, sizeof(v59));
        v60 = 0;
        v51 = 0;
        v52 = 0;
        v53 = 0;
        v54 = 0;
        v55 = 0;
        v56[0] = 0;
        v62 = 12;
        v63 = 0;
        v64 = 1024;
        v25 = atomic_load((unsigned __int8 *)&qword_2540FC608);
        if ((v25 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC608))
        {
          re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v36, (uint64_t)&v40);
          if ((_BYTE)v40)
            v37 = SDWORD1(v40);
          else
            v37 = 0;
          _MergedGlobals_52 = v37;
          __cxa_guard_release(&qword_2540FC608);
        }
        if (_MergedGlobals_52)
          v64 = _MergedGlobals_52;
        v69 = 0;
        memset(v68, 0, sizeof(v68));
        v65 = 0;
        v66 = 0;
        v67 = 0;
        v70 = 0x7FFFFFFFLL;
        *(_QWORD *)&v49 = &off_24ED2E638;
        v71 = 1;
        v74 = 0x7FFFFFFFLL;
        v80 = 0u;
        v79 = 0u;
        memset(v72, 0, sizeof(v72));
        v73 = 0;
        v77 = 0;
        v75 = 0;
        v76 = 0;
        v78 = 0;
        v85 = 0;
        v81 = 0;
        v84 = 0;
        v83 = 0u;
        v82 = 0u;
        re::StringID::destroyString((re::StringID *)v48);
        *(_QWORD *)&v49 = &off_24ED2E380;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)v68);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFuncs(&v49);
        v26 = (_anonymous_namespace_ *)(*(uint64_t (**)(__int128 *))(v49 + 32))(&v49);
        v67 = v66[6];
        v65 = a5;
        v51 = a1;
        v52 = 0;
        v53 = 0;
        if (!a6)
        {
        }
        v54 = a6;
        if (!a7)
        {
        }
        v55 = a7;
        LOBYTE(v48[0]) = 0;
        re::Optional<re::DetailedError>::operator=((uint64_t)v56, (unsigned __int8 *)v48);
        if (LOBYTE(v48[0]) && *((_QWORD *)&v48[1] + 1) && (v48[2] & 1) != 0)
          (*(void (**)(void))(**((_QWORD **)&v48[1] + 1) + 40))();
        v59[0] = v54;
        re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(v59, 0x40uLL);
        ++v60;
        LOBYTE(v48[0]) = 0;
        memset((char *)v48 + 4, 0, 44);
        re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::add((_anonymous_namespace_ *)v59, (uint64_t)v48);
        (*(void (**)(uint64_t))(v49 + 48))((uint64_t)&v49);
        if (!v56[0])
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(v49 + 72))((uint64_t)&v49, (uint64_t)"asset", 1, a2, (re::TypeInfo *)v46, (uint64_t)v44, 0);
        (*(void (**)(uint64_t))(v49 + 56))((uint64_t)&v49);
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::close((_anonymous_namespace_ *)&v51);
        if (v56[0])
        {
          v27 = re::TypeInfo::name((re::TypeInfo *)v46)[1];
          LOBYTE(v48[0]) = v56[0];
          if (v56[0])
          {
            *(_OWORD *)((char *)v48 + 8) = v57;
            re::DynamicString::DynamicString((re::DynamicString *)((char *)&v48[1] + 8), (const re::DynamicString *)&v58);
            if ((v48[2] & 1) != 0)
              v28 = (char *)*((_QWORD *)&v48[2] + 1);
            else
              v28 = (char *)&v48[2] + 1;
          }
          else
          {
            v28 = (char *)&v48[2] + 1;
          }
          re::DynamicString::format((re::DynamicString *)"Asset deserialization failed. Asset type \"%s\". Details: %s", (re::DynamicString *)&v40, v27, v28);
          v33 = v40;
          v34 = v41;
          v35 = v42;
          *(_BYTE *)a8 = 0;
          *(_OWORD *)(a8 + 8) = v33;
          *(_QWORD *)(a8 + 24) = v34;
          *(_QWORD *)(a8 + 32) = v35;
          if (LOBYTE(v48[0]) && *((_QWORD *)&v48[1] + 1) && (v48[2] & 1) != 0)
            (*(void (**)(void))(**((_QWORD **)&v48[1] + 1) + 40))();
        }
        else
        {
          *(_BYTE *)a8 = 1;
        }
        *(_QWORD *)&v49 = &off_24ED2E638;
        if (*((_QWORD *)&v82 + 1))
        {
          if (v85)
            (*(void (**)(void))(**((_QWORD **)&v82 + 1) + 40))();
          v85 = 0;
          v83 = 0uLL;
          *((_QWORD *)&v82 + 1) = 0;
          ++v84;
        }
        if (*((_QWORD *)&v79 + 1))
        {
          if ((_QWORD)v82)
            (*(void (**)(void))(**((_QWORD **)&v79 + 1) + 40))();
          *(_QWORD *)&v82 = 0;
          v80 = 0uLL;
          *((_QWORD *)&v79 + 1) = 0;
          ++v81;
        }
        if (v75)
        {
          if ((_QWORD)v79)
            (*(void (**)(void))(*(_QWORD *)v75 + 40))();
          *(_QWORD *)&v79 = 0;
          v76 = 0;
          v77 = 0;
          v75 = 0;
          ++v78;
        }
        re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v72);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::~Serializer((uint64_t)&v49);
        goto LABEL_65;
      }
      v29 = re::TypeInfo::name((re::TypeInfo *)v46);
      re::DynamicString::format((re::DynamicString *)"Asset deserialization failed. Type \"%s\" not found in persisted schema.", (re::DynamicString *)&v49, v29[1]);
    }
    else
    {
    }
    v30 = v49;
    v31 = v50;
    v32 = v51;
    *(_BYTE *)a8 = 0;
    *(_OWORD *)(a8 + 8) = v30;
    *(_QWORD *)(a8 + 24) = v31;
    *(_QWORD *)(a8 + 32) = v32;
LABEL_65:
    std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v86);
LABEL_66:
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v47);
    return;
  }
  *(_QWORD *)&v48[0] = v16;
  if (v88)
  {
    (*(void (**)(_BYTE *, _OWORD *))(*(_QWORD *)v88 + 48))(v88, v48);
    goto LABEL_6;
  }
  v38 = std::__throw_bad_function_call[abi:nn180100]();
  re::serializeAssetOPACK(v38);
}

void re::serializeAssetOPACK(uint64_t a1@<X0>, uint64_t a2@<X1>, re **a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, uint64_t a7@<X8>)
{
  _BYTE *v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  __int128 v19;
  _QWORD *v20;
  uint64_t v21;
  double v22;
  double v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  char v27;
  _BYTE v28[23];
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  _QWORD *v33;
  _QWORD v34[4];
  __int16 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD v40[3];
  int v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[8];
  _BYTE v45[39];
  char v46;
  uint64_t (**v47)();
  char v48;
  _BYTE v49[15];
  _BYTE v50[40];
  char v51;
  __int128 v52;
  _QWORD v53[15];
  _DWORD *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62[6];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68[7];

  v68[6] = *MEMORY[0x24BDAC8D0];
  re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v46);
  if (v44[0])
  {
    v34[1] = 0;
    v34[2] = &off_24ED1E8F0;
    WORD4(v32) = 0;
    v34[3] = v34;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0x2000;
    v39 = 0;
    memset(v40, 0, sizeof(v40));
    *(_QWORD *)&v32 = &off_24ED7C7D8;
    v33 = v40;
    v34[0] = &unk_24ED7C830;
    v41 = 0;
    v42 = 0;
    v43 = a1;
    v24 = 0x3D2ADDFABE78EB94;
    *(_QWORD *)&v25 = "AssetOPACKSerializer";
    re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SerializerV2((uint64_t)&v47, (const StringID *)&v24);
    re::StringID::destroyString((re::StringID *)&v24);
    v47 = (uint64_t (**)())&off_24ED2E3E8;
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)&v56);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFuncs(&v47);
    ((void (*)(uint64_t (***)()))v47[4])(&v47);
    v55 = v54[6];
    v53[14] = a4;
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::open(&v47, (uint64_t)&v32, a5, a6);
    if (!v51)
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v47[9])((uint64_t)&v47, (uint64_t)"asset", 1, a2, (re::TypeInfo *)v45, (uint64_t)v45, 0);
    ((void (*)(uint64_t))v47[7])((uint64_t)&v47);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::close(v50);
    if (v51)
    {
      LOBYTE(v24) = 1;
      v25 = v52;
      re::DynamicString::DynamicString((re::DynamicString *)&v26, (const re::DynamicString *)v53);
      if ((v27 & 1) != 0)
        v14 = *(_BYTE **)&v28[7];
      else
        v14 = v28;
      re::DynamicString::format((re::DynamicString *)"Asset serialization failed. Details: %s", (re::DynamicString *)&v29, v14);
      v15 = v29;
      v16 = v30;
      v17 = v31;
      *(_BYTE *)a7 = 0;
      *(_OWORD *)(a7 + 8) = v15;
      *(_QWORD *)(a7 + 24) = v16;
      *(_QWORD *)(a7 + 32) = v17;
      if ((_BYTE)v24 && v26 && (v27 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v26 + 40))();
    }
    else
    {
      *(_BYTE *)a7 = 1;
    }
    v47 = &off_24ED2B1A0;
    v22 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(v68);
    if (v63)
    {
      if (v67)
        (*(void (**)(double))(*(_QWORD *)v63 + 40))(v22);
      v67 = 0;
      v64 = 0;
      v65 = 0;
      v63 = 0;
      ++v66;
    }
    v23 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v62);
    if (v57)
    {
      if (v61)
        (*(void (**)(double))(*(_QWORD *)v57 + 40))(v23);
      v61 = 0;
      v58 = 0;
      v59 = 0;
      v57 = 0;
      ++v60;
    }
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer(&v47);
    re::StreamWriterCopyingOutputStream::~StreamWriterCopyingOutputStream((re::StreamWriterCopyingOutputStream *)&v32);
  }
  else
  {
    re::getPrettyTypeName((re *)a3, (const re::IntrospectionBase *)&v47);
    if ((v48 & 1) != 0)
      v18 = *(_BYTE **)&v49[7];
    else
      v18 = v49;
    re::DynamicString::format((re::DynamicString *)"Asset serialization failed. Type info \"%s\" not found.", (re::DynamicString *)&v32, v18);
    v19 = v32;
    v20 = v33;
    v21 = v34[0];
    *(_BYTE *)a7 = 0;
    *(_OWORD *)(a7 + 8) = v19;
    *(_QWORD *)(a7 + 24) = v20;
    *(_QWORD *)(a7 + 32) = v21;
    if (v47 && (v48 & 1) != 0)
      (*((void (**)(void))*v47 + 5))();
  }
  re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v46);
}

void re::deserializeAssetOPACK(uint64_t a1@<X0>, uint64_t a2@<X1>, re **a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  _BYTE *v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  double v30;
  double v31;
  _BYTE v32[24];
  uint64_t v33;
  char v34;
  _BYTE v35[23];
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  _BYTE v40[32];
  _BYTE v41[8];
  _BYTE v42[39];
  char v43;
  uint64_t (**v44)();
  char v45;
  _BYTE v46[15];
  _BYTE v47[40];
  char v48;
  __int128 v49;
  _QWORD v50[15];
  _DWORD *v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59[6];
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65[6];
  uint64_t v66[7];

  v66[5] = *MEMORY[0x24BDAC8D0];
  re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v43);
  if (v41[0])
  {
    v66[0] = 0;
    v66[4] = 0;
    v39 = 1;
    re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)v42);
    *(_QWORD *)v32 = 0x935762BFD538CE16;
    *(_QWORD *)&v32[8] = "AssetOPACKDeserializer";
    re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SerializerV2((uint64_t)&v44, (const StringID *)v32);
    re::StringID::destroyString((re::StringID *)v32);
    v44 = (uint64_t (**)())&off_24ED2E450;
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)&v53);
    re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFuncs(&v44);
    ((void (*)(uint64_t (***)()))v44[4])(&v44);
    v52 = v51[6];
    v50[14] = a4;
    re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::open(&v44, a1, a5, a6);
    if (!v48)
      ((void (*)(_DWORD *, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v44[9])(&v44, (uint64_t)"asset", 1, a2, (re::TypeInfo *)v42, (uint64_t)v40, 0);
    ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v44[7])((uint64_t)&v44, v14, v15, v16, v17, v18, v19, v20);
    re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::close(v47);
    if (v48)
    {
      v21 = re::TypeInfo::name((re::TypeInfo *)v42)[1];
      v32[0] = v48;
      if (v48)
      {
        *(_OWORD *)&v32[8] = v49;
        re::DynamicString::DynamicString((re::DynamicString *)&v33, (const re::DynamicString *)v50);
        if ((v34 & 1) != 0)
          v22 = *(_BYTE **)&v35[7];
        else
          v22 = v35;
      }
      else
      {
        v22 = v35;
      }
      re::DynamicString::format((re::DynamicString *)"Asset deserialization failed. Asset type \"%s\". Details: %s", (re::DynamicString *)&v36, v21, v22);
      v27 = v36;
      v28 = v37;
      v29 = v38;
      *(_BYTE *)a7 = 0;
      *(_OWORD *)(a7 + 8) = v27;
      *(_QWORD *)(a7 + 24) = v28;
      *(_QWORD *)(a7 + 32) = v29;
      if (v32[0] && v33 && (v34 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v33 + 40))();
    }
    else
    {
      *(_BYTE *)a7 = 1;
    }
    v44 = &off_24ED2E708;
    v30 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(v65);
    if (v60)
    {
      if (v64)
        (*(void (**)(double))(*(_QWORD *)v60 + 40))(v30);
      v64 = 0;
      v61 = 0;
      v62 = 0;
      v60 = 0;
      ++v63;
    }
    v31 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v59);
    if (v54)
    {
      if (v58)
        (*(void (**)(double))(*(_QWORD *)v54 + 40))(v31);
      v58 = 0;
      v55 = 0;
      v56 = 0;
      v54 = 0;
      ++v57;
    }
    re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::~Serializer(&v44);
    std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>>::~unique_ptr[abi:nn180100](v66);
  }
  else
  {
    re::getPrettyTypeName((re *)a3, (const re::IntrospectionBase *)&v44);
    if ((v45 & 1) != 0)
      v23 = *(_BYTE **)&v46[7];
    else
      v23 = v46;
    re::DynamicString::format((re::DynamicString *)"Asset serialization failed. Type info \"%s\" not found.", (re::DynamicString *)v32, v23);
    v24 = *(_OWORD *)v32;
    v25 = *(_QWORD *)&v32[16];
    v26 = v33;
    *(_BYTE *)a7 = 0;
    *(_OWORD *)(a7 + 8) = v24;
    *(_QWORD *)(a7 + 24) = v25;
    *(_QWORD *)(a7 + 32) = v26;
    if (v44 && (v45 & 1) != 0)
      (*((void (**)(void))*v44 + 5))();
  }
  re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v43);
}

void re::serializeAssetJSON(uint64_t a1@<X0>, uint64_t a2@<X1>, re **a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, uint64_t a7@<X8>)
{
  unsigned __int8 v14;
  _anonymous_namespace_ *v15;
  _anonymous_namespace_ *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *var1;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  __int128 v25;
  _QWORD *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t (**v33)();
  char v34;
  _BYTE v35[15];
  __int128 *v36;
  uint64_t v37;
  int v38;
  uint64_t *v39;
  uint64_t *v40;
  _BYTE v41[8];
  __int128 v42;
  uint64_t v43;
  _QWORD v44[3];
  int v45;
  uint64_t v46;
  int v47;
  char v48;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  _QWORD v52[5];
  __int16 v53;
  uint64_t v54;
  _DWORD *v55;
  int v56;
  _OWORD v57[2];
  int v58;
  uint64_t v59;
  __int16 v60;
  uint64_t v61[4];
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  __int128 v68;
  __int128 v69;
  int v70;
  __int128 v71;
  __int128 v72;
  int v73;
  uint64_t v74;
  __int128 v75;
  _QWORD *v76;
  _QWORD v77[4];
  __int16 v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  _QWORD v83[3];
  int v84;
  uint64_t v85;
  uint64_t v86;
  _BYTE v87[8];
  _BYTE v88[39];
  char v89;
  StringID v90[4];

  re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v89);
  if (v87[0])
  {
    v77[1] = 0;
    v77[2] = &off_24ED1E8F0;
    WORD4(v75) = 0;
    v77[3] = v77;
    v78 = 0;
    v80 = 0;
    v79 = 0;
    v81 = 0x2000;
    memset(v83, 0, sizeof(v83));
    v82 = 0;
    *(_QWORD *)&v75 = &off_24ED7C7D8;
    v76 = v83;
    v77[0] = &unk_24ED7C830;
    v84 = 0;
    v85 = 0;
    v86 = a1;
    *(_QWORD *)&v90[0].var0 = 0x8EBD744EB006D4;
    v90[0].var1 = "AssetJSONSerializer";
    v33 = &off_24ED2E840;
    re::StringID::StringID((re::StringID *)&v34, v90);
    v46 = 0;
    memset(v44, 0, sizeof(v44));
    v45 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    v40 = 0;
    v41[0] = 0;
    v47 = 12;
    v48 = 0;
    v49 = 1024;
    v14 = atomic_load((unsigned __int8 *)&qword_2540FC618);
    if ((v14 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC618))
    {
      re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v28, (uint64_t)&v30);
      if ((_BYTE)v30)
        v29 = SDWORD1(v30);
      else
        v29 = 0;
      qword_2540FC610 = v29;
      __cxa_guard_release(&qword_2540FC618);
    }
    if (qword_2540FC610)
      v49 = qword_2540FC610;
    v53 = 0;
    v50 = 0u;
    v51 = 0u;
    memset(v52, 0, 28);
    memset(v57, 0, sizeof(v57));
    v58 = 0;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    v59 = 0x7FFFFFFFLL;
    v52[4] = 0;
    v33 = &off_24ED2E7D8;
    v60 = 1;
    v63 = 0x7FFFFFFFLL;
    v69 = 0u;
    v68 = 0u;
    memset(v61, 0, sizeof(v61));
    v62 = 0;
    v64 = 0;
    v65 = 0;
    v67 = 0;
    v66 = 0;
    v74 = 0;
    v70 = 0;
    v73 = 0;
    v71 = 0u;
    v72 = 0u;
    re::StringID::destroyString((re::StringID *)v90);
    v33 = (uint64_t (**)())&off_24ED2E4B8;
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)v57);
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs(&v33);
    v15 = (_anonymous_namespace_ *)((uint64_t (*)(uint64_t (***)()))v33[4])(&v33);
    v56 = v55[6];
    v54 = a4;
    v36 = &v75;
    v37 = 0;
    v38 = 0;
    if (!a5)
    {
    }
    v39 = a5;
    if (!a6)
    {
    }
    v40 = a6;
    *(_BYTE *)&v90[0].var0 = 0;
    re::Optional<re::DetailedError>::operator=((uint64_t)v41, (unsigned __int8 *)v90);
    if (*(_BYTE *)&v90[0].var0 && v90[1].var1 && (*(_BYTE *)&v90[2].var0 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v90[1].var1 + 40))();
    v44[0] = v39;
    re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(v44, 0x40uLL);
    ++v45;
    *(_BYTE *)&v90[0].var0 = 0;
    memset(&v90[0].var0 + 1, 0, 44);
    re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::add((_anonymous_namespace_ *)v44, (uint64_t)v90);
    if (!re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance)
    {
    }
    v52[0] = v40;
    re::DynamicArray<char>::setCapacity(v52, 0);
    ++LODWORD(v52[3]);
    v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v39 + 32))(v39, 64, 8);
    *(_OWORD *)v17 = 0u;
    *(_OWORD *)(v17 + 16) = 0u;
    *(_OWORD *)(v17 + 32) = 0u;
    *(_QWORD *)(v17 + 48) = 512;
    *(_DWORD *)(v17 + 56) = 324;
    *(_BYTE *)(v17 + 60) = 0;
    *((_QWORD *)&v50 + 1) = v17;
    v18 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v39 + 32))(v39, 48, 8);
    *(_OWORD *)v18 = 0u;
    *(_OWORD *)(v18 + 16) = 0u;
    *(_QWORD *)(v18 + 32) = 0;
    *(_QWORD *)(v18 + 40) = 256;
    *(_QWORD *)&v50 = v18;
    v19 = *((_QWORD *)&v50 + 1);
    **((_QWORD **)&v50 + 1) = v18;
    *(_BYTE *)(v19 + 60) = 0;
    *(_QWORD *)(v19 + 32) = *(_QWORD *)(v19 + 24);
    ((void (*)(uint64_t))v33[6])((uint64_t)&v33);
    if (!v41[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v33[9])((uint64_t)&v33, (uint64_t)"asset", 1, a2, (re::TypeInfo *)v88, (uint64_t)v88, 0);
    ((void (*)(uint64_t))v33[7])((uint64_t)&v33);
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::close(&v36);
    if (v41[0])
    {
      *(_BYTE *)&v90[0].var0 = 1;
      *(_OWORD *)&v90[0].var1 = v42;
      re::DynamicString::DynamicString((re::DynamicString *)&v90[1].var1, (const re::DynamicString *)&v43);
      if ((*(_BYTE *)&v90[2].var0 & 1) != 0)
        var1 = v90[2].var1;
      else
        var1 = (char *)&v90[2].var0 + 1;
      re::DynamicString::format((re::DynamicString *)"Asset serialization failed. Details: %s", (re::DynamicString *)&v30, var1);
      v21 = v30;
      v22 = v31;
      v23 = v32;
      *(_BYTE *)a7 = 0;
      *(_OWORD *)(a7 + 8) = v21;
      *(_QWORD *)(a7 + 24) = v22;
      *(_QWORD *)(a7 + 32) = v23;
      if (*(_BYTE *)&v90[0].var0 && v90[1].var1 && (*(_BYTE *)&v90[2].var0 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v90[1].var1 + 40))();
    }
    else
    {
      *(_BYTE *)a7 = 1;
    }
    v33 = &off_24ED2E7D8;
    if (*((_QWORD *)&v71 + 1))
    {
      if (v74)
        (*(void (**)(void))(**((_QWORD **)&v71 + 1) + 40))();
      v74 = 0;
      v72 = 0uLL;
      *((_QWORD *)&v71 + 1) = 0;
      ++v73;
    }
    if (*((_QWORD *)&v68 + 1))
    {
      if ((_QWORD)v71)
        (*(void (**)(void))(**((_QWORD **)&v68 + 1) + 40))();
      *(_QWORD *)&v71 = 0;
      v69 = 0uLL;
      *((_QWORD *)&v68 + 1) = 0;
      ++v70;
    }
    if (v64)
    {
      if ((_QWORD)v68)
        (*(void (**)(void))(*(_QWORD *)v64 + 40))();
      *(_QWORD *)&v68 = 0;
      v65 = 0;
      v66 = 0;
      v64 = 0;
      ++v67;
    }
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v61);
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)&v33);
    re::StreamWriterCopyingOutputStream::~StreamWriterCopyingOutputStream((re::StreamWriterCopyingOutputStream *)&v75);
  }
  else
  {
    re::getPrettyTypeName((re *)a3, (const re::IntrospectionBase *)&v33);
    if ((v34 & 1) != 0)
      v24 = *(_BYTE **)&v35[7];
    else
      v24 = v35;
    re::DynamicString::format((re::DynamicString *)"Asset serialization failed. Type info \"%s\" not found.", (re::DynamicString *)&v75, v24);
    v25 = v75;
    v26 = v76;
    v27 = v77[0];
    *(_BYTE *)a7 = 0;
    *(_OWORD *)(a7 + 8) = v25;
    *(_QWORD *)(a7 + 24) = v26;
    *(_QWORD *)(a7 + 32) = v27;
    if (v33 && (v34 & 1) != 0)
      (*((void (**)(void))*v33 + 5))();
  }
  re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v89);
}

void re::AssetBinarySerializer::~AssetBinarySerializer(re::AssetBinarySerializer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2B590;
  v2 = *((_QWORD *)this + 49);
  if (v2)
  {
    if (*((_QWORD *)this + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 49) = 0;
    ++*((_DWORD *)this + 104);
  }
  v3 = *((_QWORD *)this + 44);
  if (v3)
  {
    if (*((_QWORD *)this + 48))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 44) = 0;
    ++*((_DWORD *)this + 94);
  }
  v4 = *((_QWORD *)this + 39);
  if (v4)
  {
    if (*((_QWORD *)this + 43))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 41) = 0;
    *((_QWORD *)this + 39) = 0;
    ++*((_DWORD *)this + 84);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2B590;
  v2 = *((_QWORD *)this + 49);
  if (v2)
  {
    if (*((_QWORD *)this + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 49) = 0;
    ++*((_DWORD *)this + 104);
  }
  v3 = *((_QWORD *)this + 44);
  if (v3)
  {
    if (*((_QWORD *)this + 48))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 44) = 0;
    ++*((_DWORD *)this + 94);
  }
  v4 = *((_QWORD *)this + 39);
  if (v4)
  {
    if (*((_QWORD *)this + 43))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 41) = 0;
    *((_QWORD *)this + 39) = 0;
    ++*((_DWORD *)this + 84);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(this);
  JUMPOUT(0x2276933B8);
}

void re::AssetBinaryDeserializer::~AssetBinaryDeserializer(re::AssetBinaryDeserializer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2E638;
  v2 = *((_QWORD *)this + 49);
  if (v2)
  {
    if (*((_QWORD *)this + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 49) = 0;
    ++*((_DWORD *)this + 104);
  }
  v3 = *((_QWORD *)this + 44);
  if (v3)
  {
    if (*((_QWORD *)this + 48))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 44) = 0;
    ++*((_DWORD *)this + 94);
  }
  v4 = *((_QWORD *)this + 39);
  if (v4)
  {
    if (*((_QWORD *)this + 43))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 41) = 0;
    *((_QWORD *)this + 39) = 0;
    ++*((_DWORD *)this + 84);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::~Serializer((uint64_t)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2E638;
  v2 = *((_QWORD *)this + 49);
  if (v2)
  {
    if (*((_QWORD *)this + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 49) = 0;
    ++*((_DWORD *)this + 104);
  }
  v3 = *((_QWORD *)this + 44);
  if (v3)
  {
    if (*((_QWORD *)this + 48))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 44) = 0;
    ++*((_DWORD *)this + 94);
  }
  v4 = *((_QWORD *)this + 39);
  if (v4)
  {
    if (*((_QWORD *)this + 43))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 41) = 0;
    *((_QWORD *)this + 39) = 0;
    ++*((_DWORD *)this + 84);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::~Serializer((uint64_t)this);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::trackObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v4;

  v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 256), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::untrackObject(uint64_t result)
{
  if (*(_BYTE *)(result + 256))
  {
    --*(_QWORD *)(result + 408);
    ++*(_DWORD *)(result + 416);
  }
  return result;
}

void re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 257) = 1;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(_QWORD *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(_QWORD *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::doClose(uint64_t a1)
{
  re::internal::SharedObjectGraph::markAndSweep((re::internal::SharedObjectGraph *)(a1 + 256), *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(_QWORD *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(_QWORD *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  __int128 v8;
  __int128 v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderBinary<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 192);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 192);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = 48 * v13;
        v7 = (__int128 *)(v14 + 16);
        do
        {
          v8 = *v7;
          v7 += 3;
          v9 = v8;
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, (uint64_t)&v9, (uint64_t)re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::SeekableInputStream>>);
          v6 -= 48;
        }
        while (v6);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t result;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;

  v14 = (_BYTE *)(a1 + 256);
  v15 = *(_QWORD *)(a1 + 408);
  if (!v15)
  {
    if ((_DWORD)a7)
      v16 = 0;
    else
      v16 = a4;
    v17 = **((_QWORD **)a5 + 2);
    *(_QWORD *)&v26 = *(_QWORD *)a5;
    *((_QWORD *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 256), v16, &v26);
  }
  v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v18)
  {
    result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(_QWORD *)(a1 + 408);
        ++*(_DWORD *)(a1 + 416);
      }
    }
  }
  else
  {
    v20 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v21, v22, v23, v24, v25, v20[1]);
    return 0;
  }
  return result;
}

BOOL (*re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  BOOL (*result)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int);
  uint64_t v9;

  v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    v6 = (char *)v4[1];
    if (v6 == "char*" || !strcmp(v6, "char*"))
      return (BOOL (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::serializeCString;
  }
  if (*((_BYTE *)this + 12) == 9)
  {
    v7 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 80);
    if (v7 >= 2)
    {
      if (v7 == 2)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      result = (BOOL (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))_os_crash();
      __break(1u);
    }
    else
    {
      return re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::serializePointer;
    }
  }
  else if (*(_QWORD *)this == *(_QWORD *)(a1 + 192)
         && (v9 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 208, **((_QWORD **)this + 2) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(BOOL (**)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))v9;
  }
  else
  {
    return (BOOL (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))re::serializeType<re::EncoderBinary<re::SeekableInputStream>>;
  }
  return result;
}

void re::AssetOPACKSerializer::~AssetOPACKSerializer(re::AssetOPACKSerializer *this)
{
  double v2;
  uint64_t v3;
  double v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24ED2B1A0;
  v2 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)this + 50);
  v3 = *((_QWORD *)this + 45);
  if (v3)
  {
    if (*((_QWORD *)this + 49))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *((_QWORD *)this + 49) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 47) = 0;
    *((_QWORD *)this + 45) = 0;
    ++*((_DWORD *)this + 96);
  }
  v4 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 39);
  v5 = *((_QWORD *)this + 34);
  if (v5)
  {
    if (*((_QWORD *)this + 38))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v5 + 40))(v5, v4);
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 36) = 0;
    *((_QWORD *)this + 34) = 0;
    ++*((_DWORD *)this + 74);
  }
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer(this);
}

{
  double v2;
  uint64_t v3;
  double v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24ED2B1A0;
  v2 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)this + 50);
  v3 = *((_QWORD *)this + 45);
  if (v3)
  {
    if (*((_QWORD *)this + 49))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *((_QWORD *)this + 49) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 47) = 0;
    *((_QWORD *)this + 45) = 0;
    ++*((_DWORD *)this + 96);
  }
  v4 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 39);
  v5 = *((_QWORD *)this + 34);
  if (v5)
  {
    if (*((_QWORD *)this + 38))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v5 + 40))(v5, v4);
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 36) = 0;
    *((_QWORD *)this + 34) = 0;
    ++*((_DWORD *)this + 74);
  }
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer(this);
  JUMPOUT(0x2276933B8);
}

void re::AssetOPACKDeserializer::~AssetOPACKDeserializer(re::AssetOPACKDeserializer *this)
{
  double v2;
  uint64_t v3;
  double v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24ED2E708;
  v2 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)this + 50);
  v3 = *((_QWORD *)this + 45);
  if (v3)
  {
    if (*((_QWORD *)this + 49))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *((_QWORD *)this + 49) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 47) = 0;
    *((_QWORD *)this + 45) = 0;
    ++*((_DWORD *)this + 96);
  }
  v4 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 39);
  v5 = *((_QWORD *)this + 34);
  if (v5)
  {
    if (*((_QWORD *)this + 38))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v5 + 40))(v5, v4);
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 36) = 0;
    *((_QWORD *)this + 34) = 0;
    ++*((_DWORD *)this + 74);
  }
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::~Serializer(this);
}

{
  double v2;
  uint64_t v3;
  double v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24ED2E708;
  v2 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)this + 50);
  v3 = *((_QWORD *)this + 45);
  if (v3)
  {
    if (*((_QWORD *)this + 49))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *((_QWORD *)this + 49) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 47) = 0;
    *((_QWORD *)this + 45) = 0;
    ++*((_DWORD *)this + 96);
  }
  v4 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 39);
  v5 = *((_QWORD *)this + 34);
  if (v5)
  {
    if (*((_QWORD *)this + 38))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v5 + 40))(v5, v4);
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 36) = 0;
    *((_QWORD *)this + 34) = 0;
    ++*((_DWORD *)this + 74);
  }
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::~Serializer(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::doOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  *(_QWORD *)(a1 + 288) = 0;
  ++*(_DWORD *)(a1 + 296);
  re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1 + 312);
  *(_QWORD *)(a1 + 376) = 0;
  ++*(_DWORD *)(a1 + 384);
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(a1 + 400);
  result = re::EncoderOPACK<re::SeekableInputStream>::beginObject(a1 + 24, "container", 0, 0);
  if ((result & 1) == 0 && !*(_BYTE *)(a1 + 64))
    return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, "container", "Failed to open container.", v11, v12, v13, v14, v15, a9);
  return result;
}

void re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::doClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;

  re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::deserializeSharedObjects(a1, a2, a3, a4, a5, a6, a7, a8, v9);
  re::EncoderOPACK<re::SeekableInputStream>::endObject(a1 + 24);
  *(_QWORD *)(a1 + 288) = 0;
  ++*(_DWORD *)(a1 + 296);
  re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1 + 312);
  *(_QWORD *)(a1 + 376) = 0;
  ++*(_DWORD *)(a1 + 384);
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(a1 + 400);
}

void re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t (*v16)(uint64_t, const char *, const re::TypeInfo *, uint64_t, re::TypeInfo *, re::TypeInfo *, int);

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderOPACK<re::SeekableInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 208);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 208);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = a1 + 224;
        v7 = (uint64_t *)(v14 + 24);
        v8 = 48 * v13;
        do
        {
          v9 = *v7;
          v7 += 6;
          v16 = re::serializeIntrospectionCallbackSerializer<re::EncoderOPACK<re::SeekableInputStream>>;
          v15 = v9 | 0xFFFFFFFF00000000;
          re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v6, &v15, &v16);
          v8 -= 48;
        }
        while (v8);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::doSerialize(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(_DWORD *, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _WORD v24[22];
  int v25;

  if (!a1[107] && a1[34] == 2)
  {
    v25 = 0;
    v22 = a4;
    re::TypeInfo::TypeInfo((uint64_t)&v23, (uint64_t)a5);
    re::TypeInfo::TypeInfo((uint64_t)v24, a6);
    v24[16] = 0;
    re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew((uint64_t)(a1 + 100), &v25, (uint64_t)&v22);
    a3 = 10;
  }
  v14 = (uint64_t (*)(_DWORD *, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(_DWORD *, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
  return 0;
}

BOOL (*re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, uint64_t a7)
{
  uint64_t v3;
  uint64_t v4;

  if (*(_BYTE *)(a2 + 12) == 9)
    return re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::serializePointer;
  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 208))
  {
    LODWORD(v4) = **(_QWORD **)(a2 + 16);
    HIDWORD(v4) = -1;
    v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 224, &v4);
    if (v3)
      return *(BOOL (**)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, uint64_t))v3;
  }
  return (BOOL (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, uint64_t))re::serializeType<re::EncoderOPACK<re::SeekableInputStream>>;
}

void re::AssetJSONSerializer::~AssetJSONSerializer(re::AssetJSONSerializer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2E7D8;
  v2 = *((_QWORD *)this + 59);
  if (v2)
  {
    if (*((_QWORD *)this + 63))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 63) = 0;
    *((_QWORD *)this + 60) = 0;
    *((_QWORD *)this + 61) = 0;
    *((_QWORD *)this + 59) = 0;
    ++*((_DWORD *)this + 124);
  }
  v3 = *((_QWORD *)this + 54);
  if (v3)
  {
    if (*((_QWORD *)this + 58))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 58) = 0;
    *((_QWORD *)this + 55) = 0;
    *((_QWORD *)this + 56) = 0;
    *((_QWORD *)this + 54) = 0;
    ++*((_DWORD *)this + 114);
  }
  v4 = *((_QWORD *)this + 49);
  if (v4)
  {
    if (*((_QWORD *)this + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 49) = 0;
    ++*((_DWORD *)this + 104);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2E7D8;
  v2 = *((_QWORD *)this + 59);
  if (v2)
  {
    if (*((_QWORD *)this + 63))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 63) = 0;
    *((_QWORD *)this + 60) = 0;
    *((_QWORD *)this + 61) = 0;
    *((_QWORD *)this + 59) = 0;
    ++*((_DWORD *)this + 124);
  }
  v3 = *((_QWORD *)this + 54);
  if (v3)
  {
    if (*((_QWORD *)this + 58))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 58) = 0;
    *((_QWORD *)this + 55) = 0;
    *((_QWORD *)this + 56) = 0;
    *((_QWORD *)this + 54) = 0;
    ++*((_DWORD *)this + 114);
  }
  v4 = *((_QWORD *)this + 49);
  if (v4)
  {
    if (*((_QWORD *)this + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 49) = 0;
    ++*((_DWORD *)this + 104);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)this);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::trackObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v4;

  v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::untrackObject(uint64_t result)
{
  if (*(_BYTE *)(result + 336))
  {
    --*(_QWORD *)(result + 488);
    ++*(_DWORD *)(result + 496);
  }
  return result;
}

void re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 337) = 0;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doClose(uint64_t a1)
{
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  __int128 v8;
  __int128 v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 272);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 272);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = 48 * v13;
        v7 = (__int128 *)(v14 + 16);
        do
        {
          v8 = *v7;
          v7 += 3;
          v9 = v8;
          re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, (uint64_t)&v9, (uint64_t)re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
          v6 -= 48;
        }
        while (v6);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t result;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;

  v14 = (_BYTE *)(a1 + 336);
  v15 = *(_QWORD *)(a1 + 488);
  if (!v15)
  {
    if ((_DWORD)a7)
      v16 = 0;
    else
      v16 = a4;
    v17 = **((_QWORD **)a5 + 2);
    *(_QWORD *)&v26 = *(_QWORD *)a5;
    *((_QWORD *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), v16, &v26);
  }
  v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v18)
  {
    result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
    }
  }
  else
  {
    v20 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v21, v22, v23, v24, v25, v20[1]);
    return 0;
  }
  return result;
}

uint64_t (*re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  uint64_t (*result)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, char);
  uint64_t v9;

  v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    v6 = (char *)v4[1];
    if (v6 == "char*" || !strcmp(v6, "char*"))
      return (uint64_t (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, char))re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString;
  }
  if (*((_BYTE *)this + 12) == 9)
  {
    v7 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 80);
    if (v7 >= 2)
    {
      if (v7 == 2)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      result = (uint64_t (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, char))_os_crash();
      __break(1u);
    }
    else
    {
      return re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer;
    }
  }
  else if (*(_QWORD *)this == *(_QWORD *)(a1 + 272)
         && (v9 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **((_QWORD **)this + 2) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, char))v9;
  }
  else
  {
    return (uint64_t (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, char))re::serializeType<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
  return result;
}

_QWORD *re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::trackObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v4;

  v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::untrackObject(uint64_t result)
{
  if (*(_BYTE *)(result + 336))
  {
    --*(_QWORD *)(result + 488);
    ++*(_DWORD *)(result + 496);
  }
  return result;
}

void re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 337) = 1;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doClose(uint64_t a1)
{
  re::internal::SharedObjectGraph::markAndSweep((re::internal::SharedObjectGraph *)(a1 + 336), *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int *(*v16)(uint64_t, char *, const re::TypeInfo *, uint64_t, re::TypeInfo *, re::TypeInfo *, int);

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 272);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 272);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = a1 + 288;
        v7 = (uint64_t *)(v14 + 24);
        v8 = 48 * v13;
        do
        {
          v9 = *v7;
          v7 += 6;
          v16 = re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
          v15 = v9 | 0xFFFFFFFF00000000;
          re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v6, &v15, &v16);
          v8 -= 48;
        }
        while (v8);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t result;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;

  v14 = (_BYTE *)(a1 + 336);
  v15 = *(_QWORD *)(a1 + 488);
  if (!v15)
  {
    if ((_DWORD)a7)
      v16 = 0;
    else
      v16 = a4;
    v17 = **((_QWORD **)a5 + 2);
    *(_QWORD *)&v26 = *(_QWORD *)a5;
    *((_QWORD *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), v16, &v26);
  }
  v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v18)
  {
    result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
    }
  }
  else
  {
    v20 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v21, v22, v23, v24, v25, v20[1]);
    return 0;
  }
  return result;
}

BOOL (*re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(uint64_t a1, char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  BOOL (*result)(uint64_t, char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int);
  uint64_t v9;
  uint64_t v10;

  v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    v6 = (char *)v4[1];
    if (v6 == "char*" || !strcmp(v6, "char*"))
      return (BOOL (*)(uint64_t, char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString;
  }
  if (*((_BYTE *)this + 12) == 9)
  {
    v7 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 80);
    if (v7 >= 2)
    {
      if (v7 == 2)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      result = (BOOL (*)(uint64_t, char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))_os_crash();
      __break(1u);
    }
    else
    {
      return re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer;
    }
  }
  else if (*(_QWORD *)this == *(_QWORD *)(a1 + 272)
         && (LODWORD(v10) = **((_QWORD **)this + 2),
             HIDWORD(v10) = -1,
             (v9 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, &v10)) != 0))
  {
    return *(BOOL (**)(uint64_t, char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))v9;
  }
  else
  {
    return (BOOL (*)(uint64_t, char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))re::serializeType<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
  return result;
}

uint64_t re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2E638;
  v2 = *(_QWORD *)(a1 + 392);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  v3 = *(_QWORD *)(a1 + 352);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 384))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 384) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 352) = 0;
    ++*(_DWORD *)(a1 + 376);
  }
  v4 = *(_QWORD *)(a1 + 312);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 344))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 344) = 0;
    *(_QWORD *)(a1 + 320) = 0;
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    ++*(_DWORD *)(a1 + 336);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 264));
  return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::~Serializer(a1);
}

void re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2E638;
  v2 = *(_QWORD *)(a1 + 392);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  v3 = *(_QWORD *)(a1 + 352);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 384))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 384) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 352) = 0;
    ++*(_DWORD *)(a1 + 376);
  }
  v4 = *(_QWORD *)(a1 + 312);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 344))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 344) = 0;
    *(_QWORD *)(a1 + 320) = 0;
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    ++*(_DWORD *)(a1 + 336);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 264));
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

void re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re::TypeInfo *this, const re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 192)
    && (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 208, **(_QWORD **)(a2 + 16) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, re::TypeInfo *, const re::TypeInfo *, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderBinary<re::SeekableInputStream>>;
  }
}

uint64_t re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::~Serializer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = &off_24ED2E6A0;
  if (*(_QWORD *)(a1 + 192))
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 208);
    *(_QWORD *)(a1 + 192) = 0;
  }
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 208));
  re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::close((_anonymous_namespace_ *)(a1 + 24));
  v2 = *(_QWORD *)(a1 + 120);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 152))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    ++*(_DWORD *)(a1 + 144);
  }
  if (*(_BYTE *)(a1 + 64))
  {
    v3 = *(_QWORD *)(a1 + 88);
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 104));
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
    }
  }
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 24 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16);
        v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

_anonymous_namespace_ *re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::close(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  char v9;

  if (*(_QWORD *)result)
  {
    v1 = result;
    if (!*((_BYTE *)result + 40))
    {
      v9 = 69;
      re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned char>((uint64_t)result, "End-of-file", 0, &v9, (uint64_t)"uint8", 0);
      if (v9 != 69)
      {
        re::DynamicString::format((re::DynamicString *)"Failed to read end-of-file marker.", (re::DynamicString *)&v2);
        *(_QWORD *)&v5 = 400;
        *((_QWORD *)&v5 + 1) = &re::FoundationErrorCategory(void)::instance;
        v6 = v2;
        v8 = v4;
        v7 = v3;
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, &v5);
        if (v6)
        {
          if ((v7 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v6 + 40))();
        }
      }
      if (!*((_BYTE *)v1 + 40))
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 0);
    }
    result = (_anonymous_namespace_ *)*((_QWORD *)v1 + 12);
    if (result)
    {
      if (*((_QWORD *)v1 + 16))
        result = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *))(*(_QWORD *)result + 40))(result);
      *((_QWORD *)v1 + 16) = 0;
      *((_QWORD *)v1 + 13) = 0;
      *((_QWORD *)v1 + 14) = 0;
      *((_QWORD *)v1 + 12) = 0;
      ++*((_DWORD *)v1 + 30);
    }
    if (*((int *)v1 + 4) >= 1)
    {
      result = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)v1 + 24))(*(_QWORD *)v1);
      *((_QWORD *)v1 + 1) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *(_QWORD *)v1 = 0;
    *((_QWORD *)v1 + 3) = 0;
    *((_QWORD *)v1 + 4) = 0;
  }
  return result;
}

_anonymous_namespace_ *re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(_anonymous_namespace_ *result, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  char v7;

  v3 = (uint64_t)result;
  v4 = *((_QWORD *)result + 14);
  if (!v4)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v3, (uint64_t)&v6);
    result = v6;
    if (v6 && (v7 & 1) != 0)
      result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v6 + 40))();
    v4 = *(_QWORD *)(v3 + 112);
  }
  v5 = v4 - 1;
  if (*(unsigned __int8 *)(*(_QWORD *)(v3 + 128) + 48 * v5) != a2)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v3, (uint64_t)&v6);
    result = v6;
    if (v6 && (v7 & 1) != 0)
      result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v6 + 40))();
    v5 = *(_QWORD *)(v3 + 112) - 1;
  }
  *(_QWORD *)(v3 + 112) = v5;
  ++*(_DWORD *)(v3 + 120);
  return result;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned char>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a4, 1uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(_anonymous_namespace_ *a1, const char *a2, uint64_t a3)
{
  _BYTE *v5;
  uint64_t result;
  uint64_t v7;
  char v8;
  _BYTE v9[23];
  _OWORD v10[2];

  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v7);
  if ((v8 & 1) != 0)
    v5 = *(_BYTE **)&v9[7];
  else
    v5 = v9;
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: Error %s type %s.", (re::DynamicString *)v10, "deserialize", v5, "reading", a3);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v10);
  if (*(_QWORD *)&v10[0])
  {
    if ((BYTE8(v10[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
    memset(v10, 0, sizeof(v10));
  }
  result = v7;
  if (v7)
  {
    if ((v8 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v7 + 40))();
  }
  return result;
}

uint64_t re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  _BYTE *v12;
  char *v13;
  uint64_t result;
  uint64_t v15;
  char v16;
  _BYTE v17[23];
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21[3];
  char *v22;
  uint64_t *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;

  v24 = 0;
  v25 = 0;
  v26 = 0;
  re::DynamicString::setCapacity(&v23, 0);
  v22 = &a9;
  re::DynamicString::vassignf((re::DynamicString *)&v23, a3, &a9);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)(a1 + 24), a2, (re::DynamicString *)&v15);
  if ((v16 & 1) != 0)
    v12 = *(_BYTE **)&v17[7];
  else
    v12 = v17;
  if ((v24 & 1) != 0)
    v13 = v25;
  else
    v13 = (char *)&v24 + 1;
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: %s", (re::DynamicString *)&v18, "deserialize", v12, v13);
  *(_QWORD *)&v21[0] = 400;
  *((_QWORD *)&v21[0] + 1) = &re::FoundationErrorCategory(void)::instance;
  *(_QWORD *)&v21[1] = v18;
  *((_QWORD *)&v21[2] + 1) = v20;
  *(__int128 *)((char *)&v21[1] + 8) = v19;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1 + 24, v21);
  if (*(_QWORD *)&v21[1])
  {
    if ((BYTE8(v21[1]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v21[1] + 40))();
    memset(&v21[1], 0, 32);
  }
  if (v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  result = (uint64_t)v23;
  if (v23)
  {
    if ((v24 & 1) != 0)
      return (*(uint64_t (**)(void))(*v23 + 40))();
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (a2 % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v2 == 0x7FFFFFFF)
    return 0;
  v4 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v4 + 24 * v2 + 4) != a2)
  {
    while (1)
    {
      LODWORD(v2) = *(_DWORD *)(v4 + 24 * v2) & 0x7FFFFFFF;
      if ((_DWORD)v2 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v4 + 24 * v2 + 4) == a2)
        return v4 + 24 * v2 + 16;
    }
    return 0;
  }
  return v4 + 24 * v2 + 16;
}

uint64_t re::serializeType<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re::TypeInfo *this, const re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t result;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  const char *v30;
  int v31;
  char v32;
  re::internal *v33;
  uint64_t v34;
  void (*v35)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t);
  _QWORD *v36;
  int v37;
  uint64_t v38;
  int v39;
  char v40;
  re::internal *v41;
  uint64_t v42;
  void (*v43)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t);
  _anonymous_namespace_ *v44;
  _BOOL4 v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  void **Instance;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v55;
  uint64_t v56;
  re::internal *v57;
  _anonymous_namespace_ *v58;
  double v59;
  void **v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v65;
  _QWORD *v66;
  int v67;
  uint64_t v68;
  void (*v69)(uint64_t, _QWORD, _QWORD, uint64_t, const re::TypeInfo **, char *, _QWORD);
  uint64_t v70;
  int v71;
  int v72;
  const re::TypeInfo *v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  re::internal *v80;
  re::internal *v81;
  uint64_t v82;
  void (*v83)(uint64_t, const char *, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t, double);
  uint64_t v84;
  void (*v85)(uint64_t, const char *, _QWORD, _QWORD, const re::TypeInfo **, const re::TypeInfo **, uint64_t);
  _anonymous_namespace_ *v86;
  unint64_t v87;
  double v88;
  uint64_t v89;
  void (*v90)(uint64_t, const char *, _QWORD, void **, unint64_t *, char *, _QWORD, double);
  uint64_t v91;
  void (*v92)(uint64_t, const char *, _QWORD, uint64_t, const re::TypeInfo **, _QWORD **, _QWORD);
  uint64_t v93;
  void (*v94)(uint64_t *, __int128 *, uint64_t);
  void **v95;
  uint64_t v96;
  double v97;
  re::Allocator *v98;
  uint64_t v99;
  unint64_t *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  void *v105;
  unint64_t *v106;
  void **v107;
  uint64_t v108;
  void (*v109)(uint64_t, _QWORD, _QWORD, uint64_t, const re::TypeInfo **, char *, _QWORD);
  uint64_t v110;
  _BOOL4 v111;
  unint64_t v112;
  uint64_t v113;
  const char *v114;
  uint64_t v115;
  uint64_t v116;
  BOOL v117;
  char v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  unint64_t v125;
  unint64_t v126;
  _anonymous_namespace_ *v127;
  uint64_t v128;
  void (*v129)(uint64_t *, __int128 *, uint64_t, unint64_t);
  uint64_t (*v130)(uint64_t *, _QWORD);
  char v131;
  uint64_t v132;
  char *v133;
  uint64_t (*v134)(uint64_t *, _QWORD);
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  unint64_t v138;
  uint64_t v139;
  BOOL v140;
  char v141;
  uint64_t v142;
  char v143;
  char *v144;
  unint64_t v145;
  uint64_t v146;
  char *v147;
  uint64_t v148;
  uint64_t *v149[4];
  __int128 v150;
  __int128 v151;
  __int128 v152;
  unint64_t v153;
  _BYTE v154[4];
  char v155;
  uint64_t v156;
  _QWORD v157[2];
  unint64_t v158;
  uint64_t v159[2];
  uint64_t v160;
  _QWORD *v161[2];
  uint64_t v162;
  char v163[32];
  const re::TypeInfo *Tag;
  char v165;
  uint64_t v166;

  if (this == a6)
    goto LABEL_18;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        goto LABEL_18;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_18;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
  {
LABEL_203:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, this, a6);
    return 0;
  }
  v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
  if (v19)
    v20 = *(_DWORD *)(v19 + 16);
  else
    v20 = -1;
  v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
  if (v21)
    v22 = *(_DWORD *)(v21 + 16);
  else
    v22 = -1;
  if (v20 != v22)
  {
    v26 = re::TypeInfo::name(this);
    v27 = re::TypeInfo::name(a6);
    if (re::StringID::operator==(v26, v27))
    {
      v28 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
      if (v28)
        v29 = *(_DWORD *)(v28 + 16);
      else
        v29 = -1;
      re::TypeInfo::atVersion(this, v29, (unsigned __int8 *)&v153);
      if ((_BYTE)v153)
      {
        if ((a7 & 1) != 0)
          Instance = 0;
        else
          Instance = re::TypeInfo::createInstance((re::TypeInfo *)v154, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
        if (!*(_BYTE *)(a1 + 64))
        {
          (*(void (**)(uint64_t, const char *, const re::TypeInfo *, void **, _BYTE *, const re::TypeInfo *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, Instance, v154, a6, a7);
          if (!*(_BYTE *)(a1 + 64))
          {
            if ((a7 & 1) != 0)
              return 1;
            re::TypeInfo::TypeInfo((uint64_t)v149, (uint64_t)v154);
            re::internal::upgradeObject(Instance, v149, a4, (uint64_t **)this, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184), &v150);
            if ((_BYTE)v150)
              return 1;
            if ((v152 & 1) != 0)
              LOBYTE(v147) = BYTE8(v152);
            else
              v147 = (char *)&v152 + 1;
            re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "%s", v120, v121, v122, v123, v124, (char)v147);
            if (!(_BYTE)v150 && *((_QWORD *)&v151 + 1) && (v152 & 1) != 0)
              (*(void (**)(void))(**((_QWORD **)&v151 + 1) + 40))();
            return 0;
          }
        }
        if (!Instance)
          return 0;
        v98 = *(re::Allocator **)(a1 + 48);
        v105 = *(void **)(a1 + 184);
        v106 = (unint64_t *)v154;
        v107 = Instance;
LABEL_159:
        re::TypeInfo::releaseInstance((re::TypeInfo *)v106, v107, v98, v105);
        return 0;
      }
      v50 = re::TypeInfo::name(a6)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
      LOBYTE(v148) = v50;
      v30 = "Unknown serialized type \"%s\" version %u. No matching runtime type found.";
    }
    else
    {
      v47 = re::TypeInfo::name(a6)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
      re::TypeInfo::name(this);
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      LOBYTE(v148) = v47;
      v30 = "Type name changed: Serialized type \"%s\" version %u, runtime type \"%s\" version %u.";
    }
LABEL_186:
    v113 = a1;
    v114 = a2;
LABEL_187:
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v113, v114, v30, (uint64_t)a4, (uint64_t)this, (uint64_t)a6, a7, a8, v148);
    return 0;
  }
LABEL_18:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      if (this == a6)
        goto LABEL_22;
      if (*(_QWORD *)this != *(_QWORD *)a6)
      {
        if (!re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_203;
LABEL_22:
        v23 = re::TypeInfo::name(this);
        v24 = (unint64_t)*v23 >> 1;
        if (v24 <= 0xCA3DEFB5)
        {
          if ((unint64_t)*v23 >> 1 <= 0x5D0225B)
          {
            if ((unint64_t)*v23 >> 1 <= 0x2E9355)
            {
              if (v24 != 104431)
              {
                if (v24 == 3029738)
                  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<BOOL>(a1 + 24, a2, (char *)a4, a7);
LABEL_237:
                v148 = re::TypeInfo::name(this)[1];
                v30 = "Unsupported basic type \"%s\".";
                goto LABEL_186;
              }
              return re::EncoderBinary<re::SeekableInputStream>::serializeValue<int>(a1 + 24, a2, (char *)a4, a7);
            }
            if (v24 == 3052374)
              return re::EncoderBinary<re::SeekableInputStream>::serializeValue<char>(a1 + 24, a2, (char *)a4, a7);
            v119 = 3327612;
LABEL_210:
            if (v24 == v119)
              return re::EncoderBinary<re::SeekableInputStream>::serializeValue<long long>(a1 + 24, a2, (char *)a4, a7);
            goto LABEL_237;
          }
          if ((unint64_t)*v23 >> 1 > 0xB0F77BD0)
          {
            if (v24 == 2969009105)
              return re::EncoderBinary<re::SeekableInputStream>::serializeValue<double>(a1 + 24, a2, (uint64_t)a3, (char *)a4, (uint64_t)"double", a7);
            if (v24 == 3111160798)
              return re::EncoderBinary<re::SeekableInputStream>::serializeValue<signed char>(a1 + 24, a2, (char *)a4, a7);
            goto LABEL_237;
          }
          if (v24 == 97526364)
            return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, a2, (uint64_t)a3, (char *)a4, (uint64_t)"float", a7);
          v48 = 109413500;
LABEL_180:
          if (v24 == v48)
            return re::EncoderBinary<re::SeekableInputStream>::serializeValue<short>(a1 + 24, a2, (char *)a4, a7);
          goto LABEL_237;
        }
        if ((unint64_t)*v23 >> 1 > 0x18E6A9A092)
        {
          if ((unint64_t)*v23 >> 1 <= 0x303EE8780EDLL)
          {
            if (v24 == 0x18E6A9A093)
              return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, (char *)a4, (uint64_t)"uint8", a7);
            if (v24 == 0x303EE86A734)
              return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned short>(a1 + 24, a2, (char *)a4, a7);
            goto LABEL_237;
          }
          if (v24 == 0x303EE8780EELL)
            return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, a2, (uint64_t)a3, (char *)a4, (uint64_t)"uint32", a7);
          if (v24 != 0x303EE88E58DLL)
            goto LABEL_237;
        }
        else
        {
          if ((unint64_t)*v23 >> 1 > 0x16749DFF02)
          {
            if (v24 == 0x16749DFF03)
              return re::EncoderBinary<re::SeekableInputStream>::serializeValue<int>(a1 + 24, a2, (char *)a4, a7);
            v119 = 0x16749F63A2;
            goto LABEL_210;
          }
          if (v24 != 3393056694)
          {
            v48 = 0x16749D2549;
            goto LABEL_180;
          }
        }
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned long long>(a1 + 24, a2, (char *)a4, a7);
      }
      v51 = **((_QWORD **)this + 2);
      v52 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v51 == (unsigned __int16)v52)
      {
        v18 = WORD1(v51) == WORD1(v52);
        v53 = (v52 ^ v51) & 0xFFFFFF00000000;
        if (v18 && v53 == 0)
          goto LABEL_22;
      }
      goto LABEL_203;
    case 2:
      return re::serializeEnum<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a3, a4, (uint64_t)this, (uint64_t)a6, a7);
    case 3:
      if (this == a6)
        goto LABEL_94;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v55 = **((_QWORD **)this + 2);
        v56 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v55 == (unsigned __int16)v56
          && WORD1(v55) == WORD1(v56)
          && ((v56 ^ v55) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_94;
        }
        v31 = 3;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_94;
        v31 = *((unsigned __int8 *)this + 12);
      }
      if (v31 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_203;
LABEL_94:
      if ((_DWORD)a7)
      {
        LOBYTE(Tag) = 0;
        re::EncoderBinary<re::SeekableInputStream>::beginOptional(a1 + 24, a2, (char *)&Tag);
        if ((_BYTE)Tag)
        {
          v57 = *(re::internal **)(a1 + 192);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v150);
          re::TypeInfo::TypeInfo((uint64_t)&v153, (uint64_t)&v150 + 8);
          re::internal::translateType(v57, (const re::TypeRegistry *)&v153, (uint64_t)&v150);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, __int128 *, __int128 *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, 0, &v150, &v150, 1);
        }
        v58 = (_anonymous_namespace_ *)(a1 + 24);
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v150);
        re::TypeInfo::TypeInfo((uint64_t)&v153, (uint64_t)&v150 + 8);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v150);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&v150 + 8);
        re::TypeInfo::TypeInfo((uint64_t)&v150, (uint64_t)this);
        v163[0] = (*(uint64_t (**)(uint64_t *))(v151 + 80))(a4) != 0;
        v59 = re::EncoderBinary<re::SeekableInputStream>::beginOptional(a1 + 24, a2, v163);
        if (v163[0])
        {
          v60 = re::TypeInfo::createInstance((re::TypeInfo *)&v153, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
          (*(void (**)(uint64_t *, void **))(v151 + 88))(a4, v60);
          re::TypeInfo::releaseInstance((re::TypeInfo *)&v153, v60, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
        }
        else
        {
          (*(void (**)(uint64_t *, _QWORD, double))(v151 + 88))(a4, 0, v59);
        }
        if (v163[0])
        {
          v115 = (*(uint64_t (**)(uint64_t *))(v151 + 80))(a4);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, uint64_t, unint64_t *, const re::TypeInfo **, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, v115, &v153, &Tag, 0);
        }
        v58 = (_anonymous_namespace_ *)(a1 + 24);
      }
      re::EncoderBinary<re::SeekableInputStream>::endOptional(v58);
      return *(_BYTE *)(a1 + 64) == 0;
    case 4:
      if (this == a6)
        goto LABEL_40;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v61 = **((_QWORD **)this + 2);
        v62 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v61 == (unsigned __int16)v62)
        {
          v18 = WORD1(v61) == WORD1(v62);
          v63 = (v62 ^ v61) & 0xFFFFFF00000000;
          if (v18 && v63 == 0)
          {
LABEL_40:
            v32 = 1;
            if ((_DWORD)a7)
              goto LABEL_41;
            goto LABEL_110;
          }
        }
      }
      else if (re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_40;
      }
      if (*((_BYTE *)a6 + 12) != 4)
        goto LABEL_203;
      v65 = *((_QWORD *)this + 2);
      v66 = (_QWORD *)*((_QWORD *)a6 + 2);
      v67 = *((_DWORD *)v66 + 21) & 0xFFFFFF;
      if ((*(_DWORD *)(v65 + 84) & 0xFFFFFF) != 0)
      {
        if (!v67)
          goto LABEL_203;
      }
      else if (v67 || *(_DWORD *)(v65 + 88) != *((_DWORD *)v66 + 22))
      {
        goto LABEL_203;
      }
      v32 = 0;
      if ((_DWORD)a7)
      {
LABEL_41:
        v33 = *(re::internal **)(a1 + 192);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v150);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&v150 + 8);
        re::internal::translateType(v33, (const re::TypeRegistry *)&Tag, (uint64_t)&v153);
        v34 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v153);
        if (!v34)
          goto LABEL_146;
        v35 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t))v34;
        v36 = (_QWORD *)*((_QWORD *)a6 + 2);
        v37 = *((_DWORD *)v36 + 21) & 0xFFFFFF;
        if (v37)
        {
          v38 = 0;
          v39 = 8;
        }
        else
        {
          v38 = *((int *)v36 + 22);
          v39 = 4;
        }
        *(_QWORD *)&v150 = v38;
        v44 = (_anonymous_namespace_ *)(a1 + 24);
        result = re::EncoderBinary<re::SeekableInputStream>::beginArray(a1 + 24, a2, (uint64_t)a3, (char *)&v150, v39);
        if ((_DWORD)result)
        {
          v116 = v150;
          if (v37)
            v117 = (_QWORD)v150 == 0;
          else
            v117 = 1;
          v118 = v117;
          if (!v117)
          {
            v159[0] = 0;
            v159[1] = 0xFFFFFFFFLL;
            (*(void (**)(uint64_t, _QWORD, uint64_t *))(*(_QWORD *)a1 + 16))(a1, 0, v159);
            v116 = v150;
          }
          if (v155 == 1)
          {
            if (v116)
              re::EncoderBinary<re::SeekableInputStream>::serializeArray(a1 + 24, 0, *(unsigned int *)(v156 + 8), v116, 1);
          }
          else if (v116)
          {
            v126 = 0;
            do
            {
              v35(a1, 0, 0, 0, &v153, &v153, 1);
              ++v126;
            }
            while (v126 < (unint64_t)v150);
          }
          if ((v118 & 1) == 0)
            (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
          goto LABEL_231;
        }
        return result;
      }
LABEL_110:
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v150);
      re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&v150 + 8);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v150);
      re::TypeInfo::TypeInfo((uint64_t)v163, (uint64_t)&v150 + 8);
      re::TypeInfo::TypeInfo((uint64_t)v161, (uint64_t)this);
      v68 = (*(uint64_t (**)(uint64_t, const re::TypeInfo **))(*(_QWORD *)a1 + 80))(a1, &Tag);
      if (!v68)
        goto LABEL_168;
      v69 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, const re::TypeInfo **, char *, _QWORD))v68;
      v70 = re::ArrayAccessor::size((re::ArrayAccessor *)v161, (char *)a4);
      v158 = v70;
      v71 = *(_DWORD *)(*((_QWORD *)this + 2) + 84) & 0xFFFFFF;
      if (v71)
        v72 = 8;
      else
        v72 = 4;
      result = re::EncoderBinary<re::SeekableInputStream>::beginArray(a1 + 24, a2, (uint64_t)a3, (char *)&v158, v72);
      if (!(_DWORD)result)
        return result;
      v73 = (const re::TypeInfo *)v158;
      if (v70 != v158)
      {
        if ((*(_DWORD *)(v162 + 84) & 0xFFFFFF) == 0)
        {
          LOBYTE(v148) = v70;
          v30 = "Invalid array size. Expected size = %zu, actual size = %zu";
          goto LABEL_170;
        }
        re::TypeRegistry::typeInfo(v161[0], *(_QWORD *)(v162 + 72), &v150);
        re::TypeInfo::TypeInfo((uint64_t)&v153, (uint64_t)&v150 + 8);
        v74 = *(_DWORD *)(v156 + 8);
        if (!is_mul_ok(v74, (unint64_t)v73))
          goto LABEL_167;
        re::ArrayAccessor::reset((re::ArrayAccessor *)v161, (void **)a4, *(re::Allocator **)(a1 + 48), v73);
        v70 = v158;
      }
      if (v71)
        v140 = v70 == 0;
      else
        v140 = 1;
      v141 = v140;
      if (!v140)
      {
        v142 = *a4;
        v157[0] = 0;
        v157[1] = 0xFFFFFFFFLL;
        (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 16))(a1, v142, v157);
        v70 = v158;
      }
      if (v165 == 1)
        v143 = v32;
      else
        v143 = 0;
      if ((v143 & 1) != 0)
      {
        if (v70)
        {
          v144 = (char *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)v161, (char *)a4, 0);
          re::EncoderBinary<re::SeekableInputStream>::serializeArray(a1 + 24, v144, *(unsigned int *)(v166 + 8), v158, 0);
        }
      }
      else if (v70)
      {
        v145 = 0;
        do
        {
          v146 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)v161, (char *)a4, v145);
          v69(a1, 0, 0, v146, &Tag, v163, 0);
          ++v145;
        }
        while (v145 < v158);
      }
      if ((v141 & 1) == 0)
        (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
      v127 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_283;
    case 5:
      if (this == a6)
        goto LABEL_47;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v75 = **((_QWORD **)this + 2);
        v76 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v75 == (unsigned __int16)v76
          && WORD1(v75) == WORD1(v76)
          && ((v76 ^ v75) & 0xFFFFFF00000000) == 0)
        {
LABEL_47:
          v40 = 1;
          if ((_DWORD)a7)
            goto LABEL_48;
LABEL_163:
          re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v150);
          re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&v150 + 8);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v150);
          re::TypeInfo::TypeInfo((uint64_t)v163, (uint64_t)&v150 + 8);
          re::TypeInfo::TypeInfo((uint64_t)v161, (uint64_t)this);
          v108 = (*(uint64_t (**)(uint64_t, const re::TypeInfo **))(*(_QWORD *)a1 + 80))(a1, &Tag);
          if (!v108)
            goto LABEL_168;
          v109 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, const re::TypeInfo **, char *, _QWORD))v108;
          v110 = (*(uint64_t (**)(uint64_t *))(v162 + 80))(a4);
          v159[0] = v110;
          v111 = re::EncoderBinary<re::SeekableInputStream>::beginArray(a1 + 24, a2, (uint64_t)a3, (char *)v159, 0);
          result = 0;
          if (!v111)
            return result;
          v112 = v159[0];
          if (v110 != v159[0])
          {
            re::TypeRegistry::typeInfo(v161[0], *(_QWORD *)(v162 + 72), &v150);
            re::TypeInfo::TypeInfo((uint64_t)&v153, (uint64_t)&v150 + 8);
            v74 = *(_DWORD *)(v156 + 8);
            if (!is_mul_ok(v74, v112))
            {
LABEL_167:
              LOBYTE(v148) = v74;
              v30 = "Size overflow during deserialization. Element size = %zu, count = %zu";
              goto LABEL_170;
            }
            v128 = *(_QWORD *)(a1 + 48);
            v129 = *(void (**)(uint64_t *, __int128 *, uint64_t, unint64_t))(v162 + 88);
            re::TypeInfo::TypeInfo((uint64_t)&v150, (uint64_t)v161);
            v129(a4, &v150, v128, v112);
          }
          v130 = *(uint64_t (**)(uint64_t *, _QWORD))(v162 + 96);
          if (v130)
          {
            if (*((_BYTE *)this + 12) == 5)
              v131 = v40;
            else
              v131 = 0;
            if ((v131 & 1) != 0)
            {
              v132 = v159[0];
              if ((*(_BYTE *)(*((_QWORD *)this + 2) + 48) & 8) != 0 && v165 == 1)
              {
                if (v159[0])
                {
                  v133 = (char *)v130(a4, 0);
                  re::EncoderBinary<re::SeekableInputStream>::serializeArray(a1 + 24, v133, *(unsigned int *)(v166 + 8), v159[0], 0);
                }
                goto LABEL_259;
              }
            }
            else
            {
              v132 = v159[0];
            }
            if (v132)
            {
              v138 = 0;
              do
              {
                v139 = (*(uint64_t (**)(uint64_t *, unint64_t))(v162 + 96))(a4, v138);
                v109(a1, 0, 0, v139, &Tag, v163, 0);
                ++v138;
              }
              while (v138 < v159[0]);
            }
            goto LABEL_259;
          }
          v134 = *(uint64_t (**)(uint64_t *, _QWORD))(v162 + 104);
          if (!v134 || !*(_QWORD *)(v162 + 112) || !*(_QWORD *)(v162 + 120))
          {
            re::TypeInfo::TypeInfo((uint64_t)&v150, (uint64_t)v161);
            v148 = re::TypeInfo::name((re::TypeInfo *)&v150)[1];
            v30 = "List type \"%s\" does not provide an indexer or iterator.";
            goto LABEL_186;
          }
          v135 = v134(a4, *(_QWORD *)(a1 + 56));
          v136 = (*(uint64_t (**)(void))(v162 + 112))();
          if (v136)
          {
            v137 = v136;
            do
            {
              v109(a1, 0, 0, v137, &Tag, v163, 0);
              v137 = (*(uint64_t (**)(uint64_t))(v162 + 112))(v135);
            }
            while (v137);
          }
          (*(void (**)(uint64_t, _QWORD))(v162 + 120))(v135, *(_QWORD *)(a1 + 56));
LABEL_259:
          v127 = (_anonymous_namespace_ *)(a1 + 24);
          goto LABEL_283;
        }
        v77 = 5;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_47;
        v77 = *((unsigned __int8 *)this + 12);
      }
      if (v77 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_203;
      v40 = 0;
      if (!(_DWORD)a7)
        goto LABEL_163;
LABEL_48:
      v41 = *(re::internal **)(a1 + 192);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v150);
      re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&v150 + 8);
      re::internal::translateType(v41, (const re::TypeRegistry *)&Tag, (uint64_t)&v153);
      v42 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v153);
      if (!v42)
        goto LABEL_146;
      v43 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t))v42;
      *(_QWORD *)&v150 = 0;
      v44 = (_anonymous_namespace_ *)(a1 + 24);
      v45 = re::EncoderBinary<re::SeekableInputStream>::beginArray(a1 + 24, a2, (uint64_t)a3, (char *)&v150, 0);
      result = 0;
      if (v45)
      {
        if (v155 == 1)
        {
          if ((_QWORD)v150)
            re::EncoderBinary<re::SeekableInputStream>::serializeArray(a1 + 24, 0, *(unsigned int *)(v156 + 8), v150, 1);
        }
        else if ((_QWORD)v150)
        {
          v125 = 0;
          do
          {
            v43(a1, 0, 0, 0, &v153, &v153, 1);
            ++v125;
          }
          while (v125 < (unint64_t)v150);
        }
LABEL_231:
        v127 = v44;
LABEL_283:
        re::EncoderBinary<re::SeekableInputStream>::endArray(v127);
        return *(_BYTE *)(a1 + 64) == 0;
      }
      return result;
    case 6:
      if (this == a6)
        goto LABEL_128;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v78 = **((_QWORD **)this + 2);
        v79 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v78 == (unsigned __int16)v79
          && WORD1(v78) == WORD1(v79)
          && ((v79 ^ v78) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_128;
        }
        v46 = 6;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_128;
        v46 = *((unsigned __int8 *)this + 12);
      }
      if (v46 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_203;
LABEL_128:
      if ((_DWORD)a7)
      {
        v80 = *(re::internal **)(a1 + 192);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v150);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&v150 + 8);
        re::internal::translateType(v80, (const re::TypeRegistry *)&Tag, (uint64_t)&v153);
        v81 = *(re::internal **)(a1 + 192);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v150);
        re::TypeInfo::TypeInfo((uint64_t)v163, (uint64_t)&v150 + 8);
        re::internal::translateType(v81, (const re::TypeRegistry *)v163, (uint64_t)&Tag);
        v82 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v153);
        if (v82)
        {
          v83 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t, double))v82;
          v84 = (*(uint64_t (**)(uint64_t, const re::TypeInfo **))(*(_QWORD *)a1 + 80))(a1, &Tag);
          if (v84)
          {
            v85 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, const re::TypeInfo **, const re::TypeInfo **, uint64_t))v84;
            *(_QWORD *)&v150 = 0;
            v86 = (_anonymous_namespace_ *)(a1 + 24);
            result = re::EncoderBinary<re::SeekableInputStream>::beginDictionary(a1 + 24, a2, (char *)&v150);
            if (!(_DWORD)result)
              return result;
            if ((_QWORD)v150)
            {
              v87 = 0;
              do
              {
                v88 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 1);
                v83(a1, "key", 0, 0, &v153, &v153, 1, v88);
                v85(a1, "value", 0, 0, &Tag, &Tag, 1);
                re::EncoderBinary<re::SeekableInputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
                ++v87;
              }
              while (v87 < (unint64_t)v150);
            }
            goto LABEL_145;
          }
          goto LABEL_168;
        }
LABEL_146:
        v100 = &v153;
        goto LABEL_169;
      }
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v150);
      re::TypeInfo::TypeInfo((uint64_t)&v153, (uint64_t)&v150 + 8);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v150);
      re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&v150 + 8);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v150);
      re::TypeInfo::TypeInfo((uint64_t)v163, (uint64_t)&v150 + 8);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v150);
      re::TypeInfo::TypeInfo((uint64_t)v161, (uint64_t)&v150 + 8);
      re::TypeInfo::TypeInfo((uint64_t)v159, (uint64_t)this);
      v89 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v153);
      if (!v89)
        goto LABEL_146;
      v90 = (void (*)(uint64_t, const char *, _QWORD, void **, unint64_t *, char *, _QWORD, double))v89;
      v91 = (*(uint64_t (**)(uint64_t, const re::TypeInfo **))(*(_QWORD *)a1 + 80))(a1, &Tag);
      if (!v91)
      {
LABEL_168:
        v100 = (unint64_t *)&Tag;
LABEL_169:
        v148 = re::TypeInfo::name((re::TypeInfo *)v100)[1];
        v30 = "Failed to resolve serialize function for type \"%s\"";
LABEL_170:
        v113 = a1;
        v114 = 0;
        goto LABEL_187;
      }
      v92 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, const re::TypeInfo **, _QWORD **, _QWORD))v91;
      v157[0] = (*(uint64_t (**)(uint64_t *))(v160 + 88))(a4);
      v86 = (_anonymous_namespace_ *)(a1 + 24);
      result = re::EncoderBinary<re::SeekableInputStream>::beginDictionary(a1 + 24, a2, (char *)v157);
      if (!(_DWORD)result)
        return result;
      v93 = *(_QWORD *)(a1 + 48);
      v94 = *(void (**)(uint64_t *, __int128 *, uint64_t))(v160 + 96);
      re::TypeInfo::TypeInfo((uint64_t)&v150, (uint64_t)v159);
      v94(a4, &v150, v93);
      if (!v157[0])
        goto LABEL_145;
      v95 = re::TypeInfo::createInstance((re::TypeInfo *)&v153, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
      if (!v157[0])
      {
LABEL_144:
        re::TypeInfo::releaseInstance((re::TypeInfo *)&v153, v95, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
LABEL_145:
        re::EncoderBinary<re::SeekableInputStream>::endDictionary(v86);
        return *(_BYTE *)(a1 + 64) == 0;
      }
      v96 = 0;
      while (1)
      {
        v97 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
        v90(a1, "key", 0, v95, &v153, v163, 0, v97);
        v98 = *(re::Allocator **)(a1 + 48);
        if (*(_BYTE *)(a1 + 64))
          break;
        v99 = (*(uint64_t (**)(uint64_t *, uint64_t *, re::Allocator *, void **))(v160 + 104))(a4, v159, v98, v95);
        v92(a1, "value", 0, v99, &Tag, v161, 0);
        re::EncoderBinary<re::SeekableInputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
        if ((unint64_t)++v96 >= v157[0])
          goto LABEL_144;
      }
      v105 = *(void **)(a1 + 184);
      v106 = &v153;
      v107 = v95;
      break;
    case 7:
      if (this == a6)
        goto LABEL_60;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v101 = **((_QWORD **)this + 2);
        v102 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v101 != (unsigned __int16)v102)
          goto LABEL_203;
        v18 = WORD1(v101) == WORD1(v102);
        v103 = (v102 ^ v101) & 0xFFFFFF00000000;
        if (!v18 || v103 != 0)
          goto LABEL_203;
      }
      else if (!re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_203;
      }
LABEL_60:
      if ((_DWORD)a7)
      {
        if (*(_BYTE *)(a1 + 64))
          return 0;
        LOBYTE(v150) = 1;
        DWORD1(v150) = 16;
        *((_QWORD *)&v150 + 1) = a2;
        v151 = 0u;
        v152 = 0u;
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), &v150);
        v153 = 0;
        re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned long long>(a1 + 24, "tag", (char *)&v153, 0);
        if (v153 < *(unsigned int *)(*((_QWORD *)a6 + 2) + 88))
        {
          re::TypeInfo::unionMember(a6, v153, (uint64_t)&v150);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, __int128 *, __int128 *, uint64_t))(*(_QWORD *)a1 + 72))(a1, "value", 0, 0, &v150, &v150, 1);
        }
      }
      else
      {
        if (*(_BYTE *)(a1 + 64))
          return 0;
        LOBYTE(v150) = 1;
        DWORD1(v150) = 16;
        *((_QWORD *)&v150 + 1) = a2;
        v151 = 0u;
        v152 = 0u;
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), &v150);
        re::TypeInfo::TypeInfo((uint64_t)&v150, (uint64_t)this);
        Tag = (const re::TypeInfo *)re::UnionAccessor::readTag((re::UnionAccessor *)&v150, (char *)a4);
        re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned long long>(a1 + 24, "tag", (char *)&Tag, 0);
        re::UnionAccessor::reset((re::UnionAccessor *)&v150, (char *)a4, Tag, *(re::Allocator **)(a1 + 48));
        if ((unint64_t)Tag < *(unsigned int *)(*((_QWORD *)this + 2) + 88))
        {
          re::TypeInfo::unionMember(this, (uint64_t)Tag, (uint64_t)&v153);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, uint64_t *, unint64_t *, unint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, "value", 0, a4, &v153, &v153, 0);
        }
      }
      re::EncoderBinary<re::SeekableInputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(_BYTE *)(a1 + 64) == 0;
    case 8:
      return re::serializeObject<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, (uint64_t)a3, (uint64_t)a4, this, (uint64_t)a6, a7);
    case 9:
      v148 = re::TypeInfo::name(this)[1];
      v30 = "Pointer type (\"%s\") needs to be handled explicitly by the serializer.";
      goto LABEL_186;
    default:
      LOBYTE(v148) = *((_BYTE *)this + 12);
      v30 = "Invalid type category. Value = %d";
      goto LABEL_186;
  }
  goto LABEL_159;
}

uint64_t re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, re::TypeInfo *this, re::TypeInfo *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v7 = re::TypeInfo::name(this)[1];
  re::TypeInfo::name(a4);
  return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Type mismatch. Runtime type \"%s\" and serialized type \"%s\" are different.", v8, v9, v10, v11, v12, v7);
}

uint64_t re::serializeEnum<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  uint64_t *v19;

  if (a5 == a6)
    return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **(_QWORD **)(a5 + 16);
    v15 = **(_QWORD **)(a6 + 16);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
    }
  }
  else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
  {
    return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
  }
  if (*(unsigned __int8 *)(a5 + 12) == *(unsigned __int8 *)(a6 + 12))
  {
    v18 = re::TypeInfo::name((re::TypeInfo *)a5);
    v19 = re::TypeInfo::name((re::TypeInfo *)a6);
    if (re::StringID::operator==(v18, v19))
      return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
  return 0;
}

uint64_t re::serializeObject<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  uint64_t *v14;
  const char *v15;
  re::TypeRegistry *v17;
  re *v18;
  const re::TypeInfo *v19;
  uint64_t v20;
  const char *v21;
  const re::TypeInfo *v22;
  const re::TypeInfo *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[2];
  _BYTE v35[32];
  _OWORD v36[3];

  if (!(_DWORD)a7)
  {
LABEL_6:
    if ((*(_BYTE *)(*((_QWORD *)this + 2) + 48) & 4) != 0)
      return re::internal::serializeObjectWithOneMember<re::EncoderBinary<re::SeekableInputStream>>((_BYTE *)a1, a2, a3, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    if (*(_BYTE *)(a1 + 64))
      return 0;
    LOBYTE(v36[0]) = 1;
    DWORD1(v36[0]) = 0;
    *((_QWORD *)&v36[0] + 1) = a2;
    memset(&v36[1], 0, 32);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), v36);
    if (this == (re::TypeInfo *)a6)
      goto LABEL_14;
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v24 = **((_QWORD **)this + 2);
      v25 = **(_QWORD **)(a6 + 16);
      if ((unsigned __int16)v24 == (unsigned __int16)v25)
      {
        v27 = WORD1(v24) == WORD1(v25);
        v26 = (v25 ^ v24) & 0xFFFFFF00000000;
        v27 = v27 && v26 == 0;
        if (v27)
          goto LABEL_14;
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v23))
    {
LABEL_14:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, a4, (uint64_t *)this, a7);
LABEL_25:
      re::EncoderBinary<re::SeekableInputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(_BYTE *)(a1 + 64) == 0;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::SeekableInputStream>>(a1, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    }
    else
    {
      v28 = re::TypeInfo::name(this)[1];
      re::TypeInfo::name((re::TypeInfo *)a6);
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v29, v30, v31, v32, v33, v28);
    }
    goto LABEL_25;
  }
  if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
  {
    v17 = *(re::TypeRegistry **)(a1 + 192);
    v34[0] = 0x2686EB529B3EE220;
    v34[1] = "DynamicString";
    re::TypeRegistry::typeInfo(v17, (const re::StringID *)v34, v36);
    re::TypeInfo::TypeInfo((uint64_t)v35, (uint64_t)v36 + 8);
    re::StringID::destroyString((re::StringID *)v34);
    v18 = (re *)v35;
    v19 = (const re::TypeInfo *)v35;
    v20 = a1;
    v21 = a2;
    v22 = (const re::TypeInfo *)a3;
  }
  else
  {
    v14 = re::TypeInfo::name(this);
    if ((*v14 & 0xFFFFFFFFFFFFFFFELL) != 0x2686EB529B3EE220)
      goto LABEL_6;
    v15 = (const char *)v14[1];
    if (v15 != "DynamicString")
    {
      if (strcmp(v15, "DynamicString"))
        goto LABEL_6;
    }
    v20 = a1;
    v21 = a2;
    v22 = (const re::TypeInfo *)a3;
    v18 = this;
    v19 = this;
  }
  re::serializeDynamicString<re::EncoderBinary<re::SeekableInputStream>>(v20, v21, v22, 0, v18, v19, 1);
  return *(_BYTE *)(a1 + 64) == 0;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<BOOL>(uint64_t a1, const char *a2, char *a3, char a4)
{
  uint64_t v8;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a4 & 1) != 0)
    a3 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a3, 1uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"BOOL");
    return 0;
  }
  if ((a4 & 2) == 0)
  {
    v8 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v8 - 16);
  }
  return 1;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<char>(uint64_t a1, const char *a2, char *a3, char a4)
{
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    if ((a4 & 1) != 0)
      a3 = 0;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a3, 1uLL) & 1) != 0)
    {
      v7 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v7 - 16);
      return 1;
    }
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"char");
  }
  return 0;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<signed char>(uint64_t a1, const char *a2, char *a3, char a4)
{
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    if ((a4 & 1) != 0)
      a3 = 0;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a3, 1uLL) & 1) != 0)
    {
      v7 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v7 - 16);
      return 1;
    }
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"int8");
  }
  return 0;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<short>(uint64_t a1, const char *a2, char *a3, char a4)
{
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    if ((a4 & 1) != 0)
      a3 = 0;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a3, 2uLL) & 1) != 0)
    {
      v7 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v7 - 16);
      return 1;
    }
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"int16");
  }
  return 0;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<int>(uint64_t a1, const char *a2, char *a3, char a4)
{
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    if ((a4 & 1) != 0)
      a3 = 0;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a3, 4uLL) & 1) != 0)
    {
      v7 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v7 - 16);
      return 1;
    }
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"int32");
  }
  return 0;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<long long>(uint64_t a1, const char *a2, char *a3, char a4)
{
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    if ((a4 & 1) != 0)
      a3 = 0;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a3, 8uLL) & 1) != 0)
    {
      v7 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v7 - 16);
      return 1;
    }
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"int64");
  }
  return 0;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned short>(uint64_t a1, const char *a2, char *a3, char a4)
{
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    if ((a4 & 1) != 0)
      a3 = 0;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a3, 2uLL) & 1) != 0)
    {
      v7 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v7 - 16);
      return 1;
    }
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"uint16");
  }
  return 0;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a4, 4uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned long long>(uint64_t a1, const char *a2, char *a3, char a4)
{
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    if ((a4 & 1) != 0)
      a3 = 0;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a3, 8uLL) & 1) != 0)
    {
      v7 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v7 - 16);
      return 1;
    }
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"uint64");
  }
  return 0;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeValue<double>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a4, 8uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::internal::serializeEnumAsBinary<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re::internal *a5, re::internal *a6, int a7)
{
  re::internal *v11;
  uint64_t result;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  void *v21;
  int v22;
  re::internal *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  unsigned int EnumConstantIndex;
  unsigned int v31;
  re::internal::TypeTranslationTable *v32;
  const void *v33;
  int v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD v56[4];
  uint64_t __src;
  _QWORD v58[4];

  if (a7)
  {
    v11 = *(re::internal **)(a1 + 192);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v11, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (!*(_BYTE *)(a1 + 64))
      return (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, _QWORD, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, 0, &__src, &__src, 1);
    return 0;
  }
  v15 = *(_QWORD **)a5;
  if (a5 == a6)
    goto LABEL_8;
  if (v15 == *(_QWORD **)a6)
  {
    v16 = **((_QWORD **)a5 + 2);
    v17 = (uint64_t *)*((_QWORD *)a6 + 2);
    v18 = *v17;
    if ((unsigned __int16)v16 == (unsigned __int16)*v17)
    {
      v20 = WORD1(v16) == WORD1(v18);
      v19 = (v18 ^ v16) & 0xFFFFFF00000000;
      v20 = v20 && v19 == 0;
      if (v20)
        goto LABEL_8;
    }
LABEL_21:
    v23 = *(re::internal **)(a1 + 192);
    re::TypeRegistry::typeInfo(v15, v17[9], &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v23, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (*(_DWORD *)(v58[1] + 8) < 9u)
    {
      v55 = 0;
      if (!*(_BYTE *)(a1 + 64)
        && (*(unsigned int (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, uint64_t *, uint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, a3, &v55, &__src, &__src, 0))
      {
        EnumConstantIndex = re::internal::getEnumConstantIndex(a6, (const re::TypeInfo *)&v55, v29);
        if ((EnumConstantIndex & 0x80000000) != 0)
        {
          v41 = v55;
          re::TypeInfo::name(a6);
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v42, v43, v44, v45, v46, v41);
        }
        else
        {
          v31 = EnumConstantIndex;
          v32 = *(re::internal::TypeTranslationTable **)(*(_QWORD *)a6 + 856);
          if (v32)
          {
            v33 = (const void *)re::internal::TypeTranslationTable::translateSerializedEnum(v32, a6, v31, a5);
            if (v33)
            {
              memcpy(a4, v33, *(unsigned int *)(*((_QWORD *)a5 + 2) + 8));
              v34 = 0;
              return v34 == 0;
            }
          }
          v56[0] = re::TypeInfo::enumConstants(a6);
          v56[1] = v47;
          v48 = *(_QWORD *)(re::Slice<re::EnumConstant>::operator[](v56, v31) + 16);
          re::TypeInfo::name(a5);
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Serialized enum constant \"%s\" does not exist in runtime type \"%s\".", v49, v50, v51, v52, v53, v48);
        }
      }
    }
    else
    {
      v54 = re::TypeInfo::name((re::TypeInfo *)&__src)[1];
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Enum type \"%s\" has invalid size: %zu bytes.", v24, v25, v26, v27, v28, v54);
    }
    v34 = 1;
    return v34 == 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
  {
    v15 = *(_QWORD **)a6;
    v17 = (uint64_t *)*((_QWORD *)a6 + 2);
    goto LABEL_21;
  }
  v15 = *(_QWORD **)a5;
LABEL_8:
  re::TypeRegistry::typeInfo(v15, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &__src);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
  __src = 0;
  if (*(_BYTE *)(a1 + 64))
    return 0;
  v22 = (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, _QWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, a3, &__src, v56, v56, 0);
  result = 0;
  if (v22)
  {
    if ((re::internal::getEnumConstantIndex(a5, (const re::TypeInfo *)&__src, v21) & 0x80000000) != 0)
    {
      v35 = __src;
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v36, v37, v38, v39, v40, v35);
      return 0;
    }
    memcpy(a4, &__src, *(unsigned int *)(*((_QWORD *)a5 + 2) + 8));
    return 1;
  }
  return result;
}

double re::EncoderBinary<re::SeekableInputStream>::beginOptional(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6;
  double result;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (!*(_BYTE *)(a1 + 40))
  {
    re::EncoderBinary<re::SeekableInputStream>::serializeValue<BOOL>(a1, a2, a3, 2);
    v6 = *a3;
    LOBYTE(v8) = 3;
    DWORD1(v8) = 0;
    *((_QWORD *)&v8 + 1) = a2;
    v9 = 0;
    v11 = 0;
    v12 = 0;
    v10 = v6;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v8);
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::SeekableInputStream>::endOptional(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  const char *v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  _OWORD v8[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 3);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v3 = *(_BYTE **)&v7[7];
      else
        v3 = v7;
      if (*(uint64_t *)(*(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112) - 24) <= 0)
        v4 = "Optional should not have a value.";
      else
        v4 = "Optional requires a value.";
      re::DynamicString::format((re::DynamicString *)"Failed to serialize optional type \"%s\". %s", (re::DynamicString *)v8, v3, v4);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(_QWORD *)&v8[0])
      {
        if ((BYTE8(v8[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v8[0] + 40))();
        memset(v8, 0, sizeof(v8));
      }
      result = v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
      }
    }
  }
  return result;
}

BOOL re::EncoderBinary<re::SeekableInputStream>::beginArray(uint64_t a1, const char *a2, uint64_t a3, char *a4, int a5)
{
  char v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a5 & 4) == 0)
    re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1, a2, 0, a4, (uint64_t)"uint32", 2);
  if ((a5 & 8) != 0)
  {
    if (*(_QWORD *)a4)
      v10 = 73;
    else
      v10 = 78;
    v17 = v10;
    re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned char>(a1, a2, 0, &v17, (uint64_t)"uint8", 2);
  }
  v11 = *(_QWORD *)a4;
  LOBYTE(v12) = 5;
  DWORD1(v12) = a5;
  *((_QWORD *)&v12 + 1) = a2;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  v14 = v11;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v12);
  return *(_BYTE *)(a1 + 40) == 0;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeArray(uint64_t result, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  _anonymous_namespace_ *v6;
  size_t v7;
  uint64_t v8;

  if (!*(_BYTE *)(result + 40))
  {
    v6 = (_anonymous_namespace_ *)result;
    v7 = a4 * a3;
    if ((a5 & 1) != 0)
      a2 = 0;
    result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, a2, v7);
    if ((result & 1) != 0)
    {
      v8 = *((_QWORD *)v6 + 16) + 48 * *((_QWORD *)v6 + 14);
      *(_QWORD *)(v8 - 16) += a4;
    }
    else
    {
      return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v6, 0, (uint64_t)"Array");
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::SeekableInputStream>::endArray(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  _OWORD v8[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 5);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v3 = *(_BYTE **)&v7[7];
      else
        v3 = v7;
      v4 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)v8, v3, *(_QWORD *)(v4 - 24), *(_QWORD *)(v4 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(_QWORD *)&v8[0])
      {
        if ((BYTE8(v8[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v8[0] + 40))();
        memset(v8, 0, sizeof(v8));
      }
      result = v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
      }
    }
  }
  return result;
}

BOOL re::EncoderBinary<re::SeekableInputStream>::beginDictionary(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1, a2, 0, a3, (uint64_t)"uint32", 2);
  v7 = *(_QWORD *)a3;
  LOBYTE(v8) = 6;
  DWORD1(v8) = 0;
  *((_QWORD *)&v8 + 1) = a2;
  v9 = 0;
  v11 = 0;
  v12 = 0;
  v10 = v7;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v8);
  return *(_BYTE *)(a1 + 40) == 0;
}

_anonymous_namespace_ *re::EncoderBinary<re::SeekableInputStream>::endDictionaryEntry(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  _anonymous_namespace_ *v4;
  char v5;
  _BYTE v6[23];
  _OWORD v7[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == 2)
    {
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 7);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v4);
      if ((v5 & 1) != 0)
        v3 = *(_BYTE **)&v6[7];
      else
        v3 = v6;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary entry \"%s\". Expected 2 objects (key+value). Actual number of objects: %lld.", (re::DynamicString *)v7, v3, *(_QWORD *)(*(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112) - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v7);
      if (*(_QWORD *)&v7[0])
      {
        if ((BYTE8(v7[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v7[0] + 40))();
        memset(v7, 0, sizeof(v7));
      }
      result = v4;
      if (v4)
      {
        if ((v5 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v4 + 40))();
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::SeekableInputStream>::endDictionary(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  _OWORD v8[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 6);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v3 = *(_BYTE **)&v7[7];
      else
        v3 = v7;
      v4 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)v8, v3, *(_QWORD *)(v4 - 24), *(_QWORD *)(v4 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(_QWORD *)&v8[0])
      {
        if ((BYTE8(v8[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v8[0] + 40))();
        memset(v8, 0, sizeof(v8));
      }
      result = v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::SeekableInputStream>::endObject(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 1);
    v2 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
    ++*(_QWORD *)(v2 - 16);
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, _QWORD *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  _BOOL4 v20;
  _BOOL8 result;
  _anonymous_namespace_ *v22;
  unint64_t v23;
  unint64_t v24;
  _BOOL4 v25;
  unint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  char *v34;
  unint64_t v35;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v35 = 0;
    v20 = re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v35, 0);
    result = 0;
    if (!v20)
      return result;
    if (v35)
      re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  v23 = a4[1];
  if ((v23 & 1) != 0)
    v24 = v23 >> 1;
  else
    v24 = v23 >> 1;
  v35 = v24;
  v25 = re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v35, 0);
  result = 0;
  if (v25)
  {
    v26 = v35;
    if (v26 <= (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
    {
      if (!*a4)
      {
        v33 = v35 + 1;
        *a4 = *(_QWORD *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v33);
      }
      re::DynamicString::resize(a4, v35, 0);
      if (v35)
      {
        if ((a4[1] & 1) != 0)
          v34 = (char *)a4[2];
        else
          v34 = (char *)a4 + 9;
        re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, v34, 0);
      }
      v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      re::EncoderBinary<re::SeekableInputStream>::endString(v22);
      return *(_BYTE *)(a1 + 64) == 0;
    }
    v27 = v35;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v28, v29, v30, v31, v32, v27);
    return 0;
  }
  return result;
}

uint64_t re::internal::serializeObjectWithOneMember<re::EncoderBinary<re::SeekableInputStream>>(_BYTE *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t *v14;
  uint64_t v15;
  const re::TypeInfo *v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23[5];
  _QWORD *v24[4];
  _BYTE v25[32];
  _BYTE v26[32];
  _QWORD *v27;
  uint64_t v28;
  _BYTE v29[8];
  _BYTE v30[32];

  v14 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)v29, *a5, a5[2]);
  re::TypeMemberCollection::operator[](v14, 0, (uint64_t)&v27);
  v15 = a4 + *(unsigned int *)(v28 + 24);
  re::TypeRegistry::typeInfo(v27, *(_QWORD *)v28, v29);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v30);
  if (a5 == a6)
    goto LABEL_4;
  if (*a5 == *a6)
  {
    v18 = *(_QWORD *)a5[2];
    v19 = a6[2];
    v20 = *(_QWORD *)v19;
    if ((unsigned __int16)v18 != (unsigned __int16)*(_QWORD *)v19)
      goto LABEL_14;
    v22 = WORD1(v18) == WORD1(v20);
    v21 = (v20 ^ v18) & 0xFFFFFF00000000;
    v22 = v22 && v21 == 0;
    if (!v22)
      goto LABEL_14;
LABEL_4:
    if (!a1[64])
      return (*(uint64_t (**)(_BYTE *, const char *, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, v15, v26, v26, a7);
    return 0;
  }
  if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, v16))
    goto LABEL_4;
  v19 = a6[2];
LABEL_14:
  if (*(_DWORD *)(v19 + 88) != 1)
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
    return 0;
  }
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v23, *a6, v19);
  re::TypeMemberCollection::operator[](v23, 0, (uint64_t)v24);
  re::TypeRegistry::typeInfo(v24[0], *v24[2], v29);
  re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v30);
  if (a1[64])
    return 0;
  return (*(uint64_t (**)(_BYTE *, const char *, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, v15, v26, v25, a7);
}

BOOL re::EncoderBinary<re::SeekableInputStream>::beginString(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1, "length", 0, a4, (uint64_t)"uint32", 2);
  v10 = *(_QWORD *)a4;
  LOBYTE(v11) = 8;
  DWORD1(v11) = a5;
  *((_QWORD *)&v11 + 1) = a2;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v13 = v10;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
  return *(_BYTE *)(a1 + 40) == 0;
}

uint64_t re::EncoderBinary<re::SeekableInputStream>::serializeString(uint64_t result, char *a2, char a3)
{
  _anonymous_namespace_ *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (!*(_BYTE *)(result + 40))
  {
    v4 = (_anonymous_namespace_ *)result;
    v5 = *(_QWORD *)(result + 128) + 48 * *(_QWORD *)(result + 112);
    v6 = *(_QWORD *)(v5 - 24);
    if ((a3 & 1) != 0)
      a2 = 0;
    result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, a2, *(_QWORD *)(v5 - 24));
    if ((result & 1) != 0)
    {
      if ((a3 & 2) == 0)
      {
        v7 = *((_QWORD *)v4 + 16) + 48 * *((_QWORD *)v4 + 14);
        *(_QWORD *)(v7 - 16) += v6;
      }
    }
    else
    {
      return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v4, 0, (uint64_t)"string");
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::SeekableInputStream>::endString(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11[3];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 8);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v3 = *(_BYTE **)&v7[7];
      else
        v3 = v7;
      v4 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize string \"%s\". Expected number of characters: %lld. Actual number of characters: %lld.", (re::DynamicString *)&v8, v3, *(_QWORD *)(v4 - 24), *(_QWORD *)(v4 - 16));
      *(_QWORD *)&v11[0] = 400;
      *((_QWORD *)&v11[0] + 1) = &re::FoundationErrorCategory(void)::instance;
      *(_QWORD *)&v11[1] = v8;
      *((_QWORD *)&v11[2] + 1) = v10;
      *(__int128 *)((char *)&v11[1] + 8) = v9;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, v11);
      if (*(_QWORD *)&v11[1])
      {
        if ((BYTE8(v11[1]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v11[1] + 40))();
        memset(&v11[1], 0, 32);
      }
      result = v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  const re::TypeInfo *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  uint64_t v29;
  uint64_t v30;
  re *v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  NSObject *v35;
  uint64_t v36;
  re::internal *v37;
  uint64_t v38;
  _BYTE v39[32];
  _BYTE v40[32];
  _QWORD *v41[2];
  uint64_t v42;
  _QWORD *v43[2];
  uint64_t v44;
  uint64_t v45[4];
  unint64_t v46;
  uint64_t v47[5];
  _BYTE v48[8];
  uint64_t v49;
  char v50;
  uint64_t *v51;
  _BYTE v52[8];
  uint64_t v53;
  char v54;
  uint64_t *v55;
  uint8_t buf[4];
  uint64_t v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v52);
  re::TypeRegistry::typeInfo((_QWORD *)*a4, *(_QWORD *)(a4[2] + 72), v48);
  if (v48[0])
  {
    if (!v52[0])
    {
      v11 = re::TypeInfo::name((re::TypeInfo *)&v49)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (v53 == v49)
    {
      v18 = *v55;
      v19 = *v51;
      if ((unsigned __int16)*v55 == (unsigned __int16)*v51)
      {
        v21 = WORD1(v18) == WORD1(v19);
        v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        v21 = v21 && v20 == 0;
        if (v21)
          goto LABEL_5;
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v53, (const re::TypeInfo *)&v49, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, a2, &v53, a5);
      goto LABEL_15;
    }
    if (v54 == v50)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, &v53, &v49, a5);
    }
    else
    {
      v22 = re::TypeInfo::name((re::TypeInfo *)&v53)[1];
      re::TypeInfo::name((re::TypeInfo *)&v49);
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v47, *a3, a3[2]);
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v45, *a4, a4[2]);
  if (v46)
  {
    for (i = 0; i < v46; ++i)
    {
      if (*(_BYTE *)(a1 + 64))
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[](v45, i, (uint64_t)v43);
      if (*(_BYTE *)(v44 + 28))
      {
        v29 = *(_QWORD *)(v44 + 16);
        if (strlen((const char *)v29) >= 3 && *(_BYTE *)v29 == 109)
          v29 += 2 * (*(_BYTE *)(v29 + 1) == 95);
        v30 = *(unsigned int *)(v44 + 32);
        v31 = *(re **)(*a4 + 856);
        if (!v31
          || (v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v43),
              (_DWORD)v31 == -1))
        {
          v35 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            v36 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            v57 = v36;
            v58 = 2080;
            v59 = v29;
            _os_log_impl(&dword_224FE9000, v35, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          v37 = *(re::internal **)(a1 + 192);
          re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v57 + 4);
          result = re::internal::translateType(v37, (const re::TypeRegistry *)v41, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint8_t *, uint8_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
        }
        else
        {
          re::TypeMemberCollection::operator[](v47, (int)v31, (uint64_t)v41);
          v32 = a2 + *(unsigned int *)(v42 + 24);
          re::TypeRegistry::typeInfo(v41[0], *(_QWORD *)v42, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
          re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
          if (*(_BYTE *)(a1 + 64)
            || (result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, v32, v40, v39, a5), (result & 1) == 0))
          {
            result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a4);
            if (v33)
            {
              v34 = (_DWORD *)(result + 16);
              while (i != *v34)
              {
                v34 += 6;
                if (!--v33)
                  goto LABEL_35;
              }
              v38 = *((_QWORD *)v34 - 1);
              re::TypeRegistry::typeInfo(v41[0], *(_QWORD *)v42, buf);
              re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
              re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
              result = re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
              if (!*(_BYTE *)(a1 + 64))
                result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v38, v30, v32, v40, v39, a5);
            }
          }
        }
      }
LABEL_35:
      ;
    }
  }
  return result;
}

_QWORD *re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::~SerializerV2(uint64_t a1)
{
  double v2;
  uint64_t v3;
  double v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24ED2E708;
  v2 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)(a1 + 400));
  v3 = *(_QWORD *)(a1 + 360);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 392))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *(_QWORD *)(a1 + 392) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 376) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    ++*(_DWORD *)(a1 + 384);
  }
  v4 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 312));
  v5 = *(_QWORD *)(a1 + 272);
  if (v5)
  {
    if (*(_QWORD *)(a1 + 304))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v5 + 40))(v5, v4);
    *(_QWORD *)(a1 + 304) = 0;
    *(_QWORD *)(a1 + 280) = 0;
    *(_QWORD *)(a1 + 288) = 0;
    *(_QWORD *)(a1 + 272) = 0;
    ++*(_DWORD *)(a1 + 296);
  }
  return re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::~Serializer((_QWORD *)a1);
}

void re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::~SerializerV2(uint64_t a1)
{
  double v2;
  uint64_t v3;
  double v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24ED2E708;
  v2 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)(a1 + 400));
  v3 = *(_QWORD *)(a1 + 360);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 392))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *(_QWORD *)(a1 + 392) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 376) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    ++*(_DWORD *)(a1 + 384);
  }
  v4 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 312));
  v5 = *(_QWORD *)(a1 + 272);
  if (v5)
  {
    if (*(_QWORD *)(a1 + 304))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v5 + 40))(v5, v4);
    *(_QWORD *)(a1 + 304) = 0;
    *(_QWORD *)(a1 + 280) = 0;
    *(_QWORD *)(a1 + 288) = 0;
    *(_QWORD *)(a1 + 272) = 0;
    ++*(_DWORD *)(a1 + 296);
  }
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::~Serializer((_QWORD *)a1);
  JUMPOUT(0x2276933B8);
}

void re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::~Serializer(_QWORD *a1)
{
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(_BYTE *a1, const char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;
  uint64_t v4;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 208)
    && (LODWORD(v4) = **(_QWORD **)(a2 + 16),
        HIDWORD(v4) = -1,
        (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 224, &v4)) != 0))
  {
    return *(uint64_t (**)(_BYTE *, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderOPACK<re::SeekableInputStream>>;
  }
}

uint64_t re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::Encoder(uint64_t result, int a2)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t v4;
  int v5;
  const char *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[4];
  int v11;

  *(_QWORD *)(result + 128) = 0;
  *(_QWORD *)(result + 104) = 0;
  *(_QWORD *)(result + 112) = 0;
  *(_QWORD *)(result + 96) = 0;
  *(_DWORD *)(result + 120) = 0;
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_BYTE *)(result + 40) = 0;
  *(_DWORD *)(result + 136) = a2;
  *(_BYTE *)(result + 140) = 0;
  *(_QWORD *)(result + 152) = 1024;
  if ((v3 & 1) == 0)
  {
    v9 = result;
    v7 = v5;
    result = v9;
    if (v7)
    {
      re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v6, (uint64_t)v10);
      v8 = v11;
      if (!v10[0])
        v8 = 0;
      re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::Encoder(int)::s_maxSerializationDepth = v8;
      result = v9;
    }
  }
  v4 = v2[210];
  if (v4)
    *(_QWORD *)(result + 152) = v4;
  return result;
}

_QWORD *re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::~Serializer(_QWORD *a1)
{
  *a1 = &off_24ED2E770;
  if (a1[26])
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
    a1[26] = 0;
  }
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit(a1 + 28);
  re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::~Encoder((uint64_t)(a1 + 3));
  re::StringID::destroyString((re::StringID *)(a1 + 1));
  return a1;
}

uint64_t re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::~Encoder(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::close((_BYTE *)a1);
  v2 = *(_QWORD *)(a1 + 96);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 128))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    ++*(_DWORD *)(a1 + 120);
  }
  if (*(_BYTE *)(a1 + 40))
  {
    v3 = *(_QWORD *)(a1 + 64);
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 80));
      *(_OWORD *)(a1 + 64) = 0u;
      *(_OWORD *)(a1 + 80) = 0u;
    }
  }
  return a1;
}

_BYTE *re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::close(_BYTE *result)
{
  _QWORD *v1;

  if (*(_QWORD *)result)
  {
    v1 = result;
    if (!result[40])
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState((_anonymous_namespace_ *)result, 0);
    result = (_BYTE *)v1[12];
    if (result)
    {
      if (v1[16])
        result = (_BYTE *)(*(uint64_t (**)(_BYTE *))(*(_QWORD *)result + 40))(result);
      v1[16] = 0;
      v1[13] = 0;
      v1[14] = 0;
      v1[12] = 0;
      ++*((_DWORD *)v1 + 30);
    }
    if (*((int *)v1 + 4) >= 1)
    {
      result = (_BYTE *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 24))(*v1);
      v1[1] = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *v1 = 0;
    v1[3] = 0;
    v1[4] = 0;
  }
  return result;
}

uint64_t re::serializeType<re::EncoderOPACK<re::SeekableInputStream>>(_BYTE *a1, const char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t result;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void **Instance;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _BYTE *v51;
  uint64_t v52;
  uint64_t *v53[4];
  _BYTE v54[24];
  uint64_t v55;
  char v56;
  _BYTE v57[23];
  unsigned __int8 v58[8];
  _BYTE v59[32];

  if (this != (re::TypeInfo *)a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **(_QWORD **)(a6 + 16);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_19;
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, a3))
    {
      goto LABEL_19;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      if (v19)
        v20 = *(_DWORD *)(v19 + 16);
      else
        v20 = -1;
      v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
      if (v21)
        v22 = *(_DWORD *)(v21 + 16);
      else
        v22 = -1;
      if (v20 == v22)
        goto LABEL_19;
      v24 = re::TypeInfo::name(this);
      v25 = re::TypeInfo::name((re::TypeInfo *)a6);
      if (re::StringID::operator==(v24, v25))
      {
        v26 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
        if (v26)
          v27 = *(_DWORD *)(v26 + 16);
        else
          v27 = -1;
        re::TypeInfo::atVersion(this, v27, v58);
        if (v58[0])
        {
          if ((a7 & 1) != 0)
            Instance = 0;
          else
            Instance = re::TypeInfo::createInstance((re::TypeInfo *)v59, *((re::Allocator **)a1 + 6), *((void **)a1 + 25));
          if (a1[64]
            || ((*(void (**)(_BYTE *, const char *, const re::TypeInfo *, void **, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, Instance, v59, a6, a7), a1[64]))
          {
            if (Instance)
              re::TypeInfo::releaseInstance((re::TypeInfo *)v59, Instance, *((re::Allocator **)a1 + 6), *((void **)a1 + 25));
          }
          else
          {
            if ((a7 & 1) != 0)
              return 1;
            re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v59);
            re::internal::upgradeObject(Instance, v53, a4, (uint64_t **)this, *((re::Allocator **)a1 + 6), *((void **)a1 + 25), v54);
            if (v54[0])
              return 1;
            if ((v56 & 1) != 0)
              LOBYTE(v51) = v57[7];
            else
              v51 = v57;
            re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "%s", v46, v47, v48, v49, v50, (char)v51);
            if (!v54[0] && v55 && (v56 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v55 + 40))();
          }
        }
        else
        {
          v35 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
          re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Unknown serialized type \"%s\" version %u. No matching runtime type found.", v41, v42, v43, v44, v45, v35);
        }
      }
      else
      {
        v33 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
        re::TypeInfo::name(this);
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Type name changed: Serialized type \"%s\" version %u, runtime type \"%s\" version %u.", v36, v37, v38, v39, v40, v33);
      }
    }
    else
    {
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>((uint64_t)a1, a2, this, (re::TypeInfo *)a6);
    }
    return 0;
  }
LABEL_19:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      result = re::serializeBasic<re::EncoderOPACK<re::SeekableInputStream>>((uint64_t)a1, a2, a3, (__int16 *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 2:
      result = re::serializeEnum<re::EncoderOPACK<re::SeekableInputStream>>((uint64_t)a1, a2, a3, a4, (uint64_t)this, a6, a7);
      break;
    case 3:
      result = re::serializeOptional<re::EncoderOPACK<re::SeekableInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 4:
      result = re::serializeArray<re::EncoderOPACK<re::SeekableInputStream>>(a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 5:
      result = re::serializeList<re::EncoderOPACK<re::SeekableInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 6:
      result = re::serializeDictionary<re::EncoderOPACK<re::SeekableInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 7:
      result = re::serializeUnion<re::EncoderOPACK<re::SeekableInputStream>>((uint64_t)a1, a2, a3, (char *)a4, this, (re::TypeInfo *)a6, a7);
      break;
    case 8:
      result = re::serializeObject<re::EncoderOPACK<re::SeekableInputStream>>((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)a4, this, a6, a7);
      break;
    case 9:
      v52 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Pointer type (\"%s\") needs to be handled explicitly by the serializer.", v28, v29, v30, v31, v32, v52);
      return 0;
    default:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Invalid type category. Value = %d", (uint64_t)a4, (uint64_t)this, a6, a7, a8, *((_BYTE *)this + 12));
      return 0;
  }
  return result;
}

uint64_t re::serializeBasic<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  int v10;
  uint64_t *v14;
  unint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v10 = (int)a3;
  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_19:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, this, a6);
      return 0;
    }
    v18 = **((_QWORD **)this + 2);
    v19 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v18 != (unsigned __int16)v19)
      goto LABEL_19;
    v21 = WORD1(v18) == WORD1(v19);
    v20 = (v19 ^ v18) & 0xFFFFFF00000000;
    v21 = v21 && v20 == 0;
    if (!v21)
      goto LABEL_19;
  }
LABEL_4:
  v14 = re::TypeInfo::name(this);
  v15 = (unint64_t)*v14 >> 1;
  if (v15 > 0xCA3DEFB5)
  {
    if ((unint64_t)*v14 >> 1 > 0x18E6A9A092)
    {
      if ((unint64_t)*v14 >> 1 <= 0x303EE8780EDLL)
      {
        if (v15 != 0x18E6A9A093)
        {
          if (v15 == 0x303EE86A734)
            return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v10, a4, a7);
          goto LABEL_47;
        }
        return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v10, (char *)a4, a7);
      }
      if (v15 == 0x303EE8780EELL)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v10, (int *)a4, a7);
      if (v15 != 0x303EE88E58DLL)
        goto LABEL_47;
    }
    else
    {
      if ((unint64_t)*v14 >> 1 > 0x16749DFF02)
      {
        if (v15 == 0x16749DFF03)
          return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v10, (int *)a4, a7);
        v22 = 0x16749F63A2;
        goto LABEL_34;
      }
      if (v15 != 3393056694)
      {
        v17 = 0x16749D2549;
        goto LABEL_24;
      }
    }
    return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v10, (char *)a4, a7);
  }
  if ((unint64_t)*v14 >> 1 <= 0x5D0225B)
  {
    if ((unint64_t)*v14 >> 1 <= 0x2E9355)
    {
      if (v15 != 104431)
      {
        if (v15 == 3029738)
          return re::EncoderOPACK<re::SeekableInputStream>::serializeBool(a1 + 24, a2, v10, a4, a7);
        goto LABEL_47;
      }
      return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v10, (int *)a4, a7);
    }
    if (v15 != 3052374)
    {
      v22 = 3327612;
LABEL_34:
      if (v15 == v22)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v10, a4, a7);
LABEL_47:
      v23 = re::TypeInfo::name(this);
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Unsupported basic type \"%s\".", v24, v25, v26, v27, v28, v23[1]);
      return 0;
    }
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v10, (char *)a4, a7);
  }
  if ((unint64_t)*v14 >> 1 > 0xB0F77BD0)
  {
    if (v15 != 2969009105)
    {
      if (v15 != 3111160798)
        goto LABEL_47;
      return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v10, (char *)a4, a7);
    }
    return re::EncoderOPACK<re::SeekableInputStream>::serializeDouble(a1 + 24, a2, v10, (char *)a4, a7);
  }
  else
  {
    if (v15 != 97526364)
    {
      v17 = 109413500;
LABEL_24:
      if (v15 == v17)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<short>(a1 + 24, a2, v10, a4, a7);
      goto LABEL_47;
    }
    return re::EncoderOPACK<re::SeekableInputStream>::serializeFloat(a1 + 24, a2, v10, (char *)a4, a7);
  }
}

uint64_t re::serializeEnum<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  uint64_t *v19;

  if (a5 == a6)
    return re::internal::serializeEnumAsBinary<re::EncoderOPACK<re::SeekableInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **(_QWORD **)(a5 + 16);
    v15 = **(_QWORD **)(a6 + 16);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::internal::serializeEnumAsBinary<re::EncoderOPACK<re::SeekableInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
    }
  }
  else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
  {
    return re::internal::serializeEnumAsBinary<re::EncoderOPACK<re::SeekableInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
  }
  if (*(unsigned __int8 *)(a5 + 12) == *(unsigned __int8 *)(a6 + 12))
  {
    v18 = re::TypeInfo::name((re::TypeInfo *)a5);
    v19 = re::TypeInfo::name((re::TypeInfo *)a6);
    if (re::StringID::operator==(v18, v19))
      return re::internal::serializeEnumAsBinary<re::EncoderOPACK<re::SeekableInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
  return 0;
}

BOOL re::serializeOptional<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  re::internal *v18;
  _anonymous_namespace_ *v19;
  double v20;
  void **Instance;
  uint64_t v23;
  BOOL v24;
  _BYTE v25[32];
  _BYTE v26[32];
  _BYTE v27[8];
  uint64_t v28;
  uint64_t v29;

  v11 = (int)a3;
  if (a5 == a6)
    goto LABEL_11;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_11;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v25[0] = 0;
    re::EncoderOPACK<re::SeekableInputStream>::beginOptional(a1 + 24, a2, v11, v25, 0);
    if (v25[0])
    {
      v18 = *(re::internal **)(a1 + 208);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), v27);
      re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
      re::internal::translateType(v18, (const re::TypeRegistry *)v26, (uint64_t)v27);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, 0, v27, v27, 1);
    }
    v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)&v28);
    re::TypeInfo::TypeInfo((uint64_t)v27, (uint64_t)a5);
    v24 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4) != 0;
    v20 = re::EncoderOPACK<re::SeekableInputStream>::beginOptional(a1 + 24, a2, v11, &v24, 0);
    if (v24)
    {
      Instance = re::TypeInfo::createInstance((re::TypeInfo *)v26, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
      (*(void (**)(uint64_t, void **))(v29 + 88))(a4, Instance);
      re::TypeInfo::releaseInstance((re::TypeInfo *)v26, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
    }
    else
    {
      (*(void (**)(uint64_t, _QWORD, double))(v29 + 88))(a4, 0, v20);
    }
    if (v24)
    {
      v23 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, v23, v26, v25, 0);
    }
    v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderOPACK<re::SeekableInputStream>::endOptional(v19);
  return *(_BYTE *)(a1 + 64) == 0;
}

uint64_t re::serializeArray<re::EncoderOPACK<re::SeekableInputStream>>(_BYTE *a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  _QWORD *v18;
  _QWORD *v19;
  int v20;
  re::internal *v21;
  uint64_t v22;
  void (*v23)(_BYTE *, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  _QWORD *v24;
  int v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(_BYTE *, _QWORD, _QWORD, uint64_t, _BYTE *, uint64_t *, _QWORD);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t result;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  _anonymous_namespace_ *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  _anonymous_namespace_ *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const re::TypeInfo *v52;
  BOOL v53;
  char v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  BOOL v61;
  char v62;
  unint64_t v63;
  _QWORD v64[2];
  unint64_t v65;
  const re::TypeInfo *v66;
  _QWORD v67[2];
  uint64_t v68[4];
  _BYTE v69[12];
  char v70;
  uint64_t v71;
  unint64_t v72;
  _BYTE v73[32];

  v11 = (int)a3;
  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((_BYTE *)a6 + 12) != 4)
    goto LABEL_71;
  v18 = (_QWORD *)*((_QWORD *)a5 + 2);
  v19 = (_QWORD *)*((_QWORD *)a6 + 2);
  v20 = *((_DWORD *)v19 + 21) & 0xFFFFFF;
  if ((*((_DWORD *)v18 + 21) & 0xFFFFFF) != 0)
  {
    if (v20)
      goto LABEL_13;
LABEL_71:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>((uint64_t)a1, a2, a5, a6);
    return 0;
  }
  if (v20 || *((_DWORD *)v18 + 22) != *((_DWORD *)v19 + 22))
    goto LABEL_71;
LABEL_13:
  if (a7)
  {
    v21 = (re::internal *)*((_QWORD *)a1 + 26);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v72);
    re::TypeInfo::TypeInfo((uint64_t)v68, (uint64_t)v73);
    re::internal::translateType(v21, (const re::TypeRegistry *)v68, (uint64_t)v69);
    v22 = (*(uint64_t (**)(_BYTE *, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v69);
    if (v22)
    {
      v23 = (void (*)(_BYTE *, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v22;
      v24 = (_QWORD *)*((_QWORD *)a6 + 2);
      v25 = *((_DWORD *)v24 + 21) & 0xFFFFFF;
      if (v25)
        v26 = 0;
      else
        v26 = *((int *)v24 + 22);
      v72 = v26;
      if (v70 == 1)
      {
        v68[0] = v26 * *(unsigned int *)(v71 + 8);
        v58 = re::EncoderOPACK<re::SeekableInputStream>::beginBLOB((uint64_t)(a1 + 24), a2, v11, v68, 0);
        result = 0;
        if (!v58)
          return result;
        if (v68[0])
          re::EncoderOPACK<re::SeekableInputStream>::serializeBLOB((uint64_t)(a1 + 24), 0, 1);
        v39 = (_anonymous_namespace_ *)(a1 + 24);
        goto LABEL_49;
      }
      if (v25)
        v59 = 8;
      else
        v59 = 4;
      v48 = (_anonymous_namespace_ *)(a1 + 24);
      result = re::EncoderOPACK<re::SeekableInputStream>::beginArray((uint64_t)(a1 + 24), a2, v11, (char *)&v72, v59);
      if ((_DWORD)result)
      {
        v60 = v72;
        if (v25)
          v61 = v72 == 0;
        else
          v61 = 1;
        v62 = v61;
        if (!v61)
        {
          v67[0] = 0;
          v67[1] = 0xFFFFFFFFLL;
          (*(void (**)(_BYTE *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 16))(a1, 0, v67);
          v60 = v72;
        }
        if (v60)
        {
          v63 = 0;
          do
          {
            v23(a1, 0, 0, 0, v69, v69, 1);
            ++v63;
          }
          while (v63 < v72);
        }
        if ((v62 & 1) != 0)
          goto LABEL_67;
        goto LABEL_66;
      }
      return result;
    }
    goto LABEL_24;
  }
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v72);
  re::TypeInfo::TypeInfo((uint64_t)v69, (uint64_t)v73);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v72);
  re::TypeInfo::TypeInfo((uint64_t)v68, (uint64_t)v73);
  re::TypeInfo::TypeInfo((uint64_t)&v72, (uint64_t)a5);
  v27 = (*(uint64_t (**)(_BYTE *, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v69);
  if (!v27)
  {
LABEL_24:
    v40 = re::TypeInfo::name((re::TypeInfo *)v69);
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v41, v42, v43, v44, v45, v40[1]);
    return 0;
  }
  v28 = (void (*)(_BYTE *, _QWORD, _QWORD, uint64_t, _BYTE *, uint64_t *, _QWORD))v27;
  v29 = re::ArrayAccessor::size((re::ArrayAccessor *)&v72, a4);
  v30 = v29;
  v66 = (const re::TypeInfo *)v29;
  if (v70 == 1)
  {
    v65 = v29 * *(unsigned int *)(v71 + 8);
    v34 = re::EncoderOPACK<re::SeekableInputStream>::beginBLOB((uint64_t)(a1 + 24), a2, v11, (uint64_t *)&v65, 0);
    result = 0;
    if (v34)
    {
      v36 = v65;
      v37 = *(unsigned int *)(v71 + 8);
      if ((_DWORD)result)
      {
        if (v36 >= v37)
        {
          v38 = (char *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v72, a4, 0);
          re::EncoderOPACK<re::SeekableInputStream>::serializeBLOB((uint64_t)(a1 + 24), v38, 0);
        }
        v39 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_49:
        re::EncoderOPACK<re::SeekableInputStream>::endBLOB(v39);
        return a1[64] == 0;
      }
    }
  }
  else
  {
    v46 = *(_DWORD *)(*((_QWORD *)a5 + 2) + 84) & 0xFFFFFF;
    if (v46)
      v47 = 8;
    else
      v47 = 4;
    v48 = (_anonymous_namespace_ *)(a1 + 24);
    result = re::EncoderOPACK<re::SeekableInputStream>::beginArray((uint64_t)(a1 + 24), a2, v11, (char *)&v66, v47);
    if ((_DWORD)result)
    {
      if ((_DWORD)result)
      {
        v52 = v66;
        if (v46)
          v53 = v66 == 0;
        else
          v53 = 1;
        v54 = v53;
        if (!v53)
        {
          v55 = *(_QWORD *)a4;
          v64[0] = 0;
          v64[1] = 0xFFFFFFFFLL;
          (*(void (**)(_BYTE *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 16))(a1, v55, v64);
          v52 = v66;
        }
        if (v52)
        {
          v56 = 0;
          do
          {
            v57 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v72, a4, v56);
            v28(a1, 0, 0, v57, v69, v68, 0);
            ++v56;
          }
          while (v56 < (unint64_t)v66);
        }
        if ((v54 & 1) != 0)
          goto LABEL_67;
LABEL_66:
        (*(void (**)(_BYTE *))(*(_QWORD *)a1 + 24))(a1);
LABEL_67:
        re::EncoderOPACK<re::SeekableInputStream>::endArray(v48);
        return a1[64] == 0;
      }
    }
  }
  return result;
}

uint64_t re::serializeList<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  re::internal *v18;
  uint64_t v19;
  int v20;
  uint64_t result;
  _anonymous_namespace_ *v22;
  uint64_t v23;
  void (*v24)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, uint64_t *, _QWORD);
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  unint64_t j;
  uint64_t v43;
  _anonymous_namespace_ *v44;
  void (*v45)(uint64_t, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  int v46;
  unint64_t i;
  uint64_t (*v48)(uint64_t, _QWORD);
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59[4];
  unint64_t v60;
  uint64_t v61[4];
  _BYTE v62[12];
  char v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;

  v11 = (int)a3;
  if (a5 == a6)
    goto LABEL_11;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_11;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v18 = *(re::internal **)(a1 + 208);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v65);
    re::TypeInfo::TypeInfo((uint64_t)v61, (uint64_t)&v66);
    re::internal::translateType(v18, (const re::TypeRegistry *)v61, (uint64_t)v62);
    v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v62);
    if (v19)
    {
      v65 = 0;
      if (v63 == 1)
      {
        v61[0] = 0;
        v20 = re::EncoderOPACK<re::SeekableInputStream>::beginBLOB(a1 + 24, a2, v11, v61, 0);
        result = 0;
        if (!v20)
          return result;
        if (v61[0])
          re::EncoderOPACK<re::SeekableInputStream>::serializeBLOB(a1 + 24, 0, 1);
        v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_18:
        re::EncoderOPACK<re::SeekableInputStream>::endBLOB(v22);
        return *(_BYTE *)(a1 + 64) == 0;
      }
      v45 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v19;
      v46 = re::EncoderOPACK<re::SeekableInputStream>::beginArray(a1 + 24, a2, v11, (char *)&v65, 0);
      result = 0;
      if (!v46)
        return result;
      if (v65)
      {
        for (i = 0; i < v65; ++i)
          v45(a1, 0, 0, 0, v62, v62, 1);
      }
      v44 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_45:
      re::EncoderOPACK<re::SeekableInputStream>::endArray(v44);
      return *(_BYTE *)(a1 + 64) == 0;
    }
    goto LABEL_29;
  }
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v65);
  re::TypeInfo::TypeInfo((uint64_t)v62, (uint64_t)&v66);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v65);
  re::TypeInfo::TypeInfo((uint64_t)v61, (uint64_t)&v66);
  re::TypeInfo::TypeInfo((uint64_t)&v65, (uint64_t)a5);
  v23 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v62);
  if (!v23)
  {
LABEL_29:
    v57 = re::TypeInfo::name((re::TypeInfo *)v62)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v36, v37, v38, v39, v40, v57);
    return 0;
  }
  v24 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, uint64_t *, _QWORD))v23;
  v25 = (*(uint64_t (**)(uint64_t))(v67 + 80))(a4);
  v26 = v25;
  v60 = v25;
  if (*((_BYTE *)a5 + 12) == 5 && (*(_BYTE *)(*((_QWORD *)a5 + 2) + 48) & 8) != 0 && v63 == 1)
  {
    v59[0] = v25 * *(unsigned int *)(v64 + 8);
    v31 = re::EncoderOPACK<re::SeekableInputStream>::beginBLOB(a1 + 24, a2, v11, v59, 0);
    result = 0;
    if (!v31)
      return result;
    v32 = v59[0];
    v33 = *(unsigned int *)(v64 + 8);
    v34 = v59[0] / v33;
    if (v59[0] / v33 * v33 == v59[0])
    {
      if (!(_DWORD)result)
        return result;
      if (v32 >= v33)
      {
        v35 = (char *)(*(uint64_t (**)(uint64_t, _QWORD))(v67 + 96))(a4, 0);
        re::EncoderOPACK<re::SeekableInputStream>::serializeBLOB(a1 + 24, v35, 0);
      }
      v22 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_18;
    }
    re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::setError((_anonymous_namespace_ *)(a1 + 24), a2, "BLOB size mismatch: BLOB is %zu bytes, but list only accomodates %zu bytes (%zu elements * %zu bytes/element)", v27, v34, v28, v29, v30, v59[0]);
    return 0;
  }
  v41 = re::EncoderOPACK<re::SeekableInputStream>::beginArray(a1 + 24, a2, v11, (char *)&v60, 0);
  result = 0;
  if (v41)
  {
    if ((_DWORD)result)
    {
      if (*(_QWORD *)(v67 + 96))
      {
        if (v60)
        {
          for (j = 0; j < v60; ++j)
          {
            v43 = (*(uint64_t (**)(uint64_t, unint64_t))(v67 + 96))(a4, j);
            v24(a1, 0, 0, v43, v62, v61, 0);
          }
        }
      }
      else
      {
        v48 = *(uint64_t (**)(uint64_t, _QWORD))(v67 + 104);
        if (!v48 || !*(_QWORD *)(v67 + 112) || !*(_QWORD *)(v67 + 120))
        {
          re::TypeInfo::TypeInfo((uint64_t)v59, (uint64_t)&v65);
          v58 = re::TypeInfo::name((re::TypeInfo *)v59)[1];
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "List type \"%s\" does not provide an indexer or iterator.", v52, v53, v54, v55, v56, v58);
          return 0;
        }
        v49 = v48(a4, *(_QWORD *)(a1 + 56));
        v50 = (*(uint64_t (**)(void))(v67 + 112))();
        if (v50)
        {
          v51 = v50;
          do
          {
            v24(a1, 0, 0, v51, v62, v61, 0);
            v51 = (*(uint64_t (**)(uint64_t))(v67 + 112))(v49);
          }
          while (v51);
        }
        (*(void (**)(uint64_t, _QWORD))(v67 + 120))(v49, *(_QWORD *)(a1 + 56));
      }
      v44 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_45;
    }
  }
  return result;
}

BOOL re::serializeDictionary<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  re::internal *v18;
  re::internal *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t, double);
  uint64_t v22;
  void (*v23)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  _anonymous_namespace_ *v24;
  int v25;
  _BOOL8 result;
  unint64_t i;
  double v28;
  uint64_t v29;
  void (*v30)(uint64_t, const char *, _QWORD, void **, _BYTE *, _BYTE *, _QWORD, double);
  uint64_t v31;
  void (*v32)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  int v33;
  uint64_t v34;
  void (*v35)(uint64_t, unint64_t *, uint64_t);
  void **Instance;
  uint64_t v37;
  double v38;
  re::Allocator *v39;
  uint64_t v40;
  re::TypeInfo *v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  _BYTE v49[16];
  uint64_t v50;
  _BYTE v51[32];
  _BYTE v52[32];
  _BYTE v53[32];
  _BYTE v54[32];
  unint64_t v55;
  _BYTE v56[32];

  v11 = (int)a3;
  if (a5 == a6)
    goto LABEL_11;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_11;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v51, (uint64_t)v56);
    re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)a5);
    v29 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v54);
    if (v29)
    {
      v30 = (void (*)(uint64_t, const char *, _QWORD, void **, _BYTE *, _BYTE *, _QWORD, double))v29;
      v31 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
      if (v31)
      {
        v32 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v31;
        v48 = (*(uint64_t (**)(uint64_t))(v50 + 88))(a4);
        v24 = (_anonymous_namespace_ *)(a1 + 24);
        v33 = re::EncoderOPACK<re::SeekableInputStream>::beginDictionary(a1 + 24, a2, v11, (char *)&v48, 0);
        result = 0;
        if (!v33)
          return result;
        v34 = *(_QWORD *)(a1 + 48);
        v35 = *(void (**)(uint64_t, unint64_t *, uint64_t))(v50 + 96);
        re::TypeInfo::TypeInfo((uint64_t)&v55, (uint64_t)v49);
        v35(a4, &v55, v34);
        if (v48)
        {
          Instance = re::TypeInfo::createInstance((re::TypeInfo *)v54, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
          if (v48)
          {
            v37 = 0;
            while (1)
            {
              v38 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
              v30(a1, "key", 0, Instance, v54, v52, 0, v38);
              v39 = *(re::Allocator **)(a1 + 48);
              if (*(_BYTE *)(a1 + 64))
                break;
              v40 = (*(uint64_t (**)(uint64_t, _BYTE *, re::Allocator *, void **))(v50 + 104))(a4, v49, v39, Instance);
              v32(a1, "value", 0, v40, v53, v51, 0);
              re::EncoderOPACK<re::SeekableInputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
              if (++v37 >= v48)
                goto LABEL_27;
            }
            re::TypeInfo::releaseInstance((re::TypeInfo *)v54, Instance, v39, *(void **)(a1 + 200));
            return 0;
          }
LABEL_27:
          re::TypeInfo::releaseInstance((re::TypeInfo *)v54, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
        }
LABEL_28:
        re::EncoderOPACK<re::SeekableInputStream>::endDictionary(v24);
        return *(_BYTE *)(a1 + 64) == 0;
      }
      goto LABEL_31;
    }
LABEL_29:
    v41 = (re::TypeInfo *)v54;
LABEL_32:
    v42 = re::TypeInfo::name(v41);
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v43, v44, v45, v46, v47, v42[1]);
    return 0;
  }
  v18 = *(re::internal **)(a1 + 208);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
  re::internal::translateType(v18, (const re::TypeRegistry *)v53, (uint64_t)v54);
  v19 = *(re::internal **)(a1 + 208);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
  re::internal::translateType(v19, (const re::TypeRegistry *)v52, (uint64_t)v53);
  v20 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v54);
  if (!v20)
    goto LABEL_29;
  v21 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t, double))v20;
  v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
  if (!v22)
  {
LABEL_31:
    v41 = (re::TypeInfo *)v53;
    goto LABEL_32;
  }
  v23 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v22;
  v55 = 0;
  v24 = (_anonymous_namespace_ *)(a1 + 24);
  v25 = re::EncoderOPACK<re::SeekableInputStream>::beginDictionary(a1 + 24, a2, v11, (char *)&v55, 0);
  result = 0;
  if (v25)
  {
    if (v55)
    {
      for (i = 0; i < v55; ++i)
      {
        v28 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 1);
        v21(a1, "key", 0, 0, v54, v54, 1, v28);
        v23(a1, "value", 0, 0, v53, v53, 1);
        re::EncoderOPACK<re::SeekableInputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    goto LABEL_28;
  }
  return result;
}

uint64_t re::serializeUnion<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  int v11;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  unint64_t v19[4];
  unint64_t Tag;
  _BYTE v21[32];

  v11 = (int)a3;
  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        goto LABEL_4;
    }
LABEL_19:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_19;
LABEL_4:
  result = re::EncoderOPACK<re::SeekableInputStream>::beginObject(a1 + 24, a2, v11, 16);
  if (a7)
  {
    if (!(_DWORD)result)
      return result;
    v19[0] = 0;
    re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, "tag", 0, (char *)v19, 0);
    if (v19[0] < *(unsigned int *)(*((_QWORD *)a6 + 2) + 88))
    {
      re::TypeInfo::unionMember(a6, v19[0], (uint64_t)v21);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, "value", 0, 0, v21, v21, 1);
    }
  }
  else
  {
    if (!(_DWORD)result)
      return result;
    re::TypeInfo::TypeInfo((uint64_t)v21, (uint64_t)a5);
    Tag = re::UnionAccessor::readTag((re::UnionAccessor *)v21, a4);
    re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, "tag", 0, (char *)&Tag, 0);
    re::UnionAccessor::reset((re::UnionAccessor *)v21, a4, (const re::TypeInfo *)Tag, *(re::Allocator **)(a1 + 48));
    if (Tag < *(unsigned int *)(*((_QWORD *)a5 + 2) + 88))
    {
      re::TypeInfo::unionMember(a5, Tag, (uint64_t)v19);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, unint64_t *, unint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, "value", 0, a4, v19, v19, 0);
    }
  }
  re::EncoderOPACK<re::SeekableInputStream>::endObject(a1 + 24);
  return *(_BYTE *)(a1 + 64) == 0;
}

uint64_t re::serializeObject<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  uint64_t *v14;
  const char *v15;
  const re::TypeInfo *v16;
  int v17;
  uint64_t result;
  re::TypeRegistry *v19;
  re *v20;
  const re::TypeInfo *v21;
  uint64_t v22;
  const char *v23;
  const re::TypeInfo *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[2];
  _BYTE v36[8];
  uint64_t v37;
  _BYTE v38[32];

  if (!(_DWORD)a7)
  {
LABEL_6:
    if ((*(_BYTE *)(*((_QWORD *)this + 2) + 48) & 4) != 0)
      return re::internal::serializeObjectWithOneMember<re::EncoderBinary<re::SeekableInputStream>>((_BYTE *)a1, a2, a3, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    v17 = re::EncoderOPACK<re::SeekableInputStream>::beginObject(a1 + 24, a2, a3, 0);
    result = 0;
    if (!v17)
      return result;
    if (this == (re::TypeInfo *)a6)
      goto LABEL_11;
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v25 = **((_QWORD **)this + 2);
      v26 = **(_QWORD **)(a6 + 16);
      if ((unsigned __int16)v25 == (unsigned __int16)v26)
      {
        v28 = WORD1(v25) == WORD1(v26);
        v27 = (v26 ^ v25) & 0xFFFFFF00000000;
        v28 = v28 && v27 == 0;
        if (v28)
          goto LABEL_11;
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v16))
    {
LABEL_11:
      re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::SeekableInputStream>>((_BYTE *)a1, a4, (uint64_t *)this, a7);
LABEL_24:
      re::EncoderOPACK<re::SeekableInputStream>::endObject(a1 + 24);
      return *(_BYTE *)(a1 + 64) == 0;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::SeekableInputStream>>(a1, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    }
    else
    {
      v29 = re::TypeInfo::name(this)[1];
      re::TypeInfo::name((re::TypeInfo *)a6);
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v30, v31, v32, v33, v34, v29);
    }
    goto LABEL_24;
  }
  if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
  {
    v19 = *(re::TypeRegistry **)(a1 + 208);
    v35[0] = 0x2686EB529B3EE220;
    v35[1] = "DynamicString";
    re::TypeRegistry::typeInfo(v19, (const re::StringID *)v35, v36);
    re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v37);
    re::StringID::destroyString((re::StringID *)v35);
    v20 = (re *)v38;
    v21 = (const re::TypeInfo *)v38;
    v22 = a1;
    v23 = a2;
    v24 = (const re::TypeInfo *)a3;
  }
  else
  {
    v14 = re::TypeInfo::name(this);
    if ((unint64_t)*v14 >> 1 != 0x134375A94D9F7110)
      goto LABEL_6;
    v15 = (const char *)v14[1];
    if (v15 != "DynamicString")
    {
      if (strcmp(v15, "DynamicString"))
        goto LABEL_6;
    }
    v22 = a1;
    v23 = a2;
    v24 = (const re::TypeInfo *)a3;
    v20 = this;
    v21 = this;
  }
  re::serializeDynamicString<re::EncoderOPACK<re::SeekableInputStream>>(v22, v23, v24, 0, v20, v21, 1);
  return *(_BYTE *)(a1 + 64) == 0;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeBool(uint64_t a1, const char *a2, int a3, _BYTE *a4, char a5)
{
  uint64_t result;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  const char *v16;
  unsigned __int8 __dst;
  uint64_t v18;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v18 = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if ((_DWORD)result)
  {
    __dst = 0;
    if (*(_BYTE *)(a1 + 40))
    {
LABEL_5:
      for (i = v18; i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
      result = 1;
      if ((a5 & 2) == 0)
      {
        v11 = *(_QWORD *)(a1 + 128);
        v12 = *(_QWORD *)(a1 + 112) - 1;
        if (*(_BYTE *)(v11 + 48 * v12) != 2)
          ++*(_QWORD *)(v11 + 48 * v12 + 32);
      }
      return result;
    }
    v13 = *(_QWORD *)(a1 + 168);
    if (v13)
    {
      v14 = v13 - 1;
      v15 = *(unsigned __int8 *)(a1 + v14 + 160);
      __dst = *(_BYTE *)(a1 + v14 + 160);
      *(_QWORD *)(a1 + 168) = v14;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Boolean");
        goto LABEL_5;
      }
      v15 = __dst;
    }
    if (v15 == 2)
    {
      if ((a5 & 1) == 0)
        *a4 = 0;
    }
    else
    {
      if (v15 != 1)
      {
        v16 = re::OPACK::toString(v15);
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, (uint64_t)"Boolean", (uint64_t)v16);
        return 0;
      }
      if ((a5 & 1) == 0)
        *a4 = 1;
    }
    goto LABEL_5;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeFloat(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  uint64_t result;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  int64_t v18;
  uint64_t v19;
  int64_t v20;
  size_t v21;
  const char *v22;
  char *v23;
  unsigned __int8 __dst;
  uint64_t v25;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v25 = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v25, 0);
  if ((_DWORD)result)
  {
    __dst = 0;
    if (*(_BYTE *)(a1 + 40))
      goto LABEL_5;
    v13 = *(_QWORD *)(a1 + 168);
    if (v13)
    {
      v14 = v13 - 1;
      v15 = *(unsigned __int8 *)(a1 + v14 + 160);
      __dst = *(_BYTE *)(a1 + v14 + 160);
      *(_QWORD *)(a1 + 168) = v14;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL))goto LABEL_31;
      v15 = __dst;
    }
    if (v15 != 53)
    {
      v22 = re::OPACK::toString(v15);
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, (uint64_t)"Float", (uint64_t)v22);
      return 0;
    }
    if (*(_BYTE *)(a1 + 40))
      goto LABEL_5;
    v16 = *(_QWORD *)(a1 + 168);
    if (v16)
    {
      v17 = 4;
      if (v16 < 4)
        v17 = *(_QWORD *)(a1 + 168);
      v18 = v16 - v17;
      if ((uint64_t)(v16 - 1) >= (uint64_t)(v16 - v17))
      {
        v19 = *(_QWORD *)(a1 + 168);
        do
        {
          *a4++ = *(_BYTE *)(a1 + 159 + v19);
          v20 = v19 - 2;
          --v19;
        }
        while (v20 >= v18);
      }
      *(_QWORD *)(a1 + 168) = v18;
      if (v16 > 3)
        goto LABEL_5;
      v21 = 4 - v17;
    }
    else
    {
      v21 = 4;
    }
    if ((a5 & 1) != 0)
      v23 = 0;
    else
      v23 = a4;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, v23, v21) & 1) != 0)
    {
LABEL_5:
      for (i = v25; i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
      result = 1;
      if ((a5 & 2) == 0)
      {
        v11 = *(_QWORD *)(a1 + 128);
        v12 = *(_QWORD *)(a1 + 112) - 1;
        if (*(_BYTE *)(v11 + 48 * v12) != 2)
          ++*(_QWORD *)(v11 + 48 * v12 + 32);
      }
      return result;
    }
LABEL_31:
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Float");
    goto LABEL_5;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeDouble(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  uint64_t result;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  int64_t v18;
  uint64_t v19;
  int64_t v20;
  size_t v21;
  const char *v22;
  char *v23;
  unsigned __int8 __dst;
  uint64_t v25;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v25 = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v25, 0);
  if ((_DWORD)result)
  {
    __dst = 0;
    if (*(_BYTE *)(a1 + 40))
      goto LABEL_5;
    v13 = *(_QWORD *)(a1 + 168);
    if (v13)
    {
      v14 = v13 - 1;
      v15 = *(unsigned __int8 *)(a1 + v14 + 160);
      __dst = *(_BYTE *)(a1 + v14 + 160);
      *(_QWORD *)(a1 + 168) = v14;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL))goto LABEL_31;
      v15 = __dst;
    }
    if (v15 != 54)
    {
      v22 = re::OPACK::toString(v15);
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, (uint64_t)"Double", (uint64_t)v22);
      return 0;
    }
    if (*(_BYTE *)(a1 + 40))
      goto LABEL_5;
    v16 = *(_QWORD *)(a1 + 168);
    if (v16)
    {
      v17 = 8;
      if (v16 < 8)
        v17 = *(_QWORD *)(a1 + 168);
      v18 = v16 - v17;
      if ((uint64_t)(v16 - 1) >= (uint64_t)(v16 - v17))
      {
        v19 = *(_QWORD *)(a1 + 168);
        do
        {
          *a4++ = *(_BYTE *)(a1 + 159 + v19);
          v20 = v19 - 2;
          --v19;
        }
        while (v20 >= v18);
      }
      *(_QWORD *)(a1 + 168) = v18;
      if (v16 > 7)
        goto LABEL_5;
      v21 = 8 - v17;
    }
    else
    {
      v21 = 8;
    }
    if ((a5 & 1) != 0)
      v23 = 0;
    else
      v23 = a4;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, v23, v21) & 1) != 0)
    {
LABEL_5:
      for (i = v25; i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
      result = 1;
      if ((a5 & 2) == 0)
      {
        v11 = *(_QWORD *)(a1 + 128);
        v12 = *(_QWORD *)(a1 + 112) - 1;
        if (*(_BYTE *)(v11 + 48 * v12) != 2)
          ++*(_QWORD *)(v11 + 48 * v12 + 32);
      }
      return result;
    }
LABEL_31:
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Double");
    goto LABEL_5;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::advance(uint64_t a1, const char *a2, int a3, _QWORD *a4, _DWORD *a5)
{
  int v9;

  v9 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 48);
  if (v9 == 2)
  {
    if (!re::EncoderOPACK<re::SeekableInputStream>::advance_KeyedContainer(a1, a2, a3))
      return 0;
  }
  else if (v9 == 1 && !re::EncoderOPACK<re::SeekableInputStream>::advance_UnkeyedContainer(a1, a2))
  {
    return 0;
  }
  return re::EncoderOPACK<re::SeekableInputStream>::evaluateConditional(a1, a2, a5, a4);
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readTag(uint64_t a1, const char *a2, char *__dst, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    v6 = *(_QWORD *)(a1 + 168);
    if (v6)
    {
      v7 = v6 - 1;
      *__dst = *(_BYTE *)(a1 + v7 + 160);
      *(_QWORD *)(a1 + 168) = v7;
      return 1;
    }
    v4 = 1;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, __dst, 1uLL) & 1) != 0)return v4;
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a4);
  }
  return 0;
}

BOOL re::EncoderOPACK<re::SeekableInputStream>::advance_UnkeyedContainer(uint64_t a1, const char *a2)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  unsigned __int8 __dst;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v4 = *(_QWORD *)(a1 + 168);
  if (v4)
  {
    v5 = v4 - 1;
    v6 = *(unsigned __int8 *)(a1 + v4 - 1 + 160);
    *(_QWORD *)(a1 + 168) = v5;
  }
  else
  {
    __dst = 0;
    if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL))
    {
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Array element or terminator");
      return 0;
    }
    v6 = __dst;
    v5 = *(_QWORD *)(a1 + 168);
  }
  if (v5 <= 7)
  {
    *(_QWORD *)(a1 + 168) = v5 + 1;
    *(_BYTE *)(a1 + v5 + 160) = v6;
  }
  return v6 != 3;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::advance_KeyedContainer(uint64_t a1, const char *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int v6;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int64_t v18;
  char *v19;
  uint64_t v20;
  int64_t v21;
  size_t v22;
  unint64_t v23;
  uint64_t v24;
  int64_t v25;
  char *v26;
  uint64_t v27;
  int64_t v28;
  size_t v29;
  unint64_t v30;
  unint64_t v31;
  const char *v32;
  __int16 v33;
  char v34;
  unsigned __int8 __dst;
  int v36;

  v3 = *(_QWORD *)(a1 + 128);
  v4 = *(_QWORD *)(a1 + 112) - 1;
  if ((*(_BYTE *)(v3 + 48 * v4 + 4) & 0x40) != 0)
    return 1;
  v6 = *(_DWORD *)(v3 + 48 * v4 + 32);
  v36 = v6;
  if (v6 == a3)
  {
LABEL_3:
    *(_QWORD *)(v3 + 48 * v4 + 32) = 0xFFFFFFFF80000000;
    return 1;
  }
  v10 = a1 + 159;
  while (1)
  {
    if (v6 > a3)
    {
      result = 0;
      *(_QWORD *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 16) = v6;
      return result;
    }
    if ((v6 & 0x80000000) == 0)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    __dst = 0;
    if (*(_BYTE *)(a1 + 40))
      return 0;
    v11 = *(_QWORD *)(a1 + 168);
    if (v11)
    {
      v12 = v11 - 1;
      v13 = *(unsigned __int8 *)(a1 + v11 - 1 + 160);
      __dst = v13;
      *(_QWORD *)(a1 + 168) = v12;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL) & 1) == 0)
      {
        v32 = "Integer (numeric tag)";
        goto LABEL_64;
      }
      v13 = __dst;
    }
    if (v13 == 3)
      break;
    if ((v13 - 7) <= 0x28)
    {
      LODWORD(v14) = v13 - 8;
      goto LABEL_53;
    }
    if (v13 != 50)
    {
      if (v13 != 49)
      {
        if (v13 != 48)
        {
          v31 = *(_QWORD *)(a1 + 168);
          if (v31 <= 7)
          {
            *(_QWORD *)(a1 + 168) = v31 + 1;
            *(_BYTE *)(a1 + v31 + 160) = v13;
          }
          return 0;
        }
        v34 = 0;
        if (*(_BYTE *)(a1 + 40))
          return 0;
        v14 = *(_QWORD *)(a1 + 168);
        if (v14)
        {
          v15 = v14 - 1;
          LOBYTE(v14) = *(_BYTE *)(a1 + v14 - 1 + 160);
          *(_QWORD *)(a1 + 168) = v15;
        }
        else
        {
          if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, &v34, 1uLL))
          {
            v32 = "8-Bit Signed Integer";
            goto LABEL_64;
          }
          LOBYTE(v14) = v34;
        }
        LODWORD(v14) = (char)v14;
        goto LABEL_53;
      }
      v33 = 0;
      if (*(_BYTE *)(a1 + 40))
        return 0;
      v23 = *(_QWORD *)(a1 + 168);
      if (!v23)
      {
        v26 = (char *)&v33;
        v29 = 2;
        goto LABEL_51;
      }
      if (v23 >= 2)
        v24 = 2;
      else
        v24 = *(_QWORD *)(a1 + 168);
      v25 = v23 - v24;
      v26 = (char *)&v33;
      if ((uint64_t)(v23 - 1) >= (uint64_t)(v23 - v24))
      {
        v27 = *(_QWORD *)(a1 + 168);
        do
        {
          *v26++ = *(_BYTE *)(v10 + v27);
          v28 = v27 - 2;
          --v27;
        }
        while (v28 >= v25);
      }
      *(_QWORD *)(a1 + 168) = v25;
      if (v23 <= 1)
      {
        v29 = 2 - v24;
LABEL_51:
        if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, v26, v29) & 1) == 0)
        {
          v32 = "16-Bit Signed Integer";
          goto LABEL_64;
        }
      }
      LODWORD(v14) = v33;
LABEL_53:
      v36 = v14;
      goto LABEL_54;
    }
    if (*(_BYTE *)(a1 + 40))
      return 0;
    v16 = *(_QWORD *)(a1 + 168);
    if (v16)
    {
      if (v16 >= 4)
        v17 = 4;
      else
        v17 = *(_QWORD *)(a1 + 168);
      v18 = v16 - v17;
      v19 = (char *)&v36;
      if ((uint64_t)(v16 - 1) >= (uint64_t)(v16 - v17))
      {
        v20 = *(_QWORD *)(a1 + 168);
        do
        {
          *v19++ = *(_BYTE *)(v10 + v20);
          v21 = v20 - 2;
          --v20;
        }
        while (v21 >= v18);
      }
      *(_QWORD *)(a1 + 168) = v18;
      if (v16 > 3)
        goto LABEL_54;
      v22 = 4 - v17;
    }
    else
    {
      v19 = (char *)&v36;
      v22 = 4;
    }
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, v19, v22) & 1) == 0)
    {
      v32 = "32-Bit Signed Integer";
LABEL_64:
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)v32);
      return 0;
    }
LABEL_54:
    v6 = v36;
    if (v36 == a3)
    {
      v3 = *(_QWORD *)(a1 + 128);
      v4 = *(_QWORD *)(a1 + 112) - 1;
      goto LABEL_3;
    }
  }
  v30 = *(_QWORD *)(a1 + 168);
  if (v30 <= 7)
  {
    *(_QWORD *)(a1 + 168) = v30 + 1;
    *(_BYTE *)(a1 + v30 + 160) = 3;
  }
  return 0;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::evaluateConditional(uint64_t a1, const char *a2, _DWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v15;
  uint64_t v17;
  uint64_t v18;
  int v19;
  unint64_t v21;
  uint64_t i;
  char v23;
  uint64_t v24;
  unsigned __int8 v25;
  unint64_t v26;
  unint64_t v27;
  unsigned __int8 v28;
  const char *v29;
  unint64_t v30;
  uint64_t v31;
  int64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int8 v39;
  uint64_t v40;
  size_t v42;
  uint64_t v43;
  int64_t v44;
  _BYTE *v45;
  _BYTE *v46;
  int v47;
  uint64_t v48;
  char v49;
  _BYTE v50[7];
  _BYTE *v51;
  __int128 v52;
  __int128 v53;
  int v54;
  __int16 v55;
  unsigned __int8 v56;
  unsigned __int8 __dst;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  __dst = 0;
  v9 = *(_QWORD *)(a1 + 168);
  if (v9)
  {
    v10 = v9 - 1;
    v11 = *(unsigned __int8 *)(a1 + v9 - 1 + 160);
    __dst = v11;
    *(_QWORD *)(a1 + 168) = v10;
  }
  else
  {
    if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL))
    {
LABEL_55:
      v29 = "Array";
      goto LABEL_56;
    }
    v11 = __dst;
  }
  v12 = v11;
  v13 = v11 - 209;
  if ((v11 + 33) < 0xF3u || v11 == 209)
  {
    v15 = *(_QWORD *)(a1 + 168);
    if (v15 <= 7)
    {
      *(_QWORD *)(a1 + 168) = v15 + 1;
      *(_BYTE *)(a1 + v15 + 160) = v11;
    }
    return 1;
  }
  v4 = 0;
  v56 = 0;
  if (*(_BYTE *)(a1 + 40))
    return v4;
  v17 = *(_QWORD *)(a1 + 168);
  if (v17)
  {
    v18 = v17 - 1;
    v19 = *(unsigned __int8 *)(a1 + v17 - 1 + 160);
    v56 = v19;
    *(_QWORD *)(a1 + 168) = v18;
    goto LABEL_21;
  }
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&v56, 1uLL) & 1) != 0)
  {
    v19 = v56;
LABEL_21:
    if (v19 != 69)
    {
      v26 = *(_QWORD *)(a1 + 168);
      if (v26 <= 7)
      {
        *(_QWORD *)(a1 + 168) = v26 + 1;
        *(_BYTE *)(a1 + v26 + 160) = v19;
LABEL_35:
        v27 = *(_QWORD *)(a1 + 168);
        if (v27 <= 7)
        {
          v28 = __dst;
          *(_QWORD *)(a1 + 168) = v27 + 1;
          *(_BYTE *)(a1 + v27 + 160) = v28;
        }
      }
      return 1;
    }
    v55 = 0;
    v54 = 0;
    if (*(_BYTE *)(a1 + 40))
    {
LABEL_23:
      if (v54 == 1852793664 && v55 == 100)
      {
        v34 = 0;
        v35 = v12 - 210;
        v36 = 1;
        while (!*(_BYTE *)(a1 + 40))
        {
          v37 = *(_QWORD *)(a1 + 168);
          if (v37)
          {
            v38 = v37 - 1;
            v39 = *(_BYTE *)(a1 + v37 - 1 + 160);
            __dst = v39;
            *(_QWORD *)(a1 + 168) = v38;
          }
          else
          {
            if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL))goto LABEL_55;
            v39 = __dst;
          }
          if ((v39 + 46) >= 0xDu)
          {
            re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)a1, a2, (re::DynamicString *)&v48);
            if ((v49 & 1) != 0)
              v45 = v51;
            else
              v45 = v50;
            re::DynamicString::format((re::DynamicString *)"Failed to read version conditional \"%s\". Invalid condition.", (re::DynamicString *)&v52, v45);
            re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1, (uint64_t)&v52);
            if ((_QWORD)v52)
            {
              if ((BYTE8(v52) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v52 + 40))();
              v52 = 0u;
              v53 = 0u;
            }
            if (v48 && (v49 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v48 + 40))();
            return 0;
          }
          v47 = 0;
          v4 = re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<int>((_anonymous_namespace_ *)a1, a2, &v47);
          if ((v4 & 1) == 0)
          {
            re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)a1, a2, (re::DynamicString *)&v48);
            if ((v49 & 1) != 0)
              v46 = v51;
            else
              v46 = v50;
            re::DynamicString::format((re::DynamicString *)"Failed to read version conditional \"%s\". Failed to read version.", (re::DynamicString *)&v52, v46);
            re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1, (uint64_t)&v52);
            if ((_QWORD)v52)
            {
              if ((BYTE8(v52) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v52 + 40))();
              v52 = 0u;
              v53 = 0u;
            }
            if (v48 && (v49 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v48 + 40))();
            return v4;
          }
          if (*(_DWORD *)(a1 + 136) <= v47 || v35 == v34)
          {
            if (a3)
              *a3 = v47;
            *a4 = v13 + ~v34;
            return v4;
          }
          re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
          v34 = v36;
          if (v13 <= v36++)
          {
            re::internal::assertLog((re::internal *)4, v40, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "evaluateConditional", 2285);
            _os_crash();
            __break(1u);
            goto LABEL_55;
          }
        }
        return 0;
      }
      v21 = *(_QWORD *)(a1 + 168);
      if (v21 + 4 <= 7)
      {
        for (i = 4; i != -1; --i)
        {
          v23 = *((_BYTE *)&v54 + i);
          v24 = *(_QWORD *)(a1 + 168);
          *(_QWORD *)(a1 + 168) = v24 + 1;
          *(_BYTE *)(a1 + v24 + 160) = v23;
        }
        v21 = *(_QWORD *)(a1 + 168);
      }
      if (v21 <= 7)
      {
        v25 = v56;
        *(_QWORD *)(a1 + 168) = v21 + 1;
        *(_BYTE *)(a1 + v21 + 160) = v25;
        goto LABEL_35;
      }
      return 1;
    }
    v30 = *(_QWORD *)(a1 + 168);
    if (v30)
    {
      v31 = 5;
      if (v30 < 5)
        v31 = *(_QWORD *)(a1 + 168);
      v32 = v30 - v31;
      if ((uint64_t)(v30 - 1) >= (uint64_t)(v30 - v31))
      {
        v33 = (char *)&v54;
        v43 = *(_QWORD *)(a1 + 168);
        do
        {
          *v33++ = *(_BYTE *)(a1 + 159 + v43);
          v44 = v43 - 2;
          --v43;
        }
        while (v44 >= v32);
      }
      else
      {
        v33 = (char *)&v54;
      }
      *(_QWORD *)(a1 + 168) = v32;
      if (v30 > 4)
        goto LABEL_23;
      v42 = 5 - v31;
    }
    else
    {
      v33 = (char *)&v54;
      v42 = 5;
    }
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, v33, v42) & 1) == 0)re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Small String");
    goto LABEL_23;
  }
  v29 = "Small String";
LABEL_56:
  re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)v29);
  return 0;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::skipObject(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned __int8 v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  size_t v11;
  const char *v12;
  _anonymous_namespace_ *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  size_t i;
  unsigned __int8 v23;
  unint64_t v24;
  unint64_t v25;
  size_t v26;
  BOOL v27;
  unsigned __int8 v28;
  unint64_t v29;
  uint64_t v30;
  _BYTE *v31;
  uint64_t v32;
  char v33;
  _BYTE v34[23];
  size_t v35;
  __int128 v36;
  size_t v37;
  size_t __n[6];
  unsigned __int8 __dst;

  if (*(_BYTE *)(result + 40))
    return result;
  v1 = result;
  __dst = 0;
  v2 = *(_QWORD *)(result + 168);
  if (v2)
  {
    v3 = v2 - 1;
    v4 = *(unsigned __int8 *)(result + v3 + 160);
    __dst = v4;
    *(_QWORD *)(v1 + 168) = v3;
  }
  else
  {
    if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, (char *)&__dst, 1uLL))
    {
      v12 = "Member";
      v13 = (_anonymous_namespace_ *)v1;
      return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v13, "unknown", (uint64_t)v12);
    }
    v4 = __dst;
  }
  result = (uint64_t)re::OPACK::toString(v4);
  v5 = result;
  v6 = __dst;
  if (__dst > 0x2Fu)
  {
    switch(__dst)
    {
      case '0':
LABEL_20:
        if (*(_BYTE *)(v1 + 40))
          return result;
        v10 = (_QWORD *)v1;
        v11 = 1;
        goto LABEL_73;
      case '1':
LABEL_30:
        if (*(_BYTE *)(v1 + 40))
          return result;
        v15 = *(_QWORD *)(v1 + 168);
        if (!v15)
        {
          v11 = 2;
          goto LABEL_72;
        }
        v8 = 2;
        if (v15 >= 2)
          v9 = 2;
        else
          v9 = *(_QWORD *)(v1 + 168);
        *(_QWORD *)(v1 + 168) = v15 - v9;
        if (v15 != 1)
          return result;
        goto LABEL_48;
      case '2':
      case '5':
LABEL_23:
        if (*(_BYTE *)(v1 + 40))
          return result;
        v14 = *(_QWORD *)(v1 + 168);
        if (!v14)
        {
          v11 = 4;
          goto LABEL_72;
        }
        v8 = 4;
        if (v14 >= 4)
          v9 = 4;
        else
          v9 = *(_QWORD *)(v1 + 168);
        *(_QWORD *)(v1 + 168) = v14 - v9;
        if (v14 > 3)
          return result;
        goto LABEL_48;
      case '3':
      case '6':
        goto LABEL_12;
      case '4':
        goto LABEL_37;
      default:
        switch(__dst)
        {
          case 0xC1u:
            goto LABEL_20;
          case 0xC2u:
            goto LABEL_30;
          case 0xC3u:
            if (*(_BYTE *)(v1 + 40))
              return result;
            v18 = *(_QWORD *)(v1 + 168);
            if (!v18)
            {
              v11 = 3;
              goto LABEL_72;
            }
            v19 = 3;
            if (v18 < 3)
              v19 = *(_QWORD *)(v1 + 168);
            *(_QWORD *)(v1 + 168) = v18 - v19;
            v11 = v19 ^ 3;
            if (v19 == 3)
              return result;
            goto LABEL_72;
          case 0xC4u:
            goto LABEL_23;
          default:
            goto LABEL_37;
        }
    }
  }
  if (__dst - 1 >= 4)
  {
    if (__dst == 5)
    {
      if (*(_BYTE *)(v1 + 40))
        return result;
      v17 = *(_QWORD *)(v1 + 168);
      if (!v17)
      {
        v11 = 16;
        goto LABEL_72;
      }
      v8 = 16;
      if (v17 >= 0x10)
        v9 = 16;
      else
        v9 = *(_QWORD *)(v1 + 168);
      *(_QWORD *)(v1 + 168) = v17 - v9;
      if (v17 > 0xF)
        return result;
    }
    else
    {
      if (__dst != 6)
      {
LABEL_37:
        if (__dst - 7 < 0x29)
          return result;
        if (__dst - 64 > 0x24)
        {
          if (__dst - 112 > 0x24)
          {
            if ((__dst + 96) >= 0x21u)
            {
              if ((__dst + 48) > 0xEu)
              {
                if (__dst == 223)
                {
                  result = re::EncoderOPACK<re::SeekableInputStream>::readTag(v1, "unknown", (char *)&__dst, (uint64_t)"Array value/terminator");
                  if ((_DWORD)result)
                  {
                    do
                    {
                      v23 = __dst;
                      if (__dst == 3)
                        break;
                      v24 = *(_QWORD *)(v1 + 168);
                      if (v24 <= 7)
                      {
                        *(_QWORD *)(v1 + 168) = v24 + 1;
                        *(_BYTE *)(v1 + v24 + 160) = v23;
                      }
                      re::EncoderOPACK<re::SeekableInputStream>::skipObject(v1);
                      result = re::EncoderOPACK<re::SeekableInputStream>::readTag(v1, "unknown", (char *)&__dst, (uint64_t)"Array value/terminator");
                    }
                    while ((result & 1) != 0);
                  }
                }
                else if ((__dst + 32) > 0xEu)
                {
                  if (__dst == 239)
                  {
                    for (result = re::EncoderOPACK<re::SeekableInputStream>::readTag(v1, "unknown", (char *)&__dst, (uint64_t)"Dictionary key/value/terminator");
                          (_DWORD)result;
                          result = re::EncoderOPACK<re::SeekableInputStream>::readTag(v1, "unknown", (char *)&__dst, (uint64_t)"Dictionary key/value/terminator"))
                    {
                      v28 = __dst;
                      if (__dst == 3)
                        break;
                      v29 = *(_QWORD *)(v1 + 168);
                      if (v29 <= 7)
                      {
                        *(_QWORD *)(v1 + 168) = v29 + 1;
                        *(_BYTE *)(v1 + v29 + 160) = v28;
                      }
                      v30 = -2;
                      do
                      {
                        re::EncoderOPACK<re::SeekableInputStream>::skipObject(v1);
                        v27 = __CFADD__(v30++, 1);
                      }
                      while (!v27);
                    }
                  }
                  else
                  {
                    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)v1, 0, (re::DynamicString *)&v32);
                    if ((v33 & 1) != 0)
                      v31 = *(_BYTE **)&v34[7];
                    else
                      v31 = v34;
                    re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Found unsupported tag while skipping over data.", (re::DynamicString *)&v35, v31);
                    __n[0] = 400;
                    __n[1] = (size_t)&re::FoundationErrorCategory(void)::instance;
                    __n[2] = v35;
                    __n[5] = v37;
                    *(_OWORD *)&__n[3] = v36;
                    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (__int128 *)__n);
                    if (__n[2])
                    {
                      if ((__n[3] & 1) != 0)
                        (*(void (**)(void))(*(_QWORD *)__n[2] + 40))();
                      memset(&__n[2], 0, 32);
                    }
                    result = v32;
                    if (v32 && (v33 & 1) != 0)
                      return (*(uint64_t (**)(void))(*(_QWORD *)v32 + 40))();
                  }
                }
                else
                {
                  v25 = *(_QWORD *)(v1 + 168);
                  if (v25 <= 7)
                  {
                    *(_QWORD *)(v1 + 168) = v25 + 1;
                    *(_BYTE *)(v1 + v25 + 160) = v6;
                  }
                  __n[0] = 0;
                  result = re::EncoderOPACK<re::SeekableInputStream>::readDictionaryTag(v1, "unknown", (char *)__n);
                  if (2 * __n[0])
                  {
                    v26 = -2 * __n[0];
                    do
                    {
                      result = re::EncoderOPACK<re::SeekableInputStream>::skipObject(v1);
                      v27 = __CFADD__(v26++, 1);
                    }
                    while (!v27);
                  }
                }
              }
              else
              {
                v21 = *(_QWORD *)(v1 + 168);
                if (v21 <= 7)
                {
                  *(_QWORD *)(v1 + 168) = v21 + 1;
                  *(_BYTE *)(v1 + v21 + 160) = v6;
                }
                __n[0] = 0;
                result = re::EncoderOPACK<re::SeekableInputStream>::readArrayTag(v1, "unknown", (char *)__n);
                for (i = __n[0]; i; result = re::EncoderOPACK<re::SeekableInputStream>::skipObject(v1))
                  --i;
              }
            }
            return result;
          }
          v20 = *(_QWORD *)(v1 + 168);
          if (v20 <= 7)
          {
            *(_QWORD *)(v1 + 168) = v20 + 1;
            *(_BYTE *)(v1 + v20 + 160) = v6;
          }
          __n[0] = 0;
          re::EncoderOPACK<re::SeekableInputStream>::readDataTag(v1, "unknown", (uint64_t *)__n);
        }
        else
        {
          v16 = *(_QWORD *)(v1 + 168);
          if (v16 <= 7)
          {
            *(_QWORD *)(v1 + 168) = v16 + 1;
            *(_BYTE *)(v1 + v16 + 160) = v6;
          }
          __n[0] = 0;
          re::EncoderOPACK<re::SeekableInputStream>::readStringTag(v1, "unknown", (uint64_t *)__n);
        }
        return re::EncoderOPACK<re::SeekableInputStream>::readRaw(v1, "unknown", 0, __n[0], v5, 1);
      }
LABEL_12:
      if (*(_BYTE *)(v1 + 40))
        return result;
      v7 = *(_QWORD *)(v1 + 168);
      if (!v7)
      {
        v11 = 8;
        goto LABEL_72;
      }
      v8 = 8;
      if (v7 >= 8)
        v9 = 8;
      else
        v9 = *(_QWORD *)(v1 + 168);
      *(_QWORD *)(v1 + 168) = v7 - v9;
      if (v7 > 7)
        return result;
    }
LABEL_48:
    v11 = v8 - v9;
LABEL_72:
    v10 = (_QWORD *)v1;
LABEL_73:
    result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>(v10, 0, v11);
    if ((result & 1) == 0)
    {
      v13 = (_anonymous_namespace_ *)v1;
      v12 = (const char *)v5;
      return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v13, "unknown", (uint64_t)v12);
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readRaw(uint64_t a1, const char *a2, _BYTE *a3, size_t __n, uint64_t a5, char a6)
{
  size_t v10;
  size_t v11;
  int64_t v12;
  int64_t v13;
  char *v14;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v10 = *(_QWORD *)(a1 + 168);
  if (v10)
  {
    if (v10 >= __n)
      v11 = __n;
    else
      v11 = *(_QWORD *)(a1 + 168);
    v12 = v10 - v11;
    if ((uint64_t)(v10 - 1) >= (uint64_t)(v10 - v11))
    {
      do
      {
        *a3++ = *(_BYTE *)(a1 + 159 + v10);
        v13 = v10 - 2;
        --v10;
      }
      while (v13 >= v12);
    }
    *(_QWORD *)(a1 + 168) = v12;
    __n -= v11;
  }
  if (__n)
  {
    v14 = (a6 & 1) != 0 ? 0 : a3;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, v14, __n) & 1) == 0)
    {
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
      return 0;
    }
  }
  return 1;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readStringTag(uint64_t result, const char *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  int64_t v13;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  int64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  int64_t v21;
  char *v22;
  size_t v23;
  size_t v24;
  size_t v25;
  uint64_t v26;
  int64_t v27;
  uint64_t v28;
  int64_t v29;
  uint64_t v30;
  int64_t v31;
  uint64_t v32;
  unsigned __int8 __dst;

  if (*(_BYTE *)(result + 40))
    return result;
  v5 = result;
  __dst = 0;
  v6 = *(_QWORD *)(result + 168);
  if (v6)
  {
    v7 = v6 - 1;
    result = *(unsigned __int8 *)(result + v7 + 160);
    __dst = *(_BYTE *)(v5 + v7 + 160);
    *(_QWORD *)(v5 + 168) = v7;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, (char *)&__dst, 1uLL) & 1) == 0)return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
    result = __dst;
  }
  if ((result - 64) > 0x20)
  {
    switch((int)result)
    {
      case 'a':
        LOBYTE(v32) = 0;
        if (!*(_BYTE *)(v5 + 40))
        {
          v8 = *(_QWORD *)(v5 + 168);
          if (v8)
          {
            v9 = v8 - 1;
            LODWORD(v8) = *(unsigned __int8 *)(v5 + v8 - 1 + 160);
            *(_QWORD *)(v5 + 168) = v9;
          }
          else
          {
            result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)v5, (char *)&v32, 1uLL);
            if (!(_DWORD)result)
              return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
            LODWORD(v8) = v32;
          }
          v8 = v8;
          goto LABEL_8;
        }
        return result;
      case 'b':
        LOWORD(v32) = 0;
        if (*(_BYTE *)(v5 + 40))
          return result;
        v11 = *(_QWORD *)(v5 + 168);
        if (v11)
        {
          v12 = 2;
          if (v11 < 2)
            v12 = *(_QWORD *)(v5 + 168);
          v13 = v11 - v12;
          if ((uint64_t)(v11 - 1) >= (uint64_t)(v11 - v12))
          {
            v14 = (char *)&v32;
            v26 = *(_QWORD *)(v5 + 168);
            do
            {
              *v14++ = *(_BYTE *)(v5 + 159 + v26);
              v27 = v26 - 2;
              --v26;
            }
            while (v27 >= v13);
          }
          else
          {
            v14 = (char *)&v32;
          }
          *(_QWORD *)(v5 + 168) = v13;
          if (v11 > 1)
          {
LABEL_43:
            v8 = (unsigned __int16)v32;
            goto LABEL_8;
          }
          v25 = 2 - v12;
        }
        else
        {
          v14 = (char *)&v32;
          v25 = 2;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)v5, v14, v25);
        if ((result & 1) == 0)
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
        goto LABEL_43;
      case 'c':
        LODWORD(v32) = 0;
        if (*(_BYTE *)(v5 + 40))
          return result;
        v15 = *(_QWORD *)(v5 + 168);
        if (v15)
        {
          v16 = 4;
          if (v15 < 4)
            v16 = *(_QWORD *)(v5 + 168);
          v17 = v15 - v16;
          if ((uint64_t)(v15 - 1) >= (uint64_t)(v15 - v16))
          {
            v18 = (char *)&v32;
            v28 = *(_QWORD *)(v5 + 168);
            do
            {
              *v18++ = *(_BYTE *)(v5 + 159 + v28);
              v29 = v28 - 2;
              --v28;
            }
            while (v29 >= v17);
          }
          else
          {
            v18 = (char *)&v32;
          }
          *(_QWORD *)(v5 + 168) = v17;
          if (v15 > 3)
            goto LABEL_49;
          v23 = 4 - v16;
        }
        else
        {
          v18 = (char *)&v32;
          v23 = 4;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)v5, v18, v23);
        if ((result & 1) == 0)
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
LABEL_49:
        v8 = v32;
        goto LABEL_8;
      case 'd':
        v32 = 0;
        if (*(_BYTE *)(v5 + 40))
          return result;
        v19 = *(_QWORD *)(v5 + 168);
        if (v19)
        {
          v20 = 8;
          if (v19 < 8)
            v20 = *(_QWORD *)(v5 + 168);
          v21 = v19 - v20;
          if ((uint64_t)(v19 - 1) >= (uint64_t)(v19 - v20))
          {
            v22 = (char *)&v32;
            v30 = *(_QWORD *)(v5 + 168);
            do
            {
              *v22++ = *(_BYTE *)(v5 + 159 + v30);
              v31 = v30 - 2;
              --v30;
            }
            while (v31 >= v21);
          }
          else
          {
            v22 = (char *)&v32;
          }
          *(_QWORD *)(v5 + 168) = v21;
          if (v19 > 7)
            goto LABEL_55;
          v24 = 8 - v20;
        }
        else
        {
          v22 = (char *)&v32;
          v24 = 8;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)v5, v22, v24);
        if ((result & 1) == 0)
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
LABEL_55:
        v8 = v32;
        goto LABEL_8;
      default:
        v10 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"String", (uint64_t)v10);
    }
  }
  v8 = result - 64;
LABEL_8:
  *a3 = v8;
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readDataTag(uint64_t result, const char *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  int64_t v13;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  int64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  int64_t v21;
  char *v22;
  size_t v23;
  size_t v24;
  size_t v25;
  uint64_t v26;
  int64_t v27;
  uint64_t v28;
  int64_t v29;
  uint64_t v30;
  int64_t v31;
  uint64_t v32;
  unsigned __int8 __dst;

  if (*(_BYTE *)(result + 40))
    return result;
  v5 = result;
  __dst = 0;
  v6 = *(_QWORD *)(result + 168);
  if (v6)
  {
    v7 = v6 - 1;
    result = *(unsigned __int8 *)(result + v7 + 160);
    __dst = *(_BYTE *)(v5 + v7 + 160);
    *(_QWORD *)(v5 + 168) = v7;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, (char *)&__dst, 1uLL) & 1) == 0)return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
    result = __dst;
  }
  if ((result - 112) > 0x20)
  {
    switch((int)result)
    {
      case 145:
        LOBYTE(v32) = 0;
        if (!*(_BYTE *)(v5 + 40))
        {
          v8 = *(_QWORD *)(v5 + 168);
          if (v8)
          {
            v9 = v8 - 1;
            LODWORD(v8) = *(unsigned __int8 *)(v5 + v8 - 1 + 160);
            *(_QWORD *)(v5 + 168) = v9;
          }
          else
          {
            result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)v5, (char *)&v32, 1uLL);
            if (!(_DWORD)result)
              return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
            LODWORD(v8) = v32;
          }
          v8 = v8;
          goto LABEL_8;
        }
        return result;
      case 146:
        LOWORD(v32) = 0;
        if (*(_BYTE *)(v5 + 40))
          return result;
        v11 = *(_QWORD *)(v5 + 168);
        if (v11)
        {
          v12 = 2;
          if (v11 < 2)
            v12 = *(_QWORD *)(v5 + 168);
          v13 = v11 - v12;
          if ((uint64_t)(v11 - 1) >= (uint64_t)(v11 - v12))
          {
            v14 = (char *)&v32;
            v26 = *(_QWORD *)(v5 + 168);
            do
            {
              *v14++ = *(_BYTE *)(v5 + 159 + v26);
              v27 = v26 - 2;
              --v26;
            }
            while (v27 >= v13);
          }
          else
          {
            v14 = (char *)&v32;
          }
          *(_QWORD *)(v5 + 168) = v13;
          if (v11 > 1)
          {
LABEL_43:
            v8 = (unsigned __int16)v32;
            goto LABEL_8;
          }
          v25 = 2 - v12;
        }
        else
        {
          v14 = (char *)&v32;
          v25 = 2;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)v5, v14, v25);
        if ((result & 1) == 0)
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
        goto LABEL_43;
      case 147:
        LODWORD(v32) = 0;
        if (*(_BYTE *)(v5 + 40))
          return result;
        v15 = *(_QWORD *)(v5 + 168);
        if (v15)
        {
          v16 = 4;
          if (v15 < 4)
            v16 = *(_QWORD *)(v5 + 168);
          v17 = v15 - v16;
          if ((uint64_t)(v15 - 1) >= (uint64_t)(v15 - v16))
          {
            v18 = (char *)&v32;
            v28 = *(_QWORD *)(v5 + 168);
            do
            {
              *v18++ = *(_BYTE *)(v5 + 159 + v28);
              v29 = v28 - 2;
              --v28;
            }
            while (v29 >= v17);
          }
          else
          {
            v18 = (char *)&v32;
          }
          *(_QWORD *)(v5 + 168) = v17;
          if (v15 > 3)
            goto LABEL_49;
          v23 = 4 - v16;
        }
        else
        {
          v18 = (char *)&v32;
          v23 = 4;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)v5, v18, v23);
        if ((result & 1) == 0)
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
LABEL_49:
        v8 = v32;
        goto LABEL_8;
      case 148:
        v32 = 0;
        if (*(_BYTE *)(v5 + 40))
          return result;
        v19 = *(_QWORD *)(v5 + 168);
        if (v19)
        {
          v20 = 8;
          if (v19 < 8)
            v20 = *(_QWORD *)(v5 + 168);
          v21 = v19 - v20;
          if ((uint64_t)(v19 - 1) >= (uint64_t)(v19 - v20))
          {
            v22 = (char *)&v32;
            v30 = *(_QWORD *)(v5 + 168);
            do
            {
              *v22++ = *(_BYTE *)(v5 + 159 + v30);
              v31 = v30 - 2;
              --v30;
            }
            while (v31 >= v21);
          }
          else
          {
            v22 = (char *)&v32;
          }
          *(_QWORD *)(v5 + 168) = v21;
          if (v19 > 7)
            goto LABEL_55;
          v24 = 8 - v20;
        }
        else
        {
          v22 = (char *)&v32;
          v24 = 8;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)v5, v22, v24);
        if ((result & 1) == 0)
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
LABEL_55:
        v8 = v32;
        goto LABEL_8;
      default:
        v10 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"BLOB", (uint64_t)v10);
    }
  }
  v8 = result - 112;
LABEL_8:
  *a3 = v8;
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readArrayTag(uint64_t result, const char *a2, char *__dst)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  unsigned __int8 __dsta;

  if (!*(_BYTE *)(result + 40))
  {
    v5 = (_QWORD *)result;
    __dsta = 0;
    v6 = *(_QWORD *)(result + 168);
    if (v6)
    {
      v7 = v6 - 1;
      result = *(unsigned __int8 *)(result + v7 + 160);
      __dsta = *((_BYTE *)v5 + v7 + 160);
      v5[21] = v7;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, (char *)&__dsta, 1uLL) & 1) == 0)return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Array");
      result = __dsta;
    }
    if ((result + 48) > 0xEu)
    {
      if ((_DWORD)result == 223)
      {
        return re::EncoderOPACK<re::SeekableInputStream>::readUint64((uint64_t)v5, a2, __dst);
      }
      else
      {
        v8 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"Array", (uint64_t)v8);
      }
    }
    else
    {
      *(_QWORD *)__dst = result - 208;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readDictionaryTag(uint64_t result, const char *a2, char *__dst)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  unsigned __int8 __dsta;

  if (!*(_BYTE *)(result + 40))
  {
    v5 = result;
    __dsta = 0;
    v6 = *(_QWORD *)(result + 168);
    if (v6)
    {
      v7 = v6 - 1;
      result = *(unsigned __int8 *)(result + v7 + 160);
      __dsta = *(_BYTE *)(v5 + v7 + 160);
      *(_QWORD *)(v5 + 168) = v7;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, (char *)&__dsta, 1uLL) & 1) == 0)return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Dictionary");
      result = __dsta;
    }
    if ((result + 32) <= 0xEu)
    {
      *(_QWORD *)__dst = result - 224;
      return result;
    }
    if ((_DWORD)result != 210)
      goto LABEL_17;
    result = re::EncoderOPACK<re::SeekableInputStream>::readUint64(v5, a2, __dst);
    if (!(_DWORD)result || *(_BYTE *)(v5 + 40))
      return result;
    v8 = *(_QWORD *)(v5 + 168);
    if (v8)
    {
      v9 = v8 - 1;
      result = *(unsigned __int8 *)(v5 + v9 + 160);
      __dsta = *(_BYTE *)(v5 + v9 + 160);
      *(_QWORD *)(v5 + 168) = v9;
      goto LABEL_16;
    }
    if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)v5, (char *)&__dsta, 1uLL))
    {
      result = __dsta;
LABEL_16:
      if ((_DWORD)result == 239)
        return result;
LABEL_17:
      v10 = re::OPACK::toString(result);
      return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"Dictionary", (uint64_t)v10);
    }
    return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Dictionary");
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readUint64(uint64_t a1, const char *a2, char *__dst)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  int64_t v12;
  uint64_t v13;
  int64_t v14;
  size_t v15;
  unint64_t v16;
  unsigned __int8 __dsta;
  uint64_t v18;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  __dsta = 0;
  v7 = *(_QWORD *)(a1 + 168);
  if (v7)
  {
    v8 = v7 - 1;
    v9 = *(unsigned __int8 *)(a1 + v7 - 1 + 160);
    __dsta = v9;
    *(_QWORD *)(a1 + 168) = v8;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dsta, 1uLL) & 1) == 0)
    {
LABEL_25:
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"UInt64");
      return 0;
    }
    v9 = __dsta;
  }
  if (v9 != 120)
  {
    v16 = *(_QWORD *)(a1 + 168);
    if (v16 <= 7)
    {
      *(_QWORD *)(a1 + 168) = v16 + 1;
      *(_BYTE *)(a1 + v16 + 160) = v9;
    }
    v18 = 0;
    if ((re::EncoderOPACK<re::SeekableInputStream>::readInteger(a1, a2, (char *)&v18, (uint64_t)"Int64") & 1) == 0)
      return 0;
    *(_QWORD *)__dst = v18;
    return 1;
  }
  if (!*(_BYTE *)(a1 + 40))
  {
    v10 = *(_QWORD *)(a1 + 168);
    if (v10)
    {
      v11 = 8;
      if (v10 < 8)
        v11 = *(_QWORD *)(a1 + 168);
      v12 = v10 - v11;
      if ((uint64_t)(v10 - 1) >= (uint64_t)(v10 - v11))
      {
        v13 = *(_QWORD *)(a1 + 168);
        do
        {
          *__dst++ = *(_BYTE *)(a1 + 159 + v13);
          v14 = v13 - 2;
          --v13;
        }
        while (v14 >= v12);
      }
      *(_QWORD *)(a1 + 168) = v12;
      if (v10 > 7)
        return 1;
      v15 = 8 - v11;
    }
    else
    {
      v15 = 8;
    }
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, __dst, v15) & 1) != 0)return 1;
    goto LABEL_25;
  }
  return 0;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readInteger(uint64_t a1, const char *a2, char *__dst, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  _anonymous_namespace_ *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  unint64_t v18;
  uint64_t v19;
  int64_t v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  int64_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  int64_t v28;
  uint64_t v29;
  int64_t v30;
  size_t v31;
  size_t v32;
  size_t v33;
  uint64_t v34;
  int64_t v35;
  uint64_t v36;
  int64_t v37;
  int v38;
  __int16 v39;
  char v40;
  unsigned __int8 __dsta;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  __dsta = 0;
  v9 = *(_QWORD *)(a1 + 168);
  if (v9)
  {
    v10 = v9 - 1;
    v11 = *(unsigned __int8 *)(a1 + v10 + 160);
    __dsta = *(_BYTE *)(a1 + v10 + 160);
    *(_QWORD *)(a1 + 168) = v10;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dsta, 1uLL) & 1) == 0)
    {
      v14 = (_anonymous_namespace_ *)a1;
      v15 = a2;
      v16 = (const char *)a4;
      goto LABEL_17;
    }
    v11 = __dsta;
  }
  if (v11 - 7 > 0x28)
  {
    switch(v11)
    {
      case '0':
        result = 0;
        v40 = 0;
        if (*(_BYTE *)(a1 + 40))
          return result;
        v12 = *(_QWORD *)(a1 + 168);
        if (v12)
        {
          v13 = v12 - 1;
          LOBYTE(v12) = *(_BYTE *)(a1 + v12 - 1 + 160);
          *(_QWORD *)(a1 + 168) = v13;
LABEL_46:
          v12 = (char)v12;
          goto LABEL_10;
        }
        if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, &v40, 1uLL))
        {
          LOBYTE(v12) = v40;
          goto LABEL_46;
        }
        v16 = "8-Bit Signed Integer";
        goto LABEL_63;
      case '1':
        result = 0;
        v39 = 0;
        if (*(_BYTE *)(a1 + 40))
          return result;
        v18 = *(_QWORD *)(a1 + 168);
        if (v18)
        {
          v19 = 2;
          if (v18 < 2)
            v19 = *(_QWORD *)(a1 + 168);
          v20 = v18 - v19;
          if ((uint64_t)(v18 - 1) >= (uint64_t)(v18 - v19))
          {
            v21 = (char *)&v39;
            v34 = *(_QWORD *)(a1 + 168);
            do
            {
              *v21++ = *(_BYTE *)(a1 + 159 + v34);
              v35 = v34 - 2;
              --v34;
            }
            while (v35 >= v20);
          }
          else
          {
            v21 = (char *)&v39;
          }
          *(_QWORD *)(a1 + 168) = v20;
          if (v18 > 1)
            goto LABEL_53;
          v33 = 2 - v19;
        }
        else
        {
          v21 = (char *)&v39;
          v33 = 2;
        }
        if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, v21, v33) & 1) != 0)
        {
LABEL_53:
          v12 = v39;
          goto LABEL_10;
        }
        v16 = "16-Bit Signed Integer";
        goto LABEL_63;
      case '2':
        result = 0;
        v38 = 0;
        if (*(_BYTE *)(a1 + 40))
          return result;
        v22 = *(_QWORD *)(a1 + 168);
        if (v22)
        {
          v23 = 4;
          if (v22 < 4)
            v23 = *(_QWORD *)(a1 + 168);
          v24 = v22 - v23;
          if ((uint64_t)(v22 - 1) >= (uint64_t)(v22 - v23))
          {
            v25 = (char *)&v38;
            v36 = *(_QWORD *)(a1 + 168);
            do
            {
              *v25++ = *(_BYTE *)(a1 + 159 + v36);
              v37 = v36 - 2;
              --v36;
            }
            while (v37 >= v24);
          }
          else
          {
            v25 = (char *)&v38;
          }
          *(_QWORD *)(a1 + 168) = v24;
          if (v22 > 3)
            goto LABEL_60;
          v32 = 4 - v23;
        }
        else
        {
          v25 = (char *)&v38;
          v32 = 4;
        }
        if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, v25, v32) & 1) != 0)
        {
LABEL_60:
          v12 = v38;
          goto LABEL_10;
        }
        v16 = "32-Bit Signed Integer";
LABEL_63:
        v14 = (_anonymous_namespace_ *)a1;
        v15 = a2;
        break;
      case '3':
        if (*(_BYTE *)(a1 + 40))
          return 0;
        v26 = *(_QWORD *)(a1 + 168);
        if (v26)
        {
          v27 = 8;
          if (v26 < 8)
            v27 = *(_QWORD *)(a1 + 168);
          v28 = v26 - v27;
          if ((uint64_t)(v26 - 1) >= (uint64_t)(v26 - v27))
          {
            v29 = *(_QWORD *)(a1 + 168);
            do
            {
              *__dst++ = *(_BYTE *)(a1 + 159 + v29);
              v30 = v29 - 2;
              --v29;
            }
            while (v30 >= v28);
          }
          *(_QWORD *)(a1 + 168) = v28;
          if (v26 > 7)
            return 1;
          v31 = 8 - v27;
        }
        else
        {
          v31 = 8;
        }
        if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, __dst, v31) & 1) != 0)return 1;
        v16 = "64-Bit Signed Integer";
        goto LABEL_63;
      default:
        v17 = re::OPACK::toString(v11);
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, a4, (uint64_t)v17);
        return 0;
    }
LABEL_17:
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v14, v15, (uint64_t)v16);
    return 0;
  }
  v12 = v11 - 8;
LABEL_10:
  *(_QWORD *)__dst = v12;
  return 1;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<int>(_anonymous_namespace_ *a1, const char *a2, _DWORD *a3)
{
  uint64_t result;
  _BYTE *v7;
  uint64_t v8;
  char v9;
  _BYTE v10[23];
  _OWORD v11[2];
  uint64_t __dst;

  __dst = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"Int32");
  if ((_DWORD)result)
  {
    if (__dst == (int)__dst)
    {
      *a3 = __dst;
      return 1;
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if ((v9 & 1) != 0)
        v7 = *(_BYTE **)&v10[7];
      else
        v7 = v10;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "Int32", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(_QWORD *)&v11[0])
      {
        if ((BYTE8(v11[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if ((v9 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v8 + 40))();
      }
      return 0;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  uint64_t v5;
  _anonymous_namespace_ *v10;
  const char *v11;
  char *v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  char v17;
  uint64_t v18;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v18 = 0;
  v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if ((_DWORD)v5)
  {
    if ((a5 & 1) != 0)
    {
      v17 = 0;
      v12 = &v17;
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
    }
    else
    {
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
      v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<signed char>(v10, v11, v12);
    for (i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      v14 = *(_QWORD *)(a1 + 128);
      v15 = *(_QWORD *)(a1 + 112) - 1;
      if (*(_BYTE *)(v14 + 48 * v15) != 2)
        ++*(_QWORD *)(v14 + 48 * v15 + 32);
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<signed char>(_anonymous_namespace_ *a1, const char *a2, _BYTE *a3)
{
  uint64_t result;
  _BYTE *v7;
  uint64_t v8;
  char v9;
  _BYTE v10[23];
  _OWORD v11[2];
  uint64_t __dst;

  __dst = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"Int8");
  if ((_DWORD)result)
  {
    if (__dst == (char)__dst)
    {
      *a3 = __dst;
      return 1;
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if ((v9 & 1) != 0)
        v7 = *(_BYTE **)&v10[7];
      else
        v7 = v10;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "Int8", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(_QWORD *)&v11[0])
      {
        if ((BYTE8(v11[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if ((v9 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v8 + 40))();
      }
      return 0;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<short>(uint64_t a1, const char *a2, int a3, __int16 *a4, char a5)
{
  uint64_t v5;
  _anonymous_namespace_ *v10;
  const char *v11;
  __int16 *v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  __int16 v17;
  uint64_t v18;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v18 = 0;
  v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if ((_DWORD)v5)
  {
    if ((a5 & 1) != 0)
    {
      v17 = 0;
      v12 = &v17;
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
    }
    else
    {
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
      v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<short>(v10, v11, v12);
    for (i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      v14 = *(_QWORD *)(a1 + 128);
      v15 = *(_QWORD *)(a1 + 112) - 1;
      if (*(_BYTE *)(v14 + 48 * v15) != 2)
        ++*(_QWORD *)(v14 + 48 * v15 + 32);
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<short>(_anonymous_namespace_ *a1, const char *a2, _WORD *a3)
{
  uint64_t result;
  _BYTE *v7;
  uint64_t v8;
  char v9;
  _BYTE v10[23];
  _OWORD v11[2];
  uint64_t __dst;

  __dst = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"Int16");
  if ((_DWORD)result)
  {
    if (__dst == (__int16)__dst)
    {
      *a3 = __dst;
      return 1;
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if ((v9 & 1) != 0)
        v7 = *(_BYTE **)&v10[7];
      else
        v7 = v10;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "Int16", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(_QWORD *)&v11[0])
      {
        if ((BYTE8(v11[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if ((v9 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v8 + 40))();
      }
      return 0;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<int>(uint64_t a1, const char *a2, int a3, int *a4, char a5)
{
  uint64_t v5;
  _anonymous_namespace_ *v10;
  const char *v11;
  int *v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  int v17;
  uint64_t v18;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v18 = 0;
  v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if ((_DWORD)v5)
  {
    if ((a5 & 1) != 0)
    {
      v17 = 0;
      v12 = &v17;
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
    }
    else
    {
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
      v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<int>(v10, v11, v12);
    for (i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      v14 = *(_QWORD *)(a1 + 128);
      v15 = *(_QWORD *)(a1 + 112) - 1;
      if (*(_BYTE *)(v14 + 48 * v15) != 2)
        ++*(_QWORD *)(v14 + 48 * v15 + 32);
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<long long>(uint64_t a1, const char *a2, int a3, _QWORD *a4, char a5)
{
  uint64_t v5;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t __dst;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v14 = 0;
  v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v14, 0);
  if ((_DWORD)v5)
  {
    if ((a5 & 1) != 0)
    {
      __dst = 0;
      re::EncoderOPACK<re::SeekableInputStream>::readInteger(a1, a2, (char *)&__dst, (uint64_t)"Int64");
    }
    else
    {
      __dst = 0;
      if (re::EncoderOPACK<re::SeekableInputStream>::readInteger(a1, a2, (char *)&__dst, (uint64_t)"Int64"))*a4 = __dst;
    }
    for (i = v14; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      v11 = *(_QWORD *)(a1 + 128);
      v12 = *(_QWORD *)(a1 + 112) - 1;
      if (*(_BYTE *)(v11 + 48 * v12) != 2)
        ++*(_QWORD *)(v11 + 48 * v12 + 32);
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned char>(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  uint64_t v5;
  _anonymous_namespace_ *v10;
  const char *v11;
  char *v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  char v17;
  uint64_t v18;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v18 = 0;
  v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if ((_DWORD)v5)
  {
    if ((a5 & 1) != 0)
    {
      v17 = 0;
      v12 = &v17;
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
    }
    else
    {
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
      v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned char>(v10, v11, v12);
    for (i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      v14 = *(_QWORD *)(a1 + 128);
      v15 = *(_QWORD *)(a1 + 112) - 1;
      if (*(_BYTE *)(v14 + 48 * v15) != 2)
        ++*(_QWORD *)(v14 + 48 * v15 + 32);
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned char>(_anonymous_namespace_ *a1, const char *a2, _BYTE *a3)
{
  uint64_t result;
  _BYTE *v7;
  uint64_t v8;
  char v9;
  _BYTE v10[23];
  _OWORD v11[2];
  unint64_t __dst;

  __dst = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"UInt8");
  if ((_DWORD)result)
  {
    if (__dst > 0xFF)
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if ((v9 & 1) != 0)
        v7 = *(_BYTE **)&v10[7];
      else
        v7 = v10;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "UInt8", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(_QWORD *)&v11[0])
      {
        if ((BYTE8(v11[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if ((v9 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v8 + 40))();
      }
      return 0;
    }
    else
    {
      *a3 = __dst;
      return 1;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned short>(uint64_t a1, const char *a2, int a3, __int16 *a4, char a5)
{
  uint64_t v5;
  _anonymous_namespace_ *v10;
  const char *v11;
  __int16 *v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  __int16 v17;
  uint64_t v18;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v18 = 0;
  v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if ((_DWORD)v5)
  {
    if ((a5 & 1) != 0)
    {
      v17 = 0;
      v12 = &v17;
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
    }
    else
    {
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
      v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned short>(v10, v11, v12);
    for (i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      v14 = *(_QWORD *)(a1 + 128);
      v15 = *(_QWORD *)(a1 + 112) - 1;
      if (*(_BYTE *)(v14 + 48 * v15) != 2)
        ++*(_QWORD *)(v14 + 48 * v15 + 32);
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned short>(_anonymous_namespace_ *a1, const char *a2, _WORD *a3)
{
  uint64_t result;
  _BYTE *v7;
  uint64_t v8;
  char v9;
  _BYTE v10[23];
  _OWORD v11[2];
  unint64_t __dst;

  __dst = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"UInt16");
  if ((_DWORD)result)
  {
    if (__dst >> 16)
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if ((v9 & 1) != 0)
        v7 = *(_BYTE **)&v10[7];
      else
        v7 = v10;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "UInt16", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(_QWORD *)&v11[0])
      {
        if ((BYTE8(v11[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if ((v9 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v8 + 40))();
      }
      return 0;
    }
    else
    {
      *a3 = __dst;
      return 1;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned int>(uint64_t a1, const char *a2, int a3, int *a4, char a5)
{
  uint64_t v5;
  _anonymous_namespace_ *v10;
  const char *v11;
  int *v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  int v17;
  uint64_t v18;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v18 = 0;
  v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if ((_DWORD)v5)
  {
    if ((a5 & 1) != 0)
    {
      v17 = 0;
      v12 = &v17;
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
    }
    else
    {
      v10 = (_anonymous_namespace_ *)a1;
      v11 = a2;
      v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned int>(v10, v11, v12);
    for (i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      v14 = *(_QWORD *)(a1 + 128);
      v15 = *(_QWORD *)(a1 + 112) - 1;
      if (*(_BYTE *)(v14 + 48 * v15) != 2)
        ++*(_QWORD *)(v14 + 48 * v15 + 32);
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned int>(_anonymous_namespace_ *a1, const char *a2, _DWORD *a3)
{
  uint64_t result;
  _BYTE *v7;
  uint64_t v8;
  char v9;
  _BYTE v10[23];
  _OWORD v11[2];
  unint64_t __dst;

  __dst = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"UInt32");
  if ((_DWORD)result)
  {
    if (HIDWORD(__dst))
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if ((v9 & 1) != 0)
        v7 = *(_BYTE **)&v10[7];
      else
        v7 = v10;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "UInt32", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(_QWORD *)&v11[0])
      {
        if ((BYTE8(v11[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if ((v9 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v8 + 40))();
      }
      return 0;
    }
    else
    {
      *a3 = __dst;
      return 1;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  uint64_t v5;
  uint64_t v10;
  const char *v11;
  char *v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v18 = 0;
  v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if ((_DWORD)v5)
  {
    if ((a5 & 1) != 0)
    {
      v17 = 0;
      v12 = (char *)&v17;
      v10 = a1;
      v11 = a2;
    }
    else
    {
      v10 = a1;
      v11 = a2;
      v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readUint64(v10, v11, v12);
    for (i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      v14 = *(_QWORD *)(a1 + 128);
      v15 = *(_QWORD *)(a1 + 112) - 1;
      if (*(_BYTE *)(v14 + 48 * v15) != 2)
        ++*(_QWORD *)(v14 + 48 * v15 + 32);
    }
  }
  return v5;
}

uint64_t re::internal::serializeEnumAsBinary<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re::internal *a5, re::internal *a6, int a7)
{
  re::internal *v11;
  uint64_t result;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  void *v21;
  int v22;
  re::internal *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  unsigned int EnumConstantIndex;
  unsigned int v31;
  re::internal::TypeTranslationTable *v32;
  const void *v33;
  int v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD v56[4];
  uint64_t __src;
  _QWORD v58[4];

  if (a7)
  {
    v11 = *(re::internal **)(a1 + 208);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v11, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (!*(_BYTE *)(a1 + 64))
      return (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, _QWORD, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, 0, &__src, &__src, 1);
    return 0;
  }
  v15 = *(_QWORD **)a5;
  if (a5 == a6)
    goto LABEL_8;
  if (v15 == *(_QWORD **)a6)
  {
    v16 = **((_QWORD **)a5 + 2);
    v17 = (uint64_t *)*((_QWORD *)a6 + 2);
    v18 = *v17;
    if ((unsigned __int16)v16 == (unsigned __int16)*v17)
    {
      v20 = WORD1(v16) == WORD1(v18);
      v19 = (v18 ^ v16) & 0xFFFFFF00000000;
      v20 = v20 && v19 == 0;
      if (v20)
        goto LABEL_8;
    }
LABEL_21:
    v23 = *(re::internal **)(a1 + 208);
    re::TypeRegistry::typeInfo(v15, v17[9], &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v23, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (*(_DWORD *)(v58[1] + 8) < 9u)
    {
      v55 = 0;
      if (!*(_BYTE *)(a1 + 64)
        && (*(unsigned int (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, uint64_t *, uint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, a3, &v55, &__src, &__src, 0))
      {
        EnumConstantIndex = re::internal::getEnumConstantIndex(a6, (const re::TypeInfo *)&v55, v29);
        if ((EnumConstantIndex & 0x80000000) != 0)
        {
          v41 = v55;
          re::TypeInfo::name(a6);
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v42, v43, v44, v45, v46, v41);
        }
        else
        {
          v31 = EnumConstantIndex;
          v32 = *(re::internal::TypeTranslationTable **)(*(_QWORD *)a6 + 856);
          if (v32)
          {
            v33 = (const void *)re::internal::TypeTranslationTable::translateSerializedEnum(v32, a6, v31, a5);
            if (v33)
            {
              memcpy(a4, v33, *(unsigned int *)(*((_QWORD *)a5 + 2) + 8));
              v34 = 0;
              return v34 == 0;
            }
          }
          v56[0] = re::TypeInfo::enumConstants(a6);
          v56[1] = v47;
          v48 = *(_QWORD *)(re::Slice<re::EnumConstant>::operator[](v56, v31) + 16);
          re::TypeInfo::name(a5);
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Serialized enum constant \"%s\" does not exist in runtime type \"%s\".", v49, v50, v51, v52, v53, v48);
        }
      }
    }
    else
    {
      v54 = re::TypeInfo::name((re::TypeInfo *)&__src)[1];
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Enum type \"%s\" has invalid size: %zu bytes.", v24, v25, v26, v27, v28, v54);
    }
    v34 = 1;
    return v34 == 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
  {
    v15 = *(_QWORD **)a6;
    v17 = (uint64_t *)*((_QWORD *)a6 + 2);
    goto LABEL_21;
  }
  v15 = *(_QWORD **)a5;
LABEL_8:
  re::TypeRegistry::typeInfo(v15, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &__src);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
  __src = 0;
  if (*(_BYTE *)(a1 + 64))
    return 0;
  v22 = (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, _QWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, a3, &__src, v56, v56, 0);
  result = 0;
  if (v22)
  {
    if ((re::internal::getEnumConstantIndex(a5, (const re::TypeInfo *)&__src, v21) & 0x80000000) != 0)
    {
      v35 = __src;
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v36, v37, v38, v39, v40, v35);
      return 0;
    }
    memcpy(a4, &__src, *(unsigned int *)(*((_QWORD *)a5 + 2) + 8));
    return 1;
  }
  return result;
}

double re::EncoderOPACK<re::SeekableInputStream>::beginOptional(uint64_t a1, const char *a2, int a3, _BYTE *a4, int a5)
{
  uint64_t v9;
  double result;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 __dst;
  _OWORD v21[3];
  uint64_t v22;

  if (!*(_BYTE *)(a1 + 40))
  {
    v22 = 0;
    if ((re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v22, 0) & 1) != 0)
    {
      __dst = 0;
      if (*(_BYTE *)(a1 + 40))
      {
LABEL_4:
        v9 = *a4;
        LOBYTE(v15) = 3;
        DWORD1(v15) = a5;
        *((_QWORD *)&v15 + 1) = a2;
        v16 = 0;
        v18 = 0;
        v19 = 0;
        v17 = v9;
        result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v15);
        *(_QWORD *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 32) = v22;
        return result;
      }
      v11 = *(_QWORD *)(a1 + 168);
      if (v11)
      {
        v12 = v11 - 1;
        v13 = *(unsigned __int8 *)(a1 + v11 - 1 + 160);
        *(_QWORD *)(a1 + 168) = v12;
      }
      else
      {
        if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL) & 1) == 0)
        {
          re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Optional");
          goto LABEL_4;
        }
        v13 = __dst;
      }
      if (v13 == 4)
      {
        *a4 = 0;
      }
      else
      {
        *a4 = 1;
        v14 = *(_QWORD *)(a1 + 168);
        if (v14 <= 7)
        {
          *(_QWORD *)(a1 + 168) = v14 + 1;
          *(_BYTE *)(a1 + v14 + 160) = v13;
        }
      }
      goto LABEL_4;
    }
    *a4 = 0;
    LOBYTE(v21[0]) = 3;
    DWORD1(v21[0]) = a5;
    *((_QWORD *)&v21[0] + 1) = a2;
    memset(&v21[1], 0, 32);
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, v21);
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endOptional(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  const char *v8;
  _anonymous_namespace_ *v9;
  char v10;
  _BYTE v11[23];
  _OWORD v12[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14) - 1;
    if (*(_QWORD *)(v2 + 48 * v3 + 32) == *(_QWORD *)(v2 + 48 * v3 + 24))
    {
      for (i = *(_QWORD *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 3);
      v5 = *((_QWORD *)v1 + 16);
      v6 = *((_QWORD *)v1 + 14) - 1;
      if (*(_BYTE *)(v5 + 48 * v6) != 2)
        ++*(_QWORD *)(v5 + 48 * v6 + 32);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if ((v10 & 1) != 0)
        v7 = *(_BYTE **)&v11[7];
      else
        v7 = v11;
      if (*(uint64_t *)(*((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14) - 24) <= 0)
        v8 = "Optional should not have a value.";
      else
        v8 = "Optional requires a value.";
      re::DynamicString::format((re::DynamicString *)"Failed to serialize optional type \"%s\". %s", (re::DynamicString *)v12, v7, v8);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(_QWORD *)&v12[0])
      {
        if ((BYTE8(v12[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v12[0] + 40))();
        memset(v12, 0, sizeof(v12));
      }
      result = v9;
      if (v9 && (v10 & 1) != 0)
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v9 + 40))();
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginBLOB(uint64_t a1, const char *a2, int a3, uint64_t *a4, int a5)
{
  uint64_t result;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v16 = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v16, 0);
  if ((_DWORD)result)
  {
    re::EncoderOPACK<re::SeekableInputStream>::readDataTag(a1, a2, a4);
    v10 = *a4;
    LOBYTE(v11) = 4;
    DWORD1(v11) = a5;
    *((_QWORD *)&v11 + 1) = a2;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
    *(_QWORD *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 32) = v16;
    return *(_BYTE *)(a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeBLOB(uint64_t result, char *a2, char a3)
{
  _anonymous_namespace_ *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;

  if (*(_BYTE *)(result + 40))
    return result;
  v4 = (_anonymous_namespace_ *)result;
  v5 = *(_QWORD *)(result + 128) + 48 * *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(v5 - 24);
  v7 = *(_QWORD *)(result + 168);
  if (v7)
  {
    if (v7 >= v6)
      v8 = *(_QWORD *)(v5 - 24);
    else
      v8 = *(_QWORD *)(result + 168);
    v9 = v7 - v8;
    if ((uint64_t)(v7 - 1) >= (uint64_t)(v7 - v8))
    {
      do
      {
        *a2++ = *(_BYTE *)(result + 159 + v7);
        v10 = v7 - 2;
        --v7;
      }
      while (v10 >= v9);
    }
    *(_QWORD *)(result + 168) = v9;
    v11 = v6 - v8;
    if (v6 == v8)
      goto LABEL_15;
    goto LABEL_11;
  }
  v11 = *(_QWORD *)(v5 - 24);
  if (v6)
  {
LABEL_11:
    if ((a3 & 1) != 0)
      a2 = 0;
    result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, a2, v11);
    if ((result & 1) == 0)
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v4, 0, (uint64_t)"BLOB");
  }
LABEL_15:
  if ((a3 & 2) == 0)
  {
    v12 = *((_QWORD *)v4 + 16);
    v13 = *((_QWORD *)v4 + 14) - 1;
    if (*(_BYTE *)(v12 + 48 * v13) != 2)
      *(_QWORD *)(v12 + 48 * v13 + 32) += v6;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endBLOB(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  char v10;
  _BYTE v11[23];
  _OWORD v12[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14) - 1;
    if (*(_QWORD *)(v2 + 48 * v3 + 32) == *(_QWORD *)(v2 + 48 * v3 + 24))
    {
      for (i = *(_QWORD *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 4);
      v5 = *((_QWORD *)v1 + 16);
      v6 = *((_QWORD *)v1 + 14) - 1;
      if (*(_BYTE *)(v5 + 48 * v6) != 2)
        ++*(_QWORD *)(v5 + 48 * v6 + 32);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if ((v10 & 1) != 0)
        v7 = *(_BYTE **)&v11[7];
      else
        v7 = v11;
      v8 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize BLOB \"%s\". Expected number of bytes: %lld. Actual number of bytes: %lld.", (re::DynamicString *)v12, v7, *(_QWORD *)(v8 - 24), *(_QWORD *)(v8 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(_QWORD *)&v12[0])
      {
        if ((BYTE8(v12[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v12[0] + 40))();
        memset(v12, 0, sizeof(v12));
      }
      result = v9;
      if (v9 && (v10 & 1) != 0)
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v9 + 40))();
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginArray(uint64_t a1, const char *a2, int a3, char *a4, int a5)
{
  uint64_t result;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v16 = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v16, 0);
  if ((_DWORD)result)
  {
    re::EncoderOPACK<re::SeekableInputStream>::readArrayTag(a1, a2, a4);
    v10 = *(_QWORD *)a4;
    LOBYTE(v11) = 5;
    DWORD1(v11) = a5;
    *((_QWORD *)&v11 + 1) = a2;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
    *(_QWORD *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 32) = v16;
    return *(_BYTE *)(a1 + 40) == 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endArray(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  _BYTE *v8;
  uint64_t v9;
  const char *v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  _anonymous_namespace_ *v14;
  char v15;
  _BYTE v16[23];
  _OWORD __dst[2];

  if (*((_BYTE *)result + 40))
    return result;
  v1 = result;
  v2 = *((_QWORD *)result + 16);
  v3 = *((_QWORD *)result + 14) - 1;
  v4 = *(_QWORD *)(v2 + 48 * v3 + 32);
  if (v4 == *(_QWORD *)(v2 + 48 * v3 + 24))
  {
    if (v4 < 0xF)
    {
LABEL_22:
      for (i = *(_QWORD *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 5);
      v12 = *((_QWORD *)v1 + 16);
      v13 = *((_QWORD *)v1 + 14) - 1;
      if (*(_BYTE *)(v12 + 48 * v13) != 2)
        ++*(_QWORD *)(v12 + 48 * v13 + 32);
      return result;
    }
    LOBYTE(__dst[0]) = 0;
    v5 = *((_QWORD *)result + 21);
    if (v5)
    {
      v6 = v5 - 1;
      v7 = *((unsigned __int8 *)result + v6 + 160);
      LOBYTE(__dst[0]) = v7;
      *((_QWORD *)v1 + 21) = v6;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>(result, (char *)__dst, 1uLL))
      {
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v1, 0, (uint64_t)"Array");
LABEL_21:
        v2 = *((_QWORD *)v1 + 16);
        v3 = *((_QWORD *)v1 + 14) - 1;
        goto LABEL_22;
      }
      v7 = LOBYTE(__dst[0]);
    }
    if (v7 != 3)
    {
      v10 = re::OPACK::toString(v7);
      return (_anonymous_namespace_ *)re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag(v1, (uint64_t)"Array", (uint64_t)v10);
    }
    goto LABEL_21;
  }
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v14);
  if ((v15 & 1) != 0)
    v8 = *(_BYTE **)&v16[7];
  else
    v8 = v16;
  v9 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)__dst, v8, *(_QWORD *)(v9 - 24), *(_QWORD *)(v9 - 16));
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)__dst);
  if (*(_QWORD *)&__dst[0])
  {
    if ((BYTE8(__dst[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&__dst[0] + 40))();
    memset(__dst, 0, sizeof(__dst));
  }
  result = v14;
  if (v14 && (v15 & 1) != 0)
    return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v14 + 40))();
  return result;
}

uint64_t re::`anonymous namespace'::resizeArray<re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>>(uint64_t a1, void **a2, re::ArrayAccessor *a3, uint64_t a4, const re::TypeInfo *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BOOL4 v21;
  _BYTE v22[16];
  uint64_t v23;
  _BYTE v24[8];
  _QWORD v25[12];

  if ((const re::TypeInfo *)a4 == a5)
    return 1;
  v25[10] = v8;
  v25[11] = v9;
  v14 = *((_QWORD *)a3 + 2);
  if ((*(_DWORD *)(v14 + 84) & 0xFFFFFF) != 0)
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a3, *(_QWORD *)(v14 + 72), v24);
    re::TypeInfo::TypeInfo((uint64_t)v22, (uint64_t)v25);
    v21 = !is_mul_ok(*(unsigned int *)(v23 + 8), (unint64_t)a5);
    if (is_mul_ok(*(unsigned int *)(v23 + 8), (unint64_t)a5))
      re::ArrayAccessor::reset(a3, a2, *(re::Allocator **)(a1 + 48), a5);
    else
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Size overflow during deserialization. Element size = %zu, count = %zu", v16, v17, v18, v19, v20, *(_DWORD *)(v23 + 8));
    return !v21;
  }
  else
  {
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid array size. Expected size = %zu, actual size = %zu", a4, (uint64_t)a5, a6, a7, a8, a4);
    return 0;
  }
}

uint64_t re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::setError(_anonymous_namespace_ *a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  _BYTE *v12;
  char *v13;
  uint64_t result;
  uint64_t v15;
  char v16;
  _BYTE v17[23];
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21[3];
  char *v22;
  uint64_t *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;

  v24 = 0;
  v25 = 0;
  v26 = 0;
  re::DynamicString::setCapacity(&v23, 0);
  v22 = &a9;
  re::DynamicString::vassignf((re::DynamicString *)&v23, a3, &a9);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v15);
  if ((v16 & 1) != 0)
    v12 = *(_BYTE **)&v17[7];
  else
    v12 = v17;
  if ((v24 & 1) != 0)
    v13 = v25;
  else
    v13 = (char *)&v24 + 1;
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: %s", (re::DynamicString *)&v18, "deserialize", v12, v13);
  *(_QWORD *)&v21[0] = 400;
  *((_QWORD *)&v21[0] + 1) = &re::FoundationErrorCategory(void)::instance;
  *(_QWORD *)&v21[1] = v18;
  *((_QWORD *)&v21[2] + 1) = v20;
  *(__int128 *)((char *)&v21[1] + 8) = v19;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, v21);
  if (*(_QWORD *)&v21[1])
  {
    if ((BYTE8(v21[1]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v21[1] + 40))();
    memset(&v21[1], 0, 32);
  }
  if (v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  result = (uint64_t)v23;
  if (v23)
  {
    if ((v24 & 1) != 0)
      return (*(uint64_t (**)(void))(*v23 + 40))();
  }
  return result;
}

uint64_t re::`anonymous namespace'::resizeList<re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t v18;
  void (*v19)(uint64_t, _BYTE *, uint64_t, unint64_t);
  _BYTE v20[16];
  uint64_t v21;
  _BYTE v22[8];
  _QWORD v23[12];

  if (a4 == a5)
    return 1;
  v23[10] = v5;
  v23[11] = v6;
  re::TypeRegistry::typeInfo(*(_QWORD **)a3, *(_QWORD *)(*(_QWORD *)(a3 + 16) + 72), v22);
  re::TypeInfo::TypeInfo((uint64_t)v20, (uint64_t)v23);
  v17 = !is_mul_ok(*(unsigned int *)(v21 + 8), a5);
  if (is_mul_ok(*(unsigned int *)(v21 + 8), a5))
  {
    v18 = *(_QWORD *)(a1 + 48);
    v19 = *(void (**)(uint64_t, _BYTE *, uint64_t, unint64_t))(*(_QWORD *)(a3 + 16) + 88);
    re::TypeInfo::TypeInfo((uint64_t)v22, a3);
    v19(a2, v22, v18, a5);
  }
  else
  {
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Size overflow during deserialization. Element size = %zu, count = %zu", v12, v13, v14, v15, v16, *(_DWORD *)(v21 + 8));
  }
  return !v17;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginDictionary(uint64_t a1, const char *a2, int a3, char *a4, int a5)
{
  uint64_t result;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v16 = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v16, 0);
  if ((_DWORD)result)
  {
    re::EncoderOPACK<re::SeekableInputStream>::readDictionaryTag(a1, a2, a4);
    v10 = *(_QWORD *)a4;
    LOBYTE(v11) = 6;
    DWORD1(v11) = a5;
    *((_QWORD *)&v11 + 1) = a2;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
    *(_QWORD *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 32) = v16;
    return *(_BYTE *)(a1 + 40) == 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endDictionaryEntry(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _BYTE *v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  _OWORD v8[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == 2)
    {
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 7);
      v2 = *(_QWORD *)(v1 + 128);
      v3 = *(_QWORD *)(v1 + 112) - 1;
      if (*(_BYTE *)(v2 + 48 * v3) != 2)
        ++*(_QWORD *)(v2 + 48 * v3 + 32);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v4 = *(_BYTE **)&v7[7];
      else
        v4 = v7;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary entry \"%s\". Expected 2 objects (key+value). Actual number of objects: %lld.", (re::DynamicString *)v8, v4, *(_QWORD *)(*(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112) - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(_QWORD *)&v8[0])
      {
        if ((BYTE8(v8[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v8[0] + 40))();
        memset(v8, 0, sizeof(v8));
      }
      result = v5;
      if (v5 && (v6 & 1) != 0)
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endDictionary(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  _BYTE *v8;
  uint64_t v9;
  const char *v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  _anonymous_namespace_ *v14;
  char v15;
  _BYTE v16[23];
  _OWORD __dst[2];

  if (*((_BYTE *)result + 40))
    return result;
  v1 = result;
  v2 = *((_QWORD *)result + 16);
  v3 = *((_QWORD *)result + 14) - 1;
  v4 = *(_QWORD *)(v2 + 48 * v3 + 32);
  if (v4 == *(_QWORD *)(v2 + 48 * v3 + 24))
  {
    if (v4 < 0xF)
    {
LABEL_22:
      for (i = *(_QWORD *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 6);
      v12 = *((_QWORD *)v1 + 16);
      v13 = *((_QWORD *)v1 + 14) - 1;
      if (*(_BYTE *)(v12 + 48 * v13) != 2)
        ++*(_QWORD *)(v12 + 48 * v13 + 32);
      return result;
    }
    LOBYTE(__dst[0]) = 0;
    v5 = *((_QWORD *)result + 21);
    if (v5)
    {
      v6 = v5 - 1;
      v7 = *((unsigned __int8 *)result + v6 + 160);
      LOBYTE(__dst[0]) = v7;
      *((_QWORD *)v1 + 21) = v6;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>(result, (char *)__dst, 1uLL))
      {
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v1, 0, (uint64_t)"Dictionary");
LABEL_21:
        v2 = *((_QWORD *)v1 + 16);
        v3 = *((_QWORD *)v1 + 14) - 1;
        goto LABEL_22;
      }
      v7 = LOBYTE(__dst[0]);
    }
    if (v7 != 3)
    {
      v10 = re::OPACK::toString(v7);
      return (_anonymous_namespace_ *)re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag(v1, (uint64_t)"Dictionary", (uint64_t)v10);
    }
    goto LABEL_21;
  }
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v14);
  if ((v15 & 1) != 0)
    v8 = *(_BYTE **)&v16[7];
  else
    v8 = v16;
  v9 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)__dst, v8, *(_QWORD *)(v9 - 24), *(_QWORD *)(v9 - 16));
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)__dst);
  if (*(_QWORD *)&__dst[0])
  {
    if ((BYTE8(__dst[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&__dst[0] + 40))();
    memset(__dst, 0, sizeof(__dst));
  }
  result = v14;
  if (v14 && (v15 & 1) != 0)
    return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v14 + 40))();
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginObject(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char v12;
  const char *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned __int8 __dst;
  uint64_t v20;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v20 = 0;
  if (!re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v20, 0))
    return 0;
  __dst = 0;
  if (*(_BYTE *)(a1 + 40))
    return 0;
  v9 = *(_QWORD *)(a1 + 168);
  if (v9)
  {
    v10 = v9 - 1;
    v11 = *(unsigned __int8 *)(a1 + v10 + 160);
    __dst = *(_BYTE *)(a1 + v10 + 160);
    *(_QWORD *)(a1 + 168) = v10;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL) & 1) == 0)
    {
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Object");
      return 0;
    }
    v11 = __dst;
  }
  if (v11 != 223 && v11 != 239)
  {
    v13 = re::OPACK::toString(v11);
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, (uint64_t)"Object", (uint64_t)v13);
    return 0;
  }
  v7 = 1;
  if (v11 == 223)
    v12 = 1;
  else
    v12 = 2;
  LOBYTE(v14) = v12;
  DWORD1(v14) = a4;
  *((_QWORD *)&v14 + 1) = a2;
  v15 = 0;
  v16 = 0;
  v17 = 0xFFFFFFFF80000000;
  v18 = 0;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v14);
  *(_QWORD *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 32) = v20;
  return v7;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::endObject(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 __dst;

  if (*(_BYTE *)(result + 40))
    return result;
  v1 = result;
  __dst = 0;
  while (1)
  {
    v2 = *(_QWORD *)(v1 + 168);
    if (v2)
    {
      v3 = v2 - 1;
      v4 = *(unsigned __int8 *)(v1 + v2 - 1 + 160);
      __dst = v4;
      *(_QWORD *)(v1 + 168) = v3;
      goto LABEL_7;
    }
    result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)v1, (char *)&__dst, 1uLL);
    if (!(_DWORD)result)
      break;
    v4 = __dst;
LABEL_7:
    if (v4 == 3)
      goto LABEL_13;
    v5 = *(_QWORD *)(v1 + 168);
    if (v5 <= 7)
    {
      *(_QWORD *)(v1 + 168) = v5 + 1;
      *(_BYTE *)(v1 + v5 + 160) = v4;
    }
    result = re::EncoderOPACK<re::SeekableInputStream>::skipObject(v1);
    if (*(_BYTE *)(v1 + 40))
      return result;
  }
  result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v1, 0, (uint64_t)"Object");
LABEL_13:
  if (!*(_BYTE *)(v1 + 40))
  {
    v6 = *(_QWORD *)(v1 + 128);
    v7 = *(_QWORD *)(v1 + 112) - 1;
    v8 = *(_QWORD *)(v6 + 48 * v7 + 16);
    if (v8)
    {
      do
      {
        --v8;
        re::EncoderOPACK<re::SeekableInputStream>::skipObject(v1);
      }
      while (v8);
      v6 = *(_QWORD *)(v1 + 128);
      v7 = *(_QWORD *)(v1 + 112) - 1;
    }
    result = (uint64_t)re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState((_anonymous_namespace_ *)v1, *(unsigned __int8 *)(v6 + 48 * v7));
    v9 = *(_QWORD *)(v1 + 128);
    v10 = *(_QWORD *)(v1 + 112) - 1;
    if (*(_BYTE *)(v9 + 48 * v10) != 2)
      ++*(_QWORD *)(v9 + 48 * v10 + 32);
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, _QWORD *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  int v20;
  _BOOL8 result;
  _anonymous_namespace_ *v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  char *v34;
  unint64_t v35;

  v9 = (int)a3;
  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v35 = 0;
    v20 = re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v35, 0);
    result = 0;
    if (!v20)
      return result;
    if (v35)
      re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  v23 = a4[1];
  if ((v23 & 1) != 0)
    v24 = v23 >> 1;
  else
    v24 = v23 >> 1;
  v35 = v24;
  v25 = re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v35, 0);
  result = 0;
  if (v25)
  {
    v26 = v35;
    if (v26 <= (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
    {
      if (!*a4)
      {
        v33 = v35 + 1;
        *a4 = *(_QWORD *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v33);
      }
      re::DynamicString::resize(a4, v35, 0);
      if (v35)
      {
        if ((a4[1] & 1) != 0)
          v34 = (char *)a4[2];
        else
          v34 = (char *)a4 + 9;
        re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, v34, 0);
      }
      v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      re::EncoderOPACK<re::SeekableInputStream>::endString(v22);
      return *(_BYTE *)(a1 + 64) == 0;
    }
    v27 = v35;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v28, v29, v30, v31, v32, v27);
    return 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginString(uint64_t a1, const char *a2, int a3, uint64_t *a4, int a5)
{
  uint64_t result;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v16 = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v16, 0);
  if ((_DWORD)result)
  {
    re::EncoderOPACK<re::SeekableInputStream>::readStringTag(a1, a2, a4);
    v10 = *a4;
    LOBYTE(v11) = 8;
    DWORD1(v11) = a5;
    *((_QWORD *)&v11 + 1) = a2;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
    *(_QWORD *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 32) = v16;
    return *(_BYTE *)(a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeString(uint64_t result, char *a2, char a3)
{
  _anonymous_namespace_ *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;

  if (*(_BYTE *)(result + 40))
    return result;
  v4 = (_anonymous_namespace_ *)result;
  v5 = *(_QWORD *)(result + 128) + 48 * *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(v5 - 24);
  v7 = *(_QWORD *)(result + 168);
  if (v7)
  {
    if (v7 >= v6)
      v8 = *(_QWORD *)(v5 - 24);
    else
      v8 = *(_QWORD *)(result + 168);
    v9 = v7 - v8;
    if ((uint64_t)(v7 - 1) >= (uint64_t)(v7 - v8))
    {
      do
      {
        *a2++ = *(_BYTE *)(result + 159 + v7);
        v10 = v7 - 2;
        --v7;
      }
      while (v10 >= v9);
    }
    *(_QWORD *)(result + 168) = v9;
    v11 = v6 - v8;
    if (v6 == v8)
      goto LABEL_15;
    goto LABEL_11;
  }
  v11 = *(_QWORD *)(v5 - 24);
  if (v6)
  {
LABEL_11:
    if ((a3 & 1) != 0)
      a2 = 0;
    result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, a2, v11);
    if ((result & 1) == 0)
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v4, 0, (uint64_t)"String");
  }
LABEL_15:
  if ((a3 & 2) == 0)
  {
    v12 = *((_QWORD *)v4 + 16);
    v13 = *((_QWORD *)v4 + 14) - 1;
    if (*(_BYTE *)(v12 + 48 * v13) != 2)
      *(_QWORD *)(v12 + 48 * v13 + 32) += v6;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endString(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  char v10;
  _BYTE v11[23];
  _OWORD v12[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14) - 1;
    if (*(_QWORD *)(v2 + 48 * v3 + 32) == *(_QWORD *)(v2 + 48 * v3 + 24))
    {
      for (i = *(_QWORD *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 8);
      v5 = *((_QWORD *)v1 + 16);
      v6 = *((_QWORD *)v1 + 14) - 1;
      if (*(_BYTE *)(v5 + 48 * v6) != 2)
        ++*(_QWORD *)(v5 + 48 * v6 + 32);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if ((v10 & 1) != 0)
        v7 = *(_BYTE **)&v11[7];
      else
        v7 = v11;
      v8 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize string \"%s\". Expected number of characters: %lld. Actual number of characters: %lld.", (re::DynamicString *)v12, v7, *(_QWORD *)(v8 - 24), *(_QWORD *)(v8 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(_QWORD *)&v12[0])
      {
        if ((BYTE8(v12[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v12[0] + 40))();
        memset(v12, 0, sizeof(v12));
      }
      result = v9;
      if (v9 && (v10 & 1) != 0)
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v9 + 40))();
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::SeekableInputStream>>(_BYTE *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result;
  unint64_t i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  _BYTE v15[32];
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18[2];
  uint64_t v19;
  unint64_t v20;
  _BYTE v21[8];
  uint64_t v22;
  _BYTE v23[8];
  uint64_t v24;

  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v21);
  if (v21[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)&v22);
    if (*(_DWORD *)(v19 + 88) || (re::TypeRegistry::typeInfo(v18[0], *(_QWORD *)(v19 + 72), v23), v23[0]))
    {
      if (re::EncoderOPACK<re::SeekableInputStream>::beginObject((uint64_t)(a1 + 24), "@super", 0, 0))
      {
        re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::SeekableInputStream>>(a1, a2, v18, a4);
        re::EncoderOPACK<re::SeekableInputStream>::endObject((uint64_t)(a1 + 24));
      }
    }
  }
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v18, *a3, a3[2]);
  if (v20)
  {
    for (i = 0; i < v20; ++i)
    {
      if (a1[64])
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v18, i, (uint64_t)&v16);
      if (*(_BYTE *)(v17 + 28))
      {
        v10 = *(_QWORD *)(v17 + 16);
        if (strlen((const char *)v10) >= 3 && *(_BYTE *)v10 == 109)
          v10 += 2 * (*(_BYTE *)(v10 + 1) == 95);
        v11 = *(unsigned int *)(v17 + 32);
        v12 = a2 + *(unsigned int *)(v17 + 24);
        re::TypeRegistry::typeInfo(v16, *(_QWORD *)v17, v23);
        re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v24);
        if (a1[64]
          || (result = (*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v10, v11, v12, v15, v15, a4), (result & 1) == 0))
        {
          result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a3);
          if (v13)
          {
            v14 = (_DWORD *)(result + 16);
            while (i != *v14)
            {
              v14 += 6;
              if (!--v13)
                goto LABEL_22;
            }
            if (!a1[64])
              result = (*(uint64_t (**)(_BYTE *, _QWORD, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, *((_QWORD *)v14 - 1), v11, v12, v15, v15, a4);
          }
        }
      }
LABEL_22:
      ;
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  const re::TypeInfo *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  uint64_t v29;
  uint64_t v30;
  re *v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  NSObject *v35;
  uint64_t v36;
  re::internal *v37;
  uint64_t v38;
  _BYTE v39[32];
  _BYTE v40[32];
  _QWORD *v41[2];
  uint64_t v42;
  _QWORD *v43[2];
  uint64_t v44;
  uint64_t v45[4];
  unint64_t v46;
  uint64_t v47[5];
  _BYTE v48[8];
  uint64_t v49;
  char v50;
  uint64_t *v51;
  _BYTE v52[8];
  uint64_t v53;
  char v54;
  uint64_t *v55;
  uint8_t buf[4];
  uint64_t v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v52);
  re::TypeRegistry::typeInfo((_QWORD *)*a4, *(_QWORD *)(a4[2] + 72), v48);
  if (v48[0])
  {
    if (!v52[0])
    {
      v11 = re::TypeInfo::name((re::TypeInfo *)&v49)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (re::EncoderOPACK<re::SeekableInputStream>::beginObject(a1 + 24, "@super", 0, 0))
    {
      if (v53 == v49)
      {
        v18 = *v55;
        v19 = *v51;
        if ((unsigned __int16)*v55 == (unsigned __int16)*v51)
        {
          v21 = WORD1(v18) == WORD1(v19);
          v20 = (v19 ^ v18) & 0xFFFFFF00000000;
          v21 = v21 && v20 == 0;
          if (v21)
            goto LABEL_6;
        }
      }
      else if (re::areSameTranslatedVersion((re *)&v53, (const re::TypeInfo *)&v49, v10))
      {
LABEL_6:
        re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::SeekableInputStream>>((_BYTE *)a1, a2, &v53, a5);
LABEL_16:
        re::EncoderOPACK<re::SeekableInputStream>::endObject(a1 + 24);
        goto LABEL_17;
      }
      if (v54 == v50)
      {
        re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::SeekableInputStream>>(a1, a2, &v53, &v49, a5);
      }
      else
      {
        v22 = re::TypeInfo::name((re::TypeInfo *)&v53)[1];
        re::TypeInfo::name((re::TypeInfo *)&v49);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
      }
      goto LABEL_16;
    }
  }
LABEL_17:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v47, *a3, a3[2]);
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v45, *a4, a4[2]);
  if (v46)
  {
    for (i = 0; i < v46; ++i)
    {
      if (*(_BYTE *)(a1 + 64))
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[](v45, i, (uint64_t)v43);
      if (*(_BYTE *)(v44 + 28))
      {
        v29 = *(_QWORD *)(v44 + 16);
        if (strlen((const char *)v29) >= 3 && *(_BYTE *)v29 == 109)
          v29 += 2 * (*(_BYTE *)(v29 + 1) == 95);
        v30 = *(unsigned int *)(v44 + 32);
        v31 = *(re **)(*a4 + 856);
        if (!v31
          || (v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v43),
              (_DWORD)v31 == -1))
        {
          v35 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            v36 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            v57 = v36;
            v58 = 2080;
            v59 = v29;
            _os_log_impl(&dword_224FE9000, v35, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          v37 = *(re::internal **)(a1 + 208);
          re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v57 + 4);
          result = re::internal::translateType(v37, (const re::TypeRegistry *)v41, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint8_t *, uint8_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
        }
        else
        {
          re::TypeMemberCollection::operator[](v47, (int)v31, (uint64_t)v41);
          v32 = a2 + *(unsigned int *)(v42 + 24);
          re::TypeRegistry::typeInfo(v41[0], *(_QWORD *)v42, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
          re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
          if (*(_BYTE *)(a1 + 64)
            || (result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, v32, v40, v39, a5), (result & 1) == 0))
          {
            result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a4);
            if (v33)
            {
              v34 = (_DWORD *)(result + 16);
              while (i != *v34)
              {
                v34 += 6;
                if (!--v33)
                  goto LABEL_37;
              }
              v38 = *((_QWORD *)v34 - 1);
              re::TypeRegistry::typeInfo(v41[0], *(_QWORD *)v42, buf);
              re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
              re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
              result = re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
              if (!*(_BYTE *)(a1 + 64))
                result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v38, v30, v32, v40, v39, a5);
            }
          }
        }
      }
LABEL_37:
      ;
    }
  }
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2E7D8;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  return re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
}

void re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2E7D8;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

void re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re::TypeInfo *this, const re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 272)
    && (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **(_QWORD **)(a2 + 16) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, unsigned __int8 *, re::TypeInfo *, const re::TypeInfo *, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  double v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24ED2E840;
  if (*(_QWORD *)(a1 + 272))
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 288);
    *(_QWORD *)(a1 + 272) = 0;
  }
  v2 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 288));
  v3 = *(_QWORD *)(a1 + 216);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 248))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *(_QWORD *)(a1 + 248) = 0;
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 216) = 0;
    ++*(_DWORD *)(a1 + 240);
  }
  re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::close((_QWORD *)(a1 + 24));
  v4 = *(_QWORD *)(a1 + 120);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 152))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    ++*(_DWORD *)(a1 + 144);
  }
  if (*(_BYTE *)(a1 + 64))
  {
    v5 = *(_QWORD *)(a1 + 88);
    if (v5)
    {
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a1 + 104));
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
    }
  }
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

_QWORD *re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::close(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t String;
  size_t v4;
  int *v5;
  void **v6;
  char *v7;
  size_t v8;
  uint64_t v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  char v18;

  if (*result)
  {
    v1 = result;
    if (result[21])
    {
      v2 = (_QWORD *)result[20];
      if (v2)
      {
        String = rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::GetString(v2);
        v4 = *(_QWORD *)(v1[20] + 24) - *(_QWORD *)(v1[20] + 16);
        v5 = (int *)(v1 + 2);
        v6 = (void **)(v1 + 1);
        if (String)
        {
          v7 = (char *)String;
          while (1)
          {
            v8 = *v5;
            if (v4 <= v8)
              break;
            if ((int)v8 >= 1)
            {
              memcpy(*v6, v7, v8);
              v9 = *v5;
              v7 += v9;
              v4 -= v9;
              *v6 = 0;
              *v5 = 0;
            }
            v10 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, _QWORD *, _QWORD *))(*(_QWORD *)*v1 + 16))(*v1, v1 + 1, v1 + 2);
            if ((v10 & 1) == 0)
              goto LABEL_10;
          }
          memcpy(*v6, v7, v4);
LABEL_14:
          *v6 = (char *)*v6 + v4;
          *v5 -= v4;
        }
        else
        {
          do
          {
            v16 = *v5;
            if (v4 <= v16)
            {
              bzero(*v6, v4);
              goto LABEL_14;
            }
            if ((int)v16 >= 1)
            {
              bzero(*v6, v16);
              v4 -= *v5;
              *v6 = 0;
              *v5 = 0;
            }
            v10 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, _QWORD *, _QWORD *))(*(_QWORD *)*v1 + 16))(*v1, v1 + 1, v1 + 2);
          }
          while ((v10 & 1) != 0);
LABEL_10:
          re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)&v17);
          if (v17 && (v18 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v17 + 40))();
        }
        v11 = v1[20];
        if (v11)
        {
          v12 = v1[3];
          rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy(v1[20]);
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v12 + 40))(v12, v11);
        }
        v1[20] = 0;
        v13 = v1[21];
        if (v13)
        {
          v14 = v1[3];
          rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy(v13 + 8);
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 40))(v14, v13);
        }
        v15 = v1[24];
        v1[21] = 0;
        if (v15)
        {
          if (v1[28])
            (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
          v1[28] = 0;
          v1[25] = 0;
          v1[26] = 0;
          v1[24] = 0;
          ++*((_DWORD *)v1 + 54);
        }
      }
    }
    if (!*((_BYTE *)v1 + 40))
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState((_anonymous_namespace_ *)v1, 0);
    result = (_QWORD *)v1[12];
    if (result)
    {
      if (v1[16])
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
      v1[16] = 0;
      v1[13] = 0;
      v1[14] = 0;
      v1[12] = 0;
      ++*((_DWORD *)v1 + 30);
    }
    if (*((int *)v1 + 4) >= 1)
    {
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 24))(*v1);
      v1[1] = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *v1 = 0;
    v1[3] = 0;
    v1[4] = 0;
  }
  return result;
}

uint64_t rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::GetString(_QWORD *a1)
{
  _BYTE *v2;
  uint64_t result;

  v2 = (_BYTE *)a1[3];
  if ((uint64_t)(a1[4] - (_QWORD)v2) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>((uint64_t)a1, 1);
    v2 = (_BYTE *)a1[3];
  }
  a1[3] = v2 + 1;
  *v2 = 0;
  result = a1[2];
  --a1[3];
  return result;
}

char *rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(uint64_t a1, uint64_t a2)
{
  void *v4;
  size_t v5;
  size_t v6;
  re::internal::RapidJSONAllocator *v7;
  uint64_t v8;
  size_t v9;
  char *result;

  v4 = *(void **)(a1 + 16);
  if (v4)
  {
    v5 = *(_QWORD *)(a1 + 32) - (_QWORD)v4;
    v6 = v5 + ((v5 + 1) >> 1);
    v7 = *(re::internal::RapidJSONAllocator **)a1;
  }
  else
  {
    v7 = *(re::internal::RapidJSONAllocator **)a1;
    if (*(_QWORD *)a1)
    {
      v4 = 0;
    }
    else
    {
      v7 = (re::internal::RapidJSONAllocator *)(*(uint64_t (**)(void *, uint64_t, _QWORD))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                                                  + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 1, 0);
      *(_QWORD *)a1 = v7;
      *(_QWORD *)(a1 + 8) = v7;
      v4 = *(void **)(a1 + 16);
    }
    v6 = *(_QWORD *)(a1 + 40);
    v5 = *(_QWORD *)(a1 + 32) - (_QWORD)v4;
  }
  v8 = *(_QWORD *)(a1 + 24) - (_QWORD)v4;
  if (v6 <= v8 + a2)
    v9 = v8 + a2;
  else
    v9 = v6;
  result = (char *)re::internal::RapidJSONAllocator::Realloc(v7, v4, v5, v9);
  *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 24) = &result[v8];
  *(_QWORD *)(a1 + 32) = &result[v9];
  return result;
}

void *re::internal::RapidJSONAllocator::Realloc(re::internal::RapidJSONAllocator *this, void *a2, size_t a3, size_t a4)
{
  void *v5;
  void *v8;
  size_t v9;

  if (a3 != a4)
  {
    if (a4)
    {
      v8 = (void *)(*(uint64_t (**)(void *, size_t, _QWORD))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                     + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, a4, 0);
      v5 = v8;
      if (a3 && a2 && v8)
      {
        if (a4 >= a3)
          v9 = a3;
        else
          v9 = a4;
        memcpy(v8, a2, v9);
        goto LABEL_13;
      }
    }
    else
    {
      v5 = 0;
    }
    if (!a2)
      return v5;
LABEL_13:
    (*(void (**)(void *, void *))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                           + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, a2);
    return v5;
  }
  return a2;
}

uint64_t rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy(uint64_t result)
{
  uint64_t v1;

  v1 = result;
  if (*(_QWORD *)(result + 16))
    result = (*(uint64_t (**)(void *))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                               + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
  if (*(_QWORD *)(v1 + 8))
    return (*(uint64_t (**)(void *))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                             + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
  return result;
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  _BYTE *v12;
  char *v13;
  uint64_t result;
  uint64_t v15;
  char v16;
  _BYTE v17[23];
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21[3];
  char *v22;
  uint64_t *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;

  v24 = 0;
  v25 = 0;
  v26 = 0;
  re::DynamicString::setCapacity(&v23, 0);
  v22 = &a9;
  re::DynamicString::vassignf((re::DynamicString *)&v23, a3, &a9);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)(a1 + 24), a2, (re::DynamicString *)&v15);
  if ((v16 & 1) != 0)
    v12 = *(_BYTE **)&v17[7];
  else
    v12 = v17;
  if ((v24 & 1) != 0)
    v13 = v25;
  else
    v13 = (char *)&v24 + 1;
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: %s", (re::DynamicString *)&v18, "serialize", v12, v13);
  *(_QWORD *)&v21[0] = 400;
  *((_QWORD *)&v21[0] + 1) = &re::FoundationErrorCategory(void)::instance;
  *(_QWORD *)&v21[1] = v18;
  *((_QWORD *)&v21[2] + 1) = v20;
  *(__int128 *)((char *)&v21[1] + 8) = v19;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1 + 24, v21);
  if (*(_QWORD *)&v21[1])
  {
    if ((BYTE8(v21[1]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v21[1] + 40))();
    memset(&v21[1], 0, 32);
  }
  if (v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  result = (uint64_t)v23;
  if (v23)
  {
    if ((v24 & 1) != 0)
      return (*(uint64_t (**)(void))(*v23 + 40))();
  }
  return result;
}

uint64_t re::serializeType<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re::TypeInfo *this, const re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t result;
  uint64_t v26;
  int v27;
  int v28;
  const re::TypeInfo *v29;
  uint64_t *v30;
  int v31;
  unint64_t v32;
  char *v33;
  const char *v34;
  uint64_t v35;
  re::UnionAccessor *v36;
  unint64_t Tag;
  unint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v44;
  uint64_t v45;
  _anonymous_namespace_ *v46;
  uint64_t v47;
  double v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v54;
  _QWORD *v55;
  int v56;
  re::internal *v57;
  uint64_t v58;
  void (*v59)(uint64_t, _QWORD, _QWORD, _QWORD, rapidjson::internal **, rapidjson::internal **, uint64_t);
  _QWORD *v60;
  int v61;
  unint64_t v62;
  int v63;
  uint64_t v64;
  void (*v65)(uint64_t, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD);
  int v66;
  int v67;
  _anonymous_namespace_ *v68;
  uint64_t v69;
  BOOL v70;
  char v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  re::internal *v77;
  uint64_t v78;
  void (*v79)(uint64_t, _QWORD, _QWORD, _QWORD, rapidjson::internal **, rapidjson::internal **, uint64_t);
  _BOOL4 v80;
  unint64_t v81;
  uint64_t v82;
  void (*v83)(uint64_t, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD);
  _BOOL4 v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char *v91;
  const char *v92;
  char *v93;
  uint64_t v94;
  uint64_t v95;
  re::internal *v96;
  re::internal *v97;
  _anonymous_namespace_ *v98;
  re::TypeInfo *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(uint64_t, const char *, _QWORD, uint64_t, _QWORD *, uint64_t *, _QWORD);
  uint64_t v107;
  void (*v108)(uint64_t, const char *, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD);
  unint64_t v109;
  _QWORD *v110;
  unint64_t *v111;
  unint64_t v112;
  unint64_t v113;
  uint64_t (**v114)(uint64_t, uint64_t);
  uint64_t (*v115)(uint64_t, uint64_t);
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  __n128 v119;
  uint64_t v120;
  unint64_t v121;
  double v122;
  unint64_t v123;
  void (*v124)(void);
  unint64_t v125;
  BOOL v126;
  char v127;
  unint64_t v128;
  uint64_t v129;
  char *v130;
  uint64_t (*v131)(unsigned __int8 *, _QWORD);
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  double v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  rapidjson::internal *v141;
  uint64_t v142;
  unint64_t v143;
  int v144;
  char *v145;
  unint64_t v146;
  _BYTE v147[16];
  uint64_t v148;
  _BYTE v149[32];
  uint64_t v150[4];
  uint64_t v151[4];
  _QWORD v152[4];
  uint64_t v153;
  _BYTE v154[18];
  __int16 v155;
  unint64_t v156;
  __int16 v157;
  unint64_t v158;
  __n128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  uint64_t v164;

  v164 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_18;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        goto LABEL_18;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
      goto LABEL_221;
    v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
    if (v19)
      v20 = *(_DWORD *)(v19 + 16);
    else
      v20 = -1;
    v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
    if (v21)
      v22 = *(_DWORD *)(v21 + 16);
    else
      v22 = -1;
    if (v20 != v22)
    {
      v26 = re::TypeInfo::name(this)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
      LOBYTE(v139) = v26;
      v34 = "Cannot serialize type \"%s\" version %u as version %u. Downgrading versions is not supported.";
LABEL_61:
      re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, v34, (uint64_t)a4, (uint64_t)this, (uint64_t)a6, a7, a8, v139);
      return 0;
    }
    goto LABEL_18;
  }
  if (!re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_10;
LABEL_18:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      if (this == a6)
        goto LABEL_22;
      if (*(_QWORD *)this != *(_QWORD *)a6)
      {
        if (!re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_221;
LABEL_22:
        v23 = re::TypeInfo::name(this);
        v24 = (unint64_t)*v23 >> 1;
        if (v24 <= 0xCA3DEFB5)
        {
          if ((unint64_t)*v23 >> 1 <= 0x5D0225B)
          {
            if ((unint64_t)*v23 >> 1 <= 0x2E9355)
            {
              if (v24 != 104431)
              {
                if (v24 == 3029738)
                  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, a4);
LABEL_264:
                v139 = re::TypeInfo::name(this)[1];
                v34 = "Unsupported basic type \"%s\".";
                goto LABEL_61;
              }
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, (unsigned int *)a4);
            }
            if (v24 == 3052374)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)a4);
            v129 = 3327612;
LABEL_229:
            if (v24 == v129)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, (unint64_t *)a4);
            goto LABEL_264;
          }
          if ((unint64_t)*v23 >> 1 > 0xB0F77BD0)
          {
            if (v24 == 2969009105)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (uint64_t)a3, (double *)a4, a7);
            if (v24 == 3111160798)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, (char *)a4);
            goto LABEL_264;
          }
          if (v24 == 97526364)
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (uint64_t)a3, (float *)a4, a7);
          v35 = 109413500;
LABEL_156:
          if (v24 == v35)
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, (__int16 *)a4);
          goto LABEL_264;
        }
        if ((unint64_t)*v23 >> 1 > 0x18E6A9A092)
        {
          if ((unint64_t)*v23 >> 1 <= 0x303EE8780EDLL)
          {
            if (v24 == 0x18E6A9A093)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, a4);
            if (v24 == 0x303EE86A734)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, (unsigned __int16 *)a4);
            goto LABEL_264;
          }
          if (v24 == 0x303EE8780EELL)
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, (uint64_t)a3, (unsigned int *)a4, a7);
          if (v24 != 0x303EE88E58DLL)
            goto LABEL_264;
        }
        else
        {
          if ((unint64_t)*v23 >> 1 > 0x16749DFF02)
          {
            if (v24 == 0x16749DFF03)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, (unsigned int *)a4);
            v129 = 0x16749F63A2;
            goto LABEL_229;
          }
          if (v24 != 3393056694)
          {
            v35 = 0x16749D2549;
            goto LABEL_156;
          }
        }
        return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, (rapidjson::internal **)a4);
      }
      v40 = **((_QWORD **)this + 2);
      v41 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v40 == (unsigned __int16)v41)
      {
        v18 = WORD1(v40) == WORD1(v41);
        v42 = (v41 ^ v40) & 0xFFFFFF00000000;
        if (v18 && v42 == 0)
          goto LABEL_22;
      }
      goto LABEL_221;
    case 2:
      return re::serializeEnum<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, (re::TypeInfo *)a4, (uint64_t)this, (uint64_t)a6, a7);
    case 3:
      if (this == a6)
        goto LABEL_90;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v44 = **((_QWORD **)this + 2);
        v45 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v44 == (unsigned __int16)v45
          && WORD1(v44) == WORD1(v45)
          && ((v45 ^ v44) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_90;
        }
        v27 = 3;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_90;
        v27 = *((unsigned __int8 *)this + 12);
      }
      if (v27 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_221;
LABEL_90:
      if ((_DWORD)a7)
      {
        v159.n128_u8[0] = 0;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(a1 + 24, a2, &v159);
        v46 = (_anonymous_namespace_ *)(a1 + 24);
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v159);
        re::TypeInfo::TypeInfo((uint64_t)&v141, (uint64_t)&v159.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v159);
        re::TypeInfo::TypeInfo((uint64_t)v154, (uint64_t)&v159.n128_i64[1]);
        re::TypeInfo::TypeInfo((uint64_t)&v159, (uint64_t)this);
        v47 = (*(uint64_t (**)(unsigned __int8 *))(v160 + 80))(a4);
        LOBYTE(v152[0]) = v47 != 0;
        v48 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(a1 + 24, a2, v152);
        if (v47)
        {
          v49 = (*(uint64_t (**)(unsigned __int8 *, double))(v160 + 80))(a4, v48);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, v49, &v141, v154, 0);
        }
        v46 = (_anonymous_namespace_ *)(a1 + 24);
      }
      re::EncoderBinary<re::SeekableInputStream>::endOptional(v46);
      return *(_BYTE *)(a1 + 64) == 0;
    case 4:
      if (this == a6)
        goto LABEL_105;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v50 = **((_QWORD **)this + 2);
        v51 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v50 == (unsigned __int16)v51)
        {
          v18 = WORD1(v50) == WORD1(v51);
          v52 = (v51 ^ v50) & 0xFFFFFF00000000;
          if (v18 && v52 == 0)
            goto LABEL_105;
        }
      }
      else if (re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_105;
      }
      if (*((_BYTE *)a6 + 12) != 4)
        goto LABEL_221;
      v54 = *((_QWORD *)this + 2);
      v55 = (_QWORD *)*((_QWORD *)a6 + 2);
      v56 = *((_DWORD *)v55 + 21) & 0xFFFFFF;
      if ((*(_DWORD *)(v54 + 84) & 0xFFFFFF) == 0)
      {
        if (!v56 && *(_DWORD *)(v54 + 88) == *((_DWORD *)v55 + 22))
          goto LABEL_105;
LABEL_221:
        re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, this, a6);
        return 0;
      }
      if (!v56)
        goto LABEL_221;
LABEL_105:
      if ((_DWORD)a7)
      {
        v57 = *(re::internal **)(a1 + 272);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v159);
        re::TypeInfo::TypeInfo((uint64_t)v154, (uint64_t)&v159.n128_i64[1]);
        re::internal::translateType(v57, (const re::TypeRegistry *)v154, (uint64_t)&v141);
        v58 = (*(uint64_t (**)(uint64_t, rapidjson::internal **))(*(_QWORD *)a1 + 80))(a1, &v141);
        if (!v58)
          goto LABEL_181;
        v59 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, rapidjson::internal **, rapidjson::internal **, uint64_t))v58;
        v60 = (_QWORD *)*((_QWORD *)a6 + 2);
        v61 = *((_DWORD *)v60 + 21) & 0xFFFFFF;
        if (v61)
        {
          v62 = 0;
          v63 = 8;
        }
        else
        {
          v62 = *((int *)v60 + 22);
          v63 = 4;
        }
        v159.n128_u64[0] = v62;
        v68 = (_anonymous_namespace_ *)(a1 + 24);
        result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v159, v63);
        if ((_DWORD)result)
        {
          v125 = v159.n128_u64[0];
          if (v61)
            v126 = v159.n128_u64[0] == 0;
          else
            v126 = 1;
          v127 = v126;
          if (!v126)
          {
            v152[0] = 0;
            v152[1] = 0xFFFFFFFFLL;
            (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)a1 + 16))(a1, 0, v152);
            v125 = v159.n128_u64[0];
          }
          if (v125)
          {
            v128 = 0;
            do
            {
              v59(a1, 0, 0, 0, &v141, &v141, 1);
              ++v128;
            }
            while (v128 < v159.n128_u64[0]);
          }
          if ((v127 & 1) == 0)
          {
LABEL_216:
            (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
            goto LABEL_217;
          }
          goto LABEL_217;
        }
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v159);
        re::TypeInfo::TypeInfo((uint64_t)&v141, (uint64_t)&v159.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v159);
        re::TypeInfo::TypeInfo((uint64_t)v154, (uint64_t)&v159.n128_i64[1]);
        re::TypeInfo::TypeInfo((uint64_t)&v159, (uint64_t)this);
        v64 = (*(uint64_t (**)(uint64_t, rapidjson::internal **))(*(_QWORD *)a1 + 80))(a1, &v141);
        if (!v64)
          goto LABEL_181;
        v65 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))v64;
        v150[0] = re::ArrayAccessor::size((re::ArrayAccessor *)&v159, (char *)a4);
        v66 = *(_DWORD *)(*((_QWORD *)this + 2) + 84) & 0xFFFFFF;
        if (v66)
          v67 = 8;
        else
          v67 = 4;
        v68 = (_anonymous_namespace_ *)(a1 + 24);
        result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, (uint64_t)a3, v150, v67);
        if ((_DWORD)result)
        {
          v69 = v150[0];
          if (v66)
            v70 = v150[0] == 0;
          else
            v70 = 1;
          v71 = v70;
          if (!v70)
          {
            v72 = *(_QWORD *)a4;
            v151[0] = 0;
            v151[1] = 0xFFFFFFFFLL;
            (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)a1 + 16))(a1, v72, v151);
            v69 = v150[0];
          }
          if (v69)
          {
            v73 = 0;
            do
            {
              v74 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v159, (char *)a4, v73);
              v65(a1, 0, 0, v74, &v141, v154, 0);
              ++v73;
            }
            while (v73 < v150[0]);
          }
          if ((v71 & 1) == 0)
            goto LABEL_216;
LABEL_217:
          re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endArray(v68);
          return *(_BYTE *)(a1 + 64) == 0;
        }
      }
      return result;
    case 5:
      if (this == a6)
        goto LABEL_132;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v75 = **((_QWORD **)this + 2);
        v76 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v75 == (unsigned __int16)v76
          && WORD1(v75) == WORD1(v76)
          && ((v76 ^ v75) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_132;
        }
        v28 = 5;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_132;
        v28 = *((unsigned __int8 *)this + 12);
      }
      if (v28 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_221;
LABEL_132:
      if ((_DWORD)a7)
      {
        v77 = *(re::internal **)(a1 + 272);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v159);
        re::TypeInfo::TypeInfo((uint64_t)v154, (uint64_t)&v159.n128_i64[1]);
        re::internal::translateType(v77, (const re::TypeRegistry *)v154, (uint64_t)&v141);
        v78 = (*(uint64_t (**)(uint64_t, rapidjson::internal **))(*(_QWORD *)a1 + 80))(a1, &v141);
        if (!v78)
          goto LABEL_181;
        v79 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, rapidjson::internal **, rapidjson::internal **, uint64_t))v78;
        v159.n128_u64[0] = 0;
        v68 = (_anonymous_namespace_ *)(a1 + 24);
        v80 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v159, 0);
        result = 0;
        if (v80)
        {
          if (v159.n128_u64[0])
          {
            v81 = 0;
            do
            {
              v79(a1, 0, 0, 0, &v141, &v141, 1);
              ++v81;
            }
            while (v81 < v159.n128_u64[0]);
          }
          goto LABEL_217;
        }
        return result;
      }
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v159);
      re::TypeInfo::TypeInfo((uint64_t)&v141, (uint64_t)&v159.n128_i64[1]);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v159);
      re::TypeInfo::TypeInfo((uint64_t)v154, (uint64_t)&v159.n128_i64[1]);
      re::TypeInfo::TypeInfo((uint64_t)&v159, (uint64_t)this);
      v82 = (*(uint64_t (**)(uint64_t, rapidjson::internal **))(*(_QWORD *)a1 + 80))(a1, &v141);
      if (!v82)
        goto LABEL_181;
      v83 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))v82;
      v151[0] = (*(uint64_t (**)(unsigned __int8 *))(v160 + 80))(a4);
      v68 = (_anonymous_namespace_ *)(a1 + 24);
      v84 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, (uint64_t)a3, v151, 0);
      result = 0;
      if (!v84)
        return result;
      if (*(_QWORD *)(v160 + 96))
      {
        if (v151[0])
        {
          v85 = 0;
          do
          {
            v86 = (*(uint64_t (**)(unsigned __int8 *, unint64_t))(v160 + 96))(a4, v85);
            v83(a1, 0, 0, v86, &v141, v154, 0);
            ++v85;
          }
          while (v85 < v151[0]);
        }
      }
      else
      {
        v131 = *(uint64_t (**)(unsigned __int8 *, _QWORD))(v160 + 104);
        if (!v131 || !*(_QWORD *)(v160 + 112) || !*(_QWORD *)(v160 + 120))
        {
          re::TypeInfo::TypeInfo((uint64_t)v152, (uint64_t)&v159);
          v139 = re::TypeInfo::name((re::TypeInfo *)v152)[1];
          v34 = "List type \"%s\" does not provide an indexer or iterator.";
          goto LABEL_61;
        }
        v132 = v131(a4, *(_QWORD *)(a1 + 56));
        v133 = (*(uint64_t (**)(void))(v160 + 112))();
        if (v133)
        {
          v134 = v133;
          do
          {
            v83(a1, 0, 0, v134, &v141, v154, 0);
            v134 = (*(uint64_t (**)(uint64_t))(v160 + 112))(v132);
          }
          while (v134);
        }
        (*(void (**)(uint64_t, _QWORD))(v160 + 120))(v132, *(_QWORD *)(a1 + 56));
      }
      goto LABEL_217;
    case 6:
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v159);
      re::TypeInfo::TypeInfo((uint64_t)&v141, (uint64_t)&v159.n128_i64[1]);
      v30 = re::TypeInfo::name((re::TypeInfo *)&v141);
      v31 = BYTE4(v142);
      if (BYTE4(v142) != 1)
        goto LABEL_72;
      if (!re::TypeInfo::isInteger((re::TypeInfo *)&v141))
      {
        v31 = BYTE4(v142);
LABEL_72:
        if (v31 == 8)
        {
          v38 = (unint64_t)*v30 >> 1;
          if (v38 == 0x22C6ED80D0CLL)
          {
            v93 = (char *)v30[1];
            if (v93 == "StringID" || !strcmp(v93, "StringID"))
              return re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, (uint64_t)a4, this, a6, a7);
          }
          else if (v38 == 0x134375A94D9F7110)
          {
            v39 = (char *)v30[1];
            if (v39 == "DynamicString" || !strcmp(v39, "DynamicString"))
              return re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, (uint64_t)a4, this, a6, a7);
          }
        }
        goto LABEL_168;
      }
      v32 = (unint64_t)*v30 >> 1;
      if (v32 > 0x303EE8780EDLL)
      {
        if (v32 == 0x303EE8780EELL)
        {
          v130 = (char *)v30[1];
          if (v130 == "uint32_t" || !strcmp(v130, "uint32_t"))
            return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(a1, a2, a3, (uint64_t)a4, this, a6, a7);
LABEL_246:
          v159.n128_u64[0] = 0x18E6A9A093;
          v159.n128_u64[1] = (unint64_t)"uint8_t";
          if (re::StringID::operator==(v30, &v159))
            return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(a1, a2, a3, (uint64_t)a4, this, a6, a7);
          v159.n128_u64[0] = 0x16749F63A2;
          v159.n128_u64[1] = (unint64_t)"int64_t";
          if (re::StringID::operator==(v30, &v159))
            return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(a1, a2, a3, (uint64_t)a4, this, a6, a7);
          *(_QWORD *)v154 = 3327612;
          *(_QWORD *)&v154[8] = "long";
          if (re::StringID::operator==(v30, v154))
            return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(a1, a2, a3, (uint64_t)a4, this, a6, a7);
          v159.n128_u64[0] = 104431;
          v159.n128_u64[1] = (unint64_t)"int";
          if (re::StringID::operator==(v30, &v159))
            return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(a1, a2, a3, (uint64_t)a4, this, a6, a7);
          v159.n128_u64[0] = 109413500;
          v159.n128_u64[1] = (unint64_t)"short";
          if (re::StringID::operator==(v30, &v159))
            return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(a1, a2, a3, (uint64_t)a4, this, a6, a7);
LABEL_168:
          if (this == a6)
            goto LABEL_176;
          if (*(_QWORD *)this == *(_QWORD *)a6)
          {
            v94 = **((_QWORD **)this + 2);
            v95 = **((_QWORD **)a6 + 2);
            if ((unsigned __int16)v94 == (unsigned __int16)v95
              && WORD1(v94) == WORD1(v95)
              && ((v95 ^ v94) & 0xFFFFFF00000000) == 0)
            {
              goto LABEL_176;
            }
          }
          else if (re::areSameTranslatedVersion(this, a6, v29))
          {
            goto LABEL_176;
          }
          if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
            goto LABEL_221;
LABEL_176:
          if ((_DWORD)a7)
          {
            v96 = *(re::internal **)(a1 + 272);
            re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v159);
            re::TypeInfo::TypeInfo((uint64_t)v154, (uint64_t)&v159.n128_i64[1]);
            re::internal::translateType(v96, (const re::TypeRegistry *)v154, (uint64_t)&v141);
            v97 = *(re::internal **)(a1 + 272);
            re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v159);
            re::TypeInfo::TypeInfo((uint64_t)v152, (uint64_t)&v159.n128_i64[1]);
            re::internal::translateType(v97, (const re::TypeRegistry *)v152, (uint64_t)v154);
            if ((*(uint64_t (**)(uint64_t, rapidjson::internal **))(*(_QWORD *)a1 + 80))(a1, &v141))
            {
              if ((*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v154))
              {
                v159.n128_u64[0] = 0;
                result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(a1 + 24, a2, (uint64_t *)&v159);
                if (!(_DWORD)result)
                  return result;
                v98 = (_anonymous_namespace_ *)(a1 + 24);
                goto LABEL_274;
              }
              v99 = (re::TypeInfo *)v154;
            }
            else
            {
LABEL_181:
              v99 = (re::TypeInfo *)&v141;
            }
LABEL_182:
            v140 = re::TypeInfo::name(v99)[1];
            re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v100, v101, v102, v103, v104, v140);
            return 0;
          }
          re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v159);
          re::TypeInfo::TypeInfo((uint64_t)v152, (uint64_t)&v159.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v159);
          re::TypeInfo::TypeInfo((uint64_t)v151, (uint64_t)&v159.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v159);
          re::TypeInfo::TypeInfo((uint64_t)v150, (uint64_t)&v159.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v159);
          re::TypeInfo::TypeInfo((uint64_t)v149, (uint64_t)&v159.n128_i64[1]);
          re::TypeInfo::TypeInfo((uint64_t)v147, (uint64_t)this);
          v105 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 80))(a1, v152);
          if (!v105)
          {
            v99 = (re::TypeInfo *)v152;
            goto LABEL_182;
          }
          v106 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, _QWORD *, uint64_t *, _QWORD))v105;
          v107 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 80))(a1, v151);
          if (!v107)
          {
            v99 = (re::TypeInfo *)v151;
            goto LABEL_182;
          }
          v108 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD))v107;
          v109 = (*(uint64_t (**)(unsigned __int8 *))(v148 + 88))(a4);
          v146 = v109;
          result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(a1 + 24, a2, (uint64_t *)&v146);
          if (!(_DWORD)result)
            return result;
          if (!v109)
          {
LABEL_273:
            v98 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_274:
            re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionary(v98);
            return *(_BYTE *)(a1 + 64) == 0;
          }
          v110 = *(_QWORD **)this;
          v159.n128_u64[0] = 0x449AD97C4B77BED4;
          v159.n128_u64[1] = (unint64_t)"_CompareFunc";
          v111 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)(v110 + 25), &v159);
          if (v111)
          {
            v112 = *v111;
            re::StringID::destroyString((re::StringID *)&v159);
            if (v110)
            {
              v113 = *(_QWORD *)v152[2];
              v159.n128_u64[0] = v112;
              v159.n128_u64[1] = v113;
              LODWORD(v160) = -1;
              v114 = (uint64_t (**)(uint64_t, uint64_t))re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v152[0] + 768, (uint64_t *)&v159);
              if (v114)
              {
                v115 = *v114;
                if (*v114)
                {
                  v145 = 0;
                  v142 = 0;
                  v143 = 0;
                  v144 = 0;
                  v141 = *(rapidjson::internal **)(a1 + 56);
                  re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v141, v109);
                  ++v144;
                  v116 = (*(uint64_t (**)(unsigned __int8 *, _QWORD))(v148 + 112))(a4, *(_QWORD *)(a1 + 56));
                  if ((*(unsigned int (**)(void))(v148 + 120))())
                  {
                    do
                    {
                      v117 = (*(uint64_t (**)(uint64_t))(v148 + 128))(v116);
                      v118 = (*(uint64_t (**)(uint64_t))(v148 + 136))(v116);
                      v159.n128_u64[0] = v117;
                      v159.n128_u64[1] = v118;
                      v119 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v141, &v159);
                    }
                    while (((*(uint64_t (**)(uint64_t, __n128))(v148 + 120))(v116, v119) & 1) != 0);
                  }
                  (*(void (**)(uint64_t, _QWORD))(v148 + 144))(v116, *(_QWORD *)(a1 + 56));
                  std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(v145, &v145[16 * v143], v115);
                  v120 = 0;
                  v121 = 0;
                  if (v109 <= 1)
                    v109 = 1;
                  do
                  {
                    v122 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 0);
                    v123 = v143;
                    if (v143 <= v121)
                    {
                      v153 = 0;
                      v162 = 0u;
                      v163 = 0u;
                      v160 = 0u;
                      v161 = 0u;
                      v159 = 0u;
                      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v154 = 136315906;
                      *(_QWORD *)&v154[4] = "operator[]";
                      *(_WORD *)&v154[12] = 1024;
                      *(_DWORD *)&v154[14] = 789;
                      v155 = 2048;
                      v156 = v121;
                      v157 = 2048;
                      v158 = v123;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_278:
                      v153 = 0;
                      v162 = 0u;
                      v163 = 0u;
                      v160 = 0u;
                      v161 = 0u;
                      v159 = 0u;
                      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v154 = 136315906;
                      *(_QWORD *)&v154[4] = "operator[]";
                      *(_WORD *)&v154[12] = 1024;
                      *(_DWORD *)&v154[14] = 789;
                      v155 = 2048;
                      v156 = v121;
                      v157 = 2048;
                      v158 = v123;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
                    }
                    ((void (*)(uint64_t, const char *, _QWORD, _QWORD, _QWORD *, uint64_t *, _QWORD, double))v106)(a1, "key", 0, *(_QWORD *)&v145[v120], v152, v150, 0, v122);
                    v123 = v143;
                    if (v143 <= v121)
                      goto LABEL_278;
                    v108(a1, "value", 0, *(_QWORD *)&v145[v120 + 8], v151, v149, 0);
                    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
                    ++v121;
                    v120 += 16;
                  }
                  while (v109 != v121);
                  if (!v141 || !v145)
                    goto LABEL_273;
                  v124 = *(void (**)(void))(*(_QWORD *)v141 + 40);
                  goto LABEL_272;
                }
              }
            }
          }
          else
          {
            re::StringID::destroyString((re::StringID *)&v159);
          }
          v135 = (*(uint64_t (**)(unsigned __int8 *, _QWORD))(v148 + 112))(a4, *(_QWORD *)(a1 + 56));
          (*(void (**)(void))(v148 + 120))();
          do
          {
            v136 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 0);
            v137 = (*(uint64_t (**)(uint64_t, double))(v148 + 128))(v135, v136);
            v106(a1, "key", 0, v137, v152, v150, 0);
            v138 = (*(uint64_t (**)(uint64_t))(v148 + 136))(v135);
            v108(a1, "value", 0, v138, v151, v149, 0);
            re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
            (*(void (**)(uint64_t))(v148 + 120))(v135);
            --v109;
          }
          while (v109);
          v124 = *(void (**)(void))(v148 + 144);
LABEL_272:
          v124();
          goto LABEL_273;
        }
        if (v32 != 0x303EE88E58DLL)
          goto LABEL_246;
        v91 = (char *)v30[1];
        if (v91 != "uint64_t")
        {
          v92 = "uint64_t";
          goto LABEL_242;
        }
      }
      else
      {
        if (v32 != 3393056694)
        {
          if (v32 == 0x303EE86A734)
          {
            v33 = (char *)v30[1];
            if (v33 == "uint16_t" || !strcmp(v33, "uint16_t"))
              return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(a1, a2, a3, (uint64_t)a4, this, a6, a7);
          }
          goto LABEL_246;
        }
        v91 = (char *)v30[1];
        if (v91 != "size_t")
        {
          v92 = "size_t";
LABEL_242:
          if (strcmp(v91, v92))
            goto LABEL_246;
        }
      }
      return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(a1, a2, a3, (uint64_t)a4, this, a6, a7);
    case 7:
      if (this == a6)
        goto LABEL_54;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v87 = **((_QWORD **)this + 2);
        v88 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v87 != (unsigned __int16)v88)
          goto LABEL_221;
        v18 = WORD1(v87) == WORD1(v88);
        v89 = (v88 ^ v87) & 0xFFFFFF00000000;
        if (!v18 || v89 != 0)
          goto LABEL_221;
      }
      else if (!re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_221;
      }
LABEL_54:
      result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 16);
      if ((_DWORD)a7)
      {
        if (!(_DWORD)result)
          return result;
        v141 = 0;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, "tag", &v141);
        if (*(_DWORD *)(*((_QWORD *)a6 + 2) + 88))
        {
          re::TypeInfo::unionMember(a6, 0, (uint64_t)&v159);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, __n128 *, __n128 *, uint64_t))(*(_QWORD *)a1 + 72))(a1, "value", 0, 0, &v159, &v159, 1);
        }
      }
      else
      {
        if (!(_DWORD)result)
          return result;
        v36 = (re::UnionAccessor *)re::TypeInfo::TypeInfo((uint64_t)&v159, (uint64_t)this);
        Tag = re::UnionAccessor::readTag(v36, (char *)a4);
        *(_QWORD *)v154 = Tag;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, "tag", (rapidjson::internal **)v154);
        if (Tag < *(unsigned int *)(*((_QWORD *)this + 2) + 88))
        {
          re::TypeInfo::unionMember(this, Tag, (uint64_t)&v141);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, unsigned __int8 *, rapidjson::internal **, rapidjson::internal **, _QWORD))(*(_QWORD *)a1 + 72))(a1, "value", 0, a4, &v141, &v141, 0);
        }
      }
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(_BYTE *)(a1 + 64) == 0;
    case 8:
      return re::serializeObject<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, (uint64_t)a3, (uint64_t)a4, this, (uint64_t)a6, a7);
    case 9:
      v139 = re::TypeInfo::name(this)[1];
      v34 = "Pointer type (\"%s\") needs to be handled explicitly by the serializer.";
      goto LABEL_61;
    default:
      LOBYTE(v139) = *((_BYTE *)this + 12);
      v34 = "Invalid type category. Value = %d";
      goto LABEL_61;
  }
}

uint64_t re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, re::TypeInfo *this, re::TypeInfo *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v7 = re::TypeInfo::name(this)[1];
  re::TypeInfo::name(a4);
  return re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Type mismatch. Runtime type \"%s\" and serialized type \"%s\" are different.", v8, v9, v10, v11, v12, v7);
}

uint64_t re::serializeEnum<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, re::TypeInfo *a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  uint64_t *v19;

  if (a5 == a6)
    return re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, (re *)a5, (const re::TypeInfo *)a6, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **(_QWORD **)(a5 + 16);
    v15 = **(_QWORD **)(a6 + 16);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, (re *)a5, (const re::TypeInfo *)a6, a7);
    }
  }
  else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
  {
    return re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, (re *)a5, (const re::TypeInfo *)a6, a7);
  }
  if (*(unsigned __int8 *)(a5 + 12) == *(unsigned __int8 *)(a6 + 12))
  {
    v18 = re::TypeInfo::name((re::TypeInfo *)a5);
    v19 = re::TypeInfo::name((re::TypeInfo *)a6);
    if (re::StringID::operator==(v18, v19))
      return re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, (re *)a5, (const re::TypeInfo *)a6, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
  return 0;
}

uint64_t re::serializeObject<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  uint64_t *v14;
  const char *v15;
  _BOOL4 v16;
  uint64_t result;
  uint64_t v18;
  const re::TypeInfo *v19;
  uint64_t v20;
  unsigned int v21;
  re::TypeRegistry *v22;
  re *v23;
  const re::TypeInfo *v24;
  uint64_t v25;
  const char *v26;
  const re::TypeInfo *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[2];
  unsigned int v37;
  uint64_t v38;
  _BYTE v39[32];

  if (!(_DWORD)a7)
  {
LABEL_6:
    if ((*(_BYTE *)(*((_QWORD *)this + 2) + 48) & 4) != 0)
      return re::internal::serializeObjectWithOneMember<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((_BYTE *)a1, a2, a3, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    v16 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, a3, 0);
    result = 0;
    if (!v16)
      return result;
    v18 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
    if (!v18 || *(_DWORD *)(v18 + 16) >= 2u)
    {
      v20 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      if (v20)
        v21 = *(_DWORD *)(v20 + 16);
      else
        v21 = -1;
      v37 = v21;
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, "@version", 0, &v37, 0);
    }
    if (this == (re::TypeInfo *)a6)
      goto LABEL_21;
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v28 = **((_QWORD **)this + 2);
      v29 = **(_QWORD **)(a6 + 16);
      if ((unsigned __int16)v28 == (unsigned __int16)v29
        && WORD1(v28) == WORD1(v29)
        && ((v29 ^ v28) & 0xFFFFFF00000000) == 0)
      {
        goto LABEL_21;
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v19))
    {
LABEL_21:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((_BYTE *)a1, a4, (uint64_t *)this, a7);
LABEL_28:
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(_BYTE *)(a1 + 64) == 0;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    }
    else
    {
      v30 = re::TypeInfo::name(this)[1];
      re::TypeInfo::name((re::TypeInfo *)a6);
      re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v31, v32, v33, v34, v35, v30);
    }
    goto LABEL_28;
  }
  if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
  {
    v22 = *(re::TypeRegistry **)(a1 + 272);
    v36[0] = 0x2686EB529B3EE220;
    v36[1] = "DynamicString";
    re::TypeRegistry::typeInfo(v22, (const re::StringID *)v36, &v37);
    re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v38);
    re::StringID::destroyString((re::StringID *)v36);
    v23 = (re *)v39;
    v24 = (const re::TypeInfo *)v39;
    v25 = a1;
    v26 = a2;
    v27 = (const re::TypeInfo *)a3;
  }
  else
  {
    v14 = re::TypeInfo::name(this);
    if ((unint64_t)*v14 >> 1 != 0x134375A94D9F7110)
      goto LABEL_6;
    v15 = (const char *)v14[1];
    if (v15 != "DynamicString")
    {
      if (strcmp(v15, "DynamicString"))
        goto LABEL_6;
    }
    v25 = a1;
    v26 = a2;
    v27 = (const re::TypeInfo *)a3;
    v23 = this;
    v24 = this;
  }
  re::serializeDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(v25, v26, v27, 0, v23, v24, 1);
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(uint64_t a1, const char *a2, unsigned __int8 *a3)
{
  int v3;
  char *v6;
  int v7;
  uint64_t v8;
  const char *v10;

  v10 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v10);
    v6 = *(char **)(a1 + 168);
    v7 = *a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteBool((uint64_t *)v6, v7);
    v8 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v8 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(uint64_t a1, const char *a2, uint64_t a3)
{
  int v3;
  char *v6;
  uint64_t v7;
  const char *v9;

  v9 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v9);
    v6 = *(char **)(a1 + 168);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v6, a3, 1u);
    v7 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v7 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(char *a1, const char **a2)
{
  const char *v3;
  unsigned int v4;

  v3 = *a2;
  v4 = strlen(*a2);
  rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(a1);
  return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)a1, (uint64_t)v3, v4);
}

char *rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(char *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _BYTE *v4;
  char v5;
  char *v6;
  char v7;

  v1 = *((_QWORD *)result + 4);
  if (v1 == *((_QWORD *)result + 3))
  {
    result[60] = 1;
  }
  else
  {
    v2 = *(_QWORD *)(v1 - 16);
    if (v2)
    {
      v3 = *(_QWORD *)result;
      if (*(_BYTE *)(v1 - 8))
      {
        v4 = *(_BYTE **)(v3 + 24);
        if ((uint64_t)(*(_QWORD *)(v3 + 32) - (_QWORD)v4) <= 0)
        {
          result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*(_QWORD *)result, 1);
          v4 = *(_BYTE **)(v3 + 24);
        }
        *(_QWORD *)(v3 + 24) = v4 + 1;
        *v4 = 44;
      }
      else
      {
        if ((v2 & 1) != 0)
          v5 = 58;
        else
          v5 = 44;
        v6 = *(char **)(v3 + 24);
        if ((uint64_t)(*(_QWORD *)(v3 + 32) - (_QWORD)v6) <= 0)
        {
          v7 = v5;
          result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*(_QWORD *)result, 1);
          v5 = v7;
          v6 = *(char **)(v3 + 24);
        }
        *(_QWORD *)(v3 + 24) = v6 + 1;
        *v6 = v5;
      }
    }
    ++*(_QWORD *)(v1 - 16);
  }
  return result;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  _BYTE *v12;
  _BYTE *v13;
  _BYTE *v14;
  _BYTE *v15;
  _BYTE *v16;
  char v17;
  _BYTE *v18;
  _BYTE *v19;

  v6 = *a1;
  v7 = 6 * a3 + 2;
  v8 = *(_BYTE **)(v6 + 24);
  if (*(_QWORD *)(v6 + 32) - (_QWORD)v8 < v7)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v6, v7);
    v6 = *a1;
    v8 = *(_BYTE **)(*a1 + 24);
  }
  *(_QWORD *)(v6 + 24) = v8 + 1;
  *v8 = 34;
  if (a3)
  {
    v9 = 0;
    do
    {
      v10 = *(unsigned __int8 *)(a2 + v9);
      v11 = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString(char const*,unsigned int)::escape[v10];
      v12 = *(_BYTE **)(*a1 + 24);
      *(_QWORD *)(*a1 + 24) = v12 + 1;
      if (v11)
      {
        *v12 = 92;
        v13 = *(_BYTE **)(*a1 + 24);
        *(_QWORD *)(*a1 + 24) = v13 + 1;
        *v13 = v11;
        if (v11 == 117)
        {
          v14 = *(_BYTE **)(*a1 + 24);
          *(_QWORD *)(*a1 + 24) = v14 + 1;
          *v14 = 48;
          v15 = *(_BYTE **)(*a1 + 24);
          *(_QWORD *)(*a1 + 24) = v15 + 1;
          *v15 = 48;
          LOBYTE(v15) = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString(char const*,unsigned int)::hexDigits[v10 >> 4];
          v16 = *(_BYTE **)(*a1 + 24);
          *(_QWORD *)(*a1 + 24) = v16 + 1;
          *v16 = (_BYTE)v15;
          v17 = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString(char const*,unsigned int)::hexDigits[v10 & 0xF];
          v18 = *(_BYTE **)(*a1 + 24);
          *(_QWORD *)(*a1 + 24) = v18 + 1;
          *v18 = v17;
        }
      }
      else
      {
        *v12 = v10;
      }
      ++v9;
    }
    while (v9 < a3);
  }
  v19 = *(_BYTE **)(*a1 + 24);
  *(_QWORD *)(*a1 + 24) = v19 + 1;
  *v19 = 34;
  return 1;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteBool(uint64_t *a1, int a2)
{
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *v6;
  char *v7;
  char v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;

  v3 = *a1;
  v4 = *(_BYTE **)(v3 + 24);
  v5 = *(_QWORD *)(v3 + 32) - (_QWORD)v4;
  if (a2)
  {
    if (v5 <= 3)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v3, 4);
      v3 = *a1;
      v4 = *(_BYTE **)(*a1 + 24);
    }
    *(_QWORD *)(v3 + 24) = v4 + 1;
    *v4 = 116;
    v6 = *(_BYTE **)(*a1 + 24);
    *(_QWORD *)(*a1 + 24) = v6 + 1;
    *v6 = 114;
    v7 = *(char **)(*a1 + 24);
    *(_QWORD *)(*a1 + 24) = v7 + 1;
    v8 = 117;
  }
  else
  {
    if (v5 <= 4)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v3, 5);
      v3 = *a1;
      v4 = *(_BYTE **)(*a1 + 24);
    }
    *(_QWORD *)(v3 + 24) = v4 + 1;
    *v4 = 102;
    v9 = *(_BYTE **)(*a1 + 24);
    *(_QWORD *)(*a1 + 24) = v9 + 1;
    *v9 = 97;
    v10 = *(_BYTE **)(*a1 + 24);
    *(_QWORD *)(*a1 + 24) = v10 + 1;
    *v10 = 108;
    v7 = *(char **)(*a1 + 24);
    *(_QWORD *)(*a1 + 24) = v7 + 1;
    v8 = 115;
  }
  *v7 = v8;
  v11 = *(_BYTE **)(*a1 + 24);
  *(_QWORD *)(*a1 + 24) = v11 + 1;
  *v11 = 101;
  return 1;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(uint64_t a1, const char *a2, char *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;
  const char *v11;

  v11 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt(uint64_t *a1, rapidjson::internal *this, char *a3)
{
  rapidjson::internal *v3;
  char *v5;
  char *v6;
  char *v7;
  char v8;
  _BYTE *v9;
  char v11;
  _BYTE v12[18];

  v3 = this;
  *(_QWORD *)&v12[10] = *MEMORY[0x24BDAC8D0];
  if ((this & 0x80000000) != 0)
  {
    v5 = v12;
    v11 = 45;
    v3 = (rapidjson::internal *)-(int)v3;
  }
  else
  {
    v5 = &v11;
  }
  v6 = rapidjson::internal::u32toa(v3, v5, a3);
  if (*(_QWORD *)(*a1 + 32) - *(_QWORD *)(*a1 + 24) < v6 - &v11)
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, v6 - &v11);
  if (&v11 != v6)
  {
    v7 = &v11;
    do
    {
      v8 = *v7++;
      v9 = *(_BYTE **)(*a1 + 24);
      *(_QWORD *)(*a1 + 24) = v9 + 1;
      *v9 = v8;
    }
    while (v7 != v6);
  }
  return 1;
}

_BYTE *rapidjson::internal::u32toa(rapidjson::internal *this, _BYTE *a2, char *a3)
{
  unint64_t v3;
  _BYTE *v4;
  unsigned int v5;
  _BYTE *v6;

  if (this >> 4 <= 0x270)
  {
    if (this < 0x3E8)
    {
      if (this < 0x64)
      {
        if (this < 0xA)
          goto LABEL_10;
        goto LABEL_9;
      }
    }
    else
    {
      *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * ((unsigned __int16)this / 0x64u));
    }
    *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((2 * ((unsigned __int16)this / 0x64u)) | 1));
LABEL_9:
    *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * ((unsigned __int16)this % 0x64u));
LABEL_10:
    *a2 = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
          + ((unsigned __int16)(2 * ((unsigned __int16)this % 0x64u)) | 1u));
    return a2 + 1;
  }
  if (this < 0x5F5E100)
  {
    v3 = (this / 0x7A120uLL) & 0x3FFE;
    if (this < 0x989680)
    {
      if (this <= 0xF423F)
      {
        if (this >> 5 < 0xC35)
          goto LABEL_16;
        goto LABEL_15;
      }
    }
    else
    {
      *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v3);
    }
    *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + (v3 | 1));
LABEL_15:
    *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + 2 * ((unsigned __int16)(this / 0x2710) % 0x64u));
LABEL_16:
    *a2 = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
          + ((unsigned __int16)(2 * ((unsigned __int16)(this / 0x2710) % 0x64u)) | 1u));
    a2[1] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this % 0x2710 / 0x64));
    a2[2] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((2 * (this % 0x2710 / 0x64)) | 1));
    a2[3] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this % 0x2710 % 0x64));
    a2[4] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((unsigned __int16)(2 * (this % 0x2710 % 0x64)) | 1u));
    return a2 + 5;
  }
  v5 = this % 0x5F5E100;
  if (this < 0x3B9ACA00)
  {
    *a2 = this / 0x5F5E100 + 48;
    v6 = a2 + 1;
  }
  else
  {
    *a2 = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this / 0x5F5E100));
    v6 = a2 + 2;
    a2[1] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this / 0x5F5E100) + 1);
  }
  *(_WORD *)v6 = *(_WORD *)((char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + ((v5 / 0x7A120uLL) & 0x3FFE));
  *((_WORD *)v6 + 1) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                       + (unsigned __int16)(v5 / 0x2710) % 0x64u);
  *((_WORD *)v6 + 2) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v5 % 0x2710 / 0x64);
  v6[6] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (v5 % 0x2710 % 0x64));
  v4 = v6 + 8;
  v6[7] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
          + (unsigned __int16)(2 * (v5 % 0x2710 % 0x64))
          + 1);
  return v4;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(uint64_t a1, const char *a2, __int16 *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;
  const char *v11;

  v11 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(uint64_t a1, const char *a2, unsigned int *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;
  const char *v11;

  v11 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(uint64_t a1, const char *a2, unint64_t *a3)
{
  int v3;
  char *v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  const char *v11;

  v11 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    v6 = *(char **)(a1 + 168);
    v7 = *a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt64((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt64(uint64_t *a1, unint64_t this, char *a3)
{
  unint64_t v3;
  char *v5;
  char *v6;
  char *v7;
  char v8;
  _BYTE *v9;
  char v11;
  _BYTE v12[28];

  v3 = this;
  *(_QWORD *)&v12[20] = *MEMORY[0x24BDAC8D0];
  if ((this & 0x8000000000000000) != 0)
  {
    v5 = v12;
    v11 = 45;
    v3 = -(uint64_t)v3;
  }
  else
  {
    v5 = &v11;
  }
  v6 = rapidjson::internal::u64toa(v3, v5, a3);
  if (*(_QWORD *)(*a1 + 32) - *(_QWORD *)(*a1 + 24) < v6 - &v11)
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, v6 - &v11);
  if (&v11 != v6)
  {
    v7 = &v11;
    do
    {
      v8 = *v7++;
      v9 = *(_BYTE **)(*a1 + 24);
      *(_QWORD *)(*a1 + 24) = v9 + 1;
      *v9 = v8;
    }
    while (v7 != v6);
  }
  return 1;
}

_BYTE *rapidjson::internal::u64toa(unint64_t this, _BYTE *a2, char *a3)
{
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _BYTE *v12;
  _BYTE *v13;
  unsigned int v14;
  uint64_t v15;
  char v16;
  unsigned int v17;
  unsigned int v18;

  if (this < 0x5F5E100)
  {
    if (this >> 4 <= 0x270)
    {
      if (this < 0x3E8)
      {
        if (this < 0x64)
        {
          if (this < 0xA)
            goto LABEL_15;
          goto LABEL_14;
        }
      }
      else
      {
        *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * ((unsigned __int16)this / 0x64u));
      }
      *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
              + ((2 * ((unsigned __int16)this / 0x64u)) | 1));
LABEL_14:
      *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * ((unsigned __int16)this % 0x64u));
LABEL_15:
      *a2 = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((unsigned __int16)(2 * ((unsigned __int16)this % 0x64u)) | 1u));
      return a2 + 1;
    }
    v9 = (this / 0x7A120uLL) & 0x3FFE;
    if (this < 0x989680)
    {
      if (this < 0xF4240)
      {
        if (this >> 5 < 0xC35)
          goto LABEL_27;
        goto LABEL_26;
      }
    }
    else
    {
      *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v9);
    }
    *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + (v9 | 1));
LABEL_26:
    *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + 2 * ((unsigned __int16)(this / 0x2710) % 0x64u));
LABEL_27:
    *a2 = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
          + ((unsigned __int16)(2 * ((unsigned __int16)(this / 0x2710) % 0x64u)) | 1u));
    a2[1] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this % 0x2710 / 0x64));
    a2[2] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((2 * (this % 0x2710 / 0x64)) | 1));
    a2[3] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this % 0x2710 % 0x64));
    a2[4] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((unsigned __int16)(2 * (this % 0x2710 % 0x64)) | 1u));
    return a2 + 5;
  }
  if (this < 0x2386F26FC10000)
  {
    v3 = this % 0x5F5E100;
    v4 = this / 0x5F5E100;
    v5 = (v4 / 0x7A120uLL) & 0x3FFE;
    v6 = v3 / 0x2710;
    v7 = v3 % 0x2710;
    v8 = (v3 / 0x7A120uLL) & 0x3FFE;
    if (this < 0x38D7EA4C68000)
    {
      if (this < 0x5AF3107A4000)
      {
        if (this < 0x9184E72A000)
        {
          if (this < 0xE8D4A51000)
          {
            if (this < 0x174876E800)
            {
              if (this < 0x2540BE400)
              {
                if (this < 0x3B9ACA00)
                  goto LABEL_23;
                goto LABEL_22;
              }
LABEL_21:
              *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + ((2 * (v4 % 0x2710 / 0x64)) | 1));
LABEL_22:
              *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (v4 % 0x2710 % 0x64));
LABEL_23:
              *a2 = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                    + ((unsigned __int16)(2 * (v4 % 0x2710 % 0x64)) | 1u));
              a2[1] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v8);
              a2[2] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + (v8 | 1));
              a2[3] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + 2 * ((unsigned __int16)v6 % 0x64u));
              a2[4] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + ((unsigned __int16)(2 * ((unsigned __int16)v6 % 0x64u)) | 1u));
              a2[5] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + 2 * ((unsigned __int16)v7 / 0x64u));
              a2[6] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + ((2 * ((unsigned __int16)v7 / 0x64u)) | 1));
              a2[7] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + 2 * ((unsigned __int16)v7 % 0x64u));
              a2[8] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + ((unsigned __int16)(2 * ((unsigned __int16)v7 % 0x64u)) | 1u));
              return a2 + 9;
            }
LABEL_20:
            *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (v4 % 0x2710 / 0x64));
            goto LABEL_21;
          }
LABEL_19:
          *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                  + ((unsigned __int16)(2 * ((unsigned __int16)(v4 / 0x2710) % 0x64u)) | 1u));
          goto LABEL_20;
        }
LABEL_18:
        *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                + 2 * ((unsigned __int16)(v4 / 0x2710) % 0x64u));
        goto LABEL_19;
      }
    }
    else
    {
      *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v5);
    }
    *a2++ = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + (v5 | 1));
    goto LABEL_18;
  }
  v10 = this / 0x2386F26FC10000;
  v11 = this % 0x2386F26FC10000;
  if ((this / 0x2386F26FC10000) > 9)
  {
    if (v10 > 0x63)
    {
      v14 = (unsigned __int16)v10 / 0x64u;
      if (v10 > 0x3E7)
      {
        v15 = 2 * ((unsigned __int16)v10 % 0x64u);
        *(_WORD *)a2 = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v14);
        a2[2] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v15);
        v16 = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + ((unsigned __int16)v15 & 0xFFFE) + 1);
        v12 = a2 + 4;
        a2[3] = v16;
      }
      else
      {
        *a2 = v14 + 48;
        *(_WORD *)(a2 + 1) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                             + (unsigned __int16)v10 % 0x64u);
        v12 = a2 + 3;
      }
    }
    else
    {
      *a2 = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this / 0x2386F26FC10000));
      v12 = a2 + 2;
      a2[1] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
              + 2 * (this / 0x2386F26FC10000)
              + 1);
    }
  }
  else
  {
    *a2 = v10 + 48;
    v12 = a2 + 1;
  }
  v17 = v11 / 0x5F5E100;
  v18 = v11 % 0x5F5E100;
  *(_WORD *)v12 = *(_WORD *)((char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + ((v17 / 0x7A120uLL) & 0x3FFE));
  *((_WORD *)v12 + 1) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                        + (unsigned __int16)(v17 / 0x2710) % 0x64u);
  *((_WORD *)v12 + 2) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v17 % 0x2710 / 0x64);
  v12[6] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (v17 % 0x2710 % 0x64));
  v12[7] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
           + (unsigned __int16)(2 * (v17 % 0x2710 % 0x64))
           + 1);
  *((_WORD *)v12 + 4) = *(_WORD *)((char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                                 + ((v18 / 0x7A120uLL) & 0x3FFE));
  *((_WORD *)v12 + 5) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                        + (unsigned __int16)(v18 / 0x2710) % 0x64u);
  *((_WORD *)v12 + 6) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v18 % 0x2710 / 0x64);
  v12[14] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (v18 % 0x2710 % 0x64));
  v13 = v12 + 16;
  v12[15] = *((_BYTE *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + (unsigned __int16)(2 * (v18 % 0x2710 % 0x64))
            + 1);
  return v13;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(uint64_t a1, const char *a2, unsigned __int8 *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;
  const char *v11;

  v11 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint(uint64_t *a1, rapidjson::internal *this, char *a3)
{
  char *v4;
  char *v5;
  char v6;
  _BYTE *v7;
  _BYTE v9[10];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v4 = rapidjson::internal::u32toa(this, v9, a3);
  if (*(_QWORD *)(*a1 + 32) - *(_QWORD *)(*a1 + 24) < v4 - v9)
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, v4 - v9);
  if (v9 != v4)
  {
    v5 = v9;
    do
    {
      v6 = *v5++;
      v7 = *(_BYTE **)(*a1 + 24);
      *(_QWORD *)(*a1 + 24) = v7 + 1;
      *v7 = v6;
    }
    while (v5 != v4);
  }
  return 1;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(uint64_t a1, const char *a2, unsigned __int16 *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;
  const char *v11;

  v11 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(uint64_t a1, const char *a2, uint64_t a3, unsigned int *a4, char a5)
{
  int v5;
  char *v9;
  rapidjson::internal *v10;
  char *v11;
  uint64_t v12;
  const char *v14;

  v14 = a2;
  v5 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v14);
    v9 = *(char **)(a1 + 168);
    v10 = (rapidjson::internal *)*a4;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v9);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint((uint64_t *)v9, v10, v11);
    if ((a5 & 2) == 0)
    {
      v12 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v12 - 16);
    }
  }
  return v5 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(uint64_t a1, const char *a2, rapidjson::internal **a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;
  const char *v11;

  v11 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    v6 = *(char **)(a1 + 168);
    v7 = *a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint64((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint64(uint64_t *a1, rapidjson::internal *this, char *a3)
{
  char *v4;
  char *v5;
  char v6;
  _BYTE *v7;
  _BYTE v9[20];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v4 = rapidjson::internal::u64toa((unint64_t)this, v9, a3);
  if (*(_QWORD *)(*a1 + 32) - *(_QWORD *)(*a1 + 24) < v4 - v9)
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, v4 - v9);
  if (v9 != v4)
  {
    v5 = v9;
    do
    {
      v6 = *v5++;
      v7 = *(_BYTE **)(*a1 + 24);
      *(_QWORD *)(*a1 + 24) = v7 + 1;
      *v7 = v6;
    }
    while (v5 != v4);
  }
  return 1;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(uint64_t a1, const char *a2, uint64_t a3, float *a4, char a5)
{
  int v5;
  float v9;
  char *v10;
  const char *v11;
  uint64_t v12;
  double v14;
  const char *v15;
  const char *v16;

  v16 = a2;
  v5 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v16);
    v9 = *a4;
    v10 = *(char **)(a1 + 168);
    if (fabsf(v9) != INFINITY)
    {
      v14 = v9;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble((uint64_t)v10, v14);
      if ((a5 & 2) != 0)
        return v5 == 0;
      goto LABEL_8;
    }
    v11 = "-Infinity";
    if (v9 > 0.0)
      v11 = "Infinity";
    v15 = v11;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(v10, &v15);
    if ((a5 & 2) == 0)
    {
LABEL_8:
      v12 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v12 - 16);
    }
  }
  return v5 == 0;
}

BOOL rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble(uint64_t a1, double a2)
{
  uint64_t v2;
  char *v4;
  char *v5;
  char v6;
  _BYTE *v7;
  _BYTE v9[25];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)&a2 & 0x7FF0000000000000;
  if ((*(_QWORD *)&a2 & 0x7FF0000000000000) != 0x7FF0000000000000)
  {
    v4 = rapidjson::internal::dtoa((rapidjson::internal *)v9, a2, (char *)*(unsigned int *)(a1 + 56));
    if (*(_QWORD *)(*(_QWORD *)a1 + 32) - *(_QWORD *)(*(_QWORD *)a1 + 24) < v4 - v9)
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*(_QWORD *)a1, v4 - v9);
    if (v9 != v4)
    {
      v5 = v9;
      do
      {
        v6 = *v5++;
        v7 = *(_BYTE **)(*(_QWORD *)a1 + 24);
        *(_QWORD *)(*(_QWORD *)a1 + 24) = v7 + 1;
        *v7 = v6;
      }
      while (v5 != v4);
    }
  }
  return v2 != 0x7FF0000000000000;
}

char *rapidjson::internal::dtoa(rapidjson::internal *this, double a2, char *a3)
{
  rapidjson::internal *v3;
  unint64_t v4;
  int v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  char v11;
  double v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v22;
  unsigned int v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26[2];
  _QWORD v27[2];
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;

  v3 = this;
  v4 = *(_QWORD *)&a2;
  if ((*(_QWORD *)&a2 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    v5 = (int)a3;
    if (a2 < 0.0)
    {
      *(_BYTE *)this = 45;
      v3 = (rapidjson::internal *)((char *)this + 1);
      v4 = *(_QWORD *)&a2 ^ 0x8000000000000000;
    }
    v23 = 0;
    if (((v4 >> 52) & 0x7FF) != 0)
      v6 = v4 & 0xFFFFFFFFFFFFFLL | 0x10000000000000;
    else
      v6 = v4 & 0xFFFFFFFFFFFFFLL;
    if (((v4 >> 52) & 0x7FF) != 0)
      v7 = ((v4 >> 52) & 0x7FF) - 1075;
    else
      v7 = -1074;
    v30 = (2 * (v6 & 0x1FFFFFFFFFFFFFLL)) | 1;
    v31 = v7 - 1;
    v8 = rapidjson::internal::DiyFp::NormalizeBoundary((rapidjson::internal::DiyFp *)&v30);
    v10 = 2 * v6 - 1;
    if (v6 == 0x10000000000000)
      v11 = -2;
    else
      v11 = -1;
    if (v6 == 0x10000000000000)
      v10 = 0x3FFFFFFFFFFFFFLL;
    v28 = v8;
    v29 = v9;
    v30 = v10 << (v11 + v7 - v9);
    v31 = v9;
    v12 = (double)(-61 - v9) * 0.301029996 + 347.0;
    v13 = (int)v12;
    if (v12 - (double)(int)v12 > 0.0)
      ++v13;
    v14 = (v13 >> 3) + 1;
    v22 = 348 - 8 * v14;
    v15 = rapidjson::internal::GetCachedPowerByIndex(unsigned long)::kCachedPowers_F[v14];
    v16 = rapidjson::internal::GetCachedPowerByIndex(unsigned long)::kCachedPowers_E[v14];
    v27[0] = v15;
    v27[1] = v16;
    LODWORD(v16) = __clz(v6);
    v24 = v6 << v16;
    v25 = (v7 - v16);
    v26[0] = rapidjson::internal::DiyFp::operator*(&v24, v27);
    v26[1] = v17;
    v18 = rapidjson::internal::DiyFp::operator*(&v28, v27);
    v25 = v19;
    v20 = rapidjson::internal::DiyFp::operator*(&v30, v27);
    v24 = v18 - 1;
    rapidjson::internal::DigitGen(v26, (uint64_t *)&v24, v18 - 1 + ~v20, (uint64_t)v3, (int *)&v23, &v22);
    return rapidjson::internal::Prettify(v3, (char *)v23, v22, v5);
  }
  else
  {
    if ((*(_QWORD *)&a2 & 0x8000000000000000) != 0)
    {
      *(_BYTE *)this = 45;
      v3 = (rapidjson::internal *)((char *)this + 1);
    }
    *(_WORD *)v3 = 11824;
    *((_BYTE *)v3 + 2) = 48;
    return (char *)v3 + 3;
  }
}

char *rapidjson::internal::Prettify(rapidjson::internal *this, char *a2, int a3, int a4)
{
  int v6;
  int v8;
  char *v9;
  int v10;
  char *v11;
  __int16 v12;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned int i;
  int v19;
  unsigned int v20;
  uint64_t v21;

  v6 = (int)a2;
  v8 = a3 + (_DWORD)a2;
  if ((a3 & 0x80000000) == 0 && v8 <= 21)
  {
    if (a3)
    {
      v9 = (char *)this + (int)a2;
      if (v8 <= (int)a2 + 1)
        v10 = (_DWORD)a2 + 1;
      else
        v10 = a3 + (_DWORD)a2;
      memset(v9, 48, (v10 + ~(_DWORD)a2) + 1);
    }
    v11 = (char *)this + v8;
    v12 = 12334;
    goto LABEL_9;
  }
  v14 = v8 - 1;
  if ((v8 - 1) <= 0x14)
  {
    v15 = (v8 + 1);
    memmove((char *)this + v15, (char *)this + v8, -a3);
    *((_BYTE *)this + v8) = 46;
    if (a4 + a3 >= 0)
      return (char *)this + v6 + 1;
    if (a4 >= 2)
    {
      v20 = v8 + a4;
      while (*((_BYTE *)this + v20) == 48)
      {
        if ((int)--v20 <= (int)v15)
          goto LABEL_32;
      }
      return (char *)this + (int)(v20 + 1);
    }
LABEL_32:
    v21 = (v8 + 2);
    return (char *)this + v21;
  }
  if (v8 == 0 || v8 >= 0xFFFFFFFB)
  {
    v16 = 2 - v8;
    memmove((char *)this + v16, this, (int)a2);
    *(_WORD *)this = 11824;
    if (v8 < 0)
    {
      if ((int)v16 <= 3)
        v17 = 3;
      else
        v17 = 2 - v8;
      memset((char *)this + 2, 48, (v17 - 2));
    }
    if (-a3 <= a4)
    {
      v21 = v16 + v6;
      return (char *)this + v21;
    }
    if (a4 >= 2)
    {
      for (i = a4 + 2; ; --i)
      {
        v19 = i - 1;
        if (*((_BYTE *)this + i - 1) != 48)
          break;
        if (v19 < 4)
          return (char *)this + 3;
      }
      return (char *)this + i;
    }
    return (char *)this + 3;
  }
  if (v8 < -a4)
  {
    *(_WORD *)this = 11824;
    *((_BYTE *)this + 2) = 48;
    return (char *)this + 3;
  }
  if ((_DWORD)a2 == 1)
  {
    *((_BYTE *)this + 1) = 101;
    if ((v14 & 0x80000000) == 0)
    {
      v11 = (char *)this + 2;
      goto LABEL_44;
    }
    v11 = (char *)this + 3;
    *((_BYTE *)this + 2) = 45;
  }
  else
  {
    memmove((char *)this + 2, (char *)this + 1, (int)a2 - 1);
    *((_BYTE *)this + 1) = 46;
    *((_BYTE *)this + v6 + 1) = 101;
    v11 = (char *)this + v6 + 2;
    if ((v14 & 0x80000000) == 0)
      goto LABEL_44;
    *v11++ = 45;
  }
  v14 = 1 - v8;
LABEL_44:
  if (v14 < 0x64)
  {
    if (v14 >= 0xA)
    {
      v12 = rapidjson::internal::GetDigitsLut(void)::cDigitsLut[v14];
LABEL_9:
      *(_WORD *)v11 = v12;
      return v11 + 2;
    }
    *v11 = v14 + 48;
    return v11 + 1;
  }
  else
  {
    *v11 = v14 / 0x64 + 48;
    *(_WORD *)(v11 + 1) = rapidjson::internal::GetDigitsLut(void)::cDigitsLut[v14 % 0x64];
    return v11 + 3;
  }
}

unint64_t rapidjson::internal::DiyFp::operator*(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;

  v2 = HIDWORD(*a1);
  v3 = HIDWORD(*a2);
  v4 = v3 * (unint64_t)*a1;
  v5 = *a2 * (unint64_t)v2;
  return HIDWORD(v5)
       + v3 * (unint64_t)v2
       + HIDWORD(v4)
       + ((((*a2 * (unint64_t)*a1) >> 32)
         + v5
         + v4
         + 0x80000000) >> 32);
}

uint64_t rapidjson::internal::DigitGen(uint64_t *a1, uint64_t *a2, unint64_t a3, uint64_t a4, int *a5, _DWORD *a6)
{
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t result;
  unsigned int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t *v34;
  int v35;
  unint64_t v36;
  unint64_t v37;
  int v38;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;

  v6 = -*((_DWORD *)a2 + 2);
  v7 = 1 << -*((_BYTE *)a2 + 8);
  v8 = *a2;
  v9 = *a1;
  v10 = *a2 - *a1;
  v11 = (unint64_t)*a2 >> -*((_BYTE *)a2 + 8);
  v12 = (v7 - 1) & v8;
  if (v11 < 0x5F5E100)
    v13 = 8;
  else
    v13 = 9;
  if (v11 >= 0x989680)
    v14 = v13;
  else
    v14 = 7;
  if (v11 >= 0xF4240)
    v15 = v14;
  else
    v15 = 6;
  if (v11 >= 0x186A0)
    v16 = v15;
  else
    v16 = 5;
  if (v11 >> 4 >= 0x271)
    v17 = v16;
  else
    v17 = 4;
  if (v11 >= 0x3E8)
    v18 = v17;
  else
    v18 = 3;
  if (v11 >= 0x64)
    LODWORD(result) = v18;
  else
    LODWORD(result) = 2;
  if (v11 < 0xA)
    LODWORD(result) = 1;
  *a5 = 0;
  while (2)
  {
    if ((int)result <= 0)
    {
      v34 = rapidjson::internal::DigitGen(rapidjson::internal::DiyFp const&,rapidjson::internal::DiyFp const&,unsigned long long,char *,int *,int *)::kPow10;
      v35 = 1;
      do
      {
        v36 = a3;
        v37 = 10 * v12;
        result = (v37 >> v6);
        v38 = *a5;
        if ((v37 >> v6))
          v39 = 0;
        else
          v39 = v38 == 0;
        if (!v39)
        {
          result = (v38 + 1);
          *a5 = result;
          *(_BYTE *)(a4 + v38) = (v37 >> v6) + 48;
        }
        a3 *= 10;
        v12 = v37 & (v7 - 1);
        ++v34;
        --v35;
      }
      while (10 * v36 <= v12);
      *a6 = *a6 + v35 - 1;
      if (v35 < -18)
        v40 = 0;
      else
        v40 = *v34;
      if (10 * v36 - v12 >= v7)
      {
        v41 = v40 * v10;
        if (v12 < v40 * v10)
        {
          v42 = *a5 - 1;
          v43 = -(uint64_t)v12;
          v44 = -(uint64_t)(v40 * v10);
          v45 = v7 + v12;
          v46 = 10 * v36 - v7;
          do
          {
            if (v45 >= v41 && v41 + v43 <= v44 + v45)
              break;
            --*(_BYTE *)(a4 + v42);
            if (v45 >= v41)
              break;
            v47 = v46 + v43;
            v43 -= v7;
            v45 += v7;
          }
          while (v47 >= v7);
        }
      }
    }
    else
    {
      result = (result - 1);
      v20 = 0;
      switch((int)result)
      {
        case 0:
          goto LABEL_38;
        case 1:
          v21 = v11 / 0xA;
          v20 = v11 % 0xA;
          goto LABEL_32;
        case 2:
          v21 = v11 / 0x64;
          v20 = v11 % 0x64;
          goto LABEL_32;
        case 3:
          v21 = v11 / 0x3E8;
          v20 = v11 % 0x3E8;
          goto LABEL_32;
        case 4:
          v21 = v11 / 0x2710;
          v20 = v11 % 0x2710;
LABEL_32:
          LODWORD(v11) = v21;
          goto LABEL_38;
        case 5:
          v23 = v11 / 0x186A0;
          v20 = v11 % 0x186A0;
          goto LABEL_37;
        case 6:
          v23 = v11 / 0xF4240;
          v20 = v11 % 0xF4240;
          goto LABEL_37;
        case 7:
          v23 = v11 / 0x989680;
          v20 = v11 % 0x989680;
          goto LABEL_37;
        case 8:
          v23 = v11 / 0x5F5E100;
          v20 = v11 % 0x5F5E100;
LABEL_37:
          LODWORD(v11) = v23;
LABEL_38:
          v24 = v11;
          v22 = *a5;
          LODWORD(v11) = v20;
          if (!v24)
            goto LABEL_39;
          goto LABEL_41;
        default:
          v22 = *a5;
LABEL_39:
          if (v22)
          {
            LOBYTE(v24) = 0;
LABEL_41:
            *a5 = v22 + 1;
            *(_BYTE *)(a4 + v22) = v24 + 48;
          }
          v25 = (unint64_t)v11 << v6;
          if (a3 < v25 + v12)
            continue;
          *a6 += result;
          if (v25 + v12 < v10)
          {
            v26 = rapidjson::internal::DigitGen(rapidjson::internal::DiyFp const&,rapidjson::internal::DiyFp const&,unsigned long long,char *,int *,int *)::kPow10[result] << v6;
            if (a3 - (v25 + v12) >= v26)
            {
              v27 = *a5 - 1;
              v28 = v10 - v12;
              v29 = -(uint64_t)v25;
              v30 = v9 - v8;
              v31 = v12 + v26 + v25;
              v32 = a3 - v12 - v26;
              do
              {
                if (v31 >= v10 && v28 + v29 <= v30 + v31)
                  break;
                --*(_BYTE *)(a4 + v27);
                if (v31 >= v10)
                  break;
                v33 = v32 + v29;
                v29 -= v26;
                v31 += v26;
              }
              while (v33 >= v26);
            }
          }
          break;
      }
    }
    return result;
  }
}

uint64_t rapidjson::internal::DiyFp::NormalizeBoundary(rapidjson::internal::DiyFp *this)
{
  unint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *(_QWORD *)this;
  v1 = *((_QWORD *)this + 1);
  if ((*(_QWORD *)this & 0x20000000000000) == 0)
  {
    v3 = __clz(v2 & 0x1FFFFFFFFFFFFFLL) - 10;
    v4 = v3;
    do
    {
      v1 = (v1 - 1) | v1 & 0xFFFFFFFF00000000;
      --v4;
    }
    while (v4);
    v2 <<= v3;
  }
  return v2 << 10;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(uint64_t a1, const char *a2, uint64_t a3, double *a4, char a5)
{
  int v5;
  double v9;
  char *v10;
  const char *v11;
  uint64_t v12;
  const char *v14;
  const char *v15;

  v15 = a2;
  v5 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v15);
    v9 = *a4;
    v10 = *(char **)(a1 + 168);
    if (fabs(v9) != INFINITY)
    {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble((uint64_t)v10, v9);
      if ((a5 & 2) != 0)
        return v5 == 0;
      goto LABEL_8;
    }
    v11 = "-Infinity";
    if (v9 > 0.0)
      v11 = "Infinity";
    v14 = v11;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(v10, &v14);
    if ((a5 & 2) == 0)
    {
LABEL_8:
      v12 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v12 - 16);
    }
  }
  return v5 == 0;
}

uint64_t re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, re::TypeInfo *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  _BOOL4 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t result;
  const char *v20;
  _anonymous_namespace_ *v21;
  _BOOL4 v22;
  size_t v23;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 != (unsigned __int16)v16
      || ((v18 = WORD1(v15) == WORD1(v16), v17 = (v16 ^ v15) & 0xFFFFFF00000000, v18) ? (v18 = v17 == 0) : (v18 = 0),
          !v18))
    {
      v14 = 1;
      if (!a7)
        goto LABEL_11;
      goto LABEL_15;
    }
LABEL_14:
    v14 = 0;
    if (!a7)
      goto LABEL_11;
LABEL_15:
    v23 = 0;
    v22 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v23, 0);
    result = 0;
    if (!v22)
      return result;
    if (v23)
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    v21 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_19;
  }
  v14 = !re::areSameTranslatedVersion(a5, a6, a3);
  if (a7)
    goto LABEL_15;
LABEL_11:
  result = re::internal::findEnumConstantToSerialize<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a4, a5, a6, v14);
  if (!result)
    return result;
  v20 = *(const char **)(result + 16);
  v23 = strlen(v20);
  if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v23, 0))
  {
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, (uint64_t)v20, 0);
    v21 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_19:
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString(v21);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(uint64_t a1, const char *a2, uint64_t a3, uint64_t *a4, int a5)
{
  int v5;
  uint64_t v9;
  char *v10;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;

  v17 = a2;
  v5 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v17);
    v9 = *a4;
    if (!*a4)
    {
      v10 = *(char **)(a1 + 168);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v10);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v10, (uint64_t)"", 0);
      v9 = *a4;
    }
    LOBYTE(v12) = 8;
    DWORD1(v12) = a5 & 0xFFFFFFDF;
    *((_QWORD *)&v12 + 1) = v17;
    v13 = 0;
    v15 = 0;
    v16 = 0;
    v14 = v9;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v12);
  }
  return v5 == 0;
}

uint64_t re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(uint64_t result, uint64_t a2, char a3)
{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;

  if (!*(_BYTE *)(result + 40))
  {
    v5 = result;
    v6 = *(_QWORD *)(*(_QWORD *)(result + 128) + 48 * *(_QWORD *)(result + 112) - 24);
    v7 = *(char **)(result + 168);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v7);
    result = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v7, a2, v6);
    if ((a3 & 2) == 0)
    {
      v8 = *(_QWORD *)(v5 + 128) + 48 * *(_QWORD *)(v5 + 112);
      *(_QWORD *)(v8 - 16) += v6;
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  _OWORD v8[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 8);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v3 = *(_BYTE **)&v7[7];
      else
        v3 = v7;
      v4 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize string \"%s\". Expected number of characters: %lld. Actual number of characters: %lld.", (re::DynamicString *)v8, v3, *(_QWORD *)(v4 - 24), *(_QWORD *)(v4 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(_QWORD *)&v8[0])
      {
        if ((BYTE8(v8[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v8[0] + 40))();
        memset(v8, 0, sizeof(v8));
      }
      result = v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::internal::findEnumConstantToSerialize<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, re::TypeInfo *a3, re::internal *this, re::TypeInfo *a5, int a6)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int EnumConstantIndex;
  unsigned int v18;
  re::internal::TypeTranslationTable *v19;
  uint64_t result;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t __dst;

  if (*(_DWORD *)(*((_QWORD *)this + 2) + 8) >= 9u)
  {
    v38 = re::TypeInfo::name(this)[1];
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Enum type \"%s\" has invalid size: %zu bytes", v9, v10, v11, v12, v13, v38);
    return 0;
  }
  EnumConstantIndex = re::internal::getEnumConstantIndex(this, a3, a3);
  if ((EnumConstantIndex & 0x80000000) != 0)
  {
    __dst = 0;
    memcpy(&__dst, a3, *(unsigned int *)(*((_QWORD *)this + 2) + 8));
    v30 = __dst;
    re::TypeInfo::name(this);
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v31, v32, v33, v34, v35, v30);
    return 0;
  }
  v18 = EnumConstantIndex;
  if (!a6)
  {
    v36 = re::TypeInfo::enumConstants(this);
    if (v37 > v18)
      return v36 + 24 * v18;
    re::internal::assertLog((re::internal *)6, v37, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v18, v37);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  v19 = *(re::internal::TypeTranslationTable **)(*(_QWORD *)a5 + 856);
  if (!v19 || (result = re::internal::TypeTranslationTable::translateRuntimeEnum(v19, this, v18, a5)) == 0)
  {
    v21 = re::TypeInfo::enumConstants(this);
    v23 = v18;
    if (v22 > v18)
    {
      v24 = *(_QWORD *)(v21 + 24 * v18 + 16);
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Runtime enum constant \"%s\" does not exist in serialized type \"%s\".", v25, v26, v27, v28, v29, v24);
      return 0;
    }
LABEL_15:
    re::internal::assertLog((re::internal *)6, v22, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v23, v22);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(uint64_t a1, const char *a2, _BYTE *a3)
{
  uint64_t v5;
  char *v6;
  double result;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;

  v13 = a2;
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v13);
    if (*a3)
    {
      v5 = 1;
    }
    else
    {
      v6 = *(char **)(a1 + 168);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull((uint64_t *)v6);
      v5 = *a3;
    }
    LOBYTE(v8) = 3;
    DWORD1(v8) = 0;
    *((_QWORD *)&v8 + 1) = v13;
    v9 = 0;
    v11 = 0;
    v12 = 0;
    v10 = v5;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v8);
  }
  return result;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull(uint64_t *a1)
{
  uint64_t v2;
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;

  v2 = *a1;
  v3 = *(_BYTE **)(v2 + 24);
  if ((uint64_t)(*(_QWORD *)(v2 + 32) - (_QWORD)v3) <= 3)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v2, 4);
    v2 = *a1;
    v3 = *(_BYTE **)(*a1 + 24);
  }
  *(_QWORD *)(v2 + 24) = v3 + 1;
  *v3 = 110;
  v4 = *(_BYTE **)(*a1 + 24);
  *(_QWORD *)(*a1 + 24) = v4 + 1;
  *v4 = 117;
  v5 = *(_BYTE **)(*a1 + 24);
  *(_QWORD *)(*a1 + 24) = v5 + 1;
  *v5 = 108;
  v6 = *(_BYTE **)(*a1 + 24);
  *(_QWORD *)(*a1 + 24) = v6 + 1;
  *v6 = 108;
  return 1;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(uint64_t a1, const char *a2, uint64_t a3, uint64_t *a4, int a5)
{
  int v5;
  uint64_t v9;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;

  v16 = a2;
  v5 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v16);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(*(_QWORD *)(a1 + 168));
    v9 = *a4;
    LOBYTE(v11) = 5;
    DWORD1(v11) = a5 & 0xFFFFFFDF;
    *((_QWORD *)&v11 + 1) = v16;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v9;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
  }
  return v5 == 0;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endArray(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t *v2;
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  char v7;
  _BYTE v8[23];
  _OWORD v9[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      v2 = (uint64_t *)*((_QWORD *)result + 21);
      v2[4] -= 16;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndArray(v2);
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 5);
      v3 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      ++*(_QWORD *)(v3 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v6);
      if ((v7 & 1) != 0)
        v4 = *(_BYTE **)&v8[7];
      else
        v4 = v8;
      v5 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)v9, v4, *(_QWORD *)(v5 - 24), *(_QWORD *)(v5 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v9);
      if (*(_QWORD *)&v9[0])
      {
        if ((BYTE8(v9[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v9[0] + 40))();
        memset(v9, 0, sizeof(v9));
      }
      result = v6;
      if (v6)
      {
        if ((v7 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v6 + 40))();
      }
    }
  }
  return result;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(uint64_t a1)
{
  uint64_t v2;

  rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix((char *)a1);
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 40) - v2 <= 15)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Level>(a1 + 8, 1);
    v2 = *(_QWORD *)(a1 + 32);
  }
  *(_QWORD *)(a1 + 32) = v2 + 16;
  *(_QWORD *)v2 = 0;
  *(_BYTE *)(v2 + 8) = 1;
  return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteStartArray((uint64_t *)a1);
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteStartArray(uint64_t *a1)
{
  uint64_t v1;
  _BYTE *v2;

  v1 = *a1;
  v2 = *(_BYTE **)(*a1 + 24);
  if ((uint64_t)(*(_QWORD *)(*a1 + 32) - (_QWORD)v2) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, 1);
    v2 = *(_BYTE **)(v1 + 24);
  }
  *(_QWORD *)(v1 + 24) = v2 + 1;
  *v2 = 91;
  return 1;
}

char *rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Level>(uint64_t a1, uint64_t a2)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  re::internal::RapidJSONAllocator *v7;
  uint64_t v8;
  size_t v9;
  char *result;

  v4 = *(void **)(a1 + 16);
  if (v4)
  {
    v5 = *(_QWORD *)(a1 + 32) - (_QWORD)v4;
    v6 = v5 + ((v5 + 1) >> 1);
    v7 = *(re::internal::RapidJSONAllocator **)a1;
  }
  else
  {
    v7 = *(re::internal::RapidJSONAllocator **)a1;
    if (*(_QWORD *)a1)
    {
      v4 = 0;
    }
    else
    {
      v7 = (re::internal::RapidJSONAllocator *)(*(uint64_t (**)(void *, uint64_t, _QWORD))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                                                  + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 1, 0);
      *(_QWORD *)a1 = v7;
      *(_QWORD *)(a1 + 8) = v7;
      v4 = *(void **)(a1 + 16);
    }
    v6 = *(_QWORD *)(a1 + 40);
    v5 = *(_QWORD *)(a1 + 32) - (_QWORD)v4;
  }
  v8 = *(_QWORD *)(a1 + 24) - (_QWORD)v4;
  if (v6 <= v8 + 16 * a2)
    v9 = v8 + 16 * a2;
  else
    v9 = v6;
  result = (char *)re::internal::RapidJSONAllocator::Realloc(v7, v4, v5, v9);
  *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 24) = &result[v8];
  *(_QWORD *)(a1 + 32) = &result[v9];
  return result;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndArray(uint64_t *a1)
{
  uint64_t v1;
  _BYTE *v2;

  v1 = *a1;
  v2 = *(_BYTE **)(*a1 + 24);
  if ((uint64_t)(*(_QWORD *)(*a1 + 32) - (_QWORD)v2) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, 1);
    v2 = *(_BYTE **)(v1 + 24);
  }
  *(_QWORD *)(v1 + 24) = v2 + 1;
  *v2 = 93;
  return 1;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, __n128 *, _QWORD, unint64_t *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t **v30;
  unint64_t **v31;
  unint64_t *v32;
  unint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[16];
  uint64_t v41;
  _BYTE v42[32];
  _BYTE v43[32];
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  unint64_t **v48;
  __n128 v49[2];
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v44),
        re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45),
        v43[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v43))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v45);
  re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v43);
  if (v19)
  {
    v20 = (void (*)(uint64_t, __n128 *, _QWORD, unint64_t *, _BYTE *, _BYTE *, _QWORD))v19;
    v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v41 + 88))(a4);
    if (v23)
    {
      v48 = 0;
      v45 = 0;
      v46 = 0;
      v47 = 0;
      v44 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v44, v23);
      ++v47;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v41 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v41 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v41 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v41 + 136))(v24);
          v49[0].n128_u64[0] = v25;
          v49[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v44, v49);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v41 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v41 + 144))(v24, v18);
      v28 = 126 - 2 * __clz(v46);
      if (v46)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(v48, &v48[2 * v46], v29, 1);
      if (v46)
      {
        v30 = v48;
        v31 = &v48[2 * v46];
        do
        {
          v32 = *v30;
          v33 = v30[1];
          v30 += 2;
          *(_BYTE *)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v49, *v32) = 0;
          v20(a1, v49, 0, v33, v43, v42, 0);
        }
        while (v30 != v31);
      }
      if (v44)
      {
        if (v48)
          (*(void (**)(void))(*(_QWORD *)v44 + 40))();
      }
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v34 = re::TypeInfo::name((re::TypeInfo *)v43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v35, v36, v37, v38, v39, v34[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, __n128 *, _QWORD, unsigned int *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int **v30;
  unsigned int **v31;
  unsigned int *v32;
  unsigned int *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[16];
  uint64_t v41;
  _BYTE v42[32];
  _BYTE v43[32];
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  unsigned int **v48;
  __n128 v49[2];
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v44),
        re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45),
        v43[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v43))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v45);
  re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v43);
  if (v19)
  {
    v20 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned int *, _BYTE *, _BYTE *, _QWORD))v19;
    v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v41 + 88))(a4);
    if (v23)
    {
      v48 = 0;
      v45 = 0;
      v46 = 0;
      v47 = 0;
      v44 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v44, v23);
      ++v47;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v41 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v41 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v41 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v41 + 136))(v24);
          v49[0].n128_u64[0] = v25;
          v49[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v44, v49);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v41 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v41 + 144))(v24, v18);
      v28 = 126 - 2 * __clz(v46);
      if (v46)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(v48, &v48[2 * v46], v29, 1);
      if (v46)
      {
        v30 = v48;
        v31 = &v48[2 * v46];
        do
        {
          v32 = *v30;
          v33 = v30[1];
          v30 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v49, *v32) = 0;
          v20(a1, v49, 0, v33, v43, v42, 0);
        }
        while (v30 != v31);
      }
      if (v44)
      {
        if (v48)
          (*(void (**)(void))(*(_QWORD *)v44 + 40))();
      }
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v34 = re::TypeInfo::name((re::TypeInfo *)v43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v35, v36, v37, v38, v39, v34[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, __n128 *, _QWORD, unsigned __int16 *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  unsigned __int16 **v30;
  unsigned __int16 **v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[16];
  uint64_t v41;
  _BYTE v42[32];
  _BYTE v43[32];
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  unsigned __int16 **v48;
  __n128 v49[2];
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v44),
        re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45),
        v43[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v43))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v45);
  re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v43);
  if (v19)
  {
    v20 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned __int16 *, _BYTE *, _BYTE *, _QWORD))v19;
    v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v41 + 88))(a4);
    if (v23)
    {
      v48 = 0;
      v45 = 0;
      v46 = 0;
      v47 = 0;
      v44 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v44, v23);
      ++v47;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v41 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v41 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v41 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v41 + 136))(v24);
          v49[0].n128_u64[0] = v25;
          v49[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v44, v49);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v41 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v41 + 144))(v24, v18);
      v28 = 126 - 2 * __clz(v46);
      if (v46)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(v48, &v48[2 * v46], v29, 1);
      if (v46)
      {
        v30 = v48;
        v31 = &v48[2 * v46];
        do
        {
          v32 = *v30;
          v33 = v30[1];
          v30 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v49, *v32) = 0;
          v20(a1, v49, 0, v33, v43, v42, 0);
        }
        while (v30 != v31);
      }
      if (v44)
      {
        if (v48)
          (*(void (**)(void))(*(_QWORD *)v44 + 40))();
      }
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v34 = re::TypeInfo::name((re::TypeInfo *)v43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v35, v36, v37, v38, v39, v34[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, __n128 *, _QWORD, unsigned __int8 *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  unsigned __int8 **v30;
  unsigned __int8 **v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[16];
  uint64_t v41;
  _BYTE v42[32];
  _BYTE v43[32];
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  unsigned __int8 **v48;
  __n128 v49[2];
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v44),
        re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45),
        v43[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v43))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v45);
  re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v43);
  if (v19)
  {
    v20 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned __int8 *, _BYTE *, _BYTE *, _QWORD))v19;
    v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v41 + 88))(a4);
    if (v23)
    {
      v48 = 0;
      v45 = 0;
      v46 = 0;
      v47 = 0;
      v44 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v44, v23);
      ++v47;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v41 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v41 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v41 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v41 + 136))(v24);
          v49[0].n128_u64[0] = v25;
          v49[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v44, v49);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v41 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v41 + 144))(v24, v18);
      v28 = 126 - 2 * __clz(v46);
      if (v46)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(v48, &v48[2 * v46], v29, 1);
      if (v46)
      {
        v30 = v48;
        v31 = &v48[2 * v46];
        do
        {
          v32 = *v30;
          v33 = v30[1];
          v30 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v49, *v32) = 0;
          v20(a1, v49, 0, v33, v43, v42, 0);
        }
        while (v30 != v31);
      }
      if (v44)
      {
        if (v48)
          (*(void (**)(void))(*(_QWORD *)v44 + 40))();
      }
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v34 = re::TypeInfo::name((re::TypeInfo *)v43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v35, v36, v37, v38, v39, v34[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, __n128 *, _QWORD, uint64_t *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v21;
  _BOOL4 v22;
  _BOOL8 result;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __n128 v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t **v31;
  uint64_t **v32;
  unint64_t v33;
  __n128 *v34;
  uint64_t *v35;
  unsigned int v36;
  int64_t v37;
  _WORD *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _BYTE v45[16];
  uint64_t v46;
  _BYTE v47[32];
  _BYTE v48[32];
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  uint64_t **v53;
  __n128 v54[2];
  _QWORD v55[2];

  v55[0] = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v49),
        re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50),
        v48[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v48))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v50);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v48);
  if (v19)
  {
    v20 = (void (*)(uint64_t, __n128 *, _QWORD, uint64_t *, _BYTE *, _BYTE *, _QWORD))v19;
    v21 = (_anonymous_namespace_ *)(a1 + 24);
    v22 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    result = 0;
    if (!v22)
      return result;
    v24 = (*(uint64_t (**)(uint64_t))(v46 + 88))(a4);
    if (v24)
    {
      v53 = 0;
      v50 = 0;
      v51 = 0;
      v52 = 0;
      v49 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v49, v24);
      ++v52;
      v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v46 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v46 + 120))())
      {
        do
        {
          v26 = (*(uint64_t (**)(uint64_t))(v46 + 128))(v25);
          v27 = (*(uint64_t (**)(uint64_t))(v46 + 136))(v25);
          v54[0].n128_u64[0] = v26;
          v54[0].n128_u64[1] = v27;
          v28 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v49, v54);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v46 + 120))(v25, v28) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v46 + 144))(v25, v18);
      v29 = 126 - 2 * __clz(v51);
      if (v51)
        v30 = v29;
      else
        v30 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(v53, (__n128 *)&v53[2 * v51], v30, 1);
      if (v51)
      {
        v31 = v53;
        v32 = &v53[2 * v51];
        do
        {
          v33 = **v31;
          if ((v33 & 0x8000000000000000) != 0)
          {
            v54[0].n128_u8[0] = 45;
            v33 = -(uint64_t)v33;
            v34 = (__n128 *)((char *)v54[0].n128_u64 + 1);
          }
          else
          {
            v34 = v54;
          }
          v35 = v31[1];
          if ((char *)v55 - (char *)v34 > 19
            || (v36 = (1233 * (64 - __clz(v33 | 1))) >> 12,
                v37 = v36 - (std::__itoa::__pow10_64[v36] > v33) + 1,
                v38 = v55,
                (char *)v55 - (char *)v34 >= v37))
          {
            v38 = std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v34, v33);
          }
          *(_BYTE *)v38 = 0;
          v20(a1, v54, 0, v35, v48, v47, 0);
          v31 += 2;
        }
        while (v31 != v32);
      }
      if (v49)
      {
        if (v53)
          (*(void (**)(void))(*(_QWORD *)v49 + 40))();
      }
      v21 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v21);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v39 = re::TypeInfo::name((re::TypeInfo *)v48);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v40, v41, v42, v43, v44, v39[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, __n128 *, _QWORD, int *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v21;
  _BOOL4 v22;
  _BOOL8 result;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __n128 v28;
  unint64_t v29;
  uint64_t v30;
  int **v31;
  int **v32;
  unsigned int v33;
  __n128 *v34;
  int *v35;
  unsigned int v36;
  int64_t v37;
  _WORD *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _BYTE v45[16];
  uint64_t v46;
  _BYTE v47[32];
  _BYTE v48[32];
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  int **v53;
  __n128 v54[2];
  _QWORD v55[2];

  v55[0] = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v49),
        re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50),
        v48[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v48))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v50);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v48);
  if (v19)
  {
    v20 = (void (*)(uint64_t, __n128 *, _QWORD, int *, _BYTE *, _BYTE *, _QWORD))v19;
    v21 = (_anonymous_namespace_ *)(a1 + 24);
    v22 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    result = 0;
    if (!v22)
      return result;
    v24 = (*(uint64_t (**)(uint64_t))(v46 + 88))(a4);
    if (v24)
    {
      v53 = 0;
      v50 = 0;
      v51 = 0;
      v52 = 0;
      v49 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v49, v24);
      ++v52;
      v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v46 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v46 + 120))())
      {
        do
        {
          v26 = (*(uint64_t (**)(uint64_t))(v46 + 128))(v25);
          v27 = (*(uint64_t (**)(uint64_t))(v46 + 136))(v25);
          v54[0].n128_u64[0] = v26;
          v54[0].n128_u64[1] = v27;
          v28 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v49, v54);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v46 + 120))(v25, v28) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v46 + 144))(v25, v18);
      v29 = 126 - 2 * __clz(v51);
      if (v51)
        v30 = v29;
      else
        v30 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(v53, (__n128 *)&v53[2 * v51], v30, 1);
      if (v51)
      {
        v31 = v53;
        v32 = &v53[2 * v51];
        do
        {
          v33 = **v31;
          if ((v33 & 0x80000000) != 0)
          {
            v54[0].n128_u8[0] = 45;
            v33 = -v33;
            v34 = (__n128 *)((char *)v54[0].n128_u64 + 1);
          }
          else
          {
            v34 = v54;
          }
          v35 = v31[1];
          if ((char *)v55 - (char *)v34 > 9
            || (v36 = (1233 * (32 - __clz(v33 | 1))) >> 12,
                v37 = (((__PAIR64__(v36, v33) - std::__itoa::__pow10_32[v36]) >> 32) + 1),
                v38 = v55,
                (char *)v55 - (char *)v34 >= v37))
          {
            v38 = std::__itoa::__base_10_u32[abi:nn180100](v34, v33);
          }
          *(_BYTE *)v38 = 0;
          v20(a1, v54, 0, v35, v48, v47, 0);
          v31 += 2;
        }
        while (v31 != v32);
      }
      if (v49)
      {
        if (v53)
          (*(void (**)(void))(*(_QWORD *)v49 + 40))();
      }
      v21 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v21);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v39 = re::TypeInfo::name((re::TypeInfo *)v48);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v40, v41, v42, v43, v44, v39[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, __n128 *, _QWORD, __int16 *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v21;
  _BOOL4 v22;
  _BOOL8 result;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __n128 v28;
  unint64_t v29;
  uint64_t v30;
  __int16 **v31;
  __int16 **v32;
  unsigned int v33;
  __n128 *v34;
  __int16 *v35;
  unsigned int v36;
  int64_t v37;
  _WORD *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _BYTE v45[16];
  uint64_t v46;
  _BYTE v47[32];
  _BYTE v48[32];
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  __int16 **v53;
  __n128 v54[2];
  _QWORD v55[2];

  v55[0] = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v49),
        re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50),
        v48[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v48))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v50);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v48);
  if (v19)
  {
    v20 = (void (*)(uint64_t, __n128 *, _QWORD, __int16 *, _BYTE *, _BYTE *, _QWORD))v19;
    v21 = (_anonymous_namespace_ *)(a1 + 24);
    v22 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    result = 0;
    if (!v22)
      return result;
    v24 = (*(uint64_t (**)(uint64_t))(v46 + 88))(a4);
    if (v24)
    {
      v53 = 0;
      v50 = 0;
      v51 = 0;
      v52 = 0;
      v49 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v49, v24);
      ++v52;
      v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v46 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v46 + 120))())
      {
        do
        {
          v26 = (*(uint64_t (**)(uint64_t))(v46 + 128))(v25);
          v27 = (*(uint64_t (**)(uint64_t))(v46 + 136))(v25);
          v54[0].n128_u64[0] = v26;
          v54[0].n128_u64[1] = v27;
          v28 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v49, v54);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v46 + 120))(v25, v28) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v46 + 144))(v25, v18);
      v29 = 126 - 2 * __clz(v51);
      if (v51)
        v30 = v29;
      else
        v30 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(v53, &v53[2 * v51], v30, 1);
      if (v51)
      {
        v31 = v53;
        v32 = &v53[2 * v51];
        do
        {
          v33 = **v31;
          if ((v33 & 0x80000000) != 0)
          {
            v54[0].n128_u8[0] = 45;
            v33 = -v33;
            v34 = (__n128 *)((char *)v54[0].n128_u64 + 1);
          }
          else
          {
            v34 = v54;
          }
          v35 = v31[1];
          if ((char *)v55 - (char *)v34 > 9
            || (v36 = (1233 * (32 - __clz(v33 | 1))) >> 12,
                v37 = (((__PAIR64__(v36, v33) - std::__itoa::__pow10_32[v36]) >> 32) + 1),
                v38 = v55,
                (char *)v55 - (char *)v34 >= v37))
          {
            v38 = std::__itoa::__base_10_u32[abi:nn180100](v34, v33);
          }
          *(_BYTE *)v38 = 0;
          v20(a1, v54, 0, v35, v48, v47, 0);
          v31 += 2;
        }
        while (v31 != v32);
      }
      if (v49)
      {
        if (v53)
          (*(void (**)(void))(*(_QWORD *)v49 + 40))();
      }
      v21 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v21);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v39 = re::TypeInfo::name((re::TypeInfo *)v48);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v40, v41, v42, v43, v44, v39[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, re *a6, int a7)
{
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v25;
  _BOOL8 result;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __n128 v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __n128 v44;
  char v45[16];
  uint64_t v46;
  _BYTE v47[32];
  _BYTE v48[32];
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  uint64_t *v53;

  if (a5 == a6)
    goto LABEL_14;
  v14 = *(_QWORD **)a5;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v16 = **((_QWORD **)a5 + 2);
    v15 = (uint64_t *)*((_QWORD *)a6 + 2);
    v17 = *v15;
    if ((unsigned __int16)v16 != (unsigned __int16)*v15)
      goto LABEL_10;
    v19 = WORD1(v16) == WORD1(v17);
    v18 = (v17 ^ v16) & 0xFFFFFF00000000;
    v19 = v19 && v18 == 0;
    if (!v19)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v22 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v49);
      re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v49);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v50);
      re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)a5);
      v23 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v48);
      if (!v23)
      {
        v38 = re::TypeInfo::name((re::TypeInfo *)v48);
        re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v39, v40, v41, v42, v43, v38[1]);
        return 0;
      }
      v24 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v23;
      v25 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
      result = 0;
      if (!v25)
        return result;
      v27 = (*(uint64_t (**)(uint64_t))(v46 + 88))(a4);
      if (v27)
      {
        v53 = 0;
        v50 = 0;
        v51 = 0;
        v52 = 0;
        v49 = v22;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v49, v27);
        ++v52;
        v28 = (*(uint64_t (**)(uint64_t, uint64_t))(v46 + 112))(a4, v22);
        if ((*(unsigned int (**)(void))(v46 + 120))())
        {
          do
          {
            v29 = (*(uint64_t (**)(uint64_t))(v46 + 128))(v28);
            v30 = (*(uint64_t (**)(uint64_t))(v46 + 136))(v28);
            v44.n128_u64[0] = v29;
            v44.n128_u64[1] = v30;
            v31 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v49, &v44);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v46 + 120))(v28, v31) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v46 + 144))(v28, v22);
        v32 = 126 - 2 * __clz(v51);
        if (v51)
          v33 = v32;
        else
          v33 = 0;
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(v53, &v53[2 * v51], v33, 1);
        if (v51)
        {
          v34 = v53;
          v35 = &v53[2 * v51];
          do
          {
            v36 = *v34;
            if ((*(_BYTE *)(*v34 + 8) & 1) != 0)
              v37 = *(_QWORD *)(v36 + 16);
            else
              v37 = v36 + 9;
            v24(a1, v37, 0, v34[1], v48, v47, 0);
            v34 += 2;
          }
          while (v34 != v35);
        }
        if (v49)
        {
          if (v53)
            (*(void (**)(void))(*(_QWORD *)v49 + 40))();
        }
      }
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_14;
  v14 = *(_QWORD **)a6;
  v15 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v14, v15[9], &v49);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
  v20 = re::TypeInfo::name((re::TypeInfo *)v48);
  if ((unint64_t)*v20 >> 1 == 0x22C6ED80D0CLL)
  {
    v21 = (char *)v20[1];
    if (v21 == "StringID" || !strcmp(v21, "StringID"))
      goto LABEL_14;
  }
  re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, re *a6, int a7)
{
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v25;
  _BOOL8 result;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __n128 v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __n128 v44;
  _BYTE v45[16];
  uint64_t v46;
  _BYTE v47[32];
  _BYTE v48[32];
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  uint64_t *v53;

  if (a5 == a6)
    goto LABEL_14;
  v14 = *(_QWORD **)a5;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v16 = **((_QWORD **)a5 + 2);
    v15 = (uint64_t *)*((_QWORD *)a6 + 2);
    v17 = *v15;
    if ((unsigned __int16)v16 != (unsigned __int16)*v15)
      goto LABEL_10;
    v19 = WORD1(v16) == WORD1(v17);
    v18 = (v17 ^ v16) & 0xFFFFFF00000000;
    v19 = v19 && v18 == 0;
    if (!v19)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v22 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v49);
      re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v49);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v50);
      re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)a5);
      v23 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v48);
      if (!v23)
      {
        v38 = re::TypeInfo::name((re::TypeInfo *)v48);
        re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v39, v40, v41, v42, v43, v38[1]);
        return 0;
      }
      v24 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v23;
      v25 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
      result = 0;
      if (!v25)
        return result;
      v27 = (*(uint64_t (**)(uint64_t))(v46 + 88))(a4);
      if (v27)
      {
        v53 = 0;
        v50 = 0;
        v51 = 0;
        v52 = 0;
        v49 = v22;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v49, v27);
        ++v52;
        v28 = (*(uint64_t (**)(uint64_t, uint64_t))(v46 + 112))(a4, v22);
        if ((*(unsigned int (**)(void))(v46 + 120))())
        {
          do
          {
            v29 = (*(uint64_t (**)(uint64_t))(v46 + 128))(v28);
            v30 = (*(uint64_t (**)(uint64_t))(v46 + 136))(v28);
            v44.n128_u64[0] = v29;
            v44.n128_u64[1] = v30;
            v31 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v49, &v44);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v46 + 120))(v28, v31) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v46 + 144))(v28, v22);
        v32 = 126 - 2 * __clz(v51);
        if (v51)
          v33 = v32;
        else
          v33 = 0;
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>((uint64_t)v53, (__n128 *)&v53[2 * v51], v33, 1);
        if (v51)
        {
          v34 = v53;
          v35 = &v53[2 * v51];
          do
          {
            v37 = *v34;
            v36 = v34[1];
            v34 += 2;
            v24(a1, *(_QWORD *)(v37 + 8), 0, v36, v48, v47, 0);
          }
          while (v34 != v35);
        }
        if (v49)
        {
          if (v53)
            (*(void (**)(void))(*(_QWORD *)v49 + 40))();
        }
      }
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_14;
  v14 = *(_QWORD **)a6;
  v15 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v14, v15[9], &v49);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
  v20 = re::TypeInfo::name((re::TypeInfo *)v48);
  if ((unint64_t)*v20 >> 1 == 0x134375A94D9F7110)
  {
    v21 = (char *)v20[1];
    if (v21 == "DynamicString" || !strcmp(v21, "DynamicString"))
      goto LABEL_14;
  }
  re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(uint64_t a1, const char *a2, uint64_t *a3)
{
  int v3;
  uint64_t v6;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;

  v13 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v13);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(*(_QWORD *)(a1 + 168));
    v6 = *a3;
    LOBYTE(v8) = 6;
    DWORD1(v8) = 0;
    *((_QWORD *)&v8 + 1) = v13;
    v9 = 0;
    v11 = 0;
    v12 = 0;
    v10 = v6;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v8);
  }
  return v3 == 0;
}

double re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(uint64_t a1, int a2)
{
  double result;
  _OWORD v5[2];
  uint64_t v6;
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(*(_QWORD *)(a1 + 168));
    LOBYTE(v5[0]) = 7;
    DWORD1(v5[0]) = a2 | 0x20;
    *((_QWORD *)&v5[0] + 1) = "entry";
    v5[1] = xmmword_2260F4F20;
    v6 = 0;
    v7 = 0;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, v5);
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t *v2;
  uint64_t v3;
  _BYTE *v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  _OWORD v8[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == 2)
    {
      v2 = (uint64_t *)*((_QWORD *)result + 21);
      v2[4] -= 16;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndObject(v2);
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 7);
      v3 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      ++*(_QWORD *)(v3 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v4 = *(_BYTE **)&v7[7];
      else
        v4 = v7;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary entry \"%s\". Expected 2 objects (key+value). Actual number of objects: %lld.", (re::DynamicString *)v8, v4, *(_QWORD *)(*((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14) - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v8);
      if (*(_QWORD *)&v8[0])
      {
        if ((BYTE8(v8[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v8[0] + 40))();
        memset(v8, 0, sizeof(v8));
      }
      result = v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionary(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t *v2;
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  char v7;
  _BYTE v8[23];
  _OWORD v9[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      v2 = (uint64_t *)*((_QWORD *)result + 21);
      v2[4] -= 16;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndArray(v2);
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 6);
      v3 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      ++*(_QWORD *)(v3 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v6);
      if ((v7 & 1) != 0)
        v4 = *(_BYTE **)&v8[7];
      else
        v4 = v8;
      v5 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)v9, v4, *(_QWORD *)(v5 - 24), *(_QWORD *)(v5 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v9);
      if (*(_QWORD *)&v9[0])
      {
        if ((BYTE8(v9[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v9[0] + 40))();
        memset(v9, 0, sizeof(v9));
      }
      result = v6;
      if (v6)
      {
        if ((v7 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v6 + 40))();
      }
    }
  }
  return result;
}

void std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(char *a1, char *a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  unint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t);

  v3 = 126 - 2 * __clz((a2 - a1) >> 4);
  v5 = a3;
  if (a2 == a1)
    v4 = 0;
  else
    v4 = v3;
  std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(a1, a2, &v5, v4, 1);
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(uint64_t a1, const char *a2, uint64_t a3, int a4)
{
  int v4;
  _OWORD v8[3];
  const char *v9;

  v9 = a2;
  v4 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v9);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(*(_QWORD *)(a1 + 168));
    LOBYTE(v8[0]) = 2;
    DWORD1(v8[0]) = a4 | 0x20;
    *((_QWORD *)&v8[0] + 1) = v9;
    memset(&v8[1], 0, 32);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, v8);
  }
  return v4 == 0;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t *v2;
  uint64_t v3;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = (uint64_t *)*((_QWORD *)result + 21);
    v2[4] -= 16;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndObject(v2);
    result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 2);
    v3 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
    ++*(_QWORD *)(v3 - 16);
  }
  return result;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(uint64_t a1)
{
  uint64_t v2;

  rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix((char *)a1);
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 40) - v2 <= 15)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Level>(a1 + 8, 1);
    v2 = *(_QWORD *)(a1 + 32);
  }
  *(_QWORD *)(a1 + 32) = v2 + 16;
  *(_QWORD *)v2 = 0;
  *(_BYTE *)(v2 + 8) = 0;
  return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteStartObject((uint64_t *)a1);
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteStartObject(uint64_t *a1)
{
  uint64_t v1;
  _BYTE *v2;

  v1 = *a1;
  v2 = *(_BYTE **)(*a1 + 24);
  if ((uint64_t)(*(_QWORD *)(*a1 + 32) - (_QWORD)v2) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, 1);
    v2 = *(_BYTE **)(v1 + 24);
  }
  *(_QWORD *)(v1 + 24) = v2 + 1;
  *v2 = 123;
  return 1;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(unint64_t **a1, unint64_t **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t **v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t **v18;
  unint64_t **v19;
  unint64_t *v20;
  unint64_t *v21;
  __int128 *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t *v25;
  BOOL v26;
  unint64_t *v27;
  unint64_t **v28;
  _OWORD *v29;
  unint64_t *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t *v34;
  __int128 *v35;
  _QWORD *v36;
  unint64_t **v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t **v42;
  unint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unint64_t **v52;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t **v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t **v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  unint64_t **v77;
  unint64_t *v78;
  unint64_t *v79;
  unint64_t **v80;
  unint64_t *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

__int128 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(__int128 *result, unint64_t **a2, unint64_t **a3)
{
  unint64_t v3;
  unint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v3 = **a2;
  v4 = **a3;
  if (v3 >= **(_QWORD **)result)
  {
    if (v4 < v3)
    {
      v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (**a2 < **(_QWORD **)result)
      {
        v7 = *result;
        *result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v8 = *result;
      *result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**a3 >= **a2)
        return result;
      v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      v5 = *result;
      *result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(uint64_t a1, unint64_t **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unint64_t **v8;
  unint64_t **v9;
  uint64_t v10;
  int v11;
  unint64_t *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t **v16;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (**(a2 - 2) < **(_QWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = (unint64_t **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32));
      v9 = (unint64_t **)(a1 + 48);
      if ((unint64_t **)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unint64_t **)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (unint64_t **)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(__int128 *a1, unint64_t **a2, unint64_t **a3, _OWORD *a4)
{
  __n128 result;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(a1, a2, a3);
  if (**(_QWORD **)a4 < **a3)
  {
    result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (**a3 < **a2)
    {
      result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (**a2 < **(_QWORD **)a1)
      {
        result = (__n128)*a1;
        *a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(__int128 *a1, unint64_t **a2, unint64_t **a3, __n128 *a4, __n128 *a5)
{
  __n128 result;

  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(_QWORD *)a5->n128_u64[0] < *(_QWORD *)a4->n128_u64[0])
  {
    result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(_QWORD *)a4->n128_u64[0] < **a3)
    {
      result = *(__n128 *)a3;
      *(__n128 *)a3 = *a4;
      *a4 = result;
      if (**a3 < **a2)
      {
        result = *(__n128 *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(__n128 *)a3 = result;
        if (**a2 < **(_QWORD **)a1)
        {
          result = (__n128)*a1;
          *a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

_WORD *std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](_WORD *a1, unint64_t a2)
{
  unint64_t v2;

  v2 = a2;
  if (!HIDWORD(a2))
    return std::__itoa::__base_10_u32[abi:nn180100](a1, a2);
  if (a2 > 0x2540BE3FFLL)
  {
    a1 = std::__itoa::__base_10_u32[abi:nn180100](a1, a2 / 0x2540BE400);
    v2 %= 0x2540BE400uLL;
  }
  return std::__itoa::__append10[abi:nn180100]<unsigned long long>(a1, v2);
}

_WORD *std::__itoa::__base_10_u32[abi:nn180100](_WORD *a1, unsigned int a2)
{
  unsigned int v3;
  unint64_t v4;
  unsigned __int16 v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned __int16 v10;

  if (a2 >= 0xF4240)
  {
    if (a2 >= 0x5F5E100)
    {
      if (a2 > 0x3B9AC9FF)
      {
        return std::__itoa::__append10[abi:nn180100]<unsigned int>(a1, a2);
      }
      else
      {
        *(_BYTE *)a1 = a2 / 0x5F5E100 + 48;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240];
        v7 = a2 % 0x5F5E100 % 0xF4240;
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v7 / 0x2710uLL];
        v7 %= 0x2710u;
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[(unsigned __int16)v7 / 0x64u];
        *(_WORD *)((char *)a1 + 7) = std::__itoa::__digits_base_10[(unsigned __int16)v7 % 0x64u];
        return (_WORD *)((char *)a1 + 9);
      }
    }
    else
    {
      v3 = a2 / 0xF4240;
      if (a2 > 0x98967F)
      {
        *a1 = std::__itoa::__digits_base_10[v3];
        a1[1] = std::__itoa::__digits_base_10[a2 % 0xF4240 / 0x2710uLL];
        v9 = a2 % 0xF4240 % 0x2710;
        a1[2] = std::__itoa::__digits_base_10[(unsigned __int16)v9 / 0x64u];
        a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v9 % 0x64u];
        return a1 + 4;
      }
      else
      {
        *(_BYTE *)a1 = v3 + 48;
        v4 = (429497 * (unint64_t)(a2 % 0xF4240)) >> 32;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[v4];
        v5 = a2 % 0xF4240 - 10000 * v4;
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v5 / 0x64u];
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[v5 % 0x64u];
        return (_WORD *)((char *)a1 + 7);
      }
    }
  }
  else if (a2 >> 4 > 0x270)
  {
    v6 = a2 / 0x2710;
    if (a2 >> 5 > 0xC34)
    {
      *a1 = std::__itoa::__digits_base_10[v6];
      v10 = a2 % 0x2710;
      a1[1] = std::__itoa::__digits_base_10[v10 / 0x64u];
      a1[2] = std::__itoa::__digits_base_10[v10 % 0x64u];
      return a1 + 3;
    }
    else
    {
      *(_BYTE *)a1 = v6 + 48;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[(5243 * (a2 % 0x2710)) >> 19];
      *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[(unsigned __int16)(a2 % 0x2710
                                                                                  - 100
                                                                                  * ((unsigned __int16)((5243 * (a2 % 0x2710)) >> 16) >> 3))];
      return (_WORD *)((char *)a1 + 5);
    }
  }
  else if (a2 > 0x63)
  {
    v8 = (unsigned __int16)a2 / 0x64u;
    if (a2 > 0x3E7)
    {
      *a1 = std::__itoa::__digits_base_10[v8];
      a1[1] = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      return a1 + 2;
    }
    else
    {
      *(_BYTE *)a1 = v8 + 48;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      return (_WORD *)((char *)a1 + 3);
    }
  }
  else if (a2 > 9)
  {
    *a1 = std::__itoa::__digits_base_10[a2];
    return a1 + 1;
  }
  else
  {
    *(_BYTE *)a1 = a2 + 48;
    return (_WORD *)((char *)a1 + 1);
  }
}

_WORD *std::__itoa::__append10[abi:nn180100]<unsigned long long>(_WORD *a1, unint64_t a2)
{
  unsigned int v2;

  *a1 = std::__itoa::__digits_base_10[(a2 / 0x5F5E100)];
  v2 = a2 % 0x5F5E100;
  a1[1] = std::__itoa::__digits_base_10[v2 / 0xF4240uLL];
  v2 %= 0xF4240u;
  a1[2] = std::__itoa::__digits_base_10[v2 / 0x2710uLL];
  v2 %= 0x2710u;
  a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v2 / 0x64u];
  a1[4] = std::__itoa::__digits_base_10[(unsigned __int16)v2 % 0x64u];
  return a1 + 5;
}

_WORD *std::__itoa::__append10[abi:nn180100]<unsigned int>(_WORD *a1, unsigned int a2)
{
  unsigned int v2;

  *a1 = std::__itoa::__digits_base_10[a2 / 0x5F5E100uLL];
  a1[1] = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240uLL];
  v2 = a2 % 0x5F5E100 % 0xF4240;
  a1[2] = std::__itoa::__digits_base_10[v2 / 0x2710uLL];
  v2 %= 0x2710u;
  a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v2 / 0x64u];
  a1[4] = std::__itoa::__digits_base_10[(unsigned __int16)v2 % 0x64u];
  return a1 + 5;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndObject(uint64_t *a1)
{
  uint64_t v1;
  _BYTE *v2;

  v1 = *a1;
  v2 = *(_BYTE **)(*a1 + 24);
  if ((uint64_t)(*(_QWORD *)(*a1 + 32) - (_QWORD)v2) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, 1);
    v2 = *(_BYTE **)(v1 + 24);
  }
  *(_QWORD *)(v1 + 24) = v2 + 1;
  *v2 = 125;
  return 1;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(unsigned int **a1, unsigned int **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int **v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int **v18;
  unsigned int **v19;
  unsigned int *v20;
  unsigned int *v21;
  __int128 *v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int *v25;
  BOOL v26;
  unsigned int *v27;
  unsigned int **v28;
  _OWORD *v29;
  unsigned int *v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int *v34;
  __int128 *v35;
  _DWORD *v36;
  unsigned int **v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int **v42;
  unsigned int *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned int **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned int **v56;
  unsigned int *v57;
  unsigned int *v58;
  unsigned int **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _DWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  unsigned int **v77;
  unsigned int *v78;
  unsigned int *v79;
  unsigned int **v80;
  unsigned int *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

__int128 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(__int128 *result, unsigned int **a2, unsigned int **a3)
{
  unsigned int v3;
  unsigned int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v3 = **a2;
  v4 = **a3;
  if (v3 >= **(_DWORD **)result)
  {
    if (v4 < v3)
    {
      v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (**a2 < **(_DWORD **)result)
      {
        v7 = *result;
        *result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v8 = *result;
      *result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**a3 >= **a2)
        return result;
      v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      v5 = *result;
      *result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(uint64_t a1, unsigned int **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unsigned int **v8;
  unsigned int **v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  unsigned int *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int **v16;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (**(a2 - 2) < **(_DWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = (unsigned int **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32));
      v9 = (unsigned int **)(a1 + 48);
      if ((unsigned int **)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned int **)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (unsigned int **)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(__int128 *a1, unsigned int **a2, unsigned int **a3, _OWORD *a4)
{
  __n128 result;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(a1, a2, a3);
  if (**(_DWORD **)a4 < **a3)
  {
    result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (**a3 < **a2)
    {
      result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (**a2 < **(_DWORD **)a1)
      {
        result = (__n128)*a1;
        *a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(__int128 *a1, unsigned int **a2, unsigned int **a3, __n128 *a4, __n128 *a5)
{
  __n128 result;

  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(_DWORD *)a5->n128_u64[0] < *(_DWORD *)a4->n128_u64[0])
  {
    result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(_DWORD *)a4->n128_u64[0] < **a3)
    {
      result = *(__n128 *)a3;
      *(__n128 *)a3 = *a4;
      *a4 = result;
      if (**a3 < **a2)
      {
        result = *(__n128 *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(__n128 *)a3 = result;
        if (**a2 < **(_DWORD **)a1)
        {
          result = (__n128)*a1;
          *a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(unsigned __int16 **a1, unsigned __int16 **a2, uint64_t a3, char a4)
{
  unsigned __int16 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int16 **v12;
  unsigned __int16 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;
  unsigned __int16 **v18;
  unsigned __int16 **v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  unsigned __int16 **v22;
  unsigned int v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  BOOL v26;
  unsigned __int16 *v27;
  unsigned __int16 **v28;
  unsigned __int16 **v29;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  unsigned int v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  unsigned __int16 **v35;
  unsigned __int16 *v36;
  unsigned __int16 **v37;
  BOOL v39;
  uint64_t v40;
  unsigned __int16 **v41;
  unsigned __int16 **v42;
  unsigned __int16 *v43;
  unsigned __int16 *v44;
  uint64_t v45;
  unsigned int v46;
  unsigned __int16 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned __int16 **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned __int16 **v56;
  unsigned __int16 *v57;
  unsigned __int16 *v58;
  unsigned __int16 **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int16 **v67;
  unsigned __int16 **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unsigned __int16 **v73;
  unsigned __int16 *v74;
  unsigned __int16 *v75;
  unsigned __int16 **v76;
  unsigned __int16 **v78;
  unsigned __int16 *v79;
  unsigned __int16 *v80;
  unsigned __int16 **v81;
  unsigned __int16 *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;

unsigned __int16 **std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **result, unsigned __int16 **a2, _OWORD *a3)
{
  unsigned int v3;
  unsigned int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v3 = **a2;
  v4 = **(unsigned __int16 **)a3;
  if (v3 >= **result)
  {
    if (v4 < v3)
    {
      v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
      *a3 = v6;
      if (**a2 < **result)
      {
        v7 = *(_OWORD *)result;
        *(_OWORD *)result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v8 = *(_OWORD *)result;
      *(_OWORD *)result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**(unsigned __int16 **)a3 >= **a2)
        return result;
      v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
    }
    else
    {
      v5 = *(_OWORD *)result;
      *(_OWORD *)result = *a3;
    }
    *a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **a1, unsigned __int16 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned __int16 **v6;
  __int128 v7;
  unsigned __int16 **v8;
  unsigned __int16 **v9;
  uint64_t v10;
  int v11;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int16 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(unsigned __int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned __int16 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **a1, unsigned __int16 **a2, __n128 *a3, __n128 *a4)
{
  __n128 result;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a2, a3);
  if (*(unsigned __int16 *)a4->n128_u64[0] < *(unsigned __int16 *)a3->n128_u64[0])
  {
    result = *a3;
    *a3 = *a4;
    *a4 = result;
    if (*(unsigned __int16 *)a3->n128_u64[0] < **a2)
    {
      result = *(__n128 *)a2;
      *(__n128 *)a2 = *a3;
      *a3 = result;
      if (**a2 < **a1)
      {
        result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **a1, unsigned __int16 **a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  __n128 result;

  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(unsigned __int16 *)a5->n128_u64[0] < *(unsigned __int16 *)a4->n128_u64[0])
  {
    result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(unsigned __int16 *)a4->n128_u64[0] < *(unsigned __int16 *)a3->n128_u64[0])
    {
      result = *a3;
      *a3 = *a4;
      *a4 = result;
      if (*(unsigned __int16 *)a3->n128_u64[0] < **a2)
      {
        result = *(__n128 *)a2;
        *(__n128 *)a2 = *a3;
        *a3 = result;
        if (**a2 < **a1)
        {
          result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(unsigned __int8 **a1, unsigned __int8 **a2, uint64_t a3, char a4)
{
  unsigned __int8 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 **v12;
  unsigned __int8 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned int v17;
  unsigned __int8 **v18;
  unsigned __int8 **v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned __int8 **v22;
  unsigned int v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  BOOL v26;
  unsigned __int8 *v27;
  unsigned __int8 **v28;
  unsigned __int8 **v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  unsigned __int8 **v35;
  unsigned __int8 *v36;
  unsigned __int8 **v37;
  BOOL v39;
  uint64_t v40;
  unsigned __int8 **v41;
  unsigned __int8 **v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  uint64_t v45;
  unsigned int v46;
  unsigned __int8 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned __int8 **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned __int8 **v56;
  unsigned __int8 *v57;
  unsigned __int8 *v58;
  unsigned __int8 **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 **v67;
  unsigned __int8 **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unsigned __int8 **v73;
  unsigned __int8 *v74;
  unsigned __int8 *v75;
  unsigned __int8 **v76;
  unsigned __int8 **v78;
  unsigned __int8 *v79;
  unsigned __int8 *v80;
  unsigned __int8 **v81;
  unsigned __int8 *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;

unsigned __int8 **std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **result, unsigned __int8 **a2, _OWORD *a3)
{
  unsigned int v3;
  unsigned int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v3 = **a2;
  v4 = **(unsigned __int8 **)a3;
  if (v3 >= **result)
  {
    if (v4 < v3)
    {
      v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
      *a3 = v6;
      if (**a2 < **result)
      {
        v7 = *(_OWORD *)result;
        *(_OWORD *)result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v8 = *(_OWORD *)result;
      *(_OWORD *)result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**(unsigned __int8 **)a3 >= **a2)
        return result;
      v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
    }
    else
    {
      v5 = *(_OWORD *)result;
      *(_OWORD *)result = *a3;
    }
    *a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **a1, unsigned __int8 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned __int8 **v6;
  __int128 v7;
  unsigned __int8 **v8;
  unsigned __int8 **v9;
  uint64_t v10;
  int v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int8 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(unsigned __int8 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned __int8 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **a1, unsigned __int8 **a2, __n128 *a3, __n128 *a4)
{
  __n128 result;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a2, a3);
  if (*(unsigned __int8 *)a4->n128_u64[0] < *(unsigned __int8 *)a3->n128_u64[0])
  {
    result = *a3;
    *a3 = *a4;
    *a4 = result;
    if (*(unsigned __int8 *)a3->n128_u64[0] < **a2)
    {
      result = *(__n128 *)a2;
      *(__n128 *)a2 = *a3;
      *a3 = result;
      if (**a2 < **a1)
      {
        result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **a1, unsigned __int8 **a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  __n128 result;

  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(unsigned __int8 *)a5->n128_u64[0] < *(unsigned __int8 *)a4->n128_u64[0])
  {
    result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(unsigned __int8 *)a4->n128_u64[0] < *(unsigned __int8 *)a3->n128_u64[0])
    {
      result = *a3;
      *a3 = *a4;
      *a4 = result;
      if (*(unsigned __int8 *)a3->n128_u64[0] < **a2)
      {
        result = *(__n128 *)a2;
        *(__n128 *)a2 = *a3;
        *a3 = result;
        if (**a2 < **a1)
        {
          result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(uint64_t **a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t **v18;
  __n128 *v19;
  _QWORD *v20;
  _QWORD *v21;
  __int128 *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  BOOL v26;
  _QWORD *v27;
  _QWORD **v28;
  __int128 *v29;
  _QWORD *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  __int128 *v35;
  _QWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  uint64_t **v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t **v56;
  uint64_t *v57;
  uint64_t *v58;
  uint64_t **v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  __n128 *v76;
  uint64_t *v77;
  uint64_t *v78;
  __n128 *v79;
  uint64_t *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

__int128 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(__int128 *result, uint64_t **a2, uint64_t **a3)
{
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v3 = **a2;
  v4 = **a3;
  if (v3 >= **(_QWORD **)result)
  {
    if (v4 < v3)
    {
      v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (**a2 < **(_QWORD **)result)
      {
        v7 = *result;
        *result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v8 = *result;
      *result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**a3 >= **a2)
        return result;
      v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      v5 = *result;
      *result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_QWORD **)(a2 - 16) < **(_QWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_QWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_QWORD **)v9;
    if (**(_QWORD **)v9 < **v8)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_QWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(__int128 *a1, uint64_t **a2, uint64_t **a3, _OWORD *a4)
{
  __n128 result;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(a1, a2, a3);
  if (**(_QWORD **)a4 < **a3)
  {
    result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (**a3 < **a2)
    {
      result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (**a2 < **(_QWORD **)a1)
      {
        result = (__n128)*a1;
        *a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(__int128 *a1, uint64_t **a2, uint64_t **a3, __n128 *a4, __n128 *a5)
{
  __n128 result;

  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(_QWORD *)a5->n128_u64[0] < *(_QWORD *)a4->n128_u64[0])
  {
    result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(_QWORD *)a4->n128_u64[0] < **a3)
    {
      result = *(__n128 *)a3;
      *(__n128 *)a3 = *a4;
      *a4 = result;
      if (**a3 < **a2)
      {
        result = *(__n128 *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(__n128 *)a3 = result;
        if (**a2 < **(_QWORD **)a1)
        {
          result = (__n128)*a1;
          *a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(int **a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int **v12;
  int *v13;
  int v14;
  uint64_t v15;
  int *v16;
  int v17;
  int **v18;
  __n128 *v19;
  _DWORD *v20;
  _DWORD *v21;
  __int128 *v22;
  int v23;
  int *v24;
  int *v25;
  BOOL v26;
  _DWORD *v27;
  _DWORD **v28;
  __int128 *v29;
  _DWORD *v30;
  int *v31;
  int v32;
  int *v33;
  int *v34;
  __int128 *v35;
  _DWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  int **v52;
  int v53;
  int v54;
  BOOL v55;
  int **v56;
  int *v57;
  int *v58;
  int **v59;
  uint64_t v60;
  int v61;
  int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _DWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  __n128 *v76;
  int *v77;
  int *v78;
  __n128 *v79;
  int *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

__int128 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(__int128 *result, int **a2, int **a3)
{
  int v3;
  int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v3 = **a2;
  v4 = **a3;
  if (v3 >= **(_DWORD **)result)
  {
    if (v4 < v3)
    {
      v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (**a2 < **(_DWORD **)result)
      {
        v7 = *result;
        *result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v8 = *result;
      *result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**a3 >= **a2)
        return result;
      v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      v5 = *result;
      *result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _DWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_DWORD **)(a2 - 16) < **(_DWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_DWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_DWORD **)v9;
    if (**(_DWORD **)v9 < **v8)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_DWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(__int128 *a1, int **a2, int **a3, _OWORD *a4)
{
  __n128 result;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(a1, a2, a3);
  if (**(_DWORD **)a4 < **a3)
  {
    result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (**a3 < **a2)
    {
      result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (**a2 < **(_DWORD **)a1)
      {
        result = (__n128)*a1;
        *a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(__int128 *a1, int **a2, int **a3, __n128 *a4, __n128 *a5)
{
  __n128 result;

  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(_DWORD *)a5->n128_u64[0] < *(_DWORD *)a4->n128_u64[0])
  {
    result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(_DWORD *)a4->n128_u64[0] < **a3)
    {
      result = *(__n128 *)a3;
      *(__n128 *)a3 = *a4;
      *a4 = result;
      if (**a3 < **a2)
      {
        result = *(__n128 *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(__n128 *)a3 = result;
        if (**a2 < **(_DWORD **)a1)
        {
          result = (__n128)*a1;
          *a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(__int16 **a1, __int16 **a2, uint64_t a3, char a4)
{
  __int16 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int16 **v12;
  __int16 *v13;
  int v14;
  uint64_t v15;
  __int16 *v16;
  int v17;
  __int16 **v18;
  __int16 **v19;
  __int16 *v20;
  __int16 *v21;
  __int16 **v22;
  int v23;
  __int16 *v24;
  __int16 *v25;
  BOOL v26;
  __int16 *v27;
  __int16 **v28;
  __int16 **v29;
  __int16 *v30;
  __int16 *v31;
  int v32;
  __int16 *v33;
  __int16 *v34;
  __int16 **v35;
  __int16 *v36;
  __int16 **v37;
  BOOL v39;
  uint64_t v40;
  __int16 **v41;
  __int16 **v42;
  __int16 *v43;
  __int16 *v44;
  uint64_t v45;
  int v46;
  __int16 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  __int16 **v52;
  int v53;
  int v54;
  BOOL v55;
  __int16 **v56;
  __int16 *v57;
  __int16 *v58;
  __int16 **v59;
  uint64_t v60;
  int v61;
  int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  __int16 **v66;
  __int16 **v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  __int16 **v72;
  __int16 *v73;
  __int16 *v74;
  __int16 **v75;
  __int16 **v76;
  __int16 *v77;
  __int16 *v78;
  __int16 **v79;
  __int16 *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

__int16 **std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **result, __int16 **a2, _OWORD *a3)
{
  int v3;
  int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v3 = **a2;
  v4 = **(__int16 **)a3;
  if (v3 >= **result)
  {
    if (v4 < v3)
    {
      v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
      *a3 = v6;
      if (**a2 < **result)
      {
        v7 = *(_OWORD *)result;
        *(_OWORD *)result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v8 = *(_OWORD *)result;
      *(_OWORD *)result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**(__int16 **)a3 >= **a2)
        return result;
      v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
    }
    else
    {
      v5 = *(_OWORD *)result;
      *(_OWORD *)result = *a3;
    }
    *a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **a1, __int16 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int16 **v6;
  __int128 v7;
  __int16 **v8;
  __int16 **v9;
  uint64_t v10;
  int v11;
  __int16 *v12;
  __int16 *v13;
  uint64_t v14;
  int v15;
  __int16 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(__int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (__int16 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **a1, __int16 **a2, __n128 *a3, __n128 *a4)
{
  __n128 result;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a2, a3);
  if (*(__int16 *)a4->n128_u64[0] < *(__int16 *)a3->n128_u64[0])
  {
    result = *a3;
    *a3 = *a4;
    *a4 = result;
    if (*(__int16 *)a3->n128_u64[0] < **a2)
    {
      result = *(__n128 *)a2;
      *(__n128 *)a2 = *a3;
      *a3 = result;
      if (**a2 < **a1)
      {
        result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **a1, __int16 **a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  __n128 result;

  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(__int16 *)a5->n128_u64[0] < *(__int16 *)a4->n128_u64[0])
  {
    result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(__int16 *)a4->n128_u64[0] < *(__int16 *)a3->n128_u64[0])
    {
      result = *a3;
      *a3 = *a4;
      *a4 = result;
      if (*(__int16 *)a3->n128_u64[0] < **a2)
      {
        result = *(__n128 *)a2;
        *(__n128 *)a2 = *a3;
        *a3 = result;
        if (**a2 < **a1)
        {
          result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  BOOL v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t *v44;
  int64_t v45;
  int64_t v46;
  int64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  int64_t v52;
  uint64_t v53;
  int v54;
  BOOL v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t *v87;
  char v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t *v91;
  int64_t v92;
  uint64_t *v93;
  uint64_t *v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  char v7;
  uint64_t result;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  v6 = *a2;
  v7 = re::DynamicString::operator<(*a2, *a1);
  result = re::DynamicString::operator<(*a3, v6);
  if ((v7 & 1) != 0)
  {
    if ((_DWORD)result)
    {
      v9 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a3;
    }
    else
    {
      v12 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v12;
      result = re::DynamicString::operator<(*a3, *a2);
      if (!(_DWORD)result)
        return result;
      v9 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v9;
  }
  else if ((_DWORD)result)
  {
    v10 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v10;
    result = re::DynamicString::operator<(*a2, *a1);
    if ((_DWORD)result)
    {
      v11 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v11;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t *v6;
  __int128 v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t *v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (re::DynamicString::operator<(*(a2 - 2), *a1))
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (re::DynamicString::operator<(*v9, *v8))
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v14 -= 16;
        if ((re::DynamicString::operator<(v12, *((_QWORD *)v15 + 2)) & 1) == 0)
        {
          v16 = (uint64_t *)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  __n128 result;
  __int128 v9;
  __int128 v10;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a2, a3);
  if (re::DynamicString::operator<(*a4, *a3))
  {
    v9 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)a4 = v9;
    if (re::DynamicString::operator<(*a3, *a2))
    {
      v10 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v10;
      if (re::DynamicString::operator<(*a2, *a1))
      {
        result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  __n128 result;
  __int128 v11;
  __int128 v12;
  __int128 v13;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a2, a3, a4);
  if (re::DynamicString::operator<(*a5, *a4))
  {
    v11 = *(_OWORD *)a4;
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)a5 = v11;
    if (re::DynamicString::operator<(*a4, *a3))
    {
      v12 = *(_OWORD *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)a4 = v12;
      if (re::DynamicString::operator<(*a3, *a2))
      {
        v13 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)a3 = v13;
        if (re::DynamicString::operator<(*a2, *a1))
        {
          result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>(uint64_t a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int128 *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  __int128 *v19;
  _QWORD *v20;
  _QWORD *v21;
  __int128 *v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  BOOL v26;
  _QWORD *v27;
  unint64_t v28;
  __int128 *v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  __int128 *v35;
  _QWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unint64_t **v52;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t **v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t **v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  uint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

__int128 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(__int128 *result, _QWORD **a2, _QWORD **a3)
{
  unint64_t v3;
  unint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v3 = **a2 >> 1;
  v4 = **a3 >> 1;
  if (v3 >= **(_QWORD **)result >> 1)
  {
    if (v4 < v3)
    {
      v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (**a2 >> 1 < **(_QWORD **)result >> 1)
      {
        v7 = *result;
        *result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v8 = *result;
      *result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**a3 >> 1 >= **a2 >> 1)
        return result;
      v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      v5 = *result;
      *result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_QWORD **)(a2 - 16) >> 1 < **(_QWORD **)a1 >> 1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (_QWORD **)(a1 + 16), (_QWORD **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_QWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (_QWORD **)(a1 + 16), (_QWORD **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_QWORD **)v9;
    if (**(_QWORD **)v9 >> 1 < **v8 >> 1)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >> 1 >= v15 >> 1)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_QWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(__int128 *a1, __n128 *a2, __n128 *a3, __n128 *a4)
{
  __n128 result;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(a1, a2, a3);
  if (*(_QWORD *)a4->n128_u64[0] >> 1 < *(_QWORD *)a3->n128_u64[0] >> 1)
  {
    result = *a3;
    *a3 = *a4;
    *a4 = result;
    if (*(_QWORD *)a3->n128_u64[0] >> 1 < *(_QWORD *)a2->n128_u64[0] >> 1)
    {
      result = *a2;
      *a2 = *a3;
      *a3 = result;
      if (*(_QWORD *)a2->n128_u64[0] >> 1 < **(_QWORD **)a1 >> 1)
      {
        result = (__n128)*a1;
        *a1 = (__int128)*a2;
        *a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(__int128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  __n128 result;

  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(_QWORD *)a5->n128_u64[0] >> 1 < *(_QWORD *)a4->n128_u64[0] >> 1)
  {
    result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(_QWORD *)a4->n128_u64[0] >> 1 < *(_QWORD *)a3->n128_u64[0] >> 1)
    {
      result = *a3;
      *a3 = *a4;
      *a4 = result;
      if (*(_QWORD *)a3->n128_u64[0] >> 1 < *(_QWORD *)a2->n128_u64[0] >> 1)
      {
        result = *a2;
        *a2 = *a3;
        *a3 = result;
        if (*(_QWORD *)a2->n128_u64[0] >> 1 < **(_QWORD **)a1 >> 1)
        {
          result = (__n128)*a1;
          *a1 = (__int128)*a2;
          *a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(char *a1, char *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  BOOL v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  char *v38;
  BOOL v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  char *v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t *v75;
  BOOL v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  char *v81;
  char v82;
  char *v83;
  unint64_t v84;
  char *v85;
  char *v86;
  char *v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  int64_t v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(_QWORD *a1, _QWORD *a2, _QWORD *a3, uint64_t (**a4)(_QWORD, _QWORD))
{
  char v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;

  v8 = (*a4)(*a2, *a1);
  result = (*a4)(*a3, *a2);
  if ((v8 & 1) != 0)
  {
    if ((_DWORD)result)
    {
      v10 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a3;
    }
    else
    {
      v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v13;
      result = (*a4)(*a3, *a2);
      if (!(_DWORD)result)
        return result;
      v10 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v10;
  }
  else if ((_DWORD)result)
  {
    v11 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v11;
    result = (*a4)(*a2, *a1);
    if ((_DWORD)result)
    {
      v12 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v12;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(char *a1, char *a2, uint64_t (**a3)(uint64_t, _QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  char *v8;
  __int128 v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  char *v17;
  __int128 v18;

  v6 = (a2 - a1) >> 4;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 16;
      if ((*a3)(*((_QWORD *)a2 - 2), *(_QWORD *)a1))
      {
        v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a1 + 6, (_QWORD *)a2 - 2, a3);
      return 1;
    default:
      v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, a3);
      v11 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(*(_QWORD *)v11, *(_QWORD *)v10))
    {
      v18 = *(_OWORD *)v11;
      v14 = *(_QWORD *)v11;
      v15 = v12;
      while (1)
      {
        *(_OWORD *)&a1[v15 + 48] = *(_OWORD *)&a1[v15 + 32];
        if (v15 == -32)
          break;
        v16 = (*a3)(v14, *(_QWORD *)&a1[v15 + 16]);
        v15 -= 16;
        if ((v16 & 1) == 0)
        {
          v17 = &a1[v15 + 48];
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *(_OWORD *)v17 = v18;
      if (++v13 == 8)
        return v11 + 16 == a2;
    }
    v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t (**a5)(_QWORD, _QWORD))
{
  __n128 result;
  __int128 v11;
  __int128 v12;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, a2, a3, a5);
  if ((*a5)(*a4, *a3))
  {
    v11 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)a4 = v11;
    if ((*a5)(*a3, *a2))
    {
      v12 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v12;
      if ((*a5)(*a2, *a1))
      {
        result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, uint64_t (**a6)(_QWORD, _QWORD))
{
  __n128 v12;
  __n128 result;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  v12 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, a2, a3, a4, a6);
  if (((unsigned int (*)(_QWORD, _QWORD, __n128))*a6)(*a5, *a4, v12))
  {
    v14 = *(_OWORD *)a4;
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)a5 = v14;
    if ((*a6)(*a4, *a3))
    {
      v15 = *(_OWORD *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)a4 = v15;
      if ((*a6)(*a3, *a2))
      {
        v16 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)a3 = v16;
        if ((*a6)(*a2, *a1))
        {
          result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  _BOOL8 result;
  _BOOL4 v21;
  _anonymous_namespace_ *v22;
  unint64_t v23;
  uint64_t v24;
  _BOOL4 v25;
  uint64_t v26;
  uint64_t v27;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v27 = 0;
    v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, &v27, 0);
    result = 0;
    if (!v21)
      return result;
    if (v27)
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_29;
  }
  v23 = *(_QWORD *)(a4 + 8);
  if ((v23 & 1) != 0)
    v24 = v23 >> 1;
  else
    v24 = v23 >> 1;
  v27 = v24;
  v25 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, &v27, 0);
  result = 0;
  if (v25)
  {
    if (v27)
    {
      if ((*(_BYTE *)(a4 + 8) & 1) != 0)
        v26 = *(_QWORD *)(a4 + 16);
      else
        v26 = a4 + 9;
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v26, 0);
    }
    v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_29:
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString(v22);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::internal::serializeObjectWithOneMember<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(_BYTE *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t *v14;
  uint64_t v15;
  const re::TypeInfo *v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23[5];
  _QWORD *v24[4];
  _BYTE v25[32];
  _BYTE v26[32];
  _QWORD *v27;
  uint64_t v28;
  _BYTE v29[8];
  _BYTE v30[32];

  v14 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)v29, *a5, a5[2]);
  re::TypeMemberCollection::operator[](v14, 0, (uint64_t)&v27);
  v15 = a4 + *(unsigned int *)(v28 + 24);
  re::TypeRegistry::typeInfo(v27, *(_QWORD *)v28, v29);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v30);
  if (a5 == a6)
    goto LABEL_4;
  if (*a5 == *a6)
  {
    v18 = *(_QWORD *)a5[2];
    v19 = a6[2];
    v20 = *(_QWORD *)v19;
    if ((unsigned __int16)v18 != (unsigned __int16)*(_QWORD *)v19)
      goto LABEL_14;
    v22 = WORD1(v18) == WORD1(v20);
    v21 = (v20 ^ v18) & 0xFFFFFF00000000;
    v22 = v22 && v21 == 0;
    if (!v22)
      goto LABEL_14;
LABEL_4:
    if (!a1[64])
      return (*(uint64_t (**)(_BYTE *, const char *, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, v15, v26, v26, a7);
    return 0;
  }
  if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, v16))
    goto LABEL_4;
  v19 = a6[2];
LABEL_14:
  if (*(_DWORD *)(v19 + 88) != 1)
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
    return 0;
  }
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v23, *a6, v19);
  re::TypeMemberCollection::operator[](v23, 0, (uint64_t)v24);
  re::TypeRegistry::typeInfo(v24[0], *v24[2], v29);
  re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v30);
  if (a1[64])
    return 0;
  return (*(uint64_t (**)(_BYTE *, const char *, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, v15, v26, v25, a7);
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  const re::TypeInfo *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  uint64_t v29;
  uint64_t v30;
  re *v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  re::internal *v35;
  _BYTE v36[32];
  _BYTE v37[32];
  _QWORD *v38[2];
  uint64_t v39;
  _QWORD *v40[2];
  uint64_t v41;
  uint64_t v42[4];
  unint64_t v43;
  uint64_t v44[5];
  _BYTE v45[8];
  uint64_t v46;
  char v47;
  uint64_t *v48;
  _BYTE v49[8];
  uint64_t v50;
  char v51;
  uint64_t *v52;
  uint8_t buf[4];
  uint64_t v54;
  __int16 v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v49);
  re::TypeRegistry::typeInfo((_QWORD *)*a4, *(_QWORD *)(a4[2] + 72), v45);
  if (v45[0])
  {
    if (!v49[0])
    {
      v11 = re::TypeInfo::name((re::TypeInfo *)&v46)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (v50 == v46)
    {
      v18 = *v52;
      v19 = *v48;
      if ((unsigned __int16)*v52 == (unsigned __int16)*v48)
      {
        v21 = WORD1(v18) == WORD1(v19);
        v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        v21 = v21 && v20 == 0;
        if (v21)
          goto LABEL_5;
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v50, (const re::TypeInfo *)&v46, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((_BYTE *)a1, a2, &v50, a5);
      goto LABEL_15;
    }
    if (v51 == v47)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, &v50, &v46, a5);
    }
    else
    {
      v22 = re::TypeInfo::name((re::TypeInfo *)&v50)[1];
      re::TypeInfo::name((re::TypeInfo *)&v46);
      re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v44, *a3, a3[2]);
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v42, *a4, a4[2]);
  if (v43)
  {
    for (i = 0; i < v43; ++i)
    {
      if (*(_BYTE *)(a1 + 64))
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[](v42, i, (uint64_t)v40);
      if (*(_BYTE *)(v41 + 28))
      {
        v29 = *(_QWORD *)(v41 + 16);
        if (strlen((const char *)v29) >= 3 && *(_BYTE *)v29 == 109)
          v29 += 2 * (*(_BYTE *)(v29 + 1) == 95);
        v30 = *(unsigned int *)(v41 + 32);
        v31 = *(re **)(*a4 + 856);
        if (!v31
          || (v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v40),
              (_DWORD)v31 == -1))
        {
          v33 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
          {
            v34 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            v54 = v34;
            v55 = 2080;
            v56 = v29;
            _os_log_impl(&dword_224FE9000, v33, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          v35 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(v40[0], *(_QWORD *)v41, buf);
          re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v54 + 4);
          result = re::internal::translateType(v35, (const re::TypeRegistry *)v38, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint8_t *, uint8_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
        }
        else
        {
          re::TypeMemberCollection::operator[](v44, (int)v31, (uint64_t)v38);
          v32 = *(unsigned int *)(v39 + 24);
          re::TypeRegistry::typeInfo(v38[0], *(_QWORD *)v39, buf);
          re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v54 + 4);
          re::TypeRegistry::typeInfo(v40[0], *(_QWORD *)v41, buf);
          result = re::TypeInfo::TypeInfo((uint64_t)v36, (uint64_t)&v54 + 4);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, a2 + v32, v37, v36, a5);
        }
      }
    }
  }
  return result;
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::Serializer(uint64_t a1, const StringID *a2, int a3)
{
  *(_QWORD *)a1 = &off_24ED2E910;
  re::StringID::StringID((re::StringID *)(a1 + 8), a2);
  re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::Encoder(a1 + 24, a3);
  *(_QWORD *)(a1 + 248) = 0;
  *(_WORD *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 228) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_DWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 324) = 0x7FFFFFFFLL;
  return a1;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2E8A8;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  return re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
}

void re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2E8A8;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

void re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(re::Allocator **a1, char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;
  uint64_t v4;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 272)
    && (LODWORD(v4) = **(_QWORD **)(a2 + 16),
        HIDWORD(v4) = -1,
        (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, &v4)) != 0))
  {
    return *(uint64_t (**)(re::Allocator **, char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
}

uint64_t re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::Encoder(uint64_t result, int a2)
{
  __guard *v2;
  unsigned __int8 v3;
  __guard v4;
  int v5;
  const char *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[4];
  int v11;

  *(_QWORD *)(result + 128) = 0;
  *(_QWORD *)(result + 104) = 0;
  *(_QWORD *)(result + 112) = 0;
  *(_QWORD *)(result + 96) = 0;
  *(_DWORD *)(result + 120) = 0;
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_BYTE *)(result + 40) = 0;
  *(_DWORD *)(result + 136) = a2;
  *(_BYTE *)(result + 140) = 0;
  *(_QWORD *)(result + 152) = 1024;
  if ((v3 & 1) == 0)
  {
    v9 = result;
    v7 = v5;
    result = v9;
    if (v7)
    {
      re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v6, (uint64_t)v10);
      v8 = v11;
      if (!v10[0])
        v8 = 0;
      re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::Encoder(int)::s_maxSerializationDepth = v8;
      result = v9;
    }
  }
  v4 = v2[213];
  if (v4)
    *(_QWORD *)(result + 152) = v4;
  return result;
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  double v2;
  uint64_t v3;

  *(_QWORD *)a1 = &off_24ED2E910;
  if (*(_QWORD *)(a1 + 272))
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 288);
    *(_QWORD *)(a1 + 272) = 0;
  }
  v2 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 288));
  v3 = *(_QWORD *)(a1 + 216);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 248))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *(_QWORD *)(a1 + 248) = 0;
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 216) = 0;
    ++*(_DWORD *)(a1 + 240);
  }
  re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::~Encoder(a1 + 24);
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

uint64_t re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::~Encoder(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::close(a1);
  v2 = *(_QWORD *)(a1 + 96);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 128))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    ++*(_DWORD *)(a1 + 120);
  }
  if (*(_BYTE *)(a1 + 40))
  {
    v3 = *(_QWORD *)(a1 + 64);
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 80));
      *(_OWORD *)(a1 + 64) = 0u;
      *(_OWORD *)(a1 + 80) = 0u;
    }
  }
  return a1;
}

uint64_t re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::close(uint64_t result)
{
  _anonymous_namespace_ *v1;

  if (*(_QWORD *)result)
  {
    v1 = (_anonymous_namespace_ *)result;
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::doClose(result);
    if (!*((_BYTE *)v1 + 40))
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 0);
    result = *((_QWORD *)v1 + 12);
    if (result)
    {
      if (*((_QWORD *)v1 + 16))
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
      *((_QWORD *)v1 + 16) = 0;
      *((_QWORD *)v1 + 13) = 0;
      *((_QWORD *)v1 + 14) = 0;
      *((_QWORD *)v1 + 12) = 0;
      ++*((_DWORD *)v1 + 30);
    }
    if (*((int *)v1 + 4) >= 1)
    {
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v1 + 24))(*(_QWORD *)v1);
      *((_QWORD *)v1 + 1) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *(_QWORD *)v1 = 0;
    *((_QWORD *)v1 + 3) = 0;
    *((_QWORD *)v1 + 4) = 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::doClose(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 184);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 24);
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy(*(_QWORD *)(a1 + 184));
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  *(_QWORD *)(a1 + 184) = 0;
  v4 = *(_QWORD *)(a1 + 176);
  if (v4)
  {
    v5 = *(_QWORD *)(a1 + 24);
    rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::~GenericDocument(*(_QWORD **)(a1 + 176));
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, v4);
    *(_QWORD *)(a1 + 176) = 0;
  }
  result = *(_QWORD *)(a1 + 192);
  if (result)
  {
    if (*(_QWORD *)(a1 + 224))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 200) = 0;
    *(_QWORD *)(a1 + 208) = 0;
    *(_QWORD *)(a1 + 192) = 0;
    ++*(_DWORD *)(a1 + 216);
  }
  return result;
}

_QWORD *rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::~GenericDocument(_QWORD *a1)
{
  uint64_t v2;

  v2 = a1[4];
  if (v2)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::~MemoryPoolAllocator(v2);
    (*(void (**)(void *, uint64_t))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                            + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, v2);
  }
  rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy((uint64_t)(a1 + 5));
  return a1;
}

uint64_t rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::~MemoryPoolAllocator(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 < 2)
    {
      rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Clear(a1);
      v4 = *(_QWORD *)(a1 + 16);
      v5 = *(_QWORD *)(v4 + 8);
      if (*(_BYTE *)(v4 + 24))
        (*(void (**)(void *))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                       + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
      if (v5)
        (*(void (**)(void *, uint64_t))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, v5);
    }
    else
    {
      *(_QWORD *)(v2 + 16) = v3 - 1;
    }
  }
  return a1;
}

uint64_t rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Clear(uint64_t result)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *(uint64_t **)(result + 16);
  v2 = *v1;
  v3 = *(_QWORD *)(*v1 + 16);
  if (v3)
  {
    v4 = result;
    do
    {
      *v1 = v3;
      result = (*(uint64_t (**)(void *))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                 + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
      v1 = *(uint64_t **)(v4 + 16);
      v2 = *v1;
      v3 = *(_QWORD *)(*v1 + 16);
    }
    while (v3);
  }
  *(_QWORD *)(v2 + 8) = 0;
  return result;
}

uint64_t re::serializeType<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Allocator **a1, char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t result;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void **Instance;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _BYTE *v51;
  uint64_t v52;
  uint64_t *v53[4];
  _BYTE v54[24];
  uint64_t v55;
  char v56;
  _BYTE v57[23];
  unsigned __int8 v58[8];
  _BYTE v59[32];

  if (this != (re::TypeInfo *)a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **(_QWORD **)(a6 + 16);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_19;
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, a3))
    {
      goto LABEL_19;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      if (v19)
        v20 = *(_DWORD *)(v19 + 16);
      else
        v20 = -1;
      v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
      if (v21)
        v22 = *(_DWORD *)(v21 + 16);
      else
        v22 = -1;
      if (v20 == v22)
        goto LABEL_19;
      v24 = re::TypeInfo::name(this);
      v25 = re::TypeInfo::name((re::TypeInfo *)a6);
      if (re::StringID::operator==(v24, v25))
      {
        v26 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
        if (v26)
          v27 = *(_DWORD *)(v26 + 16);
        else
          v27 = -1;
        re::TypeInfo::atVersion(this, v27, v58);
        if (v58[0])
        {
          if ((a7 & 1) != 0)
            Instance = 0;
          else
            Instance = re::TypeInfo::createInstance((re::TypeInfo *)v59, a1[6], a1[33]);
          if (*((_BYTE *)a1 + 64)
            || ((*((void (**)(re::Allocator **, char *, const re::TypeInfo *, void **, _BYTE *, uint64_t, uint64_t))*a1
                 + 9))(a1, a2, a3, Instance, v59, a6, a7), *((_BYTE *)a1 + 64)))
          {
            if (Instance)
              re::TypeInfo::releaseInstance((re::TypeInfo *)v59, Instance, a1[6], a1[33]);
          }
          else
          {
            if ((a7 & 1) != 0)
              return 1;
            re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v59);
            re::internal::upgradeObject(Instance, v53, a4, (uint64_t **)this, a1[6], a1[33], v54);
            if (v54[0])
              return 1;
            if ((v56 & 1) != 0)
              LOBYTE(v51) = v57[7];
            else
              v51 = v57;
            re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "%s", v46, v47, v48, v49, v50, (char)v51);
            if (!v54[0] && v55 && (v56 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v55 + 40))();
          }
        }
        else
        {
          v35 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
          re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Unknown serialized type \"%s\" version %u. No matching runtime type found.", v41, v42, v43, v44, v45, v35);
        }
      }
      else
      {
        v33 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
        re::TypeInfo::name(this);
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Type name changed: Serialized type \"%s\" version %u, runtime type \"%s\" version %u.", v36, v37, v38, v39, v40, v33);
      }
    }
    else
    {
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>((uint64_t)a1, a2, this, (re::TypeInfo *)a6);
    }
    return 0;
  }
LABEL_19:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      result = (uint64_t)re::serializeBasic<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, (unsigned int *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 2:
      result = re::serializeEnum<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, a4, (uint64_t)this, a6, a7);
      break;
    case 3:
      result = re::serializeOptional<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 4:
      result = (uint64_t)re::serializeArray<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 5:
      result = re::serializeList<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 6:
      result = re::serializeDictionary<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 7:
      result = (uint64_t)re::serializeUnion<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, (char *)a4, this, (re::TypeInfo *)a6, a7);
      break;
    case 8:
      result = re::serializeObject<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, (uint64_t)a3, a4, this, a6, a7);
      break;
    case 9:
      v52 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Pointer type (\"%s\") needs to be handled explicitly by the serializer.", v28, v29, v30, v31, v32, v52);
      return 0;
    default:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Invalid type category. Value = %d", (uint64_t)a4, (uint64_t)this, a6, a7, a8, *((_BYTE *)this + 12));
      return 0;
  }
  return result;
}

unsigned int *re::serializeBasic<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned int *a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  uint64_t *v14;
  unint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_19:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, this, a6);
      return 0;
    }
    v18 = **((_QWORD **)this + 2);
    v19 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v18 != (unsigned __int16)v19)
      goto LABEL_19;
    v21 = WORD1(v18) == WORD1(v19);
    v20 = (v19 ^ v18) & 0xFFFFFF00000000;
    v21 = v21 && v20 == 0;
    if (!v21)
      goto LABEL_19;
  }
LABEL_4:
  v14 = re::TypeInfo::name(this);
  v15 = (unint64_t)*v14 >> 1;
  if (v15 > 0xCA3DEFB5)
  {
    if ((unint64_t)*v14 >> 1 > 0x18E6A9A092)
    {
      if ((unint64_t)*v14 >> 1 <= 0x303EE8780EDLL)
      {
        if (v15 != 0x18E6A9A093)
        {
          if (v15 == 0x303EE86A734)
            return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint16");
          goto LABEL_48;
        }
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint8");
      }
      if (v15 == 0x303EE8780EELL)
        return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint32");
      if (v15 != 0x303EE88E58DLL)
        goto LABEL_48;
    }
    else
    {
      if ((unint64_t)*v14 >> 1 > 0x16749DFF02)
      {
        if (v15 == 0x16749DFF03)
          return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int32");
        v22 = 0x16749F63A2;
        goto LABEL_34;
      }
      if (v15 != 3393056694)
      {
        v17 = 0x16749D2549;
        goto LABEL_24;
      }
    }
    return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint64");
  }
  if ((unint64_t)*v14 >> 1 > 0x5D0225B)
  {
    if ((unint64_t)*v14 >> 1 > 0xB0F77BD0)
    {
      if (v15 != 2969009105)
      {
        if (v15 == 3111160798)
          return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int8");
LABEL_48:
        v23 = re::TypeInfo::name(this);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Unsupported basic type \"%s\".", v24, v25, v26, v27, v28, v23[1]);
        return 0;
      }
      return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (uint64_t)a3, (double *)a4, a7, (uint64_t)"double");
    }
    if (v15 == 97526364)
      return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (uint64_t)a3, (float *)a4, a7, (uint64_t)"float");
    v17 = 109413500;
LABEL_24:
    if (v15 == v17)
      return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int16");
    goto LABEL_48;
  }
  if ((unint64_t)*v14 >> 1 <= 0x2E9355)
  {
    if (v15 != 104431)
    {
      if (v15 == 3029738)
        return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, (uint64_t)a3, (BOOL *)a4, a7);
      goto LABEL_48;
    }
    return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int32");
  }
  if (v15 != 3052374)
  {
    v22 = 3327612;
LABEL_34:
    if (v15 == v22)
      return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, (uint64_t)a3, (unint64_t *)a4, a7, (uint64_t)"int64");
    goto LABEL_48;
  }
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)a3, a4, a7);
}

BOOL re::serializeEnum<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, void *a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  uint64_t *v19;

  if (a5 == a6)
    return re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, (re *)a5, (const re::TypeInfo *)a6, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **(_QWORD **)(a5 + 16);
    v15 = **(_QWORD **)(a6 + 16);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, (re *)a5, (const re::TypeInfo *)a6, a7);
    }
  }
  else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
  {
    return re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, (re *)a5, (const re::TypeInfo *)a6, a7);
  }
  if (*(unsigned __int8 *)(a5 + 12) == *(unsigned __int8 *)(a6 + 12))
  {
    v18 = re::TypeInfo::name((re::TypeInfo *)a5);
    v19 = re::TypeInfo::name((re::TypeInfo *)a6);
    if (re::StringID::operator==(v18, v19))
      return re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, (re *)a5, (const re::TypeInfo *)a6, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
  return 0;
}

BOOL re::serializeOptional<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  re::internal *v18;
  _anonymous_namespace_ *v19;
  double v20;
  void **Instance;
  uint64_t v23;
  BOOL v24;
  _BYTE v25[32];
  _BYTE v26[32];
  _BYTE v27[8];
  uint64_t v28;
  uint64_t v29;

  if (a5 == a6)
    goto LABEL_11;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_11;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v25[0] = 0;
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, v25, 0);
    if (v25[0])
    {
      v18 = *(re::internal **)(a1 + 272);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), v27);
      re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
      re::internal::translateType(v18, (const re::TypeRegistry *)v26, (uint64_t)v27);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, 0, v27, v27, 1);
    }
    v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)&v28);
    re::TypeInfo::TypeInfo((uint64_t)v27, (uint64_t)a5);
    v24 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4) != 0;
    v20 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v24, 0);
    if (v24)
    {
      Instance = re::TypeInfo::createInstance((re::TypeInfo *)v26, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
      (*(void (**)(uint64_t, void **))(v29 + 88))(a4, Instance);
      re::TypeInfo::releaseInstance((re::TypeInfo *)v26, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
    }
    else
    {
      (*(void (**)(uint64_t, _QWORD, double))(v29 + 88))(a4, 0, v20);
    }
    if (v24)
    {
      v23 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, v23, v26, v25, 0);
    }
    v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::SeekableInputStream>::endOptional(v19);
  return *(_BYTE *)(a1 + 64) == 0;
}

unsigned int *re::serializeArray<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Allocator **a1, char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  _QWORD *v18;
  _QWORD *v19;
  int v20;
  re::internal *v21;
  uint64_t v22;
  void (*v23)(re::Allocator **, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  _QWORD *v24;
  int v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  void (*v29)(re::Allocator **, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  uint64_t v30;
  int v31;
  int v32;
  unsigned int *result;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const re::TypeInfo *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  re::TypeInfo *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  BOOL v52;
  char v53;
  unint64_t v54;
  _anonymous_namespace_ *v55;
  BOOL v56;
  char v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD v62[2];
  const re::TypeInfo *v63;
  _QWORD *v64[2];
  uint64_t v65;
  _BYTE v66[32];
  _QWORD v67[2];
  _BYTE v68[32];
  _BYTE v69[16];
  uint64_t v70;
  unint64_t v71;
  _BYTE v72[32];

  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((_BYTE *)a6 + 12) != 4)
    goto LABEL_48;
  v18 = (_QWORD *)*((_QWORD *)a5 + 2);
  v19 = (_QWORD *)*((_QWORD *)a6 + 2);
  v20 = *((_DWORD *)v19 + 21) & 0xFFFFFF;
  if ((*((_DWORD *)v18 + 21) & 0xFFFFFF) != 0)
  {
    if (v20)
      goto LABEL_13;
LABEL_48:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>((uint64_t)a1, a2, a5, a6);
    return 0;
  }
  if (v20 || *((_DWORD *)v18 + 22) != *((_DWORD *)v19 + 22))
    goto LABEL_48;
LABEL_13:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v71);
    re::TypeInfo::TypeInfo((uint64_t)v68, (uint64_t)v72);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v71);
    re::TypeInfo::TypeInfo((uint64_t)v66, (uint64_t)v72);
    re::TypeInfo::TypeInfo((uint64_t)v64, (uint64_t)a5);
    v28 = (*((uint64_t (**)(re::Allocator **, _BYTE *))*a1 + 10))(a1, v68);
    if (!v28)
    {
      v45 = (re::TypeInfo *)v68;
      goto LABEL_28;
    }
    v29 = (void (*)(re::Allocator **, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v28;
    v30 = re::ArrayAccessor::size((re::ArrayAccessor *)v64, a4);
    v63 = (const re::TypeInfo *)v30;
    v31 = *(_DWORD *)(*((_QWORD *)a5 + 2) + 84) & 0xFFFFFF;
    if (v31)
      v32 = 8;
    else
      v32 = 4;
    result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((_anonymous_namespace_ *)(a1 + 3), a2, (uint64_t)a3, &v63, v32);
    if (!(_DWORD)result)
      return result;
    v39 = v63;
    if ((const re::TypeInfo *)v30 != v63)
    {
      if ((*(_DWORD *)(v65 + 84) & 0xFFFFFF) == 0)
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, 0, "Invalid array size. Expected size = %zu, actual size = %zu", v34, v35, v36, v37, v38, v30);
        return 0;
      }
      re::TypeRegistry::typeInfo(v64[0], *(_QWORD *)(v65 + 72), &v71);
      re::TypeInfo::TypeInfo((uint64_t)v69, (uint64_t)v72);
      if (!is_mul_ok(*(unsigned int *)(v70 + 8), (unint64_t)v39))
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, 0, "Size overflow during deserialization. Element size = %zu, count = %zu", v40, v41, v42, v43, v44, *(_DWORD *)(v70 + 8));
        return 0;
      }
      re::ArrayAccessor::reset((re::ArrayAccessor *)v64, (void **)a4, a1[6], v39);
      v30 = (uint64_t)v63;
    }
    if (v31)
      v56 = v30 == 0;
    else
      v56 = 1;
    v57 = v56;
    if (!v56)
    {
      v58 = *(_QWORD *)a4;
      v62[0] = 0;
      v62[1] = 0xFFFFFFFFLL;
      (*((void (**)(re::Allocator **, uint64_t, _QWORD *))*a1 + 2))(a1, v58, v62);
      v30 = (uint64_t)v63;
    }
    if (v30)
    {
      v59 = 0;
      do
      {
        v60 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)v64, a4, v59);
        v29(a1, 0, 0, v60, v68, v66, 0);
        ++v59;
      }
      while (v59 < (unint64_t)v63);
    }
    if ((v57 & 1) == 0)
      (*((void (**)(re::Allocator **))*a1 + 3))(a1);
    v55 = (_anonymous_namespace_ *)(a1 + 3);
    goto LABEL_66;
  }
  v21 = a1[34];
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v71);
  re::TypeInfo::TypeInfo((uint64_t)v68, (uint64_t)v72);
  re::internal::translateType(v21, (const re::TypeRegistry *)v68, (uint64_t)v69);
  v22 = (*((uint64_t (**)(re::Allocator **, _BYTE *))*a1 + 10))(a1, v69);
  if (!v22)
  {
    v45 = (re::TypeInfo *)v69;
LABEL_28:
    v61 = re::TypeInfo::name(v45)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v46, v47, v48, v49, v50, v61);
    return 0;
  }
  v23 = (void (*)(re::Allocator **, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v22;
  v24 = (_QWORD *)*((_QWORD *)a6 + 2);
  v25 = *((_DWORD *)v24 + 21) & 0xFFFFFF;
  if (v25)
  {
    v26 = 0;
    v27 = 8;
  }
  else
  {
    v26 = *((int *)v24 + 22);
    v27 = 4;
  }
  v71 = v26;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((_anonymous_namespace_ *)(a1 + 3), a2, (uint64_t)a3, &v71, v27);
  if ((_DWORD)result)
  {
    v51 = v71;
    if (v25)
      v52 = v71 == 0;
    else
      v52 = 1;
    v53 = v52;
    if (!v52)
    {
      v67[0] = 0;
      v67[1] = 0xFFFFFFFFLL;
      (*((void (**)(re::Allocator **, _QWORD, _QWORD *))*a1 + 2))(a1, 0, v67);
      v51 = v71;
    }
    if (v51)
    {
      v54 = 0;
      do
      {
        v23(a1, 0, 0, 0, v69, v69, 1);
        ++v54;
      }
      while (v54 < v71);
    }
    if ((v53 & 1) == 0)
      (*((void (**)(re::Allocator **))*a1 + 3))(a1);
    v55 = (_anonymous_namespace_ *)(a1 + 3);
LABEL_66:
    re::EncoderBinary<re::SeekableInputStream>::endArray(v55);
    return (unsigned int *)(*((_BYTE *)a1 + 64) == 0);
  }
  return result;
}

BOOL re::serializeList<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  re::internal *v18;
  uint64_t v19;
  void (*v20)(uint64_t, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  _anonymous_namespace_ *v21;
  unsigned int v22;
  _BOOL8 result;
  unint64_t i;
  uint64_t v25;
  void (*v26)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  uint64_t v27;
  unsigned int v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  re::TypeInfo *v36;
  uint64_t v37;
  void (*v38)(uint64_t, unint64_t *, uint64_t, unint64_t);
  unint64_t j;
  uint64_t v40;
  uint64_t (*v41)(uint64_t, _QWORD);
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  re::TypeInfo *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  _QWORD *v54[2];
  uint64_t v55;
  _BYTE v56[32];
  _BYTE v57[32];
  _BYTE v58[16];
  uint64_t v59;
  unint64_t v60;
  _BYTE v61[32];

  if (a5 == a6)
    goto LABEL_11;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_11;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v18 = *(re::internal **)(a1 + 272);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v60);
    re::TypeInfo::TypeInfo((uint64_t)v57, (uint64_t)v61);
    re::internal::translateType(v18, (const re::TypeRegistry *)v57, (uint64_t)v58);
    v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v58);
    if (v19)
    {
      v20 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v19;
      v60 = 0;
      v21 = (_anonymous_namespace_ *)(a1 + 24);
      v22 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v60, 0);
      result = 0;
      if (!v22)
        return result;
      if (v60)
      {
        for (i = 0; i < v60; ++i)
          v20(a1, 0, 0, 0, v58, v58, 1);
      }
      goto LABEL_34;
    }
    v36 = (re::TypeInfo *)v58;
    goto LABEL_26;
  }
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v60);
  re::TypeInfo::TypeInfo((uint64_t)v57, (uint64_t)v61);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v60);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v61);
  re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)a5);
  v25 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v57);
  if (!v25)
  {
    v36 = (re::TypeInfo *)v57;
LABEL_26:
    v51 = re::TypeInfo::name(v36)[1];
    v35 = "Failed to resolve serialize function for type \"%s\"";
    goto LABEL_27;
  }
  v26 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v25;
  v27 = (*(uint64_t (**)(uint64_t))(v55 + 80))(a4);
  v53 = v27;
  v21 = (_anonymous_namespace_ *)(a1 + 24);
  v28 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v53, 0);
  result = 0;
  if (!v28)
    return result;
  v29 = v53;
  if (v27 != v53)
  {
    re::TypeRegistry::typeInfo(v54[0], *(_QWORD *)(v55 + 72), &v60);
    re::TypeInfo::TypeInfo((uint64_t)v58, (uint64_t)v61);
    if (!is_mul_ok(*(unsigned int *)(v59 + 8), v29))
    {
      LODWORD(v51) = *(_DWORD *)(v59 + 8);
      v35 = "Size overflow during deserialization. Element size = %zu, count = %zu";
LABEL_27:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, v35, v30, v31, v32, v33, v34, v51);
      return 0;
    }
    v37 = *(_QWORD *)(a1 + 48);
    v38 = *(void (**)(uint64_t, unint64_t *, uint64_t, unint64_t))(v55 + 88);
    re::TypeInfo::TypeInfo((uint64_t)&v60, (uint64_t)v54);
    v38(a4, &v60, v37, v29);
  }
  if (*(_QWORD *)(v55 + 96))
  {
    if (v53)
    {
      for (j = 0; j < v53; ++j)
      {
        v40 = (*(uint64_t (**)(uint64_t, unint64_t))(v55 + 96))(a4, j);
        v26(a1, 0, 0, v40, v57, v56, 0);
      }
    }
  }
  else
  {
    v41 = *(uint64_t (**)(uint64_t, _QWORD))(v55 + 104);
    if (!v41 || !*(_QWORD *)(v55 + 112) || !*(_QWORD *)(v55 + 120))
    {
      v45 = (re::TypeInfo *)re::TypeInfo::TypeInfo((uint64_t)&v60, (uint64_t)v54);
      v52 = re::TypeInfo::name(v45)[1];
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "List type \"%s\" does not provide an indexer or iterator.", v46, v47, v48, v49, v50, v52);
      return 0;
    }
    v42 = v41(a4, *(_QWORD *)(a1 + 56));
    v43 = (*(uint64_t (**)(void))(v55 + 112))();
    if (v43)
    {
      v44 = v43;
      do
      {
        v26(a1, 0, 0, v44, v57, v56, 0);
        v44 = (*(uint64_t (**)(uint64_t))(v55 + 112))(v42);
      }
      while (v44);
    }
    (*(void (**)(uint64_t, _QWORD))(v55 + 120))(v42, *(_QWORD *)(a1 + 56));
  }
LABEL_34:
  re::EncoderBinary<re::SeekableInputStream>::endArray(v21);
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeDictionary<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  const re::TypeInfo *v14;
  uint64_t *v15;
  int v16;
  unint64_t v17;
  char *v18;
  _BOOL8 result;
  unint64_t v20;
  char *v21;
  char *v22;
  const char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  re::internal *v29;
  re::internal *v30;
  uint64_t v31;
  void (*v32)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  uint64_t v33;
  void (*v34)(uint64_t, const char *, _QWORD, _QWORD, _QWORD *, _QWORD *, uint64_t);
  _anonymous_namespace_ *v35;
  unsigned int v36;
  unint64_t i;
  uint64_t v38;
  void (*v39)(uint64_t, const char *, _QWORD, void **, _BYTE *, _BYTE *, _QWORD);
  uint64_t v40;
  void (*v41)(uint64_t, const char *, _QWORD, uint64_t, _QWORD *, _BYTE *, _QWORD);
  unsigned int v42;
  uint64_t v43;
  void (*v44)(uint64_t, unint64_t *, uint64_t);
  void **Instance;
  uint64_t v46;
  re::Allocator *v47;
  uint64_t v48;
  re::TypeInfo *v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  unint64_t v57;
  _BYTE v58[16];
  uint64_t v59;
  _BYTE v60[32];
  _BYTE v61[32];
  _QWORD v62[4];
  _BYTE v63[12];
  unsigned __int8 v64;
  unint64_t v65;
  _QWORD v66[4];

  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v65);
  re::TypeInfo::TypeInfo((uint64_t)v63, (uint64_t)v66);
  v15 = re::TypeInfo::name((re::TypeInfo *)v63);
  v16 = v64;
  if (v64 != 1)
  {
LABEL_10:
    if (v16 == 8)
    {
      v20 = (unint64_t)*v15 >> 1;
      if (v20 == 0x22C6ED80D0CLL)
      {
        v24 = (char *)v15[1];
        if (v24 == "StringID" || !strcmp(v24, "StringID"))
          return re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, a5, a6, a7);
      }
      else if (v20 == 0x134375A94D9F7110)
      {
        v21 = (char *)v15[1];
        if (v21 == "DynamicString" || !strcmp(v21, "DynamicString"))
          return re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, a5, a6, a7);
      }
    }
    goto LABEL_22;
  }
  if (!re::TypeInfo::isInteger((re::TypeInfo *)v63))
  {
    v16 = v64;
    goto LABEL_10;
  }
  v17 = (unint64_t)*v15 >> 1;
  if (v17 <= 0x303EE8780EDLL)
  {
    if (v17 != 3393056694)
    {
      if (v17 == 0x303EE86A734)
      {
        v18 = (char *)v15[1];
        if (v18 == "uint16_t" || !strcmp(v18, "uint16_t"))
          return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(a1, a2, a3, a4, a5, a6, a7);
      }
      goto LABEL_62;
    }
    v22 = (char *)v15[1];
    if (v22 == "size_t")
      return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(a1, a2, a3, a4, a5, a6, a7);
    v23 = "size_t";
LABEL_58:
    if (strcmp(v22, v23))
      goto LABEL_62;
    return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(a1, a2, a3, a4, a5, a6, a7);
  }
  if (v17 == 0x303EE8780EELL)
  {
    v56 = (char *)v15[1];
    if (v56 == "uint32_t" || !strcmp(v56, "uint32_t"))
      return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(a1, a2, a3, a4, a5, a6, a7);
    goto LABEL_62;
  }
  if (v17 == 0x303EE88E58DLL)
  {
    v22 = (char *)v15[1];
    if (v22 == "uint64_t")
      return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(a1, a2, a3, a4, a5, a6, a7);
    v23 = "uint64_t";
    goto LABEL_58;
  }
LABEL_62:
  v65 = 0x18E6A9A093;
  v66[0] = "uint8_t";
  if (re::StringID::operator==(v15, &v65))
    return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(a1, a2, a3, a4, a5, a6, a7);
  v65 = 0x16749F63A2;
  v66[0] = "int64_t";
  if (re::StringID::operator==(v15, &v65))
    return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(a1, a2, a3, a4, a5, a6, a7);
  v62[0] = 3327612;
  v62[1] = "long";
  if (re::StringID::operator==(v15, v62))
    return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(a1, a2, a3, a4, a5, a6, a7);
  v65 = 104431;
  v66[0] = "int";
  if (re::StringID::operator==(v15, &v65))
    return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(a1, a2, a3, a4, a5, a6, a7);
  v65 = 109413500;
  v66[0] = "short";
  if (re::StringID::operator==(v15, &v65))
    return re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(a1, a2, a3, a4, a5, a6, a7);
LABEL_22:
  if (a5 == a6)
    goto LABEL_32;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v25 = **((_QWORD **)a5 + 2);
    v26 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v25 == (unsigned __int16)v26)
    {
      v28 = WORD1(v25) == WORD1(v26);
      v27 = (v26 ^ v25) & 0xFFFFFF00000000;
      v28 = v28 && v27 == 0;
      if (v28)
        goto LABEL_32;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, v14))
  {
    goto LABEL_32;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_32:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v65);
    re::TypeInfo::TypeInfo((uint64_t)v63, (uint64_t)v66);
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v65);
    re::TypeInfo::TypeInfo((uint64_t)v62, (uint64_t)v66);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v65);
    re::TypeInfo::TypeInfo((uint64_t)v61, (uint64_t)v66);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v65);
    re::TypeInfo::TypeInfo((uint64_t)v60, (uint64_t)v66);
    re::TypeInfo::TypeInfo((uint64_t)v58, (uint64_t)a5);
    v38 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v63);
    if (v38)
    {
      v39 = (void (*)(uint64_t, const char *, _QWORD, void **, _BYTE *, _BYTE *, _QWORD))v38;
      v40 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 80))(a1, v62);
      if (v40)
      {
        v41 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, _QWORD *, _BYTE *, _QWORD))v40;
        v57 = (*(uint64_t (**)(uint64_t))(v59 + 88))(a4);
        v35 = (_anonymous_namespace_ *)(a1 + 24);
        v42 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v57, 0);
        result = 0;
        if (!v42)
          return result;
        v43 = *(_QWORD *)(a1 + 48);
        v44 = *(void (**)(uint64_t, unint64_t *, uint64_t))(v59 + 96);
        re::TypeInfo::TypeInfo((uint64_t)&v65, (uint64_t)v58);
        v44(a4, &v65, v43);
        if (v57)
        {
          Instance = re::TypeInfo::createInstance((re::TypeInfo *)v63, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          if (v57)
          {
            v46 = 0;
            while (1)
            {
              re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 0);
              v39(a1, "key", 0, Instance, v63, v61, 0);
              v47 = *(re::Allocator **)(a1 + 48);
              if (*(_BYTE *)(a1 + 64))
                break;
              v48 = (*(uint64_t (**)(uint64_t, _BYTE *, re::Allocator *, void **))(v59 + 104))(a4, v58, v47, Instance);
              v41(a1, "value", 0, v48, v62, v60, 0);
              re::EncoderBinary<re::SeekableInputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
              if (++v46 >= v57)
                goto LABEL_48;
            }
            re::TypeInfo::releaseInstance((re::TypeInfo *)v63, Instance, v47, *(void **)(a1 + 264));
            return 0;
          }
LABEL_48:
          re::TypeInfo::releaseInstance((re::TypeInfo *)v63, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
        }
LABEL_49:
        re::EncoderBinary<re::SeekableInputStream>::endDictionary(v35);
        return *(_BYTE *)(a1 + 64) == 0;
      }
      goto LABEL_52;
    }
LABEL_50:
    v49 = (re::TypeInfo *)v63;
LABEL_53:
    v50 = re::TypeInfo::name(v49);
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v51, v52, v53, v54, v55, v50[1]);
    return 0;
  }
  v29 = *(re::internal **)(a1 + 272);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v65);
  re::TypeInfo::TypeInfo((uint64_t)v62, (uint64_t)v66);
  re::internal::translateType(v29, (const re::TypeRegistry *)v62, (uint64_t)v63);
  v30 = *(re::internal **)(a1 + 272);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v65);
  re::TypeInfo::TypeInfo((uint64_t)v61, (uint64_t)v66);
  re::internal::translateType(v30, (const re::TypeRegistry *)v61, (uint64_t)v62);
  v31 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v63);
  if (!v31)
    goto LABEL_50;
  v32 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v31;
  v33 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 80))(a1, v62);
  if (!v33)
  {
LABEL_52:
    v49 = (re::TypeInfo *)v62;
    goto LABEL_53;
  }
  v34 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, _QWORD *, _QWORD *, uint64_t))v33;
  v65 = 0;
  v35 = (_anonymous_namespace_ *)(a1 + 24);
  v36 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v65, 0);
  result = 0;
  if (v36)
  {
    if (v65)
    {
      for (i = 0; i < v65; ++i)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 1);
        v32(a1, "key", 0, 0, v63, v63, 1);
        v34(a1, "value", 0, 0, v62, v62, 1);
        re::EncoderBinary<re::SeekableInputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    goto LABEL_49;
  }
  return result;
}

unsigned int *re::serializeUnion<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  unsigned int *result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  unint64_t v19[4];
  unint64_t Tag;
  _BYTE v21[32];

  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        goto LABEL_4;
    }
LABEL_19:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_19;
LABEL_4:
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 16);
  if (a7)
  {
    if (!(_DWORD)result)
      return result;
    v19[0] = 0;
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, "tag", 0, v19, 0, (uint64_t)"uint64");
    if (v19[0] < *(unsigned int *)(*((_QWORD *)a6 + 2) + 88))
    {
      re::TypeInfo::unionMember(a6, v19[0], (uint64_t)v21);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, "value", 0, 0, v21, v21, 1);
    }
  }
  else
  {
    if (!(_DWORD)result)
      return result;
    re::TypeInfo::TypeInfo((uint64_t)v21, (uint64_t)a5);
    Tag = re::UnionAccessor::readTag((re::UnionAccessor *)v21, a4);
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, "tag", 0, &Tag, 0, (uint64_t)"uint64");
    re::UnionAccessor::reset((re::UnionAccessor *)v21, a4, (const re::TypeInfo *)Tag, *(re::Allocator **)(a1 + 48));
    if (Tag < *(unsigned int *)(*((_QWORD *)a5 + 2) + 88))
    {
      re::TypeInfo::unionMember(a5, Tag, (uint64_t)v19);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, unint64_t *, unint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, "value", 0, a4, v19, v19, 0);
    }
  }
  re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
  return (unsigned int *)(*(_BYTE *)(a1 + 64) == 0);
}

uint64_t re::serializeObject<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, uint64_t a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  uint64_t *v14;
  const char *v15;
  unsigned int v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  int v21;
  uint64_t v22;
  const re::TypeInfo *v23;
  int v24;
  re::TypeRegistry *v25;
  re *v26;
  const re::TypeInfo *v27;
  uint64_t v28;
  char *v29;
  const re::TypeInfo *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void **Instance;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _BYTE *v58;
  uint64_t v59;
  uint64_t *v60[4];
  _BYTE v61[8];
  uint64_t v62;
  uint64_t v63;
  char v64;
  _BYTE v65[23];
  unsigned __int8 v66[8];
  uint64_t v67[4];
  _QWORD v68[2];

  if ((_DWORD)a7)
  {
    if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
    {
      v25 = *(re::TypeRegistry **)(a1 + 272);
      v68[0] = 0x2686EB529B3EE220;
      v68[1] = "DynamicString";
      re::TypeRegistry::typeInfo(v25, (const re::StringID *)v68, v61);
      re::TypeInfo::TypeInfo((uint64_t)v66, (uint64_t)&v62);
      re::StringID::destroyString((re::StringID *)v68);
      v26 = (re *)v66;
      v27 = (const re::TypeInfo *)v66;
      v28 = a1;
      v29 = a2;
      v30 = (const re::TypeInfo *)a3;
    }
    else
    {
      v14 = re::TypeInfo::name(this);
      if ((unint64_t)*v14 >> 1 != 0x134375A94D9F7110)
        goto LABEL_6;
      v15 = (const char *)v14[1];
      if (v15 != "DynamicString")
      {
        if (strcmp(v15, "DynamicString"))
          goto LABEL_6;
      }
      v28 = a1;
      v29 = a2;
      v30 = (const re::TypeInfo *)a3;
      v26 = this;
      v27 = this;
    }
    re::serializeDynamicString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(v28, v29, v30, 0, v26, v27, 1);
    return *(_BYTE *)(a1 + 64) == 0;
  }
LABEL_6:
  if ((*(_BYTE *)(*((_QWORD *)this + 2) + 48) & 4) != 0)
    return re::internal::serializeObjectWithOneMember<re::EncoderBinary<re::SeekableInputStream>>((_BYTE *)a1, a2, a3, (uint64_t)a4, (uint64_t *)this, (uint64_t *)a6, a7);
  v16 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, a3, 0);
  result = 0;
  if (v16)
  {
    v18 = *(_QWORD *)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v18
      && *(_WORD *)(v18 + 22) == 3
      && *(_DWORD *)v18
      && (v19 = *(_QWORD *)(v18 + 8), (*(_WORD *)(v19 + 46) & 0x40) != 0)
      && ((*(_WORD *)(v19 + 22) & 0x1000) != 0 ? (v20 = *(const char **)(v18 + 8)) : (v20 = *(const char **)(v19 + 8)),
          !strcmp(v20, "@version")))
    {
      v21 = *(_DWORD *)(v19 + 24);
    }
    else
    {
      v21 = 1;
    }
    v22 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
    if (v22)
      v24 = *(_DWORD *)(v22 + 16);
    else
      v24 = -1;
    if (v21 == v24)
    {
      if (this != (re::TypeInfo *)a6)
      {
        if (*(_QWORD *)this == *(_QWORD *)a6)
        {
          v39 = **((_QWORD **)this + 2);
          v40 = **(_QWORD **)(a6 + 16);
          if ((unsigned __int16)v39 == (unsigned __int16)v40
            && WORD1(v39) == WORD1(v40)
            && ((v40 ^ v39) & 0xFFFFFF00000000) == 0)
          {
            goto LABEL_28;
          }
        }
        else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v23))
        {
          goto LABEL_28;
        }
        if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
        {
          re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, (uint64_t)a4, (uint64_t *)this, (uint64_t *)a6, a7);
        }
        else
        {
          v41 = re::TypeInfo::name(this)[1];
          re::TypeInfo::name((re::TypeInfo *)a6);
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v42, v43, v44, v45, v46, v41);
        }
        goto LABEL_41;
      }
LABEL_28:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, (uint64_t)a4, (uint64_t *)this, a7);
LABEL_41:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(_BYTE *)(a1 + 64) == 0;
    }
    if (*(_QWORD *)this != *(_QWORD *)a6
      || (v31 = **((_QWORD **)this + 2), v32 = **(_QWORD **)(a6 + 16), (unsigned __int16)v31 != (unsigned __int16)v32)
      || WORD1(v31) != WORD1(v32)
      || ((v32 ^ v31) & 0xFFFFFF00000000) != 0)
    {
      v33 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type \"%s\" version %u expected in JSON. Actual version found in JSON: %u", v34, v35, v36, v37, v38, v33);
      return 0;
    }
    re::TypeInfo::atVersion(this, v21, v66);
    if (!v66[0])
    {
      v59 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Unknown serialized type \"%s\" version %u. No matching runtime type found.", v48, v49, v50, v51, v52, v59);
      return 0;
    }
    if ((a7 & 1) != 0)
      Instance = 0;
    else
      Instance = re::TypeInfo::createInstance((re::TypeInfo *)v67, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
    re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, (uint64_t)Instance, v67, a7);
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    if (*(_BYTE *)(a1 + 64))
    {
      if (Instance)
        re::TypeInfo::releaseInstance((re::TypeInfo *)v67, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
      return 0;
    }
    if ((a7 & 1) == 0)
    {
      re::TypeInfo::TypeInfo((uint64_t)v60, (uint64_t)v67);
      re::internal::upgradeObject(Instance, v60, a4, (uint64_t **)this, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264), v61);
      if (!v61[0])
      {
        if ((v64 & 1) != 0)
          LOBYTE(v58) = v65[7];
        else
          v58 = v65;
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "%s", v53, v54, v55, v56, v57, (char)v58);
        if (!v61[0] && v63 && (v64 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v63 + 40))();
      }
    }
    return 1;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(uint64_t a1, char *a2, uint64_t a3, BOOL *a4, char a5)
{
  uint64_t result;
  int v10;
  const char *v11;
  re *v12;
  BOOL v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    v10 = *(unsigned __int16 *)(result + 22);
    if ((v10 & 8) != 0)
    {
      v13 = v10 == 10;
    }
    else
    {
      if ((v10 & 0x400) == 0
        || !*(_BYTE *)(a1 + 233)
        || ((v10 & 0x1000) != 0 ? (v11 = (const char *)result) : (v11 = *(const char **)(result + 8)),
            (v12 = (re *)strcasecmp(v11, "true"), v13 = (_DWORD)v12 == 0, (_DWORD)v12)
         && (v12 = (re *)strcasecmp(v11, "false"), (_DWORD)v12)))
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, (uint64_t)"BOOL");
        return 0;
      }
      v15 = *re::foundationSerializationLogObjects(v12);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v16 = 136315138;
        v17 = v11;
        _os_log_impl(&dword_224FE9000, v15, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as BOOLean in Bool/String Compatibility Mode", (uint8_t *)&v16, 0xCu);
      }
    }
    if ((a5 & 1) != 0)
    {
      if ((a5 & 2) != 0)
        return 1;
    }
    else
    {
      *a4 = v13;
      if ((a5 & 2) != 0)
        return 1;
    }
    v14 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v14 - 16);
    return 1;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(uint64_t a1, char *a2, uint64_t a3, _BYTE *a4, char a5)
{
  unsigned int *result;
  int v10;
  _BYTE *v11;
  uint64_t v12;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*((_WORD *)result + 11) & 0x400) == 0)
    {
      v10 = (*((_WORD *)result + 11) & 0x1000) != 0 ? 21 - *((char *)result + 21) : *result;
      if (v10 == 1)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, (uint64_t)"char");
        return 0;
      }
    }
    if ((a5 & 1) == 0)
    {
      if ((*((_WORD *)result + 11) & 0x1000) != 0)
        v11 = result;
      else
        v11 = (_BYTE *)*((_QWORD *)result + 1);
      *a4 = *v11;
    }
    if ((a5 & 2) == 0)
    {
      v12 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v12 - 16);
    }
    return (unsigned int *)1;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(_anonymous_namespace_ *a1, char *__s, _DWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v8;
  uint64_t Member;
  uint64_t v12;

  v4 = *((_QWORD *)a1 + 16);
  v5 = *((_QWORD *)a1 + 14) - 1;
  v6 = *(unsigned __int8 *)(v4 + 48 * v5);
  if (!*(_BYTE *)(v4 + 48 * v5))
    return (unsigned int *)*((_QWORD *)a1 + 22);
  v8 = v4 + 48 * v5;
  Member = *(_QWORD *)(v8 + 40);
  if (Member)
  {
    if (v6 == 7)
      goto LABEL_6;
    if (v6 != 5)
    {
      if (v6 != 2)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::evaluateConditional(a1, __s, (unsigned int *)Member, a3);
LABEL_6:
      Member = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::findMember((int)a1, *(unsigned int **)(v8 + 40), __s);
      return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::evaluateConditional(a1, __s, (unsigned int *)Member, a3);
    }
    v12 = *(_QWORD *)(v4 + 48 * v5 + 32);
    if (*(_DWORD *)Member > v12)
    {
      Member = *(_QWORD *)(Member + 8) + 24 * v12;
      return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::evaluateConditional(a1, __s, (unsigned int *)Member, a3);
    }
  }
  return 0;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType(_anonymous_namespace_ *a1, const char *a2, uint64_t a3)
{
  _BYTE *v5;
  uint64_t result;
  uint64_t v7;
  char v8;
  _BYTE v9[23];
  _OWORD v10[2];

  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v7);
  if ((v8 & 1) != 0)
    v5 = *(_BYTE **)&v9[7];
  else
    v5 = v9;
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Expected type: \"%s\"", (re::DynamicString *)v10, v5, a3);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v10);
  if (*(_QWORD *)&v10[0])
  {
    if ((BYTE8(v10[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
    memset(v10, 0, sizeof(v10));
  }
  result = v7;
  if (v7)
  {
    if ((v8 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v7 + 40))();
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::findMember(int a1, unsigned int *a2, char *__s)
{
  size_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  char *v11;
  int v12;
  uint64_t v13;
  __darwin_ct_rune_t v14;
  uint64_t v15;
  uint64_t result;

  v5 = strlen(__s);
  v6 = *a2;
  if ((_DWORD)v6)
  {
    v7 = v5;
    v8 = *((_QWORD *)a2 + 1);
    v9 = v5 - 1;
    v10 = v8 + 24;
    do
    {
      if ((*(_WORD *)(v10 - 2) & 0x1000) != 0)
        v11 = (char *)(v10 - 24);
      else
        v11 = *(char **)(v10 - 16);
      if ((*(_WORD *)(v10 - 2) & 0x1000) != 0)
        v12 = 21 - *(char *)(v10 - 3);
      else
        v12 = *(_DWORD *)(v10 - 24);
      if (v7 == v12 && !strncmp(__s + 1, v11 + 1, v9))
      {
        if (!v7)
        {
          re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
          result = _os_crash();
          __break(1u);
          return result;
        }
        v14 = __toupper(*__s);
        if (v14 == __toupper(*v11))
          return v10;
        v8 = *((_QWORD *)a2 + 1);
        v6 = *a2;
      }
      v15 = v10 + 24;
      v10 += 48;
    }
    while (v15 != v8 + 48 * v6);
  }
  return 0;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::evaluateConditional(_anonymous_namespace_ *a1, const char *a2, unsigned int *a3, _DWORD *a4)
{
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _WORD *v14;
  int *v15;
  int v16;
  _BYTE *v17;
  uint64_t v19;
  char v20;
  _BYTE v21[23];
  _OWORD v22[2];

  v4 = a3;
  if (a3)
  {
    if (*((_WORD *)a3 + 11) == 4)
    {
      v5 = *a3;
      if (v5 >= 2)
      {
        v6 = *((_QWORD *)a3 + 1);
        if ((*(_WORD *)(v6 + 22) & 0x400) != 0)
        {
          v10 = (*(_WORD *)(v6 + 22) & 0x1000) != 0 ? (const char *)*((_QWORD *)a3 + 1) : *(const char **)(v6 + 8);
          if (!strcmp(v10, "@cond"))
          {
            v12 = v5 - 1;
            v13 = (v5 - 1) - 1;
            v14 = (_WORD *)(v6 + 46);
            while (1)
            {
              if (*v14 != 4)
                goto LABEL_17;
              if (*(_DWORD *)(v14 - 11) < 2u)
                goto LABEL_17;
              v15 = *(int **)(v14 - 7);
              if ((*((_WORD *)v15 + 11) & 0x20) == 0)
                goto LABEL_17;
              v16 = *v15;
              if (!v13 || *((_DWORD *)a1 + 34) <= v16)
                break;
              --v13;
              v14 += 12;
              if (!--v12)
              {
                re::internal::assertLog((re::internal *)4, v11, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "evaluateConditional", 1447);
                _os_crash();
                __break(1u);
LABEL_17:
                re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v19);
                if ((v20 & 1) != 0)
                  v17 = *(_BYTE **)&v21[7];
                else
                  v17 = v21;
                re::DynamicString::format((re::DynamicString *)"Failed to read version conditional \"%s\". Invalid condition.", (re::DynamicString *)v22, v17);
                re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v22);
                if (*(_QWORD *)&v22[0])
                {
                  if ((BYTE8(v22[0]) & 1) != 0)
                    (*(void (**)(void))(**(_QWORD **)&v22[0] + 40))();
                  memset(v22, 0, sizeof(v22));
                }
                if (v19 && (v20 & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)v19 + 40))();
                return 0;
              }
            }
            if (a4)
            {
              *a4 = v16;
              v15 = *(int **)(v14 - 7);
            }
            return (unsigned int *)(v15 + 6);
          }
        }
      }
    }
  }
  return v4;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(uint64_t a1, char *a2, uint64_t a3, _BYTE *a4, char a5, uint64_t a6)
{
  unsigned int *result;
  unsigned __int8 *v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  _BOOL4 v17;
  BOOL v18;
  unint64_t v19;
  unsigned __int8 *v20;
  unsigned int v21;
  NSObject *v22;
  unsigned int v23;
  uint8_t buf[4];
  unsigned __int8 *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*((_WORD *)result + 11) & 0x20) != 0)
    {
      v14 = *result;
      if (v14 != (char)v14)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorValueOutOfTypeRange((_anonymous_namespace_ *)a1, a2, a6);
        return 0;
      }
LABEL_14:
      if ((a5 & 1) == 0)
        *a4 = v14;
      if ((a5 & 2) == 0)
      {
        v15 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v15 - 16);
      }
      return (unsigned int *)1;
    }
    if ((*((_WORD *)result + 11) & 0x400) == 0 || !*(_BYTE *)(a1 + 232))
      goto LABEL_43;
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v12 = (unsigned __int8 *)result;
    else
      v12 = (unsigned __int8 *)*((_QWORD *)result + 1);
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v13 = 21 - *((char *)result + 21);
    else
      v13 = *result;
    v16 = &v12[v13];
    if (v13)
      v17 = *v12 == 45;
    else
      v17 = 0;
    v18 = v17;
    if (v13 == (unint64_t)v17)
      goto LABEL_38;
    v19 = v13 - (unint64_t)v17;
    v20 = &v12[v17];
    while (*v20 == 48)
    {
      ++v20;
      if (!--v19)
        goto LABEL_38;
    }
    if (!v19)
    {
LABEL_38:
      v20 = &v12[v13];
    }
    else if (*v20 - 48 < 0xA)
    {
      v20 = std::__itoa::__traits<unsigned char>::__read[abi:nn180100](v20, v16, buf, &v23);
      if (v20 != v16 && *v20 - 48 <= 9 || *(_DWORD *)buf > 0xFFu || 255 - *(_DWORD *)buf < v23)
        goto LABEL_43;
      v21 = v23 + *(_DWORD *)buf;
      if (!v18)
      {
        if ((v21 & 0x80) != 0)
          goto LABEL_43;
        LOBYTE(v14) = v23 + buf[0];
        goto LABEL_42;
      }
      if ((v23 + buf[0]) > 0x80u)
        goto LABEL_43;
LABEL_41:
      v14 = -v21;
LABEL_42:
      if (v16 != v20)
        goto LABEL_43;
      v22 = *re::foundationSerializationLogObjects((re *)v20);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v25 = v12;
        _os_log_impl(&dword_224FE9000, v22, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
      }
      goto LABEL_14;
    }
    if (v20 == &v12[v17])
    {
LABEL_43:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    v21 = 0;
    LOBYTE(v14) = 0;
    if (!v17)
      goto LABEL_42;
    goto LABEL_41;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorValueOutOfTypeRange(_anonymous_namespace_ *a1, const char *a2, uint64_t a3)
{
  _BYTE *v5;
  uint64_t result;
  uint64_t v7;
  char v8;
  _BYTE v9[23];
  _OWORD v10[2];

  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v7);
  if ((v8 & 1) != 0)
    v5 = *(_BYTE **)&v9[7];
  else
    v5 = v9;
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Value out of \"%s\" type range.", (re::DynamicString *)v10, v5, a3);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v10);
  if (*(_QWORD *)&v10[0])
  {
    if ((BYTE8(v10[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
    memset(v10, 0, sizeof(v10));
  }
  result = v7;
  if (v7)
  {
    if ((v8 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v7 + 40))();
  }
  return result;
}

unsigned __int8 *std::__itoa::__traits<unsigned char>::__read[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v4;
  int v5;
  int v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  _DWORD v12[3];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v4 = 2;
  do
  {
    v5 = *a1;
    if ((v5 - 58) < 0xFFFFFFF6)
      break;
    ++a1;
    v12[v4] = v5 - 48;
    if (v4-- == 0)
      break;
  }
  while (a1 != a2);
  v7 = v4 + 1;
  v8 = (v4 + 1) << 32;
  v9 = v12[v7];
  if (v7 <= 0)
    v9 += 10 * v12[v7 + 1];
  *a3 = v9;
  v10 = v12[2] * (unint64_t)*(unsigned int *)((char *)&std::__itoa::__pow10_32 + ((0x200000000 - v8) >> 30));
  *a4 = v10;
  return &a1[-((v10 & 0xFFFFFFFF00000000) != 0)];
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, char a5, uint64_t a6)
{
  unsigned int *result;
  unsigned __int8 *v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  _BOOL4 v17;
  BOOL v18;
  unint64_t v19;
  unsigned __int8 *v20;
  unsigned int v21;
  NSObject *v22;
  unsigned int v23;
  uint8_t buf[4];
  unsigned __int8 *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*((_WORD *)result + 11) & 0x20) != 0)
    {
      v14 = *result;
      if (v14 != (__int16)v14)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorValueOutOfTypeRange((_anonymous_namespace_ *)a1, a2, a6);
        return 0;
      }
LABEL_14:
      if ((a5 & 1) == 0)
        *a4 = v14;
      if ((a5 & 2) == 0)
      {
        v15 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v15 - 16);
      }
      return (unsigned int *)1;
    }
    if ((*((_WORD *)result + 11) & 0x400) == 0 || !*(_BYTE *)(a1 + 232))
      goto LABEL_43;
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v12 = (unsigned __int8 *)result;
    else
      v12 = (unsigned __int8 *)*((_QWORD *)result + 1);
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v13 = 21 - *((char *)result + 21);
    else
      v13 = *result;
    v16 = &v12[v13];
    if (v13)
      v17 = *v12 == 45;
    else
      v17 = 0;
    v18 = v17;
    if (v13 == (unint64_t)v17)
      goto LABEL_38;
    v19 = v13 - (unint64_t)v17;
    v20 = &v12[v17];
    while (*v20 == 48)
    {
      ++v20;
      if (!--v19)
        goto LABEL_38;
    }
    if (!v19)
    {
LABEL_38:
      v20 = &v12[v13];
    }
    else if (*v20 - 48 < 0xA)
    {
      v20 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v20, v16, buf, &v23);
      if (v20 != v16 && *v20 - 48 <= 9 || *(_WORD *)&buf[2] || 0xFFFF - *(_DWORD *)buf < v23)
        goto LABEL_43;
      v21 = v23 + *(_DWORD *)buf;
      if (!v18)
      {
        if ((v21 & 0x8000) != 0)
          goto LABEL_43;
        LOWORD(v14) = v23 + *(_WORD *)buf;
        goto LABEL_42;
      }
      if ((unsigned __int16)(v23 + *(_WORD *)buf) > 0x8000u)
        goto LABEL_43;
LABEL_41:
      v14 = -v21;
LABEL_42:
      if (v16 != v20)
        goto LABEL_43;
      v22 = *re::foundationSerializationLogObjects((re *)v20);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v25 = v12;
        _os_log_impl(&dword_224FE9000, v22, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
      }
      goto LABEL_14;
    }
    if (v20 == &v12[v17])
    {
LABEL_43:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    v21 = 0;
    LOWORD(v14) = 0;
    if (!v17)
      goto LABEL_42;
    goto LABEL_41;
  }
  return result;
}

unsigned __int8 *std::__itoa::__traits<unsigned short>::__read[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v4;
  int v5;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int *v11;
  int v12;
  unint64_t v13;
  _DWORD v15[4];
  unsigned int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = 4;
  do
  {
    v5 = *a1;
    if ((v5 - 58) < 0xFFFFFFF6)
      break;
    ++a1;
    v15[v4] = v5 - 48;
    if (v4-- == 0)
      break;
  }
  while (a1 != a2);
  v7 = v4 + 1;
  v8 = (v4 + 1) << 32;
  v9 = v15[v7];
  if (v7 <= 2)
  {
    v10 = v7;
    v11 = &dword_2260F75FC;
    do
    {
      v12 = *v11++;
      v9 += v12 * v15[++v10];
    }
    while (v10 != 3);
  }
  *a3 = v9;
  v13 = v16 * (unint64_t)*(unsigned int *)((char *)&std::__itoa::__pow10_32 + ((0x400000000 - v8) >> 30));
  *a4 = v13;
  return &a1[-((v13 & 0xFFFFFFFF00000000) != 0)];
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(uint64_t a1, char *a2, uint64_t a3, unsigned int *a4, char a5, uint64_t a6)
{
  uint64_t result;
  unsigned __int8 *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  _BOOL4 v17;
  BOOL v18;
  unint64_t v19;
  unsigned __int8 *v20;
  NSObject *v21;
  int v22;
  uint8_t buf[4];
  unsigned __int8 *v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*(_WORD *)(result + 22) & 0x20) != 0)
    {
      v14 = *(_DWORD *)result;
      goto LABEL_14;
    }
    if ((*(_WORD *)(result + 22) & 0x400) == 0 || !*(_BYTE *)(a1 + 232))
      goto LABEL_42;
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      v12 = (unsigned __int8 *)result;
    else
      v12 = *(unsigned __int8 **)(result + 8);
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      v13 = 21 - *(char *)(result + 21);
    else
      v13 = *(_DWORD *)result;
    v16 = &v12[v13];
    if (v13)
      v17 = *v12 == 45;
    else
      v17 = 0;
    v18 = v17;
    if (v13 == (unint64_t)v17)
      goto LABEL_37;
    v19 = v13 - (unint64_t)v17;
    v20 = &v12[v17];
    while (*v20 == 48)
    {
      ++v20;
      if (!--v19)
        goto LABEL_37;
    }
    if (!v19)
    {
LABEL_37:
      v20 = &v12[v13];
    }
    else if (*v20 - 48 < 0xA)
    {
      v20 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v20, v16, buf, &v22);
      if (v20 != v16 && *v20 - 48 <= 9 || __CFADD__(*(_DWORD *)buf, v22))
        goto LABEL_42;
      v14 = *(_DWORD *)buf + v22;
      if (!v18)
      {
        if ((v14 & 0x80000000) != 0)
          goto LABEL_42;
        goto LABEL_41;
      }
      if (v14 > 0x80000000)
        goto LABEL_42;
LABEL_40:
      v14 = -v14;
LABEL_41:
      if (v16 != v20)
        goto LABEL_42;
      v21 = *re::foundationSerializationLogObjects((re *)v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v24 = v12;
        _os_log_impl(&dword_224FE9000, v21, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
      }
LABEL_14:
      if ((a5 & 1) != 0)
      {
        if ((a5 & 2) != 0)
          return 1;
      }
      else
      {
        *a4 = v14;
        if ((a5 & 2) != 0)
          return 1;
      }
      v15 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v15 - 16);
      return 1;
    }
    if (v20 == &v12[v17])
    {
LABEL_42:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    v14 = 0;
    if (!v17)
      goto LABEL_41;
    goto LABEL_40;
  }
  return result;
}

unsigned __int8 *std::__itoa::__traits<unsigned int>::__read[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v4;
  int v5;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int *v11;
  int v12;
  unint64_t v13;
  _DWORD v15[10];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v4 = 9;
  do
  {
    v5 = *a1;
    if ((v5 - 58) < 0xFFFFFFF6)
      break;
    ++a1;
    v15[v4] = v5 - 48;
    if (v4-- == 0)
      break;
  }
  while (a1 != a2);
  v7 = v4 + 1;
  v8 = (v4 + 1) << 32;
  v9 = v15[v7];
  if (v7 <= 7)
  {
    v10 = v7;
    v11 = &dword_2260F75FC;
    do
    {
      v12 = *v11++;
      v9 += v12 * v15[++v10];
    }
    while (v10 != 8);
  }
  *a3 = v9;
  v13 = v15[9] * (unint64_t)*(unsigned int *)((char *)&std::__itoa::__pow10_32 + ((0x900000000 - v8) >> 30));
  *a4 = v13;
  return &a1[-((v13 & 0xFFFFFFFF00000000) != 0)];
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(uint64_t a1, char *a2, uint64_t a3, unint64_t *a4, char a5, uint64_t a6)
{
  uint64_t result;
  unsigned __int8 *v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  _BOOL4 v17;
  BOOL v18;
  unint64_t v19;
  unsigned __int8 *v20;
  NSObject *v21;
  uint64_t v22;
  uint8_t buf[24];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*(_WORD *)(result + 22) & 0x80) != 0)
    {
      v14 = *(_QWORD *)result;
      goto LABEL_14;
    }
    if ((*(_WORD *)(result + 22) & 0x400) == 0 || !*(_BYTE *)(a1 + 232))
      goto LABEL_42;
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      v12 = (unsigned __int8 *)result;
    else
      v12 = *(unsigned __int8 **)(result + 8);
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      v13 = 21 - *(char *)(result + 21);
    else
      v13 = *(_DWORD *)result;
    v16 = &v12[v13];
    if (v13)
      v17 = *v12 == 45;
    else
      v17 = 0;
    v18 = v17;
    if (v13 == (unint64_t)v17)
      goto LABEL_37;
    v19 = v13 - (unint64_t)v17;
    v20 = &v12[v17];
    while (*v20 == 48)
    {
      ++v20;
      if (!--v19)
        goto LABEL_37;
    }
    if (!v19)
    {
LABEL_37:
      v20 = &v12[v13];
    }
    else if (*v20 - 48 < 0xA)
    {
      v20 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v20, v16, buf, &v22);
      if (v20 != v16 && *v20 - 48 <= 9 || __CFADD__(*(_QWORD *)buf, v22))
        goto LABEL_42;
      v14 = *(_QWORD *)buf + v22;
      if (!v18)
      {
        if ((v14 & 0x8000000000000000) != 0)
          goto LABEL_42;
        goto LABEL_41;
      }
      if (v14 > 0x8000000000000000)
        goto LABEL_42;
LABEL_40:
      v14 = -(uint64_t)v14;
LABEL_41:
      if (v16 != v20)
        goto LABEL_42;
      v21 = *re::foundationSerializationLogObjects((re *)v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v12;
        _os_log_impl(&dword_224FE9000, v21, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
      }
LABEL_14:
      if ((a5 & 1) != 0)
      {
        if ((a5 & 2) != 0)
          return 1;
      }
      else
      {
        *a4 = v14;
        if ((a5 & 2) != 0)
          return 1;
      }
      v15 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
      ++*(_QWORD *)(v15 - 16);
      return 1;
    }
    if (v20 == &v12[v17])
    {
LABEL_42:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    v14 = 0;
    if (!v17)
      goto LABEL_41;
    goto LABEL_40;
  }
  return result;
}

unsigned __int8 *std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  int v5;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  _BOOL8 v14;
  _QWORD v16[19];
  unint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v4 = 19;
  do
  {
    v5 = *a1;
    if ((v5 - 58) < 0xFFFFFFF6)
      break;
    ++a1;
    v16[v4] = (v5 - 48);
    if (v4-- == 0)
      break;
  }
  while (a1 != a2);
  v7 = v4 + 1;
  v8 = (v4 + 1) << 32;
  v9 = v16[v7];
  if (v7 <= 17)
  {
    v10 = v7;
    v11 = &qword_2260F7498;
    do
    {
      v12 = *v11++;
      v9 += v12 * v16[++v10];
    }
    while (v10 != 18);
  }
  *a3 = v9;
  v13 = *(_QWORD *)((char *)&std::__itoa::__pow10_64 + ((0x1300000000 - v8) >> 29));
  v14 = !is_mul_ok(v17, v13);
  *a4 = v17 * v13;
  return &a1[-v14];
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(uint64_t a1, char *a2, uint64_t a3, _BYTE *a4, char a5, uint64_t a6)
{
  unsigned int *result;
  unsigned __int8 *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  NSObject *v18;
  unsigned int v19;
  uint8_t buf[4];
  unsigned __int8 *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*((_WORD *)result + 11) & 0x40) != 0)
    {
      v14 = *result;
      if (*result > 0xFF)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorValueOutOfTypeRange((_anonymous_namespace_ *)a1, a2, a6);
        return 0;
      }
LABEL_14:
      if ((a5 & 1) == 0)
        *a4 = v14;
      if ((a5 & 2) == 0)
      {
        v15 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v15 - 16);
      }
      return (unsigned int *)1;
    }
    if ((*((_WORD *)result + 11) & 0x400) == 0 || !*(_BYTE *)(a1 + 232))
      goto LABEL_36;
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v12 = (unsigned __int8 *)result;
    else
      v12 = (unsigned __int8 *)*((_QWORD *)result + 1);
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      LODWORD(v13) = 21 - *((char *)result + 21);
    else
      LODWORD(v13) = *result;
    v16 = &v12[v13];
    if ((_DWORD)v13)
    {
      v13 = v13;
      v17 = v12;
      while (*v17 == 48)
      {
        ++v17;
        if (!--v13)
          goto LABEL_32;
      }
      if (*v17 - 48 < 0xA)
      {
        v17 = std::__itoa::__traits<unsigned char>::__read[abi:nn180100](v17, v16, buf, &v19);
        if (v17 != v16 && *v17 - 48 <= 9 || *(_DWORD *)buf > 0xFFu || 255 - *(_DWORD *)buf < v19)
          goto LABEL_36;
        LOBYTE(v14) = v19 + buf[0];
LABEL_35:
        if (v16 != v17)
          goto LABEL_36;
        v18 = *re::foundationSerializationLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          v21 = v12;
          _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
        }
        goto LABEL_14;
      }
    }
    else
    {
LABEL_32:
      v17 = v16;
    }
    if (v17 == v12)
    {
LABEL_36:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    LOBYTE(v14) = 0;
    goto LABEL_35;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, char a5, uint64_t a6)
{
  unsigned int *result;
  unsigned __int8 *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  NSObject *v18;
  unsigned int v19;
  uint8_t buf[4];
  unsigned __int8 *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*((_WORD *)result + 11) & 0x40) != 0)
    {
      v14 = *result;
      if (HIWORD(*result))
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorValueOutOfTypeRange((_anonymous_namespace_ *)a1, a2, a6);
        return 0;
      }
LABEL_14:
      if ((a5 & 1) == 0)
        *a4 = v14;
      if ((a5 & 2) == 0)
      {
        v15 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v15 - 16);
      }
      return (unsigned int *)1;
    }
    if ((*((_WORD *)result + 11) & 0x400) == 0 || !*(_BYTE *)(a1 + 232))
      goto LABEL_36;
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v12 = (unsigned __int8 *)result;
    else
      v12 = (unsigned __int8 *)*((_QWORD *)result + 1);
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      LODWORD(v13) = 21 - *((char *)result + 21);
    else
      LODWORD(v13) = *result;
    v16 = &v12[v13];
    if ((_DWORD)v13)
    {
      v13 = v13;
      v17 = v12;
      while (*v17 == 48)
      {
        ++v17;
        if (!--v13)
          goto LABEL_32;
      }
      if (*v17 - 48 < 0xA)
      {
        v17 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v17, v16, buf, &v19);
        if (v17 != v16 && *v17 - 48 <= 9 || *(_WORD *)&buf[2] || 0xFFFF - *(_DWORD *)buf < v19)
          goto LABEL_36;
        LOWORD(v14) = v19 + *(_WORD *)buf;
LABEL_35:
        if (v16 != v17)
          goto LABEL_36;
        v18 = *re::foundationSerializationLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          v21 = v12;
          _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
        }
        goto LABEL_14;
      }
    }
    else
    {
LABEL_32:
      v17 = v16;
    }
    if (v17 == v12)
    {
LABEL_36:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    LOWORD(v14) = 0;
    goto LABEL_35;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(uint64_t a1, char *a2, uint64_t a3, _DWORD *a4, char a5, uint64_t a6)
{
  uint64_t result;
  unsigned __int8 *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  NSObject *v18;
  int v19;
  uint8_t buf[4];
  unsigned __int8 *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*(_WORD *)(result + 22) & 0x40) != 0)
    {
      v14 = *(_DWORD *)result;
      goto LABEL_14;
    }
    if ((*(_WORD *)(result + 22) & 0x400) == 0 || !*(_BYTE *)(a1 + 232))
      goto LABEL_35;
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      v12 = (unsigned __int8 *)result;
    else
      v12 = *(unsigned __int8 **)(result + 8);
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      LODWORD(v13) = 21 - *(char *)(result + 21);
    else
      LODWORD(v13) = *(_DWORD *)result;
    v16 = &v12[v13];
    if ((_DWORD)v13)
    {
      v13 = v13;
      v17 = v12;
      while (*v17 == 48)
      {
        ++v17;
        if (!--v13)
          goto LABEL_31;
      }
      if (*v17 - 48 < 0xA)
      {
        v17 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v17, v16, buf, &v19);
        if (v17 != v16 && *v17 - 48 <= 9 || __CFADD__(*(_DWORD *)buf, v19))
          goto LABEL_35;
        v14 = *(_DWORD *)buf + v19;
LABEL_34:
        if (v16 != v17)
          goto LABEL_35;
        v18 = *re::foundationSerializationLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          v21 = v12;
          _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
        }
LABEL_14:
        if ((a5 & 1) != 0)
        {
          if ((a5 & 2) != 0)
            return 1;
        }
        else
        {
          *a4 = v14;
          if ((a5 & 2) != 0)
            return 1;
        }
        v15 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v15 - 16);
        return 1;
      }
    }
    else
    {
LABEL_31:
      v17 = v16;
    }
    if (v17 == v12)
    {
LABEL_35:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    v14 = 0;
    goto LABEL_34;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(uint64_t a1, char *a2, uint64_t a3, _QWORD *a4, char a5, uint64_t a6)
{
  uint64_t result;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  NSObject *v18;
  uint64_t v19;
  uint8_t buf[24];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*(_WORD *)(result + 22) & 0x100) != 0)
    {
      v14 = *(_QWORD *)result;
      goto LABEL_14;
    }
    if ((*(_WORD *)(result + 22) & 0x400) == 0 || !*(_BYTE *)(a1 + 232))
      goto LABEL_35;
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      v12 = (unsigned __int8 *)result;
    else
      v12 = *(unsigned __int8 **)(result + 8);
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      LODWORD(v13) = 21 - *(char *)(result + 21);
    else
      LODWORD(v13) = *(_DWORD *)result;
    v16 = &v12[v13];
    if ((_DWORD)v13)
    {
      v13 = v13;
      v17 = v12;
      while (*v17 == 48)
      {
        ++v17;
        if (!--v13)
          goto LABEL_31;
      }
      if (*v17 - 48 < 0xA)
      {
        v17 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v17, v16, buf, &v19);
        if (v17 != v16 && *v17 - 48 <= 9 || __CFADD__(*(_QWORD *)buf, v19))
          goto LABEL_35;
        v14 = *(_QWORD *)buf + v19;
LABEL_34:
        if (v16 != v17)
          goto LABEL_35;
        v18 = *re::foundationSerializationLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v12;
          _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
        }
LABEL_14:
        if ((a5 & 1) != 0)
        {
          if ((a5 & 2) != 0)
            return 1;
        }
        else
        {
          *a4 = v14;
          if ((a5 & 2) != 0)
            return 1;
        }
        v15 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v15 - 16);
        return 1;
      }
    }
    else
    {
LABEL_31:
      v17 = v16;
    }
    if (v17 == v12)
    {
LABEL_35:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    v14 = 0;
    goto LABEL_34;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(uint64_t a1, char *a2, uint64_t a3, float *a4, char a5, uint64_t a6)
{
  uint64_t result;
  double v12;
  __int16 v13;
  float Double;
  uint64_t v15;
  const char *v16;
  unsigned int v17;
  int v18;
  re *v19;
  float v20;
  BOOL v21;
  NSObject *v22;
  _BYTE v23[24];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    v13 = *(_WORD *)(result + 22);
    if ((v13 & 0x400) == 0)
    {
      if ((v13 & 0x10) != 0)
      {
        Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble((_WORD *)result, v12);
        if ((a5 & 1) != 0)
          goto LABEL_8;
LABEL_37:
        *a4 = Double;
        if ((a5 & 2) != 0)
          return 1;
        goto LABEL_9;
      }
LABEL_39:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      v16 = (const char *)result;
    else
      v16 = *(const char **)(result + 8);
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      v17 = 21 - *(char *)(result + 21);
    else
      v17 = *(_DWORD *)result;
    if (v17 == 9)
    {
      if (strcasecmp(v16, "-Infinity"))
        goto LABEL_25;
      *(float *)&v18 = -INFINITY;
    }
    else
    {
      if (v17 != 8)
      {
        if (v17 == 3 && !strcasecmp(v16, "NaN"))
        {
          *(float *)&v18 = NAN;
          goto LABEL_41;
        }
LABEL_25:
        if (!*(_BYTE *)(a1 + 232))
          goto LABEL_39;
        *(_QWORD *)v23 = 0;
        v20 = strtof(v16, (char **)v23);
        v21 = *(const char **)v23 != &v16[v17] || v20 == INFINITY;
        Double = v21 ? INFINITY : v20;
        if (Double == INFINITY)
          goto LABEL_39;
        v22 = *re::foundationSerializationLogObjects(v19);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v23 = 136315138;
          *(_QWORD *)&v23[4] = v16;
          _os_log_impl(&dword_224FE9000, v22, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", v23, 0xCu);
          if ((a5 & 1) == 0)
            goto LABEL_37;
        }
        else if ((a5 & 1) == 0)
        {
          goto LABEL_37;
        }
LABEL_8:
        if ((a5 & 2) != 0)
          return 1;
LABEL_9:
        v15 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v15 - 16);
        return 1;
      }
      if (strcasecmp(v16, "Infinity"))
        goto LABEL_25;
      *(float *)&v18 = INFINITY;
    }
LABEL_41:
    Double = *(float *)&v18;
    if ((a5 & 1) == 0)
      goto LABEL_37;
    goto LABEL_8;
  }
  return result;
}

double rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(_WORD *a1, double a2)
{
  __int16 v2;
  uint64_t v3;

  v2 = a1[11];
  if ((v2 & 0x200) != 0)
    return *(double *)a1;
  if ((v2 & 0x20) != 0)
    return (double)*(int *)a1;
  if ((v2 & 0x40) != 0)
  {
    LODWORD(a2) = *(_DWORD *)a1;
    return (double)*(unint64_t *)&a2;
  }
  else
  {
    v3 = *(_QWORD *)a1;
    if ((v2 & 0x80) != 0)
      return (double)v3;
    else
      return (double)(unint64_t)v3;
  }
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(uint64_t a1, char *a2, uint64_t a3, double *a4, char a5, uint64_t a6)
{
  uint64_t result;
  double v12;
  __int16 v13;
  double Double;
  uint64_t v15;
  const char *v16;
  unsigned int v17;
  unint64_t v18;
  re *v19;
  float v20;
  BOOL v21;
  NSObject *v22;
  _BYTE v23[24];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    v13 = *(_WORD *)(result + 22);
    if ((v13 & 0x400) == 0)
    {
      if ((v13 & 0x10) != 0)
      {
        Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble((_WORD *)result, v12);
        if ((a5 & 1) != 0)
          goto LABEL_8;
LABEL_37:
        *a4 = Double;
        if ((a5 & 2) != 0)
          return 1;
        goto LABEL_9;
      }
LABEL_39:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      v16 = (const char *)result;
    else
      v16 = *(const char **)(result + 8);
    if ((*(_WORD *)(result + 22) & 0x1000) != 0)
      v17 = 21 - *(char *)(result + 21);
    else
      v17 = *(_DWORD *)result;
    if (v17 == 9)
    {
      if (strcasecmp(v16, "-Infinity"))
        goto LABEL_25;
      *(double *)&v18 = -INFINITY;
    }
    else
    {
      if (v17 != 8)
      {
        if (v17 == 3 && !strcasecmp(v16, "NaN"))
        {
          *(double *)&v18 = NAN;
          goto LABEL_41;
        }
LABEL_25:
        if (!*(_BYTE *)(a1 + 232))
          goto LABEL_39;
        *(_QWORD *)v23 = 0;
        v20 = strtod(v16, (char **)v23);
        v21 = *(const char **)v23 != &v16[v17] || v20 == INFINITY;
        Double = v21 ? INFINITY : v20;
        if (Double == INFINITY)
          goto LABEL_39;
        v22 = *re::foundationSerializationLogObjects(v19);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v23 = 136315138;
          *(_QWORD *)&v23[4] = v16;
          _os_log_impl(&dword_224FE9000, v22, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", v23, 0xCu);
          if ((a5 & 1) == 0)
            goto LABEL_37;
        }
        else if ((a5 & 1) == 0)
        {
          goto LABEL_37;
        }
LABEL_8:
        if ((a5 & 2) != 0)
          return 1;
LABEL_9:
        v15 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v15 - 16);
        return 1;
      }
      if (strcasecmp(v16, "Infinity"))
        goto LABEL_25;
      *(double *)&v18 = INFINITY;
    }
LABEL_41:
    Double = *(double *)&v18;
    if ((a5 & 1) == 0)
      goto LABEL_37;
    goto LABEL_8;
  }
  return result;
}

BOOL re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, void *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  unsigned int v19;
  _BOOL8 result;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  const re::StringID *v27;
  uint64_t v28;
  char v29;
  unsigned __int8 *v30;
  int v31;
  unsigned int EnumConstantIndex;
  re *v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  const void *v39;
  re::internal::TypeTranslationTable *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  _QWORD v48[2];
  unint64_t v49;
  _BYTE buf[22];
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_10;
  if (*(_QWORD *)a5 != *(_QWORD *)a6)
  {
    v14 = re::areSameTranslatedVersion(a5, a6, a3);
    goto LABEL_11;
  }
  v15 = **((_QWORD **)a5 + 2);
  v16 = **((_QWORD **)a6 + 2);
  if ((unsigned __int16)v15 == (unsigned __int16)v16
    && ((v18 = WORD1(v15) == WORD1(v16), v17 = (v16 ^ v15) & 0xFFFFFF00000000, v18) ? (v18 = v17 == 0) : (v18 = 0), v18))
  {
LABEL_10:
    v14 = 1;
  }
  else
  {
    v14 = 0;
  }
LABEL_11:
  if (!a7)
  {
    v49 = 0;
    if (!re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v49, 0))return 0;
    if (!v49)
    {
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to read enum constant. String is empty.", v21, v22, v23, v24, v25, v47);
      return 0;
    }
    if (v49 >= 0x401)
    {
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to read enum constant. String is too long. Length: %zu", v21, v22, v23, v24, v25, v49);
      return 0;
    }
    v26 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56), v49 + 1, 0);
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v26, 0);
    v26[v49] = 0;
    if (*(_BYTE *)(a1 + 64))
    {
LABEL_24:
      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v26);
      return 0;
    }
    v28 = *v26;
    if (*v26)
    {
      v29 = v26[1];
      if (v29)
      {
        v30 = (unsigned __int8 *)(v26 + 2);
        do
        {
          v28 = 31 * v28 + v29;
          v31 = *v30++;
          v29 = v31;
        }
        while (v31);
      }
    }
    *(_QWORD *)buf = 2 * v28;
    *(_QWORD *)&buf[8] = v26;
    EnumConstantIndex = re::internal::getEnumConstantIndex(a6, (const re::TypeInfo *)buf, v27);
    re::StringID::destroyString((re::StringID *)buf);
    if ((EnumConstantIndex & 0x80000000) != 0)
    {
      v37 = *re::foundationSerializationLogObjects(v33);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
      {
        v38 = re::TypeInfo::name(a6)[1];
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v26;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v38;
        _os_log_impl(&dword_224FE9000, v37, OS_LOG_TYPE_INFO, "String \"%s\" is not a valid enum constant of type \"%s\" - skipping.", buf, 0x16u);
      }
      v39 = 0;
    }
    else if (v14)
    {
      *(_QWORD *)buf = re::TypeInfo::enumConstants(a5);
      *(_QWORD *)&buf[8] = v34;
      v35 = EnumConstantIndex - v34;
      if (EnumConstantIndex >= v34)
      {
        v48[0] = re::TypeInfo::renamedEnumConstants(a5);
        v48[1] = v46;
        v36 = re::Slice<re::EnumConstant>::operator[](v48, v35);
      }
      else
      {
        v36 = re::Slice<re::EnumConstant>::operator[](buf, EnumConstantIndex);
      }
      v39 = (const void *)v36;
    }
    else
    {
      v40 = *(re::internal::TypeTranslationTable **)(*(_QWORD *)a6 + 856);
      if (!v40
        || (v39 = (const void *)re::internal::TypeTranslationTable::translateSerializedEnum(v40, a6, EnumConstantIndex, a5)) == 0)
      {
        re::TypeInfo::name(a5);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Serialized enum constant \"%s\" does not exist in runtime type \"%s\".", v41, v42, v43, v44, v45, (char)v26);
        goto LABEL_24;
      }
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v26);
    if (v39)
      memcpy(a4, v39, *(unsigned int *)(*((_QWORD *)a5 + 2) + 8));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  *(_QWORD *)buf = 0;
  v19 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)buf, 0);
  result = 0;
  if (v19)
  {
    if (*(_QWORD *)buf)
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(_anonymous_namespace_ *a1, char *a2, uint64_t a3, uint64_t *a4, int a5)
{
  unsigned int *result;
  double v10;
  unsigned int *v11;
  __int16 v12;
  double Double;
  int v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  char __str[64];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)a1 + 40))
    return 0;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
  if (result)
  {
    v11 = result;
    v12 = *((_WORD *)result + 11);
    if ((v12 & 0x400) != 0)
    {
      if ((*((_WORD *)result + 11) & 0x1000) != 0)
        LODWORD(v15) = 21 - *((char *)result + 21);
      else
        LODWORD(v15) = *result;
      v15 = v15;
    }
    else if ((v12 & 0x10) != 0
           && *((_BYTE *)a1 + 232)
           && (Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(result, v10), (v14 = snprintf(__str, 0x40uLL, "%g", Double)) != 0))
    {
      v15 = v14;
    }
    else
    {
      if (!*((_BYTE *)a1 + 233) || (v16 = *((unsigned __int16 *)v11 + 11), (v16 & 8) == 0))
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType(a1, a2, (uint64_t)"string");
        return 0;
      }
      v17 = v16 == 10;
      v15 = 4;
      if (!v17)
        v15 = 5;
    }
    *a4 = v15;
    LOBYTE(v18) = 8;
    DWORD1(v18) = a5;
    *((_QWORD *)&v18 + 1) = a2;
    v19 = 0;
    v20 = v15;
    v21 = 0;
    v22 = v11;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v18);
    return (unsigned int *)1;
  }
  return result;
}

void re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(uint64_t a1, char *a2, char a3)
{
  uint64_t v6;
  size_t v7;
  char *v8;
  unsigned int *JSONValue;
  double v10;
  unsigned int *v11;
  int v12;
  double Double;
  int v14;
  size_t v15;
  re *v16;
  NSObject *v17;
  const char *v18;
  char *v19;
  const char *v20;
  const char *v21;
  char *v22;
  const char *v23;
  uint64_t v24;
  int v25;
  char *v26;
  char __str[4];
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(a1 + 40))
  {
    v6 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    v7 = *(unsigned int *)(v6 - 24);
    v8 = *(char **)(v6 - 40);
    JSONValue = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, v8, 0);
    if (!JSONValue)
    {
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorKeyNotFound((_anonymous_namespace_ *)a1, v8);
      return;
    }
    v11 = JSONValue;
    v12 = *((unsigned __int16 *)JSONValue + 11);
    if ((v12 & 0x400) != 0)
    {
      if ((a3 & 1) == 0)
      {
        if ((v12 & 0x1000) != 0)
          v20 = (const char *)JSONValue;
        else
          v20 = (const char *)*((_QWORD *)JSONValue + 1);
        strncpy(a2, v20, v7);
      }
      goto LABEL_34;
    }
    if (*(_BYTE *)(a1 + 232))
    {
      if ((a3 & 1) == 0 && (v12 & 0x10) != 0)
      {
        Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(JSONValue, v10);
        v14 = snprintf(__str, 0x40uLL, "%g", Double);
        if (v14 >= v7)
          v15 = v7;
        else
          v15 = v14;
        v16 = (re *)memcpy(a2, __str, v15);
        v17 = *re::foundationSerializationLogObjects(v16);
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
        v25 = 136315138;
        v26 = __str;
        v18 = "Reading JSON number as string \"%s\" in Number/String Compatibility Mode";
        v19 = (char *)&v25;
        goto LABEL_31;
      }
      if ((v12 & 0x10) != 0)
        goto LABEL_34;
    }
    if (*(_BYTE *)(a1 + 233))
    {
      if ((a3 & 1) == 0 && (v12 & 8) != 0)
      {
        if (v12 == 10)
          v21 = "true";
        else
          v21 = "false";
        v22 = strncpy(a2, v21, v7);
        v17 = *re::foundationSerializationLogObjects((re *)v22);
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
        if (*((_WORD *)v11 + 11) == 10)
          v23 = "true";
        else
          v23 = "false";
        *(_DWORD *)__str = 136315138;
        v28 = v23;
        v18 = "Reading JSON BOOL as string \"%s\" in Bool/String Compatibility Mode";
        v19 = __str;
LABEL_31:
        _os_log_impl(&dword_224FE9000, v17, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)v19, 0xCu);
        goto LABEL_34;
      }
      if ((v12 & 8) != 0)
      {
LABEL_34:
        if ((a3 & 2) == 0)
        {
          v24 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
          *(_QWORD *)(v24 - 16) += v7;
        }
        return;
      }
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, v8, (uint64_t)"string");
  }
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorKeyNotFound(_anonymous_namespace_ *a1, const char *a2)
{
  _BYTE *v3;
  uint64_t result;
  uint64_t v5;
  char v6;
  _BYTE v7[23];
  _OWORD v8[2];

  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v5);
  if ((v6 & 1) != 0)
    v3 = *(_BYTE **)&v7[7];
  else
    v3 = v7;
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Key not found.", (re::DynamicString *)v8, v3);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v8);
  if (*(_QWORD *)&v8[0])
  {
    if ((BYTE8(v8[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v8[0] + 40))();
    memset(v8, 0, sizeof(v8));
  }
  result = v5;
  if (v5)
  {
    if ((v6 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
  }
  return result;
}

double re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(_anonymous_namespace_ *a1, char *a2, uint64_t a3, _BYTE *a4, int a5)
{
  unsigned int *JSONValue;
  _BOOL4 v10;
  double result;
  __int128 v12;
  uint64_t v13;
  _BOOL8 v14;
  uint64_t v15;
  unsigned int *v16;

  if (!*((_BYTE *)a1 + 40))
  {
    JSONValue = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
    if (JSONValue)
      v10 = *((_WORD *)JSONValue + 11) != 0;
    else
      v10 = 0;
    *a4 = v10;
    LOBYTE(v12) = 3;
    DWORD1(v12) = a5;
    *((_QWORD *)&v12 + 1) = a2;
    v13 = 0;
    v14 = v10;
    v15 = 0;
    v16 = JSONValue;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v12);
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(_anonymous_namespace_ *a1, char *a2, uint64_t a3, _QWORD *a4, int a5)
{
  unsigned int *result;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;

  if (*((_BYTE *)a1 + 40))
    return 0;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
  if (result)
  {
    if (*((_WORD *)result + 11) == 4)
    {
      v10 = *result;
      *a4 = v10;
      LOBYTE(v11) = 5;
      DWORD1(v11) = a5;
      *((_QWORD *)&v11 + 1) = a2;
      v12 = 0;
      v13 = v10;
      v14 = 0;
      v15 = result;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v11);
      return (unsigned int *)1;
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType(a1, a2, (uint64_t)"array");
    return 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v21)(uint64_t, uint64_t *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  _BOOL8 result;
  unsigned int *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _BYTE v46[16];
  uint64_t v47;
  _BYTE v48[32];
  _BYTE v49[32];
  uint64_t v50;
  uint64_t v51;
  _BYTE v52[40];

  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v51),
        re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52),
        v49[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v49))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v52);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v49);
  if (!v19)
  {
    v44 = re::TypeInfo::name((re::TypeInfo *)v49)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v39, v40, v41, v42, v43, v44);
    return 0;
  }
  v20 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v19;
  v21 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v47 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v51, (uint64_t)v46);
  v21(a4, &v51, v18);
  v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  result = 0;
  if (v27)
  {
    v29 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      v30 = *((_QWORD *)v29 + 1);
      while (1)
      {
        if ((*(_WORD *)(v30 + 22) & 0x1000) != 0)
          v31 = v30;
        else
          v31 = *(_QWORD *)(v30 + 8);
        if ((*(_WORD *)(v30 + 22) & 0x1000) != 0)
          v32 = 21 - *(char *)(v30 + 21);
        else
          v32 = *(_DWORD *)v30;
        v45 = 0;
        if (!v32)
          goto LABEL_42;
        v33 = 0;
        v34 = (unsigned __int8 *)(v31 + v32);
        while (*(_BYTE *)(v31 + v33) == 48)
        {
          if (v32 == ++v33)
            goto LABEL_42;
        }
        if (v32 == v33)
          goto LABEL_42;
        v35 = (unsigned __int8 *)(v31 + v33);
        if (*(unsigned __int8 *)(v31 + v33) - 48 > 9)
          goto LABEL_41;
        v35 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v35, v34, &v51, &v50);
        if (v35 == v34)
          break;
        if (*v35 - 48 > 9)
        {
          v37 = v50;
          v36 = v51;
          if (!__CFADD__(v51, v50))
            goto LABEL_40;
        }
        while (*v35 - 48 <= 9)
        {
          if (++v35 == v34)
          {
            v35 = v34;
            break;
          }
        }
LABEL_41:
        if (v34 != v35)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, v31);
          return 0;
        }
LABEL_42:
        v38 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, uint64_t *))(v47 + 104))(a4, v46, *(_QWORD *)(a1 + 48), &v45);
        v20(a1, v31, 0, v38, v49, v48, 0);
        v30 += 48;
        if (v30 == *((_QWORD *)v29 + 1) + 48 * *v29)
          goto LABEL_43;
      }
      v37 = v50;
      v36 = v51;
      if (__CFADD__(v51, v50))
        goto LABEL_42;
LABEL_40:
      v45 = v36 + v37;
      goto LABEL_41;
    }
LABEL_43:
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v21)(uint64_t, int *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  _BOOL8 result;
  unsigned int *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  _BYTE v46[16];
  uint64_t v47;
  _BYTE v48[32];
  _BYTE v49[36];
  int v50;
  int v51;
  _BYTE v52[40];

  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v51),
        re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52),
        v49[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v49))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v52);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v49);
  if (!v19)
  {
    v44 = re::TypeInfo::name((re::TypeInfo *)v49)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v39, v40, v41, v42, v43, v44);
    return 0;
  }
  v20 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v19;
  v21 = *(void (**)(uint64_t, int *, uint64_t))(v47 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v51, (uint64_t)v46);
  v21(a4, &v51, v18);
  v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  result = 0;
  if (v27)
  {
    v29 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      v30 = *((_QWORD *)v29 + 1);
      while (1)
      {
        if ((*(_WORD *)(v30 + 22) & 0x1000) != 0)
          v31 = v30;
        else
          v31 = *(_QWORD *)(v30 + 8);
        if ((*(_WORD *)(v30 + 22) & 0x1000) != 0)
          v32 = 21 - *(char *)(v30 + 21);
        else
          v32 = *(_DWORD *)v30;
        v45 = 0;
        if (!v32)
          goto LABEL_42;
        v33 = 0;
        v34 = (unsigned __int8 *)(v31 + v32);
        while (*(_BYTE *)(v31 + v33) == 48)
        {
          if (v32 == ++v33)
            goto LABEL_42;
        }
        if (v32 == v33)
          goto LABEL_42;
        v35 = (unsigned __int8 *)(v31 + v33);
        if (*(unsigned __int8 *)(v31 + v33) - 48 > 9)
          goto LABEL_41;
        v35 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v35, v34, &v51, &v50);
        if (v35 == v34)
          break;
        if (*v35 - 48 > 9)
        {
          v37 = v50;
          v36 = v51;
          if (!__CFADD__(v51, v50))
            goto LABEL_40;
        }
        while (*v35 - 48 <= 9)
        {
          if (++v35 == v34)
          {
            v35 = v34;
            break;
          }
        }
LABEL_41:
        if (v34 != v35)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, v31);
          return 0;
        }
LABEL_42:
        v38 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, int *))(v47 + 104))(a4, v46, *(_QWORD *)(a1 + 48), &v45);
        v20(a1, v31, 0, v38, v49, v48, 0);
        v30 += 48;
        if (v30 == *((_QWORD *)v29 + 1) + 48 * *v29)
          goto LABEL_43;
      }
      v37 = v50;
      v36 = v51;
      if (__CFADD__(v51, v50))
        goto LABEL_42;
LABEL_40:
      v45 = v36 + v37;
      goto LABEL_41;
    }
LABEL_43:
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v21)(uint64_t, unsigned int *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  _BOOL8 result;
  unsigned int *v29;
  uint64_t i;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int16 v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[36];
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[40];

  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v49),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v50),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v50);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v50);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (!v19)
  {
    v42 = re::TypeInfo::name((re::TypeInfo *)v47)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v37, v38, v39, v40, v41, v42);
    return 0;
  }
  v20 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v19;
  v21 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v45 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v49, (uint64_t)v44);
  v21(a4, &v49, v18);
  v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  result = 0;
  if (v27)
  {
    v29 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      for (i = *((_QWORD *)v29 + 1); i != *((_QWORD *)v29 + 1) + 48 * *v29; i += 48)
      {
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v31 = i;
        else
          v31 = *(_QWORD *)(i + 8);
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v32 = 21 - *(char *)(i + 21);
        else
          v32 = *(_DWORD *)i;
        v43 = 0;
        if (!v32)
          goto LABEL_42;
        v33 = 0;
        v34 = (unsigned __int8 *)(v31 + v32);
        while (*(_BYTE *)(v31 + v33) == 48)
        {
          if (v32 == ++v33)
            goto LABEL_42;
        }
        if (v32 == v33)
          goto LABEL_42;
        v35 = (unsigned __int8 *)(v31 + v33);
        if (*(unsigned __int8 *)(v31 + v33) - 48 <= 9)
        {
          v35 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v35, v34, &v49, &v48);
          if (v35 == v34 || *v35 - 48 > 9)
          {
            if (HIWORD(v49) || 0xFFFF - v49 < v48)
            {
              if (v35 != v34)
                goto LABEL_37;
              goto LABEL_42;
            }
            v43 = v48 + v49;
          }
          else
          {
LABEL_37:
            while (*v35 - 48 <= 9)
            {
              if (++v35 == v34)
              {
                v35 = v34;
                break;
              }
            }
          }
        }
        if (v34 != v35)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, v31);
          return 0;
        }
LABEL_42:
        v36 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, __int16 *))(v45 + 104))(a4, v44, *(_QWORD *)(a1 + 48), &v43);
        v20(a1, v31, 0, v36, v47, v46, 0);
      }
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v21)(uint64_t, unsigned int *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  _BOOL8 result;
  unsigned int *v29;
  uint64_t i;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[36];
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[40];

  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v49),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v50),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v50);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v50);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (!v19)
  {
    v42 = re::TypeInfo::name((re::TypeInfo *)v47)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v37, v38, v39, v40, v41, v42);
    return 0;
  }
  v20 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v19;
  v21 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v45 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v49, (uint64_t)v44);
  v21(a4, &v49, v18);
  v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  result = 0;
  if (v27)
  {
    v29 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      for (i = *((_QWORD *)v29 + 1); i != *((_QWORD *)v29 + 1) + 48 * *v29; i += 48)
      {
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v31 = i;
        else
          v31 = *(_QWORD *)(i + 8);
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v32 = 21 - *(char *)(i + 21);
        else
          v32 = *(_DWORD *)i;
        v43 = 0;
        if (!v32)
          goto LABEL_42;
        v33 = 0;
        v34 = (unsigned __int8 *)(v31 + v32);
        while (*(_BYTE *)(v31 + v33) == 48)
        {
          if (v32 == ++v33)
            goto LABEL_42;
        }
        if (v32 == v33)
          goto LABEL_42;
        v35 = (unsigned __int8 *)(v31 + v33);
        if (*(unsigned __int8 *)(v31 + v33) - 48 <= 9)
        {
          v35 = std::__itoa::__traits<unsigned char>::__read[abi:nn180100](v35, v34, &v49, &v48);
          if (v35 == v34 || *v35 - 48 > 9)
          {
            if (v49 > 0xFF || 255 - v49 < v48)
            {
              if (v35 != v34)
                goto LABEL_37;
              goto LABEL_42;
            }
            v43 = v48 + v49;
          }
          else
          {
LABEL_37:
            while (*v35 - 48 <= 9)
            {
              if (++v35 == v34)
              {
                v35 = v34;
                break;
              }
            }
          }
        }
        if (v34 != v35)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, v31);
          return 0;
        }
LABEL_42:
        v36 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, char *))(v45 + 104))(a4, v44, *(_QWORD *)(a1 + 48), &v43);
        v20(a1, v31, 0, v36, v47, v46, 0);
      }
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v21)(uint64_t, uint64_t *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  _BOOL8 result;
  unsigned int *v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unsigned __int8 *v35;
  char v36;
  unsigned __int8 *v37;
  uint64_t v38;
  unsigned __int8 *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  _BYTE v51[16];
  uint64_t v52;
  _BYTE v53[32];
  _BYTE v54[32];
  uint64_t v55;
  uint64_t v56;
  _BYTE v57[40];

  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v56),
        re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v57),
        v54[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v54))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v57);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v57);
  re::TypeInfo::TypeInfo((uint64_t)v51, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v54);
  if (!v19)
  {
    v49 = re::TypeInfo::name((re::TypeInfo *)v54)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v44, v45, v46, v47, v48, v49);
    return 0;
  }
  v20 = (void (*)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v19;
  v21 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v52 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v56, (uint64_t)v51);
  v21(a4, &v56, v18);
  v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  result = 0;
  if (v27)
  {
    v29 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      v30 = *((_QWORD *)v29 + 1);
      while (1)
      {
        v31 = (*(_WORD *)(v30 + 22) & 0x1000) != 0 ? (unsigned __int8 *)v30 : *(unsigned __int8 **)(v30 + 8);
        v32 = (*(_WORD *)(v30 + 22) & 0x1000) != 0 ? 21 - *(char *)(v30 + 21) : *(_DWORD *)v30;
        v50 = 0;
        v33 = v32 && *v31 == 45;
        v34 = v32;
        v35 = &v31[v32];
        v36 = v33;
        v37 = &v31[v33];
        if (v34 == v33)
          break;
        v38 = v34 - v33;
        v39 = v37;
        while (*v39 == 48)
        {
          ++v39;
          if (!--v38)
            goto LABEL_42;
        }
        if (!v38)
          break;
        if (*v39 - 48 >= 0xA)
          goto LABEL_43;
        v39 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v39, v35, &v56, &v55);
        if (v39 == v35)
        {
          v41 = v55;
          v40 = v56;
          if (__CFADD__(v56, v55))
          {
LABEL_53:
            v39 = v35;
            goto LABEL_48;
          }
        }
        else if (*v39 - 48 <= 9 || (v41 = v55, v40 = v56, __CFADD__(v56, v55)))
        {
          while (*v39 - 48 <= 9)
          {
            if (++v39 == v35)
              goto LABEL_53;
          }
          goto LABEL_48;
        }
        v42 = v40 + v41;
        if ((v36 & 1) != 0)
        {
          if (v42 <= 0x8000000000000000)
            goto LABEL_45;
        }
        else if ((v42 & 0x8000000000000000) == 0)
        {
          goto LABEL_46;
        }
LABEL_48:
        if (v35 != v39)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, (char)v31);
          return 0;
        }
        v43 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, unint64_t *))(v52 + 104))(a4, v51, *(_QWORD *)(a1 + 48), &v50);
        v20(a1, v31, 0, v43, v54, v53, 0);
        v30 += 48;
        if (v30 == *((_QWORD *)v29 + 1) + 48 * *v29)
          goto LABEL_62;
      }
LABEL_42:
      v39 = v35;
LABEL_43:
      if (v39 != v37)
      {
        v42 = 0;
        if ((v36 & 1) != 0)
LABEL_45:
          v42 = -(uint64_t)v42;
LABEL_46:
        v50 = v42;
        goto LABEL_48;
      }
      v39 = v31;
      goto LABEL_48;
    }
LABEL_62:
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v21)(uint64_t, int *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  _BOOL8 result;
  unsigned int *v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unsigned __int8 *v35;
  char v36;
  unsigned __int8 *v37;
  uint64_t v38;
  unsigned __int8 *v39;
  int v40;
  int v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  _BYTE v51[16];
  uint64_t v52;
  _BYTE v53[32];
  _BYTE v54[36];
  int v55;
  int v56;
  _BYTE v57[40];

  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v56),
        re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v57),
        v54[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v54))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v57);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v57);
  re::TypeInfo::TypeInfo((uint64_t)v51, (uint64_t)a5);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v54);
  if (!v19)
  {
    v49 = re::TypeInfo::name((re::TypeInfo *)v54)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v44, v45, v46, v47, v48, v49);
    return 0;
  }
  v20 = (void (*)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v19;
  v21 = *(void (**)(uint64_t, int *, uint64_t))(v52 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v56, (uint64_t)v51);
  v21(a4, &v56, v18);
  v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  result = 0;
  if (v27)
  {
    v29 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      v30 = *((_QWORD *)v29 + 1);
      while (1)
      {
        v31 = (*(_WORD *)(v30 + 22) & 0x1000) != 0 ? (unsigned __int8 *)v30 : *(unsigned __int8 **)(v30 + 8);
        v32 = (*(_WORD *)(v30 + 22) & 0x1000) != 0 ? 21 - *(char *)(v30 + 21) : *(_DWORD *)v30;
        v50 = 0;
        v33 = v32 && *v31 == 45;
        v34 = v32;
        v35 = &v31[v32];
        v36 = v33;
        v37 = &v31[v33];
        if (v34 == v33)
          break;
        v38 = v34 - v33;
        v39 = v37;
        while (*v39 == 48)
        {
          ++v39;
          if (!--v38)
            goto LABEL_42;
        }
        if (!v38)
          break;
        if (*v39 - 48 >= 0xA)
          goto LABEL_43;
        v39 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v39, v35, &v56, &v55);
        if (v39 == v35)
        {
          v41 = v55;
          v40 = v56;
          if (__CFADD__(v56, v55))
          {
LABEL_53:
            v39 = v35;
            goto LABEL_48;
          }
        }
        else if (*v39 - 48 <= 9 || (v41 = v55, v40 = v56, __CFADD__(v56, v55)))
        {
          while (*v39 - 48 <= 9)
          {
            if (++v39 == v35)
              goto LABEL_53;
          }
          goto LABEL_48;
        }
        v42 = v40 + v41;
        if ((v36 & 1) != 0)
        {
          if (v42 <= 0x80000000)
            goto LABEL_45;
        }
        else if ((v42 & 0x80000000) == 0)
        {
          goto LABEL_46;
        }
LABEL_48:
        if (v35 != v39)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, (char)v31);
          return 0;
        }
        v43 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, unsigned int *))(v52 + 104))(a4, v51, *(_QWORD *)(a1 + 48), &v50);
        v20(a1, v31, 0, v43, v54, v53, 0);
        v30 += 48;
        if (v30 == *((_QWORD *)v29 + 1) + 48 * *v29)
          goto LABEL_62;
      }
LABEL_42:
      v39 = v35;
LABEL_43:
      if (v39 != v37)
      {
        v42 = 0;
        if ((v36 & 1) != 0)
LABEL_45:
          v42 = -v42;
LABEL_46:
        v50 = v42;
        goto LABEL_48;
      }
      v39 = v31;
      goto LABEL_48;
    }
LABEL_62:
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  _BOOL8 result;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v22)(uint64_t, unsigned int *, uint64_t);
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int *v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unsigned __int8 *v35;
  char v36;
  unsigned __int8 *v37;
  uint64_t v38;
  unsigned __int8 *v39;
  __int16 v40;
  __int16 v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  __int16 v49;
  _BYTE v50[16];
  uint64_t v51;
  _BYTE v52[32];
  _BYTE v53[36];
  unsigned int v54;
  unsigned int v55;
  _BYTE v56[40];

  if (a5 == a6)
    goto LABEL_13;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v55),
        re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56),
        v53[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v53))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v19 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
  re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)a5);
  v20 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
  if (!v20)
  {
    v48 = re::TypeInfo::name((re::TypeInfo *)v53)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v43, v44, v45, v46, v47, v48);
    return 0;
  }
  v21 = (void (*)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v20;
  v22 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v51 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v55, (uint64_t)v50);
  v22(a4, &v55, v19);
  v28 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  result = 0;
  if (v28)
  {
    v29 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (!v29 || !*v29)
    {
LABEL_62:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(_BYTE *)(a1 + 64) == 0;
    }
    v30 = (unsigned __int8 *)*((_QWORD *)v29 + 1);
    while (1)
    {
      if ((*((_WORD *)v30 + 11) & 0x1000) != 0)
        v31 = v30;
      else
        v31 = (unsigned __int8 *)*((_QWORD *)v30 + 1);
      if ((*((_WORD *)v30 + 11) & 0x1000) != 0)
        v32 = 21 - (char)v30[21];
      else
        v32 = *(_DWORD *)v30;
      v49 = 0;
      if (v32)
        v33 = *v31 == 45;
      else
        v33 = 0;
      v34 = v32;
      v35 = &v31[v32];
      v36 = v33;
      v37 = &v31[v33];
      if (v34 == v33)
        goto LABEL_44;
      v38 = v34 - v33;
      v39 = v37;
      while (*v39 == 48)
      {
        ++v39;
        if (!--v38)
          goto LABEL_44;
      }
      if (!v38)
      {
LABEL_44:
        v39 = v35;
LABEL_45:
        if (v39 == v37)
        {
          v39 = v31;
          goto LABEL_52;
        }
        v40 = 0;
        v41 = 0;
        if ((v36 & 1) != 0)
        {
LABEL_47:
          v49 = -v40;
          goto LABEL_52;
        }
LABEL_51:
        v49 = v41;
        goto LABEL_52;
      }
      if (*v39 - 48 >= 0xA)
        goto LABEL_45;
      v39 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v39, v35, &v55, &v54);
      if (v39 != v35 && *v39 - 48 <= 9)
        goto LABEL_56;
      if (HIWORD(v55) || 0xFFFF - v55 < v54)
        break;
      v40 = v54 + v55;
      if ((v36 & 1) == 0)
      {
        if ((((_WORD)v54 + (_WORD)v55) & 0x8000) != 0)
          goto LABEL_52;
        v41 = v54 + v55;
        goto LABEL_51;
      }
      if ((unsigned __int16)(v54 + v55) <= 0x8000u)
        goto LABEL_47;
LABEL_52:
      if (v35 != v39)
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v23, v24, v25, v26, v27, (char)v31);
        return 0;
      }
      v42 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, __int16 *))(v51 + 104))(a4, v50, *(_QWORD *)(a1 + 48), &v49);
      v21(a1, v31, 0, v42, v53, v52, 0);
      v30 += 48;
      if (v30 == (unsigned __int8 *)(*((_QWORD *)v29 + 1) + 48 * *v29))
        goto LABEL_62;
    }
    while (1)
    {
      if (v39 == v35)
      {
        v39 = v35;
        goto LABEL_52;
      }
LABEL_56:
      if (*v39 - 48 > 9)
        goto LABEL_52;
      ++v39;
    }
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, re *a6, int a7)
{
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  unsigned int v26;
  _BOOL8 result;
  void (*v28)(uint64_t, const char **, uint64_t);
  re::DynamicString *v29;
  unsigned int *v30;
  uint64_t v31;
  const char *v32;
  size_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _BYTE v41[16];
  uint64_t v42;
  _BYTE v43[32];
  _BYTE v44[32];
  const char *v45;
  _QWORD v46[5];

  if (a5 == a6)
    goto LABEL_14;
  v14 = *(_QWORD **)a5;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v16 = **((_QWORD **)a5 + 2);
    v15 = (uint64_t *)*((_QWORD *)a6 + 2);
    v17 = *v15;
    if ((unsigned __int16)v16 != (unsigned __int16)*v15)
      goto LABEL_10;
    v19 = WORD1(v16) == WORD1(v17);
    v18 = (v17 ^ v16) & 0xFFFFFF00000000;
    v19 = v19 && v18 == 0;
    if (!v19)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v23 = *(_QWORD *)(a1 + 48);
      v22 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v45);
      re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)v46);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v45);
      re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)v46);
      re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)a5);
      v24 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v44);
      if (!v24)
      {
        v35 = re::TypeInfo::name((re::TypeInfo *)v44);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v36, v37, v38, v39, v40, v35[1]);
        return 0;
      }
      v25 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v24;
      v26 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
      result = 0;
      if (!v26)
        return result;
      v28 = *(void (**)(uint64_t, const char **, uint64_t))(v42 + 96);
      re::TypeInfo::TypeInfo((uint64_t)&v45, (uint64_t)v41);
      v28(a4, &v45, v23);
      v29 = (re::DynamicString *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22 + 32))(v22, 32, 8);
      *((_QWORD *)v29 + 1) = 0;
      *((_QWORD *)v29 + 2) = 0;
      *((_QWORD *)v29 + 3) = 0;
      *(_QWORD *)v29 = v23;
      re::DynamicString::setCapacity(v29, 0);
      v30 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
      if (v30 && *v30)
      {
        v31 = *((_QWORD *)v30 + 1);
        do
        {
          if ((*(_WORD *)(v31 + 22) & 0x1000) != 0)
            v32 = (const char *)v31;
          else
            v32 = *(const char **)(v31 + 8);
          v33 = strlen(v32);
          v45 = v32;
          v46[0] = v33;
          re::DynamicString::operator=(v29, (uint64_t)&v45);
          v34 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, re::DynamicString *))(v42 + 104))(a4, v41, *(_QWORD *)(a1 + 48), v29);
          v25(a1, v32, 0, v34, v44, v43, 0);
          v31 += 48;
        }
        while (v31 != *((_QWORD *)v30 + 1) + 48 * *v30);
      }
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      if (*(_QWORD *)v29)
      {
        if ((*((_BYTE *)v29 + 8) & 1) != 0)
          (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v29 + 40))(*(_QWORD *)v29, *((_QWORD *)v29 + 2));
        *(_OWORD *)v29 = 0u;
        *((_OWORD *)v29 + 1) = 0u;
      }
      (*(void (**)(uint64_t, re::DynamicString *))(*(_QWORD *)v22 + 40))(v22, v29);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_14;
  v14 = *(_QWORD **)a6;
  v15 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v14, v15[9], &v45);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)v46);
  v20 = re::TypeInfo::name((re::TypeInfo *)v44);
  if ((unint64_t)*v20 >> 1 == 0x22C6ED80D0CLL)
  {
    v21 = (char *)v20[1];
    if (v21 == "StringID" || !strcmp(v21, "StringID"))
      goto LABEL_14;
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, re *a6, int a7)
{
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t (*v24)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  unsigned int v25;
  _BOOL8 result;
  uint64_t (*v27)(uint64_t, unint64_t *, uint64_t);
  _anonymous_namespace_ *v28;
  unsigned int *v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  void *v33;
  char v34;
  void *v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  void *v46;
  _BYTE v47[16];
  uint64_t v48;
  _BYTE v49[32];
  _BYTE v50[32];
  unint64_t v51;
  _QWORD v52[5];

  if (a5 == a6)
    goto LABEL_14;
  v14 = *(_QWORD **)a5;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v16 = **((_QWORD **)a5 + 2);
    v15 = (uint64_t *)*((_QWORD *)a6 + 2);
    v17 = *v15;
    if ((unsigned __int16)v16 != (unsigned __int16)*v15)
      goto LABEL_10;
    v19 = WORD1(v16) == WORD1(v17);
    v18 = (v17 ^ v16) & 0xFFFFFF00000000;
    v19 = v19 && v18 == 0;
    if (!v19)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v22 = *(_QWORD *)(a1 + 48);
      re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v51);
      re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)v52);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v51);
      re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)a5);
      v23 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v50);
      if (!v23)
      {
        v37 = re::TypeInfo::name((re::TypeInfo *)v50);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v38, v39, v40, v41, v42, v37[1]);
        return 0;
      }
      v24 = (uint64_t (*)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v23;
      v25 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
      result = 0;
      if (!v25)
        return result;
      v27 = *(uint64_t (**)(uint64_t, unint64_t *, uint64_t))(v48 + 96);
      re::TypeInfo::TypeInfo((uint64_t)&v51, (uint64_t)v47);
      v28 = (_anonymous_namespace_ *)v27(a4, &v51, v22);
      v45 = 0;
      v46 = &str_110;
      v29 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
      if (v29 && *v29)
      {
        v30 = *((_QWORD *)v29 + 1);
        do
        {
          if ((*(_WORD *)(v30 + 22) & 0x1000) != 0)
            v31 = (const char *)v30;
          else
            v31 = *(const char **)(v30 + 8);
          v43 = 0;
          v44 = &str_110;
          v32 = v43;
          v33 = v44;
          v43 = 0;
          v44 = &str_110;
          v34 = v45;
          v35 = v46;
          v45 = v32;
          v46 = v33;
          v51 = v32 & 0xFFFFFFFFFFFFFFFELL | v34 & 1;
          v52[0] = v35;
          re::StringID::destroyString((re::StringID *)&v51);
          re::StringID::destroyString((re::StringID *)&v43);
          v36 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, uint64_t *))(v48 + 104))(a4, v47, *(_QWORD *)(a1 + 48), &v45);
          v28 = (_anonymous_namespace_ *)v24(a1, v31, 0, v36, v50, v49, 0);
          v30 += 48;
        }
        while (v30 != *((_QWORD *)v29 + 1) + 48 * *v29);
      }
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      re::StringID::destroyString((re::StringID *)&v45);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_14;
  v14 = *(_QWORD **)a6;
  v15 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v14, v15[9], &v51);
  re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)v52);
  v20 = re::TypeInfo::name((re::TypeInfo *)v50);
  if ((unint64_t)*v20 >> 1 == 0x134375A94D9F7110)
  {
    v21 = (char *)v20[1];
    if (v21 == "DynamicString" || !strcmp(v21, "DynamicString"))
      goto LABEL_14;
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(_anonymous_namespace_ *a1, char *a2, uint64_t a3, _QWORD *a4, int a5)
{
  unsigned int *result;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;

  if (*((_BYTE *)a1 + 40))
    return 0;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
  if (result)
  {
    if (*((_WORD *)result + 11) == 4)
    {
      v10 = *result;
      *a4 = v10;
      LOBYTE(v11) = 6;
      DWORD1(v11) = a5;
      *((_QWORD *)&v11 + 1) = a2;
      v12 = 0;
      v13 = v10;
      v14 = 0;
      v15 = result;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v11);
      return (unsigned int *)1;
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType(a1, a2, (uint64_t)"dictionary");
    return 0;
  }
  return result;
}

void re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  _OWORD v8[2];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  _BYTE v13[23];
  _OWORD v14[2];

  if (*(_BYTE *)(a1 + 40))
    return;
  v3 = *(_QWORD *)(a1 + 128);
  v4 = *(_QWORD *)(a1 + 112) - 1;
  v5 = *(_QWORD *)(v3 + 48 * v4 + 40);
  if (!v5)
  {
LABEL_6:
    if (*(_WORD *)(v5 + 22) == 3)
    {
      LOBYTE(v8[0]) = 7;
      DWORD1(v8[0]) = a2;
      *((_QWORD *)&v8[0] + 1) = "entry";
      v8[1] = xmmword_2260F4F20;
      v9 = 0;
      v10 = v5;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, v8);
    }
    else
    {
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, "entry", (uint64_t)"object");
    }
    return;
  }
  v6 = *(_QWORD *)(v3 + 48 * v4 + 32);
  if (*(_DWORD *)v5 > v6)
  {
    v5 = *(_QWORD *)(v5 + 8) + 24 * v6;
    goto LABEL_6;
  }
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)a1, "entry", (re::DynamicString *)&v11);
  if ((v12 & 1) != 0)
    v7 = *(_BYTE **)&v13[7];
  else
    v7 = v13;
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Index out of range.", (re::DynamicString *)v14, v7);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1, (uint64_t)v14);
  if (*(_QWORD *)&v14[0])
  {
    if ((BYTE8(v14[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v14[0] + 40))();
    memset(v14, 0, sizeof(v14));
  }
  if (v11 && (v12 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v11 + 40))();
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(_anonymous_namespace_ *a1, char *a2, uint64_t a3, int a4)
{
  unsigned int *result;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;

  if (*((_BYTE *)a1 + 40))
    return 0;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
  if (result)
  {
    if (*((_WORD *)result + 11) == 3)
    {
      LOBYTE(v8) = 2;
      DWORD1(v8) = a4;
      *((_QWORD *)&v8 + 1) = a2;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = result;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v8);
      return (unsigned int *)1;
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType(a1, a2, (uint64_t)"object");
    return 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 2);
    v2 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
    ++*(_QWORD *)(v2 - 16);
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _QWORD *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  unsigned int v20;
  _BOOL8 result;
  _anonymous_namespace_ *v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  unint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  char *v34;
  unint64_t v35;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v35 = 0;
    v20 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v35, 0);
    result = 0;
    if (!v20)
      return result;
    if (v35)
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  v23 = a4[1];
  if ((v23 & 1) != 0)
    v24 = v23 >> 1;
  else
    v24 = v23 >> 1;
  v35 = v24;
  v25 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v35, 0);
  result = 0;
  if (v25)
  {
    v26 = v35;
    if (v26 <= (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
    {
      if (!*a4)
      {
        v33 = v35 + 1;
        *a4 = *(_QWORD *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v33);
      }
      re::DynamicString::resize(a4, v35, 0);
      if (v35)
      {
        if ((a4[1] & 1) != 0)
          v34 = (char *)a4[2];
        else
          v34 = (char *)a4 + 9;
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v34, 0);
      }
      v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString(v22);
      return *(_BYTE *)(a1 + 64) == 0;
    }
    v27 = v35;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v28, v29, v30, v31, v32, v27);
    return 0;
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  const re::TypeInfo *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  uint64_t v29;
  uint64_t v30;
  re *v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  NSObject *v35;
  uint64_t v36;
  re::internal *v37;
  uint64_t v38;
  _BYTE v39[32];
  _BYTE v40[32];
  _QWORD *v41[2];
  uint64_t v42;
  _QWORD *v43[2];
  uint64_t v44;
  uint64_t v45[4];
  unint64_t v46;
  uint64_t v47[5];
  _BYTE v48[8];
  uint64_t v49;
  char v50;
  uint64_t *v51;
  _BYTE v52[8];
  uint64_t v53;
  char v54;
  uint64_t *v55;
  uint8_t buf[4];
  uint64_t v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v52);
  re::TypeRegistry::typeInfo((_QWORD *)*a4, *(_QWORD *)(a4[2] + 72), v48);
  if (v48[0])
  {
    if (!v52[0])
    {
      v11 = re::TypeInfo::name((re::TypeInfo *)&v49)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (v53 == v49)
    {
      v18 = *v55;
      v19 = *v51;
      if ((unsigned __int16)*v55 == (unsigned __int16)*v51)
      {
        v21 = WORD1(v18) == WORD1(v19);
        v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        v21 = v21 && v20 == 0;
        if (v21)
          goto LABEL_5;
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v53, (const re::TypeInfo *)&v49, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, a2, &v53, a5);
      goto LABEL_15;
    }
    if (v54 == v50)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, &v53, &v49, a5);
    }
    else
    {
      v22 = re::TypeInfo::name((re::TypeInfo *)&v53)[1];
      re::TypeInfo::name((re::TypeInfo *)&v49);
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v47, *a3, a3[2]);
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v45, *a4, a4[2]);
  if (v46)
  {
    for (i = 0; i < v46; ++i)
    {
      if (*(_BYTE *)(a1 + 64))
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[](v45, i, (uint64_t)v43);
      if (*(_BYTE *)(v44 + 28))
      {
        v29 = *(_QWORD *)(v44 + 16);
        if (strlen((const char *)v29) >= 3 && *(_BYTE *)v29 == 109)
          v29 += 2 * (*(_BYTE *)(v29 + 1) == 95);
        v30 = *(unsigned int *)(v44 + 32);
        v31 = *(re **)(*a4 + 856);
        if (!v31
          || (v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v43),
              (_DWORD)v31 == -1))
        {
          v35 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            v36 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            v57 = v36;
            v58 = 2080;
            v59 = v29;
            _os_log_impl(&dword_224FE9000, v35, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          v37 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v57 + 4);
          result = re::internal::translateType(v37, (const re::TypeRegistry *)v41, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint8_t *, uint8_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
        }
        else
        {
          re::TypeMemberCollection::operator[](v47, (int)v31, (uint64_t)v41);
          v32 = a2 + *(unsigned int *)(v42 + 24);
          re::TypeRegistry::typeInfo(v41[0], *(_QWORD *)v42, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
          re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
          if (*(_BYTE *)(a1 + 64)
            || (result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, v32, v40, v39, a5), (result & 1) == 0))
          {
            result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a4);
            if (v33)
            {
              v34 = (_DWORD *)(result + 16);
              while (i != *v34)
              {
                v34 += 6;
                if (!--v33)
                  goto LABEL_35;
              }
              v38 = *((_QWORD *)v34 - 1);
              re::TypeRegistry::typeInfo(v41[0], *(_QWORD *)v42, buf);
              re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
              re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
              result = re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
              if (!*(_BYTE *)(a1 + 64))
                result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v38, v30, v32, v40, v39, a5);
            }
          }
        }
      }
LABEL_35:
      ;
    }
  }
  return result;
}

uint64_t re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::open(_QWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8;
  double v9;

  v8 = a1[24];
  if (*(_DWORD *)(v8 + 24) != *((_DWORD *)a1 + 50))
  {
    (*(void (**)(_QWORD *))(*a1 + 40))(a1);
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
    a1[24] = v8;
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
    re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFuncs(a1);
    (*(void (**)(_QWORD *))(*a1 + 32))(a1);
    *((_DWORD *)a1 + 50) = *(_DWORD *)(a1[24] + 24);
  }
  v9 = re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::open((uint64_t)(a1 + 3), a2, 0, 0xFFFFFFFFLL, a3, a4);
  return (*(uint64_t (**)(_QWORD *, double))(*a1 + 48))(a1, v9);
}

double re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::open(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v8;
  double result;
  _BYTE v10[4];
  __int128 v11;
  _BYTE v12[28];
  unsigned __int8 v13[24];
  uint64_t v14;
  char v15;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  if (!a5)
  {
  }
  *(_QWORD *)(a1 + 24) = a5;
  if (!a6)
  {
  }
  *(_QWORD *)(a1 + 32) = a6;
  v13[0] = 0;
  re::Optional<re::DetailedError>::operator=(a1 + 40, v13);
  if (v13[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 24);
  v8 = a1 + 96;
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity((_QWORD *)v8, 0x40uLL);
  ++*(_DWORD *)(v8 + 24);
  v10[0] = 0;
  v11 = 0u;
  memset(v12, 0, sizeof(v12));
  *(_QWORD *)&result = re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::add((_anonymous_namespace_ *)v8, (uint64_t)v10).n128_u64[0];
  return result;
}

_BYTE *re::Optional<re::TypeInfo>::operator=(_BYTE *a1, unsigned __int8 *a2)
{
  int v3;
  int v4;
  BOOL v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;

  v3 = *a1;
  v4 = *a2;
  if (*a1)
    v5 = 0;
  else
    v5 = v4 == 0;
  if (!v5)
  {
    if (*a1)
      v6 = v4 == 0;
    else
      v6 = 0;
    if (v6)
    {
      *a1 = 0;
    }
    else
    {
      v7 = (uint64_t)(a1 + 8);
      if (v3)
        v8 = 1;
      else
        v8 = v4 == 0;
      if (v8)
      {
        re::TypeInfo::operator=(v7, (uint64_t)(a2 + 8));
      }
      else
      {
        *a1 = 1;
        re::TypeInfo::TypeInfo(v7, (uint64_t)(a2 + 8));
      }
    }
  }
  return a1;
}

void std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED2E978;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED2E978;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::operator()(uint64_t result, re::TypeRegistry **a2)
{
  re::TypeRegistry *v2;
  uint64_t v3;

  v2 = *a2;
  if (*a2)
  {
    v3 = *(_QWORD *)(result + 8);
    re::TypeRegistry::~TypeRegistry(*a2);
    return (*(uint64_t (**)(uint64_t, re::TypeRegistry *))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::target_type()
{
}

uint64_t std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;

  v2 = *a1;
  *a1 = 0;
  if (!v2)
  {
LABEL_4:
    v4 = (uint64_t *)a1[4];
    if (v4 == a1 + 1)
    {
      v5 = 4;
      v4 = a1 + 1;
    }
    else
    {
      if (!v4)
        return (uint64_t)a1;
      v5 = 5;
    }
    (*(void (**)(void))(*v4 + 8 * v5))();
    return (uint64_t)a1;
  }
  v8 = v2;
  v3 = a1[4];
  if (v3)
  {
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v8);
    goto LABEL_4;
  }
  v7 = std::__throw_bad_function_call[abi:nn180100]();
  return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFuncs(v7);
}

uint64_t *re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFuncs(_QWORD *a1)
{
  uint64_t v2;
  uint64_t *result;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[2];
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
  (*(void (**)(_QWORD *))(*a1 + 64))(a1);
  v2 = a1[24];
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, a1 + 1);
  if (v2)
    v4 = result == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v5 = *result;
    v6 = a1[24];
    v11[0] = v2;
    v11[1] = v5;
    re::TypeRegistry::attributesByAttributeType(v6, (uint64_t)v11, (uint64_t)&v12);
    if (v13)
    {
      v7 = 48 * v13;
      v8 = (uint64_t *)(v14 + 40);
      do
      {
        v10 = *(_OWORD *)(v8 - 3);
        v9 = *v8;
        v8 += 6;
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc((uint64_t)a1, (uint64_t)&v10, v9);
        v7 -= 48;
      }
      while (v7);
    }
    result = v12;
    if (v12)
    {
      if (v14)
        return (uint64_t *)(*(uint64_t (**)(void))(*v12 + 40))();
    }
  }
  return result;
}

void re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v7 = *(_QWORD *)(a1 + 208);
  v5 = a1 + 208;
  LODWORD(v6) = v7;
  v8 = *(_QWORD *)(a2 + 8) | 0xFFFFFFFF00000000;
  if (v7)
  {
    v6 = v8 % *(unsigned int *)(a1 + 232);
    v9 = *(unsigned int *)(*(_QWORD *)(a1 + 216) + 4 * v6);
    if ((_DWORD)v9 != 0x7FFFFFFF)
    {
      v15 = *(_QWORD *)(a1 + 224);
      if (*(_QWORD *)(v15 + 24 * v9 + 4) == v8)
      {
LABEL_12:
        *(_QWORD *)(v15 + 24 * v9 + 16) = a3;
        goto LABEL_13;
      }
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v15 + 24 * v9) & 0x7FFFFFFF;
        if ((_DWORD)v9 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v15 + 24 * v9 + 4) == v8)
          goto LABEL_12;
      }
    }
  }
  v10 = *(unsigned int *)(a1 + 244);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 240);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 232))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(v5, 2 * *(_DWORD *)(a1 + 236));
      LODWORD(v6) = v8 % *(unsigned int *)(a1 + 232);
      v11 = *(_DWORD *)(a1 + 240);
    }
    *(_DWORD *)(a1 + 240) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 224);
    v13 = *(_DWORD *)(v12 + 24 * v10);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 224);
    v13 = *(_DWORD *)(v12 + 24 * v10);
    *(_DWORD *)(a1 + 244) = v13 & 0x7FFFFFFF;
  }
  v14 = 24 * v10;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 224) + v14) = *(_DWORD *)(*(_QWORD *)(a1 + 224) + 24 * v10) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 216) + 4 * v6);
  *(_QWORD *)(*(_QWORD *)(a1 + 224) + 24 * v10 + 4) = v8;
  *(_QWORD *)(*(_QWORD *)(a1 + 224) + 24 * v10 + 16) = a3;
  *(_DWORD *)(*(_QWORD *)(a1 + 216) + 4 * v6) = v10;
  ++*(_DWORD *)(a1 + 236);
LABEL_13:
  ++*(_DWORD *)(a1 + 248);
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        do
        {
          if ((*(_DWORD *)v6 & 0x80000000) != 0)
          {
            v13 = *(_QWORD *)(v6 + 4);
            v14 = *(unsigned int *)(a1 + 24);
            v15 = v13 % v14;
            v16 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v16 == 0x7FFFFFFF)
            {
              v16 = *(unsigned int *)(a1 + 32);
              v17 = v16;
              if ((_DWORD)v16 == (_DWORD)v14)
              {
                re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, (2 * v11));
                v15 = v13 % *(unsigned int *)(a1 + 24);
                v17 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v17 + 1;
              v18 = *(_QWORD *)(a1 + 16);
              v19 = *(_DWORD *)(v18 + 24 * v16);
            }
            else
            {
              v18 = *(_QWORD *)(a1 + 16);
              v19 = *(_DWORD *)(v18 + 24 * v16);
              *(_DWORD *)(a1 + 36) = v19 & 0x7FFFFFFF;
            }
            v20 = 24 * v16;
            *(_DWORD *)(v18 + v20) = v19 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + v20) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v16) & 0x80000000 | *(_DWORD *)(v12 + 4 * v15);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v16 + 4) = *(_QWORD *)(v6 + 4);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v16 + 16) = *(_QWORD *)(v6 + 16);
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v15) = v16;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v6 += 24;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::open(_QWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8;
  double v9;

  v8 = a1[26];
  if (*(_DWORD *)(v8 + 24) != *((_DWORD *)a1 + 54))
  {
    (*(void (**)(_QWORD *))(*a1 + 40))(a1);
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
    a1[26] = v8;
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFuncs(a1);
    (*(void (**)(_QWORD *))(*a1 + 32))(a1);
    *((_DWORD *)a1 + 54) = *(_DWORD *)(a1[26] + 24);
  }
  v9 = re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::open((uint64_t)(a1 + 3), a2, 0, 0xFFFFFFFFLL, a3, a4);
  return (*(uint64_t (**)(_QWORD *, double))(*a1 + 48))(a1, v9);
}

uint64_t re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::open(_QWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8;
  double v9;

  v8 = a1[26];
  if (*(_DWORD *)(v8 + 24) != *((_DWORD *)a1 + 54))
  {
    (*(void (**)(_QWORD *))(*a1 + 40))(a1);
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
    a1[26] = v8;
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
    re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFuncs(a1);
    (*(void (**)(_QWORD *))(*a1 + 32))(a1);
    *((_DWORD *)a1 + 54) = *(_DWORD *)(a1[26] + 24);
  }
  v9 = re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::open((uint64_t)(a1 + 3), a2, 0, 0xFFFFFFFFLL, a3, a4);
  return (*(uint64_t (**)(_QWORD *, double))(*a1 + 48))(a1, v9);
}

uint64_t *re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFuncs(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *result;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[2];
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;

  v2 = (uint64_t)(a1 + 28);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
  (*(void (**)(_QWORD *))(*a1 + 64))(a1);
  v3 = a1[26];
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3)
    v5 = result == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = *result;
    v7 = a1[26];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      v8 = (uint64_t *)(v15 + 40);
      v9 = 48 * v14;
      do
      {
        v10 = *(v8 - 2);
        v11 = *v8;
        v8 += 6;
        v17 = v11;
        v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    result = v13;
    if (v13)
    {
      if (v15)
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v6 = *a2;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  v7 = v6 % *(unsigned int *)(a1 + 24);
  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v7);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v9 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v9 + 24 * v8 + 4) != v6)
  {
    v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if ((_DWORD)v8 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v10 = 3 * v8;
  *(_QWORD *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10 + 4), *(_QWORD *)&v13[16] + v10 + 4, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t *re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs(_QWORD *a1)
{
  uint64_t v2;
  uint64_t *result;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[2];
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 36));
  (*(void (**)(_QWORD *))(*a1 + 64))(a1);
  v2 = a1[34];
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, a1 + 1);
  if (v2)
    v4 = result == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v5 = *result;
    v6 = a1[34];
    v11[0] = v2;
    v11[1] = v5;
    re::TypeRegistry::attributesByAttributeType(v6, (uint64_t)v11, (uint64_t)&v12);
    if (v13)
    {
      v7 = 48 * v13;
      v8 = (uint64_t *)(v14 + 40);
      do
      {
        v10 = *(_OWORD *)(v8 - 3);
        v9 = *v8;
        v8 += 6;
        re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc((uint64_t)a1, (uint64_t)&v10, v9);
        v7 -= 48;
      }
      while (v7);
    }
    result = v12;
    if (v12)
    {
      if (v14)
        return (uint64_t *)(*(uint64_t (**)(void))(*v12 + 40))();
    }
  }
  return result;
}

void re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;

  v5 = *(_QWORD *)(a2 + 8) | 0xFFFFFFFF00000000;
  v6 = *(_QWORD *)(a1 + 288);
  if (v6)
  {
    v6 = v5 % *(unsigned int *)(a1 + 312);
    v7 = *(unsigned int *)(*(_QWORD *)(a1 + 296) + 4 * v6);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v13 = *(_QWORD *)(a1 + 304);
      if (*(_QWORD *)(v13 + 24 * v7 + 4) == v5)
      {
LABEL_12:
        *(_QWORD *)(v13 + 24 * v7 + 16) = a3;
        goto LABEL_13;
      }
      while (1)
      {
        LODWORD(v7) = *(_DWORD *)(v13 + 24 * v7) & 0x7FFFFFFF;
        if ((_DWORD)v7 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v13 + 24 * v7 + 4) == v5)
          goto LABEL_12;
      }
    }
  }
  v8 = *(unsigned int *)(a1 + 324);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 320);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 312))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1 + 288, 2 * *(_DWORD *)(a1 + 316));
      LODWORD(v6) = v5 % *(unsigned int *)(a1 + 312);
      v9 = *(_DWORD *)(a1 + 320);
    }
    *(_DWORD *)(a1 + 320) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 304);
    v11 = *(_DWORD *)(v10 + 24 * v8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 304);
    v11 = *(_DWORD *)(v10 + 24 * v8);
    *(_DWORD *)(a1 + 324) = v11 & 0x7FFFFFFF;
  }
  v12 = 24 * v8;
  *(_DWORD *)(v10 + v12) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 304) + v12) = *(_DWORD *)(*(_QWORD *)(a1 + 304) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 296) + 4 * v6);
  *(_QWORD *)(*(_QWORD *)(a1 + 304) + 24 * v8 + 4) = v5;
  *(_QWORD *)(*(_QWORD *)(a1 + 304) + 24 * v8 + 16) = a3;
  *(_DWORD *)(*(_QWORD *)(a1 + 296) + 4 * v6) = v8;
  ++*(_DWORD *)(a1 + 316);
LABEL_13:
  ++*(_DWORD *)(a1 + 328);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::open(_QWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8;

  v8 = a1[34];
  if (*(_DWORD *)(v8 + 24) != *((_DWORD *)a1 + 70))
  {
    (*(void (**)(_QWORD *))(*a1 + 40))(a1);
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 36));
    a1[34] = v8;
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 36));
    re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs(a1);
    (*(void (**)(_QWORD *))(*a1 + 32))(a1);
    *((_DWORD *)a1 + 70) = *(_DWORD *)(a1[34] + 24);
  }
  re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::open((uint64_t)(a1 + 3), a2, 0, 0xFFFFFFFFLL, a3, a4);
  return (*(uint64_t (**)(_QWORD *))(*a1 + 48))(a1);
}

uint64_t *re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *result;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[2];
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;

  v2 = (uint64_t)(a1 + 36);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 36));
  (*(void (**)(_QWORD *))(*a1 + 64))(a1);
  v3 = a1[34];
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3)
    v5 = result == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = *result;
    v7 = a1[34];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      v8 = (uint64_t *)(v15 + 40);
      v9 = 48 * v14;
      do
      {
        v10 = *(v8 - 2);
        v11 = *v8;
        v8 += 6;
        v17 = v11;
        v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    result = v13;
    if (v13)
    {
      if (v15)
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v6 = *a2;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  v7 = v6 % *(unsigned int *)(a1 + 24);
  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v7);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v9 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v9 + 24 * v8 + 4) != v6)
  {
    v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if ((_DWORD)v8 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v10 = 3 * v8;
  *(_QWORD *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10 + 4), *(_QWORD *)&v13[16] + v10 + 4, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::open(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  _BYTE v9[4];
  __int128 v10;
  _BYTE v11[28];
  unsigned __int8 v12[24];
  uint64_t v13;
  char v14;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  if (!a5)
  {
  }
  *(_QWORD *)(a1 + 24) = a5;
  if (!a6)
  {
  }
  *(_QWORD *)(a1 + 32) = a6;
  v12[0] = 0;
  re::Optional<re::DetailedError>::operator=(a1 + 40, v12);
  if (v12[0] && v13 && (v14 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v13 + 40))();
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 24);
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity((_QWORD *)(a1 + 96), 0x40uLL);
  ++*(_DWORD *)(a1 + 120);
  v9[0] = 0;
  v10 = 0u;
  memset(v11, 0, sizeof(v11));
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::add((_anonymous_namespace_ *)(a1 + 96), (uint64_t)v9);
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::doOpen(a1);
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::doOpen(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char v9;
  _QWORD v10[2];
  int v11;
  unint64_t v12;
  uint64_t v13;

  if (!re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance)
  {
  }
  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a1 + 32);
  re::DynamicArray<char>::setCapacity((_QWORD *)(a1 + 192), 0);
  ++*(_DWORD *)(a1 + 216);
  v2 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 24) + 32))(*(_QWORD *)(a1 + 24), 72, 8);
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 256;
  *(_DWORD *)(v2 + 48) = 0;
  *(_QWORD *)(v2 + 56) = 0;
  *(_DWORD *)(v2 + 64) = 2;
  *(_QWORD *)(a1 + 184) = v2;
  v3 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 24) + 32))(*(_QWORD *)(a1 + 24), 104, 8);
  v4 = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::GenericDocument(v3, 0, 1024, 0);
  *(_QWORD *)(a1 + 176) = v4;
  v10[0] = *(_QWORD *)a1;
  v10[1] = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::ParseStream<440u,rapidjson::UTF8<char>,re::internal::RapidJSONInputStream>(v4, v10);
  v6 = *(_QWORD *)(result + 88);
  if ((_DWORD)v6)
  {
    v7 = v6 > 0x11
       ? "Unknown error."
       : *(char **)((char *)off_24ED2E9F8 + (((v6 << 32) - 0x100000000) >> 29));
    re::DynamicString::format((re::DynamicString *)"Failed to deserialize JSON: %s (Offset %zu)", (re::DynamicString *)&v8, v7, *(_QWORD *)(result + 96));
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1, (uint64_t)&v8);
    result = v8;
    if (v8)
    {
      if ((v9 & 1) != 0)
        result = (*(uint64_t (**)(void))(*(_QWORD *)v8 + 40))();
    }
  }
  if (v12 < v11)
    return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v10[0] + 24))(v10[0], (v11 - v12));
  return result;
}

BOOL rapidjson::ParseResult::IsError(rapidjson::ParseResult *this)
{
  return *(_DWORD *)this != 0;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::GenericDocument(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = a4;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)(a1 + 80) = a3;
  *(_DWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  if (!a2)
  {
    v5 = (_QWORD *)(*(uint64_t (**)(void *, uint64_t, _QWORD))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                      + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 24, 0);
    v5[1] = 0;
    v5[2] = 0;
    *v5 = 0x10000;
    v5[1] = (*(uint64_t (**)(void *, uint64_t, _QWORD))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                               + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 1, 0);
    v6 = (*(uint64_t (**)(void *, uint64_t, _QWORD))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                            + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 56, 0);
    v5[2] = v6;
    v7 = v5[1];
    *(_QWORD *)(v6 + 32) = 0;
    *(_QWORD *)v6 = v6 + 32;
    *(_QWORD *)(v6 + 8) = v7;
    *(_QWORD *)(v6 + 40) = 0;
    *(_QWORD *)(v6 + 48) = 0;
    *(_BYTE *)(v6 + 24) = 1;
    *(_QWORD *)(v6 + 16) = 1;
    *(_QWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 32) = v5;
  }
  return a1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::ParseStream<440u,rapidjson::UTF8<char>,re::internal::RapidJSONInputStream>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  BOOL (*v6)(rapidjson::ParseResult *);
  uint64_t v7;
  __int128 *v8;
  __int16 v9;
  __int128 v10;
  int v11;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;

  v3 = (_QWORD *)(a1 + 40);
  v13 = *(_QWORD *)(a1 + 40);
  v14 = 0u;
  v15 = 0u;
  v16 = 256;
  v17 = 0;
  v18 = 0;
  v19 = 2;
  v4 = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::Parse<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>((uint64_t)&v13, a2, a1);
  *(_QWORD *)(a1 + 88) = v4;
  *(_QWORD *)(a1 + 96) = v5;
  v6 = rapidjson::ParseResult::IsError;
  if ((_DWORD)v4)
    v6 = 0;
  if (v6)
  {
    v7 = *(_QWORD *)(a1 + 64);
    v8 = (__int128 *)(v7 - 24);
    *(_QWORD *)(a1 + 64) = v7 - 24;
    if (v7 - 24 != a1)
    {
      v9 = *(_WORD *)(v7 - 2);
      *(_WORD *)(v7 - 2) = 0;
      v10 = *v8;
      v11 = *(_DWORD *)(v7 - 8);
      *(_WORD *)(a1 + 20) = *((_WORD *)v8 + 10);
      *(_DWORD *)(a1 + 16) = v11;
      *(_OWORD *)a1 = v10;
      *(_WORD *)(a1 + 22) = v9;
    }
  }
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 56);
  rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::ShrinkToFit(v3);
  if (*((_QWORD *)&v14 + 1))
    (*(void (**)(void *))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                   + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
  if ((_QWORD)v14)
    (*(void (**)(void *))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                   + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
  return a1;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::Parse<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
  if (!*(_DWORD *)(a1 + 48))
  {
    if (re::internal::RapidJSONInputStream::next<false>(a2))
    {
      rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseValue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
    }
    else
    {
      v7 = a2[4];
      *(_DWORD *)(a1 + 48) = 1;
      *(_QWORD *)(a1 + 56) = v7;
    }
  }
  result = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16);
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(uint64_t a1, _QWORD *a2)
{
  _QWORD *i;
  uint64_t result;
  int v6;
  uint64_t v7;

  for (i = a2; ; i = a2)
  {
    rapidjson::SkipWhitespace<re::internal::RapidJSONInputStream>(i);
    result = re::internal::RapidJSONInputStream::next<false>(a2);
    if ((_DWORD)result != 47)
      break;
    re::internal::RapidJSONInputStream::next<true>(a2);
    if (re::internal::RapidJSONInputStream::next<false>(a2) == 42)
    {
      re::internal::RapidJSONInputStream::next<true>(a2);
      while (1)
      {
        result = re::internal::RapidJSONInputStream::next<false>(a2);
        if (!(_DWORD)result)
          break;
        v6 = re::internal::RapidJSONInputStream::next<false>(a2);
        re::internal::RapidJSONInputStream::next<true>(a2);
        if (v6 == 42 && re::internal::RapidJSONInputStream::next<false>(a2) == 47)
        {
          re::internal::RapidJSONInputStream::next<true>(a2);
          goto LABEL_9;
        }
      }
LABEL_15:
      v7 = a2[4];
      *(_DWORD *)(a1 + 48) = 17;
      *(_QWORD *)(a1 + 56) = v7;
      return result;
    }
    result = re::internal::RapidJSONInputStream::next<false>(a2);
    if ((_DWORD)result != 47)
      goto LABEL_15;
    re::internal::RapidJSONInputStream::next<true>(a2);
    while (re::internal::RapidJSONInputStream::next<false>(a2)
         && re::internal::RapidJSONInputStream::next<true>(a2) != 10)
      ;
LABEL_9:
    ;
  }
  return result;
}

void rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseValue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  int v6;

  v6 = re::internal::RapidJSONInputStream::next<false>(a2);
  if (v6 > 109)
  {
    switch(v6)
    {
      case '{':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseObject<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        return;
      case 't':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseTrue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        return;
      case 'n':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseNull<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        return;
    }
  }
  else
  {
    switch(v6)
    {
      case '"':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseString<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        return;
      case '[':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseArray<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        return;
      case 'f':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseFalse<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        return;
    }
  }
  rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseNumber<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
}

uint64_t rapidjson::SkipWhitespace<re::internal::RapidJSONInputStream>(_QWORD *a1)
{
  uint64_t result;

  while (1)
  {
    result = re::internal::RapidJSONInputStream::next<false>(a1);
    if (result > 0x20 || ((1 << result) & 0x100002600) == 0)
      break;
    re::internal::RapidJSONInputStream::next<true>(a1);
  }
  return result;
}

uint64_t re::internal::RapidJSONInputStream::next<true>(_QWORD *a1)
{
  int v2;
  int *v3;
  _QWORD *v4;
  unint64_t v5;
  char v6;
  uint64_t v7;

  v3 = (int *)(a1 + 2);
  v2 = *((_DWORD *)a1 + 4);
  v4 = a1 + 1;
  while (1)
  {
    v5 = a1[3];
    if (v5 < v2)
    {
      v6 = *(_BYTE *)(a1[1] + v5);
      v7 = a1[4] + 1;
      a1[3] = v5 + 1;
      a1[4] = v7;
      return v6;
    }
    if (!(*(unsigned int (**)(_QWORD, _QWORD *, int *))(*(_QWORD *)*a1 + 16))(*a1, v4, v3))
      break;
    v2 = *v3;
    if (*v3 >= 1)
    {
      a1[3] = 1;
      return *(char *)a1[1];
    }
  }
  return 0;
}

uint64_t re::internal::RapidJSONInputStream::next<false>(_QWORD *a1)
{
  int v2;
  int *v3;
  _QWORD *v4;
  unint64_t v5;
  char *v6;

  v3 = (int *)(a1 + 2);
  v2 = *((_DWORD *)a1 + 4);
  v4 = a1 + 1;
  while (1)
  {
    v5 = a1[3];
    if (v5 < v2)
    {
      v6 = (char *)(*v4 + v5);
      return *v6;
    }
    if (!(*(unsigned int (**)(_QWORD, _QWORD *, int *))(*(_QWORD *)*a1 + 16))(*a1, v4, v3))
      break;
    v2 = *v3;
    if (*v3 >= 1)
    {
      a1[3] = 0;
      v6 = (char *)a1[1];
      return *v6;
    }
  }
  return 0;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseNull<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  _QWORD *v7;
  uint64_t v8;

  re::internal::RapidJSONInputStream::next<true>(a2);
  result = re::internal::RapidJSONInputStream::next<false>(a2);
  if ((_DWORD)result == 117
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        result = re::internal::RapidJSONInputStream::next<false>(a2),
        (_DWORD)result == 108)
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        result = re::internal::RapidJSONInputStream::next<false>(a2),
        (_DWORD)result == 108))
  {
    result = re::internal::RapidJSONInputStream::next<true>(a2);
    v7 = *(_QWORD **)(a3 + 64);
    if ((uint64_t)(*(_QWORD *)(a3 + 72) - (_QWORD)v7) <= 23)
    {
      result = (uint64_t)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a3 + 40, 1);
      v7 = *(_QWORD **)(a3 + 64);
    }
    *(_QWORD *)(a3 + 64) = v7 + 3;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
  }
  else
  {
    v8 = a2[4];
    *(_DWORD *)(a1 + 48) = 3;
    *(_QWORD *)(a1 + 56) = v8;
  }
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseTrue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  re::internal::RapidJSONInputStream::next<true>(a2);
  result = re::internal::RapidJSONInputStream::next<false>(a2);
  if ((_DWORD)result == 114
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        result = re::internal::RapidJSONInputStream::next<false>(a2),
        (_DWORD)result == 117)
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        result = re::internal::RapidJSONInputStream::next<false>(a2),
        (_DWORD)result == 101))
  {
    result = re::internal::RapidJSONInputStream::next<true>(a2);
    v7 = *(_QWORD *)(a3 + 64);
    if (*(_QWORD *)(a3 + 72) - v7 <= 23)
    {
      result = (uint64_t)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a3 + 40, 1);
      v7 = *(_QWORD *)(a3 + 64);
    }
    *(_QWORD *)(a3 + 64) = v7 + 24;
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(v7 + 16) = 0;
    *(_QWORD *)v7 = 0;
    *(_WORD *)(v7 + 22) = 10;
  }
  else
  {
    v8 = a2[4];
    *(_DWORD *)(a1 + 48) = 3;
    *(_QWORD *)(a1 + 56) = v8;
  }
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseFalse<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  re::internal::RapidJSONInputStream::next<true>(a2);
  result = re::internal::RapidJSONInputStream::next<false>(a2);
  if ((_DWORD)result == 97
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        result = re::internal::RapidJSONInputStream::next<false>(a2),
        (_DWORD)result == 108)
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        result = re::internal::RapidJSONInputStream::next<false>(a2),
        (_DWORD)result == 115)
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        result = re::internal::RapidJSONInputStream::next<false>(a2),
        (_DWORD)result == 101))
  {
    result = re::internal::RapidJSONInputStream::next<true>(a2);
    v7 = *(_QWORD *)(a3 + 64);
    if (*(_QWORD *)(a3 + 72) - v7 <= 23)
    {
      result = (uint64_t)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a3 + 40, 1);
      v7 = *(_QWORD *)(a3 + 64);
    }
    *(_QWORD *)(a3 + 64) = v7 + 24;
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(v7 + 16) = 0;
    *(_QWORD *)v7 = 0;
    *(_WORD *)(v7 + 22) = 9;
  }
  else
  {
    v8 = a2[4];
    *(_DWORD *)(a1 + 48) = 3;
    *(_QWORD *)(a1 + 56) = v8;
  }
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseString<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  char v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  _BYTE *v17;
  int v18;
  unsigned int v19;
  void *v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;

  re::internal::RapidJSONInputStream::next<true>(a2);
  v24 = a1;
  v25 = 0;
  while (1)
  {
    while (1)
    {
      result = re::internal::RapidJSONInputStream::next<false>(a2);
      if ((_DWORD)result != 92)
      {
        if (result == 34)
        {
          result = re::internal::RapidJSONInputStream::next<true>(a2);
          v16 = v24;
          v17 = *(_BYTE **)(v24 + 24);
          if ((uint64_t)(*(_QWORD *)(v24 + 32) - (_QWORD)v17) <= 0)
          {
            result = (uint64_t)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v24, 1);
            v17 = *(_BYTE **)(v16 + 24);
          }
          *(_QWORD *)(v16 + 24) = v17 + 1;
          *v17 = 0;
          v18 = v25;
          v19 = ++v25;
          if (*(_DWORD *)(a1 + 48))
            return result;
          v20 = (void *)(*(_QWORD *)(v24 + 24) - v19);
          *(_QWORD *)(v24 + 24) = v20;
          result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::String(a3, v20, v18, 1);
          if ((result & 1) != 0)
            return result;
          v21 = a2[4];
          v22 = 16;
        }
        else
        {
          if (result > 0x1F)
          {
            v7 = re::internal::RapidJSONInputStream::next<true>(a2);
            v8 = v24;
            v9 = *(_BYTE **)(v24 + 24);
            if ((uint64_t)(*(_QWORD *)(v24 + 32) - (_QWORD)v9) <= 0)
            {
              rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v24, 1);
              v9 = *(_BYTE **)(v8 + 24);
            }
            *(_QWORD *)(v8 + 24) = v9 + 1;
            *v9 = v7;
            goto LABEL_8;
          }
          v21 = a2[4];
          if ((_DWORD)result)
            v22 = 12;
          else
            v22 = 11;
        }
        *(_DWORD *)(a1 + 48) = v22;
        *(_QWORD *)(a1 + 56) = v21;
        return result;
      }
      v10 = a2[4];
      re::internal::RapidJSONInputStream::next<true>(a2);
      result = re::internal::RapidJSONInputStream::next<false>(a2);
      v11 = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseStringToStream<440u,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONInputStream,rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::StackStream<char>>(re::internal::RapidJSONInputStream &,rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::StackStream<char> &)::escape[result];
      if (!v11)
        break;
      re::internal::RapidJSONInputStream::next<true>(a2);
      v12 = v24;
      v13 = *(_BYTE **)(v24 + 24);
      if ((uint64_t)(*(_QWORD *)(v24 + 32) - (_QWORD)v13) <= 0)
      {
        rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v24, 1);
        v13 = *(_BYTE **)(v12 + 24);
      }
      *(_QWORD *)(v12 + 24) = v13 + 1;
      *v13 = v11;
LABEL_8:
      ++v25;
    }
    if ((_DWORD)result != 117)
    {
      v23 = 10;
      goto LABEL_34;
    }
    re::internal::RapidJSONInputStream::next<true>(a2);
    result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseHex4<re::internal::RapidJSONInputStream>(a1, a2, v10);
    if (*(_DWORD *)(a1 + 48))
      return result;
    v14 = result;
    if (result >> 11 == 27)
      break;
LABEL_16:
    rapidjson::UTF8<char>::Encode<rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::StackStream<char>>(&v24, v14);
  }
  if (result >> 10 <= 0x36)
  {
    v15 = result;
    result = re::internal::RapidJSONInputStream::next<false>(a2);
    if ((_DWORD)result == 92)
    {
      re::internal::RapidJSONInputStream::next<true>(a2);
      result = re::internal::RapidJSONInputStream::next<false>(a2);
      if ((_DWORD)result == 117)
      {
        re::internal::RapidJSONInputStream::next<true>(a2);
        result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseHex4<re::internal::RapidJSONInputStream>(a1, a2, v10);
        if (*(_DWORD *)(a1 + 48))
          return result;
        if ((result - 57344) > 0xFFFFFBFF)
        {
          v14 = ((result - 56320) | ((v15 << 10) - 56623104)) + 0x10000;
          goto LABEL_16;
        }
      }
    }
  }
  v23 = 9;
LABEL_34:
  *(_DWORD *)(a1 + 48) = v23;
  *(_QWORD *)(a1 + 56) = v10;
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseObject<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  int v10;

  re::internal::RapidJSONInputStream::next<true>(a2);
  result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::StartObject(a3);
  if ((result & 1) != 0)
  {
    result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
    if (*(_DWORD *)(a1 + 48))
      return result;
    if (re::internal::RapidJSONInputStream::next<false>(a2) == 125)
    {
      result = re::internal::RapidJSONInputStream::next<true>(a2);
      v7 = *(_QWORD *)(a3 + 64);
      *(_WORD *)(v7 - 2) = 3;
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      return result;
    }
    v8 = 0;
    while (1)
    {
      result = re::internal::RapidJSONInputStream::next<false>(a2);
      if ((_DWORD)result != 34)
      {
        v9 = a2[4];
        v10 = 4;
        goto LABEL_23;
      }
      result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseString<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
      if (*(_DWORD *)(a1 + 48))
        return result;
      result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
      if (*(_DWORD *)(a1 + 48))
        return result;
      result = re::internal::RapidJSONInputStream::next<false>(a2);
      if ((_DWORD)result != 58)
      {
        v9 = a2[4];
        v10 = 5;
        goto LABEL_23;
      }
      re::internal::RapidJSONInputStream::next<true>(a2);
      result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
      if (*(_DWORD *)(a1 + 48))
        return result;
      result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseValue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
      if (*(_DWORD *)(a1 + 48))
        return result;
      result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
      if (*(_DWORD *)(a1 + 48))
        return result;
      result = re::internal::RapidJSONInputStream::next<false>(a2);
      if ((_DWORD)result != 44)
        break;
      re::internal::RapidJSONInputStream::next<true>(a2);
      result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
      if (*(_DWORD *)(a1 + 48))
        return result;
      ++v8;
      if (re::internal::RapidJSONInputStream::next<false>(a2) == 125)
      {
        result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndObject(a3, v8);
        if ((result & 1) == 0)
          goto LABEL_21;
        return re::internal::RapidJSONInputStream::next<true>(a2);
      }
    }
    if ((_DWORD)result != 125)
    {
      v9 = a2[4];
      v10 = 6;
      goto LABEL_23;
    }
    re::internal::RapidJSONInputStream::next<true>(a2);
    result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndObject(a3, v8 + 1);
    if ((result & 1) != 0)
      return result;
  }
LABEL_21:
  v9 = a2[4];
  v10 = 16;
LABEL_23:
  *(_DWORD *)(a1 + 48) = v10;
  *(_QWORD *)(a1 + 56) = v9;
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseArray<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  int v10;

  re::internal::RapidJSONInputStream::next<true>(a2);
  result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::StartArray(a3);
  if ((result & 1) != 0)
  {
    result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
    if (!*(_DWORD *)(a1 + 48))
    {
      if (re::internal::RapidJSONInputStream::next<false>(a2) == 93)
      {
        result = re::internal::RapidJSONInputStream::next<true>(a2);
        v7 = *(_QWORD *)(a3 + 64);
        *(_WORD *)(v7 - 2) = 4;
        *(_QWORD *)(v7 - 24) = 0;
        *(_QWORD *)(v7 - 16) = 0;
      }
      else
      {
        v8 = 0;
        while (1)
        {
          result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseValue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
          if (*(_DWORD *)(a1 + 48))
            break;
          result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
          if (*(_DWORD *)(a1 + 48))
            break;
          if (re::internal::RapidJSONInputStream::next<false>(a2) != 44)
          {
            result = re::internal::RapidJSONInputStream::next<false>(a2);
            if ((_DWORD)result != 93)
            {
              v9 = a2[4];
              v10 = 7;
              goto LABEL_17;
            }
            re::internal::RapidJSONInputStream::next<true>(a2);
            result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndArray(a3, v8 + 1);
            if ((result & 1) != 0)
              return result;
            goto LABEL_16;
          }
          re::internal::RapidJSONInputStream::next<true>(a2);
          result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
          if (*(_DWORD *)(a1 + 48))
            return result;
          ++v8;
          if (re::internal::RapidJSONInputStream::next<false>(a2) == 93)
          {
            result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndArray(a3, v8);
            if ((result & 1) == 0)
              goto LABEL_16;
            return re::internal::RapidJSONInputStream::next<true>(a2);
          }
        }
      }
    }
  }
  else
  {
LABEL_16:
    v9 = a2[4];
    v10 = 16;
LABEL_17:
    *(_DWORD *)(a1 + 48) = v10;
    *(_QWORD *)(a1 + 56) = v9;
  }
  return result;
}

void rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseNumber<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  char v11;
  char v12;
  _BYTE *v13;
  int v14;
  unsigned int v15;
  int v16;
  double v17;
  int v18;
  char v19;
  _BYTE *v20;
  char v21;
  _BYTE *v22;
  int v23;
  unint64_t v24;
  int v25;
  int v26;
  int v27;
  char v28;
  _BYTE *v29;
  char v30;
  _BYTE *v31;
  char v32;
  _BYTE *v33;
  int v34;
  int v35;
  int v36;
  char v37;
  _BYTE *v38;
  int v39;
  _BYTE *v40;
  char v41;
  _BYTE *v42;
  uint64_t v43;
  unint64_t v44;
  int v45;
  _BOOL4 v46;
  int v47;
  int v48;
  int v49;
  char *v50;
  double v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  _QWORD *v61;
  uint64_t v62;
  int v63;

  v4 = a2;
  v61 = a2;
  v62 = a1;
  v63 = 0;
  v6 = a2 + 4;
  v7 = a2[4];
  v8 = re::internal::RapidJSONInputStream::next<false>(a2);
  if (v8 == 45)
    re::internal::RapidJSONInputStream::next<true>(v4);
  v9 = re::internal::RapidJSONInputStream::next<false>(v4);
  v10 = re::internal::RapidJSONInputStream::next<false>(v4);
  v11 = v10;
  v58 = v7;
  v59 = a1;
  v57 = a3;
  v60 = v8;
  if (v9 == 48)
  {
    v40 = *(_BYTE **)(a1 + 24);
    if ((uint64_t)(*(_QWORD *)(a1 + 32) - (_QWORD)v40) <= 0)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(a1, 1);
      v40 = *(_BYTE **)(a1 + 24);
    }
    *(_QWORD *)(a1 + 24) = v40 + 1;
    *v40 = v11;
    v14 = ++v63;
    v4 = v61;
    re::internal::RapidJSONInputStream::next<true>(v61);
    v23 = 0;
    v18 = 0;
    v24 = 0;
    v25 = 0;
    v15 = 0;
    v26 = 0;
    v17 = 0.0;
  }
  else
  {
    if (v10 >= 49 && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
    {
      v12 = re::internal::RapidJSONInputStream::next<false>(v4);
      v13 = *(_BYTE **)(a1 + 24);
      if ((uint64_t)(*(_QWORD *)(a1 + 32) - (_QWORD)v13) <= 0)
      {
        rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(a1, 1);
        v13 = *(_BYTE **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v13 + 1;
      *v13 = v12;
      v14 = ++v63;
      v4 = v61;
      v15 = re::internal::RapidJSONInputStream::next<true>(v61) - 48;
      v16 = re::internal::RapidJSONInputStream::next<false>(v61);
      v17 = 0.0;
      if (v8 == 45)
      {
        if (v16 >= 48)
        {
          v18 = 0;
          while ((int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
          {
            if (v15 > 0xCCCCCCB)
            {
              if (v15 != 214748364)
                goto LABEL_35;
              if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 56)
              {
                v15 = 214748364;
                goto LABEL_35;
              }
            }
            v19 = re::internal::RapidJSONInputStream::next<false>(v4);
            v20 = *(_BYTE **)(v62 + 24);
            if ((uint64_t)(*(_QWORD *)(v62 + 32) - (_QWORD)v20) <= 0)
            {
              rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
              v20 = *(_BYTE **)(v62 + 24);
            }
            *(_QWORD *)(v62 + 24) = v20 + 1;
            *v20 = v19;
            v14 = ++v63;
            v4 = v61;
            v15 = 10 * v15 + re::internal::RapidJSONInputStream::next<true>(v61) - 48;
            ++v18;
            if ((int)re::internal::RapidJSONInputStream::next<false>(v61) <= 47)
              break;
          }
LABEL_31:
          v23 = 0;
LABEL_32:
          v24 = 0;
          v25 = 0;
          v26 = 0;
          goto LABEL_67;
        }
      }
      else if (v16 >= 48)
      {
        v18 = 0;
        while ((int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
        {
          if (v15 > 0x19999998)
          {
            if (v15 != 429496729)
              goto LABEL_35;
            if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 53)
            {
              v15 = 429496729;
LABEL_35:
              v24 = v15;
              v27 = re::internal::RapidJSONInputStream::next<false>(v4);
              v17 = 0.0;
              if (v8 == 45)
              {
                if (v27 >= 48)
                {
                  while ((int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
                  {
                    if (v24 > 0xCCCCCCCCCCCCCCBLL)
                    {
                      if (v24 != 0xCCCCCCCCCCCCCCCLL)
                        goto LABEL_59;
                      if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 56)
                      {
                        v24 = 0xCCCCCCCCCCCCCCCLL;
                        goto LABEL_59;
                      }
                    }
                    v28 = re::internal::RapidJSONInputStream::next<false>(v4);
                    v29 = *(_BYTE **)(v62 + 24);
                    if ((uint64_t)(*(_QWORD *)(v62 + 32) - (_QWORD)v29) <= 0)
                    {
                      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
                      v29 = *(_BYTE **)(v62 + 24);
                    }
                    *(_QWORD *)(v62 + 24) = v29 + 1;
                    *v29 = v28;
                    v14 = ++v63;
                    v4 = v61;
                    v24 = re::internal::RapidJSONInputStream::next<true>(v61) - 48 + 10 * v24;
                    ++v18;
                    if ((int)re::internal::RapidJSONInputStream::next<false>(v61) <= 47)
                      break;
                  }
                }
              }
              else if (v27 >= 48)
              {
                while ((int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
                {
                  if (v24 > 0x1999999999999998)
                  {
                    if (v24 != 0x1999999999999999)
                      goto LABEL_59;
                    if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 53)
                    {
                      v24 = 0x1999999999999999;
LABEL_59:
                      v17 = (double)v24;
                      if ((int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48
                        && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
                      {
                        do
                        {
                          v32 = re::internal::RapidJSONInputStream::next<false>(v4);
                          v33 = *(_BYTE **)(v62 + 24);
                          if ((uint64_t)(*(_QWORD *)(v62 + 32) - (_QWORD)v33) <= 0)
                          {
                            rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
                            v33 = *(_BYTE **)(v62 + 24);
                          }
                          *(_QWORD *)(v62 + 24) = v33 + 1;
                          *v33 = v32;
                          v14 = ++v63;
                          v4 = v61;
                          v17 = (double)(int)(re::internal::RapidJSONInputStream::next<true>(v61) - 48) + v17 * 10.0;
                        }
                        while ((int)re::internal::RapidJSONInputStream::next<false>(v61) > 47
                             && (int)re::internal::RapidJSONInputStream::next<false>(v61) <= 57);
                      }
                      v25 = 0;
                      v23 = 1;
                      goto LABEL_66;
                    }
                  }
                  v30 = re::internal::RapidJSONInputStream::next<false>(v4);
                  v31 = *(_BYTE **)(v62 + 24);
                  if ((uint64_t)(*(_QWORD *)(v62 + 32) - (_QWORD)v31) <= 0)
                  {
                    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
                    v31 = *(_BYTE **)(v62 + 24);
                  }
                  *(_QWORD *)(v62 + 24) = v31 + 1;
                  *v31 = v30;
                  v14 = ++v63;
                  v4 = v61;
                  v24 = re::internal::RapidJSONInputStream::next<true>(v61) - 48 + 10 * v24;
                  ++v18;
                  if ((int)re::internal::RapidJSONInputStream::next<false>(v61) <= 47)
                    break;
                }
              }
              v23 = 0;
              v25 = 0;
LABEL_66:
              v26 = 1;
              goto LABEL_67;
            }
          }
          v21 = re::internal::RapidJSONInputStream::next<false>(v4);
          v22 = *(_BYTE **)(v62 + 24);
          if ((uint64_t)(*(_QWORD *)(v62 + 32) - (_QWORD)v22) <= 0)
          {
            rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
            v22 = *(_BYTE **)(v62 + 24);
          }
          *(_QWORD *)(v62 + 24) = v22 + 1;
          *v22 = v21;
          v14 = ++v63;
          v4 = v61;
          v15 = 10 * v15 + re::internal::RapidJSONInputStream::next<true>(v61) - 48;
          ++v18;
          if ((int)re::internal::RapidJSONInputStream::next<false>(v61) <= 47)
            goto LABEL_31;
        }
        goto LABEL_31;
      }
      v23 = 0;
      v18 = 0;
      goto LABEL_32;
    }
    if (re::internal::RapidJSONInputStream::next<false>(v4) != 73
      && re::internal::RapidJSONInputStream::next<false>(v4) != 78)
    {
      goto LABEL_154;
    }
    if (re::internal::RapidJSONInputStream::next<false>(v4) == 78)
    {
      re::internal::RapidJSONInputStream::next<true>(v4);
      if (re::internal::RapidJSONInputStream::next<false>(v4) != 97)
        goto LABEL_154;
      re::internal::RapidJSONInputStream::next<true>(v4);
      if (re::internal::RapidJSONInputStream::next<false>(v4) != 78)
        goto LABEL_154;
      re::internal::RapidJSONInputStream::next<true>(v4);
      v14 = 0;
      v23 = 0;
      v18 = 0;
      v24 = 0;
      v15 = 0;
      v26 = 0;
      v25 = 1;
      v17 = NAN;
    }
    else
    {
      if (re::internal::RapidJSONInputStream::next<false>(v4) != 73)
        goto LABEL_154;
      re::internal::RapidJSONInputStream::next<true>(v4);
      if (re::internal::RapidJSONInputStream::next<false>(v4) != 110)
        goto LABEL_154;
      re::internal::RapidJSONInputStream::next<true>(v4);
      if (re::internal::RapidJSONInputStream::next<false>(v4) != 102)
        goto LABEL_154;
      re::internal::RapidJSONInputStream::next<true>(v4);
      if (v8 == 45)
        v17 = -INFINITY;
      else
        v17 = INFINITY;
      if (re::internal::RapidJSONInputStream::next<false>(v4) == 105)
      {
        if (re::internal::RapidJSONInputStream::next<false>(v4) != 105)
          goto LABEL_154;
        re::internal::RapidJSONInputStream::next<true>(v4);
        if (re::internal::RapidJSONInputStream::next<false>(v4) != 110)
          goto LABEL_154;
        re::internal::RapidJSONInputStream::next<true>(v4);
        if (re::internal::RapidJSONInputStream::next<false>(v4) != 105)
          goto LABEL_154;
        re::internal::RapidJSONInputStream::next<true>(v4);
        if (re::internal::RapidJSONInputStream::next<false>(v4) != 116)
          goto LABEL_154;
        re::internal::RapidJSONInputStream::next<true>(v4);
        if (re::internal::RapidJSONInputStream::next<false>(v4) != 121)
          goto LABEL_154;
        re::internal::RapidJSONInputStream::next<true>(v4);
      }
      v14 = 0;
      v23 = 0;
      v18 = 0;
      v24 = 0;
      v15 = 0;
      v26 = 0;
      v25 = 1;
    }
  }
LABEL_67:
  if (re::internal::RapidJSONInputStream::next<false>(v4) != 46)
  {
    v34 = 0;
    v35 = v14;
    goto LABEL_115;
  }
  re::internal::RapidJSONInputStream::next<true>(v4);
  if (v25)
  {
LABEL_153:
    v6 = v4 + 4;
LABEL_154:
    v39 = 3;
    goto LABEL_156;
  }
  if ((int)re::internal::RapidJSONInputStream::next<false>(v4) < 48
    || (int)re::internal::RapidJSONInputStream::next<false>(v4) >= 58)
  {
    v6 = v4 + 4;
    v39 = 14;
    goto LABEL_156;
  }
  if ((v23 & 1) != 0)
  {
    v34 = 0;
    v35 = v14;
    goto LABEL_102;
  }
  if (!v26)
    v24 = v15;
  if ((int)re::internal::RapidJSONInputStream::next<false>(v4) < 48)
  {
    v34 = 0;
  }
  else
  {
    v34 = 0;
    if ((int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57 && !(v24 >> 53))
    {
      v36 = -1;
      do
      {
        v34 = v36;
        v37 = re::internal::RapidJSONInputStream::next<false>(v4);
        v38 = *(_BYTE **)(v62 + 24);
        if ((uint64_t)(*(_QWORD *)(v62 + 32) - (_QWORD)v38) <= 0)
        {
          rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
          v38 = *(_BYTE **)(v62 + 24);
        }
        *(_QWORD *)(v62 + 24) = v38 + 1;
        *v38 = v37;
        v35 = ++v63;
        v4 = v61;
        v24 = re::internal::RapidJSONInputStream::next<true>(v61) - 48 + 10 * v24;
        if (v24)
          ++v18;
        if ((int)re::internal::RapidJSONInputStream::next<false>(v61) <= 47)
          break;
        if ((int)re::internal::RapidJSONInputStream::next<false>(v61) > 57)
          break;
        v36 = v34 - 1;
      }
      while (!(v24 >> 53));
      goto LABEL_101;
    }
  }
  v35 = v14;
LABEL_101:
  v17 = (double)v24;
LABEL_102:
  if ((int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48
    && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
  {
    do
    {
      v41 = re::internal::RapidJSONInputStream::next<false>(v4);
      v42 = *(_BYTE **)(v62 + 24);
      v43 = *(_QWORD *)(v62 + 32) - (_QWORD)v42;
      if (v18 > 16)
      {
        if (v43 <= 0)
        {
          rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
          v42 = *(_BYTE **)(v62 + 24);
        }
        *(_QWORD *)(v62 + 24) = v42 + 1;
        *v42 = v41;
        v35 = ++v63;
        v4 = v61;
        re::internal::RapidJSONInputStream::next<true>(v61);
      }
      else
      {
        if (v43 <= 0)
        {
          rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
          v42 = *(_BYTE **)(v62 + 24);
        }
        *(_QWORD *)(v62 + 24) = v42 + 1;
        *v42 = v41;
        v35 = ++v63;
        v4 = v61;
        v17 = (double)(int)(re::internal::RapidJSONInputStream::next<true>(v61) - 48) + v17 * 10.0;
        --v34;
        if (v17 > 0.0)
          ++v18;
      }
    }
    while ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 47
         && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57);
  }
  v23 = 1;
LABEL_115:
  if (re::internal::RapidJSONInputStream::next<false>(v4) == 101
    || re::internal::RapidJSONInputStream::next<false>(v4) == 69)
  {
    re::internal::RapidJSONInputStream::next<true>(v4);
    if (!v25)
    {
      v44 = v15;
      if (v26)
        v44 = v24;
      if (!v23)
        v17 = (double)v44;
      v45 = re::internal::RapidJSONInputStream::next<false>(v4);
      v46 = v45 != 43;
      if (v45 == 43 || (v56 = re::internal::RapidJSONInputStream::next<false>(v4), v56 == 45))
        re::internal::RapidJSONInputStream::next<true>(v4);
      else
        v46 = 0;
      v47 = v60;
      if ((int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48
        && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
      {
        v48 = re::internal::RapidJSONInputStream::next<true>(v4) - 48;
        if (v46)
        {
          if ((int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48)
          {
            do
            {
              if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 57)
                break;
              v48 = re::internal::RapidJSONInputStream::next<true>(v4) + 10 * v48 - 48;
              if (v48 > (v34 + 2147483639) / 10 && (int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48)
              {
                do
                {
                  if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 57)
                    break;
                  re::internal::RapidJSONInputStream::next<true>(v4);
                }
                while ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 47);
              }
            }
            while ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 47);
          }
        }
        else
        {
          while ((int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48
               && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
          {
            v48 = re::internal::RapidJSONInputStream::next<true>(v4) + 10 * v48 - 48;
            if (v48 > 308 - v34)
              goto LABEL_145;
          }
        }
        if (v46)
          v49 = -v48;
        else
          v49 = v48;
        v50 = (char *)rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::NumberStream<re::internal::RapidJSONInputStream,char,true,false>::Pop((uint64_t)&v61);
        goto LABEL_144;
      }
      v6 = v4 + 4;
      v39 = 15;
LABEL_156:
      v53 = *v6;
      v52 = v59;
      goto LABEL_147;
    }
    goto LABEL_153;
  }
  v55 = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::NumberStream<re::internal::RapidJSONInputStream,char,true,false>::Pop((uint64_t)&v61);
  if (v23)
  {
    v50 = (char *)v55;
    v49 = 0;
    v47 = v60;
LABEL_144:
    v51 = rapidjson::internal::StrtodFullPrecision<char>(v49 + v34, v50, v35, v14, v49, v17);
    if (v51 > 1.79769313e308)
    {
LABEL_145:
      v39 = 13;
LABEL_146:
      v53 = v58;
      v52 = v59;
LABEL_147:
      *(_DWORD *)(v52 + 48) = v39;
      *(_QWORD *)(v52 + 56) = v53;
      return;
    }
    if (v47 == 45)
      v51 = -v51;
    v54 = v57;
LABEL_151:
    if ((rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Double(v54, v51) & 1) != 0)return;
LABEL_181:
    v39 = 16;
    goto LABEL_146;
  }
  if (v25)
  {
    v54 = v57;
    v51 = v17;
    goto LABEL_151;
  }
  if (v26)
  {
    if (v60 == 45)
    {
      if ((rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Int64(v57, -(uint64_t)v24) & 1) == 0)goto LABEL_181;
    }
    else if ((rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Uint64(v57, v24) & 1) == 0)
    {
      goto LABEL_181;
    }
  }
  else if (v60 == 45)
  {
    if ((rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Int(v57, -v15) & 1) == 0)goto LABEL_181;
  }
  else if ((rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Uint(v57, v15) & 1) == 0)
  {
    goto LABEL_181;
  }
}

char *rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(uint64_t a1, uint64_t a2)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  re::internal::RapidJSONAllocator *v7;
  uint64_t v8;
  size_t v9;
  char *result;

  v4 = *(void **)(a1 + 16);
  if (v4)
  {
    v5 = *(_QWORD *)(a1 + 32) - (_QWORD)v4;
    v6 = v5 + ((v5 + 1) >> 1);
    v7 = *(re::internal::RapidJSONAllocator **)a1;
  }
  else
  {
    v7 = *(re::internal::RapidJSONAllocator **)a1;
    if (*(_QWORD *)a1)
    {
      v4 = 0;
    }
    else
    {
      v7 = (re::internal::RapidJSONAllocator *)(*(uint64_t (**)(void *, uint64_t, _QWORD))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                                                  + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 1, 0);
      *(_QWORD *)a1 = v7;
      *(_QWORD *)(a1 + 8) = v7;
      v4 = *(void **)(a1 + 16);
    }
    v6 = *(_QWORD *)(a1 + 40);
    v5 = *(_QWORD *)(a1 + 32) - (_QWORD)v4;
  }
  v8 = *(_QWORD *)(a1 + 24) - (_QWORD)v4;
  if (v6 <= v8 + 24 * a2)
    v9 = v8 + 24 * a2;
  else
    v9 = v6;
  result = (char *)re::internal::RapidJSONAllocator::Realloc(v7, v4, v5, v9);
  *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 24) = &result[v8];
  *(_QWORD *)(a1 + 32) = &result[v9];
  return result;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::String(uint64_t a1, void *a2, int a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v14;
  int v15;

  v8 = a1 + 64;
  v7 = *(_QWORD *)(a1 + 64);
  v9 = *(_QWORD *)(v8 + 8) - v7;
  if (a4)
  {
    if (v9 <= 23)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
      v7 = *(_QWORD *)(a1 + 64);
    }
    *(_QWORD *)(a1 + 64) = v7 + 24;
    v10 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)v7 = 0;
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(v7 + 16) = 0;
    v11 = &rapidjson::GenericStringRef<char>::emptyString;
    if (a2)
      v11 = a2;
    v14 = v11;
    v15 = a3;
    rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::SetStringRaw((_WORD *)v7, (uint64_t)&v14, v10);
  }
  else
  {
    if (v9 <= 23)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
      v7 = *(_QWORD *)(a1 + 64);
    }
    *(_QWORD *)(a1 + 64) = v7 + 24;
    *(_QWORD *)(v7 + 16) = 0;
    v12 = &rapidjson::GenericStringRef<char>::emptyString;
    *(_WORD *)(v7 + 22) = 1029;
    if (a2)
      v12 = a2;
    *(_QWORD *)v7 = 0;
    *(_QWORD *)(v7 + 8) = v12;
    *(_DWORD *)v7 = a3;
  }
  return 1;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseHex4<re::internal::RapidJSONInputStream>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;

  LODWORD(v6) = 0;
  v7 = 4;
  while (1)
  {
    v8 = re::internal::RapidJSONInputStream::next<false>(a2);
    if ((v8 - 48) >= 0xA)
      break;
    v9 = -48;
LABEL_8:
    v6 = (v8 + 16 * v6 + v9);
    re::internal::RapidJSONInputStream::next<true>(a2);
    if (!--v7)
      return v6;
  }
  if ((v8 - 65) < 6)
  {
    v9 = -55;
    goto LABEL_8;
  }
  if ((v8 - 97) < 6)
  {
    v9 = -87;
    goto LABEL_8;
  }
  v6 = 0;
  *(_DWORD *)(a1 + 48) = 8;
  *(_QWORD *)(a1 + 56) = a3;
  return v6;
}

uint64_t *rapidjson::UTF8<char>::Encode<rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::StackStream<char>>(uint64_t *result, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  _BYTE *v5;
  _DWORD *v6;
  unsigned int v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  _BYTE *v16;
  char v17;
  uint64_t v18;
  _BYTE *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  _BYTE *v23;
  unsigned int v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  _BYTE *v28;

  v3 = result;
  if (a2 <= 0x7F)
  {
    v4 = *result;
    v5 = *(_BYTE **)(*result + 24);
    if ((uint64_t)(*(_QWORD *)(*result + 32) - (_QWORD)v5) <= 0)
    {
      result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*result, 1);
      v5 = *(_BYTE **)(v4 + 24);
    }
    *(_QWORD *)(v4 + 24) = v5 + 1;
    *v5 = a2;
    v6 = v3 + 1;
    goto LABEL_27;
  }
  if (a2 <= 0x7FF)
  {
    v7 = (a2 >> 6) | 0xFFFFFFC0;
    v8 = *result;
    v9 = *(_BYTE **)(*result + 24);
    if ((uint64_t)(*(_QWORD *)(*result + 32) - (_QWORD)v9) <= 0)
    {
      result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*result, 1);
      v9 = *(_BYTE **)(v8 + 24);
    }
    *(_QWORD *)(v8 + 24) = v9 + 1;
    *v9 = v7;
    v6 = v3 + 1;
    ++*((_DWORD *)v3 + 2);
LABEL_24:
    v27 = *v3;
    v28 = *(_BYTE **)(v27 + 24);
    if ((uint64_t)(*(_QWORD *)(v27 + 32) - (_QWORD)v28) <= 0)
    {
      result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v27, 1);
      v28 = *(_BYTE **)(v27 + 24);
    }
    *(_QWORD *)(v27 + 24) = v28 + 1;
    *v28 = a2 & 0x3F | 0x80;
    goto LABEL_27;
  }
  v10 = *result;
  v11 = *(_BYTE **)(*result + 24);
  v12 = *(_QWORD *)(*result + 32) - (_QWORD)v11;
  if (HIWORD(a2))
  {
    v20 = (a2 >> 18) | 0xFFFFFFF0;
    if (v12 <= 0)
    {
      result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*result, 1);
      v11 = *(_BYTE **)(v10 + 24);
    }
    *(_QWORD *)(v10 + 24) = v11 + 1;
    *v11 = v20;
    v6 = v3 + 1;
    ++*((_DWORD *)v3 + 2);
    v21 = (a2 >> 12) & 0x3F | 0xFFFFFF80;
    v22 = *v3;
    v23 = *(_BYTE **)(*v3 + 24);
    if ((uint64_t)(*(_QWORD *)(*v3 + 32) - (_QWORD)v23) <= 0)
    {
      result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*v3, 1);
      v21 = (a2 >> 12) & 0x3F | 0xFFFFFF80;
      v23 = *(_BYTE **)(v22 + 24);
    }
    *(_QWORD *)(v22 + 24) = v23 + 1;
    *v23 = v21;
    ++*((_DWORD *)v3 + 2);
    v24 = (a2 >> 6) & 0x3F | 0xFFFFFF80;
    v25 = *v3;
    v26 = *(_BYTE **)(*v3 + 24);
    if ((uint64_t)(*(_QWORD *)(*v3 + 32) - (_QWORD)v26) <= 0)
    {
      result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*v3, 1);
      v24 = (a2 >> 6) & 0x3F | 0xFFFFFF80;
      v26 = *(_BYTE **)(v25 + 24);
    }
    *(_QWORD *)(v25 + 24) = v26 + 1;
    *v26 = v24;
    ++*((_DWORD *)v3 + 2);
    goto LABEL_24;
  }
  v13 = (a2 >> 12) | 0xFFFFFFE0;
  if (v12 <= 0)
  {
    result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*result, 1);
    v11 = *(_BYTE **)(v10 + 24);
  }
  *(_QWORD *)(v10 + 24) = v11 + 1;
  *v11 = v13;
  v6 = v3 + 1;
  ++*((_DWORD *)v3 + 2);
  v14 = (a2 >> 6) & 0x3F | 0xFFFFFF80;
  v15 = *v3;
  v16 = *(_BYTE **)(*v3 + 24);
  if ((uint64_t)(*(_QWORD *)(*v3 + 32) - (_QWORD)v16) <= 0)
  {
    result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*v3, 1);
    v14 = (a2 >> 6) & 0x3F | 0xFFFFFF80;
    v16 = *(_BYTE **)(v15 + 24);
  }
  *(_QWORD *)(v15 + 24) = v16 + 1;
  *v16 = v14;
  ++*((_DWORD *)v3 + 2);
  v17 = a2 & 0x3F | 0x80;
  v18 = *v3;
  v19 = *(_BYTE **)(v18 + 24);
  if ((uint64_t)(*(_QWORD *)(v18 + 32) - (_QWORD)v19) <= 0)
  {
    result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v18, 1);
    v17 = a2 & 0x3F | 0x80;
    v19 = *(_BYTE **)(v18 + 24);
  }
  *(_QWORD *)(v18 + 24) = v19 + 1;
  *v19 = v17;
LABEL_27:
  ++*v6;
  return result;
}

void *rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::SetStringRaw(_WORD *__dst, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  void *result;

  v4 = __dst;
  if (*(_DWORD *)(a2 + 8) > 0x15u)
  {
    __dst[11] = 3077;
    *(_DWORD *)__dst = *(_DWORD *)(a2 + 8);
    v5 = rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Malloc(a3, (*(_DWORD *)(a2 + 8) + 1));
    v4[1] = v5;
    v4 = (_QWORD *)v5;
  }
  else
  {
    __dst[11] = 7173;
    *((_BYTE *)__dst + 21) = 21 - *(_BYTE *)(a2 + 8);
  }
  result = memcpy(v4, *(const void **)a2, *(unsigned int *)(a2 + 8));
  *((_BYTE *)v4 + *(unsigned int *)(a2 + 8)) = 0;
  return result;
}

uint64_t rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Malloc(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  unint64_t v8;

  if (!a2)
    return 0;
  v3 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  v4 = **(_QWORD ***)(a1 + 16);
  v5 = v4[1];
  v6 = v5 + v3;
  if (v5 + v3 <= *v4)
  {
LABEL_3:
    result = (uint64_t)v4 + v5 + 24;
    v4[1] = v6;
    return result;
  }
  if (*(_QWORD *)a1 <= v3)
    v8 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  else
    v8 = *(_QWORD *)a1;
  if (rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::AddChunk(a1, v8))
  {
    v4 = **(_QWORD ***)(a1 + 16);
    v5 = v4[1];
    v6 = v5 + v3;
    goto LABEL_3;
  }
  return 0;
}

BOOL rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::AddChunk(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;

  if (!*(_QWORD *)(a1 + 8))
  {
    v4 = (*(uint64_t (**)(void *, uint64_t, _QWORD))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                            + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 1, 0);
    *(_QWORD *)(a1 + 8) = v4;
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8) = v4;
  }
  v5 = (_QWORD *)(*(uint64_t (**)(void *, uint64_t, _QWORD))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                    + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, a2 + 24, 0);
  if (v5)
  {
    *v5 = a2;
    v5[1] = 0;
    v6 = *(_QWORD **)(a1 + 16);
    v5[2] = *v6;
    *v6 = v5;
  }
  return v5 != 0;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::StartObject(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 64);
  if (*(_QWORD *)(a1 + 72) - v2 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    v2 = *(_QWORD *)(a1 + 64);
  }
  *(_QWORD *)(a1 + 64) = v2 + 24;
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)v2 = 0;
  *(_WORD *)(v2 + 22) = 3;
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndObject(uint64_t a1, unsigned int a2)
{
  _WORD *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  v3 = (_WORD *)(*(_QWORD *)(a1 + 64) - 48 * a2);
  *(_QWORD *)(a1 + 64) = v3;
  v4 = *(_QWORD *)(a1 + 24);
  *(v3 - 1) = 3;
  if (a2)
  {
    v5 = 48 * a2;
    v6 = (void *)rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Malloc(v4, v5);
    *((_QWORD *)v3 - 2) = v6;
    memcpy(v6, v3, v5);
  }
  else
  {
    *((_QWORD *)v3 - 2) = 0;
  }
  *((_DWORD *)v3 - 6) = a2;
  *((_DWORD *)v3 - 5) = a2;
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::StartArray(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 64);
  if (*(_QWORD *)(a1 + 72) - v2 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    v2 = *(_QWORD *)(a1 + 64);
  }
  *(_QWORD *)(a1 + 64) = v2 + 24;
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)v2 = 0;
  *(_WORD *)(v2 + 22) = 4;
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndArray(uint64_t a1, unsigned int a2)
{
  _WORD *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  v3 = (_WORD *)(*(_QWORD *)(a1 + 64) - 24 * a2);
  *(_QWORD *)(a1 + 64) = v3;
  v4 = *(_QWORD *)(a1 + 24);
  *(v3 - 1) = 4;
  if (a2)
  {
    v5 = 24 * a2;
    v6 = (void *)rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Malloc(v4, v5);
    *((_QWORD *)v3 - 2) = v6;
    memcpy(v6, v3, v5);
  }
  else
  {
    *((_QWORD *)v3 - 2) = 0;
  }
  *((_DWORD *)v3 - 6) = a2;
  *((_DWORD *)v3 - 5) = a2;
  return 1;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::NumberStream<re::internal::RapidJSONInputStream,char,true,false>::Pop(uint64_t a1)
{
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_BYTE **)(v2 + 24);
  if ((uint64_t)(*(_QWORD *)(v2 + 32) - (_QWORD)v3) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*(_QWORD *)(a1 + 8), 1);
    v3 = *(_BYTE **)(v2 + 24);
  }
  *(_QWORD *)(v2 + 24) = v3 + 1;
  *v3 = 0;
  v4 = (*(_DWORD *)(a1 + 16) + 1);
  *(_DWORD *)(a1 + 16) = v4;
  v5 = *(_QWORD *)(a1 + 8);
  result = *(_QWORD *)(v5 + 24) - v4;
  *(_QWORD *)(v5 + 24) = result;
  return result;
}

double rapidjson::internal::StrtodFullPrecision<char>(unsigned int a1, char *a2, int a3, int a4, int a5, double a6)
{
  double v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  unint64_t v13;
  const rapidjson::internal::BigInteger *v14;
  BOOL v15;
  int v16;
  double v17;
  double v18;
  double v20;
  unint64_t v21[417];

  v20 = 0.0;
  if (a1 - 23 >= 0xF)
  {
    if (a6 <= 9.00719925e15 && a1 + 22 < 0x2D)
    {
      if ((a1 & 0x80000000) != 0)
        return a6 / rapidjson::internal::Pow10(int)::e[-a1];
      return a6 * rapidjson::internal::Pow10(int)::e[a1];
    }
  }
  else
  {
    a6 = rapidjson::internal::Pow10(int)::e[a1 - 22] * a6;
    if (a6 <= 9.00719925e15)
    {
      a1 = 22;
      return a6 * rapidjson::internal::Pow10(int)::e[a1];
    }
  }
  v8 = a4 - a3 + a5;
  v9 = a3 - 1;
  if (a3 < 1)
  {
    if (!a3)
      return 0.0;
  }
  else
  {
    v10 = a3;
    v11 = a3 + 1;
    while (*a2 == 48)
    {
      ++a2;
      --v9;
      --v10;
      if (--v11 <= 1)
        return 0.0;
    }
    while (a2[v9] == 48)
    {
      --v10;
      ++v8;
      --v9;
      if ((unint64_t)(v10 + 1) <= 1)
        return 0.0;
    }
    a3 = v10;
  }
  v12 = a3 - 768;
  if (a3 >= 768)
    v13 = 768;
  else
    v13 = a3;
  if (a3 <= 768)
    v12 = 0;
  v14 = (const rapidjson::internal::BigInteger *)(v12 + v8);
  v7 = 0.0;
  if ((int)v14 + (int)v13 >= -323)
  {
    if ((int)v14 + (int)v13 <= 309)
    {
      v15 = rapidjson::internal::StrtodDiyFp<char>((uint64_t)a2, v13, (int)v14, (unint64_t *)&v20);
      v7 = v20;
      if (!v15)
      {
        rapidjson::internal::BigInteger::BigInteger<char>(v21, a2, v13);
        v16 = rapidjson::internal::CheckWithinHalfULP((rapidjson::internal *)v21, v7, v14);
        *(_QWORD *)&v17 = *(_QWORD *)&v7 + 1;
        if ((LOBYTE(v7) & 1) != 0)
          *(_QWORD *)&v18 = *(_QWORD *)&v7 + 1;
        else
          v18 = v7;
        if (!v16)
          v17 = v18;
        if (v16 >= 0)
          return v17;
      }
    }
    else
    {
      return INFINITY;
    }
  }
  return v7;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Double(uint64_t a1, double a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 64);
  if (*(_QWORD *)(a1 + 72) - v4 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    v4 = *(_QWORD *)(a1 + 64);
  }
  *(_QWORD *)(a1 + 64) = v4 + 24;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(double *)v4 = a2;
  *(_WORD *)(v4 + 22) = 534;
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Int64(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  __int16 v5;
  __int16 v6;

  v4 = *(_QWORD *)(a1 + 64);
  if (*(_QWORD *)(a1 + 72) - v4 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    v4 = *(_QWORD *)(a1 + 64);
  }
  *(_QWORD *)(a1 + 64) = v4 + 24;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)v4 = a2;
  *(_WORD *)(v4 + 22) = 150;
  if ((a2 & 0x8000000000000000) != 0)
  {
    if (a2 >= 0xFFFFFFFF80000000)
    {
      v6 = 182;
      goto LABEL_11;
    }
  }
  else
  {
    if (HIDWORD(a2))
      v5 = 406;
    else
      v5 = 470;
    *(_WORD *)(v4 + 22) = v5;
    if (!(a2 >> 31))
    {
      v6 = v5 | 0x20;
LABEL_11:
      *(_WORD *)(v4 + 22) = v6;
    }
  }
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Uint64(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int16 v5;

  v4 = *(_QWORD *)(a1 + 64);
  if (*(_QWORD *)(a1 + 72) - v4 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    v4 = *(_QWORD *)(a1 + 64);
  }
  *(_QWORD *)(a1 + 64) = v4 + 24;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)v4 = a2;
  if (a2 < 0)
    v5 = 278;
  else
    v5 = 406;
  *(_WORD *)(v4 + 22) = v5;
  if (!HIDWORD(a2))
  {
    *(_WORD *)(v4 + 22) = v5 | 0x40;
    if (!((unint64_t)a2 >> 31))
      *(_WORD *)(v4 + 22) = v5 | 0x60;
  }
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Int(uint64_t a1, int a2)
{
  uint64_t v4;
  __int16 v5;

  v4 = *(_QWORD *)(a1 + 64);
  if (*(_QWORD *)(a1 + 72) - v4 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    v4 = *(_QWORD *)(a1 + 64);
  }
  *(_QWORD *)(a1 + 64) = v4 + 24;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)v4 = a2;
  if (a2 < 0)
    v5 = 182;
  else
    v5 = 502;
  *(_WORD *)(v4 + 22) = v5;
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Uint(uint64_t a1, int a2)
{
  uint64_t v4;
  __int16 v5;

  v4 = *(_QWORD *)(a1 + 64);
  if (*(_QWORD *)(a1 + 72) - v4 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    v4 = *(_QWORD *)(a1 + 64);
  }
  *(_QWORD *)(a1 + 64) = v4 + 24;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)v4 = a2;
  if (a2 < 0)
    v5 = 470;
  else
    v5 = 502;
  *(_WORD *)(v4 + 22) = v5;
  return 1;
}

BOOL rapidjson::internal::StrtodDiyFp<char>(uint64_t a1, int a2, int a3, unint64_t *a4)
{
  uint64_t v6;
  unint64_t v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned __int8 v18;
  int v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  unint64_t v29;
  uint64_t v30;
  BOOL v31;
  int v32;
  int v33;
  unint64_t v34;
  int v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  BOOL v40;
  unint64_t v41;
  _QWORD v44[2];
  unint64_t v45;
  int v46;

  if (a2 < 1)
  {
    LODWORD(v6) = 0;
    v7 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    while (1)
    {
      v8 = *(char *)(a1 + v6);
      if (v7 == 0x1999999999999999 && v8 > 53)
        break;
      v7 = (v8 - 48) + 10 * v7;
      if (++v6 >= (unint64_t)a2 || v7 > 0x1999999999999999)
        goto LABEL_10;
    }
    v7 = 0x1999999999999999;
  }
LABEL_10:
  if (a2 > (int)v6 && *(char *)(a1 + v6) > 52)
    ++v7;
  v9 = a2 - v6;
  v10 = __clz(v7);
  v45 = v7 << v10;
  v46 = -v10;
  v11 = (4 * (v9 != 0)) << v10;
  v12 = v9 + a3;
  v13 = (v9 + a3 + 348) >> 3;
  v14 = ((v9 + a3 + 348) & 0xFFFFFFF8) - 348;
  v15 = rapidjson::internal::GetCachedPowerByIndex(unsigned long)::kCachedPowers_F[v13];
  v16 = rapidjson::internal::GetCachedPowerByIndex(unsigned long)::kCachedPowers_E[v13];
  v44[0] = v15;
  v44[1] = v16;
  v17 = v12 - v14;
  if (v12 != v14)
  {
    if ((v18 & 1) == 0
    {
      rapidjson::internal::StrtodDiyFp<char>(char const*,int,int,double *)::kPow10[0] = 0xA000000000000000;
      dword_2558006C0 = -60;
      qword_2558006C8 = 0xC800000000000000;
      dword_2558006D0 = -57;
      qword_2558006D8 = 0xFA00000000000000;
      dword_2558006E0 = -54;
      qword_2558006E8 = 0x9C40000000000000;
      dword_2558006F0 = -50;
      qword_2558006F8 = 0xC350000000000000;
      dword_255800700 = -47;
      qword_255800708 = 0xF424000000000000;
      dword_255800710 = -44;
      qword_255800718 = 0x9896800000000000;
      dword_255800720 = -40;
    }
    v45 = rapidjson::internal::DiyFp::operator*(&v45, &rapidjson::internal::StrtodDiyFp<char>(char const*,int,int,double *)::kPow10[2 * v17 - 2]);
    v46 = v19;
    if (v17 + a2 > 19)
      v11 += 4;
  }
  v20 = rapidjson::internal::DiyFp::operator*(&v45, v44);
  v22 = 8;
  if (v11)
    v22 = 9;
  v23 = __clz(v20);
  v24 = v20 << v23;
  v25 = v21 - v23;
  v26 = (v22 + v11) << v23;
  v27 = v21 - v23 + 1138;
  if (v25 < -1137)
    v27 = 0;
  if (v25 > -1086)
    v27 = 53;
  v28 = 64 - v27;
  v29 = v24 >> (4 - v27);
  v30 = (v26 >> (4 - v27)) + 9;
  v31 = v27 <= 3;
  if (v27 <= 3)
    v32 = 4 - v27 + v25;
  else
    v32 = v25;
  if (v31)
    v24 = v29;
  if (v31)
  {
    v33 = 60;
  }
  else
  {
    LODWORD(v30) = v26;
    v33 = v28;
  }
  v34 = v24 >> v33;
  v35 = v33 + v32;
  v36 = 8 * (v24 & ~(-1 << v33));
  v37 = 8 << (v33 - 1);
  v38 = v37 + v30;
  if (v36 >= v38 && (++v34 & 0x20000000000000) != 0)
  {
    v34 >>= 1;
    ++v35;
  }
  if (v35 >= -1074)
  {
    if (v35 <= 971)
    {
      v40 = (v34 & 0x10000000000000) == 0 && v35 == -1074;
      v41 = (unint64_t)(v35 + 1075) << 52;
      if (v40)
        v41 = 0;
      v39 = v41 & 0xFFF0000000000000 | v34 & 0xFFFFFFFFFFFFFLL;
    }
    else
    {
      v39 = 0x7FF0000000000000;
    }
  }
  else
  {
    v39 = 0;
  }
  *a4 = v39;
  return v37 - (unint64_t)v30 >= v36 || v36 >= v38;
}

uint64_t rapidjson::internal::CheckWithinHalfULP(rapidjson::internal *this, double a2, const rapidjson::internal::BigInteger *a3)
{
  _QWORD *v3;
  int v4;
  unint64_t v5;
  _BOOL4 v6;
  int v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  BOOL v12;
  int v13;
  unsigned int v14;
  int v15;
  signed int v16;
  signed int v17;
  signed int v18;
  signed int v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  rapidjson::internal::BigInteger *v23;
  rapidjson::internal::BigInteger *v24;
  rapidjson::internal::BigInteger *v25;
  unint64_t v26;
  BOOL v27;
  unint64_t v28;
  unint64_t v29;
  _QWORD v31[416];
  unint64_t v32;
  uint64_t v33[416];
  unint64_t v34;
  _QWORD v35[417];
  _BYTE v36[3328];
  uint64_t v37;

  v3 = (_QWORD *)MEMORY[0x24BDAC7A8](this);
  v6 = (v5 & 0x7FF0000000000000) != 0;
  if ((v5 & 0xFFFFFFFFFFFFFLL) == 0)
    v6 = 1;
  v7 = ((v5 >> 52) & 0x7FF) - 1075;
  if (v6)
    v8 = v5 & 0xFFFFFFFFFFFFFLL | 0x10000000000000;
  else
    v8 = v5 & 0xFFFFFFFFFFFFFLL;
  if (!v6)
    v7 = -1074;
  v9 = v7 - 1;
  v10 = v4 & ~(v4 >> 31);
  if (v4 < 0)
    v11 = -v4;
  else
    v11 = 0;
  v12 = v7 <= 0;
  if (v7 < 0)
    v13 = v7;
  else
    v13 = 0;
  v14 = (v7 & ~(v7 >> 31)) + v11;
  if (v12)
    v15 = v9;
  else
    v15 = 0;
  if (v12)
    v9 = 0;
  v16 = v10 - (v13 + v15);
  v17 = v14 - v15;
  v18 = v11 - v13 + v9;
  if (v16 >= v17)
    v19 = v17;
  else
    v19 = v10 - (v13 + v15);
  if (v19 >= v18)
    v19 = v18;
  v20 = (v16 - v19);
  v21 = (v17 - v19);
  v22 = (v18 - v19);
  v37 = v3[416];
  memcpy(v36, v3, 8 * v37);
  v23 = rapidjson::internal::BigInteger::MultiplyPow5((rapidjson::internal::BigInteger *)v36, v10);
  rapidjson::internal::BigInteger::operator<<=(v23, v20);
  v35[416] = 1;
  v35[0] = v8;
  v24 = rapidjson::internal::BigInteger::MultiplyPow5((rapidjson::internal::BigInteger *)v35, v11);
  rapidjson::internal::BigInteger::operator<<=(v24, v21);
  v34 = 1;
  v33[0] = 1;
  v25 = rapidjson::internal::BigInteger::MultiplyPow5((rapidjson::internal::BigInteger *)v33, v11);
  rapidjson::internal::BigInteger::operator<<=(v25, v22);
  v32 = 1;
  v31[0] = 0;
  rapidjson::internal::BigInteger::Difference((uint64_t)v36, (uint64_t)v35, (uint64_t)v31);
  v26 = v32;
  v27 = v32 >= v34;
  if (v32 == v34)
  {
    while (v26)
    {
      v28 = v31[v26 - 1];
      v29 = v33[--v26];
      v27 = v28 >= v29;
      if (v28 != v29)
        goto LABEL_28;
    }
    return 0;
  }
  else
  {
LABEL_28:
    if (v27)
      return 1;
    else
      return 0xFFFFFFFFLL;
  }
}

unint64_t *rapidjson::internal::BigInteger::BigInteger<char>(unint64_t *a1, char *a2, unint64_t a3)
{
  unint64_t v3;
  char *v4;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;

  v3 = a3;
  v4 = a2;
  a1[416] = 1;
  *a1 = 0;
  if (a3 < 0x13)
  {
    v9 = 0;
    if (!a3)
      return a1;
LABEL_7:
    rapidjson::internal::BigInteger::AppendDecimal64<char>(a1, &v4[v9], &v4[v9 + v3]);
    return a1;
  }
  v6 = 0;
  do
  {
    v7 = a2 + 19;
    rapidjson::internal::BigInteger::AppendDecimal64<char>(a1, a2, a2 + 19);
    v6 -= 19;
    v8 = v3 + v6;
    a2 = v7;
  }
  while (v3 + v6 > 0x12);
  v9 = -v6;
  v3 += v6;
  if (v8)
    goto LABEL_7;
  return a1;
}

unint64_t *rapidjson::internal::BigInteger::AppendDecimal64<char>(unint64_t *result, char *a2, char *a3)
{
  uint64_t v3;
  char *v4;
  int v5;
  unsigned int v6;
  unint64_t v7;
  rapidjson::internal::BigInteger *v8;
  unint64_t *v9;

  if (a2 == a3)
  {
    v3 = 0;
  }
  else
  {
    v3 = 0;
    v4 = a2;
    do
    {
      v5 = *v4++;
      v3 = (v5 - 48) + 10 * v3;
    }
    while (v4 != a3);
  }
  if (result[416] == 1 && !*result)
  {
    *result = v3;
    result[416] = 1;
  }
  else
  {
    v6 = (_DWORD)a3 - (_DWORD)a2;
    v7 = v6;
    v8 = rapidjson::internal::BigInteger::MultiplyPow5((rapidjson::internal::BigInteger *)result, v6);
    v9 = rapidjson::internal::BigInteger::operator<<=(v8, v7);
    return rapidjson::internal::BigInteger::operator+=(v9, v3);
  }
  return result;
}

rapidjson::internal::BigInteger *rapidjson::internal::BigInteger::MultiplyPow5(rapidjson::internal::BigInteger *this, unsigned int a2)
{
  unsigned int v3;

  if (a2)
  {
    v3 = a2;
    if (a2 >= 0x1B)
    {
      do
      {
        rapidjson::internal::BigInteger::operator*=((unint64_t *)this, 0x6765C793FA10079DuLL);
        v3 -= 27;
      }
      while (v3 > 0x1A);
    }
    if (v3 >= 0xD)
    {
      do
      {
        rapidjson::internal::BigInteger::operator*=((unint64_t *)this, 0x48C27395u);
        v3 -= 13;
      }
      while (v3 > 0xC);
    }
    if (v3)
      rapidjson::internal::BigInteger::operator*=((unint64_t *)this, rapidjson::internal::BigInteger::MultiplyPow5::kPow5[v3 - 1]);
  }
  return this;
}

_QWORD *rapidjson::internal::BigInteger::operator<<=(_QWORD *__src, unint64_t a2)
{
  uint64_t v3;
  BOOL v4;
  unint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v3 = __src[416];
  if (v3 == 1)
  {
    v4 = *__src == 0;
    if (!a2)
      return __src;
  }
  else
  {
    v4 = 0;
    if (!a2)
      return __src;
  }
  if (!v4)
  {
    v5 = a2 >> 6;
    v6 = a2 & 0x3F;
    if ((a2 & 0x3F) != 0)
    {
      __src[v3] = 0;
      if (v3)
      {
        v7 = v3;
        do
        {
          __src[v5 + v7] = (__src[v7] << v6) | (__src[v7 - 1] >> 1 >> (v6 ^ 0x3Fu));
          --v7;
        }
        while (v7);
      }
      __src[v5] = *__src << v6;
      v8 = v3 + v5;
      __src[416] = v8;
      if (!__src[v8])
        goto LABEL_14;
      v9 = v8 + 1;
    }
    else
    {
      memmove(&__src[v5], __src, 8 * v3);
      v9 = __src[416] + v5;
    }
    __src[416] = v9;
LABEL_14:
    bzero(__src, 8 * v5);
  }
  return __src;
}

unint64_t *rapidjson::internal::BigInteger::operator+=(unint64_t *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v2 = *result;
  v3 = *result + a2;
  *result = v3;
  v4 = result[416];
  if (v4 == 1)
  {
LABEL_5:
    if (result[v4 - 1] < v2)
    {
      result[416] = v4 + 1;
      result[v4] = 1;
    }
  }
  else
  {
    v5 = result + 1;
    v6 = v4 - 1;
    while (v3 < v2)
    {
      v2 = *v5;
      v3 = *v5 + 1;
      *v5++ = v3;
      if (!--v6)
        goto LABEL_5;
    }
  }
  return result;
}

unint64_t *rapidjson::internal::BigInteger::operator*=(unint64_t *result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  if (a2 != 1)
  {
    if (!a2)
    {
      *result = 0;
LABEL_4:
      result[416] = 1;
      return result;
    }
    v2 = result[416];
    if (v2)
    {
      if (v2 == 1 && *result == 1)
      {
        *result = a2;
        goto LABEL_4;
      }
      v3 = 0;
      v4 = a2;
      v5 = HIDWORD(a2);
      v6 = result;
      v7 = result[416];
      do
      {
        v8 = *v6;
        v9 = HIDWORD(*v6);
        v10 = v8 * (unint64_t)v4;
        v11 = v9 * (unint64_t)v4;
        v12 = v9 * (unint64_t)v5;
        v13 = v8 * (unint64_t)v5 + v11 + HIDWORD(v10);
        v14 = v12 + 0x100000000;
        if (v13 >= v11)
          v14 = v12;
        v15 = v14 + HIDWORD(v13);
        v16 = v3 + v10 + (v13 << 32);
        if (v16 >= v3)
          v3 = v15;
        else
          v3 = v15 + 1;
        *v6++ = v16;
        --v7;
      }
      while (v7);
      if (v3)
      {
        result[416] = v2 + 1;
        result[v2] = v3;
      }
    }
  }
  return result;
}

unint64_t *rapidjson::internal::BigInteger::operator*=(unint64_t *result, unsigned int a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;

  if (a2 != 1)
  {
    if (!a2)
    {
      *result = 0;
LABEL_4:
      result[416] = 1;
      return result;
    }
    v2 = result[416];
    if (v2)
    {
      if (v2 == 1 && *result == 1)
      {
        *result = a2;
        goto LABEL_4;
      }
      v3 = 0;
      v4 = result;
      v5 = result[416];
      do
      {
        v6 = v3 + *v4 * (unint64_t)a2;
        v7 = HIDWORD(v6) + HIDWORD(*v4) * a2;
        *v4++ = v6 | ((unint64_t)v7 << 32);
        v3 = HIDWORD(v7);
        --v5;
      }
      while (v5);
      if (v3)
      {
        result[416] = v2 + 1;
        result[v2] = v3;
      }
    }
  }
  return result;
}

uint64_t rapidjson::internal::BigInteger::Difference(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v3 = *(_QWORD *)(a1 + 3328);
  v4 = *(_QWORD *)(a2 + 3328);
  v5 = v3 >= v4;
  if (v3 == v4)
  {
    v6 = *(_QWORD *)(a1 + 3328);
    while (v6)
    {
      v7 = a1 + 8 * v6;
      v8 = a2 + 8 * v6--;
      v9 = *(_QWORD *)(v7 - 8);
      v10 = *(_QWORD *)(v8 - 8);
      v5 = v9 >= v10;
      if (v9 != v10)
        goto LABEL_5;
    }
LABEL_9:
    v11 = a1;
    a1 = a2;
    if (!v3)
      return v6;
    goto LABEL_10;
  }
LABEL_5:
  if (v5)
  {
    v6 = 0;
    goto LABEL_9;
  }
  v6 = 1;
  v3 = *(_QWORD *)(a2 + 3328);
  v11 = a2;
  if (!v3)
    return v6;
LABEL_10:
  v12 = 0;
  v13 = 0;
  do
  {
    v14 = *(_QWORD *)(v11 + 8 * v12);
    v15 = v14 + v13;
    if (v12 < *(_QWORD *)(a1 + 3328))
      v15 -= *(_QWORD *)(a1 + 8 * v12);
    if (v15 <= v14)
      v13 = 0;
    else
      v13 = -1;
    *(_QWORD *)(a3 + 8 * v12++) = v15;
    if (v15)
    {
      *(_QWORD *)(a3 + 3328) = v12;
      v3 = *(_QWORD *)(v11 + 3328);
    }
  }
  while (v12 < v3);
  return v6;
}

_QWORD *rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::ShrinkToFit(_QWORD *result)
{
  _BYTE *v1;
  _BYTE *v2;
  _QWORD *v3;
  size_t v4;
  _QWORD *v5;

  v2 = (_BYTE *)result[2];
  v1 = (_BYTE *)result[3];
  v3 = result + 2;
  v4 = v1 - v2;
  if (v1 == v2)
  {
    if (v1)
      result = (_QWORD *)(*(uint64_t (**)(void *))(*(_QWORD *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                           + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
  }
  else
  {
    v5 = result;
    result = re::internal::RapidJSONAllocator::Realloc((re::internal::RapidJSONAllocator *)*result, v2, result[4] - (_QWORD)v2, v4);
    v5[2] = result;
    v5[3] = (char *)result + v4;
    v5[4] = (char *)result + v4;
  }
  return result;
}

void re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *v6;
  BOOL v7;
  uint64_t v8;
  _QWORD v9[2];

  v5 = *(_QWORD *)(a1 + 192);
  v6 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5)
    v7 = v6 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = *v6;
    v9[0] = v5;
    v9[1] = v8;
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, (uint64_t)v9, a3);
  }
}

uint64_t re::serializeBool<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<BOOL>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<BOOL>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<BOOL>(a1 + 24, a2, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeChar<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<char>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<char>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<char>(a1 + 24, a2, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI8<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<signed char>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<signed char>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<signed char>(a1 + 24, a2, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI16<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<short>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<short>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<short>(a1 + 24, a2, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI32<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<int>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<int>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<int>(a1 + 24, a2, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI64<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<long long>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<long long>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<long long>(a1 + 24, a2, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU8<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint8", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint8", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint8", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU16<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned short>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned short>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned short>(a1 + 24, a2, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU32<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint32", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint32", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint32", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU64<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned long long>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned long long>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned long long>(a1 + 24, a2, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeFloat<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"float", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"float", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"float", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeDouble<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<double>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"double", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::SeekableInputStream>::serializeValue<double>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"double", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::SeekableInputStream>::serializeValue<double>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"double", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::serializeCString<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 v19;
  _BOOL8 result;
  _BOOL4 v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  size_t v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  size_t v44;
  int v45;
  char v46;
  size_t v47;
  int v48;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_22:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v23 = **((_QWORD **)a5 + 2);
    v24 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24)
      goto LABEL_22;
    v26 = WORD1(v23) == WORD1(v24);
    v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    v26 = v26 && v25 == 0;
    if (!v26)
      goto LABEL_22;
  }
LABEL_4:
  if (a7)
  {
    v48 = 0;
    v19 = re::EncoderBinary<re::SeekableInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
    result = 0;
    if (!v19)
      return result;
    if (!v48)
      goto LABEL_12;
    if (v48 != 1)
    {
      v47 = 0;
      if (re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v47, 0))
      {
        if (v47)
          re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
        re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
LABEL_12:
      re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      goto LABEL_47;
    }
    goto LABEL_16;
  }
  v48 = 2 * (*a4 != 0);
  v21 = re::EncoderBinary<re::SeekableInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
  result = 0;
  if (!v21)
    return result;
  v22 = v48;
  if (v48)
  {
    if (v48 == 1)
    {
LABEL_16:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, v46);
      return 0;
    }
  }
  else
  {
    if (!*a4)
      goto LABEL_44;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
    *a4 = 0;
    v22 = v48;
  }
  if (v22 == 2)
  {
    v27 = *a4 ? strlen(*a4) : 0;
    v47 = v27;
    if (re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v47, 0))
    {
      v28 = (char *)*a4;
      v29 = v47;
      if (!*a4 || v47 != v27)
      {
        if (v28)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
          *a4 = 0;
          v29 = v47;
        }
        v30 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        v36 = v47;
        if (v29 > v30)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v37, v38, v39, v40, v41, v36);
          return 0;
        }
        v42 = v47 == -1;
        v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, v47);
          return 0;
        }
        v28 = (char *)(*(uint64_t (**)(_QWORD, size_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v47 + 1, 0);
        *a4 = v28;
        v27 = v47;
      }
      if (v27)
      {
        re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, v28, 0);
        v28 = (char *)*a4;
        v44 = v47;
      }
      else
      {
        v44 = 0;
      }
      v28[v44] = 0;
      re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    }
  }
LABEL_44:
  re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  v45 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(_BYTE *)(a1 + 64))
    return v45 == 0;
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  v45 = *(unsigned __int8 *)(a1 + 64);
  return v45 == 0;
}

BOOL re::serializeStringID<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  _anonymous_namespace_ *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v47 = 0;
    v20 = re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v47, 0);
    result = 0;
    if (!v20)
      return result;
    if (v47)
      re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    goto LABEL_26;
  }
  v46 = 0;
  if (re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v46, 0))
  {
    v22 = v46;
    if (v46)
    {
      v23 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
      v29 = v46;
      if (v22 > v23)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v30, v31, v32, v33, v34, v29);
        return 0;
      }
      v36 = v46 == -1;
      v37 = v36 << 63 >> 63;
      if (v37 != v36 || v37 < 0)
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v24, v25, v26, v27, v28, v46);
        return 0;
      }
      v38 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56), v46 + 1, 0);
      v39 = (_anonymous_namespace_ *)re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, v38, 0);
      v38[v46] = 0;
      v44 = 0;
      v45 = &str_110;
      v40 = v44;
      v41 = (uint64_t)v45;
      v44 = 0;
      v45 = &str_110;
      v42 = *a4;
      v43 = a4[1];
      *a4 = v40;
      a4[1] = v41;
      v47 = v40 & 0xFFFFFFFFFFFFFFFELL | v42 & 1;
      v48 = v43;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v38);
    }
    else
    {
      v44 = 0;
      v45 = &str_110;
      v35 = a4[1];
      v47 = *a4 & 1;
      v48 = v35;
      *a4 = 0;
      a4[1] = (uint64_t)&str_110;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
    }
LABEL_26:
    re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  _BOOL4 v14;
  _BOOL8 result;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  re *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  unint64_t v35;
  _BYTE buf[22];
  __int16 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v27 = **((_QWORD **)a5 + 2);
    v28 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v27 == (unsigned __int16)v28)
    {
      v30 = WORD1(v27) == WORD1(v28);
      v29 = (v28 ^ v27) & 0xFFFFFF00000000;
      v30 = v30 && v29 == 0;
      if (v30)
        goto LABEL_4;
    }
LABEL_32:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_32;
LABEL_4:
  if (a7)
  {
    v31 = 0;
    v14 = re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v31, 0);
    result = 0;
    if (!v14)
      return result;
    if (v31)
      re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
  }
  else
  {
    v16 = **((_QWORD **)a5 + 2);
    v31 = *(_QWORD *)a5;
    v32 = v16;
    LODWORD(v33) = -1;
    *(_QWORD *)buf = 0x258C98EAAF29A10ALL;
    *(_QWORD *)&buf[8] = "CallbackSerializerAttribute";
    v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v31, buf);
    re::StringID::destroyString((re::StringID *)buf);
    v18 = *v17;
    v19 = *(_QWORD *)(a1 + 184);
    v35 = 0;
    result = re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v35, 0);
    if (!result)
      return result;
    v20 = *(_QWORD *)(a1 + 56);
    v33 = 0;
    v34 = 0;
    v31 = v20;
    v32 = 0;
    re::DynamicString::setCapacity(&v31, 0);
    if (v35)
    {
      re::DynamicString::resize(&v31, v35, 0);
      if ((v32 & 1) != 0)
        v21 = v33;
      else
        v21 = (char *)&v32 + 1;
      re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, v21, 0);
    }
    re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    v22 = (char *)&v32 + 1;
    if ((v32 & 1) != 0)
      v23 = v33;
    else
      v23 = (char *)&v32 + 1;
    v24 = (re *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, char *))(v18 + 80))(*(_QWORD *)(a1 + 48), v19, v18, a4, v23);
    if ((v24 & 1) == 0)
    {
      v25 = *re::foundationSerializationLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        if ((v32 & 1) != 0)
          v22 = v33;
        v26 = re::TypeInfo::name(a5)[1];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v22;
        v37 = 2080;
        v38 = v26;
        _os_log_impl(&dword_224FE9000, v25, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);
      }
    }
    if (v31 && (v32 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v31 + 40))();
  }
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::EncoderBinary<re::SeekableInputStream>::beginPointer(_anonymous_namespace_ *a1, const char *a2, uint64_t a3, int *a4, int a5)
{
  int v10;
  uint64_t v11;
  _BYTE *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  _BYTE v20[23];
  _OWORD v21[2];
  char v22;

  if (*((_BYTE *)a1 + 40))
    return 0;
  v22 = 78;
  re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned char>((uint64_t)a1, a2, 0, &v22, (uint64_t)"uint8", 2);
  switch(v22)
  {
    case 'I':
      v10 = 2;
      break;
    case 'N':
      v10 = 0;
      v11 = 0;
      goto LABEL_10;
    case 'R':
      v10 = 1;
      break;
    default:
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, 0, (re::DynamicString *)&v18);
      if ((v19 & 1) != 0)
        v12 = *(_BYTE **)&v20[7];
      else
        v12 = v20;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". Invalid tag.", (re::DynamicString *)v21, v12);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v21);
      if (*(_QWORD *)&v21[0])
      {
        if ((BYTE8(v21[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v21[0] + 40))();
        memset(v21, 0, sizeof(v21));
      }
      if (v18)
      {
        if ((v19 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v18 + 40))();
      }
      return 0;
  }
  v11 = 1;
LABEL_10:
  *a4 = v10;
  LOBYTE(v13) = 9;
  DWORD1(v13) = a5;
  *((_QWORD *)&v13 + 1) = a2;
  v14 = 0;
  v16 = 0;
  v17 = 0;
  v15 = v11;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v13);
  return *((_BYTE *)a1 + 40) == 0;
}

_anonymous_namespace_ *re::EncoderBinary<re::SeekableInputStream>::endPointer(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  _anonymous_namespace_ *v4;
  char v5;
  _BYTE v6[23];
  _OWORD v7[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 9);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v4);
      if ((v5 & 1) != 0)
        v3 = *(_BYTE **)&v6[7];
      else
        v3 = v6;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". No value was provided.", (re::DynamicString *)v7, v3);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v7);
      if (*(_QWORD *)&v7[0])
      {
        if ((BYTE8(v7[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v7[0] + 40))();
        memset(v7, 0, sizeof(v7));
      }
      result = v4;
      if (v4)
      {
        if ((v5 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v4 + 40))();
      }
    }
  }
  return result;
}

BOOL re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::serializeCString(uint64_t a1, const char *a2, const re::TypeInfo *a3, char **a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _anonymous_namespace_ *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  __int128 v44;
  _QWORD *v45;
  unsigned __int16 v46;
  unsigned __int16 v47;
  int v48;
  unsigned int v49;
  int v50;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_15:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 != (unsigned __int16)v15)
      goto LABEL_15;
    v17 = WORD1(v14) == WORD1(v15);
    v16 = (v15 ^ v14) & 0xFFFFFF00000000;
    v17 = v17 && v16 == 0;
    if (!v17)
      goto LABEL_15;
  }
LABEL_4:
  v50 = 0;
  if (re::EncoderBinary<re::SeekableInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v50, 0))
  {
    if (v50 == 1)
    {
      v49 = 0;
      if (!*(_BYTE *)(a1 + 64))
      {
        re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, "ID", 0, (char *)&v49, (uint64_t)"Reference ID", 0);
        if (!*(_BYTE *)(a1 + 64))
        {
          if (*(_QWORD *)(a1 + 328) <= (unint64_t)v49)
          {
            re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid reference ID for shared object: %u", v19, v20, v21, v22, v23, v49);
          }
          else
          {
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v49, (uint64_t)&v45);
            if (v45 == *(_QWORD **)a5)
            {
              v24 = **((_QWORD **)a5 + 2);
              if (v46 == (unsigned __int16)v24 && v47 == WORD1(v24) && ((v48 ^ HIDWORD(v24)) & 0xFFFFFF) == 0)
              {
                if ((a7 & 1) == 0)
                {
                  if (*a4)
                  {
                    v42 = *a4;
                    if (v42 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v49))
                    {
                      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48), *a4);
                      *a4 = 0;
                    }
                  }
                  *a4 = (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v49);
                  re::internal::SharedObjectGraph::addReference((_QWORD *)(a1 + 256), v49);
                }
                goto LABEL_37;
              }
            }
            v25 = *(_anonymous_namespace_ **)(a1 + 192);
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v49, (uint64_t)&v45);
            v43 = *((_QWORD *)re::TypeRegistry::typeName(v25, &v45) + 1);
            re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid reference ID for shared object. Expected type \"char *\". Actual type \"%s\".", v26, v27, v28, v29, v30, v43);
          }
        }
      }
    }
    else
    {
      if (!v50)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
            *a4 = 0;
          }
        }
LABEL_37:
        re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        return *(_BYTE *)(a1 + 64) == 0;
      }
      if ((a7 & 1) == 0 && *a4)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
        *a4 = 0;
      }
      v45 = 0;
      if (re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v45, 0))
      {
        v36 = v45 == (_QWORD *)-1;
        v37 = v36 << 63 >> 63;
        if (v37 == v36 && (v37 & 0x8000000000000000) == 0)
        {
          v38 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), (uint64_t)v45 + 1, 0);
          v39 = (uint64_t)v38;
          if ((a7 & 1) == 0)
            *a4 = v38;
          v40 = v45;
          if (v45)
          {
            re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, v38, 0);
            v40 = v45;
          }
          *((_BYTE *)v40 + v39) = 0;
          re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
          v41 = **((_QWORD **)a5 + 2);
          *(_QWORD *)&v44 = *(_QWORD *)a5;
          *((_QWORD *)&v44 + 1) = v41;
          re::internal::SharedObjectGraph::addObject(a1 + 256, v39, &v44);
          goto LABEL_37;
        }
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, (char)v45);
      }
    }
  }
  return 0;
}

BOOL re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  const re::TypeInfo *v14;
  _BOOL4 isPointerToPolymorphicType;
  int v16;
  re *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t *v30;
  uint64_t *v31;
  char *v33;
  uint64_t v34;
  char **v35;
  void **v36;
  re::TypeInfo *v37;
  re::TypeRegistry *v38;
  re::TypeRegistry *v39;
  uint64_t *v40;
  char *v41;
  uint64_t v42;
  re *v43;
  uint64_t v44;
  _anonymous_namespace_ *v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t *v53;
  re *v54;
  re *v55;
  NSObject *v56;
  uint64_t v57;
  void **Instance;
  void **v59;
  void (*v60)(uint64_t);
  uint64_t v61;
  __int128 v62;
  re *v63[2];
  _BYTE v64[20];
  int v65;
  _QWORD v66[2];
  uint64_t v67;
  re *v68[2];
  re *v69[4];
  _QWORD v70[2];
  re **v71;
  _QWORD v72[2];
  re *v73[2];
  _QWORD v74[2];
  re *v75[4];
  re *v76[2];
  uint64_t v77;
  __int128 buf;
  __int128 v79;
  __int128 v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v26 = **((_QWORD **)this + 2);
    v27 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v26 == (unsigned __int16)v27)
    {
      v29 = WORD1(v26) == WORD1(v27);
      v28 = (v27 ^ v26) & 0xFFFFFF00000000;
      v29 = v29 && v28 == 0;
      if (v29)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    v16 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v30 = re::TypeInfo::name(this), v31 = re::TypeInfo::name(a6), !re::StringID::operator==(v30, v31))))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, this, a6);
    return 0;
  }
  v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &buf);
  re::TypeInfo::TypeInfo((uint64_t)v70, (uint64_t)&buf + 8);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &buf);
  re::TypeInfo::TypeInfo((uint64_t)v69, (uint64_t)&buf + 8);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v17 = *v71;
    v68[0] = (re *)v70[0];
    v68[1] = v17;
    if (v70[0])
      goto LABEL_8;
LABEL_15:
    v61 = re::TypeInfo::name(this)[1];
    v23 = "Failed to get actual type of polymorphic object. Type \"%s\".";
    v24 = a1;
    v25 = a2;
LABEL_16:
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v24, v25, v23, v18, v19, v20, v21, v22, v61);
    return 0;
  }
  re::internal::actualType(a4, (void **)this, v68);
  if (!v68[0])
    goto LABEL_15;
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v68, &buf);
  re::TypeInfo::TypeInfo((uint64_t)v66, (uint64_t)&buf + 8);
  v65 = 0;
  if (re::EncoderBinary<re::SeekableInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, a3, &v65, 0))
  {
    if (v65 != 1)
    {
      if (!v65)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v66, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
            *a4 = 0;
          }
        }
        goto LABEL_64;
      }
      if (isPointerToPolymorphicType)
      {
        if (*(_BYTE *)(a1 + 64))
          goto LABEL_64;
        LOBYTE(buf) = 1;
        DWORD1(buf) = 0;
        *((_QWORD *)&buf + 1) = a2;
        v79 = 0u;
        v80 = 0u;
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), &buf);
        v77 = 0;
        if ((re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned long long>(a1 + 24, "customClassID", (char *)&v77, 0) & 1) == 0)goto LABEL_64;
        re::TypeInfo::typeIDForCustomClassID((re::TypeInfo *)v69, v77, v76);
        if (v76[0])
        {
          if ((a7 & 1) == 0 && *a4)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v66, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
            *a4 = 0;
          }
          re::TypeRegistry::typeInfo(v69[0], v76, &buf);
          v37 = (re::TypeInfo *)re::TypeInfo::TypeInfo((uint64_t)v75, (uint64_t)&buf + 8);
          if (v16)
          {
            v38 = *(re::TypeRegistry **)(a1 + 192);
          }
          else
          {
            v38 = *(re::TypeRegistry **)(a1 + 192);
            if (*(re::TypeRegistry **)this == v38)
            {
              re::TypeInfo::operator=((uint64_t)v66, (uint64_t)v75);
              v54 = v76[0];
              v55 = v76[1];
              goto LABEL_79;
            }
          }
          v52 = re::TypeInfo::name(v37);
          v53 = re::TypeRegistry::typeInfo(v38, (const re::StringID *)v52, &buf);
          if (!(_BYTE)buf || !*(_BYTE *)(*((_QWORD *)&v79 + 1) + 120))
          {
            v56 = *re::foundationSerializationLogObjects((re *)v53);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              v57 = re::TypeInfo::name((re::TypeInfo *)v75)[1];
              LODWORD(buf) = 136315138;
              *(_QWORD *)((char *)&buf + 4) = v57;
              _os_log_impl(&dword_224FE9000, v56, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", (uint8_t *)&buf, 0xCu);
            }
            v74[0] = 0;
            v74[1] = 0xFFFFFFFFLL;
            (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)a1 + 16))(a1, 0, v74);
            if (!*(_BYTE *)(a1 + 64))
              (*(void (**)(uint64_t, const char *, uint64_t, _QWORD, re **, re **, uint64_t))(*(_QWORD *)a1 + 72))(a1, "object", 10, 0, v75, v75, 1);
            goto LABEL_83;
          }
          re::TypeInfo::operator=((uint64_t)v66, (uint64_t)&buf + 8);
          v54 = (re *)v66[0];
          v55 = *(re **)v67;
LABEL_79:
          Instance = re::TypeInfo::createInstance((re::TypeInfo *)v66, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
          v59 = Instance;
          if ((a7 & 1) == 0)
          {
            *a4 = (char *)Instance;
            v73[0] = v54;
            v73[1] = v55;
            re::internal::setActualType(a4, (re **)this, v73);
          }
          v72[0] = v54;
          v72[1] = v55;
          (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)a1 + 16))(a1, v59, v72);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, uint64_t, void **, _QWORD *, re **, BOOL))(*(_QWORD *)a1 + 72))(a1, "object", 10, v59, v66, v75, v59 == 0);
LABEL_83:
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
          re::EncoderBinary<re::SeekableInputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
          goto LABEL_64;
        }
        v46 = re::TypeInfo::name((re::TypeInfo *)v69);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Unknown polymorphic \"%s\" type. Custom class ID = %llu", v47, v48, v49, v50, v51, v46[1]);
LABEL_64:
        re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        return *(_BYTE *)(a1 + 64) == 0;
      }
      if (!a7)
      {
        v41 = *a4;
        if (!*a4)
          v41 = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v70, *(re::Allocator **)(a1 + 48), 0);
        v42 = 0;
        *a4 = v41;
        goto LABEL_60;
      }
      v39 = *(re::TypeRegistry **)(a1 + 192);
      if ((re::TypeRegistry *)v70[0] != v39)
      {
        v40 = re::TypeInfo::name((re::TypeInfo *)v70);
        re::TypeRegistry::typeInfo(v39, (const re::StringID *)v40, &buf);
        if (!(_BYTE)buf)
        {
          v41 = 0;
          v42 = 1;
          goto LABEL_60;
        }
        re::TypeInfo::operator=((uint64_t)v70, (uint64_t)&buf + 8);
      }
      v41 = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v70, *(re::Allocator **)(a1 + 48), 0);
      v42 = 0;
LABEL_60:
      v43 = *v71;
      *(_QWORD *)&v62 = v70[0];
      *((_QWORD *)&v62 + 1) = v43;
      re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 256), (uint64_t)v41, &v62);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, _QWORD *, re **, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, v41, v70, v69, v42);
      if (*(_BYTE *)(a1 + 256))
      {
        --*(_QWORD *)(a1 + 408);
        ++*(_DWORD *)(a1 + 416);
      }
      goto LABEL_64;
    }
    LODWORD(v76[0]) = 0;
    if (!*(_BYTE *)(a1 + 64))
    {
      re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, "ID", 0, (char *)v76, (uint64_t)"Reference ID", 0);
      if (!*(_BYTE *)(a1 + 64))
      {
        if (*(_QWORD *)(a1 + 328) > (unint64_t)LODWORD(v76[0]))
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v76[0], (uint64_t)v64);
          if (!re::internal::areCompatible((re **)this, (uint64_t)v64))
          {
            v44 = re::TypeInfo::name((re::TypeInfo *)v70)[1];
            v45 = *(_anonymous_namespace_ **)(a1 + 192);
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v76[0], (uint64_t)&buf);
            LOBYTE(v61) = v44;
            re::TypeRegistry::typeName(v45, &buf);
            v23 = "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".";
            goto LABEL_68;
          }
          if ((a7 & 1) != 0)
            goto LABEL_64;
          if (*a4)
          {
            v33 = *a4;
            if (v33 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v76[0]))
            {
              re::TypeInfo::releaseInstance((re::TypeInfo *)v66, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
              *a4 = 0;
            }
          }
          v34 = re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v76[0]);
          v35 = (char **)v34;
          *a4 = (char *)v34;
          if ((*(_BYTE *)(v67 + 49) & 2) != 0)
          {
            v60 = *(void (**)(uint64_t))(v67 + 32);
            if (v60)
              v60(v34);
            re::internal::SharedObjectGraph::addReference((_QWORD *)(a1 + 256), v76[0]);
          }
          else
          {
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v76[0], (uint64_t)v75);
            if (!v75[0])
            {
              LOBYTE(v61) = v76[0];
              v23 = "TypeID for shared object at index %d is invalid.";
              goto LABEL_68;
            }
            re::TypeRegistry::typeInfo(v75[0], v75, &buf);
            if (!(_BYTE)buf)
            {
              LOBYTE(v61) = v76[0];
              v23 = "No TypeInfo found for shared object at index %d.";
              goto LABEL_68;
            }
            v36 = re::TypeInfo::createInstance((re::TypeInfo *)((char *)&buf + 8), *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
            *a4 = (char *)v36;
            if ((re::TypeInfo::copy((re::TypeInfo *)((char *)&buf + 8), v36, v35, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184)) & 1) == 0)
            {
              v61 = re::TypeInfo::name((re::TypeInfo *)((char *)&buf + 8))[1];
              v23 = "Failed to copy non-shareable object of type '%s'.";
LABEL_68:
              v24 = a1;
              v25 = 0;
              goto LABEL_16;
            }
          }
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v76[0], (uint64_t)v63);
          re::TypeInfo::setActualTypeForPointer((_QWORD **)this, (uint64_t)a4, v63);
          goto LABEL_64;
        }
        LOBYTE(v61) = v76[0];
        v23 = "Invalid reference ID for shared object: %u";
        goto LABEL_68;
      }
    }
  }
  return 0;
}

void re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 96 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 96;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::deserializeSharedObjects(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  const char *v22;
  __int128 *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  void **Instance;
  char v38;
  const char *v39;
  const char *v40;
  char v41;
  uint64_t v42;
  unint64_t v43;
  char **v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  char **v49;
  BOOL v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char **v57;
  uint64_t v58;
  void **v59;
  uint64_t v60;
  void (*v61)(char **);
  uint64_t v62;
  re *v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  re *v78[2];
  __int128 v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  _WORD v83[20];
  _DWORD v84[8];
  uint64_t v85;
  unsigned __int16 v86;
  unsigned __int16 v87;
  int v88;
  _BYTE v89[32];
  __int128 v90;
  re *v91[2];
  uint64_t v92;
  _QWORD *v93[4];
  __int16 v94;
  __int128 v95;
  uint64_t v96;
  uint64_t v97;
  const char *v98;
  uint64_t v99;

  if (!*(_BYTE *)(result + 64))
  {
    v9 = result;
    v10 = result + 24;
    result = re::EncoderOPACK<re::SeekableInputStream>::beginObject(result + 24, "@shared", 20, 0);
    if ((result & 1) != 0)
    {
      v16 = *(_QWORD *)(v9 + 56);
      v98 = 0;
      v99 = 0;
      v96 = v16;
      v97 = 0;
      re::DynamicString::setCapacity(&v96, 8uLL);
      v17 = v9 + 400;
      LODWORD(v90) = 0;
      v18 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(v9 + 400, (unsigned int *)&v90);
      if (v18)
        *((_QWORD *)&v95 + 1) = **(_QWORD **)(v18 + 24);
      else
        *((_QWORD *)&v95 + 1) = 0xFFFFFFFFLL;
      if (*(_QWORD *)(v9 + 376))
      {
        v77 = v10;
        v19 = 0;
        v20 = 0;
        LODWORD(v21) = *(_DWORD *)(v9 + 428) - 1;
        v22 = (char *)&v97 + 1;
        do
        {
          v23 = (__int128 *)(*(_QWORD *)(v9 + 392) + v19);
          v90 = *v23;
          re::TypeInfo::TypeInfo((uint64_t)v91, (uint64_t)(v23 + 1));
          re::TypeInfo::TypeInfo((uint64_t)v93, (uint64_t)(v23 + 3));
          v94 = *((_WORD *)v23 + 40);
          if ((v90 & 0x80000000) != 0)
          {
            re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, 0, "Invalid referenceID %u.", v24, v25, v26, v27, v28, v90);
            goto LABEL_69;
          }
          re::TypeRegistry::typeInfo((_QWORD *)v91[0], *(_QWORD *)(v92 + 72), &v80);
          re::TypeInfo::TypeInfo((uint64_t)v89, (uint64_t)&v81);
          re::TypeRegistry::typeInfo(v93[0], v93[2][9], &v80);
          re::TypeInfo::TypeInfo((uint64_t)&v85, (uint64_t)&v81);
          if ((int)v90 > (int)v21)
          {
            re::DynamicString::assignf((re::DynamicString *)&v96, "%u", (_DWORD)v90);
            v21 = v90;
            if ((_BYTE)v94)
            {
              if ((v97 & 1) != 0)
                v29 = v98;
              else
                v29 = v22;
              if (!re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::SeekableInputStream>,false>(v9, v29, v90, *((void ***)&v90 + 1), v91, (re::TypeInfo *)v89, (re::TypeInfo *)&v85, HIBYTE(v94), 0))goto LABEL_62;
            }
            else
            {
              v35 = v22;
              v36 = **((_QWORD **)&v90 + 1);
              if (!**((_QWORD **)&v90 + 1))
              {
                Instance = re::TypeInfo::createInstance((re::TypeInfo *)v89, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                **((_QWORD **)&v90 + 1) = Instance;
                v36 = **((_QWORD **)&v90 + 1);
              }
              v38 = v97;
              v39 = v98;
              re::TypeRegistry::typeInfo((_QWORD *)v91[0], *(_QWORD *)(v92 + 72), &v80);
              re::TypeInfo::TypeInfo((uint64_t)v84, (uint64_t)&v81);
              if (*(_BYTE *)(v9 + 64))
                goto LABEL_67;
              if ((v38 & 1) != 0)
                v40 = v39;
              else
                v40 = v35;
              v22 = v35;
              v41 = (*(uint64_t (**)(uint64_t, const char *, uint64_t, uint64_t, _DWORD *, uint64_t *, _QWORD))(*(_QWORD *)v9 + 72))(v9, v40, v21, v36, v84, &v85, 0);
              v17 = v9 + 400;
              if ((v41 & 1) == 0)
              {
LABEL_62:
                if (!*(_BYTE *)(v9 + 64))
                {
                  if ((v97 & 1) != 0)
                    v64 = v98;
                  else
                    v64 = v22;
                  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, v64, "Failed to deserialize shared object (reference ID = %d).", v30, v31, v32, v33, v34, v21);
                }
LABEL_67:
                if (**((_QWORD **)&v90 + 1))
                {
                  re::TypeInfo::releaseInstance((re::TypeInfo *)v89, **((void ***)&v90 + 1), *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                  **((_QWORD **)&v90 + 1) = 0;
                }
                goto LABEL_69;
              }
            }
            v42 = **((_QWORD **)&v90 + 1);
            v84[0] = v21;
            v80 = v42;
            re::TypeInfo::TypeInfo((uint64_t)&v81, (uint64_t)v89);
            re::TypeInfo::TypeInfo((uint64_t)v83, (uint64_t)&v85);
            v83[16] = v94;
            re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew(v17, v84, (uint64_t)&v80);
          }
          ++v20;
          v43 = *(_QWORD *)(v9 + 376);
          v19 += 88;
        }
        while (v43 > v20);
        *(_QWORD *)&v95 = 0;
        *((_QWORD *)&v95 + 1) = 0xFFFFFFFFLL;
        v10 = v77;
        if (v43)
        {
          v44 = 0;
          v45 = *(_QWORD *)(v9 + 392);
          v46 = 88 * v43;
          v47 = -1;
          do
          {
            re::TypeRegistry::typeInfo(*(_QWORD **)(v45 + 16), *(_QWORD *)(*(_QWORD *)(v45 + 32) + 72), &v90);
            re::TypeInfo::TypeInfo((uint64_t)&v80, (uint64_t)&v90 + 8);
            re::TypeRegistry::typeInfo(*(_QWORD **)(v45 + 48), *(_QWORD *)(*(_QWORD *)(v45 + 64) + 72), &v90);
            re::TypeInfo::TypeInfo((uint64_t)v89, (uint64_t)&v90 + 8);
            v48 = *(_DWORD *)v45;
            if (*(_DWORD *)v45 == v47)
            {
              v79 = v95;
              if (!re::internal::areCompatible((re **)(v45 + 16), (uint64_t)&v79))
              {
                v65 = re::TypeInfo::name((re::TypeInfo *)&v80)[1];
                re::TypeRegistry::typeName(*(_anonymous_namespace_ **)(v9 + 208), &v95);
                re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, 0, "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".", v66, v67, v68, v69, v70, v65);
                goto LABEL_69;
              }
              v49 = **(char ****)(v45 + 8);
              if (v49)
                v50 = v49 == v44;
              else
                v50 = 1;
              if (!v50)
                re::TypeInfo::releaseInstance((re::TypeInfo *)&v80, v49, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
              re::TypeInfo::TypeInfo((uint64_t)&v90, (uint64_t)&v80);
              if (*(_BYTE *)(v45 + 80))
              {
                if (!(_QWORD)v95)
                {
                  v76 = re::TypeInfo::name((re::TypeInfo *)&v80)[1];
                  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, 0, "Invalid reference. Polymorphic type \"%s\" has invalid actual type.", v71, v72, v73, v74, v75, v76);
                  goto LABEL_69;
                }
                LODWORD(v85) = v47;
                v51 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(v17, (unsigned int *)&v85);
                if (!v51)
                {
                  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, 0, "Invalid reference. No such object %z", v52, v53, v54, v55, v56, v47);
                  goto LABEL_69;
                }
                re::TypeInfo::operator=((uint64_t)&v90, v51 + 8);
              }
              v57 = *(char ***)(v45 + 8);
              if ((*((_BYTE *)v82 + 49) & 2) != 0)
              {
                *v57 = (char *)v44;
                v61 = (void (*)(char **))v82[4];
                if (v61)
                  v61(v44);
                if (*(_BYTE *)(v45 + 80))
                {
                  v62 = *(_QWORD *)(v45 + 8);
                  v63 = *(re **)v91[0];
                  v78[0] = (re *)v90;
                  v78[1] = v63;
                  re::TypeInfo::setActualTypeForPointer((_QWORD **)(v45 + 16), v62, v78);
                }
              }
              else
              {
                if (*v57)
                {
                  if (*(_BYTE *)(v45 + 80))
                  {
                    re::TypeInfo::getActualTypeFromPointer((uint64_t)&v80, *v57, &v85);
                    if (v85 != (_QWORD)v90
                      || (v58 = *(_QWORD *)v91[0], v86 != (unsigned __int16)*(_QWORD *)v91[0])
                      || v87 != WORD1(v58)
                      || ((v88 ^ HIDWORD(v58)) & 0xFFFFFF) != 0)
                    {
                      re::TypeInfo::releaseInstance((re::TypeInfo *)&v80, **(void ***)(v45 + 8), *(re::Allocator **)(v9 + 48), 0);
                    }
                  }
                }
                v59 = **(void ****)(v45 + 8);
                if (!v59)
                {
                  **(_QWORD **)(v45 + 8) = re::TypeInfo::createInstance((re::TypeInfo *)&v90, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                  v59 = **(void ****)(v45 + 8);
                }
                re::TypeInfo::copy((re::TypeInfo *)&v90, v59, v44, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
              }
            }
            else if (v48 > v47)
            {
              v44 = **(char ****)(v45 + 8);
              v60 = *v82;
              *(_QWORD *)&v95 = v80;
              *((_QWORD *)&v95 + 1) = v60;
              v47 = v48;
            }
            v45 += 88;
            v46 -= 88;
          }
          while (v46);
        }
      }
      re::EncoderOPACK<re::SeekableInputStream>::endObject(v10);
LABEL_69:
      result = v96;
      if (v96)
      {
        if ((v97 & 1) != 0)
          return (*(uint64_t (**)(void))(*(_QWORD *)v96 + 40))();
      }
    }
    else if (!*(_BYTE *)(v9 + 64) && *(_QWORD *)(v9 + 376))
    {
      return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, "@shared", "Failed to deserialize shared objects. Entry not found.", v11, v12, v13, v14, v15, a9);
    }
  }
  return result;
}

BOOL re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::SeekableInputStream>,false>(uint64_t a1, const char *a2, uint64_t a3, void **a4, re **a5, re::TypeInfo *a6, re::TypeInfo *a7, int a8, char a9)
{
  uint64_t v15;
  int v16;
  _BOOL8 result;
  re::TypeRegistry *v18;
  uint64_t *v19;
  char *v20;
  re::TypeRegistry *v21;
  _BOOL8 v22;
  NSObject *v23;
  char *v24;
  uint64_t *v25;
  uint64_t *v26;
  re *v27;
  re *v28;
  void **Instance;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  _QWORD v34[2];
  re *v35[2];
  _QWORD v36[2];
  _QWORD v37[2];
  _BYTE v38[32];
  uint64_t *v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  re *v43[2];
  uint64_t v44;
  uint8_t buf[4];
  uint64_t v46;
  __int16 v47;
  _BYTE v48[18];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  v15 = a1 + 24;
  v16 = re::EncoderOPACK<re::SeekableInputStream>::beginObject(a1 + 24, a2, 0, 0);
  result = 0;
  if (v16)
  {
    v44 = 0;
    if ((re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(v15, "customClassID", 1, (char *)&v44, 0) & 1) == 0)return 0;
    re::TypeInfo::typeIDForCustomClassID(a7, v44, v43);
    if (v43[0])
    {
      if ((a9 & 1) == 0 && *a4)
      {
        re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
        *a4 = 0;
      }
      re::TypeRegistry::typeInfo(*(re **)a7, v43, buf);
      re::TypeInfo::TypeInfo((uint64_t)&v39, (uint64_t)&v46 + 4);
      if (a8)
      {
        v18 = *(re::TypeRegistry **)(a1 + 208);
      }
      else
      {
        v18 = *(re::TypeRegistry **)(a1 + 208);
        if (*a5 == v18)
        {
          re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&v39);
          v27 = v43[0];
          v28 = v43[1];
          if ((a9 & 1) != 0)
          {
LABEL_30:
            Instance = 0;
            goto LABEL_37;
          }
LABEL_36:
          Instance = re::TypeInfo::createInstance(a6, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
          *a4 = Instance;
          v35[0] = v27;
          v35[1] = v28;
          re::internal::setActualType(a4, a5, v35);
LABEL_37:
          v34[0] = v27;
          v34[1] = v28;
          (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)a1 + 16))(a1, Instance, v34);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, uint64_t, void **, re::TypeInfo *, uint64_t **, BOOL))(*(_QWORD *)a1 + 72))(a1, "object", 10, Instance, a6, &v39, Instance == 0);
LABEL_39:
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
          re::EncoderOPACK<re::SeekableInputStream>::endObject(v15);
          return *(_BYTE *)(a1 + 64) == 0;
        }
      }
      v25 = re::TypeInfo::name((re::TypeInfo *)&v39);
      v26 = re::TypeRegistry::typeInfo(v18, (const re::StringID *)v25, buf);
      if (!buf[0] || !*(_BYTE *)(*(_QWORD *)&v48[10] + 120))
      {
        v30 = *re::foundationSerializationLogObjects((re *)v26);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          v31 = re::TypeInfo::name((re::TypeInfo *)&v39)[1];
          *(_DWORD *)buf = 136315138;
          v46 = v31;
          _os_log_impl(&dword_224FE9000, v30, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", buf, 0xCu);
        }
        v36[0] = 0;
        v36[1] = 0xFFFFFFFFLL;
        (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)a1 + 16))(a1, 0, v36);
        if (!*(_BYTE *)(a1 + 64))
          (*(void (**)(uint64_t, const char *, uint64_t, _QWORD, uint64_t **, uint64_t **, uint64_t))(*(_QWORD *)a1 + 72))(a1, "object", 10, 0, &v39, &v39, 1);
        goto LABEL_39;
      }
      re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&v46 + 4);
      v27 = *(re **)a6;
      v28 = (re *)**((_QWORD **)a6 + 2);
      if ((a9 & 1) != 0)
        goto LABEL_30;
      goto LABEL_36;
    }
    if ((a9 & 1) == 0 && *a4)
    {
      re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
      *a4 = 0;
    }
    v19 = re::TypeInfo::name(a7);
    if ((unint64_t)*v19 >> 1 == 0x36D724013CDDLL)
    {
      v20 = (char *)v19[1];
      if (v20 == "Component" || (v19 = (uint64_t *)strcmp(v20, "Component"), !(_DWORD)v19))
      {
        v19 = (uint64_t *)re::EncoderOPACK<re::SeekableInputStream>::checkForString(v15, 10);
        if ((_DWORD)v19)
        {
          v40 = 0;
          v41 = 0;
          v42 = 0;
          re::DynamicString::setCapacity(&v39, 0);
          v21 = *(re::TypeRegistry **)(a1 + 208);
          v37[0] = 0x2686EB529B3EE220;
          v37[1] = "DynamicString";
          re::TypeRegistry::typeInfo(v21, (const re::StringID *)v37, buf);
          re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v46 + 4);
          re::StringID::destroyString((re::StringID *)v37);
          v22 = re::serializeDynamicString<re::EncoderOPACK<re::SeekableInputStream>>(a1, "object", (const re::TypeInfo *)0xA, &v39, (re *)v38, (const re::TypeInfo *)v38, 0);
          if (v22)
          {
            v23 = *re::foundationSerializationLogObjects((re *)v22);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              if ((v40 & 1) != 0)
                v24 = v41;
              else
                v24 = (char *)&v40 + 1;
              *(_DWORD *)buf = 134218498;
              v46 = v44;
              v47 = 1040;
              *(_DWORD *)v48 = 256;
              *(_WORD *)&v48[4] = 2080;
              *(_QWORD *)&v48[6] = v24;
              _os_log_impl(&dword_224FE9000, v23, OS_LOG_TYPE_DEFAULT, "Skipping unknown Component %llu. String data: %.256s", buf, 0x1Cu);
            }
            if (v39 && (v40 & 1) != 0)
              (*(void (**)(void))(*v39 + 40))();
LABEL_45:
            re::EncoderOPACK<re::SeekableInputStream>::endObject(v15);
            return 1;
          }
          v19 = v39;
          if (v39 && (v40 & 1) != 0)
            v19 = (uint64_t *)(*(uint64_t (**)(void))(*v39 + 40))();
        }
      }
    }
    v32 = *re::foundationSerializationLogObjects((re *)v19);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      v33 = re::TypeInfo::name(a7)[1];
      *(_DWORD *)buf = 136315394;
      v46 = v33;
      v47 = 2048;
      *(_QWORD *)v48 = v44;
      _os_log_impl(&dword_224FE9000, v32, OS_LOG_TYPE_DEFAULT, "Skipping unknown polymorphic \"%s\" type. Custom class ID = %llu", buf, 0x16u);
    }
    goto LABEL_45;
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  v8 = v7 ^ (v7 >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 96 * v13;
    return v12 + 16;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_DWORD *)(v11 + 96 * v10 + 12) != (_DWORD)v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 96 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 96 * v10;
  return v12 + 16;
}

BOOL re::EncoderOPACK<re::SeekableInputStream>::checkForString(uint64_t a1, char a2)
{
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  unsigned __int8 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  unsigned __int8 v13;
  unsigned __int8 __dst;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  __dst = 0;
  v5 = *(_QWORD *)(a1 + 168);
  if (v5)
  {
    v6 = v5 - 1;
    v7 = *(unsigned __int8 *)(a1 + v5 - 1 + 160);
    __dst = v7;
    *(_QWORD *)(a1 + 168) = v6;
  }
  else
  {
    if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL))
    {
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, "check", (uint64_t)"Key");
      return 0;
    }
    v7 = __dst;
  }
  if (v7 != (a2 + 8))
  {
    v10 = *(_QWORD *)(a1 + 168);
    if (v10 <= 7)
    {
      result = 0;
      *(_QWORD *)(a1 + 168) = v10 + 1;
      *(_BYTE *)(a1 + v10 + 160) = v7;
      return result;
    }
    return 0;
  }
  v13 = 0;
  v8 = *(_QWORD *)(a1 + 168);
  if (!*(_BYTE *)(a1 + 40))
  {
    if (v8)
    {
      v11 = v8 - 1;
      v12 = *(unsigned __int8 *)(a1 + v11 + 160);
      *(_QWORD *)(a1 + 168) = v11;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&v13, 1uLL))
      {
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, "check", (uint64_t)"String");
        v8 = *(_QWORD *)(a1 + 168);
        goto LABEL_10;
      }
      v12 = v13;
      v11 = *(_QWORD *)(a1 + 168);
    }
    result = (v12 - 64) < 0x30;
    if (v11 <= 7)
    {
      *(_QWORD *)(a1 + 168) = v11 + 1;
      *(_BYTE *)(a1 + v11 + 160) = v12;
      v8 = *(_QWORD *)(a1 + 168);
      if (v8 <= 7)
        goto LABEL_11;
    }
    return result;
  }
LABEL_10:
  result = 0;
  if (v8 < 8)
  {
LABEL_11:
    v9 = __dst;
    *(_QWORD *)(a1 + 168) = v8 + 1;
    *(_BYTE *)(a1 + v8 + 160) = v9;
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 96 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 96 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 96 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 96 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 96 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 96 * v10) = a3;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 96 * v10 + 12) = *a4;
  v14 = *(_QWORD *)(a1 + 16) + 96 * v10;
  *(_QWORD *)(v14 + 16) = *(_QWORD *)a5;
  re::TypeInfo::TypeInfo(v14 + 24, a5 + 8);
  re::TypeInfo::TypeInfo(v14 + 56, a5 + 40);
  *(_WORD *)(v14 + 88) = *(_WORD *)(a5 + 72);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 12, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 96;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 96 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t *re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *result;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v5 = *(_QWORD *)(a1 + 208);
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5)
    v7 = result == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = *result;
    v10 = a3;
    v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 224, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, _BYTE *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeBool(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeBool(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeBool(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeChar<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI8<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI16<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<short>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<short>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<short>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI32<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, int *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI64<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, _QWORD *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU8<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU16<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU32<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, int *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU64<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeFloat<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeFloat(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeFloat(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeFloat(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeDouble<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::SeekableInputStream>::serializeDouble(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::SeekableInputStream>::serializeDouble(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::SeekableInputStream>::serializeDouble(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::serializeCString<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  _BOOL8 result;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  size_t v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  char v46;
  size_t v47;
  int v48;

  v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_22:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v23 = **((_QWORD **)a5 + 2);
    v24 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24)
      goto LABEL_22;
    v26 = WORD1(v23) == WORD1(v24);
    v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    v26 = v26 && v25 == 0;
    if (!v26)
      goto LABEL_22;
  }
LABEL_4:
  if (a7)
  {
    v48 = 0;
    v19 = re::EncoderOPACK<re::SeekableInputStream>::beginPointer(a1 + 24, a2, v9, &v48, 0);
    result = 0;
    if (!v19)
      return result;
    if (!v48)
      goto LABEL_12;
    if (v48 != 1)
    {
      v47 = 0;
      if (re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, 0, (uint64_t *)&v47, 0))
      {
        if (v47)
          re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
        re::EncoderOPACK<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
LABEL_12:
      re::EncoderOPACK<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      goto LABEL_47;
    }
    goto LABEL_16;
  }
  v48 = 2 * (*a4 != 0);
  v21 = re::EncoderOPACK<re::SeekableInputStream>::beginPointer(a1 + 24, a2, v9, &v48, 0);
  result = 0;
  if (!v21)
    return result;
  v22 = v48;
  if (v48)
  {
    if (v48 == 1)
    {
LABEL_16:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, v46);
      return 0;
    }
  }
  else
  {
    if (!*a4)
      goto LABEL_44;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
    *a4 = 0;
    v22 = v48;
  }
  if (v22 == 2)
  {
    v27 = *a4 ? strlen(*a4) : 0;
    v47 = v27;
    if (re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, 0, (uint64_t *)&v47, 0))
    {
      v28 = (char *)*a4;
      v29 = v47;
      if (!*a4 || v47 != v27)
      {
        if (v28)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
          *a4 = 0;
          v29 = v47;
        }
        v30 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        v36 = v47;
        if (v29 > v30)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v37, v38, v39, v40, v41, v36);
          return 0;
        }
        v42 = v47 == -1;
        v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, v47);
          return 0;
        }
        v28 = (char *)(*(uint64_t (**)(_QWORD, size_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v47 + 1, 0);
        *a4 = v28;
        v27 = v47;
      }
      if (v27)
      {
        re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, v28, 0);
        v28 = (char *)*a4;
        v44 = v47;
      }
      else
      {
        v44 = 0;
      }
      v28[v44] = 0;
      re::EncoderOPACK<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    }
  }
LABEL_44:
  re::EncoderOPACK<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  v45 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(_BYTE *)(a1 + 64))
    return v45 == 0;
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  v45 = *(unsigned __int8 *)(a1 + 64);
  return v45 == 0;
}

BOOL re::serializeStringID<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  int v20;
  _BOOL8 result;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  _anonymous_namespace_ *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;

  v9 = (int)a3;
  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v47 = 0;
    v20 = re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v47, 0);
    result = 0;
    if (!v20)
      return result;
    if (v47)
      re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    goto LABEL_26;
  }
  v46 = 0;
  if (re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v46, 0))
  {
    v22 = v46;
    if (v46)
    {
      v23 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
      v29 = v46;
      if (v22 > v23)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v30, v31, v32, v33, v34, v29);
        return 0;
      }
      v36 = v46 == -1;
      v37 = v36 << 63 >> 63;
      if (v37 != v36 || v37 < 0)
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v24, v25, v26, v27, v28, v46);
        return 0;
      }
      v38 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56), v46 + 1, 0);
      v39 = (_anonymous_namespace_ *)re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, v38, 0);
      v38[v46] = 0;
      v44 = 0;
      v45 = &str_110;
      v40 = v44;
      v41 = (uint64_t)v45;
      v44 = 0;
      v45 = &str_110;
      v42 = *a4;
      v43 = a4[1];
      *a4 = v40;
      a4[1] = v41;
      v47 = v40 & 0xFFFFFFFFFFFFFFFELL | v42 & 1;
      v48 = v43;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v38);
    }
    else
    {
      v44 = 0;
      v45 = &str_110;
      v35 = a4[1];
      v47 = *a4 & 1;
      v48 = v35;
      *a4 = 0;
      a4[1] = (uint64_t)&str_110;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
    }
LABEL_26:
    re::EncoderOPACK<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return 0;
}

uint64_t re::serializeIntrospectionCallbackSerializer<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  int v10;
  int v14;
  uint64_t result;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  re *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  unint64_t v35;
  _BYTE buf[22];
  __int16 v37;
  uint64_t v38;
  uint64_t v39;

  v10 = (int)a3;
  v39 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v27 = **((_QWORD **)a5 + 2);
    v28 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v27 == (unsigned __int16)v28)
    {
      v30 = WORD1(v27) == WORD1(v28);
      v29 = (v28 ^ v27) & 0xFFFFFF00000000;
      v30 = v30 && v29 == 0;
      if (v30)
        goto LABEL_4;
    }
LABEL_32:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_32;
LABEL_4:
  if (a7)
  {
    v31 = 0;
    v14 = re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v10, &v31, 0);
    result = 0;
    if (!v14)
      return result;
    if (v31)
      re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    re::EncoderOPACK<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
  }
  else
  {
    v16 = **((_QWORD **)a5 + 2);
    v31 = *(_QWORD *)a5;
    v32 = v16;
    LODWORD(v33) = -1;
    *(_QWORD *)buf = 0x258C98EAAF29A10ALL;
    *(_QWORD *)&buf[8] = "CallbackSerializerAttribute";
    v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v31, buf);
    re::StringID::destroyString((re::StringID *)buf);
    v18 = *v17;
    v19 = *(_QWORD *)(a1 + 200);
    v35 = 0;
    result = re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v10, (uint64_t *)&v35, 0);
    if (!(_DWORD)result)
      return result;
    v20 = *(_QWORD *)(a1 + 56);
    v33 = 0;
    v34 = 0;
    v31 = v20;
    v32 = 0;
    re::DynamicString::setCapacity(&v31, 0);
    if (v35)
    {
      re::DynamicString::resize(&v31, v35, 0);
      if ((v32 & 1) != 0)
        v21 = v33;
      else
        v21 = (char *)&v32 + 1;
      re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, v21, 0);
    }
    re::EncoderOPACK<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    v22 = (char *)&v32 + 1;
    if ((v32 & 1) != 0)
      v23 = v33;
    else
      v23 = (char *)&v32 + 1;
    v24 = (re *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, char *))(v18 + 80))(*(_QWORD *)(a1 + 48), v19, v18, a4, v23);
    if ((v24 & 1) == 0)
    {
      v25 = *re::foundationSerializationLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        if ((v32 & 1) != 0)
          v22 = v33;
        v26 = re::TypeInfo::name(a5)[1];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v22;
        v37 = 2080;
        v38 = v26;
        _os_log_impl(&dword_224FE9000, v25, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);
      }
    }
    if (v31 && (v32 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v31 + 40))();
  }
  return *(_BYTE *)(a1 + 64) == 0;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginPointer(uint64_t a1, const char *a2, int a3, int *a4, int a5)
{
  uint64_t result;
  _BOOL8 v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  unint64_t v15;
  __int128 v16;
  uint64_t v17;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 __dst;
  uint64_t v22;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v22 = 0;
  result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v22, 0);
  if ((_DWORD)result)
  {
    __dst = 0;
    if (*(_BYTE *)(a1 + 40))
    {
LABEL_5:
      v10 = *a4 != 0;
      LOBYTE(v16) = 9;
      DWORD1(v16) = a5;
      *((_QWORD *)&v16 + 1) = a2;
      v17 = 0;
      v19 = 0;
      v20 = 0;
      v18 = v10;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v16);
      *(_QWORD *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 32) = v22;
      return *(_BYTE *)(a1 + 40) == 0;
    }
    v11 = *(_QWORD *)(a1 + 168);
    if (v11)
    {
      v12 = v11 - 1;
      v13 = *(unsigned __int8 *)(a1 + v11 - 1 + 160);
      __dst = v13;
      *(_QWORD *)(a1 + 168) = v12;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Optional");
        goto LABEL_5;
      }
      v13 = __dst;
    }
    if (v13 == 4)
    {
      *a4 = 0;
    }
    else
    {
      if ((v13 - 7) > 0x2C)
        v14 = 2;
      else
        v14 = 1;
      *a4 = v14;
      v15 = *(_QWORD *)(a1 + 168);
      if (v15 <= 7)
      {
        *(_QWORD *)(a1 + 168) = v15 + 1;
        *(_BYTE *)(a1 + v15 + 160) = v13;
      }
    }
    goto LABEL_5;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endPointer(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  _anonymous_namespace_ *v8;
  char v9;
  _BYTE v10[23];
  _OWORD v11[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14) - 1;
    if (*(_QWORD *)(v2 + 48 * v3 + 32) == *(_QWORD *)(v2 + 48 * v3 + 24))
    {
      for (i = *(_QWORD *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 9);
      v5 = *((_QWORD *)v1 + 16);
      v6 = *((_QWORD *)v1 + 14) - 1;
      if (*(_BYTE *)(v5 + 48 * v6) != 2)
        ++*(_QWORD *)(v5 + 48 * v6 + 32);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v8);
      if ((v9 & 1) != 0)
        v7 = *(_BYTE **)&v10[7];
      else
        v7 = v10;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". No value was provided.", (re::DynamicString *)v11, v7);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v11);
      if (*(_QWORD *)&v11[0])
      {
        if ((BYTE8(v11[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
        memset(v11, 0, sizeof(v11));
      }
      result = v8;
      if (v8 && (v9 & 1) != 0)
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v8 + 40))();
    }
  }
  return result;
}

BOOL re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, uint64_t a7)
{
  const re::TypeInfo *v14;
  _BOOL4 isPointerToPolymorphicType;
  int v16;
  re *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  _DWORD *v34;
  unint64_t v35;
  unsigned int *v36;
  _DWORD *v37;
  unsigned int v38;
  char *Instance;
  unsigned int v40;
  char **v41;
  uint64_t v42;
  _BYTE v43[40];
  unsigned int v44;
  int v45;
  _BYTE v46[32];
  re *v47[2];
  _BYTE v48[32];
  _QWORD v49[5];

  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v24 = **((_QWORD **)this + 2);
    v25 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v24 == (unsigned __int16)v25)
    {
      v27 = WORD1(v24) == WORD1(v25);
      v26 = (v25 ^ v24) & 0xFFFFFF00000000;
      v27 = v27 && v26 == 0;
      if (v27)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    v16 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v28 = re::TypeInfo::name(this), v29 = re::TypeInfo::name(a6), !re::StringID::operator==(v28, v29))))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, this, a6);
    return 0;
  }
  v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v40);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)&v41);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v40);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v41);
  if (isPointerToPolymorphicType && (a7 & 1) == 0)
  {
    re::internal::actualType(a4, (void **)this, v47);
    if (v47[0])
      goto LABEL_8;
LABEL_15:
    v18 = re::TypeInfo::name(this);
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Failed to get actual type of polymorphic object. Type \"%s\".", v19, v20, v21, v22, v23, v18[1]);
    return 0;
  }
  v17 = *(re **)v49[2];
  v47[0] = (re *)v49[0];
  v47[1] = v17;
  if (!v49[0])
    goto LABEL_15;
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v47, &v40);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v41);
  v45 = 0;
  if (!re::EncoderOPACK<re::SeekableInputStream>::beginPointer(a1 + 24, a2, a3, &v45, 0))
    return 0;
  if (v45 == 1)
  {
    v44 = 0;
    if (!*(_BYTE *)(a1 + 64))
    {
      re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned int>((_anonymous_namespace_ *)(a1 + 24), "ID", &v44);
      v31 = *(_QWORD *)(a1 + 152);
      v32 = *(_QWORD *)(a1 + 136) - 1;
      if (*(_BYTE *)(v31 + 48 * v32) != 2)
        ++*(_QWORD *)(v31 + 48 * v32 + 32);
      if (!*(_BYTE *)(a1 + 64))
      {
        if ((a7 & 1) == 0)
        {
          v40 = v44;
          v41 = a4;
          re::TypeInfo::TypeInfo((uint64_t)&v42, (uint64_t)this);
          re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)a6);
          v43[32] = isPointerToPolymorphicType;
          v43[33] = v16;
          v33 = *(_QWORD *)(a1 + 376);
          if (v33)
          {
            v34 = *(_DWORD **)(a1 + 392);
            do
            {
              v35 = v33 >> 1;
              v36 = &v34[22 * (v33 >> 1)];
              v38 = *v36;
              v37 = v36 + 22;
              v33 += ~(v33 >> 1);
              if (v40 < v38)
                v33 = v35;
              else
                v34 = v37;
            }
            while (v33);
          }
          else
          {
            v34 = *(_DWORD **)(a1 + 392);
          }
          re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::insert((_anonymous_namespace_ *)(a1 + 360), 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v34 - *(_QWORD *)(a1 + 392)) >> 3), (uint64_t)&v40);
        }
        goto LABEL_50;
      }
    }
    return 0;
  }
  if (v45)
  {
    if (isPointerToPolymorphicType)
    {
      re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::SeekableInputStream>,false>(a1, a2, a3, (void **)a4, (re **)this, (re::TypeInfo *)v46, (re::TypeInfo *)v48, v16, a7);
    }
    else
    {
      if ((a7 & 1) != 0)
      {
        Instance = 0;
      }
      else
      {
        Instance = *a4;
        if (!*a4)
        {
          Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v49, *(re::Allocator **)(a1 + 48), 0);
          *a4 = Instance;
        }
      }
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, _QWORD *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, Instance, v49, v48, a7);
    }
  }
  else if ((a7 & 1) == 0)
  {
    if (*a4)
    {
      re::TypeInfo::releaseInstance((re::TypeInfo *)v46, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
      *a4 = 0;
    }
  }
LABEL_50:
  re::EncoderOPACK<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  return *(_BYTE *)(a1 + 64) == 0;
}

void re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *v6;
  BOOL v7;
  uint64_t v8;
  _QWORD v9[2];

  v5 = *(_QWORD *)(a1 + 272);
  v6 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5)
    v7 = v6 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = *v6;
    v9[0] = v5;
    v9[1] = v8;
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, (uint64_t)v9, a3);
  }
}

BOOL re::serializeBool<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  unsigned __int8 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)a5 + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int8 *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, v13);
}

BOOL re::serializeChar<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)a5 + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)v13);
}

BOOL re::serializeI8<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)a5 + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, v13);
}

BOOL re::serializeI16<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  __int16 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;

  v19 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)a5 + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, v13);
}

BOOL re::serializeI32<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned int *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  unsigned int *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)a5 + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned int *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, v13);
}

BOOL re::serializeI64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  unint64_t *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)a5 + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unint64_t *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, v13);
}

BOOL re::serializeU8<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  unsigned __int8 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)a5 + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int8 *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, v13);
}

BOOL re::serializeU16<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int16 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  unsigned __int16 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;

  v19 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)a5 + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int16 *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, v13);
}

BOOL re::serializeU32<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned int *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  unsigned int *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (unsigned int *)&v20;
  else
    v14 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, (uint64_t)a3, v14, a7);
}

BOOL re::serializeU64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, rapidjson::internal **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  rapidjson::internal **v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)a5 + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (rapidjson::internal **)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, v13);
}

BOOL re::serializeFloat<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, float *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  float *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (float *)&v20;
  else
    v14 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (uint64_t)a3, v14, a7);
}

BOOL re::serializeDouble<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, double *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  double *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (double *)&v20;
  else
    v14 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (uint64_t)a3, v14, a7);
}

uint64_t re::serializeCString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  int v13;
  uint64_t result;
  _anonymous_namespace_ *v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  const char *v22;
  int v23;

  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v18 = **((_QWORD **)a5 + 2);
    v19 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v18 == (unsigned __int16)v19)
    {
      v21 = WORD1(v18) == WORD1(v19);
      v20 = (v19 ^ v18) & 0xFFFFFF00000000;
      v21 = v21 && v20 == 0;
      if (v21)
        goto LABEL_4;
    }
LABEL_22:
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_22;
LABEL_4:
  if (a7)
  {
    LODWORD(v22) = 0;
    v13 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, (int *)&v22);
    result = 0;
    if (!v13)
      return result;
    v15 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    v16 = *a4;
    v23 = 2 * (*a4 != 0);
    result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v23);
    if (!(_DWORD)result)
      return result;
    if (v16)
    {
      v17 = (const char *)*a4;
      if (*a4)
        v17 = (const char *)strlen(v17);
      v22 = v17;
      if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, 0, (uint64_t *)&v22, 0))
      {
        if (v22)
          re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, *a4, 0);
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    v15 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::SeekableInputStream>::endPointer(v15);
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  _BOOL8 result;
  _BOOL4 v21;
  _anonymous_namespace_ *v22;
  size_t v23;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v23 = 0;
    v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v23, 0);
    result = 0;
    if (!v21)
      return result;
    if (v23)
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    v23 = strlen(*(const char **)(a4 + 8));
    result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v23, 0);
    if (!result)
      return result;
    if (v23)
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, *(_QWORD *)(a4 + 8), 0);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString(v22);
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  _BOOL4 v14;
  _BOOL8 result;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36[2];

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_28:
      re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
      return 0;
    }
    v23 = **((_QWORD **)a5 + 2);
    v24 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24)
      goto LABEL_28;
    v26 = WORD1(v23) == WORD1(v24);
    v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    v26 = v26 && v25 == 0;
    if (!v26)
      goto LABEL_28;
  }
LABEL_4:
  if (!a7)
  {
    v16 = **((_QWORD **)a5 + 2);
    v32 = *(_QWORD *)a5;
    v33 = v16;
    LODWORD(v34) = -1;
    v36[0] = 0x258C98EAAF29A10ALL;
    v36[1] = (uint64_t)"CallbackSerializerAttribute";
    v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v32, v36);
    re::StringID::destroyString((re::StringID *)v36);
    v18 = *v17;
    v19 = *(_QWORD *)(a1 + 264);
    v20 = *(_QWORD *)(a1 + 56);
    v34 = 0;
    v35 = 0;
    v32 = v20;
    v33 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v18 + 72))(v19, v18, a4, &v32) & 1) != 0)
    {
      if ((v33 & 1) != 0)
        v21 = v33 >> 1;
      else
        v21 = v33 >> 1;
      v36[0] = v21;
      if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, v36, 0))
      {
        if (v36[0])
        {
          if ((v33 & 1) != 0)
            v22 = v34;
          else
            v22 = (char *)&v33 + 1;
          re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, (uint64_t)v22, 0);
        }
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
        if (v32 && (v33 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v32 + 40))();
        return *(_BYTE *)(a1 + 64) == 0;
      }
    }
    else
    {
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Failed to write string for \"%s\" (type %s) using serialization callback.", v27, v28, v29, v30, v31, (char)a2);
    }
    if (v32 && (v33 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v32 + 40))();
    return 0;
  }
  v32 = 0;
  v14 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, &v32, 0);
  result = 0;
  if (v14)
  {
    if (v32)
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(uint64_t a1, const char *a2, int *a3)
{
  int v3;
  int v6;
  char *v7;
  uint64_t result;
  __int128 v9;
  uint64_t v10;
  _BOOL8 v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;

  v14 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (*(_BYTE *)(a1 + 40))
    return v3 == 0;
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v14);
  v6 = *a3;
  if ((*a3 - 1) < 2)
  {
LABEL_7:
    LOBYTE(v9) = 9;
    DWORD1(v9) = 0;
    *((_QWORD *)&v9 + 1) = v14;
    v10 = 0;
    v12 = 0;
    v13 = 0;
    v11 = v6 != 0;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v9);
    return v3 == 0;
  }
  if (!v6)
  {
    v7 = *(char **)(a1 + 168);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v7);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull((uint64_t *)v7);
    v6 = *a3;
    goto LABEL_7;
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Unexpected PointerEncoding.", "!\"Unreachable code\"", "beginPointer", 1054);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString(_BYTE *a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6)
{
  int *v11;
  int v12;
  _anonymous_namespace_ *v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  const char *v19;
  uint64_t v20;
  int v21;
  __int128 v22;
  int v23;
  const char *v24;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_14:
      re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a5, a6);
      return 0;
    }
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 != (unsigned __int16)v16)
      goto LABEL_14;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_14;
  }
LABEL_4:
  if (!*a4)
  {
    LODWORD(v24) = 0;
    v13 = (_anonymous_namespace_ *)(a1 + 24);
    v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, (int *)&v24);
    result = 0;
    if (!v21)
      return result;
    goto LABEL_22;
  }
  if (!a1[336]
    || (v24 = *a4,
        (v11 = (int *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(a1 + 344), (uint64_t *)&v24)) == 0))
  {
    v23 = 2;
    if ((re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, &v23) & 1) != 0)
    {
      v24 = (const char *)strlen(*a4);
      result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 24), a2, 0, (uint64_t *)&v24, 0);
      if (!(_DWORD)result)
        return result;
      if (v24)
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString((uint64_t)(a1 + 24), (uint64_t)*a4, 0);
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
      re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      v19 = *a4;
      v20 = **((_QWORD **)a5 + 2);
      *(_QWORD *)&v22 = *(_QWORD *)a5;
      *((_QWORD *)&v22 + 1) = v20;
      re::internal::SharedObjectGraph::addObject((uint64_t)(a1 + 336), (uint64_t)v19, &v22);
      return a1[64] == 0;
    }
    return 0;
  }
  v12 = *v11;
  v23 = 1;
  LODWORD(v24) = v12;
  v13 = (_anonymous_namespace_ *)(a1 + 24);
  result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, &v23);
  if (!(_DWORD)result)
    return result;
  re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((uint64_t)(a1 + 24), (unsigned int *)&v24);
LABEL_22:
  re::EncoderBinary<re::SeekableInputStream>::endPointer(v13);
  return a1[64] == 0;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  const re::TypeInfo *v14;
  _BOOL4 isPointerToPolymorphicType;
  int v16;
  char *v17;
  _DWORD *v18;
  _anonymous_namespace_ *v19;
  uint64_t result;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t *v33;
  uint64_t *v34;
  char *v35;
  re::TypeRegistry *v36;
  uint64_t *v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  __int128 v46;
  _BYTE v47[32];
  __int128 v48;
  _QWORD v49[4];
  _QWORD v50[4];
  char *v51;
  _BYTE v52[32];
  int v53[10];

  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v29 = **((_QWORD **)this + 2);
    v30 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v29 == (unsigned __int16)v30)
    {
      v32 = WORD1(v29) == WORD1(v30);
      v31 = (v30 ^ v29) & 0xFFFFFF00000000;
      v32 = v32 && v31 == 0;
      if (v32)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    v16 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v33 = re::TypeInfo::name(this), v34 = re::TypeInfo::name(a6), !re::StringID::operator==(v33, v34))))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, this, a6);
    return 0;
  }
  v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)v52);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v21 = *(_QWORD *)v50[2];
    *(_QWORD *)&v48 = v50[0];
    *((_QWORD *)&v48 + 1) = v21;
    if (v50[0])
      goto LABEL_8;
    goto LABEL_15;
  }
  re::internal::actualType(a4, (void **)this, &v48);
  if (!(_QWORD)v48)
  {
LABEL_15:
    v22 = re::TypeInfo::name(this);
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Failed to get actual type of polymorphic object. Type \"%s\".", v23, v24, v25, v26, v27, v22[1]);
    return 0;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, (re **)&v48, &v51);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v52);
  if ((a7 & 1) != 0 || (v17 = *a4) == 0)
  {
    LODWORD(v51) = 0;
    v19 = (_anonymous_namespace_ *)(a1 + 24);
    v28 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, (int *)&v51);
    result = 0;
    if (v28)
      goto LABEL_17;
    return result;
  }
  if (!*(_BYTE *)(a1 + 336))
  {
LABEL_33:
    v46 = v48;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), (uint64_t)v17, &v46);
    v45 = 2;
    result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v45);
    if (!(_DWORD)result)
      return result;
    if (!isPointerToPolymorphicType)
    {
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, _QWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, *a4, v50, v49, 0);
      goto LABEL_45;
    }
    v35 = *a4;
    re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v47);
    if (v16)
    {
      v36 = (re::TypeRegistry *)v49[0];
      v37 = re::TypeInfo::name((re::TypeInfo *)v47);
      re::TypeRegistry::typeInfo(v36, (const re::StringID *)v37, &v51);
      if (!(_BYTE)v51)
      {
        v39 = re::TypeInfo::name((re::TypeInfo *)v47);
        re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "No matching type found for polymorphic type \"%s\" to serialize.", v40, v41, v42, v43, v44, v39[1]);
LABEL_45:
        re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        if (*(_BYTE *)(a1 + 336))
        {
          --*(_QWORD *)(a1 + 488);
          ++*(_DWORD *)(a1 + 496);
        }
        return *(_BYTE *)(a1 + 64) == 0;
      }
      re::TypeInfo::operator=((uint64_t)v53, (uint64_t)v52);
    }
    if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, a3, 0))
    {
      v38 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)v53);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, uint64_t, _QWORD, char *, _BYTE *, int *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v38[1], 0, v35, v47, v53, 0);
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    goto LABEL_45;
  }
  v51 = *a4;
  v18 = (_DWORD *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 344, (uint64_t *)&v51);
  if (!v18)
  {
    v17 = *a4;
    goto LABEL_33;
  }
  LODWORD(v51) = *v18;
  v53[0] = 1;
  v19 = (_anonymous_namespace_ *)(a1 + 24);
  result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, v53);
  if ((_DWORD)result)
  {
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(a1 + 24, (unsigned int *)&v51);
LABEL_17:
    re::EncoderBinary<re::SeekableInputStream>::endPointer(v19);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(uint64_t result, unsigned int *a2)
{
  _anonymous_namespace_ *v3;

  if (!*(_BYTE *)(result + 40))
  {
    v3 = (_anonymous_namespace_ *)result;
    result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(result, 0, 0, 0);
    if ((_DWORD)result)
    {
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>((uint64_t)v3, "@ref", 0, a2, 0);
      return (uint64_t)re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v3);
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *result;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v5 = *(_QWORD *)(a1 + 272);
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5)
    v7 = result == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = *result;
    v10 = a3;
    v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 288, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, BOOL *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, (uint64_t)a3, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, (uint64_t)a3, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, (uint64_t)a3, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

unsigned int *re::serializeChar<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _BYTE *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)a3, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)a3, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)a3, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

unsigned int *re::serializeI8<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _BYTE *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int8");
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int8");
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int8");
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

unsigned int *re::serializeI16<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _WORD *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int16");
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int16");
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int16");
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI32<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned int *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int32");
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int32");
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int32");
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI64<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unint64_t *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int64");
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int64");
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int64");
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

unsigned int *re::serializeU8<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _BYTE *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint8");
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint8");
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint8");
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

unsigned int *re::serializeU16<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _WORD *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint16");
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint16");
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint16");
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU32<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _DWORD *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint32");
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint32");
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint32");
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU64<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _QWORD *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint64");
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint64");
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint64");
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeFloat<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, float *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"float");
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"float");
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"float");
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeDouble<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, double *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"double");
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"double");
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"double");
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::serializeCString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  _BOOL8 result;
  unsigned int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  size_t v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  char v46;
  size_t v47;
  int v48;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_22:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v23 = **((_QWORD **)a5 + 2);
    v24 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24)
      goto LABEL_22;
    v26 = WORD1(v23) == WORD1(v24);
    v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    v26 = v26 && v25 == 0;
    if (!v26)
      goto LABEL_22;
  }
LABEL_4:
  if (a7)
  {
    v48 = 0;
    v19 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
    result = 0;
    if (!v19)
      return result;
    if (!v48)
      goto LABEL_12;
    if (v48 != 1)
    {
      v47 = 0;
      if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (uint64_t *)&v47, 0))
      {
        if (v47)
          re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
LABEL_12:
      re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      goto LABEL_47;
    }
    goto LABEL_16;
  }
  v48 = 2 * (*a4 != 0);
  v21 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
  result = 0;
  if (!v21)
    return result;
  v22 = v48;
  if (v48)
  {
    if (v48 == 1)
    {
LABEL_16:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, v46);
      return 0;
    }
  }
  else
  {
    if (!*a4)
      goto LABEL_44;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
    *a4 = 0;
    v22 = v48;
  }
  if (v22 == 2)
  {
    v27 = *a4 ? strlen(*a4) : 0;
    v47 = v27;
    if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (uint64_t *)&v47, 0))
    {
      v28 = (char *)*a4;
      v29 = v47;
      if (!*a4 || v47 != v27)
      {
        if (v28)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
          *a4 = 0;
          v29 = v47;
        }
        v30 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        v36 = v47;
        if (v29 > v30)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v37, v38, v39, v40, v41, v36);
          return 0;
        }
        v42 = v47 == -1;
        v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, v47);
          return 0;
        }
        v28 = (char *)(*(uint64_t (**)(_QWORD, size_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v47 + 1, 0);
        *a4 = v28;
        v27 = v47;
      }
      if (v27)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v28, 0);
        v28 = (char *)*a4;
        v44 = v47;
      }
      else
      {
        v44 = 0;
      }
      v28[v44] = 0;
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    }
  }
LABEL_44:
  re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  v45 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(_BYTE *)(a1 + 64))
    return v45 == 0;
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  v45 = *(unsigned __int8 *)(a1 + 64);
  return v45 == 0;
}

BOOL re::serializeStringID<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  unsigned int v20;
  _BOOL8 result;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  _anonymous_namespace_ *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v47 = 0;
    v20 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v47, 0);
    result = 0;
    if (!v20)
      return result;
    if (v47)
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    goto LABEL_26;
  }
  v46 = 0;
  if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v46, 0))
  {
    v22 = v46;
    if (v46)
    {
      v23 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
      v29 = v46;
      if (v22 > v23)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v30, v31, v32, v33, v34, v29);
        return 0;
      }
      v36 = v46 == -1;
      v37 = v36 << 63 >> 63;
      if (v37 != v36 || v37 < 0)
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v24, v25, v26, v27, v28, v46);
        return 0;
      }
      v38 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56), v46 + 1, 0);
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v38, 0);
      v38[v46] = 0;
      v44 = 0;
      v45 = &str_110;
      v40 = v44;
      v41 = (uint64_t)v45;
      v44 = 0;
      v45 = &str_110;
      v42 = *a4;
      v43 = a4[1];
      *a4 = v40;
      a4[1] = v41;
      v47 = v40 & 0xFFFFFFFFFFFFFFFELL | v42 & 1;
      v48 = v43;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v38);
    }
    else
    {
      v44 = 0;
      v45 = &str_110;
      v35 = a4[1];
      v47 = *a4 & 1;
      v48 = v35;
      *a4 = 0;
      a4[1] = (uint64_t)&str_110;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
    }
LABEL_26:
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return 0;
}

unsigned int *re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  unsigned int v14;
  unsigned int *result;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  re *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  unint64_t v35;
  _BYTE buf[22];
  __int16 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v27 = **((_QWORD **)a5 + 2);
    v28 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v27 == (unsigned __int16)v28)
    {
      v30 = WORD1(v27) == WORD1(v28);
      v29 = (v28 ^ v27) & 0xFFFFFF00000000;
      v30 = v30 && v29 == 0;
      if (v30)
        goto LABEL_4;
    }
LABEL_32:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_32;
LABEL_4:
  if (a7)
  {
    v31 = 0;
    v14 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v31, 0);
    result = 0;
    if (!v14)
      return result;
    if (v31)
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
  }
  else
  {
    v16 = **((_QWORD **)a5 + 2);
    v31 = *(_QWORD *)a5;
    v32 = v16;
    LODWORD(v33) = -1;
    *(_QWORD *)buf = 0x258C98EAAF29A10ALL;
    *(_QWORD *)&buf[8] = "CallbackSerializerAttribute";
    v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v31, buf);
    re::StringID::destroyString((re::StringID *)buf);
    v18 = *v17;
    v19 = *(_QWORD *)(a1 + 264);
    v35 = 0;
    result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v35, 0);
    if (!(_DWORD)result)
      return result;
    v20 = *(_QWORD *)(a1 + 56);
    v33 = 0;
    v34 = 0;
    v31 = v20;
    v32 = 0;
    re::DynamicString::setCapacity(&v31, 0);
    if (v35)
    {
      re::DynamicString::resize(&v31, v35, 0);
      if ((v32 & 1) != 0)
        v21 = v33;
      else
        v21 = (char *)&v32 + 1;
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v21, 0);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    v22 = (char *)&v32 + 1;
    if ((v32 & 1) != 0)
      v23 = v33;
    else
      v23 = (char *)&v32 + 1;
    v24 = (re *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, char *))(v18 + 80))(*(_QWORD *)(a1 + 48), v19, v18, a4, v23);
    if ((v24 & 1) == 0)
    {
      v25 = *re::foundationSerializationLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        if ((v32 & 1) != 0)
          v22 = v33;
        v26 = re::TypeInfo::name(a5)[1];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v22;
        v37 = 2080;
        v38 = v26;
        _os_log_impl(&dword_224FE9000, v25, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);
      }
    }
    if (v31 && (v32 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v31 + 40))();
  }
  return (unsigned int *)(*(_BYTE *)(a1 + 64) == 0);
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(_anonymous_namespace_ *a1, char *a2, uint64_t a3, int *a4, int a5)
{
  unsigned int *result;
  unsigned int *v10;
  int v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;

  if (*((_BYTE *)a1 + 40))
    return 0;
  result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
  if (result)
  {
    v10 = result;
    v11 = *((unsigned __int16 *)result + 11);
    if (*((_WORD *)result + 11))
    {
      if (v11 != 3
        || (int *)(*((_QWORD *)result + 1) + 48 * *result) == rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::FindMember(result, "@ref"))
      {
        v11 = 2;
        v12 = 1;
      }
      else
      {
        v12 = 1;
        v11 = 1;
      }
    }
    else
    {
      v12 = *((unsigned __int16 *)result + 11);
    }
    *a4 = v11;
    LOBYTE(v13) = 9;
    DWORD1(v13) = a5;
    *((_QWORD *)&v13 + 1) = a2;
    v14 = 0;
    v15 = v12;
    v16 = 0;
    v17 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v13);
    return (unsigned int *)1;
  }
  return result;
}

int *rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::FindMember(unsigned int *a1, char *__s)
{
  int *v3;
  _QWORD v5[4];

  v5[3] = *MEMORY[0x24BDAC8D0];
  v5[1] = __s;
  v5[2] = 0x405000000000000;
  v5[0] = strlen(__s);
  v3 = (int *)*((_QWORD *)a1 + 1);
  if (*a1)
  {
    do
    {
      if (rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::StringEqual<re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>((unsigned int *)v5, v3))
      {
        break;
      }
      v3 += 12;
    }
    while (v3 != (int *)(*((_QWORD *)a1 + 1) + 48 * *a1));
  }
  return v3;
}

BOOL rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::StringEqual<re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>(unsigned int *a1, int *a2)
{
  unsigned int v2;
  int v3;

  if ((*((_WORD *)a1 + 11) & 0x1000) != 0)
    v2 = 21 - *((char *)a1 + 21);
  else
    v2 = *a1;
  v3 = 21 - *((char *)a2 + 21);
  if ((*((_WORD *)a2 + 11) & 0x1000) == 0)
    v3 = *a2;
  if (v2 != v3)
    return 0;
  if ((*((_WORD *)a1 + 11) & 0x1000) == 0)
    a1 = (unsigned int *)*((_QWORD *)a1 + 1);
  if ((*((_WORD *)a2 + 11) & 0x1000) == 0)
    a2 = (int *)*((_QWORD *)a2 + 1);
  return a1 == (unsigned int *)a2 || memcmp(a1, a2, v2) == 0;
}

BOOL re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString(uint64_t a1, char *a2, const re::TypeInfo *a3, char **a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _anonymous_namespace_ *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  __int128 v44;
  _QWORD *v45;
  unsigned __int16 v46;
  unsigned __int16 v47;
  int v48;
  unsigned int v49;
  int v50;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_15:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 != (unsigned __int16)v15)
      goto LABEL_15;
    v17 = WORD1(v14) == WORD1(v15);
    v16 = (v15 ^ v14) & 0xFFFFFF00000000;
    v17 = v17 && v16 == 0;
    if (!v17)
      goto LABEL_15;
  }
LABEL_4:
  v50 = 0;
  if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v50, 0))
  {
    if (v50 == 1)
    {
      v49 = 0;
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((unsigned int *)(a1 + 24), &v49, 0);
      if (!*(_BYTE *)(a1 + 64))
      {
        if (*(_QWORD *)(a1 + 408) <= (unint64_t)v49)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid reference ID for shared object: %u", v19, v20, v21, v22, v23, v49);
        }
        else
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v49, (uint64_t)&v45);
          if (v45 == *(_QWORD **)a5)
          {
            v24 = **((_QWORD **)a5 + 2);
            if (v46 == (unsigned __int16)v24 && v47 == WORD1(v24) && ((v48 ^ HIDWORD(v24)) & 0xFFFFFF) == 0)
            {
              if ((a7 & 1) == 0)
              {
                if (*a4)
                {
                  v42 = *a4;
                  if (v42 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v49))
                  {
                    (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48), *a4);
                    *a4 = 0;
                  }
                }
                *a4 = (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v49);
                re::internal::SharedObjectGraph::addReference((_QWORD *)(a1 + 336), v49);
              }
              goto LABEL_36;
            }
          }
          v25 = *(_anonymous_namespace_ **)(a1 + 272);
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v49, (uint64_t)&v45);
          v43 = *((_QWORD *)re::TypeRegistry::typeName(v25, &v45) + 1);
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid reference ID for shared object. Expected type \"char *\". Actual type \"%s\".", v26, v27, v28, v29, v30, v43);
        }
      }
    }
    else
    {
      if (!v50)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
            *a4 = 0;
          }
        }
LABEL_36:
        re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        return *(_BYTE *)(a1 + 64) == 0;
      }
      if ((a7 & 1) == 0 && *a4)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
        *a4 = 0;
      }
      v45 = 0;
      if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (uint64_t *)&v45, 0))
      {
        v36 = v45 == (_QWORD *)-1;
        v37 = v36 << 63 >> 63;
        if (v37 == v36 && (v37 & 0x8000000000000000) == 0)
        {
          v38 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), (uint64_t)v45 + 1, 0);
          v39 = (uint64_t)v38;
          if ((a7 & 1) == 0)
            *a4 = v38;
          v40 = (uint64_t)v45;
          if (v45)
          {
            re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v38, 0);
            v40 = (uint64_t)v45;
          }
          *(_BYTE *)(v39 + v40) = 0;
          re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
          v41 = **((_QWORD **)a5 + 2);
          *(_QWORD *)&v44 = *(_QWORD *)a5;
          *((_QWORD *)&v44 + 1) = v41;
          re::internal::SharedObjectGraph::addObject(a1 + 336, v39, &v44);
          goto LABEL_36;
        }
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, (char)v45);
      }
    }
  }
  return 0;
}

BOOL re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer(uint64_t a1, char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  const re::TypeInfo *v14;
  _BOOL4 isPointerToPolymorphicType;
  int v16;
  re *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t *v30;
  uint64_t *v31;
  char *v33;
  uint64_t v34;
  char **v35;
  void **v36;
  re::TypeRegistry *v37;
  uint64_t *v38;
  char *Instance;
  uint64_t v40;
  re *v41;
  uint64_t v42;
  _anonymous_namespace_ *v43;
  void (*v44)(uint64_t);
  uint64_t v45;
  __int128 v46;
  re *v47[2];
  re *v48[2];
  _BYTE v49[16];
  unsigned int v50;
  int v51;
  _BYTE v52[16];
  uint64_t v53;
  re *v54[2];
  _BYTE v55[32];
  _QWORD v56[2];
  re **v57;
  uint64_t v58;
  _BYTE v59[40];

  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v26 = **((_QWORD **)this + 2);
    v27 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v26 == (unsigned __int16)v27)
    {
      v29 = WORD1(v26) == WORD1(v27);
      v28 = (v27 ^ v26) & 0xFFFFFF00000000;
      v29 = v29 && v28 == 0;
      if (v29)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    v16 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v30 = re::TypeInfo::name(this), v31 = re::TypeInfo::name(a6), !re::StringID::operator==(v30, v31))))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, this, a6);
    return 0;
  }
  v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v58);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v59);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v58);
  re::TypeInfo::TypeInfo((uint64_t)v55, (uint64_t)v59);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v17 = *v57;
    v54[0] = (re *)v56[0];
    v54[1] = v17;
    if (v56[0])
      goto LABEL_8;
LABEL_15:
    v45 = re::TypeInfo::name(this)[1];
    v23 = "Failed to get actual type of polymorphic object. Type \"%s\".";
    v24 = a1;
    v25 = a2;
LABEL_16:
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v24, v25, v23, v18, v19, v20, v21, v22, v45);
    return 0;
  }
  re::internal::actualType(a4, (void **)this, v54);
  if (!v54[0])
    goto LABEL_15;
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v54, &v58);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v59);
  v51 = 0;
  if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, a3, &v51, 0))
  {
    if (v51 != 1)
    {
      if (!v51)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v52, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            *a4 = 0;
          }
        }
        goto LABEL_56;
      }
      if (isPointerToPolymorphicType)
      {
        re::internal::deserializePolymorphicObject<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,true>(a1, a2, a3, (void **)a4, (re **)this, (re::TypeInfo *)v52, (re::TypeInfo *)v55, v16, a7);
        goto LABEL_56;
      }
      if (!a7)
      {
        Instance = *a4;
        if (!*a4)
          Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v56, *(re::Allocator **)(a1 + 48), 0);
        v40 = 0;
        *a4 = Instance;
        goto LABEL_52;
      }
      v37 = *(re::TypeRegistry **)(a1 + 272);
      if ((re::TypeRegistry *)v56[0] != v37)
      {
        v38 = re::TypeInfo::name((re::TypeInfo *)v56);
        re::TypeRegistry::typeInfo(v37, (const re::StringID *)v38, &v58);
        if (!(_BYTE)v58)
        {
          Instance = 0;
          v40 = 1;
          goto LABEL_52;
        }
        re::TypeInfo::operator=((uint64_t)v56, (uint64_t)v59);
      }
      Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v56, *(re::Allocator **)(a1 + 48), 0);
      v40 = 0;
LABEL_52:
      v41 = *v57;
      *(_QWORD *)&v46 = v56[0];
      *((_QWORD *)&v46 + 1) = v41;
      re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), (uint64_t)Instance, &v46);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, char *, _QWORD, char *, _QWORD *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, Instance, v56, v55, v40);
      if (*(_BYTE *)(a1 + 336))
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
      goto LABEL_56;
    }
    v50 = 0;
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((unsigned int *)(a1 + 24), &v50, 0);
    if (!*(_BYTE *)(a1 + 64))
    {
      if (*(_QWORD *)(a1 + 408) > (unint64_t)v50)
      {
        re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v50, (uint64_t)v49);
        if (!re::internal::areCompatible((re **)this, (uint64_t)v49))
        {
          v42 = re::TypeInfo::name((re::TypeInfo *)v56)[1];
          v43 = *(_anonymous_namespace_ **)(a1 + 272);
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v50, (uint64_t)&v58);
          LOBYTE(v45) = v42;
          re::TypeRegistry::typeName(v43, &v58);
          v23 = "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".";
          goto LABEL_59;
        }
        if ((a7 & 1) != 0)
        {
LABEL_56:
          re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
          return *(_BYTE *)(a1 + 64) == 0;
        }
        if (*a4)
        {
          v33 = *a4;
          if (v33 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v50))
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v52, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            *a4 = 0;
          }
        }
        v34 = re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v50);
        v35 = (char **)v34;
        *a4 = (char *)v34;
        if ((*(_BYTE *)(v53 + 49) & 2) != 0)
        {
          v44 = *(void (**)(uint64_t))(v53 + 32);
          if (v44)
            v44(v34);
          re::internal::SharedObjectGraph::addReference((_QWORD *)(a1 + 336), v50);
        }
        else
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v50, (uint64_t)v48);
          if (!v48[0])
          {
            LOBYTE(v45) = v50;
            v23 = "TypeID for shared object at index %d is invalid.";
            goto LABEL_59;
          }
          re::TypeRegistry::typeInfo(v48[0], v48, &v58);
          if (!(_BYTE)v58)
          {
            LOBYTE(v45) = v50;
            v23 = "No TypeInfo found for shared object at index %d.";
            goto LABEL_59;
          }
          v36 = re::TypeInfo::createInstance((re::TypeInfo *)v59, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          *a4 = (char *)v36;
          if ((re::TypeInfo::copy((re::TypeInfo *)v59, v36, v35, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264)) & 1) == 0)
          {
            v45 = re::TypeInfo::name((re::TypeInfo *)v59)[1];
            v23 = "Failed to copy non-shareable object of type '%s'.";
LABEL_59:
            v24 = a1;
            v25 = 0;
            goto LABEL_16;
          }
        }
        re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v50, (uint64_t)v47);
        re::TypeInfo::setActualTypeForPointer((_QWORD **)this, (uint64_t)a4, v47);
        goto LABEL_56;
      }
      LOBYTE(v45) = v50;
      v23 = "Invalid reference ID for shared object: %u";
      goto LABEL_59;
    }
  }
  return 0;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(unsigned int *result, _DWORD *a2, int a3)
{
  char v3;
  _anonymous_namespace_ *v5;

  if (!*((_BYTE *)result + 40))
  {
    v3 = a3;
    v5 = (_anonymous_namespace_ *)result;
    result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)result, 0, 0, a3);
    if ((_DWORD)result)
    {
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>((uint64_t)v5, "@ref", 0, a2, v3, (uint64_t)"uint32");
      return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v5);
    }
  }
  return result;
}

BOOL re::internal::deserializePolymorphicObject<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,true>(uint64_t a1, char *a2, uint64_t a3, void **a4, re **a5, re::TypeInfo *a6, re::TypeInfo *a7, int a8, char a9)
{
  _anonymous_namespace_ *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  _BOOL8 result;
  uint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  char v27;
  unsigned __int8 *v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  const char *v35;
  re *v36;
  uint64_t *v37;
  re *v38;
  re::TypeRegistry *v39;
  NSObject *v40;
  uint64_t *v41;
  uint64_t *v42;
  re *v43;
  re *v44;
  NSObject *v45;
  uint64_t v46;
  void **Instance;
  void **v48;
  char v49;
  re **v50;
  _QWORD v51[2];
  re *v52[2];
  _QWORD v53[2];
  _BYTE v54[32];
  re *v55;
  re *v56;
  _QWORD v57[2];
  uint8_t buf[16];
  re **v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v15 = (_anonymous_namespace_ *)(a1 + 24);
  v21 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, 0, 0);
  result = 0;
  if (v21)
  {
    v23 = *(_QWORD *)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (!*(_DWORD *)v23)
    {
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid object. Name of polymorphic type expected.", v16, v17, v18, v19, v20, v49);
      return 0;
    }
    v24 = *(char **)(v23 + 8);
    if ((*((_WORD *)v24 + 11) & 0x1000) != 0)
      v25 = v24;
    else
      v25 = (char *)*((_QWORD *)v24 + 1);
    v50 = a5;
    if (v25)
    {
      v26 = *v25;
      if (*v25)
      {
        v27 = v25[1];
        if (v27)
        {
          v28 = (unsigned __int8 *)(v25 + 2);
          do
          {
            v26 = 31 * v26 + v27;
            v29 = *v28++;
            v27 = v29;
          }
          while (v29);
        }
      }
    }
    else
    {
      v26 = 0;
    }
    v30 = 2 * v26;
    v57[0] = 2 * v26;
    v57[1] = v25;
    v31 = *(_DWORD *)(*((_QWORD *)a7 + 2) + 80);
    v32 = (v31 - 1);
    if (v31 != 1)
    {
      v33 = 0;
      while (1)
      {
        re::TypeInfo::derivedClass(a7, v33, (uint64_t)buf);
        v34 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)buf);
        if ((*v34 ^ (unint64_t)v30) <= 1)
        {
          v35 = (const char *)v34[1];
          if (v35 == v25 || !strcmp(v35, v25))
            break;
        }
        if (v32 == ++v33)
          goto LABEL_22;
      }
      v36 = *v59;
      v55 = *(re **)buf;
      v56 = v36;
      if (*(_QWORD *)buf)
      {
LABEL_26:
        if ((a9 & 1) == 0 && *a4)
        {
          re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          *a4 = 0;
        }
        re::TypeRegistry::typeInfo(*(re **)a7, &v55, buf);
        re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)&buf[8]);
        if (a8)
        {
          v39 = *(re::TypeRegistry **)(a1 + 272);
        }
        else
        {
          v39 = *(re::TypeRegistry **)(a1 + 272);
          if (*v50 == v39)
          {
            re::TypeInfo::operator=((uint64_t)a6, (uint64_t)v54);
            v43 = v55;
            v44 = v56;
            goto LABEL_45;
          }
        }
        v41 = re::TypeInfo::name((re::TypeInfo *)v54);
        v42 = re::TypeRegistry::typeInfo(v39, (const re::StringID *)v41, buf);
        if (!buf[0])
        {
          v45 = *re::foundationSerializationLogObjects((re *)v42);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            v46 = re::TypeInfo::name((re::TypeInfo *)v54)[1];
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v46;
            _os_log_impl(&dword_224FE9000, v45, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", buf, 0xCu);
          }
          v53[0] = 0;
          v53[1] = 0xFFFFFFFFLL;
          (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)a1 + 16))(a1, 0, v53);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v25, 0, 0, v54, v54, 1);
          goto LABEL_49;
        }
        re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&buf[8]);
        v43 = *(re **)a6;
        v44 = (re *)**((_QWORD **)a6 + 2);
LABEL_45:
        Instance = re::TypeInfo::createInstance(a6, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
        v48 = Instance;
        if ((a9 & 1) == 0)
        {
          *a4 = Instance;
          v52[0] = v43;
          v52[1] = v44;
          re::internal::setActualType(a4, v50, v52);
        }
        v51[0] = v43;
        v51[1] = v44;
        (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)a1 + 16))(a1, v48, v51);
        if (!*(_BYTE *)(a1 + 64))
          (*(void (**)(uint64_t, char *, _QWORD, void **, re::TypeInfo *, _BYTE *, BOOL))(*(_QWORD *)a1 + 72))(a1, v25, 0, v48, a6, v54, v48 == 0);
LABEL_49:
        (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v15);
        re::StringID::destroyString((re::StringID *)v57);
        return *(_BYTE *)(a1 + 64) == 0;
      }
    }
LABEL_22:
    v37 = re::TypeInfo::polymorphicObjectName(a7);
    if ((*v37 ^ (unint64_t)v30) <= 1)
    {
      v37 = (uint64_t *)v37[1];
      if (v37 == (uint64_t *)v25 || (v37 = (uint64_t *)strcmp((const char *)v37, v25), !(_DWORD)v37))
      {
        v38 = (re *)**((_QWORD **)a7 + 2);
        v55 = *(re **)a7;
        v56 = v38;
        if (v55)
          goto LABEL_26;
      }
    }
    v40 = *re::foundationSerializationLogObjects((re *)v37);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v25;
      _os_log_error_impl(&dword_224FE9000, v40, OS_LOG_TYPE_ERROR, "Skipping unknown polymorphic type. Type name = \"%s\"", buf, 0xCu);
    }
    if ((a9 & 1) == 0 && *a4)
    {
      re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
      *a4 = 0;
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v15);
    re::StringID::destroyString((re::StringID *)v57);
    return 1;
  }
  return result;
}

void re::introspect_RealityFileSpecifierType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  re *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  StringID v40;
  _QWORD v41[2];
  _QWORD v42[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540FC628);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540FC628);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "None";
      qword_2540FC660 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "Url";
      qword_2540FC668 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "BundleID";
      qword_2540FC670 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *((_QWORD *)v34 + 1) = 3;
      *((_QWORD *)v34 + 2) = "MemoryID";
      qword_2540FC678 = (uint64_t)v34;
      v35 = re::introspectionAllocator(v34);
      v36 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v35 + 32))(v35, 24, 8);
      *(_DWORD *)v36 = 1;
      *(_QWORD *)(v36 + 8) = 4;
      *(_QWORD *)(v36 + 16) = "NameAlias";
      qword_2540FC680 = v36;
      __cxa_guard_release(&qword_2540FC628);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC630);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC630))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540FC688, "RealityFileSpecifierType", 1, 1, 1, 1);
    qword_2540FC688 = (uint64_t)&off_24ED7D9E8;
    qword_2540FC6C8 = (uint64_t)&re::introspect_RealityFileSpecifierType(BOOL)::enumTable;
    dword_2540FC698 = 9;
    __cxa_guard_release(&qword_2540FC630);
  }
  if ((_MergedGlobals_53 & 1) == 0)
  {
    _MergedGlobals_53 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FC688, a2);
    v38 = 0x63FC8598F9F42358;
    v39 = "RealityFileSpecifierType";
    v42[0] = 0x31CD534126;
    v42[1] = "uint8_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v42);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v42);
      v6 = (unsigned int *)qword_2540FC6C8;
      v41[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v42, &v38, 1, 1, (uint64_t)v41);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v40.var0 = 2 * v12;
            v40.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v42, v16, &v40);
            re::StringID::destroyString((re::StringID *)&v40);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v40.var0 = 2 * v20;
              v40.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v42, v24, &v40);
              re::StringID::destroyString((re::StringID *)&v40);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v42, v25);
      xmmword_2540FC6A8 = (__int128)v40;
      re::StringID::destroyString((re::StringID *)&v38);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v42);
      re::internal::assertLog((re::internal *)5, v37, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RealityFileSpecifierType", v38, v39);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t *re::allocInfo_RealityFileDescriptor(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FC638);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC638))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC6D0, 0);
    *(uint64_t *)((char *)&qword_2540FC6E0 + 6) = 0;
    qword_2540FC6E0 = 0;
    qword_2540FC6F0 = 0;
    qword_2540FC6F8 = 0xFFFFFFFFLL;
    qword_2540FC6D0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC700 = (uint64_t)"RealityFileDescriptor";
    dword_2540FC708 = 0;
    *(_OWORD *)&algn_2540FC70C[4] = 0u;
    *(_OWORD *)&algn_2540FC70C[20] = 0u;
    *(_OWORD *)&algn_2540FC70C[36] = 0u;
    qword_2540FC740 = 0;
    __cxa_guard_release(&qword_2540FC638);
  }
  return &qword_2540FC6D0;
}

void re::initInfo_RealityFileDescriptor(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  uint64_t *v9;
  const re::IntrospectionBase *v10;
  void *v11;
  uint64_t v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  void *v15;
  uint64_t v16;
  __int128 v17;
  _QWORD v18[2];
  __int128 v19;

  v18[0] = 0x6D3EFC1FD26478B6;
  v18[1] = "RealityFileDescriptor";
  re::StringID::destroyString((re::StringID *)v18);
  *((_OWORD *)this + 2) = v19;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FC640);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FC640);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::introspect_RealityFileSpecifierType((re *)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "realityFileSpecifierType";
      *(_QWORD *)(v8 + 16) = &qword_2540FC688;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_2540FC648 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v11 = re::IntrospectionInfo<re::DynamicString>::get(1, v10);
      v12 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 72, 8);
      *(_DWORD *)v12 = 1;
      *(_QWORD *)(v12 + 8) = "realityFileSpecifier";
      *(_QWORD *)(v12 + 16) = v11;
      *(_QWORD *)(v12 + 24) = 0;
      *(_QWORD *)(v12 + 32) = 0x800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(_QWORD *)(v12 + 48) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_2540FC650 = v12;
      v13 = re::introspectionAllocator((re *)v12);
      v15 = re::IntrospectionInfo<re::DynamicString>::get(1, v14);
      v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
      *(_DWORD *)v16 = 1;
      *(_QWORD *)(v16 + 8) = "realityFileSpecifier2";
      *(_QWORD *)(v16 + 16) = v15;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)(v16 + 32) = 0x2800000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 48) = 0;
      *(_QWORD *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_2540FC658 = v16;
      __cxa_guard_release(&qword_2540FC640);
    }
  }
  *((_QWORD *)this + 2) = 0x4800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((_QWORD *)this + 8) = &qword_2540FC648;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::RealityFileDescriptor>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::RealityFileDescriptor>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::RealityFileDescriptor>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::RealityFileDescriptor>;
  re::IntrospectionRegistry::add(this, v3);
  v17 = v19;
}

_QWORD *re::internal::defaultConstruct<re::RealityFileDescriptor>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v4;
  _anonymous_namespace_ *v5;

  v3 = a3;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 8) = 0u;
  v4 = (_QWORD *)(a3 + 8);
  v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v4, 0);
  *(_OWORD *)(v3 + 40) = 0u;
  v3 += 40;
  *(_OWORD *)(v3 + 16) = 0u;
  return re::DynamicString::setCapacity((_QWORD *)v3, 0);
}

double re::internal::defaultDestruct<re::RealityFileDescriptor>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _OWORD *v5;
  double result;
  uint64_t v7;

  v5 = (_OWORD *)(a3 + 40);
  v4 = *(_QWORD *)(a3 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a3 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a3 + 56));
    result = 0.0;
    *v5 = 0u;
    v5[1] = 0u;
  }
  v7 = *(_QWORD *)(a3 + 8);
  if (v7)
  {
    if ((*(_BYTE *)(a3 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *(_QWORD *)(a3 + 24));
    result = 0.0;
    *(_OWORD *)(a3 + 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::RealityFileDescriptor>(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  _anonymous_namespace_ *v3;

  v1 = a1;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  v2 = (_QWORD *)(a1 + 8);
  v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v2, 0);
  *(_OWORD *)(v1 + 40) = 0u;
  v1 += 40;
  *(_OWORD *)(v1 + 16) = 0u;
  return re::DynamicString::setCapacity((_QWORD *)v1, 0);
}

double re::internal::defaultDestructV2<re::RealityFileDescriptor>(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;
  uint64_t v5;

  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  v5 = *(_QWORD *)(a1 + 8);
  if (v5)
  {
    if ((*(_BYTE *)(a1 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a1 + 24));
    result = 0.0;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
  }
  return result;
}

uint64_t re::introspect_RealityFileDescriptor(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RealityFileDescriptor", (uint64_t (*)(re::internal *))re::allocInfo_RealityFileDescriptor, (re::IntrospectionBase *(*)(void))re::initInfo_RealityFileDescriptor, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RealityFileDescriptor>, this);
}

BOOL re::RealityFileDescriptor::hasURL(unsigned __int8 *a1, _BOOL8 a2)
{
  int v2;
  _BOOL8 v3;
  uint64_t v5;
  char v6;
  _BYTE v7[8];
  __int128 v8;
  __int128 v9;

  v2 = *a1;
  if (v2 == 4)
  {
    v3 = a2;
    if (a2)
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v5, (const re::DynamicString *)(a1 + 8));
      re::NamedFileRegistry::tryGetFilePathFor((os_unfair_lock_s *)v3, (uint64_t)&v5, v7);
      v3 = v7[0] != 0;
      if (v7[0] && (_QWORD)v8)
      {
        if ((BYTE8(v8) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v8 + 40))();
        v8 = 0u;
        v9 = 0u;
      }
      if (v5 && (v6 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v5 + 40))();
    }
  }
  else
  {
    return v2 == 2 || v2 == 1;
  }
  return v3;
}

void re::RealityFileDescriptor::getURL(uint64_t a1)
{
  __asm { BR              X10 }
}

re::DynamicString *sub_22524B13C(_anonymous_namespace_ *a1, uint64_t a2, __int128 a3, __int128 a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, __int128 a10, uint64_t a11, __int128 a12, __int128 a13, uint64_t a14, uint64_t a15, stat *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,__int128 a33,uint64_t a34,uint64_t a35,__int128 a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
  uint64_t v48;
  re::DynamicString *result;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;

  v50 = v53;
  v51 = v54;
  v52 = v55;
  *(_BYTE *)v48 = 0;
  *(_OWORD *)(v48 + 8) = v50;
  *(_QWORD *)(v48 + 24) = v51;
  *(_QWORD *)(v48 + 32) = v52;
  return result;
}

void re::RealityFileDescriptor::getMemoryFileID(re::RealityFileDescriptor *this)
{
  __asm { BR              X10 }
}

re::DynamicString *sub_22524B578(_anonymous_namespace_ *a1)
{
  uint64_t v1;
  re::DynamicString *result;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v3 = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)v1 = 0;
  *(_OWORD *)(v1 + 8) = v3;
  *(_QWORD *)(v1 + 24) = v4;
  *(_QWORD *)(v1 + 32) = v5;
  return result;
}

_QWORD *re::RealityFileDescriptor::makeWithURL@<X0>(re::RealityFileDescriptor *this@<X0>, _BYTE *a2@<X8>)
{
  _BYTE *v3;
  _anonymous_namespace_ *v4;

  v3 = a2;
  *a2 = 1;
  v4 = re::DynamicString::DynamicString((re::DynamicString *)(a2 + 8), this);
  *(_OWORD *)(v3 + 40) = 0u;
  v3 += 40;
  *((_OWORD *)v3 + 1) = 0u;
  return re::DynamicString::setCapacity(v3, 0);
}

_QWORD *re::RealityFileDescriptor::makeWithMemoryFileID@<X0>(re::RealityFileDescriptor *this@<X0>, uint64_t a2@<X8>)
{
  _anonymous_namespace_ *v3;

  *(_BYTE *)a2 = 3;
  v3 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)(a2 + 8), this);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  return re::DynamicString::setCapacity((_QWORD *)(a2 + 40), 0);
}

_QWORD *re::RealityFileDescriptor::makeWithNameAlias@<X0>(const re::DynamicString *a1@<X0>, _BYTE *a2@<X8>)
{
  _BYTE *v2;
  _anonymous_namespace_ *v3;

  v2 = a2;
  *a2 = 4;
  v3 = re::DynamicString::DynamicString((re::DynamicString *)(a2 + 8), a1);
  *(_OWORD *)(v2 + 40) = 0u;
  v2 += 40;
  *((_OWORD *)v2 + 1) = 0u;
  return re::DynamicString::setCapacity(v2, 0);
}

void re::RealityFileDescriptor::transform(uint64_t a1)
{
  __asm { BR              X10 }
}

void sub_22524B77C()
{
  _BYTE *v0;

  *v0 = 0;
}

void sub_22524B794(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, __int128 a16, uint64_t a17, __int128 a18, __int128 a19)
{
  uint64_t v19;
  _anonymous_namespace_ *v21;
  uint64_t v22;

  if (re::DynamicString::operator==(a1 + 8, a2 + 24))
  {
    v21 = re::DynamicString::DynamicString((re::DynamicString *)&a15, (const re::DynamicString *)(a2 + 56));
    a18 = 0u;
    a19 = 0u;
    re::DynamicString::setCapacity(&a18, 0);
    *(_BYTE *)v19 = 1;
    *(_BYTE *)(v19 + 8) = 1;
    *(_QWORD *)(v19 + 16) = a15;
    *(_OWORD *)(v19 + 24) = a16;
    v22 = a18;
    *(_QWORD *)(v19 + 40) = a17;
    *(_QWORD *)(v19 + 48) = v22;
    *(_QWORD *)(v19 + 72) = *((_QWORD *)&a19 + 1);
    *(_OWORD *)(v19 + 56) = *(__int128 *)((char *)&a18 + 8);
    JUMPOUT(0x22524B780);
  }
  sub_22524B77C();
}

void sub_22524B820(uint64_t a1, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2);
  _os_crash();
  __break(1u);
  JUMPOUT(0x22524B85CLL);
}

void *zip_write_file_header(uint64_t a1, uint64_t a2, char a3)
{
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  size_t v16;
  void *result;
  void *v18;
  BOOL v19;
  uint64_t v20;
  unsigned __int16 v21;
  int8x16_t v22;
  uint64x2_t v23;
  int8x16_t v24;
  uint64_t v25;
  _BYTE v26[18];
  int32x2_t v27;
  __int16 v28;
  __int16 v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD **)a1;
  (*(void (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)a1 + 8))(**(_QWORD **)a1, *(_QWORD *)(a1 + 32) + 30, 0);
  if (*(char *)(a1 + 31) < 0)
  {
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 >= 0x10000)
      return 0;
    v7 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    v7 = a1 + 8;
    v8 = *(unsigned __int8 *)(a1 + 31);
  }
  v9 = ((uint64_t (*)(_QWORD, uint64_t, unint64_t))v6[3])(*v6, v7, v8);
  v6[14] += v9;
  if (v9 != v8)
    return 0;
  if ((a3 & 1) == 0)
  {
    v10 = 0;
    if ((a3 & 2) == 0)
      goto LABEL_13;
    goto LABEL_11;
  }
  *(_OWORD *)v26 = *(_OWORD *)(a1 + 40);
  if (!write_extra_field(v6, 1, (uint64_t)v26, 0x10uLL))
    return 0;
  v10 = 20;
  if ((a3 & 2) != 0)
  {
LABEL_11:
    if (!write_extra_field(v6, 65534, a1 + 60, 0x20uLL))
      return 0;
    v10 += 36;
  }
LABEL_13:
  v11 = *(_QWORD *)(a1 + 32);
  v12 = v8 + 30;
  v13 = v10 + v11 + v8 + 30;
  if (!(v13 % a2))
    goto LABEL_22;
  v14 = (v13 + a2 + 3) & -a2;
  if (((v13 + a2 - 1) & -a2) >= v13 + 4)
    v14 = (v13 + a2 - 1) & -a2;
  v15 = v14 - v13;
  v16 = v14 - v13 - 4;
  if (v14 - v13 != 4)
  {
    result = malloc_type_malloc(v14 - v13 - 4, 0x5B51575uLL);
    if (!result)
      return result;
    v18 = result;
    bzero(result, v16);
    v19 = write_extra_field(v6, 0xFFFF, (uint64_t)v18, v16);
    free(v18);
    if (!v19)
      return 0;
    goto LABEL_21;
  }
  *(_DWORD *)v26 = 0xFFFF;
  v20 = ((uint64_t (*)(_QWORD, _BYTE *, uint64_t))v6[3])(*v6, v26, 4);
  v6[14] += v20;
  if (v20 != 4)
    return 0;
LABEL_21:
  v10 += v15;
  v11 = *(_QWORD *)(a1 + 32);
LABEL_22:
  *(_DWORD *)v26 = 67324752;
  if ((a3 & 1) != 0)
    v21 = 45;
  else
    v21 = 20;
  *(_DWORD *)&v26[4] = v21;
  *(_WORD *)&v26[8] = *(_WORD *)(a1 + 92);
  *(_DWORD *)&v26[10] = *(_DWORD *)(a1 + 94);
  *(_DWORD *)&v26[14] = *(_DWORD *)(a1 + 56);
  v28 = v8;
  v29 = v10;
  v22 = *(int8x16_t *)(a1 + 40);
  v23.i64[0] = 0xFFFFFFFFLL;
  v23.i64[1] = 0xFFFFFFFFLL;
  v24 = (int8x16_t)vcgtq_u64(v23, (uint64x2_t)v22);
  v27 = vrev64_s32(vmovn_s64((int64x2_t)vornq_s8(vandq_s8(v22, v24), v24)));
  ((void (*)(_QWORD, uint64_t, _QWORD))v6[1])(*v6, v11, 0);
  v25 = ((uint64_t (*)(_QWORD, _BYTE *, uint64_t))v6[3])(*v6, v26, 30);
  v6[14] += v25;
  if (v25 != 30)
    return 0;
  ((void (*)(_QWORD, unint64_t, _QWORD))v6[1])(*v6, *(_QWORD *)(a1 + 32) + v10 + v12, 0);
  if (v10 + v8 >= 0x10000)
    return 0;
  else
    return (void *)(v10 + v12);
}

BOOL write_extra_field(_QWORD *a1, __int16 a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  _BOOL8 result;
  uint64_t v10;
  uint64_t v11;
  _WORD v12[2];
  uint64_t v13;
  uint64_t v14;

  if (a4 >> 16)
    return 0;
  v13 = v4;
  v14 = v5;
  v12[0] = a2;
  v12[1] = a4;
  v10 = ((uint64_t (*)(_QWORD, _WORD *, uint64_t))a1[3])(*a1, v12, 4);
  a1[14] += v10;
  result = 0;
  if (v10 == 4)
  {
    if (!a4)
      return 1;
    v11 = ((uint64_t (*)(_QWORD, uint64_t, unint64_t))a1[3])(*a1, a3, a4);
    a1[14] += v11;
    if (v11 == a4)
      return 1;
  }
  return result;
}

void ___ZN2re33assetsHighFrequencyLoggingEnabledEv_block_invoke(uint64_t a1, const char *a2)
{
  re *v2;
  unsigned __int8 v3;
  NSObject *v4;
  _DWORD v5[2];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  re::Defaults::BOOLValue((re::Defaults *)"enableAssetsHFLogs", a2, (char *)v5);
  if (LOBYTE(v5[0]))
    v3 = BYTE1(v5[0]);
  else
    v3 = 0;
  re::assetsLogObjects(v2);
  v4 = re::assetsLogObjects(void)::logObjects;
  if (os_log_type_enabled((os_log_t)re::assetsLogObjects(void)::logObjects, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = v3;
    _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "enableAssetsHFLogs=%d.", (uint8_t *)v5, 8u);
  }
  re::assetsHighFrequencyLoggingEnabled(void)::shouldLog = v3;
}

uint64_t *re::assetsLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::assetsLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Assets");
  }
  return &re::assetsLogObjects(void)::logObjects;
}

uint64_t *re::allocInfo_NetworkSendBlockingAssetLoadRequestService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_54);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_54))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC750, 0);
    *(uint64_t *)((char *)&qword_2540FC760 + 6) = 0;
    qword_2540FC760 = 0;
    qword_2540FC770 = 0;
    qword_2540FC778 = 0xFFFFFFFFLL;
    qword_2540FC750 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC780 = (uint64_t)"NetworkSendBlockingAssetLoadRequestService";
    dword_2540FC788 = 0;
    *(_OWORD *)&algn_2540FC78C[4] = 0u;
    *(_OWORD *)&algn_2540FC78C[20] = 0u;
    *(_OWORD *)&algn_2540FC78C[36] = 0u;
    qword_2540FC7C0 = 0;
    __cxa_guard_release(&_MergedGlobals_54);
  }
  return &qword_2540FC750;
}

void re::initInfo_NetworkSendBlockingAssetLoadRequestService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x1AFAAC597CC96262;
  v5[1] = "NetworkSendBlockingAssetLoadRequestService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_NetworkSendBlockingAssetLoadRequestService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_NetworkSendBlockingAssetLoadRequestService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"NetworkSendBlockingAssetLoadRequestService", (uint64_t (*)(re::internal *))re::allocInfo_NetworkSendBlockingAssetLoadRequestService, (re::IntrospectionBase *(*)(void))re::initInfo_NetworkSendBlockingAssetLoadRequestService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NetworkSendBlockingAssetLoadRequestService>, this);
}

re::AssetHandle *re::AssetHandle::AssetHandle(re::AssetHandle *this, re::internal::AssetEntry *a2)
{
  uint64_t v3;
  re::internal::AssetReference *v5;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = 0;
  re::internal::AssetEntry::makeAssetReference(a2, &v5);
  v3 = *(_QWORD *)this;
  *(_QWORD *)this = v5;
  if (v3)

  return this;
}

uint64_t *re::AssetHandle::AssetHandle(uint64_t *a1, re::internal::AssetEntry *this)
{
  uint64_t v3;
  re::internal::AssetReference *v5;

  *a1 = 0;
  a1[1] = (uint64_t)this;
  a1[2] = 0;
  if (this)
  {
    re::internal::AssetEntry::makeAssetReference(this, &v5);
    v3 = *a1;
    *a1 = (uint64_t)v5;
    if (v3)

  }
  return a1;
}

void re::AssetHandle::~AssetHandle(re::AssetHandle *this)
{
  uint64_t *v2;
  uint64_t v3;

  v2 = (uint64_t *)*((_QWORD *)this + 2);
  if (v2)
  {
    v3 = *v2;
    if (*v2)
    {
      if ((v2[1] & 1) != 0)
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(*v2, v2[2]);
      *(_OWORD *)v2 = 0u;
      *((_OWORD *)v2 + 1) = 0u;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 40))(v3, v2);
    *((_QWORD *)this + 2) = 0;
  }
  if (*(_QWORD *)this)
  {

    *(_QWORD *)this = 0;
  }
}

uint64_t *re::AssetHandle::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  re::AssetPath *v5;
  uint64_t v6;
  uint64_t v7;

  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a1, *a2);
  a1[1] = a2[1];
  v4 = a2[2];
  if (v4)
  {
    if ((*(_BYTE *)(v4 + 8) & 1) != 0)
      v5 = *(re::AssetPath **)(v4 + 16);
    else
      v5 = (re::AssetPath *)(v4 + 9);
    re::AssetHandle::setSerializationString((re::DynamicString *)a1, v5, *(re::Allocator **)v4);
  }
  else
  {
    v6 = a1[2];
    if (v6)
    {
      v7 = *(_QWORD *)v6;
      if (*(_QWORD *)v6)
      {
        if ((*(_BYTE *)(v6 + 8) & 1) != 0)
          (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v7 + 40))(*(_QWORD *)v6, *(_QWORD *)(v6 + 16));
        *(_OWORD *)v6 = 0u;
        *(_OWORD *)(v6 + 16) = 0u;
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 40))(v7, v6);
      a1[2] = 0;
    }
  }
  return a1;
}

re::DynamicString *re::AssetHandle::setSerializationString(re::DynamicString *this, re::AssetPath *a2, re::Allocator *a3)
{
  uint64_t v3;
  uint64_t *v4;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];

  v3 = (uint64_t)this;
  v4 = (uint64_t *)*((_QWORD *)this + 2);
  if (*(_BYTE *)a2)
  {
    if (!v4)
    {
      v7 = (_QWORD *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a3 + 32))(a3, 32, 8);
      v7[2] = 0;
      v7[3] = 0;
      *v7 = a3;
      v7[1] = 0;
      re::DynamicString::setCapacity(v7, 0);
      *(_QWORD *)(v3 + 16) = v7;
    }
    v10[0] = re::AssetPath::fixLegacyPath(a2, (const char *)a2);
    v10[1] = v8;
    return re::DynamicString::operator=(*(re::DynamicString **)(v3 + 16), (uint64_t)v10);
  }
  else if (v4)
  {
    v9 = *v4;
    if (*v4)
    {
      if ((v4[1] & 1) != 0)
        (*(void (**)(uint64_t, uint64_t, re::Allocator *))(*(_QWORD *)v9 + 40))(*v4, v4[2], a3);
      *(_OWORD *)v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
    }
    this = (re::DynamicString *)(*(uint64_t (**)(uint64_t, uint64_t *, re::Allocator *))(*(_QWORD *)v9 + 40))(v9, v4, a3);
    *(_QWORD *)(v3 + 16) = 0;
  }
  return this;
}

re::AssetHandle *re::AssetHandle::AssetHandle(re::AssetHandle *this, const re::AssetHandle *a2)
{
  uint64_t v4;
  re::AssetPath *v5;
  uint64_t *v6;
  uint64_t v7;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)this, *(_QWORD *)a2);
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  v4 = *((_QWORD *)a2 + 2);
  if (v4)
  {
    if ((*(_BYTE *)(v4 + 8) & 1) != 0)
      v5 = *(re::AssetPath **)(v4 + 16);
    else
      v5 = (re::AssetPath *)(v4 + 9);
    re::AssetHandle::setSerializationString(this, v5, *(re::Allocator **)v4);
  }
  else
  {
    v6 = (uint64_t *)*((_QWORD *)this + 2);
    if (v6)
    {
      v7 = *v6;
      if (*v6)
      {
        if ((v6[1] & 1) != 0)
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 40))(*v6, v6[2]);
        *(_OWORD *)v6 = 0u;
        *((_OWORD *)v6 + 1) = 0u;
      }
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v7 + 40))(v7, v6);
      *((_QWORD *)this + 2) = 0;
    }
  }
  return this;
}

re::AssetManager *re::AssetHandle::isAnyDependencyMutated@<X0>(re::AssetManager *this@<X0>, _BYTE *a2@<X8>)
{
  const re::internal::AssetEntry *v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  _BYTE v7[16];
  uint64_t v8;
  uint64_t v9;

  v3 = (const re::internal::AssetEntry *)*((_QWORD *)this + 1);
  if (v3 && (this = (re::AssetManager *)*((_QWORD *)v3 + 3)) != 0)
  {
    re::AssetManager::findDependencies(this, v3, (uint64_t)v7);
    if (v8)
    {
      v4 = v9 + 8;
      v5 = 24 * v8;
      while (!*(_BYTE *)(*(_QWORD *)v4 + 256))
      {
        v4 += 24;
        v5 -= 24;
        if (!v5)
          goto LABEL_7;
      }
      v6 = 1;
    }
    else
    {
LABEL_7:
      v6 = 0;
    }
    *a2 = 1;
    a2[1] = v6;
    return (re::AssetManager *)re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v7);
  }
  else
  {
    *a2 = 0;
  }
  return this;
}

void re::AssetHandle::loadNow(uint64_t a1, int a2)
{
  unsigned int v3;
  os_unfair_lock_s *v4;
  re *v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  NSObject *v12;
  uint64_t v13;
  re *v15;
  NSObject *v16;
  unsigned int v17;
  re *v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  const char *v26;
  NSObject *v27;
  uint32_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  __int16 v32;
  const char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v8 = *re::assetsLogObjects(0);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      return;
    LOWORD(v30) = 0;
    v9 = "load failed: can't load empty asset handle.";
    v10 = v8;
    v11 = 2;
    goto LABEL_24;
  }
  if (!*(_QWORD *)(a1 + 24))
  {
    v12 = *re::assetsLogObjects((re *)a1);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      return;
    if ((*(_BYTE *)(a1 + 168) & 1) != 0)
      v13 = *(_QWORD *)(a1 + 176);
    else
      v13 = a1 + 169;
    v30 = 136315138;
    v31 = v13;
    v9 = "load failed: asset isn't in an asset manager '%s'";
    v10 = v12;
    v11 = 12;
LABEL_24:
    _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v30, v11);
    return;
  }
  v3 = atomic_load((unsigned int *)(a1 + 704));
  if (v3 == 2)
    return;
  if (v3 == 3)
  {
    v4 = (os_unfair_lock_s *)(a1 + 384);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 384));
    v6 = *re::assetsLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      if ((*(_BYTE *)(a1 + 168) & 1) != 0)
        v7 = *(_QWORD *)(a1 + 176);
      else
        v7 = a1 + 169;
      v22 = *(_QWORD *)(a1 + 728);
      v23 = *(_QWORD *)(v22 + 224);
      v24 = *(const char **)(v22 + 232);
      v25 = (const char *)(v22 + 225);
      if ((v23 & 1) != 0)
        v25 = v24;
      v30 = 136315394;
      v31 = v7;
      v32 = 2080;
      v33 = v25;
      v26 = "load failed: asset loading already has failed '%s' (%s)";
LABEL_32:
      v27 = v6;
      v28 = 22;
LABEL_39:
      _os_log_error_impl(&dword_224FE9000, v27, OS_LOG_TYPE_ERROR, v26, (uint8_t *)&v30, v28);
    }
LABEL_16:
    os_unfair_lock_unlock(v4);
    return;
  }
  v4 = (os_unfair_lock_s *)(a1 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 384));
  if (*(_BYTE *)(a1 + 417) || *(_DWORD *)(a1 + 120) == 4)
  {
    v16 = *re::assetsLogObjects(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      if ((*(_BYTE *)(a1 + 168) & 1) != 0)
        v21 = *(_QWORD *)(a1 + 176);
      else
        v21 = a1 + 169;
      v30 = 136315138;
      v31 = v21;
      v26 = "loadNow doesn't work on network loaded assets. Use AssetLoadRequest instead. For '%s'";
      v27 = v16;
      v28 = 12;
      goto LABEL_39;
    }
    goto LABEL_16;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 384));
  re::AssetManager::loadNow(*(unsigned __int8 **)(a1 + 24), (os_unfair_lock_s *)a1, a2);
  v17 = atomic_load((unsigned int *)(a1 + 704));
  if (v17 != 2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 384));
    v19 = *(_QWORD *)(a1 + 728);
    if (*(_BYTE *)(v19 + 208))
    {
      if ((*(_BYTE *)(v19 + 224) & 1) != 0)
        v20 = *(const char **)(v19 + 232);
      else
        v20 = (const char *)(v19 + 225);
    }
    else
    {
      v20 = "unknown reason";
    }
    v6 = *re::assetsLogObjects(v18);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      goto LABEL_16;
    if ((*(_BYTE *)(a1 + 168) & 1) != 0)
      v29 = *(_QWORD *)(a1 + 176);
    else
      v29 = a1 + 169;
    v30 = 136315394;
    v31 = v29;
    v32 = 2080;
    v33 = v20;
    v26 = "load failed: couldn't load '%s' (%s)";
    goto LABEL_32;
  }
}

void re::AssetHandle::loadAsync(re::AssetHandle *this)
{
  uint64_t v1;
  unsigned __int8 *v2;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 1);
  if (v1)
  {
    v2 = *(unsigned __int8 **)(v1 + 24);
    if (v2)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v1 + 384));
      re::AssetManager::loadAssetAsync_entryStateLocked(v2, (re::internal::AssetEntry *)v1, 0);
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 384));
    }
    else
    {
      v4 = *re::assetsLogObjects(this);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5 = *((_QWORD *)this + 1);
        if ((*(_BYTE *)(v5 + 168) & 1) != 0)
          v6 = *(_QWORD *)(v5 + 176);
        else
          v6 = v5 + 169;
        v7 = 136315138;
        v8 = v6;
        _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "Can't load asset that isn't in an asset manager '%s'", (uint8_t *)&v7, 0xCu);
      }
    }
  }
}

void re::AssetHandle::internalForceUnloadAsync(re::AssetHandle *this)
{
  uint64_t v1;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 1);
  if (v1)
  {
    v3 = *(_QWORD *)(v1 + 24);
    if (v3)
    {
      re::AssetManager::unloadAssetAsync(v3, v1, 1);
    }
    else
    {
      v4 = *re::assetsLogObjects(0);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5 = *((_QWORD *)this + 1);
        if ((*(_BYTE *)(v5 + 168) & 1) != 0)
          v6 = *(_QWORD *)(v5 + 176);
        else
          v6 = v5 + 169;
        v7 = 136315138;
        v8 = v6;
        _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "Can't unload asset that isn't in an asset manager '%s'", (uint8_t *)&v7, 0xCu);
      }
    }
  }
}

void re::AssetHandle::loadFailedErrorCode(re::AssetHandle *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  unsigned int v4;
  os_unfair_lock_s *v6;
  uint64_t v7;
  int v8;

  v3 = *((_QWORD *)this + 1);
  if (v3 && (v4 = atomic_load((unsigned int *)(v3 + 704)), v4 == 3))
  {
    v6 = (os_unfair_lock_s *)(*((_QWORD *)this + 1) + 384);
    os_unfair_lock_lock(v6);
    v7 = *(_QWORD *)(*((_QWORD *)this + 1) + 728);
    v8 = *(unsigned __int8 *)(v7 + 196);
    *(_BYTE *)a2 = v8;
    if (v8)
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v7 + 200);
    os_unfair_lock_unlock(v6);
  }
  else
  {
    *(_BYTE *)a2 = 0;
  }
}

void re::AssetHandle::loadFailedMessage(re::AssetHandle *this@<X0>, re::DynamicString *a2@<X8>)
{
  uint64_t v3;
  unsigned int v4;
  os_unfair_lock_s *v6;
  uint64_t v7;
  _anonymous_namespace_ *v8;
  const re::DynamicString *v9;
  uint64_t v10;
  char v11;

  v3 = *((_QWORD *)this + 1);
  if (v3 && (v4 = atomic_load((unsigned int *)(v3 + 704)), v4 == 3))
  {
    v6 = (os_unfair_lock_s *)(*((_QWORD *)this + 1) + 384);
    os_unfair_lock_lock(v6);
    v7 = *(_QWORD *)(*((_QWORD *)this + 1) + 728);
    if (*(_BYTE *)(v7 + 208))
      v9 = (const re::DynamicString *)(v7 + 216);
    else
      v9 = (const re::DynamicString *)&v10;
    re::DynamicString::DynamicString(a2, v9);
    if (v10)
    {
      if ((v11 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v10 + 40))();
    }
    os_unfair_lock_unlock(v6);
  }
  else
  {
  }
}

void *re::AssetHandle::legacy_assetPath(re::AssetHandle *this)
{
  uint64_t v1;
  unsigned __int8 v3;
  unsigned __int8 v4;

  v1 = *((_QWORD *)this + 1);
  if (v1)
    return (void *)(v1 + 32);
  {
    byte_255827308 = 0;
    unk_255827300 = "assetPathNull allocator";
  }
}

void re::AssetHandle::getLegacyAppPath(re::AssetHandle *this@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v3;
  os_unfair_lock_s *v4;
  int v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  re::DynamicString *v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  _BYTE v14[8];
  uint64_t v15;
  char v16;
  uint64_t v17;
  _QWORD v18[2];
  uint64_t v19;
  uint64_t v20;

  v3 = *((_QWORD *)this + 1);
  if (!v3)
    goto LABEL_14;
  v4 = *(os_unfair_lock_s **)(v3 + 24);
  if (!v4)
    goto LABEL_14;
  v6 = *((_DWORD *)re::AssetHandle::assetInfo(this) + 22);
  if (v6 == 1)
  {
    v10 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(this);
    v11 = *((_QWORD *)v10 + 1);
    v18[1] = 0;
    v19 = 0;
    v17 = v11;
    v18[0] = 0;
    re::DynamicString::setCapacity(&v17, 0);
    re::AssetPath::fullAssetPath(v10, (re::DynamicString *)&v17);
    if (re::AssetPath::pathIsAppBased((uint64_t)&v17))
    {
      *a2 = 1;
      re::DynamicString::DynamicString((re::DynamicString *)(a2 + 8), (const re::DynamicString *)&v17);
    }
    else
    {
      *a2 = 0;
    }
    if (v17 && (v18[0] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v17 + 40))();
    return;
  }
  if (v6 != 8)
  {
LABEL_14:
    *a2 = 0;
    return;
  }
  re::AssetManager::lookupLoadDescriptors(v4, this, &v17);
  if (!v19)
  {
LABEL_12:
    if ((_BYTE)v17)
      re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v18);
    goto LABEL_14;
  }
  v7 = v20;
  v8 = 144 * v19;
  while (1)
  {
    v9 = (*(_QWORD *)(v7 + 8) & 1) != 0 ? *(const char **)(v7 + 16) : (const char *)(v7 + 9);
    if (!strcmp(v9, "AssetPath"))
      break;
    v7 += 144;
    v8 -= 144;
    if (!v8)
      goto LABEL_12;
  }
  *(_QWORD *)&v13 = re::AssetManager::convertToAssetPath((uint64_t)v4, v7, 12, (uint64_t)v14).n128_u64[0];
  if (v14[0])
  {
    if (re::AssetPath::pathIsAppBased((uint64_t)&v15))
    {
      *a2 = 1;
      re::DynamicString::DynamicString((re::DynamicString *)(a2 + 8), (const re::DynamicString *)&v15);
    }
    else
    {
      *a2 = 0;
    }
    if (v15 && (v16 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v15 + 40))();
    if ((_BYTE)v17)
      re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v18);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v12, v13, "assertion failure: '%s' (%s:line %i) Converting loadDescriptor to asset path failed.", "result.isOk()", "getLegacyAppPath", 427);
    _os_crash();
    __break(1u);
  }
}

void *re::AssetHandle::assetInfo(re::AssetHandle *this)
{
  uint64_t v1;
  unsigned __int8 v3;
  unsigned __int8 v4;

  v1 = *((_QWORD *)this + 1);
  if (v1)
    return (void *)(v1 + 32);
  if ((v3 & 1) == 0
  {
    byte_255827380 = 0;
    *(_QWORD *)algn_255827378 = "assetInformationNull allocator";
  }
  if ((v4 & 1) != 0
  {
  }
}

void re::AssetHandle::getDescription(re::AssetHandle *this@<X0>, char a2@<W1>, re::DynamicString *a3@<X8>)
{
  const re::internal::AssetEntry *v4;
  os_unfair_lock_s *v6;

  v4 = (const re::internal::AssetEntry *)*((_QWORD *)this + 1);
  if (v4)
  {
    v6 = (os_unfair_lock_s *)*((_QWORD *)v4 + 3);
    os_unfair_lock_lock(v6 + 16);
    re::AssetManager::getDescription_assetTablesLocked((re::AssetManager *)v6, v4, a2, (uint64_t)a3);
    os_unfair_lock_unlock(v6 + 16);
  }
  else
  {
  }
}

uint64_t re::AssetPathMapping::lookupString(re::AssetPathMapping *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  uint64_t result;

  if (!*((_QWORD *)a3 + 1))
    return 0;
  result = re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::tryGet((uint64_t)this, (uint64_t)a3);
  if (result)
  {
    re::DynamicString::operator=(a2, (re::DynamicString *)result);
    return 1;
  }
  return result;
}

uint64_t re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v7;

  v2 = *(_QWORD *)(a2 + 8);
  if (v2)
    v3 = *(_QWORD *)(v2 + 664);
  else
    v3 = 0;
  if (!*(_QWORD *)a1)
    return 0;
  v4 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v3 ^ (v4 >> 31) ^ v4) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v7 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v7 + 72 * v5 + 24) != v2)
  {
    while (1)
    {
      LODWORD(v5) = *(_DWORD *)(v7 + 72 * v5 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v5 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v7 + 72 * v5 + 24) == v2)
        return v7 + 72 * v5 + 40;
    }
    return 0;
  }
  return v7 + 72 * v5 + 40;
}

uint64_t re::AssetHandle::introspectionSerialize(_QWORD *a1, uint64_t a2, re::DynamicString *a3, re::AssetSerializationScheme *a4)
{
  uint64_t v5;
  unsigned __int8 v6[88];

  if (a1)
    return (*(uint64_t (**)(_QWORD, re::AssetSerializationScheme *))(*(_QWORD *)*a1 + 16))(*a1, a4);
  v6[0] = 0;
  v5 = re::AssetSerializationScheme::commonCodingKey(a4, a3, (const re::AssetHandle *)0xC, v6);
  re::Optional<re::AssetPath>::~Optional((uint64_t)v6);
  return v5;
}

uint64_t re::AssetHandle::introspectionDeserialize(re::Allocator *a1, _QWORD *a2, int a3, re::DynamicString *a4, char *__s1)
{
  char *v6;
  uint64_t v9;
  __int128 v10;
  const char *v11;
  int v12;
  void *v13;
  std::string *v14;
  int64_t v15;
  std::string *p_str;
  std::string *v17;
  int64_t size;
  char *v19;
  char *v20;
  std::string::size_type v21;
  std::string *v22;
  std::string *v23;
  char v24;
  int v26;
  std::string *v27;
  int64_t v28;
  char *v29;
  char *v30;
  void *v31;
  _QWORD v32[3];
  void *__p;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  std::string v37;
  std::string v38;
  std::string __str;
  char **v40;

  if (*__s1)
  {
    v6 = __s1;
    if (!strncmp(__s1, "framework:", 0xAuLL))
    {
      std::string::basic_string[abi:nn180100]<0>(&__str, v6);
      std::string::basic_string[abi:nn180100]<0>(&__p, "/");
      if (v30[23] < 0)
      {
        std::string::__init_copy_ctor_external(&v38, *(const std::string::value_type **)v30, *((_QWORD *)v30 + 1));
      }
      else
      {
        v10 = *(_OWORD *)v30;
        v38.__r_.__value_.__r.__words[2] = *((_QWORD *)v30 + 2);
        *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v10;
      }
      v37.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
      if (SHIBYTE(v35) < 0)
        operator delete(__p);
      std::string::basic_string[abi:nn180100]<0>(&__p, ":");
      if (v30[47] < 0)
        std::string::__init_copy_ctor_external(&v37, *((const std::string::value_type **)v30 + 3), *((_QWORD *)v30 + 4));
      else
        v37 = *(std::string *)(v30 + 1);
      v40 = &v30;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v40);
      if (SHIBYTE(v35) < 0)
        operator delete(__p);
      v12 = SHIBYTE(v37.__r_.__value_.__r.__words[2]);
      v13 = (void *)v37.__r_.__value_.__r.__words[0];
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v14 = &v37;
      else
        v14 = (std::string *)v37.__r_.__value_.__r.__words[0];
      if (re::isEngineFrameworkIdentifier((re *)v14, v11))
      {
        v15 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_str = &__str;
        else
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v17 = &v38;
        else
          v17 = (std::string *)v38.__r_.__value_.__r.__words[0];
        if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(v38.__r_.__value_.__r.__words[2]);
        else
          size = v38.__r_.__value_.__l.__size_;
        if (size)
        {
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v15 = __str.__r_.__value_.__l.__size_;
          v19 = (char *)p_str + v15;
          if (v15 >= size)
          {
            v26 = v17->__r_.__value_.__s.__data_[0];
            v27 = p_str;
            do
            {
              v28 = v15 - size;
              if (v28 == -1)
                break;
              v29 = (char *)memchr(v27, v26, v28 + 1);
              if (!v29)
                break;
              v20 = v29;
              if (!memcmp(v29, v17, size))
                goto LABEL_36;
              v27 = (std::string *)(v20 + 1);
              v15 = v19 - (v20 + 1);
            }
            while (v15 >= size);
          }
          v20 = v19;
LABEL_36:
          if (v20 == v19)
            v21 = -1;
          else
            v21 = v20 - (char *)p_str;
        }
        else
        {
          v21 = 0;
        }
        v22 = std::string::replace(&__str, v21, size + 1, "engine:");
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v23 = &__str;
        else
          v23 = (std::string *)__str.__r_.__value_.__r.__words[0];
        LOBYTE(v30) = 1;
        v6 = v35;
        v32[1] = v35;
        v32[2] = v36;
        v24 = v34;
        v31 = __p;
        v32[0] = v34;
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v37.__r_.__value_.__l.__data_);
        if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v38.__r_.__value_.__l.__data_);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str.__r_.__value_.__l.__data_);
        if ((v24 & 1) == 0)
          v6 = (char *)v32 + 1;
        if (a2)
          goto LABEL_4;
        goto LABEL_58;
      }
      if (v12 < 0)
        operator delete(v13);
      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v38.__r_.__value_.__l.__data_);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
    }
    LOBYTE(v30) = 0;
    if (a2)
    {
LABEL_4:
      v9 = (*(uint64_t (**)(_QWORD, re::DynamicString *, char *, re::Allocator *))(*(_QWORD *)*a2 + 24))(*a2, a4, v6, a1);
LABEL_59:
      if ((_BYTE)v30 && v31 && (v32[0] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v31 + 40))();
      return v9;
    }
LABEL_58:
    re::AssetHandle::setSerializationString(a4, (re::AssetPath *)v6, a1);
    v9 = 1;
    goto LABEL_59;
  }
  if (*(_QWORD *)a4)
  {

    *(_QWORD *)a4 = 0;
  }
  *((_QWORD *)a4 + 1) = 0;
  return 1;
}

uint64_t re::AssetHandle::introspectionDeepCopy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  re::AssetHandle::operator=(a5, a4);
  return 1;
}

uint64_t re::AssetHandle::hasAssetHandle(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v12;
  unint64_t v13;
  const char *v14;
  uint64_t *v15;
  uint64_t v16;
  _BYTE v17[32];
  _QWORD *v18[4];
  uint64_t v19[4];
  uint64_t v20;
  _BYTE v21[32];
  _BYTE v22[32];
  uint64_t v23;
  const char *v24;
  int v25;

  v2 = *a1;
  v23 = 0x190DE9534BBF230;
  v24 = "AssetHandle";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v23);
  if (v3)
  {
    v4 = *v3;
  }
  else
  {
    v2 = 0;
    v4 = 0xFFFFFFFFLL;
  }
  re::StringID::destroyString((re::StringID *)&v23);
  v5 = (uint64_t *)a1[2];
  if (*a1 == v2)
  {
    v6 = *v5;
    if ((unsigned __int16)*v5 == (unsigned __int16)v4)
    {
      v8 = WORD1(v6) == WORD1(v4);
      v7 = (v6 ^ v4) & 0xFFFFFF00000000;
      v8 = v8 && v7 == 0;
      if (v8)
        return 1;
    }
  }
  v9 = *((unsigned __int8 *)a1 + 12);
  if (v9 == 5)
  {
    re::TypeRegistry::typeInfo((_QWORD *)*a1, v5[9], &v23);
    re::TypeInfo::TypeInfo((uint64_t)v19, (uint64_t)&v24);
    v10 = re::TypeInfo::TypeInfo((uint64_t)v22, (uint64_t)v19);
    if ((re::AssetHandle::hasAssetHandle(v10) & 1) != 0)
      return 1;
    v9 = *((unsigned __int8 *)a1 + 12);
  }
  if (v9 == 6)
  {
    re::TypeRegistry::typeInfo((_QWORD *)*a1, *(_QWORD *)(a1[2] + 80), &v23);
    re::TypeInfo::TypeInfo((uint64_t)v19, (uint64_t)&v24);
    re::TypeInfo::TypeInfo((uint64_t)v21, (uint64_t)v19);
    if ((re::AssetHandle::hasAssetHandle(v21) & 1) != 0)
      return 1;
    v9 = *((unsigned __int8 *)a1 + 12);
  }
  if (v9 == 8)
  {
    re::TypeMemberCollection::TypeMemberCollection((uint64_t)v19, *a1, a1[2]);
    v12 = v20;
    if (v20)
    {
      v13 = 0;
      while (1)
      {
        re::TypeMemberCollection::operator[](v19, v13, (uint64_t)v18);
        re::TypeRegistry::typeInfo(v18[0], *v18[2], &v23);
        re::TypeInfo::TypeInfo((uint64_t)v17, (uint64_t)&v24);
        if ((re::AssetHandle::hasAssetHandle(v17) & 1) != 0)
          break;
        if (v12 == ++v13)
          return 0;
      }
      return 1;
    }
    v14 = *(const char **)a1[2];
    v23 = *a1;
    v24 = v14;
    v25 = -1;
    v18[0] = (_QWORD *)0x258C98EAAF29A10ALL;
    v18[1] = "CallbackSerializerAttribute";
    v15 = (uint64_t *)re::TypeAttributeCollection::operator[](&v23, v18);
    re::StringID::destroyString((re::StringID *)v18);
    if (v15)
    {
      v16 = *v15;
      if (*v15)
      {
        if (*(_QWORD *)(v16 + 96) && *(_QWORD *)(v16 + 104))
          return 1;
      }
    }
  }
  return 0;
}

uint64_t re::AssetHandle::assetWithType(re::AssetHandle *this, const re::AssetType *a2, int a3)
{
  uint64_t result;
  unsigned int v6;
  re *hasAssetPointer;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  result = *((_QWORD *)this + 1);
  if (result)
  {
    if (a3)
    {
      v6 = atomic_load((unsigned int *)(result + 704));
      if (v6 != 2)
        return 0;
    }
    else
    {
      re::AssetHandle::loadNow(result, 0);
    }
    hasAssetPointer = (re *)re::internal::AssetEntry::hasAssetPointer(*((re::internal::AssetEntry **)this + 1));
    if ((hasAssetPointer & 1) == 0)
    {
      v8 = *re::assetsLogObjects(hasAssetPointer);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *((_QWORD *)this + 1);
        if ((*(_BYTE *)(v9 + 168) & 1) != 0)
          v10 = *(_QWORD *)(v9 + 176);
        else
          v10 = v9 + 169;
        v11 = *(_QWORD *)a2;
        v12 = 136315394;
        v13 = v10;
        v14 = 2080;
        v15 = v11;
        _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "Asset %s with type %s has no asset pointer.", (uint8_t *)&v12, 0x16u);
      }
    }
    return re::internal::AssetEntry::assetPointer(*((re::internal::AssetEntry **)this + 1));
  }
  return result;
}

void re::AssetHandle::internalCloneAssetFromSharedAsset(re::AssetHandle *this)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  re::internal::AssetEntry *v4;
  re::AssetLoader *v5;
  void *v6;
  re::internal::SharedAssetPointer *v7;
  _anonymous_namespace_ *v8;

  if ((int)objc_msgSend((id)(*(_QWORD *)(*((_QWORD *)this + 1) + 712) + 8), "retainCount") >= 2)
  {
    v2 = *((_QWORD *)this + 1);
    if (v2)
    {
      if (*(_QWORD *)(v2 + 24))
      {
        v3 = (os_unfair_lock_s *)(v2 + 384);
        os_unfair_lock_lock((os_unfair_lock_t)(v2 + 384));
        v4 = (re::internal::AssetEntry *)*((_QWORD *)this + 1);
        v5 = (re::AssetLoader *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(*((_QWORD *)v4 + 3) + 1104), *((_QWORD *)v4 + 33));
        v6 = (void *)re::internal::AssetEntry::assetPointer(v4);
        v7 = (re::internal::SharedAssetPointer *)re::AssetLoader::cloneAsset(v5, v6);
        re::internal::SharedAssetPointer::makeSharedAssetPointer(v7, &v8);
        re::internal::AssetEntry::LoadState::setAssetPointer_locked((__uint64_t)v4 + 704, (uint64_t *)&v8);
        if (v8)

        re::AssetHandle::internalRegisterAsset(this);
        os_unfair_lock_unlock(v3);
      }
    }
  }
}

uint64_t re::AssetHandle::internalRegisterAsset(re::AssetHandle *this)
{
  re::internal::AssetEntry *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v2 = (re::internal::AssetEntry *)*((_QWORD *)this + 1);
  v3 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(*((_QWORD *)v2 + 3) + 1104), *((_QWORD *)v2 + 33));
  v4 = re::internal::AssetEntry::assetPointer(v2);
  v5 = re::AssetHandle::assetInfo(this);
  return (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(_QWORD *)v3 + 80))(v3, v4, v5);
}

uint64_t re::AssetHandle::internalUnregisterAsset(re::AssetHandle *this)
{
  re::internal::AssetEntry *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v2 = (re::internal::AssetEntry *)*((_QWORD *)this + 1);
  v3 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(*((_QWORD *)v2 + 3) + 1104), *((_QWORD *)v2 + 33));
  v4 = re::internal::AssetEntry::assetPointer(v2);
  v5 = re::AssetHandle::assetInfo(this);
  return (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(_QWORD *)v3 + 88))(v3, v4, v5);
}

uint64_t re::AssetHandle::setNetworkSharingMode(uint64_t a1, int a2)
{
  os_unfair_lock_s *v4;
  re *v5;
  uint64_t v6;
  int v7;
  _BOOL8 v8;
  NSObject *v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint8_t v15[16];

  v4 = (os_unfair_lock_s *)(*(_QWORD *)(a1 + 8) + 384);
  os_unfair_lock_lock(v4);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_DWORD *)(v6 + 420);
  v8 = v7 == a2;
  if (v7 == a2)
  {
LABEL_5:
    os_unfair_lock_unlock(v4);
    return v8;
  }
  if (v7)
  {
    v9 = *re::assetsLogObjects(v5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v15 = 0;
      _os_log_error_impl(&dword_224FE9000, v9, OS_LOG_TYPE_ERROR, "setNetworkSharingMode: re-enabling network sharing is not supported.", v15, 2u);
    }
    goto LABEL_5;
  }
  *(_DWORD *)(v6 + 420) = a2;
  os_unfair_lock_unlock(v4);
  v11 = *(_QWORD *)(a1 + 8);
  v12 = *(_QWORD *)(v11 + 24);
  if (*(_QWORD *)(v12 + 1208))
  {
    v13 = *(_QWORD *)(v11 + 112);
    if (v13 == -1)
      v14 = 0;
    else
      v14 = v13;
    re::NetworkActionQueue::queueSyncActionRestrictAssetShareMode(v12 + 768, v14, a2);
  }
  return 1;
}

void re::AssetHandle::payloadDidChangeIfPossible(re::AssetHandle *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v1 + 312))
  {
    if (*((_DWORD *)re::AssetHandle::assetInfo(this) + 22) != 8)
      return;
    v1 = *((_QWORD *)this + 1);
  }
  re::AssetManager::assetPayloadDidChange(*(re::AssetManager **)(v1 + 24), (re::internal::AssetEntry *)v1);
}

BOOL re::AssetHandle::isMemoryAssetWithNetworkingSyncingEnabled(re::AssetHandle *this)
{
  uint64_t v1;
  os_unfair_lock_s *v2;
  int v3;

  v1 = *((_QWORD *)this + 1);
  if (!*(_BYTE *)(v1 + 312))
    return 0;
  v2 = (os_unfair_lock_s *)(v1 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 384));
  v3 = *(_DWORD *)(v1 + 420);
  os_unfair_lock_unlock(v2);
  return v3 == 0;
}

re::DynamicString *re::AssetHandle::serializationString@<X0>(re::AssetHandle *this@<X0>, re::DynamicString *a2@<X8>)
{
  const re::DynamicString *v3;

  v3 = (const re::DynamicString *)*((_QWORD *)this + 2);
  if (v3)
    return re::DynamicString::DynamicString(a2, v3);
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *((_QWORD *)a2 + 3) = 0;
  return (re::DynamicString *)re::DynamicString::setCapacity(a2, 0);
}

double re::AssetHandle::setOrClearMetadataString(re::AssetHandle *this, const char *a2, const char *a3)
{
  os_unfair_lock_s *v6;
  _QWORD v8[2];

  v6 = (os_unfair_lock_s *)*((_QWORD *)this + 1);
  v8[0] = 0;
  v8[1] = &str_110;
  os_unfair_lock_lock(v6 + 96);
  re::internal::AssetEntry::setOrClearMetadata_stateLocked((re::internal::AssetEntry *)v6, (const re::StringID *)v8, a3);
  os_unfair_lock_unlock(v6 + 96);
  re::StringID::destroyString((re::StringID *)v8);
  return re::internal::AssetEntry::updateMetadata(*((re::internal::AssetEntry **)this + 1), 0);
}

void re::AssetHandle::composedMetadata(re::AssetHandle *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  StringID v15;

  *(_DWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 36) = 0x7FFFFFFFLL;
  v4 = *((_QWORD *)this + 1);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 1208);
  if (v5 && (unint64_t)(*(_QWORD *)(v4 + 112) + 1) >= 2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 72))(v5);
    v4 = *((_QWORD *)this + 1);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 384));
  v6 = *(unsigned int *)(v4 + 456);
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = (int *)(*(_QWORD *)(v4 + 440) + 8);
    while (1)
    {
      v9 = *v8;
      v8 += 22;
      if (v9 < 0)
        break;
      if (v6 == ++v7)
      {
        LODWORD(v7) = *(_DWORD *)(v4 + 456);
        break;
      }
    }
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if ((_DWORD)v6 != (_DWORD)v7)
  {
    v10 = v7;
    v11 = *(_QWORD *)(v4 + 440);
    do
    {
      v12 = v11 + 88 * v10;
      re::StringID::StringID((re::StringID *)&v15, (const re::DynamicString *)(v12 + 16));
      if (*(_BYTE *)(v12 + 48))
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addInternal<re::DynamicString&>(a2, &v15, 2, (const re::DynamicString *)(v11 + 88 * v10 + 56));
      else
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(a2, &v15);
      re::StringID::destroyString((re::StringID *)&v15);
      v13 = *(_DWORD *)(v4 + 456);
      v11 = *(_QWORD *)(v4 + 440);
      if (v13 <= (int)v7 + 1)
        v13 = v7 + 1;
      while (1)
      {
        v10 = (v7 + 1);
        if (v13 - 1 == (_DWORD)v7)
          break;
        LODWORD(v7) = v7 + 1;
        v14 = v10;
        if ((*(_DWORD *)(v11 + 88 * v10 + 8) & 0x80000000) != 0)
          goto LABEL_21;
      }
      v14 = v13;
LABEL_21:
      LODWORD(v7) = v14;
    }
    while ((_DWORD)v6 != v14);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 384));
}

__CFDictionary *re::AssetHandle::copyComposedMetadataCFDR(re::AssetHandle *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  _BYTE *v12;
  CFStringRef v13;
  uint64_t v14;
  const char *v15;
  CFStringRef v16;
  unsigned int v17;
  unsigned int v18;
  __CFDictionary *theDict;

  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0, 0);
  v2 = *((_QWORD *)this + 1);
  v3 = *(_QWORD *)(*(_QWORD *)(v2 + 24) + 1208);
  if (v3 && (unint64_t)(*(_QWORD *)(v2 + 112) + 1) >= 2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 80))(v3);
    v2 = *((_QWORD *)this + 1);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 384));
  v4 = *(unsigned int *)(v2 + 456);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(v2 + 440) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 22;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(v2 + 456);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    v9 = *(_QWORD *)(v2 + 440);
    do
    {
      v10 = v9 + 88 * v8;
      if ((*(_BYTE *)(v10 + 24) & 1) != 0)
        v11 = *(const char **)(v9 + 88 * v8 + 32);
      else
        v11 = (const char *)(v9 + 88 * v8 + 25);
      v12 = (_BYTE *)(v10 + 48);
      v13 = CFStringCreateWithCString(0, v11, 0x8000100u);
      if (*v12)
      {
        v14 = v9 + 88 * v8;
        if ((*(_BYTE *)(v14 + 64) & 1) != 0)
          v15 = *(const char **)(v14 + 72);
        else
          v15 = (const char *)(v14 + 65);
        v16 = CFStringCreateWithCString(0, v15, 0x8000100u);
        if (CFDictionaryContainsKey(theDict, v13))
          CFDictionaryReplaceValue(theDict, v13, v16);
        else
          CFDictionaryAddValue(theDict, v13, v16);
        CFRelease(v16);
      }
      else
      {
        CFDictionaryRemoveValue(theDict, v13);
      }
      CFRelease(v13);
      v17 = *(_DWORD *)(v2 + 456);
      v9 = *(_QWORD *)(v2 + 440);
      if (v17 <= (int)v5 + 1)
        v17 = v5 + 1;
      while (1)
      {
        v8 = (v5 + 1);
        if (v17 - 1 == (_DWORD)v5)
          break;
        LODWORD(v5) = v5 + 1;
        v18 = v8;
        if ((*(_DWORD *)(v9 + 88 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_30;
      }
      v18 = v17;
LABEL_30:
      LODWORD(v5) = v18;
    }
    while ((_DWORD)v4 != v18);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 384));
  return theDict;
}

void re::AssetHandle::serializableAsset(re::AssetHandle *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  unsigned int v5;
  re::internal::AssetEntry *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)this + 1);
  if (v3 && *(_QWORD *)(v3 + 24))
  {
    v5 = atomic_load((unsigned int *)(v3 + 704));
    if (v5 == 2)
    {
      v6 = (re::internal::AssetEntry *)*((_QWORD *)this + 1);
      v7 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(*((_QWORD *)v6 + 3) + 1104), *((_QWORD *)v6 + 33));
      v8 = re::internal::AssetEntry::assetPointer(v6);
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 256))(v7, v8);
      return;
    }
    v9 = *re::assetsLogObjects(this);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *((_QWORD *)this + 1);
      if ((*(_BYTE *)(v10 + 168) & 1) != 0)
        v11 = *(_QWORD *)(v10 + 176);
      else
        v11 = v10 + 169;
      v12 = 136315138;
      v13 = v11;
      _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEFAULT, "Cannot create serializableAsset for %s, as the asset is not loaded.", (uint8_t *)&v12, 0xCu);
    }
  }
  *a2 = 0;
  a2[4] = 0;
}

re::DynamicString *re::AssetHandle::getOrBuildSerializationString@<X0>(re::AssetHandle *this@<X0>, re::DynamicString *a2@<X8>)
{
  const re::DynamicString *v3;
  re::DynamicString *v5;
  uint64_t v6;

  v3 = (const re::DynamicString *)*((_QWORD *)this + 2);
  if (v3)
    return re::DynamicString::DynamicString(a2, v3);
  v5 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(this);
  v6 = *((_QWORD *)v5 + 1);
  *((_QWORD *)a2 + 2) = 0;
  *((_QWORD *)a2 + 3) = 0;
  *(_QWORD *)a2 = v6;
  *((_QWORD *)a2 + 1) = 0;
  re::DynamicString::setCapacity(a2, 0);
  return re::AssetPath::fullAssetPath(v5, a2);
}

void *re::introspect_AssetHandle(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  re::IntrospectionBasic *v10;
  _QWORD v11[2];
  __int128 v12;

  v2 = (int)this;
  {
    v10 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_AssetHandle(BOOL)::info, "AssetHandle", 24, 8, 0, 0);
    *(_QWORD *)v10 = &off_24ED7DA28;
    *((_QWORD *)v10 + 8) = re::internal::defaultConstruct<re::AssetHandle>;
    *((_QWORD *)v10 + 9) = re::AssetHandle::introspectionSerialize;
    *((_QWORD *)v10 + 10) = re::AssetHandle::introspectionDeserialize;
    *((_QWORD *)v10 + 11) = re::AssetHandle::introspectionDeepCopy;
    *((_QWORD *)v10 + 12) = 0;
    *((_QWORD *)v10 + 13) = 0;
    *((_DWORD *)v10 + 4) = 11;
  }
  if (v2)
  {
    if ((re::introspect_AssetHandle(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_AssetHandle(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v12);
    v4 = re::introspect_AssetHandle(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v12);
    if ((v4 & 1) != 0)
      return &re::introspect_AssetHandle(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
    if ((re::introspect_AssetHandle(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
      return &re::introspect_AssetHandle(BOOL)::info;
    }
  }
  re::introspect_AssetHandle(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_AssetHandle(BOOL)::info, a2);
  v11[0] = 0x190DE9534BBF230;
  v11[1] = "AssetHandle";
  xmmword_255827298 = v12;
  re::StringID::destroyString((re::StringID *)v11);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_AssetHandle(BOOL)::info;
}

void re::internal::defaultConstruct<re::AssetHandle>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
}

_QWORD *re::internal::defaultConstructV2<re::AssetHandle>(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

uint64_t *re::allocInfo_SharedAssetHandle(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_55);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_55))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC7E0, 0);
    *(uint64_t *)((char *)&qword_2540FC7F0 + 6) = 0;
    qword_2540FC7F0 = 0;
    qword_2540FC800 = 0;
    qword_2540FC808 = 0xFFFFFFFFLL;
    qword_2540FC7E0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC810 = (uint64_t)"SharedAssetHandle";
    dword_2540FC818 = 0;
    unk_2540FC820 = 0u;
    unk_2540FC830 = 0u;
    unk_2540FC840 = 0u;
    qword_2540FC850 = 0;
    __cxa_guard_release(&_MergedGlobals_55);
  }
  return &qword_2540FC7E0;
}

void re::initInfo_SharedAssetHandle(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  __int128 v9;
  _QWORD v10[2];
  __int128 v11;

  v10[0] = 0x91C4B88E416096E6;
  v10[1] = "SharedAssetHandle";
  re::StringID::destroyString((re::StringID *)v10);
  *((_OWORD *)this + 2) = v11;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FC7D8);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FC7D8);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::introspect_AssetHandle((re *)1, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "assetHandle";
      *(_QWORD *)(v8 + 16) = &re::introspect_AssetHandle(BOOL)::info;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 0x1800000001;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_2540FC7D0 = v8;
      __cxa_guard_release(&qword_2540FC7D8);
    }
  }
  *((_QWORD *)this + 2) = 0x3000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 8) = &qword_2540FC7D0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::SharedAssetHandle>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::SharedAssetHandle>;
  *((_QWORD *)this + 11) = re::internal::defaultRetain<re::SharedAssetHandle>(void)::{lambda(void *)#1}::__invoke;
  *((_QWORD *)this + 12) = re::internal::defaultRelease<re::SharedAssetHandle>(void)::{lambda(void *)#1}::__invoke;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::SharedAssetHandle>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::SharedAssetHandle>;
  re::IntrospectionRegistry::add(this, v3);
  v9 = v11;
}

void re::internal::defaultConstruct<re::SharedAssetHandle>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a3, 0);
  *(_QWORD *)a3 = &off_24ED2EAD0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
}

uint64_t re::internal::defaultDestruct<re::SharedAssetHandle>(uint64_t a1, uint64_t a2, uint64_t (***a3)(_QWORD))
{
  return (**a3)(a3);
}

void re::internal::defaultConstructV2<re::SharedAssetHandle>(uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24ED2EAD0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
}

uint64_t re::internal::defaultDestructV2<re::SharedAssetHandle>(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t re::introspect_SharedAssetHandle(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"SharedAssetHandle", (uint64_t (*)(re::internal *))re::allocInfo_SharedAssetHandle, (re::IntrospectionBase *(*)(void))re::initInfo_SharedAssetHandle, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::SharedAssetHandle>, this);
}

void `anonymous namespace'::splitString(char **a1, std::string *__str, char *a3)
{
  int64_t size;
  std::string *v7;
  int v8;
  char *v9;
  int64_t v10;
  std::string::size_type v11;
  unint64_t v12;
  unint64_t v13;
  __int128 v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  int64_t v20;
  std::allocator<std::string> *v21;
  unint64_t v22;
  unint64_t v23;
  __int128 v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  __int128 v31;
  unint64_t v32;
  char *v33;
  char *v34;
  __int128 v35;
  int64x2_t v36;
  char *v37;
  std::string *v38;
  int v39;
  int v40;
  std::string::size_type v41;
  std::string *v42;
  int64_t v43;
  char *v44;
  char *v45;
  char *v46;
  int64_t v47;
  int v48;
  int64_t v49;
  char *v50;
  char *v51;
  char *v52;
  int v53;
  std::string *v54;
  int64_t v55;
  char *v56;
  char *v57;
  char *v58;
  __int128 v59;
  unint64_t v60;
  char *v61;
  char *v62;
  __int128 v63;
  int64x2_t v64;
  char *v65;
  std::string *v66;
  int v67;
  std::string v68;
  std::__split_buffer<std::string> v69;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) == 0)
    v7 = __str;
  else
    v7 = (std::string *)__str->__r_.__value_.__r.__words[0];
  v8 = a3[23];
  if (v8 >= 0)
    v9 = a3;
  else
    v9 = *(char **)a3;
  if (v8 >= 0)
    v10 = a3[23];
  else
    v10 = *((_QWORD *)a3 + 1);
  if (v10)
  {
    if ((size & 0x80u) != 0)
      size = __str->__r_.__value_.__l.__size_;
    if (size >= v10)
    {
      v52 = (char *)v7 + size;
      v53 = *v9;
      v54 = v7;
      do
      {
        v55 = size - v10;
        if (v55 == -1)
          break;
        v56 = (char *)memchr(v54, v53, v55 + 1);
        if (!v56)
          break;
        v57 = v56;
        if (!memcmp(v56, v9, v10))
        {
          v11 = 0;
          if (v57 != v52)
          {
            v20 = v57 - (char *)v7;
            if (v20 != -1)
              goto LABEL_26;
          }
          goto LABEL_15;
        }
        v54 = (std::string *)(v57 + 1);
        size = v52 - (v57 + 1);
      }
      while (size >= v10);
    }
    v11 = 0;
  }
  else
  {
    v20 = 0;
LABEL_26:
    v11 = 0;
    v21 = (std::allocator<std::string> *)(a1 + 2);
    do
    {
      std::string::basic_string(&v68, __str, v11, v20 - v11, (std::allocator<char> *)&v69);
      v23 = (unint64_t)a1[1];
      v22 = (unint64_t)a1[2];
      if (v23 >= v22)
      {
        v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - (_QWORD)*a1) >> 3);
        v26 = v25 + 1;
        if (v25 + 1 > 0xAAAAAAAAAAAAAAALL)
          goto LABEL_87;
        v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - (_QWORD)*a1) >> 3);
        if (2 * v27 > v26)
          v26 = 2 * v27;
        if (v27 >= 0x555555555555555)
          v28 = 0xAAAAAAAAAAAAAAALL;
        else
          v28 = v26;
        v69.__end_cap_.__value_ = v21;
        if (v28)
          v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)v21, v28);
        else
          v29 = 0;
        v30 = &v29[24 * v25];
        v31 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
        *((_QWORD *)v30 + 2) = *((_QWORD *)&v68.__r_.__value_.__l + 2);
        *(_OWORD *)v30 = v31;
        memset(&v68, 0, sizeof(v68));
        v33 = *a1;
        v32 = (unint64_t)a1[1];
        if ((char *)v32 == *a1)
        {
          v36 = vdupq_n_s64(v32);
          v34 = &v29[24 * v25];
        }
        else
        {
          v34 = &v29[24 * v25];
          do
          {
            v35 = *(_OWORD *)(v32 - 24);
            *((_QWORD *)v34 - 1) = *(_QWORD *)(v32 - 8);
            *(_OWORD *)(v34 - 24) = v35;
            v34 -= 24;
            *(_QWORD *)(v32 - 16) = 0;
            *(_QWORD *)(v32 - 8) = 0;
            *(_QWORD *)(v32 - 24) = 0;
            v32 -= 24;
          }
          while ((char *)v32 != v33);
          v36 = *(int64x2_t *)a1;
        }
        v37 = v30 + 24;
        *a1 = v34;
        a1[1] = v30 + 24;
        *(int64x2_t *)&v69.__begin_ = v36;
        v38 = (std::string *)a1[2];
        a1[2] = &v29[24 * v28];
        v69.__end_cap_.__value_ = v38;
        v69.__first_ = (std::__split_buffer<std::string>::pointer)v36.i64[0];
        std::__split_buffer<std::string>::~__split_buffer(&v69);
        v39 = SHIBYTE(v68.__r_.__value_.__r.__words[2]);
        a1[1] = v37;
        if (v39 < 0)
          operator delete(v68.__r_.__value_.__l.__data_);
      }
      else
      {
        v24 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
        *(_QWORD *)(v23 + 16) = *((_QWORD *)&v68.__r_.__value_.__l + 2);
        *(_OWORD *)v23 = v24;
        a1[1] = (char *)(v23 + 24);
      }
      v40 = a3[23];
      v41 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
      if ((v41 & 0x80u) == 0)
        v42 = __str;
      else
        v42 = (std::string *)__str->__r_.__value_.__r.__words[0];
      if ((v41 & 0x80u) != 0)
        v41 = __str->__r_.__value_.__l.__size_;
      v43 = v40 >= 0 ? a3[23] : *((_QWORD *)a3 + 1);
      v11 = v43 + v20;
      v44 = v40 >= 0 ? a3 : *(char **)a3;
      if (v41 < v11)
        break;
      v20 += v43;
      if (v43)
      {
        v45 = (char *)v42 + v11;
        v46 = (char *)v42 + v41;
        v47 = v41 - v11;
        if (v47 < v43)
          break;
        v48 = *v44;
        while (1)
        {
          v49 = v47 - v43;
          if (v49 == -1)
            goto LABEL_15;
          v50 = (char *)memchr(v45, v48, v49 + 1);
          if (!v50)
            goto LABEL_15;
          v51 = v50;
          if (!memcmp(v50, v44, v43))
            break;
          v45 = v51 + 1;
          v47 = v46 - (v51 + 1);
          if (v47 < v43)
            goto LABEL_15;
        }
        if (v51 == v46)
          break;
        v20 = v51 - (char *)v42;
      }
      v21 = (std::allocator<std::string> *)(a1 + 2);
    }
    while (v20 != -1);
  }
LABEL_15:
  std::string::basic_string(&v68, __str, v11, ~v11, (std::allocator<char> *)&v69);
  v12 = (unint64_t)a1[2];
  v13 = (unint64_t)a1[1];
  if (v13 >= v12)
  {
    v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (_QWORD)*a1) >> 3);
    v16 = v15 + 1;
    if (v15 + 1 > 0xAAAAAAAAAAAAAAALL)
LABEL_87:
      abort();
    v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - (_QWORD)*a1) >> 3);
    if (2 * v17 > v16)
      v16 = 2 * v17;
    if (v17 >= 0x555555555555555)
      v18 = 0xAAAAAAAAAAAAAAALL;
    else
      v18 = v16;
    v69.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)(a1 + 2), v18);
    else
      v19 = 0;
    v58 = &v19[24 * v15];
    v59 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
    *((_QWORD *)v58 + 2) = *((_QWORD *)&v68.__r_.__value_.__l + 2);
    *(_OWORD *)v58 = v59;
    memset(&v68, 0, sizeof(v68));
    v61 = *a1;
    v60 = (unint64_t)a1[1];
    if ((char *)v60 == *a1)
    {
      v64 = vdupq_n_s64(v60);
      v62 = &v19[24 * v15];
    }
    else
    {
      v62 = &v19[24 * v15];
      do
      {
        v63 = *(_OWORD *)(v60 - 24);
        *((_QWORD *)v62 - 1) = *(_QWORD *)(v60 - 8);
        *(_OWORD *)(v62 - 24) = v63;
        v62 -= 24;
        *(_QWORD *)(v60 - 16) = 0;
        *(_QWORD *)(v60 - 8) = 0;
        *(_QWORD *)(v60 - 24) = 0;
        v60 -= 24;
      }
      while ((char *)v60 != v61);
      v64 = *(int64x2_t *)a1;
    }
    v65 = v58 + 24;
    *a1 = v62;
    a1[1] = v58 + 24;
    *(int64x2_t *)&v69.__begin_ = v64;
    v66 = (std::string *)a1[2];
    a1[2] = &v19[24 * v18];
    v69.__end_cap_.__value_ = v66;
    v69.__first_ = (std::__split_buffer<std::string>::pointer)v64.i64[0];
    std::__split_buffer<std::string>::~__split_buffer(&v69);
    v67 = SHIBYTE(v68.__r_.__value_.__r.__words[2]);
    a1[1] = v65;
    if (v67 < 0)
      operator delete(v68.__r_.__value_.__l.__data_);
  }
  else
  {
    v14 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
    *(_QWORD *)(v13 + 16) = *((_QWORD *)&v68.__r_.__value_.__l + 2);
    *(_OWORD *)v13 = v14;
    a1[1] = (char *)(v13 + 24);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(24 * a2);
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:nn180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:nn180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addInternal<re::DynamicString&>(uint64_t a1, StringID *a2, int a3, const re::DynamicString *a4)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  uint64_t v19;

  v7 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)&a2->var0 >> 31) ^ (*(_QWORD *)&a2->var0 >> 1));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DynamicString&>(a1, v9, v8, a2, a4);
    ++*(_DWORD *)(a1 + 40);
    v14 = *(_QWORD *)(a1 + 16) + 56 * v13;
    return v14 + 24;
  }
  v12 = *(_QWORD *)(a1 + 16);
  while (!re::StringID::operator==((_QWORD *)(v12 + 56 * v10 + 8), a2))
  {
    v10 = *(_DWORD *)(v12 + 56 * v10) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  switch(a3)
  {
    case 0:
    case 1:
      v14 = v12 + 56 * v10;
      break;
    case 2:
    case 3:
      v16 = v12 + 56 * v10;
      v19 = *(_QWORD *)(v16 + 24);
      v18 = (_OWORD *)(v16 + 24);
      v17 = v19;
      if (v19)
      {
        if ((*(_BYTE *)(v12 + 56 * v10 + 32) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 40))(v17, *(_QWORD *)(v12 + 56 * v10 + 40));
        *v18 = 0u;
        v18[1] = 0u;
        v12 = *(_QWORD *)(a1 + 16);
      }
      re::DynamicString::DynamicString((re::DynamicString *)(v12 + 56 * v10 + 24), a4);
      ++*(_DWORD *)(a1 + 40);
      v14 = *(_QWORD *)(a1 + 16) + 56 * v10;
      break;
    default:
      goto LABEL_8;
  }
  return v14 + 24;
}

void re::SharedAssetHandle::~SharedAssetHandle(re::SharedAssetHandle *this)
{
  *(_QWORD *)this = &off_24ED2EAD0;
  re::AssetHandle::~AssetHandle((re::SharedAssetHandle *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED2EAD0;
  re::AssetHandle::~AssetHandle((re::SharedAssetHandle *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

id re::internal::defaultRetain<re::SharedAssetHandle>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::SharedAssetHandle>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{

}

uint64_t *re::allocInfo_NamedFileAssetLoadDescriptorParameters(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_56);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_56))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FC870, 0);
    *(uint64_t *)((char *)&qword_2540FC880 + 6) = 0;
    qword_2540FC880 = 0;
    qword_2540FC890 = 0;
    qword_2540FC898 = 0xFFFFFFFFLL;
    qword_2540FC870 = (uint64_t)&off_24ED7DAA8;
    qword_2540FC8A0 = (uint64_t)"NamedFileAssetLoadDescriptorParameters";
    dword_2540FC8A8 = 0;
    unk_2540FC8B0 = 0u;
    unk_2540FC8C0 = 0u;
    unk_2540FC8D0 = 0u;
    qword_2540FC8E0 = 0;
    __cxa_guard_release(&_MergedGlobals_56);
  }
  return &qword_2540FC870;
}

void re::initInfo_NamedFileAssetLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0xD31F5603CC4AAF34;
  v11[1] = "NamedFileAssetLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FC868);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FC868);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicString>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "fileAliasName";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FC860 = v9;
      __cxa_guard_release(&qword_2540FC868);
    }
  }
  *((_QWORD *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 8) = &qword_2540FC860;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::NamedFileAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::NamedFileAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::NamedFileAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::NamedFileAssetLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

_QWORD *re::internal::defaultConstruct<re::NamedFileAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  return re::DynamicString::setCapacity((_QWORD *)a3, 0);
}

double re::internal::defaultDestruct<re::NamedFileAssetLoadDescriptorParameters>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;

  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::NamedFileAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  return re::DynamicString::setCapacity(a1, 0);
}

double re::internal::defaultDestructV2<re::NamedFileAssetLoadDescriptorParameters>(uint64_t *a1)
{
  uint64_t v2;
  double result;

  v2 = *a1;
  if (v2)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

_anonymous_namespace_ *re::NamedFileAssetProvider::NamedFileAssetProvider(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned __int8 v10;
  __guard *v11;
  int v13;

  ArcSharedObject::ArcSharedObject(a1, 0);
  *(_QWORD *)a1 = &off_24ED2EB18;
  *((_QWORD *)a1 + 5) = 0;
  *((_QWORD *)a1 + 6) = 0;
  *((_QWORD *)a1 + 4) = 0;
  if ((v10 & 1) == 0)
  {
    if (v13)
    {
      re::introspect<re::NamedFileAssetLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"NamedFileAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_NamedFileAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_NamedFileAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NamedFileAssetLoadDescriptorParameters>, 0);
    }
  }
  re::NamedFileAssetProvider::s_loadDescriptorParametersIntrospect = v11[236];
  *((_QWORD *)a1 + 3) = a2;
  *((_QWORD *)a1 + 4) = a3;
  *((_QWORD *)a1 + 5) = a4;
  *((_QWORD *)a1 + 6) = a5;
  return a1;
}

void re::NamedFileAssetProvider::~NamedFileAssetProvider(re::NamedFileAssetProvider *this)
{
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::NamedFileAssetProvider::makeDescriptor@<X0>(_anonymous_namespace_ *a1@<X0>, re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  _OWORD v11[2];
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a3, 0);
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_DWORD *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(_QWORD *)(a3 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a3 + 112), 0);
  v12 = (uint64_t *)"NamedFileAsset";
  v13 = 14;
  re::DynamicString::operator=((re::DynamicString *)a3, (uint64_t)&v12);
  v7 = re::DynamicString::operator=((re::DynamicString *)(a3 + 112), a2);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  re::DynamicString::setCapacity(&v12, 0);
  re::DynamicString::operator=((re::DynamicString *)&v12, a1);
  re::DynamicString::DynamicString((re::DynamicString *)v11, (const re::DynamicString *)&v12);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a3, (const re::IntrospectionBase *)re::NamedFileAssetProvider::s_loadDescriptorParametersIntrospect, (const re::IntrospectionBase **)v11, 0);
  if (*(_QWORD *)&v11[0])
  {
    if ((BYTE8(v11[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
    memset(v11, 0, sizeof(v11));
  }
  result = (uint64_t)v12;
  if (v12)
  {
    if ((v13 & 1) != 0)
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(*v12 + 40))(v12, v14, v8, v9);
  }
  return result;
}

re::DynamicString *re::NamedFileAssetProvider::load@<X0>(re::NamedFileAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  const char *v9;
  _anonymous_namespace_ *v10;
  re::DynamicString *result;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t Descriptor;
  os_unfair_lock_s *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  _OWORD v28[2];
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  re::DynamicString *v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;

  if ((*((_BYTE *)a2 + 8) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a2 + 2);
  else
    v9 = (char *)a2 + 9;
  v10 = (_anonymous_namespace_ *)strcmp(v9, "NamedFileAsset");
  if ((_DWORD)v10)
  {
    v12 = v29;
    v13 = v30;
    v14 = v31;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v12;
    *(_QWORD *)(a4 + 24) = v13;
    *(_QWORD *)(a4 + 32) = v14;
  }
  else
  {
    v33 = 0;
    v34 = 0;
    v35 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    Descriptor = re::AssetLoadDescriptor::getIntrospectableData<re::NamedFileAssetLoadDescriptorParameters>(a2, (uint64_t **)&v32);
    if ((Descriptor & 1) != 0)
    {
      v16 = (os_unfair_lock_s *)*((_QWORD *)this + 3);
      re::DynamicString::DynamicString((re::DynamicString *)v28, (const re::DynamicString *)&v32);
      re::NamedFileRegistry::tryGetFilePathFor(v16, (uint64_t)v28, &v29);
      if (*(_QWORD *)&v28[0])
      {
        if ((BYTE8(v28[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v28[0] + 40))();
        memset(v28, 0, sizeof(v28));
      }
      if ((_BYTE)v29)
      {
        if ((*((_BYTE *)a2 + 120) & 1) != 0)
          v17 = (char *)*((_QWORD *)a2 + 16);
        else
          v17 = (char *)a2 + 121;
        re::loadCompiledOrSourceFile((char *)&v29 + 8, v17, (re::internal::AssetTypeRegistry **)this + 4, (uint64_t)a3, a4);
      }
      else
      {
        if ((v33 & 1) != 0)
          v21 = v34;
        else
          v21 = (char *)&v33 + 1;
        re::DynamicString::format((re::DynamicString *)"No file found for FileAlias '%s'.", (re::DynamicString *)&v25, v21);
        v22 = v25;
        v23 = v26;
        v24 = v27;
        *(_BYTE *)a4 = 0;
        *(_OWORD *)(a4 + 8) = v22;
        *(_QWORD *)(a4 + 24) = v23;
        *(_QWORD *)(a4 + 32) = v24;
      }
      if ((_BYTE)v29 && *((_QWORD *)&v29 + 1) && (v30 & 1) != 0)
        (*(void (**)(void))(**((_QWORD **)&v29 + 1) + 40))();
    }
    else
    {
      v18 = v29;
      v19 = v30;
      v20 = v31;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v18;
      *(_QWORD *)(a4 + 24) = v19;
      *(_QWORD *)(a4 + 32) = v20;
    }
    result = v32;
    if (v32)
    {
      if ((v33 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v32 + 40))();
    }
  }
  return result;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<re::NamedFileAssetLoadDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  __guard *v4;
  int v6;
  int v7;
  re::AssetLoadDescriptor *v9;

  v2 = a2;
  if ((v3 & 1) == 0)
  {
    v9 = a1;
    v7 = v6;
    v2 = a2;
    a1 = v9;
    if (v7)
    {
      re::introspect<re::NamedFileAssetLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"NamedFileAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_NamedFileAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_NamedFileAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NamedFileAssetLoadDescriptorParameters>, 0);
      v2 = a2;
      a1 = v9;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)v4[236], v2, 0);
}

__n128 re::NamedFileAssetProvider::resolveChild@<Q0>(re::NamedFileAssetProvider *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v7;
  uint64_t v8;
  __n128 v9;
  uint64_t v10;
  uint64_t v11;

  result = v9;
  v7 = v10;
  v8 = v11;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v7;
  *(_QWORD *)(a2 + 32) = v8;
  return result;
}

uint64_t *re::NamedFileAssetProvider::getDescription(re::NamedFileAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  uint64_t *result;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];

  v7 = 0;
  v8 = 0;
  v9 = 0;
  re::DynamicString::setCapacity(&v6, 0);
  if (re::AssetLoadDescriptor::getIntrospectableData<re::NamedFileAssetLoadDescriptorParameters>(a2, &v6))
  {
    re::DynamicString::operator=(a3, (re::DynamicString *)&v6);
  }
  else
  {
    v10[0] = "mangled";
    v10[1] = 7;
    re::DynamicString::operator=(a3, (uint64_t)v10);
  }
  result = v6;
  if (v6)
  {
    if ((v7 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

const char *re::NamedFileAssetProvider::schemeName(re::NamedFileAssetProvider *this)
{
  return "NamedFileAsset";
}

id objectDecodeError(NSString *a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  NSString *v4;
  void *v5;
  void *v6;
  uint64_t v8;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x24BDAC8D0];
  v1 = (void *)MEMORY[0x24BDD1540];
  v2 = *MEMORY[0x24BDD0B88];
  v8 = *MEMORY[0x24BDD0BA0];
  v9[0] = a1;
  v3 = (void *)MEMORY[0x24BDBCE70];
  v4 = a1;
  objc_msgSend(v3, "dictionaryWithObjects:forKeys:count:", v9, &v8, 1);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "errorWithDomain:code:userInfo:", v2, 4864, v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  return v6;
}

void re::SharedResourcePayload::clientObject(id *this@<X0>, _QWORD *a2@<X8>)
{
  id v3;

  objc_msgSend(*this, "clientObject");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  *a2 = v3;

}

void re::makeResourceSharingError(__CFString *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  re::WrappedError::make((re::WrappedError *)CFSTR("REResourceSharingErrorDomain"), a1, a2, a3);
}

uint64_t re::BundleFilePathRegistry::registerBundleFilePath(os_unfair_lock_s *a1, uint64_t a2, uint64_t a3)
{
  re *v6;
  const char *v7;
  uint64_t v8;
  const char *v9;
  re *v10;
  int v11;
  NSObject *v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v25[2];
  _BYTE v26[8];
  uint64_t v27;
  char v28;
  _BYTE v29[7];
  const char *v30;
  uint8_t buf[4];
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  re::DynamicString::DynamicString((re::DynamicString *)v25, (const re::DynamicString *)a2);
  re::NamedFileRegistry::tryGetFilePathFor(a1, (uint64_t)v25, v26);
  v6 = *(re **)&v25[0];
  if (*(_QWORD *)&v25[0])
  {
    if ((BYTE8(v25[0]) & 1) != 0)
      v6 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)&v25[0] + 40))();
    memset(v25, 0, sizeof(v25));
  }
  if (!v26[0])
  {
    v18 = *re::assetsLogObjects(v6);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      if ((*(_BYTE *)(a2 + 8) & 1) != 0)
        v19 = *(_QWORD *)(a2 + 16);
      else
        v19 = a2 + 9;
      if ((*(_BYTE *)(a3 + 8) & 1) != 0)
        v23 = *(_QWORD *)(a3 + 16);
      else
        v23 = a3 + 9;
      *(_DWORD *)buf = 136315394;
      v32 = v19;
      v33 = 2080;
      v34 = v23;
      _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "BundleId '%s' manually registered for file '%s'", buf, 0x16u);
    }
    os_unfair_lock_lock(a1);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>((uint64_t)&a1[2], (re::DynamicString *)a2, (const re::DynamicString *)a3);
    os_unfair_lock_unlock(a1);
    goto LABEL_40;
  }
  if ((v28 & 1) != 0)
    v7 = v30;
  else
    v7 = v29;
  v8 = a3 + 9;
  if ((*(_QWORD *)(a3 + 8) & 1) != 0)
    v9 = *(const char **)(a3 + 16);
  else
    v9 = (const char *)(a3 + 9);
  v10 = (re *)strcmp(v7, v9);
  v11 = (int)v10;
  v12 = *re::assetsLogObjects(v10);
  v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (!v11)
  {
    if (v13)
    {
      if ((*(_BYTE *)(a2 + 8) & 1) != 0)
        v20 = *(_QWORD *)(a2 + 16);
      else
        v20 = a2 + 9;
      if ((*(_BYTE *)(a3 + 8) & 1) != 0)
        v8 = *(_QWORD *)(a3 + 16);
      *(_DWORD *)buf = 136315394;
      v32 = v20;
      v33 = 2080;
      v34 = v8;
      _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "BundleId '%s' already registered for file '%s'", buf, 0x16u);
    }
LABEL_40:
    v22 = 1;
    goto LABEL_41;
  }
  if (v13)
  {
    v16 = *(_QWORD *)(a2 + 8);
    if ((v16 & 1) != 0)
      v17 = *(_QWORD *)(a2 + 16);
    else
      v17 = a2 + 9;
    if ((*(_BYTE *)(a3 + 8) & 1) != 0)
      v8 = *(_QWORD *)(a3 + 16);
    if ((v16 & 1) != 0)
      v21 = *(_QWORD *)(a2 + 16);
    else
      v21 = a2 + 9;
    *(_DWORD *)buf = 136315650;
    v32 = v17;
    v33 = 2080;
    v34 = v8;
    v35 = 2080;
    v36 = v21;
    _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "Failed to register '%s' bundle for file '%s'! BundleId '%s' already registered for different file.", buf, 0x20u);
  }
  v22 = 0;
LABEL_41:
  if (v26[0] && v27 && (v28 & 1) != 0)
    (*(void (**)(uint64_t, const char *, uint64_t, uint64_t))(*(_QWORD *)v27 + 40))(v27, v30, v14, v15);
  return v22;
}

void re::BundleFilePathRegistry::findWithBundleID(os_unfair_lock_s *a1@<X0>, uint64_t a2@<X1>, id *a3@<X8>)
{
  re::Bundle *v6;
  uint64_t v7;
  uint64_t v8;
  re::Bundle *v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD v12[2];
  _BYTE v13[8];
  uint64_t v14;
  char v15;
  _BYTE v16[7];
  re::Bundle *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;

  re::DynamicString::DynamicString((re::DynamicString *)v12, (const re::DynamicString *)a2);
  re::NamedFileRegistry::tryGetFilePathFor(a1, (uint64_t)v12, v13);
  if (*(_QWORD *)&v12[0])
  {
    if ((BYTE8(v12[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v12[0] + 40))();
    memset(v12, 0, sizeof(v12));
  }
  if (v13[0])
  {
    if ((v15 & 1) != 0)
      v6 = v17;
    else
      v6 = (re::Bundle *)v16;
    re::Bundle::findWithFilePath(v6, a3);
  }
  else
  {
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v9 = *(re::Bundle **)(a2 + 16);
    else
      v9 = (re::Bundle *)(a2 + 9);
    re::Bundle::findWithBundleID(v9, a3);
    if (*a3)
    {
      os_unfair_lock_lock(a1);
      re::Bundle::bundlePath(a3, (re::DynamicString *)&v18);
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&a1[2], (re::DynamicString *)a2, &v18);
      if (v18 && (v19 & 1) != 0)
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v18 + 40))(v18, v20, v10, v11);
      os_unfair_lock_unlock(a1);
    }
  }
  if (v13[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(uint64_t, re::Bundle *, uint64_t, uint64_t))(*(_QWORD *)v14 + 40))(v14, v17, v7, v8);
}

__n128 re::AssetProvider::getAssetPathForRelease@<Q0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v3;
  __n128 result;
  uint64_t v5;
  uint64_t v6;
  __n128 v7;
  uint64_t v8;
  uint64_t v9;

  if ((*(_QWORD *)(a1 + 8) & 1) != 0)
    v3 = *(_QWORD *)(a1 + 16);
  else
    v3 = a1 + 9;
  re::DynamicString::format((re::DynamicString *)"No asset path for AssetLoadDescriptor type '%s'", (re::DynamicString *)&v7, v3);
  result = v7;
  v5 = v8;
  v6 = v9;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v5;
  *(_QWORD *)(a2 + 32) = v6;
  return result;
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_7, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + v3);
        ++v4;
        v3 += 56;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

BOOL re::AssetProviderRegistry::Tables::registerProvider(uint64_t a1, re::DynamicString *a2, uint64_t *a3)
{
  _BOOL4 v6;

  v6 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a1, (uint64_t)a2);
  if (!v6)
    re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::AssetProvider>&>(a1, a2, a3);
  return !v6;
}

uint64_t re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::AssetProvider>&>(uint64_t a1, re::DynamicString *a2, uint64_t *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char v14;

  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<re::SharedPtr<re::AssetProvider>&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 56 * v11;
    return v12 + 48;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 56 * v9 + 16, (uint64_t)a2))
  {
    v9 = *(_DWORD *)(v10 + 56 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v10 + 56 * v9;
  return v12 + 48;
}

BOOL re::AssetProviderRegistry::Tables::registerResolver(uint64_t a1, re::DynamicString *a2, uint64_t *a3)
{
  _BOOL8 v6;
  uint64_t v7;
  id v8;
  uint64_t v10;

  if (re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a1, (uint64_t)a2))
  {
    return 0;
  }
  re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::AssetProvider>&>(a1 + 48, a2, a3);
  v7 = *a3;
  v10 = v7;
  if (v7)
    v8 = (id)(v7 + 8);
  v6 = re::AssetProviderRegistry::Tables::registerProvider(a1, a2, &v10);
  if (v10)

  return v6;
}

BOOL re::AssetProviderRegistry::registerAssetProvider(os_unfair_lock_s *a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  uint64_t v7;
  id v8;
  _BOOL8 v9;
  uint64_t v11;
  uint64_t v12;
  char v13;

  v4 = a1 + 16;
  os_unfair_lock_lock(a1 + 16);
  v5 = (uint64_t)&a1[18];
  v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)*a2 + 32))(*a2);
  v7 = *a2;
  v11 = v7;
  if (v7)
    v8 = (id)(v7 + 8);
  v9 = re::AssetProviderRegistry::Tables::registerProvider(v5, (re::DynamicString *)&v12, &v11);
  if (v11)
  {

    v11 = 0;
  }
  if (v12 && (v13 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v12 + 40))();
  os_unfair_lock_unlock(v4);
  return v9;
}

BOOL re::AssetProviderRegistry::registerAssetResolverForScheme(os_unfair_lock_s *this, const char *a2, const char *(*a3)(const char *, const char *, void *), uint64_t a4, char a5)
{
  uint64_t *v10;
  uint64_t v11;
  _anonymous_namespace_ *v12;
  id v13;
  _BOOL8 v14;
  uint64_t v16;
  uint64_t v17;
  char v18;

  v10 = re::globalAllocators((re *)this);
  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10[2] + 32))(v10[2], 104, 8);
  re::ExternalResolverAssetProvider::ExternalResolverAssetProvider(v11, a2, a4, (uint64_t)a3, (__int128 *)this, a5);
  os_unfair_lock_lock(this + 16);
  v16 = v11;
  if (v11)
    v13 = (id)(v11 + 8);
  v14 = re::AssetProviderRegistry::Tables::registerResolver((uint64_t)&this[18], (re::DynamicString *)&v17, &v16);
  if (v16)
  {

    v16 = 0;
  }
  if (v17 && (v18 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v17 + 40))();
  os_unfair_lock_unlock(this + 16);
  if (v11)

  return v14;
}

uint64_t re::AssetProviderRegistry::tryGetProviderForScheme(os_unfair_lock_s *this, const char *a2)
{
  os_unfair_lock_s *v4;
  _anonymous_namespace_ *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v9;
  char v10;

  v4 = this + 16;
  os_unfair_lock_lock(this + 16);
  v6 = (uint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&this[18], (uint64_t)&v9);
  if (v6)
    v7 = *v6;
  else
    v7 = 0;
  if (v9 && (v10 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v9 + 40))();
  os_unfair_lock_unlock(v4);
  return v7;
}

void *re::AssetProviderRegistry::tryGetRawProviderForScheme(os_unfair_lock_s *this, const char *a2)
{
  void *result;

  result = (void *)re::AssetProviderRegistry::tryGetProviderForScheme(this, a2);
  if (result)
  return result;
}

double re::AssetProviderRegistry::getPathFromResolver@<D0>(os_unfair_lock_s *this@<X0>, const re::DynamicString *a2@<X1>, const re::DynamicString *a3@<X2>, uint64_t a4@<X8>)
{
  os_unfair_lock_s *v8;
  uint64_t *v9;
  uint64_t v10;
  re *v11;
  char *v12;
  uint64_t v13;
  NSObject *v14;
  double result;
  _anonymous_namespace_ *v16;
  const char *v17;
  NSObject *v18;
  char *v19;
  char *v20;
  const char *v21;
  NSObject *v22;
  uint32_t v23;
  char *v24;
  _BYTE v25[24];
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v8 = this + 16;
  os_unfair_lock_lock(this + 16);
  v9 = (uint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&this[30], (uint64_t)a2);
  if (!v9)
  {
    os_unfair_lock_unlock(v8);
LABEL_9:
    v14 = *re::assetsLogObjects(v11);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      if ((*((_QWORD *)a2 + 1) & 1) != 0)
        v24 = (char *)*((_QWORD *)a2 + 2);
      else
        v24 = (char *)a2 + 9;
      *(_DWORD *)v25 = 136315138;
      *(_QWORD *)&v25[4] = v24;
      v21 = "No resolver defined for %s";
      v22 = v14;
      v23 = 12;
      goto LABEL_27;
    }
LABEL_10:
    *(_BYTE *)a4 = 0;
    return result;
  }
  v10 = *v9;
  os_unfair_lock_unlock(v8);
  if (!v10)
    goto LABEL_9;
  if ((*((_BYTE *)a3 + 8) & 1) != 0)
    v12 = (char *)*((_QWORD *)a3 + 2);
  else
    v12 = (char *)a3 + 9;
  if ((*(_BYTE *)(v10 + 32) & 1) != 0)
    v13 = *(_QWORD *)(v10 + 40);
  else
    v13 = v10 + 33;
  v16 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, char *, _QWORD))(v10 + 56))(v13, v12, *(_QWORD *)(v10 + 64));
  if (!v16)
  {
    v18 = *re::assetsLogObjects(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      if ((*((_QWORD *)a2 + 1) & 1) != 0)
        v19 = (char *)*((_QWORD *)a2 + 2);
      else
        v19 = (char *)a2 + 9;
      if ((*((_QWORD *)a3 + 1) & 1) != 0)
        v20 = (char *)*((_QWORD *)a3 + 2);
      else
        v20 = (char *)a3 + 9;
      *(_DWORD *)v25 = 136315394;
      *(_QWORD *)&v25[4] = v19;
      *(_WORD *)&v25[12] = 2080;
      *(_QWORD *)&v25[14] = v20;
      v21 = "Resolver %s did not return a final path for %s";
      v22 = v18;
      v23 = 22;
LABEL_27:
      _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, v21, v25, v23);
      goto LABEL_10;
    }
    goto LABEL_10;
  }
  v17 = (const char *)v16;
  *(_BYTE *)a4 = 1;
  *(_QWORD *)(a4 + 8) = *(_QWORD *)v25;
  *(_QWORD *)(a4 + 32) = v26;
  result = *(double *)&v25[8];
  *(_OWORD *)(a4 + 16) = *(_OWORD *)&v25[8];
  return result;
}

uint64_t re::AssetProviderRegistry::deviceAssetPath@<X0>(os_unfair_lock_s *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  const char *v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;

  if ((*(_QWORD *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  result = re::AssetProviderRegistry::tryGetProviderForScheme(a1, v8);
  if (result
    && (v10 = result,
        result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 96))(result, a2, a3),
        (result & 1) != 0))
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, _QWORD, os_unfair_lock_s *, uint64_t))(*(_QWORD *)v10 + 104))(&v11, v10, a2, *(_QWORD *)&a1->_os_unfair_lock_opaque, a1, a3);
    if ((_BYTE)v11)
    {
      *a4 = 1;
      re::DynamicString::DynamicString((re::DynamicString *)(a4 + 8), (const re::DynamicString *)&v12);
    }
    else
    {
      *a4 = 0;
    }
    result = v12;
    if (v12)
    {
      if ((v13 & 1) != 0)
        return (*(uint64_t (**)(void))(*(_QWORD *)v12 + 40))();
    }
  }
  else
  {
    *a4 = 0;
  }
  return result;
}

uint64_t *re::AssetProviderRegistry::makeDescriptorForResolver@<X0>(re::AssetProviderRegistry *this@<X0>, const re::DynamicString *a2@<X1>, const re::DynamicString *a3@<X2>, uint64_t a4@<X8>)
{
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *result;
  _OWORD v14[2];
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  re::DynamicString::operator=((re::DynamicString *)a4, this);
  v10 = re::DynamicString::operator=((re::DynamicString *)(a4 + 112), a3);
  v16 = 0;
  v17 = 0;
  v18 = 0;
  re::DynamicString::setCapacity(&v15, 0);
  re::DynamicString::operator=((re::DynamicString *)&v15, a2);
  re::DynamicString::DynamicString((re::DynamicString *)v14, (const re::DynamicString *)&v15);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)re::ExternalResolverAssetProvider::s_loadDescriptorParametersIntrospect, (const re::IntrospectionBase **)v14, 0);
  if (*(_QWORD *)&v14[0])
  {
    if ((BYTE8(v14[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v14[0] + 40))();
    memset(v14, 0, sizeof(v14));
  }
  result = v15;
  if (v15)
  {
    if ((v16 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(*v15 + 40))(v15, v17, v11, v12);
  }
  return result;
}

re::DynamicString *re::loadCompiledOrSourceFile@<X0>(char *a1@<X0>, char *a2@<X1>, re::internal::AssetTypeRegistry **a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;
  _anonymous_namespace_ *LocalCompiledOrSourceAsset;
  char v12;
  __int128 v13;
  re::DynamicString *result;
  _anonymous_namespace_ *v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _BYTE v23[24];
  uint64_t v24;
  __int128 v25;
  char v26;
  char v27[16];
  uint64_t v28;
  re::DynamicString *v29;
  uint64_t v30;
  uint64_t v31;

  v10 = re::internal::AssetTypeRegistry::assetTypeWithName(*a3, a2);
  if (v10)
  {
    v27[0] = 0;
    LocalCompiledOrSourceAsset = (_anonymous_namespace_ *)re::AssetUtilities::loadLocalCompiledOrSourceAsset(a1, (uint64_t)a3, v10, a4, v27, 0, (uint64_t)&v28);
    if ((_BYTE)v28)
    {
      *(_QWORD *)&v23[8] = 0;
      *(_QWORD *)&v23[16] = 0;
      v24 = 0;
      re::DynamicString::setCapacity(v23, 0);
      BYTE8(v25) = 0;
      v26 = 0;
      *(_QWORD *)&v25 = v29;
      v20 = a2;
      *(_QWORD *)&v21 = strlen(a2);
      re::DynamicString::operator=((re::DynamicString *)v23, (uint64_t)&v20);
      re::DynamicString::DynamicString((re::DynamicString *)&v20, (const re::DynamicString *)v23);
      v12 = v26;
      v13 = v25;
      *(_BYTE *)a5 = 1;
      *(_QWORD *)(a5 + 8) = v20;
      *(_QWORD *)(a5 + 32) = v22;
      *(_OWORD *)(a5 + 16) = v21;
      *(_OWORD *)(a5 + 40) = v13;
      *(_BYTE *)(a5 + 56) = v12;
      result = *(re::DynamicString **)v23;
      if (*(_QWORD *)v23 && (v23[8] & 1) != 0)
        result = (re::DynamicString *)(*(uint64_t (**)(void))(**(_QWORD **)v23 + 40))();
    }
    else
    {
      result = re::DynamicString::DynamicString((re::DynamicString *)v23, (const re::DynamicString *)&v29);
      *(_BYTE *)a5 = 0;
      *(_QWORD *)(a5 + 8) = *(_QWORD *)v23;
      *(_QWORD *)(a5 + 32) = v24;
      *(_OWORD *)(a5 + 16) = *(_OWORD *)&v23[8];
    }
    if (!(_BYTE)v28)
    {
      result = v29;
      if (v29)
      {
        if ((v30 & 1) != 0)
        {
          v19 = v31;
          return (re::DynamicString *)(*(uint64_t (**)(re::DynamicString *, uint64_t))(*(_QWORD *)result + 40))(result, v19);
        }
      }
    }
  }
  else
  {
    re::DynamicString::operator+((re::DynamicString *)&v20, (uint64_t)&v28, (re::DynamicString *)v23);
    v16 = *(_OWORD *)v23;
    memset(v23, 0, sizeof(v23));
    v17 = *(_QWORD *)&v23[16];
    v18 = v24;
    v24 = 0;
    *(_BYTE *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v16;
    *(_QWORD *)(a5 + 24) = v17;
    *(_QWORD *)(a5 + 32) = v18;
    if (v28 && (v29 & 1) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v28 + 40))(v28, v30);
    result = (re::DynamicString *)v20;
    if (v20 && (v21 & 1) != 0)
    {
      v19 = *((_QWORD *)&v21 + 1);
      return (re::DynamicString *)(*(uint64_t (**)(re::DynamicString *, uint64_t))(*(_QWORD *)result + 40))(result, v19);
    }
  }
  return result;
}

void re::AssetProvider::getPreloadableDependencies(uint64_t a1@<X8>)
{
  uint64_t v2;
  uint64_t v3;

  re::WrappedError::make((re::WrappedError *)CFSTR("REAssetProviderErrorDomain"), (const __CFString *)1, (uint64_t)"This AssetProvider does not provide dependencies for AssetLoadDescriptors.", &v3);
  v2 = v3;
  v3 = 0;
  *(_BYTE *)a1 = 0;
  *(_QWORD *)(a1 + 8) = v2;

}

uint64_t re::AssetProvider::resolveChildPath@<X0>(re::AssetProvider *this@<X0>, re::PathBuffer *a2@<X1>, _QWORD *a3@<X8>)
{
  _anonymous_namespace_ *v7;
  const char *v8;
  re::PathBuffer *v9;
  const char *v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  char *v13;
  uint64_t v14;
  uint64_t result;
  _QWORD v16[2];
  uint64_t v17;
  _QWORD v18[3];
  const char *v19;
  _BYTE *v20;
  uint64_t v21;
  _BYTE v22[488];
  uint64_t *v23;
  _BYTE *v24;
  uint64_t v25;
  _BYTE v26[488];
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v24 = v26;
  v25 = 488;
  v26[0] = 0;
  v20 = v22;
  v21 = 488;
  v22[0] = 0;
  v9 = (re::PathBuffer *)re::path::dirname((re::path *)&v23, a2, v8);
  v11 = (_anonymous_namespace_ *)re::path::join(&v19, v9, (const char *)this, v10);
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  re::DynamicString::setCapacity(a3, 0);
  v13 = (char *)v18[1];
  if ((v18[0] & 1) == 0)
    v13 = (char *)v18 + 1;
  v14 = LOBYTE(v18[0]) >> 1;
  if ((v18[0] & 1) != 0)
    v14 = v18[0] >> 1;
  v16[0] = v13;
  v16[1] = v14;
  re::AssetPath::standardizePath(v16, (uint64_t)a3);
  result = v17;
  if (v17 && (v18[0] & 1) != 0)
    result = (*(uint64_t (**)(void))(*(_QWORD *)v17 + 40))();
  if (v20 != v22)
    result = (*(uint64_t (**)(const char *))(*(_QWORD *)v19 + 40))(v19);
  if (v24 != v26)
    return (*(uint64_t (**)(uint64_t *))(*v23 + 40))(v23);
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<re::SharedPtr<re::AssetProvider>&>(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  id v15;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 56 * v9 + 8) = v12 | 0x80000000;
  v13 = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 16), a4);
  v14 = *a5;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 48) = *a5;
  if (v14)
    v15 = (id)(v14 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v13) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  signed int v22;
  _BYTE v23[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(_QWORD *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v23, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v23;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)v23 = v5;
      *(_QWORD *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = DWORD1(v9);
        v13 = v7;
        v14 = (_QWORD *)(v6 + 48);
        do
        {
          if ((*(_DWORD *)(v14 - 5) & 0x80000000) != 0)
          {
            v15 = *(v14 - 6);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v12));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 56 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 56 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 56 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v18 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v18) = v15;
            re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v18 + 16), (const re::DynamicString *)(v14 - 4));
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v18 + 48) = *v14;
            *v14 = 0;
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 7;
        }
        while (v11 < v10);
      }
      re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2)
      v22 = a2;
    else
      v22 = 3;
  }
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_7, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

re::ExistingAssetInformation *re::ExistingAssetInformation::ExistingAssetInformation(re::ExistingAssetInformation *this, re::Allocator *a2)
{
  re::DynamicString *v4;
  re::AssetPath *v5;
  uint64_t v6;
  int v8;
  uint64_t v9;
  char v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  *(_DWORD *)this = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 1) = a2;
  v4 = (re::ExistingAssetInformation *)((char *)this + 8);
  re::DynamicString::setCapacity((_QWORD *)this + 1, 0);
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = a2;
  re::DynamicString::setCapacity((_QWORD *)this + 5, 0);
  *((_QWORD *)this + 9) = 0;
  re::DynamicString::DynamicString((re::ExistingAssetInformation *)((char *)this + 96), "(unset)", a2);
  v5 = re::ExistingAssetInformation::CachedLogName::CachedLogName((re::ExistingAssetInformation *)((char *)this + 128), a2);
  *((_DWORD *)this + 22) = 0;
  re::AssetPath::invalidAssetPath(v5, (uint64_t)&v8);
  *(_DWORD *)this = v8;
  re::DynamicString::operator=(v4, (re::DynamicString *)&v9);
  re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 40), (re::DynamicString *)&v11);
  v6 = v11;
  *((_QWORD *)this + 9) = v13;
  if (v6)
  {
    if ((BYTE8(v11) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, v12);
    v11 = 0u;
    v12 = 0u;
  }
  if (v9 && (v10 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v9 + 40))();
  *((_QWORD *)this + 10) = -1;
  return this;
}

re::DynamicString *re::ExistingAssetInformation::setupFromPath(re::ExistingAssetInformation *this, const re::AssetPath *a2)
{
  uint64_t v4;
  const char *v5;
  size_t v6;
  re::DynamicString *result;
  const char *v8;
  size_t v9;
  uint64_t v10;
  size_t v11;
  const char *v12;
  uint64_t v13;
  _QWORD v14[2];

  *(_DWORD *)this = *(_DWORD *)a2;
  re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 8), (const re::AssetPath *)((char *)a2 + 8));
  re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 40), (const re::AssetPath *)((char *)a2 + 40));
  *((_QWORD *)this + 9) = *((_QWORD *)a2 + 9);
  *((_DWORD *)this + 22) = *(_DWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  v12 = 0;
  v13 = 0;
  v10 = v4;
  v11 = 0;
  re::DynamicString::setCapacity(&v10, 0);
  re::AssetPath::fullAssetPath(a2, (re::DynamicString *)&v10);
  re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 96), (re::DynamicString *)&v10);
  if (v10 && (v11 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v10 + 40))();
  if (re::AssetPath::getAssetId(a2, (unint64_t *)this + 10))
  {
    re::DynamicString::format((re::DynamicString *)"#%llu", (re::DynamicString *)&v10, *((_QWORD *)this + 10));
    if ((v11 & 1) != 0)
      v5 = v12;
    else
      v5 = (char *)&v11 + 1;
    v6 = strlen(v5);
    v14[0] = v5;
    v14[1] = v6;
    re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 160), (uint64_t)v14);
    re::ExistingAssetInformation::CachedLogName::updateLogName((re::ExistingAssetInformation *)((char *)this + 128));
    result = (re::DynamicString *)v10;
    if (v10)
    {
      if ((v11 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v10 + 40))();
    }
  }
  else
  {
    *((_QWORD *)this + 10) = 0;
    if ((*((_BYTE *)this + 104) & 1) != 0)
      v8 = (const char *)*((_QWORD *)this + 14);
    else
      v8 = (char *)this + 105;
    v9 = strlen(v8);
    v10 = (uint64_t)v8;
    v11 = v9;
    re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 160), (uint64_t)&v10);
    return re::ExistingAssetInformation::CachedLogName::updateLogName((re::ExistingAssetInformation *)((char *)this + 128));
  }
  return result;
}

re::DynamicString *re::ExistingAssetInformation::CachedLogName::setDescription(re::ExistingAssetInformation::CachedLogName *this, const char *__s)
{
  re::DynamicString *v3;
  _QWORD v5[2];

  v3 = (re::ExistingAssetInformation::CachedLogName *)((char *)this + 32);
  v5[0] = __s;
  v5[1] = strlen(__s);
  re::DynamicString::operator=(v3, (uint64_t)v5);
  return re::ExistingAssetInformation::CachedLogName::updateLogName(this);
}

re::ExistingAssetInformation::CachedLogName *re::ExistingAssetInformation::CachedLogName::CachedLogName(re::ExistingAssetInformation::CachedLogName *this, re::Allocator *a2)
{
  re::DynamicString *v4;

  v4 = re::DynamicString::DynamicString(this, "(unset)", a2);
  re::DynamicString::DynamicString((re::DynamicString *)((char *)v4 + 32), (const char *)&str_2_26, a2);
  re::DynamicString::DynamicString((re::ExistingAssetInformation::CachedLogName *)((char *)this + 64), (const char *)&str_2_26, a2);
  return this;
}

re::DynamicString *re::ExistingAssetInformation::CachedLogName::updateLogName(re::ExistingAssetInformation::CachedLogName *this)
{
  unint64_t v2;
  unint64_t v3;
  char *v4;
  re::DynamicString *result;
  char *v6;
  uint64_t v7;
  char v8;

  v2 = *((_QWORD *)this + 9);
  v3 = v2 >> 1;
  if ((v2 & 1) == 0)
    v3 = v2 >> 1;
  if (!v3)
    return re::DynamicString::operator=(this, (re::ExistingAssetInformation::CachedLogName *)((char *)this + 32));
  if ((v2 & 1) != 0)
    v4 = (char *)*((_QWORD *)this + 10);
  else
    v4 = (char *)this + 73;
  if ((*((_BYTE *)this + 40) & 1) != 0)
    v6 = (char *)*((_QWORD *)this + 6);
  else
    v6 = (char *)this + 41;
  re::DynamicString::format((re::DynamicString *)"%s (%s)", (re::DynamicString *)&v7, v4, v6);
  re::DynamicString::operator=(this, (re::DynamicString *)&v7);
  result = (re::DynamicString *)v7;
  if (v7)
  {
    if ((v8 & 1) != 0)
      return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v7 + 40))();
  }
  return result;
}

re::DynamicString *re::ExistingAssetInformation::CachedLogName::setDebugMetadata(re::ExistingAssetInformation::CachedLogName *this, const char *__s)
{
  re::DynamicString *v3;
  _QWORD v5[2];

  v3 = (re::ExistingAssetInformation::CachedLogName *)((char *)this + 64);
  v5[0] = __s;
  v5[1] = strlen(__s);
  re::DynamicString::operator=(v3, (uint64_t)v5);
  return re::ExistingAssetInformation::CachedLogName::updateLogName(this);
}

uint64_t *allocInfo_TubeDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&_MergedGlobals_57);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_57))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FCBA8, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FCBB8 = 0;
    qword_2540FCBC8 = 0;
    qword_2540FCBD0 = 0xFFFFFFFFLL;
    qword_2540FCBA8 = (uint64_t)&off_24ED7DAA8;
    qword_2540FCBD8 = (uint64_t)"TubeDescriptorParameters";
    dword_2540FCBE0 = 0;
    xmmword_2540FCBE8 = 0u;
    unk_2540FCBF8 = 0u;
    xmmword_2540FCC08 = 0u;
    qword_2540FCC18 = 0;
    __cxa_guard_release(&_MergedGlobals_57);
  }
  return &qword_2540FCBA8;
}

void initInfo_TubeDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0x87CFA6BB47133EFALL;
  v17[1] = "TubeDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC8F0);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC8F0);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildTubeOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCAA0 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x1400000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCAA8 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x1500000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCAB0 = v15;
      __cxa_guard_release(&qword_2540FC8F0);
    }
  }
  *((_QWORD *)a1 + 2) = 0x1800000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCAA0;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<TubeDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<TubeDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<TubeDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<TubeDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

double re::internal::defaultConstruct<TubeDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_DWORD *)a3 = 65544;
  result = 0.00000190734908;
  *(_QWORD *)(a3 + 4) = 0x3EC000003F800000;
  *(_DWORD *)(a3 + 12) = 1056964608;
  *(_WORD *)(a3 + 16) = 257;
  *(_BYTE *)(a3 + 18) = 0;
  return result;
}

double re::internal::defaultConstructV2<TubeDescriptorParameters>(uint64_t a1)
{
  double result;

  *(_DWORD *)a1 = 65544;
  result = 0.00000190734908;
  *(_QWORD *)(a1 + 4) = 0x3EC000003F800000;
  *(_DWORD *)(a1 + 12) = 1056964608;
  *(_WORD *)(a1 + 16) = 257;
  *(_BYTE *)(a1 + 18) = 0;
  return result;
}

uint64_t *allocInfo_PlaneDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FC900);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC900))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FCC20, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FCC30 = 0;
    qword_2540FCC40 = 0;
    qword_2540FCC48 = 0xFFFFFFFFLL;
    qword_2540FCC20 = (uint64_t)&off_24ED7DAA8;
    qword_2540FCC50 = (uint64_t)"PlaneDescriptorParameters";
    dword_2540FCC58 = 0;
    xmmword_2540FCC60 = 0u;
    unk_2540FCC70 = 0u;
    xmmword_2540FCC80 = 0u;
    qword_2540FCC90 = 0;
    __cxa_guard_release(&qword_2540FC900);
  }
  return &qword_2540FCC20;
}

void initInfo_PlaneDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0xB6ACCE2E2A57B62ALL;
  v17[1] = "PlaneDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC908);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC908);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildPlaneOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCAB8 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x1C00000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCAC0 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x1D00000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCAC8 = v15;
      __cxa_guard_release(&qword_2540FC908);
    }
  }
  *((_QWORD *)a1 + 2) = 0x2000000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCAB8;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<PlaneDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<PlaneDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<PlaneDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<PlaneDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

double re::internal::defaultConstruct<PlaneDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_DWORD *)a3 = 65537;
  *(_WORD *)(a3 + 4) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(a3 + 8) = result;
  *(_DWORD *)(a3 + 16) = 0;
  *(_WORD *)(a3 + 20) = 257;
  *(_DWORD *)(a3 + 24) = 2;
  return result;
}

double re::internal::defaultConstructV2<PlaneDescriptorParameters>(uint64_t a1)
{
  double result;

  *(_DWORD *)a1 = 65537;
  *(_WORD *)(a1 + 4) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(a1 + 8) = result;
  *(_DWORD *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 20) = 257;
  *(_DWORD *)(a1 + 24) = 2;
  return result;
}

uint64_t *allocInfo_CylinderDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FC918);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC918))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FCC98, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FCCA8 = 0;
    qword_2540FCCB8 = 0;
    qword_2540FCCC0 = 0xFFFFFFFFLL;
    qword_2540FCC98 = (uint64_t)&off_24ED7DAA8;
    qword_2540FCCC8 = (uint64_t)"CylinderDescriptorParameters";
    dword_2540FCCD0 = 0;
    xmmword_2540FCCD8 = 0u;
    unk_2540FCCE8 = 0u;
    xmmword_2540FCCF8 = 0u;
    qword_2540FCD08 = 0;
    __cxa_guard_release(&qword_2540FC918);
  }
  return &qword_2540FCC98;
}

void initInfo_CylinderDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0x9C4984D14682379ELL;
  v17[1] = "CylinderDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC920);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC920);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildCylinderOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCAD0 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x1800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCAD8 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x1900000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCAE0 = v15;
      __cxa_guard_release(&qword_2540FC920);
    }
  }
  *((_QWORD *)a1 + 2) = 0x1C00000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCAD0;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<CylinderDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<CylinderDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<CylinderDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<CylinderDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

double re::internal::defaultConstruct<CylinderDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_DWORD *)a3 = 65544;
  result = 0.0000305175853;
  *(_QWORD *)(a3 + 4) = 0x3F0000003F800000;
  *(_QWORD *)(a3 + 12) = 0x10101013F000000;
  *(_BYTE *)(a3 + 20) = 0;
  return result;
}

double re::internal::defaultConstructV2<CylinderDescriptorParameters>(uint64_t a1)
{
  double result;

  *(_DWORD *)a1 = 65544;
  result = 0.0000305175853;
  *(_QWORD *)(a1 + 4) = 0x3F0000003F800000;
  *(_QWORD *)(a1 + 12) = 0x10101013F000000;
  *(_BYTE *)(a1 + 20) = 0;
  return result;
}

uint64_t *allocInfo_TetrahedronDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FC930);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC930))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FCD10, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FCD20 = 0;
    qword_2540FCD30 = 0;
    qword_2540FCD38 = 0xFFFFFFFFLL;
    qword_2540FCD10 = (uint64_t)&off_24ED7DAA8;
    qword_2540FCD40 = (uint64_t)"TetrahedronDescriptorParameters";
    dword_2540FCD48 = 0;
    xmmword_2540FCD50 = 0u;
    xmmword_2540FCD60 = 0u;
    xmmword_2540FCD70 = 0u;
    qword_2540FCD80 = 0;
    __cxa_guard_release(&qword_2540FC930);
  }
  return &qword_2540FCD10;
}

void initInfo_TetrahedronDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0xC1D636A90025346ALL;
  v17[1] = "TetrahedronDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC938);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC938);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildTetrahedronOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCAE8 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0xC00000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCAF0 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0xD00000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCAF8 = v15;
      __cxa_guard_release(&qword_2540FC938);
    }
  }
  *((_QWORD *)a1 + 2) = 0x1000000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCAE8;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<TetrahedronDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<TetrahedronDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<TetrahedronDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<TetrahedronDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

void re::internal::defaultConstruct<TetrahedronDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)a3 = 1;
  *(_DWORD *)(a3 + 4) = 1065353216;
  *(_WORD *)(a3 + 8) = 257;
  *(_BYTE *)(a3 + 10) = 0;
}

uint64_t re::internal::defaultConstructV2<TetrahedronDescriptorParameters>(uint64_t result)
{
  *(_WORD *)result = 1;
  *(_DWORD *)(result + 4) = 1065353216;
  *(_WORD *)(result + 8) = 257;
  *(_BYTE *)(result + 10) = 0;
  return result;
}

uint64_t *allocInfo_ConeDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FC948);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC948))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FCD88, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FCD98 = 0;
    qword_2540FCDA8 = 0;
    qword_2540FCDB0 = 0xFFFFFFFFLL;
    qword_2540FCD88 = (uint64_t)&off_24ED7DAA8;
    qword_2540FCDB8 = (uint64_t)"ConeDescriptorParameters";
    dword_2540FCDC0 = 0;
    xmmword_2540FCDC8 = 0u;
    xmmword_2540FCDD8 = 0u;
    xmmword_2540FCDE8 = 0u;
    qword_2540FCDF8 = 0;
    __cxa_guard_release(&qword_2540FC948);
  }
  return &qword_2540FCD88;
}

void initInfo_ConeDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0xA8553AB0F1149538;
  v17[1] = "ConeDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC950);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC950);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildConeOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCB00 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x1000000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCB08 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x1100000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCB10 = v15;
      __cxa_guard_release(&qword_2540FC950);
    }
  }
  *((_QWORD *)a1 + 2) = 0x1400000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCB00;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<ConeDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<ConeDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<ConeDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<ConeDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

double re::internal::defaultConstruct<ConeDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_DWORD *)a3 = 65544;
  *(_QWORD *)(a3 + 4) = 0x3F0000003F800000;
  *(_QWORD *)&result = 65793;
  *(_DWORD *)(a3 + 12) = 65793;
  return result;
}

double re::internal::defaultConstructV2<ConeDescriptorParameters>(uint64_t a1)
{
  double result;

  *(_DWORD *)a1 = 65544;
  *(_QWORD *)(a1 + 4) = 0x3F0000003F800000;
  *(_QWORD *)&result = 65793;
  *(_DWORD *)(a1 + 12) = 65793;
  return result;
}

uint64_t *allocInfo_SphereDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FC960);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC960))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FCE00, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FCE10 = 0;
    qword_2540FCE20 = 0;
    qword_2540FCE28 = 0xFFFFFFFFLL;
    qword_2540FCE00 = (uint64_t)&off_24ED7DAA8;
    qword_2540FCE30 = (uint64_t)"SphereDescriptorParameters";
    dword_2540FCE38 = 0;
    xmmword_2540FCE40 = 0u;
    xmmword_2540FCE50 = 0u;
    xmmword_2540FCE60 = 0u;
    qword_2540FCE70 = 0;
    __cxa_guard_release(&qword_2540FC960);
  }
  return &qword_2540FCE00;
}

void initInfo_SphereDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0x62D795AD0F05048CLL;
  v17[1] = "SphereDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC968);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC968);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildSphereOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCB18 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0xC00000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCB20 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0xD00000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCB28 = v15;
      __cxa_guard_release(&qword_2540FC968);
    }
  }
  *((_QWORD *)a1 + 2) = 0x1000000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCB18;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<SphereDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<SphereDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<SphereDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<SphereDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

void re::internal::defaultConstruct<SphereDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)a3 = 8;
  *(_DWORD *)(a3 + 4) = 1056964608;
  *(_WORD *)(a3 + 8) = 257;
  *(_BYTE *)(a3 + 10) = 0;
}

uint64_t re::internal::defaultConstructV2<SphereDescriptorParameters>(uint64_t result)
{
  *(_WORD *)result = 8;
  *(_DWORD *)(result + 4) = 1056964608;
  *(_WORD *)(result + 8) = 257;
  *(_BYTE *)(result + 10) = 0;
  return result;
}

uint64_t *allocInfo_CapsuleDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FC978);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC978))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FCE78, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FCE88 = 0;
    qword_2540FCE98 = 0;
    qword_2540FCEA0 = 0xFFFFFFFFLL;
    qword_2540FCE78 = (uint64_t)&off_24ED7DAA8;
    qword_2540FCEA8 = (uint64_t)"CapsuleDescriptorParameters";
    dword_2540FCEB0 = 0;
    xmmword_2540FCEB8 = 0u;
    xmmword_2540FCEC8 = 0u;
    xmmword_2540FCED8 = 0u;
    qword_2540FCEE8 = 0;
    __cxa_guard_release(&qword_2540FC978);
  }
  return &qword_2540FCE78;
}

void initInfo_CapsuleDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0x6E24928FE34990CCLL;
  v17[1] = "CapsuleDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC980);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC980);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildCapsuleOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCB30 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x1400000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCB38 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x1500000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCB40 = v15;
      __cxa_guard_release(&qword_2540FC980);
    }
  }
  *((_QWORD *)a1 + 2) = 0x1800000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCB30;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<CapsuleDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<CapsuleDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<CapsuleDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<CapsuleDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

double re::internal::defaultConstruct<CapsuleDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_DWORD *)a3 = 65544;
  *(_WORD *)(a3 + 4) = 4;
  result = 2.00000047;
  *(_QWORD *)(a3 + 8) = 0x400000003F000000;
  *(_WORD *)(a3 + 16) = 257;
  *(_BYTE *)(a3 + 18) = 0;
  return result;
}

double re::internal::defaultConstructV2<CapsuleDescriptorParameters>(uint64_t a1)
{
  double result;

  *(_DWORD *)a1 = 65544;
  *(_WORD *)(a1 + 4) = 4;
  result = 2.00000047;
  *(_QWORD *)(a1 + 8) = 0x400000003F000000;
  *(_WORD *)(a1 + 16) = 257;
  *(_BYTE *)(a1 + 18) = 0;
  return result;
}

uint64_t *allocInfo_PyramidDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FC990);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC990))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FCEF0, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FCF00 = 0;
    qword_2540FCF10 = 0;
    qword_2540FCF18 = 0xFFFFFFFFLL;
    qword_2540FCEF0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FCF20 = (uint64_t)"PyramidDescriptorParameters";
    dword_2540FCF28 = 0;
    xmmword_2540FCF30 = 0u;
    xmmword_2540FCF40 = 0u;
    xmmword_2540FCF50 = 0u;
    qword_2540FCF60 = 0;
    __cxa_guard_release(&qword_2540FC990);
  }
  return &qword_2540FCEF0;
}

void initInfo_PyramidDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0xCF698AC4CB601812;
  v17[1] = "PyramidDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC998);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC998);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildPyramidOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCB48 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x1400000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCB50 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x1500000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCB58 = v15;
      __cxa_guard_release(&qword_2540FC998);
    }
  }
  *((_QWORD *)a1 + 2) = 0x1800000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCB48;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<PyramidDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<PyramidDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<PyramidDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<PyramidDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

double re::internal::defaultConstruct<PyramidDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_WORD *)a3 = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(a3 + 4) = result;
  *(_DWORD *)(a3 + 12) = 1065353216;
  *(_WORD *)(a3 + 16) = 257;
  *(_BYTE *)(a3 + 18) = 0;
  return result;
}

double re::internal::defaultConstructV2<PyramidDescriptorParameters>(uint64_t a1)
{
  double result;

  *(_WORD *)a1 = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(a1 + 4) = result;
  *(_DWORD *)(a1 + 12) = 1065353216;
  *(_WORD *)(a1 + 16) = 257;
  *(_BYTE *)(a1 + 18) = 0;
  return result;
}

uint64_t *allocInfo_BoxDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FC9A8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC9A8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FCF68, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FCF78 = 0;
    qword_2540FCF88 = 0;
    qword_2540FCF90 = 0xFFFFFFFFLL;
    qword_2540FCF68 = (uint64_t)&off_24ED7DAA8;
    qword_2540FCF98 = (uint64_t)"BoxDescriptorParameters";
    dword_2540FCFA0 = 0;
    xmmword_2540FCFA8 = 0u;
    xmmword_2540FCFB8 = 0u;
    xmmword_2540FCFC8 = 0u;
    qword_2540FCFD8 = 0;
    __cxa_guard_release(&qword_2540FC9A8);
  }
  return &qword_2540FCF68;
}

void initInfo_BoxDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0x6F2DEA5BDE93D208;
  v17[1] = "BoxDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC9B0);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC9B0);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildBoxOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCB60 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x1C00000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCB68 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x1D00000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCB70 = v15;
      __cxa_guard_release(&qword_2540FC9B0);
    }
  }
  *((_QWORD *)a1 + 2) = 0x2000000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCB60;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<BoxDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<BoxDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<BoxDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<BoxDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

double re::internal::defaultConstruct<BoxDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0x1000100010001;
  result = 0.0078125;
  *(_OWORD *)(a3 + 8) = xmmword_2260F8390;
  *(_WORD *)(a3 + 24) = 257;
  *(_BYTE *)(a3 + 26) = 0;
  return result;
}

double re::internal::defaultConstructV2<BoxDescriptorParameters>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0x1000100010001;
  result = 0.0078125;
  *(_OWORD *)(a1 + 8) = xmmword_2260F8390;
  *(_WORD *)(a1 + 24) = 257;
  *(_BYTE *)(a1 + 26) = 0;
  return result;
}

uint64_t *allocInfo_BoxWithRoundedCornersDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FC9C0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC9C0))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FCFE0, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FCFF0 = 0;
    qword_2540FD000 = 0;
    qword_2540FD008 = 0xFFFFFFFFLL;
    qword_2540FCFE0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FD010 = (uint64_t)"BoxWithRoundedCornersDescriptorParameters";
    dword_2540FD018 = 0;
    xmmword_2540FD020 = 0u;
    xmmword_2540FD030 = 0u;
    xmmword_2540FD040 = 0u;
    qword_2540FD050 = 0;
    __cxa_guard_release(&qword_2540FC9C0);
  }
  return &qword_2540FCFE0;
}

void initInfo_BoxWithRoundedCornersDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0x67982B14680DB536;
  v17[1] = "BoxWithRoundedCornersDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC9C8);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC9C8);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildBoxWithRoundedCornersOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCB78 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x2800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCB80 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x2900000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCB88 = v15;
      __cxa_guard_release(&qword_2540FC9C8);
    }
  }
  *((_QWORD *)a1 + 2) = 0x2C00000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCB78;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<BoxWithRoundedCornersDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<BoxWithRoundedCornersDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<BoxWithRoundedCornersDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<BoxWithRoundedCornersDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

double re::internal::defaultConstruct<BoxWithRoundedCornersDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0x3000100010001;
  *(_WORD *)(a3 + 8) = 4;
  *(_OWORD *)(a3 + 12) = xmmword_2260F83A0;
  *(_DWORD *)(a3 + 28) = 1065353216;
  *(_QWORD *)&result = 16777473;
  *(_DWORD *)(a3 + 32) = 16777473;
  *(_WORD *)(a3 + 36) = 1;
  *(_BYTE *)(a3 + 38) = 0;
  return result;
}

double re::internal::defaultConstructV2<BoxWithRoundedCornersDescriptorParameters>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0x3000100010001;
  *(_WORD *)(a1 + 8) = 4;
  *(_OWORD *)(a1 + 12) = xmmword_2260F83A0;
  *(_DWORD *)(a1 + 28) = 1065353216;
  *(_QWORD *)&result = 16777473;
  *(_DWORD *)(a1 + 32) = 16777473;
  *(_WORD *)(a1 + 36) = 1;
  *(_BYTE *)(a1 + 38) = 0;
  return result;
}

uint64_t *allocInfo_ExtrudedTextDescriptorParameters(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FC9D8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC9D8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FD058, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_2540FD068 = 0;
    qword_2540FD078 = 0;
    qword_2540FD080 = 0xFFFFFFFFLL;
    qword_2540FD058 = (uint64_t)&off_24ED7DAA8;
    qword_2540FD088 = (uint64_t)"ExtrudedTextDescriptorParameters";
    dword_2540FD090 = 0;
    xmmword_2540FD098 = 0u;
    xmmword_2540FD0A8 = 0u;
    xmmword_2540FD0B8 = 0u;
    qword_2540FD0C8 = 0;
    __cxa_guard_release(&qword_2540FC9D8);
  }
  return &qword_2540FD058;
}

void initInfo_ExtrudedTextDescriptorParameters(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  const re::IntrospectionBase *v9;
  void *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0x9AF53A68A747B84ALL;
  v17[1] = "ExtrudedTextDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)a1 + 2) = v18;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC9E0);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2540FC9E0);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v6 = re::introspect_GeomBuildExtrudedTextOptions((re::IntrospectionBase **)1);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "options";
      *(_QWORD *)(v7 + 16) = v6;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_2540FCB90 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v10 = re::introspect_BOOL((re *)1, v9);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "splitMeshes";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x6800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FCB98 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_BOOL((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "decimate";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x6900000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FCBA0 = v15;
      __cxa_guard_release(&qword_2540FC9E0);
    }
  }
  *((_QWORD *)a1 + 2) = 0x7000000008;
  *((_DWORD *)a1 + 6) = 8;
  *((_WORD *)a1 + 14) = 0;
  *((_DWORD *)a1 + 14) = 3;
  *((_QWORD *)a1 + 8) = &qword_2540FCB90;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<ExtrudedTextDescriptorParameters>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<ExtrudedTextDescriptorParameters>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<ExtrudedTextDescriptorParameters>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<ExtrudedTextDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  v16 = v18;
}

double re::internal::defaultConstruct<ExtrudedTextDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, _OWORD *a3)
{
  _OWORD *v3;
  _anonymous_namespace_ *v4;
  double result;

  v3 = a3;
  *a3 = 0u;
  a3[1] = 0u;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v3, 0);
  v3[2] = 0u;
  v3[3] = 0u;
  v3 += 2;
  re::DynamicString::setCapacity(v3, 0);
  __asm { FMOV            V0.2S, #1.0 }
  *((double *)v3 + 4) = result;
  *((_BYTE *)v3 + 40) = 5;
  *((_QWORD *)v3 + 6) = 0;
  *((_QWORD *)v3 + 7) = 0;
  *((_BYTE *)v3 + 64) = 0;
  *(_WORD *)((char *)v3 + 65) = 4;
  *(_DWORD *)((char *)v3 + 67) = 16843009;
  *((_BYTE *)v3 + 71) = 0;
  return result;
}

double re::internal::defaultDestruct<ExtrudedTextDescriptorParameters>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  _OWORD *v5;
  double result;

  v5 = a3 + 4;
  v4 = a3[4];
  if (v4)
  {
    if ((a3[5] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, a3[6]);
    result = 0.0;
    *v5 = 0u;
    v5[1] = 0u;
  }
  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

double re::internal::defaultConstructV2<ExtrudedTextDescriptorParameters>(_anonymous_namespace_ *a1)
{
  _anonymous_namespace_ *v1;
  _anonymous_namespace_ *v2;
  double result;

  v1 = a1;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v1, 0);
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  v1 = (_anonymous_namespace_ *)((char *)v1 + 32);
  re::DynamicString::setCapacity(v1, 0);
  __asm { FMOV            V0.2S, #1.0 }
  *((double *)v1 + 4) = result;
  *((_BYTE *)v1 + 40) = 5;
  *((_QWORD *)v1 + 6) = 0;
  *((_QWORD *)v1 + 7) = 0;
  *((_BYTE *)v1 + 64) = 0;
  *(_WORD *)((char *)v1 + 65) = 4;
  *(_DWORD *)((char *)v1 + 67) = 16843009;
  *((_BYTE *)v1 + 71) = 0;
  return result;
}

double re::internal::defaultDestructV2<ExtrudedTextDescriptorParameters>(_QWORD *a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;

  v3 = a1 + 4;
  v2 = a1[4];
  if (v2)
  {
    if ((a1[5] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, a1[6]);
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  if (*a1)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

uint64_t re::MeshPrimitiveProvider::makeAsset(re::MeshPrimitiveProvider *this, const re::GeomBuildExtrudedTextOptions *a2, char a3)
{
  _BYTE *v4;
  __int128 v5;
  uint64_t *v6;
  unint64_t v7;
  __n128 v8;
  re::GeomAttribute *v9;
  uint64_t v10;
  _DWORD *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  re::GeomAttribute *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  re *v21;
  uint64_t *v22;
  uint64_t v23;
  double v24;
  double v25;
  re::GeomAttribute *v26;
  re::GeomBuildExtrudedTextSupport *v28;
  re::GeomAttribute *v29;
  __n128 v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  re::GeomAttribute *v39;
  int v40;
  char v41;
  int v42;
  char v43;
  char v44;
  int v45;
  int v46;
  char v47;
  _OWORD v48[2];
  __int128 v49;
  _QWORD v50[3];
  int v51;
  _OWORD v52[2];
  int v53;
  _BYTE v54[32];
  int v55;
  __int128 v56;
  __int128 v57;
  int v58;
  uint64_t v59;
  uint64_t v60[4];
  int v61;
  uint64_t v62;
  uint64_t v63;
  __int128 v64;
  int v65;
  __int128 v66;
  __int128 v67;
  int v68;
  __int128 v69;
  __int128 v70;
  int v71;
  _BYTE v72[44];
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  int v78;
  uint64_t v79[5];
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  re::GeomAttribute *v98;
  char v99;
  uint64_t v100;
  _BYTE v101[40];
  uint64_t v102;
  _BYTE v103[528];
  _QWORD v104[2];
  int32x4_t v105;
  __int128 v106;
  uint64_t *v107;
  CFTypeRef cf;
  uint64_t v109;
  __int16 v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  _BYTE v114[12];
  __int16 v115;
  int v116;
  __int16 v117;
  uint64_t v118;
  __int16 v119;
  uint64_t v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  int v125;
  _QWORD v126[4];
  __int128 v127;
  __int128 v128;
  _BYTE v129[24];
  __int128 v130;
  re::GeomAttribute *v131;
  __int128 v132;
  _BYTE v133[28];
  uint64_t v134;
  uint64_t v135;
  _QWORD v136[8];

  v136[5] = *MEMORY[0x24BDAC8D0];
  v4 = v114;
  v63 = 0;
  v64 = 0uLL;
  v65 = 0;
  v66 = 0u;
  v67 = 0u;
  v69 = 0u;
  v70 = 0u;
  v68 = 0;
  v71 = 0;
  memset(v72, 0, sizeof(v72));
  v73 = 0x7FFFFFFFLL;
  v61 = 0;
  memset(v60, 0, sizeof(v60));
  v62 = 0x7FFFFFFFLL;
  *(_QWORD *)&v5 = 0x7F0000007FLL;
  *((_QWORD *)&v5 + 1) = 0x7F0000007FLL;
  v105 = vdupq_n_s32(0x7F800000u);
  v106 = v5;
  v104[0] = &off_24ED2EBD8;
  v107 = v60;
  v109 = 0;
  cf = 0;
  v110 = 0;
  v113 = 0;
  v111 = 0;
  v112 = 0;
  memset(v50, 0, sizeof(v50));
  v51 = 0;
  v59 = 0;
  memset(v52, 0, sizeof(v52));
  memset(v54, 0, sizeof(v54));
  v53 = 0;
  v55 = 0;
  v56 = 0u;
  v57 = 0u;
  v58 = 0;
  v40 = 16842752;
  v41 = 1;
  v42 = 0;
  v43 = 0;
  v46 = 16843008;
  v47 = 0;
  v49 = 0u;
  memset(v48, 0, sizeof(v48));
  DWORD1(v49) = 0x7FFFFFFF;
  v44 = a3;
  v45 = 1065353216;
  if (*((_BYTE *)this + 103))
  {
    v79[0] = 0;
    v77 = 0;
    v75 = 0;
    v76 = 0;
    v78 = 0;
    *(_QWORD *)&v123 = 0;
    *(_QWORD *)&v122 = 0;
    v121 = 0uLL;
    DWORD2(v122) = 0;
    re::buildExtrudedText((uint64_t)&v75, (uint64_t)&v121, (uint64_t)this, (uint64_t)v104);
    re::DynamicArray<re::GeomModelWithLods>::setCapacity(&v63, v77);
    re::DynamicArray<re::RigSplineIKJoint>::setCapacity((_QWORD *)&v66 + 1, v122);
    if (v77)
    {
      v6 = (uint64_t *)v79[0];
      v4 = v103;
      v7 = 736 * v77;
      while (1)
      {
        re::GeomModel::GeomModel((re::GeomModel *)&v90);
        re::DynamicArray<re::GeomMesh>::resize((uint64_t)&v92, 1uLL);
        LODWORD(v126[0]) = 0;
        re::DynamicArray<unsigned int>::resize((_QWORD *)&v94 + 1, 1uLL, v126);
        if (!(_QWORD)v93)
          break;
        re::GeomMesh::operator=((uint64_t *)v94, v6);
        re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)v126);
        re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)&v127, (uint64_t)&v90);
        v8.n128_f64[0] = re::DynamicArray<re::GeomModelWithLods>::add((_anonymous_namespace_ *)&v63, (uint64_t)v126);
        if ((_QWORD)v132)
        {
          if (*(_QWORD *)&v133[16])
            (*(void (**)(double))(*(_QWORD *)v132 + 40))(v8.n128_f64[0]);
          *(_QWORD *)&v133[16] = 0;
          *(_QWORD *)v133 = 0;
          v132 = 0uLL;
          ++*(_DWORD *)&v133[8];
        }
        if (*(_QWORD *)&v129[8])
        {
          if (v131)
            (*(void (**)(__n128))(**(_QWORD **)&v129[8] + 40))(v8);
          v131 = 0;
          *(_QWORD *)&v129[16] = 0;
          *(_QWORD *)&v130 = 0;
          *(_QWORD *)&v129[8] = 0;
          ++DWORD2(v130);
        }
        re::DynamicArray<re::GeomModel>::deinit((uint64_t)&v127);
        if (v126[0] && (v126[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v126[0] + 40))();
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v103);
        if (v101[32])
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v102);
        if (v99)
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v100);
        if (*((_QWORD *)&v94 + 1))
        {
          v9 = v98;
          if (v98)
            (*(void (**)(void))(**((_QWORD **)&v94 + 1) + 40))();
          v98 = 0;
          v95 = 0;
          v96 = 0;
          *((_QWORD *)&v94 + 1) = 0;
          ++v97;
        }
        re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v92, v9);
        if ((_QWORD)v90 && (BYTE8(v90) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v90 + 40))();
        v6 += 92;
        v7 -= 736;
        if (!v7)
          goto LABEL_28;
      }
      v74 = 0;
      v128 = 0u;
      *(_OWORD *)v129 = 0u;
      v127 = 0u;
      memset(v126, 0, sizeof(v126));
      v18 = MEMORY[0x24BDACB70];
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v114 = 136315906;
      *(_QWORD *)&v114[4] = "operator[]";
      v115 = 1024;
      v116 = 789;
      v117 = 2048;
      v118 = 0;
      v119 = 2048;
      v120 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_99:
      *(_QWORD *)v114 = 0;
      v93 = 0u;
      v94 = 0u;
      v91 = 0u;
      v92 = 0u;
      v90 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(v121) = 136315906;
      *(_QWORD *)(v4 + 52) = "operator[]";
      WORD6(v121) = 1024;
      *(_DWORD *)(v4 + 62) = 789;
      WORD1(v122) = 2048;
      *(_QWORD *)(v4 + 68) = v18;
      WORD6(v122) = 2048;
      *(_QWORD *)(v4 + 78) = v18;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_100:
      re::internal::assertLog((re::internal *)4, v31, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      _os_crash();
      __break(1u);
LABEL_101:
      re::internal::assertLog((re::internal *)4, v31, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      _os_crash();
      __break(1u);
      goto LABEL_102;
    }
LABEL_28:
    if ((_QWORD)v122)
    {
      v10 = 80 * v122;
      v11 = (_DWORD *)(v123 + 64);
      do
      {
        LODWORD(v94) = *v11;
        v12 = *((_OWORD *)v11 - 4);
        v13 = *((_OWORD *)v11 - 3);
        v14 = *((_OWORD *)v11 - 1);
        v92 = *((_OWORD *)v11 - 2);
        v93 = v14;
        v90 = v12;
        v91 = v13;
        re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)((char *)&v66 + 8), (uint64_t)&v90);
        v11 += 20;
        v10 -= 80;
      }
      while (v10);
    }
    re::makeMeshAssetDataFromGeomScene((unint64_t)&v63, (uint64_t)&v40, (uint64_t)&v90);
    if ((_BYTE)v90)
    {
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v50, (uint64_t)&v90 + 8);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v52 + 8, (uint64_t)&v93);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v54[8], (uint64_t)&v96);
      re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)&v56 + 8, (uint64_t)v101);
    }
    re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v90);
    if ((_QWORD)v121)
    {
      v15 = (re::GeomAttribute *)v123;
      if ((_QWORD)v123)
        (*(void (**)(void))(*(_QWORD *)v121 + 40))();
    }
    v16 = &v75;
LABEL_48:
    v21 = (re *)re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v16, v15);
    goto LABEL_49;
  }
  if ((_DWORD)a2)
  {
    *(_QWORD *)&v127 = 0;
    memset(v126, 0, 28);
    v79[0] = 0;
    v77 = 0;
    v75 = 0;
    v76 = 0;
    v78 = 0;
    re::buildExtrudedText((_anonymous_namespace_ *)v126, (uint64_t)this, (uint64_t)v104);
    v17 = LODWORD(v126[2]);
    re::DynamicArray<float>::resize((uint64_t)&v75, LODWORD(v126[2]));
    v18 = v77;
    if (v17)
    {
      v19 = 0;
      v20 = v79[0];
      while (v18 != v19)
      {
        *(_DWORD *)(v20 + 4 * v19) = v19;
        if (v17 == ++v19)
          goto LABEL_42;
      }
      goto LABEL_99;
    }
LABEL_42:
    re::makeMeshAssetDataWithGeomMeshArray((re::GeomMesh *)v127, v126[2], v79[0], v18, 0, &v40, (uint64_t)&v90);
    if ((_BYTE)v90)
    {
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v50, (uint64_t)&v90 + 8);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v52 + 8, (uint64_t)&v93);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v54[8], (uint64_t)&v96);
      re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)&v56 + 8, (uint64_t)v101);
    }
    re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v90);
    if (v75)
    {
      v15 = (re::GeomAttribute *)v79[0];
      if (v79[0])
        (*(void (**)(void))(*(_QWORD *)v75 + 40))();
    }
    v16 = v126;
    goto LABEL_48;
  }
  re::GeomMesh::GeomMesh((re::GeomMesh *)&v90, 0);
  re::buildExtrudedText((re *)&v90, this, (const re::GeomBuildExtrudedTextOptions *)v104, v28);
  re::GeomModel::GeomModel((re::GeomModel *)v126);
  re::DynamicArray<re::GeomMesh>::add((uint64_t)&v127, (uint64_t)&v90);
  LODWORD(v75) = 0;
  re::DynamicArray<unsigned int>::resize(&v129[8], 1uLL, &v75);
  re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)&v75);
  re::DynamicString::operator=((re::DynamicString *)&v75, (re::DynamicString *)v126);
  re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)v79, (uint64_t)v126);
  re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v136);
  if (BYTE4(v134))
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v135);
  if ((_BYTE)v132)
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v132 + 8);
  if (*(_QWORD *)&v129[8])
  {
    v29 = v131;
    if (v131)
      (*(void (**)(void))(**(_QWORD **)&v129[8] + 40))();
    v131 = 0;
    *(_QWORD *)&v129[16] = 0;
    *(_QWORD *)&v130 = 0;
    *(_QWORD *)&v129[8] = 0;
    ++DWORD2(v130);
  }
  re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v127, v29);
  if (v126[0] && (v126[1] & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v126[0] + 40))();
  memset(v126, 0, 28);
  v127 = 0u;
  v128 = 0u;
  *(_DWORD *)v129 = 0;
  *(_OWORD *)&v129[8] = 0u;
  v130 = 0u;
  LODWORD(v131) = 0;
  v132 = 0u;
  memset(v133, 0, sizeof(v133));
  v134 = 0x7FFFFFFFLL;
  re::DynamicArray<re::GeomModelWithLods>::add((_anonymous_namespace_ *)v126, (uint64_t)&v75);
  v121 = xmmword_2260E5F10;
  v122 = xmmword_2260E5F20;
  v123 = xmmword_2260E5F40;
  v124 = xmmword_2260E5D70;
  v125 = 0;
  v30 = re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)((char *)&v127 + 8), (uint64_t)&v121);
  if (v85)
  {
    if (v89)
      (*(void (**)(__n128))(*(_QWORD *)v85 + 40))(v30);
    v89 = 0;
    v86 = 0;
    v87 = 0;
    v85 = 0;
    ++v88;
  }
  if (v80)
  {
    if (v84)
      (*(void (**)(__n128))(*(_QWORD *)v80 + 40))(v30);
    v84 = 0;
    v81 = 0;
    v82 = 0;
    v80 = 0;
    ++v83;
  }
  re::DynamicArray<re::GeomModel>::deinit((uint64_t)v79);
  if (v75 && (v76 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v75 + 40))();
  v32 = v63;
  if (v63 && v126[0] && v63 != v126[0])
    goto LABEL_100;
  v63 = v126[0];
  v126[0] = v32;
  v33 = v66;
  *(_QWORD *)&v66 = v127;
  *(_QWORD *)&v127 = v33;
  ++LODWORD(v126[3]);
  ++v65;
  v34 = v64;
  v64 = *(_OWORD *)&v126[1];
  *(_OWORD *)&v126[1] = v34;
  if (*((_QWORD *)&v66 + 1) && *((_QWORD *)&v127 + 1) && *((_QWORD *)&v66 + 1) != *((_QWORD *)&v127 + 1))
    goto LABEL_101;
  *((_QWORD *)&v66 + 1) = *((_QWORD *)&v127 + 1);
  *((_QWORD *)&v127 + 1) = *((_QWORD *)&v33 + 1);
  v35 = v69;
  *(_QWORD *)&v69 = *(_QWORD *)&v129[8];
  *(_QWORD *)&v129[8] = v35;
  ++*(_DWORD *)v129;
  ++v68;
  v36 = v67;
  v67 = v128;
  v128 = v36;
  if (*((_QWORD *)&v69 + 1) && *(_QWORD *)&v129[16] && *((_QWORD *)&v69 + 1) != *(_QWORD *)&v129[16])
  {
LABEL_102:
    re::internal::assertLog((re::internal *)4, v31, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
    _os_crash();
    __break(1u);
  }
  *((_QWORD *)&v69 + 1) = *(_QWORD *)&v129[16];
  *(_QWORD *)&v129[16] = *((_QWORD *)&v35 + 1);
  v37 = v70;
  v70 = v130;
  v130 = v37;
  v38 = *(_QWORD *)v72;
  *(_QWORD *)v72 = v132;
  *(_QWORD *)&v132 = v38;
  LODWORD(v131) = (_DWORD)v131 + 1;
  ++v71;
  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=((uint64_t)&v72[8], (uint64_t *)&v132 + 1);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v132 + 1);
  re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v129[16]);
  if (*((_QWORD *)&v127 + 1))
  {
    if (*(_QWORD *)&v129[8])
      (*(void (**)(void))(**((_QWORD **)&v127 + 1) + 40))();
    *(_QWORD *)&v129[8] = 0;
    v128 = 0uLL;
    *((_QWORD *)&v127 + 1) = 0;
    ++*(_DWORD *)v129;
  }
  re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)v126);
  re::makeMeshAssetDataFromGeomScene((unint64_t)&v63, (uint64_t)&v40, (uint64_t)v126);
  if (LOBYTE(v126[0]))
  {
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v50, (uint64_t)&v126[1]);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v52 + 8, (uint64_t)&v128);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v54[8], (uint64_t)&v130);
    re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)&v56 + 8, (uint64_t)v133);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)v126);
  re::GeomMesh::~GeomMesh((re::GeomMesh *)&v90, v39);
LABEL_49:
  v22 = re::globalAllocators(v21);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22[2] + 32))(v22[2], 960, 8);
  re::MeshAsset::MeshAsset(v23, (uint64_t)v50);
  v25 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v48, v24);
  if (*((_QWORD *)&v56 + 1))
  {
    if (v59)
      (*(void (**)(double))(**((_QWORD **)&v56 + 1) + 40))(v25);
    v59 = 0;
    v57 = 0uLL;
    *((_QWORD *)&v56 + 1) = 0;
    ++v58;
  }
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v54[8]);
  re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)v52 + 8);
  re::DynamicArray<re::MeshAssetModel>::deinit((uint64_t)v50);
  v104[0] = &off_24ED2EBD8;
  if (cf)
    CFRelease(cf);
  re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::deinit(v60, v26);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v72[8]);
  re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v69 + 8);
  if (*((_QWORD *)&v66 + 1))
  {
    if ((_QWORD)v69)
      (*(void (**)(void))(**((_QWORD **)&v66 + 1) + 40))();
    *(_QWORD *)&v69 = 0;
    v67 = 0uLL;
    *((_QWORD *)&v66 + 1) = 0;
    ++v68;
  }
  re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)&v63);
  return v23;
}

_QWORD *re::DynamicArray<re::GeomModelWithLods>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::GeomModelWithLods>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x98uLL))
        {
          v2 = 152 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 152 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 152, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (_QWORD *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 152 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::GeomModelWithLods>(v8, v11);
          v8 += 19;
          v11 += 152;
          v10 -= 152;
        }
        while (v10);
        v8 = (_QWORD *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::DynamicArray<re::GeomMesh>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v7 = 736 * a2;
    v8 = a2;
    do
    {
      re::GeomMesh::~GeomMesh((re::GeomMesh *)(*(_QWORD *)(a1 + 32) + v7), (re::GeomAttribute *)a2);
      ++v8;
      v7 += 736;
    }
    while (v8 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::GeomMesh>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 736 * v4;
      do
      {
        re::GeomMesh::GeomMesh((re::GeomMesh *)(*(_QWORD *)(a1 + 32) + v6), 0);
        v6 += 736;
        --v5;
      }
      while (v5);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::DynamicArray<unsigned int>::resize(_QWORD *result, unint64_t a2, _DWORD *a3)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v7;
  _DWORD *v8;

  v4 = result;
  v5 = result[2];
  if (v5 >= a2)
  {
    if (v5 <= a2)
      return result;
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<int>::setCapacity(result, a2);
      v5 = v4[2];
    }
    v7 = a2 - v5;
    if (a2 > v5)
    {
      v8 = (_DWORD *)(v4[4] + 4 * v5);
      do
      {
        *v8++ = *a3;
        --v7;
      }
      while (v7);
    }
  }
  v4[2] = a2;
  ++*((_DWORD *)v4 + 6);
  return result;
}

uint64_t re::DynamicArray<re::GeomModel>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::GeomModel>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 248 * v4;
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_QWORD *)(v5 + 24) = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)v5 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  v7 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 24) = 0;
  v9 = *(_QWORD *)(v5 + 8);
  v8 = *(_QWORD *)(v5 + 16);
  *(_QWORD *)(v5 + 8) = v6;
  *(_QWORD *)(v5 + 16) = v7;
  *(_QWORD *)(a2 + 8) = v9;
  *(_QWORD *)(a2 + 16) = v8;
  *(_QWORD *)(v5 + 64) = 0;
  *(_DWORD *)(v5 + 56) = 0;
  *(_QWORD *)(v5 + 40) = 0;
  *(_QWORD *)(v5 + 48) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  v10 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(v5 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(v5 + 40) = v10;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v11 = *(_QWORD *)(v5 + 48);
  *(_QWORD *)(v5 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v11;
  v12 = *(_QWORD *)(v5 + 64);
  *(_QWORD *)(v5 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v12;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(v5 + 56);
  *(_QWORD *)(v5 + 104) = 0;
  *(_QWORD *)(v5 + 80) = 0;
  *(_QWORD *)(v5 + 88) = 0;
  *(_QWORD *)(v5 + 72) = 0;
  *(_DWORD *)(v5 + 96) = 0;
  v13 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(v5 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(v5 + 80) = v13;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  v14 = *(_QWORD *)(v5 + 88);
  *(_QWORD *)(v5 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = v14;
  v15 = *(_QWORD *)(v5 + 104);
  *(_QWORD *)(v5 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v15;
  ++*(_DWORD *)(a2 + 96);
  ++*(_DWORD *)(v5 + 96);
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(v5 + 112, (unsigned __int8 *)(a2 + 112));
  result = re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(v5 + 160, (unsigned __int8 *)(a2 + 160));
  *(_QWORD *)(v5 + 240) = 0;
  *(_DWORD *)(v5 + 232) = 0;
  *(_QWORD *)(v5 + 216) = 0;
  *(_QWORD *)(v5 + 224) = 0;
  *(_QWORD *)(v5 + 208) = 0;
  v17 = *(_QWORD *)(a2 + 216);
  *(_QWORD *)(v5 + 208) = *(_QWORD *)(a2 + 208);
  *(_QWORD *)(v5 + 216) = v17;
  *(_QWORD *)(a2 + 208) = 0;
  *(_QWORD *)(a2 + 216) = 0;
  v18 = *(_QWORD *)(v5 + 224);
  *(_QWORD *)(v5 + 224) = *(_QWORD *)(a2 + 224);
  *(_QWORD *)(a2 + 224) = v18;
  v19 = *(_QWORD *)(v5 + 240);
  *(_QWORD *)(v5 + 240) = *(_QWORD *)(a2 + 240);
  *(_QWORD *)(a2 + 240) = v19;
  ++*(_DWORD *)(a2 + 232);
  ++*(_DWORD *)(v5 + 232);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

double re::DynamicArray<re::GeomModelWithLods>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  double result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::GeomModelWithLods>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 152 * v4;
  result = 0.0;
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_QWORD *)(v5 + 24) = *(_QWORD *)(a2 + 24);
  v7 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)v5 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  v8 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 24) = 0;
  v10 = *(_QWORD *)(v5 + 8);
  v9 = *(_QWORD *)(v5 + 16);
  *(_QWORD *)(v5 + 8) = v7;
  *(_QWORD *)(v5 + 16) = v8;
  *(_QWORD *)(a2 + 8) = v10;
  *(_QWORD *)(a2 + 16) = v9;
  *(_QWORD *)(v5 + 64) = 0;
  *(_DWORD *)(v5 + 56) = 0;
  *(_QWORD *)(v5 + 40) = 0;
  *(_QWORD *)(v5 + 48) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  v11 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(v5 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(v5 + 40) = v11;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v12 = *(_QWORD *)(v5 + 48);
  *(_QWORD *)(v5 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v12;
  v13 = *(_QWORD *)(v5 + 64);
  *(_QWORD *)(v5 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v13;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(v5 + 56);
  *(_QWORD *)(v5 + 104) = 0;
  *(_QWORD *)(v5 + 80) = 0;
  *(_QWORD *)(v5 + 88) = 0;
  *(_QWORD *)(v5 + 72) = 0;
  *(_DWORD *)(v5 + 96) = 0;
  v14 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(v5 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(v5 + 80) = v14;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  v15 = *(_QWORD *)(v5 + 88);
  *(_QWORD *)(v5 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = v15;
  v16 = *(_QWORD *)(v5 + 104);
  *(_QWORD *)(v5 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v16;
  ++*(_DWORD *)(a2 + 96);
  ++*(_DWORD *)(v5 + 96);
  *(_QWORD *)(v5 + 144) = 0;
  *(_QWORD *)(v5 + 120) = 0;
  *(_QWORD *)(v5 + 128) = 0;
  *(_QWORD *)(v5 + 112) = 0;
  *(_DWORD *)(v5 + 136) = 0;
  v17 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(v5 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(v5 + 120) = v17;
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  v18 = *(_QWORD *)(v5 + 128);
  *(_QWORD *)(v5 + 128) = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 128) = v18;
  v19 = *(_QWORD *)(v5 + 144);
  *(_QWORD *)(v5 + 144) = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(a2 + 144) = v19;
  ++*(_DWORD *)(a2 + 136);
  ++*(_DWORD *)(v5 + 136);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

__n128 re::DynamicArray<re::GeomInstance>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  __n128 result;
  __int128 v7;
  __int128 v8;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::GeomInstance>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 80 * v4;
  *(_OWORD *)v5 = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  v7 = *(_OWORD *)(a2 + 32);
  v8 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v5 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v5 + 64) = v8;
  *(__n128 *)(v5 + 16) = result;
  *(_OWORD *)(v5 + 32) = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::MeshPrimitiveProvider::init(re::MeshPrimitiveProvider *this, re::AssetProviderRegistry *a2, re::internal::AssetTypeRegistry *a3)
{
  uint64_t *v5;
  _QWORD *v6;
  unsigned __int8 v7;
  re *v8;
  uint64_t *v9;
  _QWORD *v10;
  unsigned __int8 v11;
  re *v12;
  uint64_t *v13;
  _QWORD *v14;
  unsigned __int8 v15;
  re *v16;
  uint64_t *v17;
  _QWORD *v18;
  unsigned __int8 v19;
  re *v20;
  uint64_t *v21;
  _QWORD *v22;
  unsigned __int8 v23;
  re *v24;
  uint64_t *v25;
  _QWORD *v26;
  unsigned __int8 v27;
  re *v28;
  uint64_t *v29;
  _QWORD *v30;
  unsigned __int8 v31;
  re *v32;
  uint64_t *v33;
  _QWORD *v34;
  unsigned __int8 v35;
  re *v36;
  uint64_t *v37;
  _QWORD *v38;
  unsigned __int8 v39;
  re *v40;
  uint64_t *v41;
  _QWORD *v42;
  unsigned __int8 v43;
  re *v44;
  uint64_t *v45;
  _QWORD *v46;
  unsigned __int8 v47;
  _QWORD *v48;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *v54;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;

  v5 = re::globalAllocators(this);
  v6 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5[2] + 32))(v5[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v6, 0);
  *v6 = off_24ED2ECE8;
  v7 = atomic_load((unsigned __int8 *)&qword_2540FC9F8);
  if ((v7 & 1) == 0 && __cxa_guard_acquire(&qword_2540FC9F8))
  {
    qword_2540FC9F0 = re::internal::getOrCreateInfo((re::internal *)"TubeDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_TubeDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_TubeDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC8F8, 0);
    __cxa_guard_release(&qword_2540FC9F8);
  }
  qword_255800778 = qword_2540FC9F0;
  v6[3] = a2;
  v6[4] = &Tube::providerType;
  *v6 = &off_24ED2EC28;
  v58 = v6;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v58);

  v58 = 0;
  v9 = re::globalAllocators(v8);
  v10 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9[2] + 32))(v9[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v10, 0);
  *v10 = off_24ED2EE38;
  v11 = atomic_load((unsigned __int8 *)&qword_2540FCA08);
  if ((v11 & 1) == 0 && __cxa_guard_acquire(&qword_2540FCA08))
  {
    qword_2540FCA00 = re::internal::getOrCreateInfo((re::internal *)"PlaneDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_PlaneDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_PlaneDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC910, 0);
    __cxa_guard_release(&qword_2540FCA08);
  }
  qword_255800788 = qword_2540FCA00;
  v10[3] = a2;
  v10[4] = &Plane::providerType;
  *v10 = &off_24ED2ED78;
  v57 = v10;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v57);

  v57 = 0;
  v13 = re::globalAllocators(v12);
  v14 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13[2] + 32))(v13[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v14, 0);
  *v14 = off_24ED2EF88;
  v15 = atomic_load((unsigned __int8 *)&qword_2540FCA18);
  if ((v15 & 1) == 0 && __cxa_guard_acquire(&qword_2540FCA18))
  {
    qword_2540FCA10 = re::internal::getOrCreateInfo((re::internal *)"CylinderDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_CylinderDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_CylinderDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC928, 0);
    __cxa_guard_release(&qword_2540FCA18);
  }
  qword_255800798 = qword_2540FCA10;
  v14[3] = a2;
  v14[4] = &Cylinder::providerType;
  *v14 = &off_24ED2EEC8;
  v56 = v14;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v56);

  v56 = 0;
  v17 = re::globalAllocators(v16);
  v18 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v17[2] + 32))(v17[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v18, 0);
  *v18 = off_24ED2F0D8;
  v19 = atomic_load((unsigned __int8 *)&qword_2540FCA28);
  if ((v19 & 1) == 0 && __cxa_guard_acquire(&qword_2540FCA28))
  {
    qword_2540FCA20 = re::internal::getOrCreateInfo((re::internal *)"TetrahedronDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_TetrahedronDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_TetrahedronDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC940, 0);
    __cxa_guard_release(&qword_2540FCA28);
  }
  qword_2558007A8 = qword_2540FCA20;
  v18[3] = a2;
  v18[4] = &Tetrahedron::providerType;
  *v18 = &off_24ED2F018;
  v55 = v18;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v55);

  v55 = 0;
  v21 = re::globalAllocators(v20);
  v22 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v21[2] + 32))(v21[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v22, 0);
  *v22 = off_24ED2F228;
  v23 = atomic_load((unsigned __int8 *)&qword_2540FCA38);
  if ((v23 & 1) == 0 && __cxa_guard_acquire(&qword_2540FCA38))
  {
    qword_2540FCA30 = re::internal::getOrCreateInfo((re::internal *)"ConeDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_ConeDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_ConeDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC958, 0);
    __cxa_guard_release(&qword_2540FCA38);
  }
  qword_2558007B8 = qword_2540FCA30;
  v22[3] = a2;
  v22[4] = &Cone::providerType;
  *v22 = &off_24ED2F168;
  v54 = v22;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v54);

  v54 = 0;
  v25 = re::globalAllocators(v24);
  v26 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v25[2] + 32))(v25[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v26, 0);
  *v26 = off_24ED2F378;
  v27 = atomic_load((unsigned __int8 *)&qword_2540FCA48);
  if ((v27 & 1) == 0 && __cxa_guard_acquire(&qword_2540FCA48))
  {
    qword_2540FCA40 = re::internal::getOrCreateInfo((re::internal *)"SphereDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_SphereDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_SphereDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC970, 0);
    __cxa_guard_release(&qword_2540FCA48);
  }
  qword_2558007C8 = qword_2540FCA40;
  v26[3] = a2;
  v26[4] = &Sphere::providerType;
  *v26 = &off_24ED2F2B8;
  v53 = v26;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v53);

  v53 = 0;
  v29 = re::globalAllocators(v28);
  v30 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v29[2] + 32))(v29[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v30, 0);
  *v30 = off_24ED2F4C8;
  v31 = atomic_load((unsigned __int8 *)&qword_2540FCA58);
  if ((v31 & 1) == 0 && __cxa_guard_acquire(&qword_2540FCA58))
  {
    qword_2540FCA50 = re::internal::getOrCreateInfo((re::internal *)"CapsuleDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_CapsuleDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_CapsuleDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC988, 0);
    __cxa_guard_release(&qword_2540FCA58);
  }
  qword_2558007D8 = qword_2540FCA50;
  v30[3] = a2;
  v30[4] = &Capsule::providerType;
  *v30 = &off_24ED2F408;
  v52 = v30;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v52);

  v52 = 0;
  v33 = re::globalAllocators(v32);
  v34 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v33[2] + 32))(v33[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v34, 0);
  *v34 = off_24ED2F618;
  v35 = atomic_load((unsigned __int8 *)&qword_2540FCA68);
  if ((v35 & 1) == 0 && __cxa_guard_acquire(&qword_2540FCA68))
  {
    qword_2540FCA60 = re::internal::getOrCreateInfo((re::internal *)"PyramidDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_PyramidDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_PyramidDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC9A0, 0);
    __cxa_guard_release(&qword_2540FCA68);
  }
  qword_2558007E8 = qword_2540FCA60;
  v34[3] = a2;
  v34[4] = &Pyramid::providerType;
  *v34 = &off_24ED2F558;
  v51 = v34;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v51);

  v51 = 0;
  v37 = re::globalAllocators(v36);
  v38 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v37[2] + 32))(v37[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v38, 0);
  *v38 = off_24ED2F768;
  v39 = atomic_load((unsigned __int8 *)&qword_2540FCA78);
  if ((v39 & 1) == 0 && __cxa_guard_acquire(&qword_2540FCA78))
  {
    qword_2540FCA70 = re::internal::getOrCreateInfo((re::internal *)"BoxDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_BoxDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_BoxDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC9B8, 0);
    __cxa_guard_release(&qword_2540FCA78);
  }
  qword_2558007F8 = qword_2540FCA70;
  v38[3] = a2;
  v38[4] = &Box::providerType;
  *v38 = &off_24ED2F6A8;
  v50 = v38;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v50);

  v50 = 0;
  v41 = re::globalAllocators(v40);
  v42 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v41[2] + 32))(v41[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v42, 0);
  *v42 = off_24ED2F8B8;
  v43 = atomic_load((unsigned __int8 *)&qword_2540FCA88);
  if ((v43 & 1) == 0 && __cxa_guard_acquire(&qword_2540FCA88))
  {
    qword_2540FCA80 = re::internal::getOrCreateInfo((re::internal *)"BoxWithRoundedCornersDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_BoxWithRoundedCornersDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_BoxWithRoundedCornersDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC9D0, 0);
    __cxa_guard_release(&qword_2540FCA88);
  }
  qword_255800808 = qword_2540FCA80;
  v42[3] = a2;
  v42[4] = &BoxWithRoundedCorners::providerType;
  *v42 = &off_24ED2F7F8;
  v49 = v42;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v49);

  v49 = 0;
  v45 = re::globalAllocators(v44);
  v46 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v45[2] + 32))(v45[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v46, 0);
  *v46 = off_24ED2FA08;
  v47 = atomic_load((unsigned __int8 *)&qword_2540FCA98);
  if ((v47 & 1) == 0 && __cxa_guard_acquire(&qword_2540FCA98))
  {
    qword_2540FCA90 = re::internal::getOrCreateInfo((re::internal *)"ExtrudedTextDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_ExtrudedTextDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_ExtrudedTextDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC9E8, 0);
    __cxa_guard_release(&qword_2540FCA98);
  }
  qword_255800818 = qword_2540FCA90;
  v46[3] = a2;
  v46[4] = &ExtrudedText::providerType;
  *v46 = &off_24ED2F948;
  v48 = v46;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v48);

}

uint64_t re::MeshPrimitiveProvider::makeDescriptor@<X0>(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, uint64_t a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  int v12;
  __int16 v13;
  char v14;
  __int128 v16;
  __int16 v17;
  char v18;
  char v19;
  char v20;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  *(_QWORD *)&v16 = Tube::providerType;
  *((_QWORD *)&v16 + 1) = strlen(Tube::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  *(_QWORD *)&v16 = v10;
  *((_QWORD *)&v16 + 1) = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  v12 = *(_DWORD *)(a1 + 12);
  v13 = *(_WORD *)(a1 + 16);
  v14 = *(_BYTE *)(a1 + 18);
  LODWORD(v16) = *(_DWORD *)a1;
  *(_QWORD *)((char *)&v16 + 4) = *(_QWORD *)(a1 + 4);
  HIDWORD(v16) = v12;
  v17 = v13;
  v18 = v14;
  v19 = a2;
  v20 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_255800778, (const re::IntrospectionBase **)&v16, 0);
}

{
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  int v12;
  int v13;
  int v14;
  size_t v15;
  const re::IntrospectionBase *v17;
  size_t v18;
  int v19;
  int v20;
  int v21;
  char v22;
  char v23;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  v17 = (const re::IntrospectionBase *)Plane::providerType;
  v18 = strlen(Plane::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v17);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  v17 = (const re::IntrospectionBase *)v10;
  v18 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v17);
  v12 = *(_DWORD *)(a1 + 16);
  v13 = *(_DWORD *)(a1 + 20);
  v14 = *(_DWORD *)(a1 + 24);
  v15 = *(_QWORD *)(a1 + 8);
  v17 = *(const re::IntrospectionBase **)a1;
  v18 = v15;
  v19 = v12;
  v20 = v13;
  v21 = v14;
  v22 = a2;
  v23 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_255800788, &v17, 0);
}

{
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  int v12;
  int v13;
  char v14;
  __int128 v16;
  int v17;
  char v18;
  char v19;
  char v20;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  *(_QWORD *)&v16 = Cylinder::providerType;
  *((_QWORD *)&v16 + 1) = strlen(Cylinder::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  *(_QWORD *)&v16 = v10;
  *((_QWORD *)&v16 + 1) = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  v12 = *(_DWORD *)(a1 + 12);
  v13 = *(_DWORD *)(a1 + 16);
  v14 = *(_BYTE *)(a1 + 20);
  LODWORD(v16) = *(_DWORD *)a1;
  *(_QWORD *)((char *)&v16 + 4) = *(_QWORD *)(a1 + 4);
  HIDWORD(v16) = v12;
  v17 = v13;
  v18 = v14;
  v19 = a2;
  v20 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_255800798, (const re::IntrospectionBase **)&v16, 0);
}

{
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  __int16 v12;
  char v13;
  size_t v14;
  const re::IntrospectionBase *v16;
  size_t v17;
  __int16 v18;
  char v19;
  char v20;
  char v21;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  v16 = (const re::IntrospectionBase *)Capsule::providerType;
  v17 = strlen(Capsule::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  v16 = (const re::IntrospectionBase *)v10;
  v17 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  v12 = *(_WORD *)(a1 + 16);
  v13 = *(_BYTE *)(a1 + 18);
  v14 = *(_QWORD *)(a1 + 8);
  v16 = *(const re::IntrospectionBase **)a1;
  v17 = v14;
  v18 = v12;
  v19 = v13;
  v20 = a2;
  v21 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2558007D8, &v16, 0);
}

{
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  int v12;
  __int16 v13;
  char v14;
  __int128 v16;
  __int16 v17;
  char v18;
  char v19;
  char v20;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  *(_QWORD *)&v16 = Pyramid::providerType;
  *((_QWORD *)&v16 + 1) = strlen(Pyramid::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  *(_QWORD *)&v16 = v10;
  *((_QWORD *)&v16 + 1) = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  v12 = *(_DWORD *)(a1 + 12);
  v13 = *(_WORD *)(a1 + 16);
  v14 = *(_BYTE *)(a1 + 18);
  LODWORD(v16) = *(_DWORD *)a1;
  *(_QWORD *)((char *)&v16 + 4) = *(_QWORD *)(a1 + 4);
  HIDWORD(v16) = v12;
  v17 = v13;
  v18 = v14;
  v19 = a2;
  v20 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2558007E8, (const re::IntrospectionBase **)&v16, 0);
}

{
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  __int16 v12;
  char v13;
  const re::IntrospectionBase *v15;
  __int128 v16;
  __int16 v17;
  char v18;
  char v19;
  char v20;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  v15 = (const re::IntrospectionBase *)Box::providerType;
  *(_QWORD *)&v16 = strlen(Box::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v15);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  v15 = (const re::IntrospectionBase *)v10;
  *(_QWORD *)&v16 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v15);
  v12 = *(_WORD *)(a1 + 24);
  v13 = *(_BYTE *)(a1 + 26);
  v15 = *(const re::IntrospectionBase **)a1;
  v16 = *(_OWORD *)(a1 + 8);
  v17 = v12;
  v18 = v13;
  v19 = a2;
  v20 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2558007F8, &v15, 0);
}

{
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  int v12;
  int v13;
  __int16 v14;
  char v15;
  const re::IntrospectionBase *v17;
  _BYTE v18[20];
  int v19;
  int v20;
  __int16 v21;
  char v22;
  char v23;
  char v24;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  v17 = (const re::IntrospectionBase *)BoxWithRoundedCorners::providerType;
  *(_QWORD *)v18 = strlen(BoxWithRoundedCorners::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v17);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  v17 = (const re::IntrospectionBase *)v10;
  *(_QWORD *)v18 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v17);
  v12 = *(_DWORD *)(a1 + 8);
  v13 = *(_DWORD *)(a1 + 28);
  v14 = *(_WORD *)(a1 + 36);
  v15 = *(_BYTE *)(a1 + 38);
  v17 = *(const re::IntrospectionBase **)a1;
  *(_DWORD *)v18 = v12;
  *(_OWORD *)&v18[4] = *(_OWORD *)(a1 + 12);
  v19 = v13;
  v20 = *(_DWORD *)(a1 + 32);
  v21 = v14;
  v22 = v15;
  v23 = a2;
  v24 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_255800808, &v17, 0);
}

uint64_t re::MeshPrimitiveProvider::makeDescriptor@<X0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const re::IntrospectionBase *v16;
  size_t v17;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  v16 = (const re::IntrospectionBase *)Tetrahedron::providerType;
  v17 = strlen(Tetrahedron::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  v16 = (const re::IntrospectionBase *)v10;
  v17 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  v12 = *(unsigned __int16 *)(a1 + 8) | ((unint64_t)*(unsigned __int8 *)(a1 + 10) << 16);
  v13 = 0x100000000;
  if (!a2)
    v13 = 0;
  v14 = 0x10000000000;
  if (!a3)
    v14 = 0;
  v16 = *(const re::IntrospectionBase **)a1;
  v17 = v14 | v13 | v12;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2558007A8, &v16, 0);
}

{
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const re::IntrospectionBase *v16;
  size_t v17;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  v16 = (const re::IntrospectionBase *)Sphere::providerType;
  v17 = strlen(Sphere::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  v16 = (const re::IntrospectionBase *)v10;
  v17 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  v12 = *(unsigned __int16 *)(a1 + 8) | ((unint64_t)*(unsigned __int8 *)(a1 + 10) << 16);
  v13 = 0x100000000;
  if (!a2)
    v13 = 0;
  v14 = 0x10000000000;
  if (!a3)
    v14 = 0;
  v16 = *(const re::IntrospectionBase **)a1;
  v17 = v14 | v13 | v12;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2558007C8, &v16, 0);
}

uint64_t re::MeshPrimitiveProvider::makeDescriptor@<X0>(_anonymous_namespace_ *a1@<X0>, char a2@<W1>, char a3@<W2>, uint64_t a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  __int128 v13;
  char v14;
  char v15;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  *(_QWORD *)&v13 = Cone::providerType;
  *((_QWORD *)&v13 + 1) = strlen(Cone::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v13);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  *(_QWORD *)&v13 = v10;
  *((_QWORD *)&v13 + 1) = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v13);
  v13 = *(_OWORD *)a1;
  v14 = a2;
  v15 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2558007B8, (const re::IntrospectionBase **)&v13, 0);
}

uint64_t *re::MeshPrimitiveProvider::makeDescriptor@<X0>(re::MeshPrimitiveProvider *this@<X0>, const re::GeomBuildExtrudedTextOptions *a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  char v5;
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  const char *v10;
  size_t v11;
  _anonymous_namespace_ *v12;
  _anonymous_namespace_ *v13;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *result;
  _OWORD v27[2];
  _QWORD v28[4];
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t *v33;
  size_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  __int16 v42;

  v5 = (char)a2;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  v33 = (uint64_t *)ExtrudedText::providerType;
  v34 = strlen(ExtrudedText::providerType);
  v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v33);
  v10 = (const char *)*re::MeshAsset::assetType(v9);
  v11 = strlen(v10);
  v33 = (uint64_t *)v10;
  v34 = v11;
  v12 = re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v33);
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v33, 0);
  *((_QWORD *)&v37 + 1) = 0;
  v38 = 0uLL;
  re::DynamicString::setCapacity(&v37, 0);
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)&v39 = _D0;
  BYTE8(v39) = 5;
  v40 = 0uLL;
  v41 = 0x1010101000400;
  re::DynamicString::operator=((re::DynamicString *)&v33, this);
  re::DynamicString::operator=((re::DynamicString *)&v37, (re::MeshPrimitiveProvider *)((char *)this + 32));
  v19 = *((_OWORD *)this + 5);
  v39 = *((_OWORD *)this + 4);
  v40 = v19;
  v41 = *((_QWORD *)this + 12);
  LOBYTE(v42) = v5;
  HIBYTE(v42) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)v27, (const re::DynamicString *)&v33);
  re::DynamicString::DynamicString((re::DynamicString *)v28, (const re::DynamicString *)&v37);
  v29 = v39;
  v30 = v40;
  v31 = v41;
  v32 = v42;
  re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_255800818, (const re::IntrospectionBase **)v27, 0);
  if (v28[0])
  {
    if ((v28[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v28[0] + 40))();
    memset(v28, 0, sizeof(v28));
  }
  if (*(_QWORD *)&v27[0])
  {
    if ((BYTE8(v27[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v27[0] + 40))();
    memset(v27, 0, sizeof(v27));
  }
  if ((_QWORD)v37)
  {
    if ((BYTE8(v37) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v37 + 40))(v37, v38, v20, v21, v22, v23, v24, v25);
    v37 = 0u;
    v38 = 0u;
  }
  result = v33;
  if (v33)
  {
    if ((v34 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*v33 + 40))(v33, v35, v20, v21, v22, v23, v24, v25);
  }
  return result;
}

void `anonymous namespace'::BuildSupport::setFont(_anonymous_namespace_::BuildSupport *this, CFTypeRef cf, unint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  const void *v7;

  *((_QWORD *)this + 10) = cf;
  *((_QWORD *)this + 11) = a3;
  v5 = *((unsigned __int16 *)this + 48);
  v6 = ((a3 << 6) + (a3 >> 2) - 0x61C8864680B583E9 + v5) ^ a3;
  if (cf)
    CFRetain(cf);
  v7 = (const void *)*((_QWORD *)this + 7);
  *((_WORD *)this + 36) = v5;
  *((_QWORD *)this + 7) = cf;
  *((_QWORD *)this + 8) = v6;
  if (v7)
    CFRelease(v7);
}

void `anonymous namespace'::BuildSupport::setGlyphIndex(_anonymous_namespace_::BuildSupport *this, uint64_t a2)
{
  __int16 v2;
  uint64_t v4;
  uint64_t v5;
  const void *v6;

  v2 = a2;
  *((_QWORD *)this + 12) = a2;
  v4 = *((_QWORD *)this + 10);
  v5 = ((*((_QWORD *)this + 11) << 6) + (unsigned __int16)a2 + (*((_QWORD *)this + 11) >> 2) - 0x61C8864680B583E9) ^ *((_QWORD *)this + 11);
  if (v4)
    CFRetain(*((CFTypeRef *)this + 10));
  v6 = (const void *)*((_QWORD *)this + 7);
  *((_WORD *)this + 36) = v2;
  *((_QWORD *)this + 7) = v4;
  *((_QWORD *)this + 8) = v5;
  if (v6)
    CFRelease(v6);
}

uint64_t `anonymous namespace'::BuildSupport::cachedGlyph(_anonymous_namespace_::BuildSupport *this)
{
  uint64_t v1;
  uint64_t v2;
  char *v3;
  uint64_t v4;
  BOOL v5;

  v1 = *((_QWORD *)this + 6);
  if (!*(_QWORD *)v1)
    return 0;
  v2 = *(unsigned int *)(*(_QWORD *)(v1 + 8) + 4
                                             * (*((_QWORD *)this + 8) % (unint64_t)*(unsigned int *)(v1 + 24)));
  if ((_DWORD)v2 == 0x7FFFFFFF)
    return 0;
  v3 = (char *)this + 56;
  v4 = *(_QWORD *)(v1 + 16);
  while (1)
  {
    v5 = re::internal::FontNameAndGlyphIndexCacheKey::operator==(v4 + 816 * v2 + 16, (uint64_t)v3);
    v4 = *(_QWORD *)(v1 + 16);
    if (v5)
      break;
    v2 = *(_DWORD *)(v4 + 816 * v2 + 8) & 0x7FFFFFFF;
    if (v2 == 0x7FFFFFFF)
      return 0;
  }
  return v4 + 816 * v2 + 48;
}

uint64_t `anonymous namespace'::BuildSupport::storeGlyph(uint64_t a1, re::GeomMesh *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;

  v4 = *(_QWORD *)(a1 + 48);
  v5 = *(_QWORD *)(a1 + 64);
  if (!*(_QWORD *)v4)
  {
    LODWORD(v6) = 0;
    goto LABEL_8;
  }
  v6 = v5 % *(unsigned int *)(v4 + 24);
  v7 = *(unsigned int *)(*(_QWORD *)(v4 + 8) + 4 * v6);
  if ((_DWORD)v7 == 0x7FFFFFFF)
  {
LABEL_8:
    v10 = *(_DWORD *)(v4 + 36);
    if (v10 == 0x7FFFFFFF)
    {
      v10 = *(_DWORD *)(v4 + 32);
      v11 = v10;
      if (v10 == *(_DWORD *)(v4 + 24))
      {
        re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::setCapacity(v4, 2 * *(_DWORD *)(v4 + 28));
        LODWORD(v6) = v5 % *(unsigned int *)(v4 + 24);
        v11 = *(_DWORD *)(v4 + 32);
      }
      *(_DWORD *)(v4 + 32) = v11 + 1;
      v12 = *(_QWORD *)(v4 + 16);
      v13 = *(_DWORD *)(v12 + 816 * v10 + 8);
    }
    else
    {
      v12 = *(_QWORD *)(v4 + 16);
      v13 = *(_DWORD *)(v12 + 816 * v10 + 8);
      *(_DWORD *)(v4 + 36) = v13 & 0x7FFFFFFF;
    }
    v14 = 816 * v10;
    *(_DWORD *)(v12 + v14 + 8) = v13 | 0x80000000;
    *(_DWORD *)(*(_QWORD *)(v4 + 16) + v14 + 8) = *(_DWORD *)(*(_QWORD *)(v4 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(v4 + 8) + 4 * v6);
    *(_QWORD *)(*(_QWORD *)(v4 + 16) + v14) = v5;
    v15 = *(_QWORD *)(v4 + 16) + v14;
    v16 = *(const void **)(a1 + 56);
    v17 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(v15 + 16) = v16;
    *(_QWORD *)(v15 + 24) = v17;
    *(_WORD *)(v15 + 32) = *(_WORD *)(a1 + 72);
    if (v16)
      CFRetain(v16);
    v18 = *(_QWORD *)(v4 + 16) + 816 * v10;
    *(_QWORD *)(v18 + 48) = 0;
    v18 += 48;
    *(_DWORD *)(v18 + 8) = 0;
    bzero((void *)(v18 + 16), 0x2C8uLL);
    re::internal::GeomBaseMesh::GeomBaseMesh((re::internal::GeomBaseMesh *)(v18 + 16));
    *(_QWORD *)(v18 + 728) = 0;
    re::GeomMesh::copy(a2, (re::GeomMesh *)v18);
    v19 = *((_OWORD *)a2 + 47);
    *(_OWORD *)(v18 + 736) = *((_OWORD *)a2 + 46);
    *(_OWORD *)(v18 + 752) = v19;
    *(_DWORD *)(*(_QWORD *)(v4 + 8) + 4 * v6) = v10;
    ++*(_DWORD *)(v4 + 28);
    ++*(_DWORD *)(v4 + 40);
    v20 = *(_QWORD *)(v4 + 16) + 816 * v10;
    return v20 + 48;
  }
  v8 = *(_QWORD *)(v4 + 16);
  while (1)
  {
    v9 = re::internal::FontNameAndGlyphIndexCacheKey::operator==(v8 + 816 * v7 + 16, a1 + 56);
    v8 = *(_QWORD *)(v4 + 16);
    if (v9)
      break;
    v7 = *(_DWORD *)(v8 + 816 * v7 + 8) & 0x7FFFFFFF;
    if (v7 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v20 = v8 + 816 * v7;
  return v20 + 48;
}

__n128 `anonymous namespace'::BuildSupport::finalBounds(_anonymous_namespace_::BuildSupport *this, const AABB *a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)&a2->var0.var0.var0.var0;
  v3 = *(_OWORD *)&a2->var1.var0.var1[1];
  *((_OWORD *)this + 1) = *(_OWORD *)&a2->var0.var0.var0.var0;
  *((_OWORD *)this + 2) = v3;
  return result;
}

void re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  re::GeomAttribute *v5;
  __int128 v6;
  uint64_t *v7;
  __int128 v8;
  unsigned int v9;
  __int128 v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23;
  uint64_t v24;
  __int128 v25;
  signed int v26;
  _BYTE v27[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v27, 0, 36);
      *(_QWORD *)&v27[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::init((uint64_t)v27, v4, a2);
      v6 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v27;
      v7 = *(uint64_t **)(a1 + 16);
      v8 = *(_OWORD *)&v27[8];
      *(_OWORD *)v27 = v6;
      *(_QWORD *)&v27[16] = v7;
      *(_OWORD *)(a1 + 8) = v8;
      v10 = *(_OWORD *)&v27[24];
      *(_OWORD *)&v27[24] = *(_OWORD *)(a1 + 24);
      v9 = *(_DWORD *)&v27[32];
      *(_OWORD *)(a1 + 24) = v10;
      v11 = v9;
      if (v9)
      {
        v12 = DWORD1(v10);
        v13 = v8;
        do
        {
          if ((v7[1] & 0x80000000) != 0)
          {
            v14 = *v7;
            v15 = *(unsigned int *)(a1 + 24);
            v16 = *v7 % v15;
            v17 = *(_DWORD *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              v17 = *(_DWORD *)(a1 + 32);
              v18 = v17;
              if (v17 == (_DWORD)v15)
              {
                re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::setCapacity(a1, (2 * v12));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 816 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 816 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 816 * v17 + 8) = v20 | 0x80000000;
            v21 = *(_QWORD *)(a1 + 16) + 816 * v17;
            *(_DWORD *)(v21 + 8) = *(_DWORD *)(v21 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 816 * v17) = v14;
            v22 = *(_QWORD *)(a1 + 16) + 816 * v17;
            v23 = (const void *)v7[2];
            *(_QWORD *)(v22 + 16) = v23;
            *(_QWORD *)(v22 + 24) = v7[3];
            *(_WORD *)(v22 + 32) = *((_WORD *)v7 + 16);
            if (v23)
              CFRetain(v23);
            v24 = *(_QWORD *)(a1 + 16) + 816 * v17;
            re::GeomMesh::GeomMesh(v24 + 48, (uint64_t)(v7 + 6));
            v25 = *((_OWORD *)v7 + 50);
            *(_OWORD *)(v24 + 784) = *((_OWORD *)v7 + 49);
            *(_OWORD *)(v24 + 800) = v25;
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v16) = v17;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          v7 += 102;
          --v11;
        }
        while (v11);
      }
      re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::deinit((uint64_t *)v27, v5);
    }
  }
  else
  {
    if (a2)
      v26 = a2;
    else
      v26 = 3;
  }
}

void re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 816 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

re::GeomModel *re::GeomModel::GeomModel(re::GeomModel *this)
{
  _anonymous_namespace_ *v2;
  _anonymous_namespace_ *v3;

  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 1) = 0;
  v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(this, 1uLL);
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 4) = 0;
  v3 = (_anonymous_namespace_ *)re::DynamicArray<re::GeomMesh>::setCapacity((_QWORD *)this + 4, 1uLL);
  ++*((_DWORD *)this + 14);
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 9) = 0;
  re::DynamicArray<int>::setCapacity((_QWORD *)this + 9, 1uLL);
  ++*((_DWORD *)this + 24);
  *((_BYTE *)this + 112) = 0;
  *((_BYTE *)this + 160) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_DWORD *)this + 58) = 0;
  return this;
}

_QWORD *re::DynamicArray<re::GeomMesh>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  re::GeomMesh *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  re::GeomAttribute *v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::GeomMesh>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x2E0uLL))
        {
          v2 = 736 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 736 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 736, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (re::GeomMesh *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 736 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::GeomMesh::GeomMesh(v11, (uint64_t)v8);
          re::GeomMesh::~GeomMesh(v8, v12);
          v8 = (re::GeomMesh *)((char *)v8 + 736);
          v11 += 736;
          v10 -= 736;
        }
        while (v10);
        v8 = (re::GeomMesh *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, re::GeomMesh *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

re::GeomModelWithLods *re::GeomModelWithLods::GeomModelWithLods(re::GeomModelWithLods *this)
{
  _anonymous_namespace_ *v2;
  _anonymous_namespace_ *v3;
  _anonymous_namespace_ *v4;

  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 1) = 0;
  v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(this, 1uLL);
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 4) = 0;
  v3 = (_anonymous_namespace_ *)re::DynamicArray<re::GeomModel>::setCapacity((_QWORD *)this + 4, 1uLL);
  ++*((_DWORD *)this + 14);
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 9) = 0;
  v4 = (_anonymous_namespace_ *)re::DynamicArray<int>::setCapacity((_QWORD *)this + 9, 1uLL);
  ++*((_DWORD *)this + 24);
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  *((_QWORD *)this + 14) = 0;
  re::DynamicArray<int>::setCapacity((_QWORD *)this + 14, 1uLL);
  ++*((_DWORD *)this + 34);
  return this;
}

_QWORD *re::DynamicArray<re::GeomModel>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::GeomModel>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xF8uLL))
        {
          v2 = 248 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 248 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 248, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (_QWORD *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 248 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::GeomModel>(v8, v11);
          v8 += 31;
          v11 += 248;
          v10 -= 248;
        }
        while (v10);
        v8 = (_QWORD *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

double re::ObjectHelper::move<re::GeomModel>(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  re::GeomAttribute *v20;
  double result;

  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 24) = a1[3];
  v4 = a1[1];
  *(_QWORD *)a2 = *a1;
  *a1 = 0;
  v5 = a1[2];
  a1[3] = 0;
  v7 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = v4;
  *(_QWORD *)(a2 + 16) = v5;
  a1[1] = v7;
  a1[2] = v6;
  *(_QWORD *)(a2 + 64) = 0;
  *(_DWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  v8 = (uint64_t)(a1 + 4);
  v9 = a1[5];
  *(_QWORD *)(a2 + 32) = a1[4];
  a1[4] = 0;
  *(_QWORD *)(a2 + 40) = v9;
  a1[5] = 0;
  v10 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = a1[6];
  a1[6] = v10;
  v11 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = a1[8];
  a1[8] = v11;
  ++*((_DWORD *)a1 + 14);
  ++*(_DWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_DWORD *)(a2 + 96) = 0;
  v12 = a1 + 9;
  v13 = a1[10];
  *(_QWORD *)(a2 + 72) = a1[9];
  a1[9] = 0;
  *(_QWORD *)(a2 + 80) = v13;
  a1[10] = 0;
  v14 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = a1[11];
  a1[11] = v14;
  v15 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = a1[13];
  a1[13] = v15;
  ++*((_DWORD *)a1 + 24);
  ++*(_DWORD *)(a2 + 96);
  v16 = a1 + 14;
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(a2 + 112, (unsigned __int8 *)a1 + 112);
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(a2 + 160, (unsigned __int8 *)a1 + 160);
  *(_QWORD *)(a2 + 240) = 0;
  *(_DWORD *)(a2 + 232) = 0;
  *(_QWORD *)(a2 + 216) = 0;
  *(_QWORD *)(a2 + 224) = 0;
  *(_QWORD *)(a2 + 208) = 0;
  v17 = a1[27];
  *(_QWORD *)(a2 + 208) = a1[26];
  *(_QWORD *)(a2 + 216) = v17;
  a1[26] = 0;
  a1[27] = 0;
  v18 = *(_QWORD *)(a2 + 224);
  *(_QWORD *)(a2 + 224) = a1[28];
  a1[28] = v18;
  v19 = *(_QWORD *)(a2 + 240);
  *(_QWORD *)(a2 + 240) = a1[30];
  a1[30] = v19;
  ++*((_DWORD *)a1 + 58);
  ++*(_DWORD *)(a2 + 232);
  re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)(a1 + 26));
  if (*((_BYTE *)a1 + 160))
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)(a1 + 21));
  if (*v16)
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)(a1 + 15));
  if (*v12)
  {
    v20 = (re::GeomAttribute *)a1[13];
    if (v20)
      (*(void (**)(_QWORD))(*(_QWORD *)*v12 + 40))(*v12);
    a1[13] = 0;
    v12[1] = 0;
    v12[2] = 0;
    *v12 = 0;
    ++*((_DWORD *)a1 + 24);
  }
  re::DynamicArray<re::GeomMesh>::deinit(v8, v20);
  if (*a1)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

uint64_t re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(uint64_t result, unsigned __int8 *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *a2;
  *(_BYTE *)result = v2;
  if (v2)
  {
    *(_QWORD *)(result + 40) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 32) = 0;
    v3 = *((_QWORD *)a2 + 2);
    *(_QWORD *)(result + 8) = *((_QWORD *)a2 + 1);
    *(_QWORD *)(result + 16) = v3;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    v4 = *(_QWORD *)(result + 24);
    *(_QWORD *)(result + 24) = *((_QWORD *)a2 + 3);
    *((_QWORD *)a2 + 3) = v4;
    v5 = *(_QWORD *)(result + 40);
    *(_QWORD *)(result + 40) = *((_QWORD *)a2 + 5);
    *((_QWORD *)a2 + 5) = v5;
    ++*((_DWORD *)a2 + 8);
    ++*(_DWORD *)(result + 32);
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomModel>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  re::GeomAttribute *v8;
  _QWORD *v9;
  uint64_t v10;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 0;
        v6 = 248 * v4;
        do
        {
          v7 = v3 + v5;
          re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit(v3 + v5 + 208);
          if (*(_BYTE *)(v3 + v5 + 160))
            re::DynamicArray<re::GeomIndexMap>::deinit(v7 + 168);
          if (*(_BYTE *)(v7 + 112))
            re::DynamicArray<re::GeomIndexMap>::deinit(v3 + v5 + 120);
          v9 = (_QWORD *)(v3 + v5);
          v10 = *(_QWORD *)(v3 + v5 + 72);
          if (v10)
          {
            v8 = (re::GeomAttribute *)v9[13];
            if (v8)
              (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
            v9[13] = 0;
            *(_QWORD *)(v3 + v5 + 80) = 0;
            *(_QWORD *)(v3 + v5 + 88) = 0;
            *(_QWORD *)(v3 + v5 + 72) = 0;
            ++*(_DWORD *)(v3 + v5 + 96);
          }
          re::DynamicArray<re::GeomMesh>::deinit((uint64_t)(v9 + 4), v8);
          if (*v9)
          {
            if ((*(_BYTE *)(v3 + v5 + 8) & 1) != 0)
              (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v9 + 40))(*v9, *(_QWORD *)(v3 + v5 + 16));
            *(_OWORD *)v7 = 0u;
            *(_OWORD *)(v7 + 16) = 0u;
          }
          v5 += 248;
        }
        while (v6 != v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(uint64_t **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 48 * v4;
        do
        {
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v3);
          v3 += 6;
          v5 -= 48;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(uint64_t **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomIndexMap>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  int v7;
  uint64_t v8;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 80 * v4;
        v6 = (uint64_t *)(v3 + 48);
        while (1)
        {
          v7 = *((unsigned __int8 *)v6 - 36);
          if (v7 == 2)
          {
            re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)(v6 - 4));
          }
          else if (v7 == 1)
          {
            v8 = *(v6 - 4);
            if (v8)
            {
              v3 = *v6;
              if (*v6)
                (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
              *v6 = 0;
              *(v6 - 3) = 0;
              *(v6 - 2) = 0;
              *(v6 - 4) = 0;
              ++*((_DWORD *)v6 - 2);
            }
          }
          else
          {
            if (*((_BYTE *)v6 - 36))
            {
              re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
              result = _os_crash();
              __break(1u);
              return result;
            }
            *((_DWORD *)v6 - 8) = 0;
          }
          v6 += 10;
          v5 -= 80;
          if (!v5)
          {
            result = *(_QWORD *)a1;
            v3 = *(_QWORD *)(a1 + 32);
            break;
          }
        }
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomMesh>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= *(_QWORD *)(a1 + 8))
  {
    re::DynamicArray<re::GeomMesh>::growCapacity((_QWORD *)a1, v4 + 1);
    v4 = *(_QWORD *)(a1 + 16);
  }
  result = re::GeomMesh::GeomMesh(*(_QWORD *)(a1 + 32) + 736 * v4, a2);
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

_QWORD *re::DynamicArray<re::GeomMesh>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::GeomMesh>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::GeomMesh>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(_QWORD *)a1 || *(_QWORD *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomSkeleton>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  __n128 v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 0;
        v6 = 160 * v4;
        do
        {
          v7 = (_QWORD *)(v3 + v5);
          v8.n128_f64[0] = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(v3 + v5 + 112));
          v9 = *(_QWORD *)(v3 + v5 + 88);
          if (v9)
          {
            if (v7[12])
            {
              (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v9 + 40))(v9, *(_QWORD *)(v3 + v5 + 104), v8.n128_f64[0]);
              v7[12] = 0;
              v7[13] = 0;
            }
            v7[11] = 0;
          }
          v10 = v7[8];
          if (v10)
          {
            if (*(_QWORD *)(v3 + v5 + 72))
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v10 + 40))(v10, *(_QWORD *)(v3 + v5 + 80), v8);
              *(_QWORD *)(v3 + v5 + 72) = 0;
              *(_QWORD *)(v3 + v5 + 80) = 0;
            }
            v7[8] = 0;
          }
          v11 = (_QWORD *)(v3 + v5);
          v12 = *(_QWORD *)(v3 + v5 + 40);
          if (v12)
          {
            if (v11[6])
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v12 + 40))(v12, *(_QWORD *)(v3 + v5 + 56), v8);
              v11[6] = 0;
              v11[7] = 0;
            }
            v11[5] = 0;
          }
          re::FixedArray<re::StringID>::deinit(v11 + 2);
          re::StringID::destroyString((re::StringID *)(v3 + v5));
          v5 += 160;
        }
        while (v6 != v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomModelWithLods>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD *v10;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = (_QWORD *)(v3 + 144);
        v6 = 152 * v4;
        do
        {
          v7 = *(v5 - 4);
          if (v7)
          {
            if (*v5)
              (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
            *v5 = 0;
            *(v5 - 3) = 0;
            *(v5 - 2) = 0;
            *(v5 - 4) = 0;
            ++*((_DWORD *)v5 - 2);
          }
          v8 = *(v5 - 9);
          if (v8)
          {
            if (*(v5 - 5))
              (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
            *(v5 - 5) = 0;
            *(v5 - 8) = 0;
            *(v5 - 7) = 0;
            *(v5 - 9) = 0;
            ++*((_DWORD *)v5 - 12);
          }
          re::DynamicArray<re::GeomModel>::deinit((uint64_t)(v5 - 14));
          v9 = *(v5 - 18);
          if (v9)
          {
            if ((*(_BYTE *)(v5 - 17) & 1) != 0)
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *(v5 - 16));
            v10 = v5 - 18;
            *v10 = 0u;
            v10[1] = 0u;
          }
          v5 += 19;
          v6 -= 152;
        }
        while (v6);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetSkeleton>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 0;
        v6 = 112 * v4;
        do
        {
          v7 = (_QWORD *)(v3 + v5);
          v8 = *(_QWORD *)(v3 + v5 + 88);
          if (v8)
          {
            if (v7[12])
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *(_QWORD *)(v3 + v5 + 104));
              v7[12] = 0;
              v7[13] = 0;
            }
            v7[11] = 0;
          }
          v9 = v7[8];
          if (v9)
          {
            if (*(_QWORD *)(v3 + v5 + 72))
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *(_QWORD *)(v3 + v5 + 80));
              *(_QWORD *)(v3 + v5 + 72) = 0;
              *(_QWORD *)(v3 + v5 + 80) = 0;
            }
            v7[8] = 0;
          }
          v10 = (_QWORD *)(v3 + v5);
          v11 = *(_QWORD *)(v3 + v5 + 40);
          if (v11)
          {
            if (v10[6])
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v3 + v5 + 56));
              v10[6] = 0;
              v10[7] = 0;
            }
            v10[5] = 0;
          }
          re::FixedArray<re::StringID>::deinit(v10 + 2);
          re::StringID::destroyString((re::StringID *)(v3 + v5));
          v5 += 112;
        }
        while (v6 != v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetInstance>::deinit(uint64_t a1)
{
  uint64_t result;
  re::StringID *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 96 * v4;
        do
        {
          re::StringID::destroyString(v3);
          v3 = (re::StringID *)((char *)v3 + 96);
          v5 -= 96;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::StringID **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetModel>::deinit(uint64_t a1)
{
  uint64_t result;
  re::MeshAssetModel *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::MeshAssetModel **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = v4 << 9;
        do
        {
          re::MeshAssetModel::~MeshAssetModel(v3);
          v3 = (re::MeshAssetModel *)((char *)v3 + 512);
          v5 -= 512;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::MeshAssetModel **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::MeshAssetModel *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::MeshAssetModel::~MeshAssetModel(re::MeshAssetModel *this)
{
  uint64_t v2;

  re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit((uint64_t)this + 472);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 432);
  re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit((uint64_t)this + 392);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352);
  re::DynamicArray<re::MeshAssetContactDeformerData>::deinit((uint64_t)this + 312);
  v2 = *((_QWORD *)this + 34);
  if (v2)
  {
    if (*((_QWORD *)this + 38))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 36) = 0;
    *((_QWORD *)this + 34) = 0;
    ++*((_DWORD *)this + 74);
  }
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)this + 232);
  re::DynamicArray<re::MeshAssetPart>::deinit((uint64_t)this + 192);
  re::DynamicArray<re::MeshAssetSkinningData>::deinit((uint64_t)this + 152);
  re::DynamicArray<re::MeshAssetBlendShapeData>::deinit((uint64_t)this + 112);
  re::StringID::destroyString(this);
}

uint64_t re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 0;
        v6 = 112 * v4;
        do
        {
          v7 = (_QWORD *)(v3 + v5);
          v8 = *(_QWORD *)(v3 + v5 + 80);
          if (v8)
          {
            if (v7[11])
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *(_QWORD *)(v3 + v5 + 96));
              v7[11] = 0;
              v7[12] = 0;
            }
            v7[10] = 0;
          }
          v9 = v7[7];
          if (v9)
          {
            if (*(_QWORD *)(v3 + v5 + 64))
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *(_QWORD *)(v3 + v5 + 72));
              *(_QWORD *)(v3 + v5 + 64) = 0;
              *(_QWORD *)(v3 + v5 + 72) = 0;
            }
            v7[7] = 0;
          }
          v10 = (_QWORD *)(v3 + v5);
          v11 = *(_QWORD *)(v3 + v5 + 32);
          if (v11)
          {
            if (v10[5])
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v3 + v5 + 48));
              v10[5] = 0;
              v10[6] = 0;
            }
            v10[4] = 0;
          }
          re::StringID::destroyString((re::StringID *)(v10 + 2));
          re::StringID::destroyString((re::StringID *)(v3 + v5));
          v5 += 112;
        }
        while (v6 != v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetContactDeformerData>::deinit(uint64_t a1)
{
  uint64_t result;
  re::StringID *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 48 * v4;
        do
        {
          re::FixedArray<re::MeshAssetContactDeformerTarget>::deinit((_QWORD *)v3 + 2);
          re::StringID::destroyString(v3);
          v3 = (re::StringID *)((char *)v3 + 48);
          v5 -= 48;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::StringID **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::FixedArray<re::MeshAssetContactDeformerTarget>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = 32 * v2;
      v5 = (_QWORD *)(result[2] + 16);
      do
      {
        v6 = *(v5 - 1);
        if (v6)
        {
          if (*v5)
          {
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, v5[1]);
            *v5 = 0;
            v5[1] = 0;
          }
          *(v5 - 1) = 0;
        }
        v5 += 4;
        v4 -= 32;
      }
      while (v4);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetPart>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = v4 << 8;
        do
        {
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v3 + 200));
          re::StringID::destroyString((re::StringID *)(v3 + 72));
          re::DynamicArray<re::MeshAssetBuffer>::deinit(v3);
          v3 += 256;
          v5 -= 256;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetBuffer>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = (_QWORD *)(v3 + 64);
        v6 = 80 * v4;
        do
        {
          v7 = *(v5 - 4);
          if (v7)
          {
            if (*v5)
              (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
            *v5 = 0;
            *(v5 - 3) = 0;
            *(v5 - 2) = 0;
            *(v5 - 4) = 0;
            ++*((_DWORD *)v5 - 2);
          }
          v8 = *(v5 - 8);
          if (v8)
          {
            if ((*(_BYTE *)(v5 - 7) & 1) != 0)
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *(v5 - 6));
            *((_OWORD *)v5 - 4) = 0u;
            *((_OWORD *)v5 - 3) = 0u;
          }
          v5 += 10;
          v6 -= 80;
        }
        while (v6);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetSkinningData>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 144 * v4;
        v6 = (_QWORD *)(v3 + 40);
        do
        {
          v7 = v6[2];
          if (v7)
          {
            if (v6[3])
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, v6[4]);
              v6[3] = 0;
              v6[4] = 0;
            }
            v6[2] = 0;
          }
          v8 = *(v6 - 1);
          if (v8)
          {
            if (*v6)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, v6[1]);
              *v6 = 0;
              v6[1] = 0;
            }
            *(v6 - 1) = 0;
          }
          v9 = *(v6 - 4);
          if (v9)
          {
            if (*(v6 - 3))
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *(v6 - 2));
              *(v6 - 3) = 0;
              *(v6 - 2) = 0;
            }
            *(v6 - 4) = 0;
          }
          v6 += 18;
          v5 -= 144;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetBlendShapeData>::deinit(uint64_t a1)
{
  uint64_t result;
  re::StringID *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 56 * v4;
        do
        {
          re::FixedArray<re::BlendShapeDefinition>::deinit((_QWORD *)v3 + 2);
          re::StringID::destroyString(v3);
          v3 = (re::StringID *)((char *)v3 + 56);
          v5 -= 56;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::StringID **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::FixedArray<re::BlendShapeDefinition>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  re::BlendShapeDefinition *v4;
  uint64_t v5;
  uint64_t v6;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = (re::BlendShapeDefinition *)result[2];
      v5 = 136 * v2;
      do
      {
        re::BlendShapeDefinition::~BlendShapeDefinition(v4);
        v4 = (re::BlendShapeDefinition *)(v6 + 136);
        v5 -= 136;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

void re::BlendShapeDefinition::~BlendShapeDefinition(re::BlendShapeDefinition *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *((_QWORD *)this + 14);
  if (v2)
  {
    if (*((_QWORD *)this + 15))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 16));
      *((_QWORD *)this + 15) = 0;
      *((_QWORD *)this + 16) = 0;
    }
    *((_QWORD *)this + 14) = 0;
  }
  v3 = *((_QWORD *)this + 11);
  if (v3)
  {
    if (*((_QWORD *)this + 12))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 13));
      *((_QWORD *)this + 12) = 0;
      *((_QWORD *)this + 13) = 0;
    }
    *((_QWORD *)this + 11) = 0;
  }
  v4 = *((_QWORD *)this + 8);
  if (v4)
  {
    if (*((_QWORD *)this + 9))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 10));
      *((_QWORD *)this + 9) = 0;
      *((_QWORD *)this + 10) = 0;
    }
    *((_QWORD *)this + 8) = 0;
  }
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    if (*((_QWORD *)this + 6))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 7));
      *((_QWORD *)this + 6) = 0;
      *((_QWORD *)this + 7) = 0;
    }
    *((_QWORD *)this + 5) = 0;
  }
  v6 = *((_QWORD *)this + 2);
  if (v6)
  {
    if (*((_QWORD *)this + 3))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)this + 4));
      *((_QWORD *)this + 3) = 0;
      *((_QWORD *)this + 4) = 0;
    }
    *((_QWORD *)this + 2) = 0;
  }
  re::StringID::destroyString(this);
}

uint64_t re::DynamicArray<re::GeomMesh>::deinit(uint64_t a1, re::GeomAttribute *a2)
{
  uint64_t result;
  re::GeomMesh *v4;
  uint64_t v5;
  uint64_t v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v4 = *(re::GeomMesh **)(a1 + 32);
    if (v4)
    {
      v5 = *(_QWORD *)(a1 + 16);
      if (v5)
      {
        v6 = 736 * v5;
        do
        {
          re::GeomMesh::~GeomMesh(v4, a2);
          v4 = (re::GeomMesh *)((char *)v4 + 736);
          v6 -= 736;
        }
        while (v6);
        result = *(_QWORD *)a1;
        v4 = *(re::GeomMesh **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::GeomMesh *))(*(_QWORD *)result + 40))(result, v4);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::GeomModel>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::GeomModel>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::GeomModel>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::GeomModelWithLods>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::GeomModelWithLods>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::GeomModelWithLods>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::GeomInstance>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::RigSplineIKJoint>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::RigSplineIKJoint>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

double re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::deinit(uint64_t *a1, re::GeomAttribute *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t i;
  uint64_t v7;
  uint64_t v8;
  int v9;
  const void *v10;
  double result;

  v3 = *a1;
  if (v3)
  {
    v4 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v4)
    {
      v5 = 0;
      for (i = 0; i < v4; ++i)
      {
        v7 = a1[2];
        v8 = v7 + v5;
        v9 = *(_DWORD *)(v7 + v5 + 8);
        if (v9 < 0)
        {
          *(_DWORD *)(v8 + 8) = v9 & 0x7FFFFFFF;
          v10 = *(const void **)(v8 + 16);
          if (v10)
          {
            CFRelease(v10);
            *(_QWORD *)(v8 + 16) = 0;
          }
          re::GeomMesh::~GeomMesh((re::GeomMesh *)(v7 + v5 + 48), a2);
          v4 = *((unsigned int *)a1 + 8);
        }
        v5 += 816;
      }
      v3 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::ObjectHelper::move<re::GeomModelWithLods>(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double result;

  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 24) = a1[3];
  v3 = a1[1];
  *(_QWORD *)a2 = *a1;
  *a1 = 0;
  v4 = a1[2];
  a1[3] = 0;
  v6 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = v3;
  *(_QWORD *)(a2 + 16) = v4;
  a1[1] = v6;
  a1[2] = v5;
  *(_QWORD *)(a2 + 64) = 0;
  *(_DWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  v7 = (uint64_t)(a1 + 4);
  v8 = a1[5];
  *(_QWORD *)(a2 + 32) = a1[4];
  a1[4] = 0;
  *(_QWORD *)(a2 + 40) = v8;
  a1[5] = 0;
  v9 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = a1[6];
  a1[6] = v9;
  v10 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = a1[8];
  a1[8] = v10;
  ++*((_DWORD *)a1 + 14);
  LODWORD(v10) = *(_DWORD *)(a2 + 56) + 1;
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_DWORD *)(a2 + 96) = 0;
  v12 = a1 + 9;
  v11 = a1[9];
  *(_DWORD *)(a2 + 56) = v10;
  v13 = a1[10];
  *(_QWORD *)(a2 + 72) = v11;
  a1[9] = 0;
  *(_QWORD *)(a2 + 80) = v13;
  a1[10] = 0;
  v14 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = a1[11];
  a1[11] = v14;
  v15 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = a1[13];
  a1[13] = v15;
  ++*((_DWORD *)a1 + 24);
  ++*(_DWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 144) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  *(_DWORD *)(a2 + 136) = 0;
  v16 = a1 + 14;
  *(_QWORD *)(a2 + 112) = a1[14];
  a1[14] = 0;
  v17 = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(a2 + 144) = a1[18];
  v18 = a1[14];
  *(_QWORD *)(a2 + 120) = v16[1];
  v16[1] = 0;
  v19 = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 128) = v16[2];
  ++*((_DWORD *)v16 + 6);
  ++*(_DWORD *)(a2 + 136);
  v16[2] = v19;
  v16[4] = v17;
  if (v18)
  {
    if (v17)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v18 + 40))(v18, v17);
    a1[18] = 0;
    v16[1] = 0;
    v16[2] = 0;
    *v16 = 0;
    ++*((_DWORD *)a1 + 34);
  }
  if (*v12)
  {
    if (a1[13])
      (*(void (**)(_QWORD))(*(_QWORD *)*v12 + 40))(*v12);
    a1[13] = 0;
    v12[1] = 0;
    v12[2] = 0;
    *v12 = 0;
    ++*((_DWORD *)a1 + 24);
  }
  re::DynamicArray<re::GeomModel>::deinit(v7);
  if (*a1)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

uint64_t re::Result<re::MeshAssetData,re::DetailedError>::~Result(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _OWORD *v4;

  if (*(_BYTE *)a1)
  {
    v2 = *(_QWORD *)(a1 + 128);
    if (v2)
    {
      if (*(_QWORD *)(a1 + 160))
        (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
      *(_QWORD *)(a1 + 160) = 0;
      *(_QWORD *)(a1 + 136) = 0;
      *(_QWORD *)(a1 + 144) = 0;
      *(_QWORD *)(a1 + 128) = 0;
      ++*(_DWORD *)(a1 + 152);
    }
    re::DynamicArray<re::MeshAssetSkeleton>::deinit(a1 + 88);
    re::DynamicArray<re::MeshAssetInstance>::deinit(a1 + 48);
    re::DynamicArray<re::MeshAssetModel>::deinit(a1 + 8);
  }
  else
  {
    v4 = (_OWORD *)(a1 + 24);
    v3 = *(_QWORD *)(a1 + 24);
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 32) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 40));
      *v4 = 0u;
      *(_OWORD *)(a1 + 40) = 0u;
    }
  }
  return a1;
}

void Tube::~Tube(Tube *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<TubeDescriptorParameters,re::GeomBuildTubeOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t `anonymous namespace'::PrimitiveProvider<TubeDescriptorParameters,re::GeomBuildTubeOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Introspectable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  __int128 v18;
  __int128 v19;
  re *MeshAssetDataWithGeomMeshArray;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  void (***v24)(_QWORD);
  uint64_t v25;
  uint64_t *v26;
  re::MeshAsset *v27;
  uint64_t *v28;
  uint64_t v29;
  _anonymous_namespace_ *v30;
  const char *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  re::GeomAttribute *v40;
  double v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  _BYTE v46[16];
  _QWORD v47[2];
  uint64_t v48;
  int v49;
  re::GeomAttribute *v50;
  _QWORD v51[2];
  uint64_t v52;
  int v53;
  re::GeomMesh *v54;
  int v55;
  uint64_t v56;
  int v57;
  __int16 v58;
  char v59;
  char v60;
  char v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  int v67;
  const char *v68;
  uint64_t v69;
  _BYTE v70[20];
  __int128 v71;
  __int128 v72;
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v11 = *(_QWORD *)(a2 + 16);
    else
      v11 = a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v62, v10, v11);
    goto LABEL_17;
  }
  v56 = 0x3EC000003F800000;
  v55 = 65544;
  v57 = 1056964608;
  v58 = 257;
  v59 = 0;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<TubeDescriptorParameters>((re::AssetLoadDescriptor *)a2, (uint64_t **)&v55);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    v18 = v62;
    v19 = v63;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  v54 = 0;
  v51[1] = 0;
  v52 = 0;
  v50 = 0;
  v51[0] = 0;
  v53 = 0;
  v47[1] = 0;
  v48 = 0;
  v47[0] = 0;
  v49 = 0;
  if (v60)
  {
    re::buildTube((uint64_t)v51, (unsigned __int16 *)&v55);
    v13 = v52;
    re::DynamicArray<float>::resize((uint64_t)v47, v52);
    if (v13)
    {
      v14 = 0;
      v15 = v48;
      v16 = (uint64_t)v50;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14)
          goto LABEL_21;
      }
      *(_QWORD *)&v42 = 0;
      v65 = 0u;
      v66 = 0u;
      v63 = 0u;
      v64 = 0u;
      v62 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v67 = 136315906;
      v68 = "operator[]";
      v69 = 0x800000003150400;
      *(_QWORD *)v70 = v15;
      *(_WORD *)&v70[8] = 2048;
      *(_QWORD *)&v70[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      *(_QWORD *)&v42 = 0;
      v65 = 0u;
      v66 = 0u;
      v63 = 0u;
      v64 = 0u;
      v62 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v67 = 136315906;
      v68 = "operator[]";
      v69 = 0x800000003150400;
      *(_QWORD *)v70 = 0;
      *(_WORD *)&v70[8] = 2048;
      *(_QWORD *)&v70[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v51, 1uLL);
    LODWORD(v62) = 0;
    re::DynamicArray<unsigned int>::resize(v47, 1uLL, &v62);
    if (!v52)
      goto LABEL_37;
    re::buildTube((uint64_t)v54, (unsigned __int16 *)&v55);
  }
LABEL_21:
  v67 = 16842752;
  LOBYTE(v68) = 1;
  *(_DWORD *)((char *)&v68 + 1) = 0;
  BYTE5(v68) = 0;
  v70[0] = 0;
  v72 = 0u;
  *(_OWORD *)&v70[4] = 0u;
  v71 = 0u;
  DWORD1(v72) = 0x7FFFFFFF;
  BYTE6(v68) = v61;
  v69 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v54, v52, (uint64_t)v50, v48, 0, &v67, (uint64_t)&v62);
  v21 = v62;
  v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22[2] + 32))(v22[2], 960, 8);
  v24 = (void (***)(_QWORD))v23;
  if (v21)
  {
    v23 = re::MeshAsset::MeshAsset(v23, (uint64_t)&v62 + 8);
  }
  else
  {
    *(_QWORD *)v23 = &off_24ED30A60;
    *(_QWORD *)(v23 + 8) = 0;
    *(_QWORD *)(v23 + 16) = 0;
    *(_QWORD *)(v23 + 24) = 0;
    *(_DWORD *)(v23 + 32) = 0;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_DWORD *)(v23 + 72) = 0;
    *(_OWORD *)(v23 + 80) = 0u;
    *(_OWORD *)(v23 + 96) = 0u;
    *(_DWORD *)(v23 + 112) = 0;
    *(_OWORD *)(v23 + 120) = 0u;
    *(_OWORD *)(v23 + 136) = 0u;
    *(_DWORD *)(v23 + 152) = 0;
    *(_DWORD *)(v23 + 424) = 0;
    *(_OWORD *)(v23 + 392) = 0u;
    *(_OWORD *)(v23 + 408) = 0u;
    *(_OWORD *)(v23 + 484) = 0u;
    *(_OWORD *)(v23 + 472) = 0u;
    *(_OWORD *)(v23 + 456) = 0u;
    *(_DWORD *)(v23 + 192) = 0;
    *(_OWORD *)(v23 + 160) = 0u;
    *(_OWORD *)(v23 + 176) = 0u;
    *(_OWORD *)(v23 + 200) = 0u;
    *(_OWORD *)(v23 + 216) = 0u;
    *(_DWORD *)(v23 + 232) = 0;
    *(_OWORD *)(v23 + 240) = 0u;
    *(_OWORD *)(v23 + 256) = 0u;
    *(_DWORD *)(v23 + 272) = 0;
    *(_OWORD *)(v23 + 280) = 0u;
    *(_OWORD *)(v23 + 296) = 0u;
    *(_OWORD *)(v23 + 312) = 0u;
    *(_OWORD *)(v23 + 328) = 0u;
    *(_OWORD *)(v23 + 344) = 0u;
    *(_OWORD *)(v23 + 360) = 0u;
    *(_OWORD *)(v23 + 372) = 0u;
    *(_DWORD *)(v23 + 448) = 0;
    *(_QWORD *)(v23 + 432) = 0;
    *(_QWORD *)(v23 + 440) = 0;
    *(_QWORD *)(v23 + 500) = 0x7FFFFFFFLL;
    *(_DWORD *)(v23 + 544) = 0;
    *(_OWORD *)(v23 + 512) = 0u;
    *(_OWORD *)(v23 + 528) = 0u;
    *(_QWORD *)(v23 + 548) = 0x7FFFFFFFLL;
    *(_OWORD *)(v23 + 905) = 0u;
    *(_OWORD *)(v23 + 880) = 0u;
    *(_OWORD *)(v23 + 896) = 0u;
    *(_OWORD *)(v23 + 848) = 0u;
    *(_OWORD *)(v23 + 864) = 0u;
    *(_OWORD *)(v23 + 816) = 0u;
    *(_OWORD *)(v23 + 832) = 0u;
    *(_OWORD *)(v23 + 784) = 0u;
    *(_OWORD *)(v23 + 800) = 0u;
    *(_OWORD *)(v23 + 752) = 0u;
    *(_OWORD *)(v23 + 768) = 0u;
    *(_OWORD *)(v23 + 720) = 0u;
    *(_OWORD *)(v23 + 736) = 0u;
    *(_OWORD *)(v23 + 688) = 0u;
    *(_OWORD *)(v23 + 704) = 0u;
    *(_OWORD *)(v23 + 656) = 0u;
    *(_OWORD *)(v23 + 672) = 0u;
    *(_OWORD *)(v23 + 624) = 0u;
    *(_OWORD *)(v23 + 640) = 0u;
    *(_OWORD *)(v23 + 592) = 0u;
    *(_OWORD *)(v23 + 608) = 0u;
    *(_OWORD *)(v23 + 560) = 0u;
    *(_OWORD *)(v23 + 576) = 0u;
    *(_DWORD *)(v23 + 924) = 2;
    *(_QWORD *)(v23 + 928) = 0;
    *(_QWORD *)(v23 + 944) = 0;
    *(_QWORD *)(v23 + 936) = 0;
    *(_BYTE *)(v23 + 952) = 0;
  }
  v25 = a1[3];
  v26 = re::MeshAsset::assetType((re::MeshAsset *)v23);
  v27 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v25, (unint64_t)v26);
  v28 = re::MeshAsset::assetType(v27);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v46, 2056, a3, (const char *)*v28);
  v29 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v27 + 24))(v27, v24, 0, 0);
  if ((v29 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
    if ((*(_BYTE *)(a2 + 120) & 1) != 0)
      v31 = *(const char **)(a2 + 128);
    else
      v31 = (const char *)(a2 + 121);
    *(_QWORD *)&v45 = v24;
    BYTE8(v45) = 0;
    v36 = v42;
    v37 = v43;
    v38 = v44;
    *(_BYTE *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v45;
    *(_BYTE *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(_QWORD *)(a4 + 24) = v37;
    *(_QWORD *)(a4 + 32) = v38;
  }
  else
  {
    if (v24)
    {
      v32 = re::globalAllocators((re *)v29)[2];
      (**v24)(v24);
      v29 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v32 + 40))(v32, v24);
    }
    v33 = v42;
    v34 = v43;
    v35 = v44;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(_QWORD *)(a4 + 24) = v34;
    *(_QWORD *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v62);
  v41 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v70[4], v39);
  if (v47[0])
  {
    v40 = v50;
    if (v50)
      (*(void (**)(double))(*(_QWORD *)v47[0] + 40))(v41);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v51, v40);
}

__n128 `anonymous namespace'::PrimitiveProvider<TubeDescriptorParameters,re::GeomBuildTubeOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *`anonymous namespace'::PrimitiveProvider<TubeDescriptorParameters,re::GeomBuildTubeOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v5;
  const char *v6;
  re::DynamicString *result;
  uint64_t v8;
  char v9;
  _OWORD v10[2];
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  __int16 v17;
  char v18;
  char v19;
  char v20;

  v14 = 65544;
  v15 = 0x3EC000003F800000;
  v16 = 1056964608;
  v17 = 257;
  v18 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<TubeDescriptorParameters>(a2, (uint64_t **)&v14))
  {
    if (v19)
      v5 = " split";
    else
      v5 = "";
    if (v20)
      v6 = "";
    else
      v6 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(_QWORD *)a1 + 120))(&v8, a1, &v14);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(_QWORD *)&v10[0])
    {
      if ((BYTE8(v10[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    result = (re::DynamicString *)v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(_QWORD *)v11 + 40))(v11, v13);
    }
  }
  else
  {
    v11 = "<mangled>";
    v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Tube::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "";
  if (*((_BYTE *)a1 + 16))
    v3 = "";
  else
    v3 = " noUV";
  if (*((_BYTE *)a1 + 17))
    v4 = "";
  else
    v4 = " noNorm";
  if (*((_BYTE *)a1 + 18))
    v2 = " merge";
  return re::DynamicString::format((re::DynamicString *)"%f/%d; %f:%f/%d;%s%s%s",
           a2,
           *((float *)a1 + 1),
           a1[1],
           *((float *)a1 + 2),
           *((float *)a1 + 3),
           *a1,
           v3,
           v4,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<TubeDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FC9F8);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FC9F8);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FC9F0 = re::internal::getOrCreateInfo((re::internal *)"TubeDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_TubeDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_TubeDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC8F8, 0);
      __cxa_guard_release(&qword_2540FC9F8);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FC9F0, v2, 0);
}

void Plane::~Plane(Plane *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<PlaneDescriptorParameters,re::GeomBuildPlaneOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t `anonymous namespace'::PrimitiveProvider<PlaneDescriptorParameters,re::GeomBuildPlaneOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Introspectable;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  __int128 v23;
  __int128 v24;
  re *MeshAssetDataWithGeomMeshArray;
  int v26;
  uint64_t *v27;
  uint64_t v28;
  void (***v29)(_QWORD);
  uint64_t v30;
  uint64_t *v31;
  re::MeshAsset *v32;
  uint64_t *v33;
  uint64_t v34;
  _anonymous_namespace_ *v35;
  const char *v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  double v44;
  re::GeomAttribute *v45;
  double v46;
  __int128 v47;
  uint64_t v48;
  uint64_t v49;
  __int128 v50;
  _BYTE v51[16];
  _QWORD v52[2];
  uint64_t v53;
  int v54;
  re::GeomAttribute *v55;
  _QWORD v56[2];
  uint64_t v57;
  int v58;
  re *v59;
  float32x2_t v60[2];
  int v61;
  __int16 v62;
  int v63;
  char v64;
  char v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  int v71;
  const char *v72;
  uint64_t v73;
  _BYTE v74[20];
  __int128 v75;
  __int128 v76;
  uint64_t v77;

  v77 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v11 = *(_QWORD *)(a2 + 16);
    else
      v11 = a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v66, v10, v11);
    goto LABEL_17;
  }
  v60[0].i32[0] = 65537;
  v60[0].i16[2] = 0;
  __asm { FMOV            V0.2S, #1.0 }
  v60[1] = _D0;
  v61 = 0;
  v62 = 257;
  v63 = 2;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<PlaneDescriptorParameters>((re::AssetLoadDescriptor *)a2, (uint64_t **)v60);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    v23 = v66;
    v24 = v67;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v23;
    *(_OWORD *)(a4 + 24) = v24;
    return result;
  }
  v59 = 0;
  v56[1] = 0;
  v57 = 0;
  v55 = 0;
  v56[0] = 0;
  v58 = 0;
  v52[1] = 0;
  v53 = 0;
  v52[0] = 0;
  v54 = 0;
  if (v64)
  {
    re::buildPlane((re::GeomMesh *)v56, v60);
    v18 = v57;
    re::DynamicArray<float>::resize((uint64_t)v52, v57);
    if (v18)
    {
      v19 = 0;
      v20 = v53;
      v21 = (uint64_t)v55;
      while (v20 != v19)
      {
        *(_DWORD *)(v21 + 4 * v19) = v19;
        if (v18 == ++v19)
          goto LABEL_21;
      }
      *(_QWORD *)&v47 = 0;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v66 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v71 = 136315906;
      v72 = "operator[]";
      v73 = 0x800000003150400;
      *(_QWORD *)v74 = v20;
      *(_WORD *)&v74[8] = 2048;
      *(_QWORD *)&v74[10] = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      *(_QWORD *)&v47 = 0;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v66 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v71 = 136315906;
      v72 = "operator[]";
      v73 = 0x800000003150400;
      *(_QWORD *)v74 = 0;
      *(_WORD *)&v74[8] = 2048;
      *(_QWORD *)&v74[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v56, 1uLL);
    LODWORD(v66) = 0;
    re::DynamicArray<unsigned int>::resize(v52, 1uLL, &v66);
    if (!v57)
      goto LABEL_37;
    re::buildPlane(v59, v60);
  }
LABEL_21:
  v71 = 16842752;
  LOBYTE(v72) = 1;
  *(_DWORD *)((char *)&v72 + 1) = 0;
  BYTE5(v72) = 0;
  v74[0] = 0;
  v76 = 0u;
  *(_OWORD *)&v74[4] = 0u;
  v75 = 0u;
  DWORD1(v76) = 0x7FFFFFFF;
  BYTE6(v72) = v65;
  v73 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v59, v57, (uint64_t)v55, v53, 0, &v71, (uint64_t)&v66);
  v26 = v66;
  v27 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  v28 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v27[2] + 32))(v27[2], 960, 8);
  v29 = (void (***)(_QWORD))v28;
  if (v26)
  {
    v28 = re::MeshAsset::MeshAsset(v28, (uint64_t)&v66 + 8);
  }
  else
  {
    *(_QWORD *)v28 = &off_24ED30A60;
    *(_QWORD *)(v28 + 8) = 0;
    *(_QWORD *)(v28 + 16) = 0;
    *(_QWORD *)(v28 + 24) = 0;
    *(_DWORD *)(v28 + 32) = 0;
    *(_OWORD *)(v28 + 40) = 0u;
    *(_OWORD *)(v28 + 56) = 0u;
    *(_DWORD *)(v28 + 72) = 0;
    *(_OWORD *)(v28 + 80) = 0u;
    *(_OWORD *)(v28 + 96) = 0u;
    *(_DWORD *)(v28 + 112) = 0;
    *(_OWORD *)(v28 + 120) = 0u;
    *(_OWORD *)(v28 + 136) = 0u;
    *(_DWORD *)(v28 + 152) = 0;
    *(_DWORD *)(v28 + 424) = 0;
    *(_OWORD *)(v28 + 392) = 0u;
    *(_OWORD *)(v28 + 408) = 0u;
    *(_OWORD *)(v28 + 484) = 0u;
    *(_OWORD *)(v28 + 472) = 0u;
    *(_OWORD *)(v28 + 456) = 0u;
    *(_DWORD *)(v28 + 192) = 0;
    *(_OWORD *)(v28 + 160) = 0u;
    *(_OWORD *)(v28 + 176) = 0u;
    *(_OWORD *)(v28 + 200) = 0u;
    *(_OWORD *)(v28 + 216) = 0u;
    *(_DWORD *)(v28 + 232) = 0;
    *(_OWORD *)(v28 + 240) = 0u;
    *(_OWORD *)(v28 + 256) = 0u;
    *(_DWORD *)(v28 + 272) = 0;
    *(_OWORD *)(v28 + 280) = 0u;
    *(_OWORD *)(v28 + 296) = 0u;
    *(_OWORD *)(v28 + 312) = 0u;
    *(_OWORD *)(v28 + 328) = 0u;
    *(_OWORD *)(v28 + 344) = 0u;
    *(_OWORD *)(v28 + 360) = 0u;
    *(_OWORD *)(v28 + 372) = 0u;
    *(_DWORD *)(v28 + 448) = 0;
    *(_QWORD *)(v28 + 432) = 0;
    *(_QWORD *)(v28 + 440) = 0;
    *(_QWORD *)(v28 + 500) = 0x7FFFFFFFLL;
    *(_DWORD *)(v28 + 544) = 0;
    *(_OWORD *)(v28 + 512) = 0u;
    *(_OWORD *)(v28 + 528) = 0u;
    *(_QWORD *)(v28 + 548) = 0x7FFFFFFFLL;
    *(_OWORD *)(v28 + 905) = 0u;
    *(_OWORD *)(v28 + 880) = 0u;
    *(_OWORD *)(v28 + 896) = 0u;
    *(_OWORD *)(v28 + 848) = 0u;
    *(_OWORD *)(v28 + 864) = 0u;
    *(_OWORD *)(v28 + 816) = 0u;
    *(_OWORD *)(v28 + 832) = 0u;
    *(_OWORD *)(v28 + 784) = 0u;
    *(_OWORD *)(v28 + 800) = 0u;
    *(_OWORD *)(v28 + 752) = 0u;
    *(_OWORD *)(v28 + 768) = 0u;
    *(_OWORD *)(v28 + 720) = 0u;
    *(_OWORD *)(v28 + 736) = 0u;
    *(_OWORD *)(v28 + 688) = 0u;
    *(_OWORD *)(v28 + 704) = 0u;
    *(_OWORD *)(v28 + 656) = 0u;
    *(_OWORD *)(v28 + 672) = 0u;
    *(_OWORD *)(v28 + 624) = 0u;
    *(_OWORD *)(v28 + 640) = 0u;
    *(_OWORD *)(v28 + 592) = 0u;
    *(_OWORD *)(v28 + 608) = 0u;
    *(_OWORD *)(v28 + 560) = 0u;
    *(_OWORD *)(v28 + 576) = 0u;
    *(_DWORD *)(v28 + 924) = 2;
    *(_QWORD *)(v28 + 928) = 0;
    *(_QWORD *)(v28 + 944) = 0;
    *(_QWORD *)(v28 + 936) = 0;
    *(_BYTE *)(v28 + 952) = 0;
  }
  v30 = a1[3];
  v31 = re::MeshAsset::assetType((re::MeshAsset *)v28);
  v32 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v30, (unint64_t)v31);
  v33 = re::MeshAsset::assetType(v32);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v51, 2056, a3, (const char *)*v33);
  v34 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v32 + 24))(v32, v29, 0, 0);
  if ((v34 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v51);
    if ((*(_BYTE *)(a2 + 120) & 1) != 0)
      v36 = *(const char **)(a2 + 128);
    else
      v36 = (const char *)(a2 + 121);
    *(_QWORD *)&v50 = v29;
    BYTE8(v50) = 0;
    v41 = v47;
    v42 = v48;
    v43 = v49;
    *(_BYTE *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v50;
    *(_BYTE *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v41;
    *(_QWORD *)(a4 + 24) = v42;
    *(_QWORD *)(a4 + 32) = v43;
  }
  else
  {
    if (v29)
    {
      v37 = re::globalAllocators((re *)v34)[2];
      (**v29)(v29);
      v34 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v37 + 40))(v37, v29);
    }
    v38 = v47;
    v39 = v48;
    v40 = v49;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v38;
    *(_QWORD *)(a4 + 24) = v39;
    *(_QWORD *)(a4 + 32) = v40;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v51);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v66);
  v46 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v74[4], v44);
  if (v52[0])
  {
    v45 = v55;
    if (v55)
      (*(void (**)(double))(*(_QWORD *)v52[0] + 40))(v46);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v56, v45);
}

__n128 `anonymous namespace'::PrimitiveProvider<PlaneDescriptorParameters,re::GeomBuildPlaneOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *`anonymous namespace'::PrimitiveProvider<PlaneDescriptorParameters,re::GeomBuildPlaneOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v10;
  const char *v11;
  re::DynamicString *result;
  uint64_t v13;
  char v14;
  _OWORD v15[2];
  const char *v16;
  uint64_t v17;
  uint64_t *v18[2];
  int v19;
  __int16 v20;
  int v21;
  char v22;
  char v23;

  LODWORD(v18[0]) = 65537;
  WORD2(v18[0]) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  v18[1] = _D0;
  v19 = 0;
  v20 = 257;
  v21 = 2;
  if (re::AssetLoadDescriptor::getIntrospectableData<PlaneDescriptorParameters>(a2, v18))
  {
    if (v22)
      v10 = " split";
    else
      v10 = "";
    if (v23)
      v11 = "";
    else
      v11 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v16, v10, v11);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t **))(*(_QWORD *)a1 + 120))(&v13, a1, v18);
    re::DynamicString::operator+((re::DynamicString *)&v13, (uint64_t)&v16, (re::DynamicString *)v15);
    re::DynamicString::operator=(a3, (re::DynamicString *)v15);
    if (*(_QWORD *)&v15[0])
    {
      if ((BYTE8(v15[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v15[0] + 40))();
      memset(v15, 0, sizeof(v15));
    }
    if (v13 && (v14 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v13 + 40))();
    result = (re::DynamicString *)v16;
    if (v16)
    {
      if ((v17 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v16 + 40))();
    }
  }
  else
  {
    v16 = "<mangled>";
    v17 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v16);
  }
  return result;
}

uint64_t Plane::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  const char *v2;
  const char *v3;

  v2 = "";
  if (*((_BYTE *)a1 + 20))
    v3 = "";
  else
    v3 = " noUV";
  if (!*((_BYTE *)a1 + 21))
    v2 = " noNorm";
  return re::DynamicString::format((re::DynamicString *)"%fx%f; %dx%d; r=%f/%d;%s%s",
           a2,
           *((float *)a1 + 2),
           *((float *)a1 + 3),
           *a1,
           a1[1],
           *((float *)a1 + 4),
           a1[2],
           v3,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<PlaneDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FCA08);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FCA08);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FCA00 = re::internal::getOrCreateInfo((re::internal *)"PlaneDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_PlaneDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_PlaneDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC910, 0);
      __cxa_guard_release(&qword_2540FCA08);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FCA00, v2, 0);
}

void Cylinder::~Cylinder(Cylinder *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<CylinderDescriptorParameters,re::GeomBuildCylinderOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t `anonymous namespace'::PrimitiveProvider<CylinderDescriptorParameters,re::GeomBuildCylinderOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Introspectable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  __int128 v18;
  __int128 v19;
  re *MeshAssetDataWithGeomMeshArray;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  void (***v24)(_QWORD);
  uint64_t v25;
  uint64_t *v26;
  re::MeshAsset *v27;
  uint64_t *v28;
  uint64_t v29;
  _anonymous_namespace_ *v30;
  const char *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  re::GeomAttribute *v40;
  double v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  _BYTE v46[16];
  _QWORD v47[2];
  uint64_t v48;
  int v49;
  re::GeomAttribute *v50;
  _QWORD v51[2];
  uint64_t v52;
  int v53;
  re::GeomMesh *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  char v58;
  char v59;
  char v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  int v66;
  const char *v67;
  uint64_t v68;
  _BYTE v69[20];
  __int128 v70;
  __int128 v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v11 = *(_QWORD *)(a2 + 16);
    else
      v11 = a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v61, v10, v11);
    goto LABEL_17;
  }
  v55 = 65544;
  v56 = 0x3F0000003F800000;
  v57 = 0x10101013F000000;
  v58 = 0;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<CylinderDescriptorParameters>((re::AssetLoadDescriptor *)a2, (uint64_t **)&v55);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    v18 = v61;
    v19 = v62;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  v54 = 0;
  v51[1] = 0;
  v52 = 0;
  v50 = 0;
  v51[0] = 0;
  v53 = 0;
  v47[1] = 0;
  v48 = 0;
  v47[0] = 0;
  v49 = 0;
  if (v59)
  {
    re::buildCylinder((uint64_t)v51, (unsigned __int16 *)&v55);
    v13 = v52;
    re::DynamicArray<float>::resize((uint64_t)v47, v52);
    if (v13)
    {
      v14 = 0;
      v15 = v48;
      v16 = (uint64_t)v50;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14)
          goto LABEL_21;
      }
      *(_QWORD *)&v42 = 0;
      v65 = 0u;
      v64 = 0u;
      v63 = 0u;
      v62 = 0u;
      v61 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v66 = 136315906;
      v67 = "operator[]";
      v68 = 0x800000003150400;
      *(_QWORD *)v69 = v15;
      *(_WORD *)&v69[8] = 2048;
      *(_QWORD *)&v69[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      *(_QWORD *)&v42 = 0;
      v65 = 0u;
      v64 = 0u;
      v63 = 0u;
      v62 = 0u;
      v61 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v66 = 136315906;
      v67 = "operator[]";
      v68 = 0x800000003150400;
      *(_QWORD *)v69 = 0;
      *(_WORD *)&v69[8] = 2048;
      *(_QWORD *)&v69[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v51, 1uLL);
    LODWORD(v61) = 0;
    re::DynamicArray<unsigned int>::resize(v47, 1uLL, &v61);
    if (!v52)
      goto LABEL_37;
    re::buildCylinder((uint64_t)v54, (unsigned __int16 *)&v55);
  }
LABEL_21:
  v66 = 16842752;
  LOBYTE(v67) = 1;
  *(_DWORD *)((char *)&v67 + 1) = 0;
  BYTE5(v67) = 0;
  v69[0] = 0;
  v71 = 0u;
  *(_OWORD *)&v69[4] = 0u;
  v70 = 0u;
  DWORD1(v71) = 0x7FFFFFFF;
  BYTE6(v67) = v60;
  v68 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v54, v52, (uint64_t)v50, v48, 0, &v66, (uint64_t)&v61);
  v21 = v61;
  v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22[2] + 32))(v22[2], 960, 8);
  v24 = (void (***)(_QWORD))v23;
  if (v21)
  {
    v23 = re::MeshAsset::MeshAsset(v23, (uint64_t)&v61 + 8);
  }
  else
  {
    *(_QWORD *)v23 = &off_24ED30A60;
    *(_QWORD *)(v23 + 8) = 0;
    *(_QWORD *)(v23 + 16) = 0;
    *(_QWORD *)(v23 + 24) = 0;
    *(_DWORD *)(v23 + 32) = 0;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_DWORD *)(v23 + 72) = 0;
    *(_OWORD *)(v23 + 80) = 0u;
    *(_OWORD *)(v23 + 96) = 0u;
    *(_DWORD *)(v23 + 112) = 0;
    *(_OWORD *)(v23 + 120) = 0u;
    *(_OWORD *)(v23 + 136) = 0u;
    *(_DWORD *)(v23 + 152) = 0;
    *(_DWORD *)(v23 + 424) = 0;
    *(_OWORD *)(v23 + 392) = 0u;
    *(_OWORD *)(v23 + 408) = 0u;
    *(_OWORD *)(v23 + 484) = 0u;
    *(_OWORD *)(v23 + 472) = 0u;
    *(_OWORD *)(v23 + 456) = 0u;
    *(_DWORD *)(v23 + 192) = 0;
    *(_OWORD *)(v23 + 160) = 0u;
    *(_OWORD *)(v23 + 176) = 0u;
    *(_OWORD *)(v23 + 200) = 0u;
    *(_OWORD *)(v23 + 216) = 0u;
    *(_DWORD *)(v23 + 232) = 0;
    *(_OWORD *)(v23 + 240) = 0u;
    *(_OWORD *)(v23 + 256) = 0u;
    *(_DWORD *)(v23 + 272) = 0;
    *(_OWORD *)(v23 + 280) = 0u;
    *(_OWORD *)(v23 + 296) = 0u;
    *(_OWORD *)(v23 + 312) = 0u;
    *(_OWORD *)(v23 + 328) = 0u;
    *(_OWORD *)(v23 + 344) = 0u;
    *(_OWORD *)(v23 + 360) = 0u;
    *(_OWORD *)(v23 + 372) = 0u;
    *(_DWORD *)(v23 + 448) = 0;
    *(_QWORD *)(v23 + 432) = 0;
    *(_QWORD *)(v23 + 440) = 0;
    *(_QWORD *)(v23 + 500) = 0x7FFFFFFFLL;
    *(_DWORD *)(v23 + 544) = 0;
    *(_OWORD *)(v23 + 512) = 0u;
    *(_OWORD *)(v23 + 528) = 0u;
    *(_QWORD *)(v23 + 548) = 0x7FFFFFFFLL;
    *(_OWORD *)(v23 + 905) = 0u;
    *(_OWORD *)(v23 + 880) = 0u;
    *(_OWORD *)(v23 + 896) = 0u;
    *(_OWORD *)(v23 + 848) = 0u;
    *(_OWORD *)(v23 + 864) = 0u;
    *(_OWORD *)(v23 + 816) = 0u;
    *(_OWORD *)(v23 + 832) = 0u;
    *(_OWORD *)(v23 + 784) = 0u;
    *(_OWORD *)(v23 + 800) = 0u;
    *(_OWORD *)(v23 + 752) = 0u;
    *(_OWORD *)(v23 + 768) = 0u;
    *(_OWORD *)(v23 + 720) = 0u;
    *(_OWORD *)(v23 + 736) = 0u;
    *(_OWORD *)(v23 + 688) = 0u;
    *(_OWORD *)(v23 + 704) = 0u;
    *(_OWORD *)(v23 + 656) = 0u;
    *(_OWORD *)(v23 + 672) = 0u;
    *(_OWORD *)(v23 + 624) = 0u;
    *(_OWORD *)(v23 + 640) = 0u;
    *(_OWORD *)(v23 + 592) = 0u;
    *(_OWORD *)(v23 + 608) = 0u;
    *(_OWORD *)(v23 + 560) = 0u;
    *(_OWORD *)(v23 + 576) = 0u;
    *(_DWORD *)(v23 + 924) = 2;
    *(_QWORD *)(v23 + 928) = 0;
    *(_QWORD *)(v23 + 944) = 0;
    *(_QWORD *)(v23 + 936) = 0;
    *(_BYTE *)(v23 + 952) = 0;
  }
  v25 = a1[3];
  v26 = re::MeshAsset::assetType((re::MeshAsset *)v23);
  v27 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v25, (unint64_t)v26);
  v28 = re::MeshAsset::assetType(v27);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v46, 2056, a3, (const char *)*v28);
  v29 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v27 + 24))(v27, v24, 0, 0);
  if ((v29 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
    if ((*(_BYTE *)(a2 + 120) & 1) != 0)
      v31 = *(const char **)(a2 + 128);
    else
      v31 = (const char *)(a2 + 121);
    *(_QWORD *)&v45 = v24;
    BYTE8(v45) = 0;
    v36 = v42;
    v37 = v43;
    v38 = v44;
    *(_BYTE *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v45;
    *(_BYTE *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(_QWORD *)(a4 + 24) = v37;
    *(_QWORD *)(a4 + 32) = v38;
  }
  else
  {
    if (v24)
    {
      v32 = re::globalAllocators((re *)v29)[2];
      (**v24)(v24);
      v29 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v32 + 40))(v32, v24);
    }
    v33 = v42;
    v34 = v43;
    v35 = v44;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(_QWORD *)(a4 + 24) = v34;
    *(_QWORD *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v61);
  v41 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v69[4], v39);
  if (v47[0])
  {
    v40 = v50;
    if (v50)
      (*(void (**)(double))(*(_QWORD *)v47[0] + 40))(v41);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v51, v40);
}

__n128 `anonymous namespace'::PrimitiveProvider<CylinderDescriptorParameters,re::GeomBuildCylinderOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *`anonymous namespace'::PrimitiveProvider<CylinderDescriptorParameters,re::GeomBuildCylinderOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v5;
  const char *v6;
  re::DynamicString *result;
  uint64_t v8;
  char v9;
  _OWORD v10[2];
  const char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  char v17;
  char v18;

  v13 = 65544;
  v14 = 0x3F0000003F800000;
  v15 = 0x10101013F000000;
  v16 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<CylinderDescriptorParameters>(a2, (uint64_t **)&v13))
  {
    if (v17)
      v5 = " split";
    else
      v5 = "";
    if (v18)
      v6 = "";
    else
      v6 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(_QWORD *)a1 + 120))(&v8, a1, &v13);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(_QWORD *)&v10[0])
    {
      if ((BYTE8(v10[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    result = (re::DynamicString *)v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v11 + 40))();
    }
  }
  else
  {
    v11 = "<mangled>";
    v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Cylinder::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;

  v2 = "";
  if (*((_BYTE *)a1 + 16))
    v3 = " capTop";
  else
    v3 = "";
  v4 = " capBottom";
  if (!*((_BYTE *)a1 + 16))
    v4 = "";
  if (*((_BYTE *)a1 + 18))
    v5 = "";
  else
    v5 = " noUV";
  if (*((_BYTE *)a1 + 19))
    v6 = "";
  else
    v6 = " noNorm";
  if (*((_BYTE *)a1 + 20))
    v2 = " merge";
  return re::DynamicString::format((re::DynamicString *)"%fx%f:%f; %dx%d;%s%s%s%s%s",
           a2,
           *((float *)a1 + 1),
           *((float *)a1 + 2),
           *((float *)a1 + 3),
           *a1,
           a1[1],
           v3,
           v4,
           v5,
           v6,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<CylinderDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FCA18);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FCA18);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FCA10 = re::internal::getOrCreateInfo((re::internal *)"CylinderDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_CylinderDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_CylinderDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC928, 0);
      __cxa_guard_release(&qword_2540FCA18);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FCA10, v2, 0);
}

void Tetrahedron::~Tetrahedron(Tetrahedron *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<TetrahedronDescriptorParameters,re::GeomBuildTetrahedronOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t `anonymous namespace'::PrimitiveProvider<TetrahedronDescriptorParameters,re::GeomBuildTetrahedronOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Introspectable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  __int128 v18;
  __int128 v19;
  re *MeshAssetDataWithGeomMeshArray;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  void (***v24)(_QWORD);
  uint64_t v25;
  uint64_t *v26;
  re::MeshAsset *v27;
  uint64_t *v28;
  uint64_t v29;
  _anonymous_namespace_ *v30;
  const char *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  re::GeomAttribute *v40;
  double v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  _BYTE v46[16];
  _QWORD v47[2];
  uint64_t v48;
  int v49;
  re::GeomAttribute *v50;
  _QWORD v51[2];
  uint64_t v52;
  int v53;
  re::internal *v54;
  uint64_t *v55;
  __int16 v56;
  char v57;
  char v58;
  char v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  int v65;
  const char *v66;
  uint64_t v67;
  _BYTE v68[20];
  __int128 v69;
  __int128 v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v11 = *(_QWORD *)(a2 + 16);
    else
      v11 = a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v60, v10, v11);
    goto LABEL_17;
  }
  LOWORD(v55) = 1;
  HIDWORD(v55) = 1065353216;
  v56 = 257;
  v57 = 0;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<TetrahedronDescriptorParameters>((re::AssetLoadDescriptor *)a2, &v55);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    v18 = v60;
    v19 = v61;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  v54 = 0;
  v51[1] = 0;
  v52 = 0;
  v50 = 0;
  v51[0] = 0;
  v53 = 0;
  v47[1] = 0;
  v48 = 0;
  v47[0] = 0;
  v49 = 0;
  if (v58)
  {
    re::buildTetrahedron((re::GeomMesh *)v51, (uint64_t *)&v55);
    v13 = v52;
    re::DynamicArray<float>::resize((uint64_t)v47, v52);
    if (v13)
    {
      v14 = 0;
      v15 = v48;
      v16 = (uint64_t)v50;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14)
          goto LABEL_21;
      }
      *(_QWORD *)&v42 = 0;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v60 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v65 = 136315906;
      v66 = "operator[]";
      v67 = 0x800000003150400;
      *(_QWORD *)v68 = v15;
      *(_WORD *)&v68[8] = 2048;
      *(_QWORD *)&v68[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      *(_QWORD *)&v42 = 0;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v60 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v65 = 136315906;
      v66 = "operator[]";
      v67 = 0x800000003150400;
      *(_QWORD *)v68 = 0;
      *(_WORD *)&v68[8] = 2048;
      *(_QWORD *)&v68[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v51, 1uLL);
    LODWORD(v60) = 0;
    re::DynamicArray<unsigned int>::resize(v47, 1uLL, &v60);
    if (!v52)
      goto LABEL_37;
    re::buildTetrahedron(v54, (unsigned __int16 *)&v55);
  }
LABEL_21:
  v65 = 16842752;
  LOBYTE(v66) = 1;
  *(_DWORD *)((char *)&v66 + 1) = 0;
  BYTE5(v66) = 0;
  v68[0] = 0;
  v70 = 0u;
  *(_OWORD *)&v68[4] = 0u;
  v69 = 0u;
  DWORD1(v70) = 0x7FFFFFFF;
  BYTE6(v66) = v59;
  v67 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v54, v52, (uint64_t)v50, v48, 0, &v65, (uint64_t)&v60);
  v21 = v60;
  v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22[2] + 32))(v22[2], 960, 8);
  v24 = (void (***)(_QWORD))v23;
  if (v21)
  {
    v23 = re::MeshAsset::MeshAsset(v23, (uint64_t)&v60 + 8);
  }
  else
  {
    *(_QWORD *)v23 = &off_24ED30A60;
    *(_QWORD *)(v23 + 8) = 0;
    *(_QWORD *)(v23 + 16) = 0;
    *(_QWORD *)(v23 + 24) = 0;
    *(_DWORD *)(v23 + 32) = 0;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_DWORD *)(v23 + 72) = 0;
    *(_OWORD *)(v23 + 80) = 0u;
    *(_OWORD *)(v23 + 96) = 0u;
    *(_DWORD *)(v23 + 112) = 0;
    *(_OWORD *)(v23 + 120) = 0u;
    *(_OWORD *)(v23 + 136) = 0u;
    *(_DWORD *)(v23 + 152) = 0;
    *(_DWORD *)(v23 + 424) = 0;
    *(_OWORD *)(v23 + 392) = 0u;
    *(_OWORD *)(v23 + 408) = 0u;
    *(_OWORD *)(v23 + 484) = 0u;
    *(_OWORD *)(v23 + 472) = 0u;
    *(_OWORD *)(v23 + 456) = 0u;
    *(_DWORD *)(v23 + 192) = 0;
    *(_OWORD *)(v23 + 160) = 0u;
    *(_OWORD *)(v23 + 176) = 0u;
    *(_OWORD *)(v23 + 200) = 0u;
    *(_OWORD *)(v23 + 216) = 0u;
    *(_DWORD *)(v23 + 232) = 0;
    *(_OWORD *)(v23 + 240) = 0u;
    *(_OWORD *)(v23 + 256) = 0u;
    *(_DWORD *)(v23 + 272) = 0;
    *(_OWORD *)(v23 + 280) = 0u;
    *(_OWORD *)(v23 + 296) = 0u;
    *(_OWORD *)(v23 + 312) = 0u;
    *(_OWORD *)(v23 + 328) = 0u;
    *(_OWORD *)(v23 + 344) = 0u;
    *(_OWORD *)(v23 + 360) = 0u;
    *(_OWORD *)(v23 + 372) = 0u;
    *(_DWORD *)(v23 + 448) = 0;
    *(_QWORD *)(v23 + 432) = 0;
    *(_QWORD *)(v23 + 440) = 0;
    *(_QWORD *)(v23 + 500) = 0x7FFFFFFFLL;
    *(_DWORD *)(v23 + 544) = 0;
    *(_OWORD *)(v23 + 512) = 0u;
    *(_OWORD *)(v23 + 528) = 0u;
    *(_QWORD *)(v23 + 548) = 0x7FFFFFFFLL;
    *(_OWORD *)(v23 + 905) = 0u;
    *(_OWORD *)(v23 + 880) = 0u;
    *(_OWORD *)(v23 + 896) = 0u;
    *(_OWORD *)(v23 + 848) = 0u;
    *(_OWORD *)(v23 + 864) = 0u;
    *(_OWORD *)(v23 + 816) = 0u;
    *(_OWORD *)(v23 + 832) = 0u;
    *(_OWORD *)(v23 + 784) = 0u;
    *(_OWORD *)(v23 + 800) = 0u;
    *(_OWORD *)(v23 + 752) = 0u;
    *(_OWORD *)(v23 + 768) = 0u;
    *(_OWORD *)(v23 + 720) = 0u;
    *(_OWORD *)(v23 + 736) = 0u;
    *(_OWORD *)(v23 + 688) = 0u;
    *(_OWORD *)(v23 + 704) = 0u;
    *(_OWORD *)(v23 + 656) = 0u;
    *(_OWORD *)(v23 + 672) = 0u;
    *(_OWORD *)(v23 + 624) = 0u;
    *(_OWORD *)(v23 + 640) = 0u;
    *(_OWORD *)(v23 + 592) = 0u;
    *(_OWORD *)(v23 + 608) = 0u;
    *(_OWORD *)(v23 + 560) = 0u;
    *(_OWORD *)(v23 + 576) = 0u;
    *(_DWORD *)(v23 + 924) = 2;
    *(_QWORD *)(v23 + 928) = 0;
    *(_QWORD *)(v23 + 944) = 0;
    *(_QWORD *)(v23 + 936) = 0;
    *(_BYTE *)(v23 + 952) = 0;
  }
  v25 = a1[3];
  v26 = re::MeshAsset::assetType((re::MeshAsset *)v23);
  v27 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v25, (unint64_t)v26);
  v28 = re::MeshAsset::assetType(v27);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v46, 2056, a3, (const char *)*v28);
  v29 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v27 + 24))(v27, v24, 0, 0);
  if ((v29 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
    if ((*(_BYTE *)(a2 + 120) & 1) != 0)
      v31 = *(const char **)(a2 + 128);
    else
      v31 = (const char *)(a2 + 121);
    *(_QWORD *)&v45 = v24;
    BYTE8(v45) = 0;
    v36 = v42;
    v37 = v43;
    v38 = v44;
    *(_BYTE *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v45;
    *(_BYTE *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(_QWORD *)(a4 + 24) = v37;
    *(_QWORD *)(a4 + 32) = v38;
  }
  else
  {
    if (v24)
    {
      v32 = re::globalAllocators((re *)v29)[2];
      (**v24)(v24);
      v29 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v32 + 40))(v32, v24);
    }
    v33 = v42;
    v34 = v43;
    v35 = v44;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(_QWORD *)(a4 + 24) = v34;
    *(_QWORD *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v60);
  v41 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v68[4], v39);
  if (v47[0])
  {
    v40 = v50;
    if (v50)
      (*(void (**)(double))(*(_QWORD *)v47[0] + 40))(v41);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v51, v40);
}

__n128 `anonymous namespace'::PrimitiveProvider<TetrahedronDescriptorParameters,re::GeomBuildTetrahedronOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *`anonymous namespace'::PrimitiveProvider<TetrahedronDescriptorParameters,re::GeomBuildTetrahedronOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v5;
  const char *v6;
  re::DynamicString *result;
  uint64_t v8;
  char v9;
  _OWORD v10[2];
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  __int16 v15;
  char v16;
  char v17;
  char v18;

  LOWORD(v14) = 1;
  HIDWORD(v14) = 1065353216;
  v15 = 257;
  v16 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<TetrahedronDescriptorParameters>(a2, &v14))
  {
    if (v17)
      v5 = " split";
    else
      v5 = "";
    if (v18)
      v6 = "";
    else
      v6 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t **))(*(_QWORD *)a1 + 120))(&v8, a1, &v14);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(_QWORD *)&v10[0])
    {
      if ((BYTE8(v10[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    result = (re::DynamicString *)v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(_QWORD *)v11 + 40))(v11, v13);
    }
  }
  else
  {
    v11 = "<mangled>";
    v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Tetrahedron::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "";
  if (*((_BYTE *)a1 + 8))
    v3 = "";
  else
    v3 = " noUV";
  if (*((_BYTE *)a1 + 9))
    v4 = "";
  else
    v4 = " noNorm";
  if (*((_BYTE *)a1 + 10))
    v2 = " merge";
  return re::DynamicString::format((re::DynamicString *)"%f/%d;%s%s%s", a2, *((float *)a1 + 1), *a1, v3, v4, v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<TetrahedronDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FCA28);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FCA28);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FCA20 = re::internal::getOrCreateInfo((re::internal *)"TetrahedronDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_TetrahedronDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_TetrahedronDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC940, 0);
      __cxa_guard_release(&qword_2540FCA28);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FCA20, v2, 0);
}

void Cone::~Cone(Cone *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<ConeDescriptorParameters,re::GeomBuildConeOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t `anonymous namespace'::PrimitiveProvider<ConeDescriptorParameters,re::GeomBuildConeOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Introspectable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  __int128 v18;
  __int128 v19;
  re *MeshAssetDataWithGeomMeshArray;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  void (***v24)(_QWORD);
  uint64_t v25;
  uint64_t *v26;
  re::MeshAsset *v27;
  uint64_t *v28;
  uint64_t v29;
  _anonymous_namespace_ *v30;
  const char *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  re::GeomAttribute *v40;
  double v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  _BYTE v46[16];
  _QWORD v47[2];
  uint64_t v48;
  int v49;
  re::GeomAttribute *v50;
  _QWORD v51[2];
  uint64_t v52;
  int v53;
  re::GeomMesh *v54;
  int v55;
  uint64_t v56;
  int v57;
  char v58;
  char v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  int v65;
  const char *v66;
  uint64_t v67;
  _BYTE v68[20];
  __int128 v69;
  __int128 v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v11 = *(_QWORD *)(a2 + 16);
    else
      v11 = a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v60, v10, v11);
    goto LABEL_17;
  }
  v55 = 65544;
  v56 = 0x3F0000003F800000;
  v57 = 65793;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<ConeDescriptorParameters>((re::AssetLoadDescriptor *)a2, (uint64_t **)&v55);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    v18 = v60;
    v19 = v61;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  v54 = 0;
  v51[1] = 0;
  v52 = 0;
  v50 = 0;
  v51[0] = 0;
  v53 = 0;
  v47[1] = 0;
  v48 = 0;
  v47[0] = 0;
  v49 = 0;
  if (v58)
  {
    re::buildCone((uint64_t)v51, (unsigned __int16 *)&v55);
    v13 = v52;
    re::DynamicArray<float>::resize((uint64_t)v47, v52);
    if (v13)
    {
      v14 = 0;
      v15 = v48;
      v16 = (uint64_t)v50;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14)
          goto LABEL_21;
      }
      *(_QWORD *)&v42 = 0;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v60 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v65 = 136315906;
      v66 = "operator[]";
      v67 = 0x800000003150400;
      *(_QWORD *)v68 = v15;
      *(_WORD *)&v68[8] = 2048;
      *(_QWORD *)&v68[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      *(_QWORD *)&v42 = 0;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v60 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v65 = 136315906;
      v66 = "operator[]";
      v67 = 0x800000003150400;
      *(_QWORD *)v68 = 0;
      *(_WORD *)&v68[8] = 2048;
      *(_QWORD *)&v68[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v51, 1uLL);
    LODWORD(v60) = 0;
    re::DynamicArray<unsigned int>::resize(v47, 1uLL, &v60);
    if (!v52)
      goto LABEL_37;
    re::buildCone((uint64_t)v54, (unsigned __int16 *)&v55);
  }
LABEL_21:
  v65 = 16842752;
  LOBYTE(v66) = 1;
  *(_DWORD *)((char *)&v66 + 1) = 0;
  BYTE5(v66) = 0;
  v68[0] = 0;
  v70 = 0u;
  *(_OWORD *)&v68[4] = 0u;
  v69 = 0u;
  DWORD1(v70) = 0x7FFFFFFF;
  BYTE6(v66) = v59;
  v67 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v54, v52, (uint64_t)v50, v48, 0, &v65, (uint64_t)&v60);
  v21 = v60;
  v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22[2] + 32))(v22[2], 960, 8);
  v24 = (void (***)(_QWORD))v23;
  if (v21)
  {
    v23 = re::MeshAsset::MeshAsset(v23, (uint64_t)&v60 + 8);
  }
  else
  {
    *(_QWORD *)v23 = &off_24ED30A60;
    *(_QWORD *)(v23 + 8) = 0;
    *(_QWORD *)(v23 + 16) = 0;
    *(_QWORD *)(v23 + 24) = 0;
    *(_DWORD *)(v23 + 32) = 0;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_DWORD *)(v23 + 72) = 0;
    *(_OWORD *)(v23 + 80) = 0u;
    *(_OWORD *)(v23 + 96) = 0u;
    *(_DWORD *)(v23 + 112) = 0;
    *(_OWORD *)(v23 + 120) = 0u;
    *(_OWORD *)(v23 + 136) = 0u;
    *(_DWORD *)(v23 + 152) = 0;
    *(_DWORD *)(v23 + 424) = 0;
    *(_OWORD *)(v23 + 392) = 0u;
    *(_OWORD *)(v23 + 408) = 0u;
    *(_OWORD *)(v23 + 484) = 0u;
    *(_OWORD *)(v23 + 472) = 0u;
    *(_OWORD *)(v23 + 456) = 0u;
    *(_DWORD *)(v23 + 192) = 0;
    *(_OWORD *)(v23 + 160) = 0u;
    *(_OWORD *)(v23 + 176) = 0u;
    *(_OWORD *)(v23 + 200) = 0u;
    *(_OWORD *)(v23 + 216) = 0u;
    *(_DWORD *)(v23 + 232) = 0;
    *(_OWORD *)(v23 + 240) = 0u;
    *(_OWORD *)(v23 + 256) = 0u;
    *(_DWORD *)(v23 + 272) = 0;
    *(_OWORD *)(v23 + 280) = 0u;
    *(_OWORD *)(v23 + 296) = 0u;
    *(_OWORD *)(v23 + 312) = 0u;
    *(_OWORD *)(v23 + 328) = 0u;
    *(_OWORD *)(v23 + 344) = 0u;
    *(_OWORD *)(v23 + 360) = 0u;
    *(_OWORD *)(v23 + 372) = 0u;
    *(_DWORD *)(v23 + 448) = 0;
    *(_QWORD *)(v23 + 432) = 0;
    *(_QWORD *)(v23 + 440) = 0;
    *(_QWORD *)(v23 + 500) = 0x7FFFFFFFLL;
    *(_DWORD *)(v23 + 544) = 0;
    *(_OWORD *)(v23 + 512) = 0u;
    *(_OWORD *)(v23 + 528) = 0u;
    *(_QWORD *)(v23 + 548) = 0x7FFFFFFFLL;
    *(_OWORD *)(v23 + 905) = 0u;
    *(_OWORD *)(v23 + 880) = 0u;
    *(_OWORD *)(v23 + 896) = 0u;
    *(_OWORD *)(v23 + 848) = 0u;
    *(_OWORD *)(v23 + 864) = 0u;
    *(_OWORD *)(v23 + 816) = 0u;
    *(_OWORD *)(v23 + 832) = 0u;
    *(_OWORD *)(v23 + 784) = 0u;
    *(_OWORD *)(v23 + 800) = 0u;
    *(_OWORD *)(v23 + 752) = 0u;
    *(_OWORD *)(v23 + 768) = 0u;
    *(_OWORD *)(v23 + 720) = 0u;
    *(_OWORD *)(v23 + 736) = 0u;
    *(_OWORD *)(v23 + 688) = 0u;
    *(_OWORD *)(v23 + 704) = 0u;
    *(_OWORD *)(v23 + 656) = 0u;
    *(_OWORD *)(v23 + 672) = 0u;
    *(_OWORD *)(v23 + 624) = 0u;
    *(_OWORD *)(v23 + 640) = 0u;
    *(_OWORD *)(v23 + 592) = 0u;
    *(_OWORD *)(v23 + 608) = 0u;
    *(_OWORD *)(v23 + 560) = 0u;
    *(_OWORD *)(v23 + 576) = 0u;
    *(_DWORD *)(v23 + 924) = 2;
    *(_QWORD *)(v23 + 928) = 0;
    *(_QWORD *)(v23 + 944) = 0;
    *(_QWORD *)(v23 + 936) = 0;
    *(_BYTE *)(v23 + 952) = 0;
  }
  v25 = a1[3];
  v26 = re::MeshAsset::assetType((re::MeshAsset *)v23);
  v27 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v25, (unint64_t)v26);
  v28 = re::MeshAsset::assetType(v27);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v46, 2056, a3, (const char *)*v28);
  v29 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v27 + 24))(v27, v24, 0, 0);
  if ((v29 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
    if ((*(_BYTE *)(a2 + 120) & 1) != 0)
      v31 = *(const char **)(a2 + 128);
    else
      v31 = (const char *)(a2 + 121);
    *(_QWORD *)&v45 = v24;
    BYTE8(v45) = 0;
    v36 = v42;
    v37 = v43;
    v38 = v44;
    *(_BYTE *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v45;
    *(_BYTE *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(_QWORD *)(a4 + 24) = v37;
    *(_QWORD *)(a4 + 32) = v38;
  }
  else
  {
    if (v24)
    {
      v32 = re::globalAllocators((re *)v29)[2];
      (**v24)(v24);
      v29 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v32 + 40))(v32, v24);
    }
    v33 = v42;
    v34 = v43;
    v35 = v44;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(_QWORD *)(a4 + 24) = v34;
    *(_QWORD *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v60);
  v41 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v68[4], v39);
  if (v47[0])
  {
    v40 = v50;
    if (v50)
      (*(void (**)(double))(*(_QWORD *)v47[0] + 40))(v41);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v51, v40);
}

__n128 `anonymous namespace'::PrimitiveProvider<ConeDescriptorParameters,re::GeomBuildConeOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *`anonymous namespace'::PrimitiveProvider<ConeDescriptorParameters,re::GeomBuildConeOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v5;
  const char *v6;
  re::DynamicString *result;
  uint64_t v8;
  char v9;
  _OWORD v10[2];
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  char v17;
  char v18;

  v14 = 65544;
  v15 = 0x3F0000003F800000;
  v16 = 65793;
  if (re::AssetLoadDescriptor::getIntrospectableData<ConeDescriptorParameters>(a2, (uint64_t **)&v14))
  {
    if (v17)
      v5 = " split";
    else
      v5 = "";
    if (v18)
      v6 = "";
    else
      v6 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(_QWORD *)a1 + 120))(&v8, a1, &v14);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(_QWORD *)&v10[0])
    {
      if ((BYTE8(v10[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    result = (re::DynamicString *)v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(_QWORD *)v11 + 40))(v11, v13);
    }
  }
  else
  {
    v11 = "<mangled>";
    v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Cone::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v2 = " cap";
  v3 = "";
  if (!*((_BYTE *)a1 + 12))
    v2 = "";
  if (*((_BYTE *)a1 + 13))
    v4 = "";
  else
    v4 = " noUV";
  if (*((_BYTE *)a1 + 14))
    v5 = "";
  else
    v5 = " noNorm";
  if (*((_BYTE *)a1 + 15))
    v3 = " merge";
  return re::DynamicString::format((re::DynamicString *)"%f/%d; %f/%d;%s%s%s%s",
           a2,
           *((float *)a1 + 2),
           *a1,
           *((float *)a1 + 1),
           a1[1],
           v2,
           v4,
           v5,
           v3);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<ConeDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FCA38);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FCA38);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FCA30 = re::internal::getOrCreateInfo((re::internal *)"ConeDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_ConeDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_ConeDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC958, 0);
      __cxa_guard_release(&qword_2540FCA38);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FCA30, v2, 0);
}

void Sphere::~Sphere(Sphere *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<SphereDescriptorParameters,re::GeomBuildSphereOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t `anonymous namespace'::PrimitiveProvider<SphereDescriptorParameters,re::GeomBuildSphereOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Introspectable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  __int128 v18;
  __int128 v19;
  re *MeshAssetDataWithGeomMeshArray;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  void (***v24)(_QWORD);
  uint64_t v25;
  uint64_t *v26;
  re::MeshAsset *v27;
  uint64_t *v28;
  uint64_t v29;
  _anonymous_namespace_ *v30;
  const char *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  re::GeomAttribute *v40;
  double v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  _BYTE v46[16];
  _QWORD v47[2];
  uint64_t v48;
  int v49;
  re::GeomAttribute *v50;
  _QWORD v51[2];
  uint64_t v52;
  int v53;
  re::GeomMesh *v54;
  uint64_t *v55;
  __int16 v56;
  char v57;
  char v58;
  char v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  int v65;
  const char *v66;
  uint64_t v67;
  _BYTE v68[20];
  __int128 v69;
  __int128 v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v11 = *(_QWORD *)(a2 + 16);
    else
      v11 = a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v60, v10, v11);
    goto LABEL_17;
  }
  LOWORD(v55) = 8;
  HIDWORD(v55) = 1056964608;
  v56 = 257;
  v57 = 0;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<SphereDescriptorParameters>((re::AssetLoadDescriptor *)a2, &v55);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    v18 = v60;
    v19 = v61;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  v54 = 0;
  v51[1] = 0;
  v52 = 0;
  v50 = 0;
  v51[0] = 0;
  v53 = 0;
  v47[1] = 0;
  v48 = 0;
  v47[0] = 0;
  v49 = 0;
  if (v58)
  {
    re::buildSphere((re::GeomMesh *)v51, (unsigned __int16 *)&v55);
    v13 = v52;
    re::DynamicArray<float>::resize((uint64_t)v47, v52);
    if (v13)
    {
      v14 = 0;
      v15 = v48;
      v16 = (uint64_t)v50;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14)
          goto LABEL_21;
      }
      *(_QWORD *)&v42 = 0;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v60 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v65 = 136315906;
      v66 = "operator[]";
      v67 = 0x800000003150400;
      *(_QWORD *)v68 = v15;
      *(_WORD *)&v68[8] = 2048;
      *(_QWORD *)&v68[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      *(_QWORD *)&v42 = 0;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v60 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v65 = 136315906;
      v66 = "operator[]";
      v67 = 0x800000003150400;
      *(_QWORD *)v68 = 0;
      *(_WORD *)&v68[8] = 2048;
      *(_QWORD *)&v68[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v51, 1uLL);
    LODWORD(v60) = 0;
    re::DynamicArray<unsigned int>::resize(v47, 1uLL, &v60);
    if (!v52)
      goto LABEL_37;
    re::buildSphere((uint64_t)v54, (unsigned __int16 *)&v55);
  }
LABEL_21:
  v65 = 16842752;
  LOBYTE(v66) = 1;
  *(_DWORD *)((char *)&v66 + 1) = 0;
  BYTE5(v66) = 0;
  v68[0] = 0;
  v70 = 0u;
  *(_OWORD *)&v68[4] = 0u;
  v69 = 0u;
  DWORD1(v70) = 0x7FFFFFFF;
  BYTE6(v66) = v59;
  v67 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v54, v52, (uint64_t)v50, v48, 0, &v65, (uint64_t)&v60);
  v21 = v60;
  v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22[2] + 32))(v22[2], 960, 8);
  v24 = (void (***)(_QWORD))v23;
  if (v21)
  {
    v23 = re::MeshAsset::MeshAsset(v23, (uint64_t)&v60 + 8);
  }
  else
  {
    *(_QWORD *)v23 = &off_24ED30A60;
    *(_QWORD *)(v23 + 8) = 0;
    *(_QWORD *)(v23 + 16) = 0;
    *(_QWORD *)(v23 + 24) = 0;
    *(_DWORD *)(v23 + 32) = 0;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_DWORD *)(v23 + 72) = 0;
    *(_OWORD *)(v23 + 80) = 0u;
    *(_OWORD *)(v23 + 96) = 0u;
    *(_DWORD *)(v23 + 112) = 0;
    *(_OWORD *)(v23 + 120) = 0u;
    *(_OWORD *)(v23 + 136) = 0u;
    *(_DWORD *)(v23 + 152) = 0;
    *(_DWORD *)(v23 + 424) = 0;
    *(_OWORD *)(v23 + 392) = 0u;
    *(_OWORD *)(v23 + 408) = 0u;
    *(_OWORD *)(v23 + 484) = 0u;
    *(_OWORD *)(v23 + 472) = 0u;
    *(_OWORD *)(v23 + 456) = 0u;
    *(_DWORD *)(v23 + 192) = 0;
    *(_OWORD *)(v23 + 160) = 0u;
    *(_OWORD *)(v23 + 176) = 0u;
    *(_OWORD *)(v23 + 200) = 0u;
    *(_OWORD *)(v23 + 216) = 0u;
    *(_DWORD *)(v23 + 232) = 0;
    *(_OWORD *)(v23 + 240) = 0u;
    *(_OWORD *)(v23 + 256) = 0u;
    *(_DWORD *)(v23 + 272) = 0;
    *(_OWORD *)(v23 + 280) = 0u;
    *(_OWORD *)(v23 + 296) = 0u;
    *(_OWORD *)(v23 + 312) = 0u;
    *(_OWORD *)(v23 + 328) = 0u;
    *(_OWORD *)(v23 + 344) = 0u;
    *(_OWORD *)(v23 + 360) = 0u;
    *(_OWORD *)(v23 + 372) = 0u;
    *(_DWORD *)(v23 + 448) = 0;
    *(_QWORD *)(v23 + 432) = 0;
    *(_QWORD *)(v23 + 440) = 0;
    *(_QWORD *)(v23 + 500) = 0x7FFFFFFFLL;
    *(_DWORD *)(v23 + 544) = 0;
    *(_OWORD *)(v23 + 512) = 0u;
    *(_OWORD *)(v23 + 528) = 0u;
    *(_QWORD *)(v23 + 548) = 0x7FFFFFFFLL;
    *(_OWORD *)(v23 + 905) = 0u;
    *(_OWORD *)(v23 + 880) = 0u;
    *(_OWORD *)(v23 + 896) = 0u;
    *(_OWORD *)(v23 + 848) = 0u;
    *(_OWORD *)(v23 + 864) = 0u;
    *(_OWORD *)(v23 + 816) = 0u;
    *(_OWORD *)(v23 + 832) = 0u;
    *(_OWORD *)(v23 + 784) = 0u;
    *(_OWORD *)(v23 + 800) = 0u;
    *(_OWORD *)(v23 + 752) = 0u;
    *(_OWORD *)(v23 + 768) = 0u;
    *(_OWORD *)(v23 + 720) = 0u;
    *(_OWORD *)(v23 + 736) = 0u;
    *(_OWORD *)(v23 + 688) = 0u;
    *(_OWORD *)(v23 + 704) = 0u;
    *(_OWORD *)(v23 + 656) = 0u;
    *(_OWORD *)(v23 + 672) = 0u;
    *(_OWORD *)(v23 + 624) = 0u;
    *(_OWORD *)(v23 + 640) = 0u;
    *(_OWORD *)(v23 + 592) = 0u;
    *(_OWORD *)(v23 + 608) = 0u;
    *(_OWORD *)(v23 + 560) = 0u;
    *(_OWORD *)(v23 + 576) = 0u;
    *(_DWORD *)(v23 + 924) = 2;
    *(_QWORD *)(v23 + 928) = 0;
    *(_QWORD *)(v23 + 944) = 0;
    *(_QWORD *)(v23 + 936) = 0;
    *(_BYTE *)(v23 + 952) = 0;
  }
  v25 = a1[3];
  v26 = re::MeshAsset::assetType((re::MeshAsset *)v23);
  v27 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v25, (unint64_t)v26);
  v28 = re::MeshAsset::assetType(v27);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v46, 2056, a3, (const char *)*v28);
  v29 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v27 + 24))(v27, v24, 0, 0);
  if ((v29 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
    if ((*(_BYTE *)(a2 + 120) & 1) != 0)
      v31 = *(const char **)(a2 + 128);
    else
      v31 = (const char *)(a2 + 121);
    *(_QWORD *)&v45 = v24;
    BYTE8(v45) = 0;
    v36 = v42;
    v37 = v43;
    v38 = v44;
    *(_BYTE *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v45;
    *(_BYTE *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(_QWORD *)(a4 + 24) = v37;
    *(_QWORD *)(a4 + 32) = v38;
  }
  else
  {
    if (v24)
    {
      v32 = re::globalAllocators((re *)v29)[2];
      (**v24)(v24);
      v29 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v32 + 40))(v32, v24);
    }
    v33 = v42;
    v34 = v43;
    v35 = v44;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(_QWORD *)(a4 + 24) = v34;
    *(_QWORD *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v60);
  v41 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v68[4], v39);
  if (v47[0])
  {
    v40 = v50;
    if (v50)
      (*(void (**)(double))(*(_QWORD *)v47[0] + 40))(v41);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v51, v40);
}

__n128 `anonymous namespace'::PrimitiveProvider<SphereDescriptorParameters,re::GeomBuildSphereOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *`anonymous namespace'::PrimitiveProvider<SphereDescriptorParameters,re::GeomBuildSphereOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v5;
  const char *v6;
  re::DynamicString *result;
  uint64_t v8;
  char v9;
  _OWORD v10[2];
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  __int16 v15;
  char v16;
  char v17;
  char v18;

  LOWORD(v14) = 8;
  HIDWORD(v14) = 1056964608;
  v15 = 257;
  v16 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<SphereDescriptorParameters>(a2, &v14))
  {
    if (v17)
      v5 = " split";
    else
      v5 = "";
    if (v18)
      v6 = "";
    else
      v6 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t **))(*(_QWORD *)a1 + 120))(&v8, a1, &v14);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(_QWORD *)&v10[0])
    {
      if ((BYTE8(v10[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    result = (re::DynamicString *)v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(_QWORD *)v11 + 40))(v11, v13);
    }
  }
  else
  {
    v11 = "<mangled>";
    v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Sphere::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "";
  if (*((_BYTE *)a1 + 8))
    v3 = "";
  else
    v3 = " noUV";
  if (*((_BYTE *)a1 + 9))
    v4 = "";
  else
    v4 = " noNorm";
  if (*((_BYTE *)a1 + 10))
    v2 = " merge";
  return re::DynamicString::format((re::DynamicString *)"%f/%d;%s%s%s", a2, *((float *)a1 + 1), *a1, v3, v4, v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<SphereDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FCA48);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FCA48);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FCA40 = re::internal::getOrCreateInfo((re::internal *)"SphereDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_SphereDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_SphereDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC970, 0);
      __cxa_guard_release(&qword_2540FCA48);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FCA40, v2, 0);
}

void Capsule::~Capsule(Capsule *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<CapsuleDescriptorParameters,re::GeomBuildCapsuleOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t `anonymous namespace'::PrimitiveProvider<CapsuleDescriptorParameters,re::GeomBuildCapsuleOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Introspectable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  __int128 v18;
  __int128 v19;
  re *MeshAssetDataWithGeomMeshArray;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  void (***v24)(_QWORD);
  uint64_t v25;
  uint64_t *v26;
  re::MeshAsset *v27;
  uint64_t *v28;
  uint64_t v29;
  _anonymous_namespace_ *v30;
  const char *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  re::GeomAttribute *v40;
  double v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  _BYTE v46[16];
  _QWORD v47[2];
  uint64_t v48;
  int v49;
  re::GeomAttribute *v50;
  _QWORD v51[2];
  uint64_t v52;
  int v53;
  re::GeomMesh *v54;
  uint64_t *v55[2];
  __int16 v56;
  char v57;
  char v58;
  char v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  int v65;
  const char *v66;
  uint64_t v67;
  _BYTE v68[20];
  __int128 v69;
  __int128 v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v11 = *(_QWORD *)(a2 + 16);
    else
      v11 = a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v60, v10, v11);
    goto LABEL_17;
  }
  LODWORD(v55[0]) = 65544;
  WORD2(v55[0]) = 4;
  v55[1] = (uint64_t *)0x400000003F000000;
  v56 = 257;
  v57 = 0;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<CapsuleDescriptorParameters>((re::AssetLoadDescriptor *)a2, v55);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    v18 = v60;
    v19 = v61;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  v54 = 0;
  v51[1] = 0;
  v52 = 0;
  v50 = 0;
  v51[0] = 0;
  v53 = 0;
  v47[1] = 0;
  v48 = 0;
  v47[0] = 0;
  v49 = 0;
  if (v58)
  {
    re::buildCapsule((re::GeomMesh *)v51, (unsigned __int16 *)v55);
    v13 = v52;
    re::DynamicArray<float>::resize((uint64_t)v47, v52);
    if (v13)
    {
      v14 = 0;
      v15 = v48;
      v16 = (uint64_t)v50;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14)
          goto LABEL_21;
      }
      *(_QWORD *)&v42 = 0;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v60 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v65 = 136315906;
      v66 = "operator[]";
      v67 = 0x800000003150400;
      *(_QWORD *)v68 = v15;
      *(_WORD *)&v68[8] = 2048;
      *(_QWORD *)&v68[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      *(_QWORD *)&v42 = 0;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v60 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v65 = 136315906;
      v66 = "operator[]";
      v67 = 0x800000003150400;
      *(_QWORD *)v68 = 0;
      *(_WORD *)&v68[8] = 2048;
      *(_QWORD *)&v68[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v51, 1uLL);
    LODWORD(v60) = 0;
    re::DynamicArray<unsigned int>::resize(v47, 1uLL, &v60);
    if (!v52)
      goto LABEL_37;
    re::buildCapsule((uint64_t)v54, (unsigned __int16 *)v55);
  }
LABEL_21:
  v65 = 16842752;
  LOBYTE(v66) = 1;
  *(_DWORD *)((char *)&v66 + 1) = 0;
  BYTE5(v66) = 0;
  v68[0] = 0;
  v70 = 0u;
  *(_OWORD *)&v68[4] = 0u;
  v69 = 0u;
  DWORD1(v70) = 0x7FFFFFFF;
  BYTE6(v66) = v59;
  v67 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v54, v52, (uint64_t)v50, v48, 0, &v65, (uint64_t)&v60);
  v21 = v60;
  v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22[2] + 32))(v22[2], 960, 8);
  v24 = (void (***)(_QWORD))v23;
  if (v21)
  {
    v23 = re::MeshAsset::MeshAsset(v23, (uint64_t)&v60 + 8);
  }
  else
  {
    *(_QWORD *)v23 = &off_24ED30A60;
    *(_QWORD *)(v23 + 8) = 0;
    *(_QWORD *)(v23 + 16) = 0;
    *(_QWORD *)(v23 + 24) = 0;
    *(_DWORD *)(v23 + 32) = 0;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_DWORD *)(v23 + 72) = 0;
    *(_OWORD *)(v23 + 80) = 0u;
    *(_OWORD *)(v23 + 96) = 0u;
    *(_DWORD *)(v23 + 112) = 0;
    *(_OWORD *)(v23 + 120) = 0u;
    *(_OWORD *)(v23 + 136) = 0u;
    *(_DWORD *)(v23 + 152) = 0;
    *(_DWORD *)(v23 + 424) = 0;
    *(_OWORD *)(v23 + 392) = 0u;
    *(_OWORD *)(v23 + 408) = 0u;
    *(_OWORD *)(v23 + 484) = 0u;
    *(_OWORD *)(v23 + 472) = 0u;
    *(_OWORD *)(v23 + 456) = 0u;
    *(_DWORD *)(v23 + 192) = 0;
    *(_OWORD *)(v23 + 160) = 0u;
    *(_OWORD *)(v23 + 176) = 0u;
    *(_OWORD *)(v23 + 200) = 0u;
    *(_OWORD *)(v23 + 216) = 0u;
    *(_DWORD *)(v23 + 232) = 0;
    *(_OWORD *)(v23 + 240) = 0u;
    *(_OWORD *)(v23 + 256) = 0u;
    *(_DWORD *)(v23 + 272) = 0;
    *(_OWORD *)(v23 + 280) = 0u;
    *(_OWORD *)(v23 + 296) = 0u;
    *(_OWORD *)(v23 + 312) = 0u;
    *(_OWORD *)(v23 + 328) = 0u;
    *(_OWORD *)(v23 + 344) = 0u;
    *(_OWORD *)(v23 + 360) = 0u;
    *(_OWORD *)(v23 + 372) = 0u;
    *(_DWORD *)(v23 + 448) = 0;
    *(_QWORD *)(v23 + 432) = 0;
    *(_QWORD *)(v23 + 440) = 0;
    *(_QWORD *)(v23 + 500) = 0x7FFFFFFFLL;
    *(_DWORD *)(v23 + 544) = 0;
    *(_OWORD *)(v23 + 512) = 0u;
    *(_OWORD *)(v23 + 528) = 0u;
    *(_QWORD *)(v23 + 548) = 0x7FFFFFFFLL;
    *(_OWORD *)(v23 + 905) = 0u;
    *(_OWORD *)(v23 + 880) = 0u;
    *(_OWORD *)(v23 + 896) = 0u;
    *(_OWORD *)(v23 + 848) = 0u;
    *(_OWORD *)(v23 + 864) = 0u;
    *(_OWORD *)(v23 + 816) = 0u;
    *(_OWORD *)(v23 + 832) = 0u;
    *(_OWORD *)(v23 + 784) = 0u;
    *(_OWORD *)(v23 + 800) = 0u;
    *(_OWORD *)(v23 + 752) = 0u;
    *(_OWORD *)(v23 + 768) = 0u;
    *(_OWORD *)(v23 + 720) = 0u;
    *(_OWORD *)(v23 + 736) = 0u;
    *(_OWORD *)(v23 + 688) = 0u;
    *(_OWORD *)(v23 + 704) = 0u;
    *(_OWORD *)(v23 + 656) = 0u;
    *(_OWORD *)(v23 + 672) = 0u;
    *(_OWORD *)(v23 + 624) = 0u;
    *(_OWORD *)(v23 + 640) = 0u;
    *(_OWORD *)(v23 + 592) = 0u;
    *(_OWORD *)(v23 + 608) = 0u;
    *(_OWORD *)(v23 + 560) = 0u;
    *(_OWORD *)(v23 + 576) = 0u;
    *(_DWORD *)(v23 + 924) = 2;
    *(_QWORD *)(v23 + 928) = 0;
    *(_QWORD *)(v23 + 944) = 0;
    *(_QWORD *)(v23 + 936) = 0;
    *(_BYTE *)(v23 + 952) = 0;
  }
  v25 = a1[3];
  v26 = re::MeshAsset::assetType((re::MeshAsset *)v23);
  v27 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v25, (unint64_t)v26);
  v28 = re::MeshAsset::assetType(v27);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v46, 2056, a3, (const char *)*v28);
  v29 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v27 + 24))(v27, v24, 0, 0);
  if ((v29 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
    if ((*(_BYTE *)(a2 + 120) & 1) != 0)
      v31 = *(const char **)(a2 + 128);
    else
      v31 = (const char *)(a2 + 121);
    *(_QWORD *)&v45 = v24;
    BYTE8(v45) = 0;
    v36 = v42;
    v37 = v43;
    v38 = v44;
    *(_BYTE *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v45;
    *(_BYTE *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(_QWORD *)(a4 + 24) = v37;
    *(_QWORD *)(a4 + 32) = v38;
  }
  else
  {
    if (v24)
    {
      v32 = re::globalAllocators((re *)v29)[2];
      (**v24)(v24);
      v29 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v32 + 40))(v32, v24);
    }
    v33 = v42;
    v34 = v43;
    v35 = v44;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(_QWORD *)(a4 + 24) = v34;
    *(_QWORD *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v60);
  v41 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v68[4], v39);
  if (v47[0])
  {
    v40 = v50;
    if (v50)
      (*(void (**)(double))(*(_QWORD *)v47[0] + 40))(v41);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v51, v40);
}

__n128 `anonymous namespace'::PrimitiveProvider<CapsuleDescriptorParameters,re::GeomBuildCapsuleOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *`anonymous namespace'::PrimitiveProvider<CapsuleDescriptorParameters,re::GeomBuildCapsuleOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v5;
  const char *v6;
  re::DynamicString *result;
  uint64_t v8;
  char v9;
  _OWORD v10[2];
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14[2];
  __int16 v15;
  char v16;
  char v17;
  char v18;

  LODWORD(v14[0]) = 65544;
  WORD2(v14[0]) = 4;
  v14[1] = (uint64_t *)0x400000003F000000;
  v15 = 257;
  v16 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<CapsuleDescriptorParameters>(a2, v14))
  {
    if (v17)
      v5 = " split";
    else
      v5 = "";
    if (v18)
      v6 = "";
    else
      v6 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t **))(*(_QWORD *)a1 + 120))(&v8, a1, v14);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(_QWORD *)&v10[0])
    {
      if ((BYTE8(v10[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    result = (re::DynamicString *)v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(_QWORD *)v11 + 40))(v11, v13);
    }
  }
  else
  {
    v11 = "<mangled>";
    v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Capsule::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "";
  if (*((_BYTE *)a1 + 16))
    v3 = "";
  else
    v3 = " noUV";
  if (*((_BYTE *)a1 + 17))
    v4 = "";
  else
    v4 = " noNorm";
  if (*((_BYTE *)a1 + 18))
    v2 = " merge";
  return re::DynamicString::format((re::DynamicString *)"%d; %f/%d; %f/%d;%s%s%s",
           a2,
           *a1,
           *((float *)a1 + 2),
           a1[2],
           *((float *)a1 + 3),
           a1[1],
           v3,
           v4,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<CapsuleDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FCA58);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FCA58);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FCA50 = re::internal::getOrCreateInfo((re::internal *)"CapsuleDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_CapsuleDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_CapsuleDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC988, 0);
      __cxa_guard_release(&qword_2540FCA58);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FCA50, v2, 0);
}

void Pyramid::~Pyramid(Pyramid *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<PyramidDescriptorParameters,re::GeomBuildPyramidOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t `anonymous namespace'::PrimitiveProvider<PyramidDescriptorParameters,re::GeomBuildPyramidOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Introspectable;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  __int128 v23;
  __int128 v24;
  re *MeshAssetDataWithGeomMeshArray;
  int v26;
  uint64_t *v27;
  uint64_t v28;
  void (***v29)(_QWORD);
  uint64_t v30;
  uint64_t *v31;
  re::MeshAsset *v32;
  uint64_t *v33;
  uint64_t v34;
  _anonymous_namespace_ *v35;
  const char *v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  double v44;
  re::GeomAttribute *v45;
  double v46;
  __int128 v47;
  uint64_t v48;
  uint64_t v49;
  __int128 v50;
  _BYTE v51[16];
  _QWORD v52[2];
  uint64_t v53;
  int v54;
  re::GeomAttribute *v55;
  _QWORD v56[2];
  uint64_t v57;
  int v58;
  re::GeomMesh *v59;
  __int128 v60;
  __int16 v61;
  char v62;
  char v63;
  char v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  int v70;
  const char *v71;
  uint64_t v72;
  _BYTE v73[20];
  __int128 v74;
  __int128 v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v11 = *(_QWORD *)(a2 + 16);
    else
      v11 = a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v65, v10, v11);
    goto LABEL_17;
  }
  LOWORD(v60) = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)((char *)&v60 + 4) = _D0;
  HIDWORD(v60) = 1065353216;
  v61 = 257;
  v62 = 0;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<PyramidDescriptorParameters>((re::AssetLoadDescriptor *)a2, (uint64_t **)&v60);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    v23 = v65;
    v24 = v66;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v23;
    *(_OWORD *)(a4 + 24) = v24;
    return result;
  }
  v59 = 0;
  v56[1] = 0;
  v57 = 0;
  v55 = 0;
  v56[0] = 0;
  v58 = 0;
  v52[1] = 0;
  v53 = 0;
  v52[0] = 0;
  v54 = 0;
  if (v63)
  {
    re::buildPyramid((re::GeomMesh *)v56, &v60);
    v18 = v57;
    re::DynamicArray<float>::resize((uint64_t)v52, v57);
    if (v18)
    {
      v19 = 0;
      v20 = v53;
      v21 = (uint64_t)v55;
      while (v20 != v19)
      {
        *(_DWORD *)(v21 + 4 * v19) = v19;
        if (v18 == ++v19)
          goto LABEL_21;
      }
      *(_QWORD *)&v47 = 0;
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      v65 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v70 = 136315906;
      v71 = "operator[]";
      v72 = 0x800000003150400;
      *(_QWORD *)v73 = v20;
      *(_WORD *)&v73[8] = 2048;
      *(_QWORD *)&v73[10] = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      *(_QWORD *)&v47 = 0;
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      v65 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v70 = 136315906;
      v71 = "operator[]";
      v72 = 0x800000003150400;
      *(_QWORD *)v73 = 0;
      *(_WORD *)&v73[8] = 2048;
      *(_QWORD *)&v73[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v56, 1uLL);
    LODWORD(v65) = 0;
    re::DynamicArray<unsigned int>::resize(v52, 1uLL, &v65);
    if (!v57)
      goto LABEL_37;
    re::buildPyramid((uint64_t)v59, (unsigned __int16 *)&v60);
  }
LABEL_21:
  v70 = 16842752;
  LOBYTE(v71) = 1;
  *(_DWORD *)((char *)&v71 + 1) = 0;
  BYTE5(v71) = 0;
  v73[0] = 0;
  v75 = 0u;
  *(_OWORD *)&v73[4] = 0u;
  v74 = 0u;
  DWORD1(v75) = 0x7FFFFFFF;
  BYTE6(v71) = v64;
  v72 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v59, v57, (uint64_t)v55, v53, 0, &v70, (uint64_t)&v65);
  v26 = v65;
  v27 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  v28 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v27[2] + 32))(v27[2], 960, 8);
  v29 = (void (***)(_QWORD))v28;
  if (v26)
  {
    v28 = re::MeshAsset::MeshAsset(v28, (uint64_t)&v65 + 8);
  }
  else
  {
    *(_QWORD *)v28 = &off_24ED30A60;
    *(_QWORD *)(v28 + 8) = 0;
    *(_QWORD *)(v28 + 16) = 0;
    *(_QWORD *)(v28 + 24) = 0;
    *(_DWORD *)(v28 + 32) = 0;
    *(_OWORD *)(v28 + 40) = 0u;
    *(_OWORD *)(v28 + 56) = 0u;
    *(_DWORD *)(v28 + 72) = 0;
    *(_OWORD *)(v28 + 80) = 0u;
    *(_OWORD *)(v28 + 96) = 0u;
    *(_DWORD *)(v28 + 112) = 0;
    *(_OWORD *)(v28 + 120) = 0u;
    *(_OWORD *)(v28 + 136) = 0u;
    *(_DWORD *)(v28 + 152) = 0;
    *(_DWORD *)(v28 + 424) = 0;
    *(_OWORD *)(v28 + 392) = 0u;
    *(_OWORD *)(v28 + 408) = 0u;
    *(_OWORD *)(v28 + 484) = 0u;
    *(_OWORD *)(v28 + 472) = 0u;
    *(_OWORD *)(v28 + 456) = 0u;
    *(_DWORD *)(v28 + 192) = 0;
    *(_OWORD *)(v28 + 160) = 0u;
    *(_OWORD *)(v28 + 176) = 0u;
    *(_OWORD *)(v28 + 200) = 0u;
    *(_OWORD *)(v28 + 216) = 0u;
    *(_DWORD *)(v28 + 232) = 0;
    *(_OWORD *)(v28 + 240) = 0u;
    *(_OWORD *)(v28 + 256) = 0u;
    *(_DWORD *)(v28 + 272) = 0;
    *(_OWORD *)(v28 + 280) = 0u;
    *(_OWORD *)(v28 + 296) = 0u;
    *(_OWORD *)(v28 + 312) = 0u;
    *(_OWORD *)(v28 + 328) = 0u;
    *(_OWORD *)(v28 + 344) = 0u;
    *(_OWORD *)(v28 + 360) = 0u;
    *(_OWORD *)(v28 + 372) = 0u;
    *(_DWORD *)(v28 + 448) = 0;
    *(_QWORD *)(v28 + 432) = 0;
    *(_QWORD *)(v28 + 440) = 0;
    *(_QWORD *)(v28 + 500) = 0x7FFFFFFFLL;
    *(_DWORD *)(v28 + 544) = 0;
    *(_OWORD *)(v28 + 512) = 0u;
    *(_OWORD *)(v28 + 528) = 0u;
    *(_QWORD *)(v28 + 548) = 0x7FFFFFFFLL;
    *(_OWORD *)(v28 + 905) = 0u;
    *(_OWORD *)(v28 + 880) = 0u;
    *(_OWORD *)(v28 + 896) = 0u;
    *(_OWORD *)(v28 + 848) = 0u;
    *(_OWORD *)(v28 + 864) = 0u;
    *(_OWORD *)(v28 + 816) = 0u;
    *(_OWORD *)(v28 + 832) = 0u;
    *(_OWORD *)(v28 + 784) = 0u;
    *(_OWORD *)(v28 + 800) = 0u;
    *(_OWORD *)(v28 + 752) = 0u;
    *(_OWORD *)(v28 + 768) = 0u;
    *(_OWORD *)(v28 + 720) = 0u;
    *(_OWORD *)(v28 + 736) = 0u;
    *(_OWORD *)(v28 + 688) = 0u;
    *(_OWORD *)(v28 + 704) = 0u;
    *(_OWORD *)(v28 + 656) = 0u;
    *(_OWORD *)(v28 + 672) = 0u;
    *(_OWORD *)(v28 + 624) = 0u;
    *(_OWORD *)(v28 + 640) = 0u;
    *(_OWORD *)(v28 + 592) = 0u;
    *(_OWORD *)(v28 + 608) = 0u;
    *(_OWORD *)(v28 + 560) = 0u;
    *(_OWORD *)(v28 + 576) = 0u;
    *(_DWORD *)(v28 + 924) = 2;
    *(_QWORD *)(v28 + 928) = 0;
    *(_QWORD *)(v28 + 944) = 0;
    *(_QWORD *)(v28 + 936) = 0;
    *(_BYTE *)(v28 + 952) = 0;
  }
  v30 = a1[3];
  v31 = re::MeshAsset::assetType((re::MeshAsset *)v28);
  v32 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v30, (unint64_t)v31);
  v33 = re::MeshAsset::assetType(v32);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v51, 2056, a3, (const char *)*v33);
  v34 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v32 + 24))(v32, v29, 0, 0);
  if ((v34 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v51);
    if ((*(_BYTE *)(a2 + 120) & 1) != 0)
      v36 = *(const char **)(a2 + 128);
    else
      v36 = (const char *)(a2 + 121);
    *(_QWORD *)&v50 = v29;
    BYTE8(v50) = 0;
    v41 = v47;
    v42 = v48;
    v43 = v49;
    *(_BYTE *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v50;
    *(_BYTE *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v41;
    *(_QWORD *)(a4 + 24) = v42;
    *(_QWORD *)(a4 + 32) = v43;
  }
  else
  {
    if (v29)
    {
      v37 = re::globalAllocators((re *)v34)[2];
      (**v29)(v29);
      v34 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v37 + 40))(v37, v29);
    }
    v38 = v47;
    v39 = v48;
    v40 = v49;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v38;
    *(_QWORD *)(a4 + 24) = v39;
    *(_QWORD *)(a4 + 32) = v40;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v51);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v65);
  v46 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v73[4], v44);
  if (v52[0])
  {
    v45 = v55;
    if (v55)
      (*(void (**)(double))(*(_QWORD *)v52[0] + 40))(v46);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v56, v45);
}

__n128 `anonymous namespace'::PrimitiveProvider<PyramidDescriptorParameters,re::GeomBuildPyramidOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *`anonymous namespace'::PrimitiveProvider<PyramidDescriptorParameters,re::GeomBuildPyramidOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v10;
  const char *v11;
  re::DynamicString *result;
  uint64_t v13;
  char v14;
  _OWORD v15[2];
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  _WORD v19[2];
  uint64_t v20;
  int v21;
  __int16 v22;
  char v23;
  char v24;
  char v25;

  v19[0] = 1;
  __asm { FMOV            V0.2S, #1.0 }
  v20 = _D0;
  v21 = 1065353216;
  v22 = 257;
  v23 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<PyramidDescriptorParameters>(a2, (uint64_t **)v19))
  {
    if (v24)
      v10 = " split";
    else
      v10 = "";
    if (v25)
      v11 = "";
    else
      v11 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v16, v10, v11);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 120))(&v13, a1, v19);
    re::DynamicString::operator+((re::DynamicString *)&v13, (uint64_t)&v16, (re::DynamicString *)v15);
    re::DynamicString::operator=(a3, (re::DynamicString *)v15);
    if (*(_QWORD *)&v15[0])
    {
      if ((BYTE8(v15[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v15[0] + 40))();
      memset(v15, 0, sizeof(v15));
    }
    if (v13 && (v14 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v13 + 40))();
    result = (re::DynamicString *)v16;
    if (v16)
    {
      if ((v17 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(_QWORD *)v16 + 40))(v16, v18);
    }
  }
  else
  {
    v16 = "<mangled>";
    v17 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v16);
  }
  return result;
}

uint64_t Pyramid::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "";
  if (*((_BYTE *)a1 + 16))
    v3 = "";
  else
    v3 = " noUV";
  if (*((_BYTE *)a1 + 17))
    v4 = "";
  else
    v4 = " noNorm";
  if (*((_BYTE *)a1 + 18))
    v2 = " merge";
  return re::DynamicString::format((re::DynamicString *)"%fx%fx%f/%d;%s%s%s",
           a2,
           *((float *)a1 + 1),
           *((float *)a1 + 2),
           *((float *)a1 + 3),
           *a1,
           v3,
           v4,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<PyramidDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FCA68);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FCA68);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FCA60 = re::internal::getOrCreateInfo((re::internal *)"PyramidDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_PyramidDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_PyramidDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC9A0, 0);
      __cxa_guard_release(&qword_2540FCA68);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FCA60, v2, 0);
}

void Box::~Box(Box *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<BoxDescriptorParameters,re::GeomBuildBoxOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t `anonymous namespace'::PrimitiveProvider<BoxDescriptorParameters,re::GeomBuildBoxOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Introspectable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  __int128 v18;
  __int128 v19;
  re *MeshAssetDataWithGeomMeshArray;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  void (***v24)(_QWORD);
  uint64_t v25;
  uint64_t *v26;
  re::MeshAsset *v27;
  uint64_t *v28;
  uint64_t v29;
  _anonymous_namespace_ *v30;
  const char *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  re::GeomAttribute *v40;
  double v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  _BYTE v46[16];
  _QWORD v47[2];
  uint64_t v48;
  int v49;
  re::GeomAttribute *v50;
  _QWORD v51[2];
  uint64_t v52;
  int v53;
  re::internal *v54;
  uint64_t v55;
  __int128 v56;
  __int16 v57;
  char v58;
  char v59;
  char v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  int v66;
  const char *v67;
  uint64_t v68;
  _BYTE v69[20];
  __int128 v70;
  __int128 v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v11 = *(_QWORD *)(a2 + 16);
    else
      v11 = a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v61, v10, v11);
    goto LABEL_17;
  }
  v55 = 0x1000100010001;
  v56 = xmmword_2260F8390;
  v57 = 257;
  v58 = 0;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<BoxDescriptorParameters>((re::AssetLoadDescriptor *)a2, (uint64_t **)&v55);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    v18 = v61;
    v19 = v62;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  v54 = 0;
  v51[1] = 0;
  v52 = 0;
  v50 = 0;
  v51[0] = 0;
  v53 = 0;
  v47[1] = 0;
  v48 = 0;
  v47[0] = 0;
  v49 = 0;
  if (v59)
  {
    re::buildBox((re::GeomMesh *)v51, (uint64_t)&v55);
    v13 = v52;
    re::DynamicArray<float>::resize((uint64_t)v47, v52);
    if (v13)
    {
      v14 = 0;
      v15 = v48;
      v16 = (uint64_t)v50;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14)
          goto LABEL_21;
      }
      *(_QWORD *)&v42 = 0;
      v64 = 0u;
      v65 = 0u;
      v62 = 0u;
      v63 = 0u;
      v61 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v66 = 136315906;
      v67 = "operator[]";
      v68 = 0x800000003150400;
      *(_QWORD *)v69 = v15;
      *(_WORD *)&v69[8] = 2048;
      *(_QWORD *)&v69[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      *(_QWORD *)&v42 = 0;
      v64 = 0u;
      v65 = 0u;
      v62 = 0u;
      v63 = 0u;
      v61 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v66 = 136315906;
      v67 = "operator[]";
      v68 = 0x800000003150400;
      *(_QWORD *)v69 = 0;
      *(_WORD *)&v69[8] = 2048;
      *(_QWORD *)&v69[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v51, 1uLL);
    LODWORD(v61) = 0;
    re::DynamicArray<unsigned int>::resize(v47, 1uLL, &v61);
    if (!v52)
      goto LABEL_37;
    re::internal::buildBoxHelper(v54, &v61, (unsigned __int16 *)&v55);
  }
LABEL_21:
  v66 = 16842752;
  LOBYTE(v67) = 1;
  *(_DWORD *)((char *)&v67 + 1) = 0;
  BYTE5(v67) = 0;
  v69[0] = 0;
  v71 = 0u;
  *(_OWORD *)&v69[4] = 0u;
  v70 = 0u;
  DWORD1(v71) = 0x7FFFFFFF;
  BYTE6(v67) = v60;
  v68 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v54, v52, (uint64_t)v50, v48, 0, &v66, (uint64_t)&v61);
  v21 = v61;
  v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22[2] + 32))(v22[2], 960, 8);
  v24 = (void (***)(_QWORD))v23;
  if (v21)
  {
    v23 = re::MeshAsset::MeshAsset(v23, (uint64_t)&v61 + 8);
  }
  else
  {
    *(_QWORD *)v23 = &off_24ED30A60;
    *(_QWORD *)(v23 + 8) = 0;
    *(_QWORD *)(v23 + 16) = 0;
    *(_QWORD *)(v23 + 24) = 0;
    *(_DWORD *)(v23 + 32) = 0;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_DWORD *)(v23 + 72) = 0;
    *(_OWORD *)(v23 + 80) = 0u;
    *(_OWORD *)(v23 + 96) = 0u;
    *(_DWORD *)(v23 + 112) = 0;
    *(_OWORD *)(v23 + 120) = 0u;
    *(_OWORD *)(v23 + 136) = 0u;
    *(_DWORD *)(v23 + 152) = 0;
    *(_DWORD *)(v23 + 424) = 0;
    *(_OWORD *)(v23 + 392) = 0u;
    *(_OWORD *)(v23 + 408) = 0u;
    *(_OWORD *)(v23 + 484) = 0u;
    *(_OWORD *)(v23 + 472) = 0u;
    *(_OWORD *)(v23 + 456) = 0u;
    *(_DWORD *)(v23 + 192) = 0;
    *(_OWORD *)(v23 + 160) = 0u;
    *(_OWORD *)(v23 + 176) = 0u;
    *(_OWORD *)(v23 + 200) = 0u;
    *(_OWORD *)(v23 + 216) = 0u;
    *(_DWORD *)(v23 + 232) = 0;
    *(_OWORD *)(v23 + 240) = 0u;
    *(_OWORD *)(v23 + 256) = 0u;
    *(_DWORD *)(v23 + 272) = 0;
    *(_OWORD *)(v23 + 280) = 0u;
    *(_OWORD *)(v23 + 296) = 0u;
    *(_OWORD *)(v23 + 312) = 0u;
    *(_OWORD *)(v23 + 328) = 0u;
    *(_OWORD *)(v23 + 344) = 0u;
    *(_OWORD *)(v23 + 360) = 0u;
    *(_OWORD *)(v23 + 372) = 0u;
    *(_DWORD *)(v23 + 448) = 0;
    *(_QWORD *)(v23 + 432) = 0;
    *(_QWORD *)(v23 + 440) = 0;
    *(_QWORD *)(v23 + 500) = 0x7FFFFFFFLL;
    *(_DWORD *)(v23 + 544) = 0;
    *(_OWORD *)(v23 + 512) = 0u;
    *(_OWORD *)(v23 + 528) = 0u;
    *(_QWORD *)(v23 + 548) = 0x7FFFFFFFLL;
    *(_OWORD *)(v23 + 905) = 0u;
    *(_OWORD *)(v23 + 880) = 0u;
    *(_OWORD *)(v23 + 896) = 0u;
    *(_OWORD *)(v23 + 848) = 0u;
    *(_OWORD *)(v23 + 864) = 0u;
    *(_OWORD *)(v23 + 816) = 0u;
    *(_OWORD *)(v23 + 832) = 0u;
    *(_OWORD *)(v23 + 784) = 0u;
    *(_OWORD *)(v23 + 800) = 0u;
    *(_OWORD *)(v23 + 752) = 0u;
    *(_OWORD *)(v23 + 768) = 0u;
    *(_OWORD *)(v23 + 720) = 0u;
    *(_OWORD *)(v23 + 736) = 0u;
    *(_OWORD *)(v23 + 688) = 0u;
    *(_OWORD *)(v23 + 704) = 0u;
    *(_OWORD *)(v23 + 656) = 0u;
    *(_OWORD *)(v23 + 672) = 0u;
    *(_OWORD *)(v23 + 624) = 0u;
    *(_OWORD *)(v23 + 640) = 0u;
    *(_OWORD *)(v23 + 592) = 0u;
    *(_OWORD *)(v23 + 608) = 0u;
    *(_OWORD *)(v23 + 560) = 0u;
    *(_OWORD *)(v23 + 576) = 0u;
    *(_DWORD *)(v23 + 924) = 2;
    *(_QWORD *)(v23 + 928) = 0;
    *(_QWORD *)(v23 + 944) = 0;
    *(_QWORD *)(v23 + 936) = 0;
    *(_BYTE *)(v23 + 952) = 0;
  }
  v25 = a1[3];
  v26 = re::MeshAsset::assetType((re::MeshAsset *)v23);
  v27 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v25, (unint64_t)v26);
  v28 = re::MeshAsset::assetType(v27);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v46, 2056, a3, (const char *)*v28);
  v29 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v27 + 24))(v27, v24, 0, 0);
  if ((v29 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
    if ((*(_BYTE *)(a2 + 120) & 1) != 0)
      v31 = *(const char **)(a2 + 128);
    else
      v31 = (const char *)(a2 + 121);
    *(_QWORD *)&v45 = v24;
    BYTE8(v45) = 0;
    v36 = v42;
    v37 = v43;
    v38 = v44;
    *(_BYTE *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v45;
    *(_BYTE *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(_QWORD *)(a4 + 24) = v37;
    *(_QWORD *)(a4 + 32) = v38;
  }
  else
  {
    if (v24)
    {
      v32 = re::globalAllocators((re *)v29)[2];
      (**v24)(v24);
      v29 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v32 + 40))(v32, v24);
    }
    v33 = v42;
    v34 = v43;
    v35 = v44;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(_QWORD *)(a4 + 24) = v34;
    *(_QWORD *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v46);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v61);
  v41 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v69[4], v39);
  if (v47[0])
  {
    v40 = v50;
    if (v50)
      (*(void (**)(double))(*(_QWORD *)v47[0] + 40))(v41);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v51, v40);
}

__n128 `anonymous namespace'::PrimitiveProvider<BoxDescriptorParameters,re::GeomBuildBoxOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *`anonymous namespace'::PrimitiveProvider<BoxDescriptorParameters,re::GeomBuildBoxOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v5;
  const char *v6;
  re::DynamicString *result;
  uint64_t v8;
  char v9;
  _OWORD v10[2];
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int16 v15;
  char v16;
  char v17;
  char v18;

  v13 = 0x1000100010001;
  v14 = xmmword_2260F8390;
  v15 = 257;
  v16 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<BoxDescriptorParameters>(a2, (uint64_t **)&v13))
  {
    if (v17)
      v5 = " split";
    else
      v5 = "";
    if (v18)
      v6 = "";
    else
      v6 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)a1 + 120))(&v8, a1, &v13);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(_QWORD *)&v10[0])
    {
      if ((BYTE8(v10[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    result = (re::DynamicString *)v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v11 + 40))();
    }
  }
  else
  {
    v11 = "<mangled>";
    v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Box::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  const char *v2;
  const char *v3;
  const char *v4;

  v2 = "";
  if (*((_BYTE *)a1 + 24))
    v3 = "";
  else
    v3 = " noUV";
  if (*((_BYTE *)a1 + 25))
    v4 = "";
  else
    v4 = " noNorm";
  if (*((_BYTE *)a1 + 26))
    v2 = " merge";
  return re::DynamicString::format((re::DynamicString *)"%fx%fx%f; %dx%dx%d; r=%f/%d;%s%s%s",
           a2,
           *((float *)a1 + 3),
           *((float *)a1 + 4),
           *((float *)a1 + 5),
           *a1,
           a1[1],
           a1[2],
           *((float *)a1 + 2),
           a1[3],
           v3,
           v4,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<BoxDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FCA78);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FCA78);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FCA70 = re::internal::getOrCreateInfo((re::internal *)"BoxDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_BoxDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_BoxDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC9B8, 0);
      __cxa_guard_release(&qword_2540FCA78);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FCA70, v2, 0);
}

void BoxWithRoundedCorners::~BoxWithRoundedCorners(BoxWithRoundedCorners *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<BoxWithRoundedCornersDescriptorParameters,re::GeomBuildBoxWithRoundedCornersOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t `anonymous namespace'::PrimitiveProvider<BoxWithRoundedCornersDescriptorParameters,re::GeomBuildBoxWithRoundedCornersOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Introspectable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  __int128 v18;
  __int128 v19;
  re *v20;
  re *MeshAssetDataWithGeomMeshArray;
  int v22;
  uint64_t *v23;
  uint64_t v24;
  void (***v25)(_QWORD);
  uint64_t v26;
  uint64_t *v27;
  re::MeshAsset *v28;
  uint64_t *v29;
  uint64_t v30;
  _anonymous_namespace_ *v31;
  const char *v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  double v40;
  re::GeomAttribute *v41;
  double v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  __int128 v46;
  _BYTE v47[16];
  _QWORD v48[2];
  uint64_t v49;
  int v50;
  re::GeomAttribute *v51;
  _QWORD v52[2];
  uint64_t v53;
  int v54;
  re::GeomMesh *v55;
  uint64_t v56;
  __int16 v57;
  __int128 v58;
  int v59;
  int v60;
  __int16 v61;
  char v62;
  char v63;
  char v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  int v70;
  const char *v71;
  uint64_t v72;
  _BYTE v73[20];
  __int128 v74;
  __int128 v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v11 = *(_QWORD *)(a2 + 16);
    else
      v11 = a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v65, v10, v11);
    goto LABEL_17;
  }
  v56 = 0x3000100010001;
  v57 = 4;
  v58 = xmmword_2260F83A0;
  v59 = 1065353216;
  v60 = 16777473;
  v61 = 1;
  v62 = 0;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<BoxWithRoundedCornersDescriptorParameters>((re::AssetLoadDescriptor *)a2, (uint64_t **)&v56);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    v18 = v65;
    v19 = v66;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  v55 = 0;
  v52[1] = 0;
  v53 = 0;
  v51 = 0;
  v52[0] = 0;
  v54 = 0;
  v48[1] = 0;
  v49 = 0;
  v48[0] = 0;
  v50 = 0;
  if (v63)
  {
    re::buildBoxWithRoundedCorners((re::GeomMesh *)v52, (__int128 *)&v56);
    v13 = v53;
    re::DynamicArray<float>::resize((uint64_t)v48, v53);
    if (v13)
    {
      v14 = 0;
      v15 = v49;
      v16 = (uint64_t)v51;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14)
          goto LABEL_21;
      }
      *(_QWORD *)&v43 = 0;
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      v65 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v70 = 136315906;
      v71 = "operator[]";
      v72 = 0x800000003150400;
      *(_QWORD *)v73 = v15;
      *(_WORD *)&v73[8] = 2048;
      *(_QWORD *)&v73[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      *(_QWORD *)&v43 = 0;
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      v65 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v70 = 136315906;
      v71 = "operator[]";
      v72 = 0x800000003150400;
      *(_QWORD *)v73 = 0;
      *(_WORD *)&v73[8] = 2048;
      *(_QWORD *)&v73[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v52, 1uLL);
    LODWORD(v65) = 0;
    re::DynamicArray<unsigned int>::resize(v48, 1uLL, &v65);
    if (!v53)
      goto LABEL_37;
    v20 = v55;
  }
LABEL_21:
  v70 = 16842752;
  LOBYTE(v71) = 1;
  *(_DWORD *)((char *)&v71 + 1) = 0;
  BYTE5(v71) = 0;
  v73[0] = 0;
  v75 = 0u;
  *(_OWORD *)&v73[4] = 0u;
  v74 = 0u;
  DWORD1(v75) = 0x7FFFFFFF;
  BYTE6(v71) = v64;
  v72 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v55, v53, (uint64_t)v51, v49, 0, &v70, (uint64_t)&v65);
  v22 = v65;
  v23 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v23[2] + 32))(v23[2], 960, 8);
  v25 = (void (***)(_QWORD))v24;
  if (v22)
  {
    v24 = re::MeshAsset::MeshAsset(v24, (uint64_t)&v65 + 8);
  }
  else
  {
    *(_QWORD *)v24 = &off_24ED30A60;
    *(_QWORD *)(v24 + 8) = 0;
    *(_QWORD *)(v24 + 16) = 0;
    *(_QWORD *)(v24 + 24) = 0;
    *(_DWORD *)(v24 + 32) = 0;
    *(_OWORD *)(v24 + 40) = 0u;
    *(_OWORD *)(v24 + 56) = 0u;
    *(_DWORD *)(v24 + 72) = 0;
    *(_OWORD *)(v24 + 80) = 0u;
    *(_OWORD *)(v24 + 96) = 0u;
    *(_DWORD *)(v24 + 112) = 0;
    *(_OWORD *)(v24 + 120) = 0u;
    *(_OWORD *)(v24 + 136) = 0u;
    *(_DWORD *)(v24 + 152) = 0;
    *(_DWORD *)(v24 + 424) = 0;
    *(_OWORD *)(v24 + 392) = 0u;
    *(_OWORD *)(v24 + 408) = 0u;
    *(_OWORD *)(v24 + 484) = 0u;
    *(_OWORD *)(v24 + 472) = 0u;
    *(_OWORD *)(v24 + 456) = 0u;
    *(_DWORD *)(v24 + 192) = 0;
    *(_OWORD *)(v24 + 160) = 0u;
    *(_OWORD *)(v24 + 176) = 0u;
    *(_OWORD *)(v24 + 200) = 0u;
    *(_OWORD *)(v24 + 216) = 0u;
    *(_DWORD *)(v24 + 232) = 0;
    *(_OWORD *)(v24 + 240) = 0u;
    *(_OWORD *)(v24 + 256) = 0u;
    *(_DWORD *)(v24 + 272) = 0;
    *(_OWORD *)(v24 + 280) = 0u;
    *(_OWORD *)(v24 + 296) = 0u;
    *(_OWORD *)(v24 + 312) = 0u;
    *(_OWORD *)(v24 + 328) = 0u;
    *(_OWORD *)(v24 + 344) = 0u;
    *(_OWORD *)(v24 + 360) = 0u;
    *(_OWORD *)(v24 + 372) = 0u;
    *(_DWORD *)(v24 + 448) = 0;
    *(_QWORD *)(v24 + 432) = 0;
    *(_QWORD *)(v24 + 440) = 0;
    *(_QWORD *)(v24 + 500) = 0x7FFFFFFFLL;
    *(_DWORD *)(v24 + 544) = 0;
    *(_OWORD *)(v24 + 512) = 0u;
    *(_OWORD *)(v24 + 528) = 0u;
    *(_QWORD *)(v24 + 548) = 0x7FFFFFFFLL;
    *(_OWORD *)(v24 + 905) = 0u;
    *(_OWORD *)(v24 + 880) = 0u;
    *(_OWORD *)(v24 + 896) = 0u;
    *(_OWORD *)(v24 + 848) = 0u;
    *(_OWORD *)(v24 + 864) = 0u;
    *(_OWORD *)(v24 + 816) = 0u;
    *(_OWORD *)(v24 + 832) = 0u;
    *(_OWORD *)(v24 + 784) = 0u;
    *(_OWORD *)(v24 + 800) = 0u;
    *(_OWORD *)(v24 + 752) = 0u;
    *(_OWORD *)(v24 + 768) = 0u;
    *(_OWORD *)(v24 + 720) = 0u;
    *(_OWORD *)(v24 + 736) = 0u;
    *(_OWORD *)(v24 + 688) = 0u;
    *(_OWORD *)(v24 + 704) = 0u;
    *(_OWORD *)(v24 + 656) = 0u;
    *(_OWORD *)(v24 + 672) = 0u;
    *(_OWORD *)(v24 + 624) = 0u;
    *(_OWORD *)(v24 + 640) = 0u;
    *(_OWORD *)(v24 + 592) = 0u;
    *(_OWORD *)(v24 + 608) = 0u;
    *(_OWORD *)(v24 + 560) = 0u;
    *(_OWORD *)(v24 + 576) = 0u;
    *(_DWORD *)(v24 + 924) = 2;
    *(_QWORD *)(v24 + 928) = 0;
    *(_QWORD *)(v24 + 944) = 0;
    *(_QWORD *)(v24 + 936) = 0;
    *(_BYTE *)(v24 + 952) = 0;
  }
  v26 = a1[3];
  v27 = re::MeshAsset::assetType((re::MeshAsset *)v24);
  v28 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v26, (unint64_t)v27);
  v29 = re::MeshAsset::assetType(v28);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v47, 2056, a3, (const char *)*v29);
  v30 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v28 + 24))(v28, v25, 0, 0);
  if ((v30 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v47);
    if ((*(_BYTE *)(a2 + 120) & 1) != 0)
      v32 = *(const char **)(a2 + 128);
    else
      v32 = (const char *)(a2 + 121);
    *(_QWORD *)&v46 = v25;
    BYTE8(v46) = 0;
    v37 = v43;
    v38 = v44;
    v39 = v45;
    *(_BYTE *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v46;
    *(_BYTE *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v37;
    *(_QWORD *)(a4 + 24) = v38;
    *(_QWORD *)(a4 + 32) = v39;
  }
  else
  {
    if (v25)
    {
      v33 = re::globalAllocators((re *)v30)[2];
      (**v25)(v25);
      v30 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v33 + 40))(v33, v25);
    }
    v34 = v43;
    v35 = v44;
    v36 = v45;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v34;
    *(_QWORD *)(a4 + 24) = v35;
    *(_QWORD *)(a4 + 32) = v36;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v47);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v65);
  v42 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v73[4], v40);
  if (v48[0])
  {
    v41 = v51;
    if (v51)
      (*(void (**)(double))(*(_QWORD *)v48[0] + 40))(v42);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v52, v41);
}

__n128 `anonymous namespace'::PrimitiveProvider<BoxWithRoundedCornersDescriptorParameters,re::GeomBuildBoxWithRoundedCornersOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *`anonymous namespace'::PrimitiveProvider<BoxWithRoundedCornersDescriptorParameters,re::GeomBuildBoxWithRoundedCornersOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v5;
  const char *v6;
  re::DynamicString *result;
  uint64_t v8;
  char v9;
  _OWORD v10[2];
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  __int16 v14;
  __int128 v15;
  int v16;
  int v17;
  __int16 v18;
  char v19;
  char v20;
  char v21;

  v13 = 0x3000100010001;
  v14 = 4;
  v15 = xmmword_2260F83A0;
  v16 = 1065353216;
  v17 = 16777473;
  v18 = 1;
  v19 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<BoxWithRoundedCornersDescriptorParameters>(a2, (uint64_t **)&v13))
  {
    if (v20)
      v5 = " split";
    else
      v5 = "";
    if (v21)
      v6 = "";
    else
      v6 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)a1 + 120))(&v8, a1, &v13);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(_QWORD *)&v10[0])
    {
      if ((BYTE8(v10[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    result = (re::DynamicString *)v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v11 + 40))();
    }
  }
  else
  {
    v11 = "<mangled>";
    v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t BoxWithRoundedCorners::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;

  v2 = "";
  if (*((_BYTE *)a1 + 35))
    v3 = "";
  else
    v3 = " disCorner";
  if (*((_BYTE *)a1 + 36))
    v4 = "";
  else
    v4 = "noClamp";
  if (*((_BYTE *)a1 + 37))
    v5 = " normUV";
  else
    v5 = "";
  v6 = " reflUV";
  if (!*((_BYTE *)a1 + 38))
    v6 = "";
  if (*((_BYTE *)a1 + 32))
    v7 = "";
  else
    v7 = " noUV";
  if (*((_BYTE *)a1 + 33))
    v8 = "";
  else
    v8 = " noNorm";
  if (*((_BYTE *)a1 + 34))
    v2 = " merge";
  return re::DynamicString::format((re::DynamicString *)"%fx%fx%f; %dx%dx%d; %f/%d; %f/%d;%s%s%s%s%s%s%s",
           a2,
           *((float *)a1 + 5),
           *((float *)a1 + 6),
           *((float *)a1 + 7),
           *a1,
           a1[1],
           a1[2],
           *((float *)a1 + 3),
           a1[3],
           *((float *)a1 + 4),
           a1[4],
           v3,
           v4,
           v5,
           v6,
           v7,
           v8,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<BoxWithRoundedCornersDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FCA88);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FCA88);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FCA80 = re::internal::getOrCreateInfo((re::internal *)"BoxWithRoundedCornersDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_BoxWithRoundedCornersDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_BoxWithRoundedCornersDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC9D0, 0);
      __cxa_guard_release(&qword_2540FCA88);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FCA80, v2, 0);
}

void ExtrudedText::~ExtrudedText(ExtrudedText *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PrimitiveProvider<ExtrudedTextDescriptorParameters,re::GeomBuildExtrudedTextOptions>::schemeName(uint64_t a1)
{
  return **(_QWORD **)(a1 + 32);
}

uint64_t ExtrudedText::load@<X0>(ExtrudedText *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, const re::CancellationToken *a4@<X4>, uint64_t a5@<X2>, uint64_t a6@<X8>)
{
  const char *v10;
  const char *v11;
  _anonymous_namespace_ *v12;
  uint64_t v13;
  char *v14;
  _anonymous_namespace_ *v15;
  uint64_t Introspectable;
  re::MeshAsset *Asset;
  uint64_t v23;
  uint64_t *v24;
  re::MeshAsset *v25;
  uint64_t *v26;
  uint64_t v27;
  _anonymous_namespace_ *v28;
  const char *v29;
  uint64_t result;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  _BYTE v45[16];
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  __int16 v56;
  int v57;
  char v58;
  unsigned __int8 v59;
  char v60;

  if ((*((_BYTE *)a2 + 8) & 1) != 0)
    v10 = (const char *)*((_QWORD *)a2 + 2);
  else
    v10 = (char *)a2 + 9;
  v11 = (const char *)(*(uint64_t (**)(ExtrudedText *))(*(_QWORD *)this + 32))(this);
  v12 = (_anonymous_namespace_ *)strcmp(v10, v11);
  if ((_DWORD)v12)
  {
    v13 = (*(uint64_t (**)(ExtrudedText *))(*(_QWORD *)this + 32))(this);
    if ((*((_BYTE *)a2 + 8) & 1) != 0)
      v14 = (char *)*((_QWORD *)a2 + 2);
    else
      v14 = (char *)a2 + 9;
    result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v46, v13, v14);
    v31 = v46;
    v32 = v47;
    v33 = v48;
    *(_BYTE *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v31;
    *(_QWORD *)(a6 + 24) = v32;
    *(_QWORD *)(a6 + 32) = v33;
    return result;
  }
  *((_QWORD *)&v46 + 1) = 0;
  v47 = 0;
  v48 = 0;
  v15 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v46, 0);
  *((_QWORD *)&v49 + 1) = 0;
  v50 = 0uLL;
  re::DynamicString::setCapacity(&v49, 0);
  __asm { FMOV            V0.2S, #1.0 }
  v51 = _D0;
  v52 = 5;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 4;
  v57 = 16843009;
  v58 = 0;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<ExtrudedTextDescriptorParameters>(a2, (uint64_t **)&v46);
  if ((Introspectable & 1) != 0)
  {
    Asset = (re::MeshAsset *)re::MeshPrimitiveProvider::makeAsset((re::MeshPrimitiveProvider *)&v46, (const re::GeomBuildExtrudedTextOptions *)v59, v60);
    v23 = *((_QWORD *)this + 3);
    v24 = re::MeshAsset::assetType(Asset);
    v25 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v23, (unint64_t)v24);
    v26 = re::MeshAsset::assetType(v25);
    re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v45, 2056, a5, (const char *)*v26);
    v27 = (*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, _QWORD, _QWORD))(*(_QWORD *)v25 + 24))(v25, Asset, 0, 0);
    if ((v27 & 1) == 0)
    {
      if (Asset)
      {
        v37 = re::globalAllocators((re *)v27)[2];
        (**(void (***)(re::MeshAsset *))Asset)(Asset);
        v27 = (*(uint64_t (**)(uint64_t, re::MeshAsset *))(*(_QWORD *)v37 + 40))(v37, Asset);
      }
      v38 = v41;
      v39 = v42;
      v40 = v43;
      *(_BYTE *)a6 = 0;
      *(_OWORD *)(a6 + 8) = v38;
      *(_QWORD *)(a6 + 24) = v39;
      *(_QWORD *)(a6 + 32) = v40;
      re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v45);
      goto LABEL_21;
    }
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v45);
    if ((*((_BYTE *)a2 + 120) & 1) != 0)
      v29 = (const char *)*((_QWORD *)a2 + 16);
    else
      v29 = (char *)a2 + 121;
    *(_QWORD *)&v44 = Asset;
    BYTE8(v44) = 0;
    v34 = v41;
    v35 = v42;
    v36 = v43;
    *(_BYTE *)(a6 + 56) = 0;
    *(_OWORD *)(a6 + 40) = v44;
    *(_BYTE *)a6 = 1;
  }
  else
  {
    v34 = v41;
    v35 = v42;
    v36 = v43;
    *(_BYTE *)a6 = 0;
  }
  *(_OWORD *)(a6 + 8) = v34;
  *(_QWORD *)(a6 + 24) = v35;
  *(_QWORD *)(a6 + 32) = v36;
LABEL_21:
  if ((_QWORD)v49)
  {
    if ((BYTE8(v49) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v49 + 40))();
    v49 = 0u;
    v50 = 0u;
  }
  result = v46;
  if ((_QWORD)v46 && (BYTE8(v46) & 1) != 0)
    return (*(uint64_t (**)(void))(*(_QWORD *)v46 + 40))();
  return result;
}

__n128 `anonymous namespace'::PrimitiveProvider<ExtrudedTextDescriptorParameters,re::GeomBuildExtrudedTextOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

uint64_t *`anonymous namespace'::PrimitiveProvider<ExtrudedTextDescriptorParameters,re::GeomBuildExtrudedTextOptions>::getDescription(_anonymous_namespace_ *a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  _anonymous_namespace_ *v6;
  const char *v12;
  const char *v13;
  uint64_t *result;
  uint64_t v15;
  char v16;
  _OWORD v17[2];
  const char *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  __int16 v31;
  int v32;
  char v33;
  char v34;
  char v35;

  v21 = 0;
  v22 = 0;
  v23 = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v20, 0);
  *((_QWORD *)&v24 + 1) = 0;
  v25 = 0uLL;
  re::DynamicString::setCapacity(&v24, 0);
  __asm { FMOV            V0.2S, #1.0 }
  v26 = _D0;
  v27 = 5;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 4;
  v32 = 16843009;
  v33 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<ExtrudedTextDescriptorParameters>(a2, &v20))
  {
    if (v34)
      v12 = " split";
    else
      v12 = "";
    if (v35)
      v13 = "";
    else
      v13 = " full";
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v18, v12, v13);
    (*(void (**)(uint64_t *__return_ptr, _anonymous_namespace_ *, uint64_t **))(*(_QWORD *)a1 + 120))(&v15, a1, &v20);
    re::DynamicString::operator+((re::DynamicString *)&v15, (uint64_t)&v18, (re::DynamicString *)v17);
    re::DynamicString::operator=(a3, (re::DynamicString *)v17);
    if (*(_QWORD *)&v17[0])
    {
      if ((BYTE8(v17[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v17[0] + 40))();
      memset(v17, 0, sizeof(v17));
    }
    if (v15 && (v16 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v15 + 40))();
    if (v18 && (v19 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v18 + 40))();
  }
  else
  {
    v18 = "<mangled>";
    v19 = 9;
    re::DynamicString::operator=(a3, (uint64_t)&v18);
  }
  if ((_QWORD)v24)
  {
    if ((BYTE8(v24) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v24 + 40))();
    v24 = 0u;
    v25 = 0u;
  }
  result = v20;
  if (v20)
  {
    if ((v21 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v20 + 40))();
  }
  return result;
}

uint64_t ExtrudedText::describe@<X0>(const re::GeomBuildExtrudedTextOptions *a1@<X1>, re::DynamicString *a2@<X8>)
{
  unint64_t v3;
  char *v4;
  unint64_t v5;
  char *v6;
  unint64_t v7;
  char *v8;
  char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  const char *v14;
  char *v15;

  v3 = *((char *)a1 + 96);
  if (v3 > 5)
    v4 = 0;
  else
    v4 = off_24ED2FA98[v3];
  v5 = *((char *)a1 + 97);
  if (v5 > 4)
    v6 = 0;
  else
    v6 = off_24ED2FAC8[v5];
  v7 = *((char *)a1 + 98);
  if (v7 > 2)
    v8 = 0;
  else
    v8 = off_24ED2FAF0[v7];
  if ((*((_QWORD *)a1 + 5) & 1) != 0)
    v9 = (char *)*((_QWORD *)a1 + 6);
  else
    v9 = (char *)a1 + 41;
  v10 = "";
  if (*((_BYTE *)a1 + 99))
    v11 = "";
  else
    v11 = " noSides";
  if (*((_BYTE *)a1 + 100))
    v12 = "";
  else
    v12 = " noBack";
  v13 = " noUV";
  if (*((_BYTE *)a1 + 101))
    v13 = "";
  if (*((_BYTE *)a1 + 102))
    v14 = "";
  else
    v14 = " noNorm";
  if ((*((_QWORD *)a1 + 1) & 1) != 0)
    v15 = (char *)*((_QWORD *)a1 + 2);
  else
    v15 = (char *)a1 + 9;
  if (*((_BYTE *)a1 + 103))
    v10 = "instanceGlyphs";
  return re::DynamicString::format((re::DynamicString *)"%s;%fx%f/%d;(%f,%f)x(%f,%f);%s;%s;%s;%s%s%s%s;%s;%s",
           a2,
           v9,
           *((float *)a1 + 16),
           *((float *)a1 + 17),
           *((unsigned __int8 *)a1 + 72),
           *((float *)a1 + 20),
           *((float *)a1 + 21),
           *((float *)a1 + 22),
           *((float *)a1 + 23),
           v4,
           v6,
           v8,
           v11,
           v12,
           v13,
           v14,
           v15,
           v10);
}

uint64_t *`anonymous namespace'::PrimitiveProvider<ExtrudedTextDescriptorParameters,re::GeomBuildExtrudedTextOptions>::load@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v8;
  const char *v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  uint64_t v12;
  _anonymous_namespace_ *v13;
  uint64_t Introspectable;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *result;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  re::GeomBuildExtrudedTextSupport *v29;
  re *MeshAssetDataWithGeomMeshArray;
  int v31;
  uint64_t *v32;
  uint64_t v33;
  void (***v34)(_QWORD);
  uint64_t v35;
  uint64_t *v36;
  re::MeshAsset *v37;
  uint64_t *v38;
  uint64_t v39;
  _anonymous_namespace_ *v40;
  const char *v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  double v49;
  re::GeomAttribute *v50;
  double v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  __int128 v55;
  _BYTE v56[16];
  _QWORD v57[2];
  uint64_t v58;
  int v59;
  re::GeomAttribute *v60;
  _QWORD v61[2];
  uint64_t v62;
  int v63;
  re *v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  char v75;
  __int16 v76;
  int v77;
  char v78;
  char v79;
  char v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  int v86;
  const char *v87;
  uint64_t v88;
  _BYTE v89[20];
  __int128 v90;
  __int128 v91;
  uint64_t v92;

  v92 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    v8 = *(const char **)(a2 + 16);
  else
    v8 = (const char *)(a2 + 9);
  v9 = (const char *)(*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  v10 = (_anonymous_namespace_ *)strcmp(v8, v9);
  if ((_DWORD)v10)
  {
    v11 = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v12 = *(_QWORD *)(a2 + 16);
    else
      v12 = a2 + 9;
    result = (uint64_t *)re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v81, v11, v12);
    v25 = v81;
    v26 = v82;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v25;
    *(_OWORD *)(a4 + 24) = v26;
    return result;
  }
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v65, 0);
  *((_QWORD *)&v69 + 1) = 0;
  v70 = 0uLL;
  re::DynamicString::setCapacity(&v69, 0);
  __asm { FMOV            V0.2S, #1.0 }
  v71 = _D0;
  v72 = 5;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 4;
  v77 = 16843009;
  v78 = 0;
  Introspectable = re::AssetLoadDescriptor::getIntrospectableData<ExtrudedTextDescriptorParameters>((re::AssetLoadDescriptor *)a2, &v65);
  if ((Introspectable & 1) != 0)
  {
    v64 = 0;
    v61[1] = 0;
    v62 = 0;
    v60 = 0;
    v61[0] = 0;
    v63 = 0;
    v57[1] = 0;
    v58 = 0;
    v57[0] = 0;
    v59 = 0;
    if (v79)
    {
      re::buildExtrudedText((_anonymous_namespace_ *)v61, (uint64_t)&v65, 0);
      v20 = v62;
      re::DynamicArray<float>::resize((uint64_t)v57, v62);
      if (v20)
      {
        v21 = 0;
        v22 = v58;
        v23 = (uint64_t)v60;
        while (v22 != v21)
        {
          *(_DWORD *)(v23 + 4 * v21) = v21;
          if (v20 == ++v21)
            goto LABEL_20;
        }
        *(_QWORD *)&v52 = 0;
        v84 = 0u;
        v85 = 0u;
        v82 = 0u;
        v83 = 0u;
        v81 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v86 = 136315906;
        v87 = "operator[]";
        v88 = 0x800000003150400;
        *(_QWORD *)v89 = v22;
        *(_WORD *)&v89[8] = 2048;
        *(_QWORD *)&v89[10] = v22;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_43:
        *(_QWORD *)&v52 = 0;
        v84 = 0u;
        v85 = 0u;
        v82 = 0u;
        v83 = 0u;
        v81 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v86 = 136315906;
        v87 = "operator[]";
        v88 = 0x800000003150400;
        *(_QWORD *)v89 = 0;
        *(_WORD *)&v89[8] = 2048;
        *(_QWORD *)&v89[10] = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
    }
    else
    {
      re::DynamicArray<re::GeomMesh>::resize((uint64_t)v61, 1uLL);
      LODWORD(v81) = 0;
      re::DynamicArray<unsigned int>::resize(v57, 1uLL, &v81);
      if (!v62)
        goto LABEL_43;
      re::buildExtrudedText(v64, (re::GeomMesh *)&v65, 0, v29);
    }
LABEL_20:
    v86 = 16842752;
    LOBYTE(v87) = 1;
    *(_DWORD *)((char *)&v87 + 1) = 0;
    BYTE5(v87) = 0;
    v89[0] = 0;
    v91 = 0u;
    *(_OWORD *)&v89[4] = 0u;
    v90 = 0u;
    DWORD1(v91) = 0x7FFFFFFF;
    BYTE6(v87) = v80;
    v88 = 0x10101003F800000;
    MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v64, v62, (uint64_t)v60, v58, 0, &v86, (uint64_t)&v81);
    v31 = v81;
    v32 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
    v33 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v32[2] + 32))(v32[2], 960, 8);
    v34 = (void (***)(_QWORD))v33;
    if (v31)
    {
      v33 = re::MeshAsset::MeshAsset(v33, (uint64_t)&v81 + 8);
    }
    else
    {
      *(_QWORD *)v33 = &off_24ED30A60;
      *(_QWORD *)(v33 + 8) = 0;
      *(_QWORD *)(v33 + 16) = 0;
      *(_QWORD *)(v33 + 24) = 0;
      *(_DWORD *)(v33 + 32) = 0;
      *(_OWORD *)(v33 + 40) = 0u;
      *(_OWORD *)(v33 + 56) = 0u;
      *(_DWORD *)(v33 + 72) = 0;
      *(_OWORD *)(v33 + 80) = 0u;
      *(_OWORD *)(v33 + 96) = 0u;
      *(_DWORD *)(v33 + 112) = 0;
      *(_OWORD *)(v33 + 120) = 0u;
      *(_OWORD *)(v33 + 136) = 0u;
      *(_DWORD *)(v33 + 152) = 0;
      *(_DWORD *)(v33 + 424) = 0;
      *(_OWORD *)(v33 + 392) = 0u;
      *(_OWORD *)(v33 + 408) = 0u;
      *(_OWORD *)(v33 + 484) = 0u;
      *(_OWORD *)(v33 + 472) = 0u;
      *(_OWORD *)(v33 + 456) = 0u;
      *(_DWORD *)(v33 + 192) = 0;
      *(_OWORD *)(v33 + 160) = 0u;
      *(_OWORD *)(v33 + 176) = 0u;
      *(_OWORD *)(v33 + 200) = 0u;
      *(_OWORD *)(v33 + 216) = 0u;
      *(_DWORD *)(v33 + 232) = 0;
      *(_OWORD *)(v33 + 240) = 0u;
      *(_OWORD *)(v33 + 256) = 0u;
      *(_DWORD *)(v33 + 272) = 0;
      *(_OWORD *)(v33 + 280) = 0u;
      *(_OWORD *)(v33 + 296) = 0u;
      *(_OWORD *)(v33 + 312) = 0u;
      *(_OWORD *)(v33 + 328) = 0u;
      *(_OWORD *)(v33 + 344) = 0u;
      *(_OWORD *)(v33 + 360) = 0u;
      *(_OWORD *)(v33 + 372) = 0u;
      *(_DWORD *)(v33 + 448) = 0;
      *(_QWORD *)(v33 + 432) = 0;
      *(_QWORD *)(v33 + 440) = 0;
      *(_QWORD *)(v33 + 500) = 0x7FFFFFFFLL;
      *(_DWORD *)(v33 + 544) = 0;
      *(_OWORD *)(v33 + 512) = 0u;
      *(_OWORD *)(v33 + 528) = 0u;
      *(_QWORD *)(v33 + 548) = 0x7FFFFFFFLL;
      *(_OWORD *)(v33 + 905) = 0u;
      *(_OWORD *)(v33 + 880) = 0u;
      *(_OWORD *)(v33 + 896) = 0u;
      *(_OWORD *)(v33 + 848) = 0u;
      *(_OWORD *)(v33 + 864) = 0u;
      *(_OWORD *)(v33 + 816) = 0u;
      *(_OWORD *)(v33 + 832) = 0u;
      *(_OWORD *)(v33 + 784) = 0u;
      *(_OWORD *)(v33 + 800) = 0u;
      *(_OWORD *)(v33 + 752) = 0u;
      *(_OWORD *)(v33 + 768) = 0u;
      *(_OWORD *)(v33 + 720) = 0u;
      *(_OWORD *)(v33 + 736) = 0u;
      *(_OWORD *)(v33 + 688) = 0u;
      *(_OWORD *)(v33 + 704) = 0u;
      *(_OWORD *)(v33 + 656) = 0u;
      *(_OWORD *)(v33 + 672) = 0u;
      *(_OWORD *)(v33 + 624) = 0u;
      *(_OWORD *)(v33 + 640) = 0u;
      *(_OWORD *)(v33 + 592) = 0u;
      *(_OWORD *)(v33 + 608) = 0u;
      *(_OWORD *)(v33 + 560) = 0u;
      *(_OWORD *)(v33 + 576) = 0u;
      *(_DWORD *)(v33 + 924) = 2;
      *(_QWORD *)(v33 + 928) = 0;
      *(_QWORD *)(v33 + 944) = 0;
      *(_QWORD *)(v33 + 936) = 0;
      *(_BYTE *)(v33 + 952) = 0;
    }
    v35 = a1[3];
    v36 = re::MeshAsset::assetType((re::MeshAsset *)v33);
    v37 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v35, (unint64_t)v36);
    v38 = re::MeshAsset::assetType(v37);
    re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v56, 2056, a3, (const char *)*v38);
    v39 = (*(uint64_t (**)(re::MeshAsset *, void (***)(_QWORD), _QWORD, _QWORD))(*(_QWORD *)v37 + 24))(v37, v34, 0, 0);
    if ((v39 & 1) != 0)
    {
      re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v56);
      if ((*(_BYTE *)(a2 + 120) & 1) != 0)
        v41 = *(const char **)(a2 + 128);
      else
        v41 = (const char *)(a2 + 121);
      *(_QWORD *)&v55 = v34;
      BYTE8(v55) = 0;
      v46 = v52;
      v47 = v53;
      v48 = v54;
      *(_BYTE *)(a4 + 56) = 0;
      *(_OWORD *)(a4 + 40) = v55;
      *(_BYTE *)a4 = 1;
      *(_OWORD *)(a4 + 8) = v46;
      *(_QWORD *)(a4 + 24) = v47;
      *(_QWORD *)(a4 + 32) = v48;
    }
    else
    {
      if (v34)
      {
        v42 = re::globalAllocators((re *)v39)[2];
        (**v34)(v34);
        v39 = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v42 + 40))(v42, v34);
      }
      v43 = v52;
      v44 = v53;
      v45 = v54;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v43;
      *(_QWORD *)(a4 + 24) = v44;
      *(_QWORD *)(a4 + 32) = v45;
      re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v56);
    }
    re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v81);
    v51 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v89[4], v49);
    if (v57[0])
    {
      v50 = v60;
      if (v60)
        (*(void (**)(double))(*(_QWORD *)v57[0] + 40))(v51);
    }
    re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v61, v50);
  }
  else
  {
    v27 = v81;
    v28 = v82;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v27;
    *(_OWORD *)(a4 + 24) = v28;
  }
  if ((_QWORD)v69)
  {
    if ((BYTE8(v69) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v69 + 40))();
    v69 = 0u;
    v70 = 0u;
  }
  result = v65;
  if (v65 && (v66 & 1) != 0)
    return (uint64_t *)(*(uint64_t (**)(void))(*v65 + 40))();
  return result;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<ExtrudedTextDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  re::AssetLoadDescriptor *v5;
  int v7;
  int v8;

  v2 = a2;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FCA98);
  if ((v3 & 1) == 0)
  {
    v5 = a1;
    v7 = __cxa_guard_acquire(&qword_2540FCA98);
    v2 = a2;
    v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_2540FCA90 = re::internal::getOrCreateInfo((re::internal *)"ExtrudedTextDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_ExtrudedTextDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_ExtrudedTextDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_2540FC9E8, 0);
      __cxa_guard_release(&qword_2540FCA98);
      a1 = v5;
      v2 = a2;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)qword_2540FCA90, v2, 0);
}

uint64_t *re::allocInfo_RealityFileAssetLoadDescriptorParameters(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_58);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_58))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FD0F0, 0);
    *(uint64_t *)((char *)&qword_2540FD100 + 6) = 0;
    qword_2540FD100 = 0;
    qword_2540FD110 = 0;
    qword_2540FD118 = 0xFFFFFFFFLL;
    qword_2540FD0F0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FD120 = (uint64_t)"RealityFileAssetLoadDescriptorParameters";
    dword_2540FD128 = 0;
    xmmword_2540FD130 = 0u;
    unk_2540FD140 = 0u;
    xmmword_2540FD150 = 0u;
    qword_2540FD160 = 0;
    __cxa_guard_release(&_MergedGlobals_58);
  }
  return &qword_2540FD0F0;
}

void re::initInfo_RealityFileAssetLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  const re::IntrospectionBase *v10;
  void *v11;
  uint64_t v12;
  __int128 v13;
  _QWORD v14[2];
  __int128 v15;

  v14[0] = 0xB2FC42FECB8E66C6;
  v14[1] = "RealityFileAssetLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FD0D8);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FD0D8);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v7 = re::introspect_RealityFileDescriptor((re::IntrospectionBase **)1);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "realityFileDescriptor";
      *(_QWORD *)(v8 + 16) = v7;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_2540FD0E0 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v11 = re::IntrospectionInfo<re::DynamicString>::get(1, v10);
      v12 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 72, 8);
      *(_DWORD *)v12 = 1;
      *(_QWORD *)(v12 + 8) = "archiveEntrySpecifier";
      *(_QWORD *)(v12 + 16) = v11;
      *(_QWORD *)(v12 + 24) = 0;
      *(_QWORD *)(v12 + 32) = 0x4800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(_QWORD *)(v12 + 48) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_2540FD0E8 = v12;
      __cxa_guard_release(&qword_2540FD0D8);
    }
  }
  *((_QWORD *)this + 2) = 0x7800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_2540FD0E0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::RealityFileAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::RealityFileAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::RealityFileAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::RealityFileAssetLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  v13 = v15;
}

_QWORD *re::internal::defaultConstruct<re::RealityFileAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;
  _QWORD *result;

  v3 = a3;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 8) = 0u;
  v4 = (_QWORD *)(a3 + 8);
  v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v4, 0);
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)(v3 + 40), 0);
  *(_OWORD *)(v3 + 72) = 0u;
  v3 += 72;
  *(_OWORD *)(v3 + 16) = 0u;
  result = re::DynamicString::setCapacity((_QWORD *)v3, 0);
  *(_BYTE *)(v3 + 32) = 0;
  *(_QWORD *)(v3 + 40) = 1;
  return result;
}

double re::internal::defaultDestruct<re::RealityFileAssetLoadDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _OWORD *v5;
  double result;
  uint64_t v7;
  uint64_t v8;

  v5 = (_OWORD *)(a3 + 72);
  v4 = *(_QWORD *)(a3 + 72);
  if (v4)
  {
    if ((*(_BYTE *)(a3 + 80) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a3 + 88));
    result = 0.0;
    *v5 = 0u;
    v5[1] = 0u;
  }
  v7 = *(_QWORD *)(a3 + 40);
  if (v7)
  {
    if ((*(_BYTE *)(a3 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *(_QWORD *)(a3 + 56));
    result = 0.0;
    *(_OWORD *)(a3 + 40) = 0u;
    *(_OWORD *)(a3 + 56) = 0u;
  }
  v8 = *(_QWORD *)(a3 + 8);
  if (v8)
  {
    if ((*(_BYTE *)(a3 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *(_QWORD *)(a3 + 24));
    result = 0.0;
    *(_OWORD *)(a3 + 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::RealityFileAssetLoadDescriptorParameters>(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  _anonymous_namespace_ *v3;
  _anonymous_namespace_ *v4;
  _QWORD *result;

  v1 = a1;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  v2 = (_QWORD *)(a1 + 8);
  v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v2, 0);
  *(_OWORD *)(v1 + 56) = 0u;
  *(_OWORD *)(v1 + 40) = 0u;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)(v1 + 40), 0);
  *(_OWORD *)(v1 + 72) = 0u;
  v1 += 72;
  *(_OWORD *)(v1 + 16) = 0u;
  result = re::DynamicString::setCapacity((_QWORD *)v1, 0);
  *(_BYTE *)(v1 + 32) = 0;
  *(_QWORD *)(v1 + 40) = 1;
  return result;
}

double re::internal::defaultDestructV2<re::RealityFileAssetLoadDescriptorParameters>(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;
  uint64_t v5;
  uint64_t v6;

  v3 = (_OWORD *)(a1 + 72);
  v2 = *(_QWORD *)(a1 + 72);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 80) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 88));
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  v5 = *(_QWORD *)(a1 + 40);
  if (v5)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a1 + 56));
    result = 0.0;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    if ((*(_BYTE *)(a1 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(_QWORD *)(a1 + 24));
    result = 0.0;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
  }
  return result;
}

uint64_t re::introspect_RealityFileAssetLoadDescriptorParameters(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RealityFileAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_RealityFileAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_RealityFileAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RealityFileAssetLoadDescriptorParameters>, this);
}

size_t re::RealityFileAssetLoadDescriptorFactory::make@<X0>(char *a1@<X0>, re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  _anonymous_namespace_ *v6;
  const re::IntrospectionBase *v8;
  _QWORD v9[4];
  _QWORD v10[4];
  _QWORD v11[4];
  __int128 v12;
  const char *v13;
  uint64_t v14;

  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a3, 0);
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_DWORD *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(_QWORD *)(a3 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a3 + 112), 0);
  v13 = "RealityFileAsset";
  v14 = 16;
  re::DynamicString::operator=((re::DynamicString *)a3, (uint64_t)&v13);
  re::DynamicString::operator=((re::DynamicString *)(a3 + 112), a2);
  LOBYTE(v8) = *a1;
  re::DynamicString::DynamicString((re::DynamicString *)v9, (const re::DynamicString *)(a1 + 8));
  re::DynamicString::DynamicString((re::DynamicString *)v10, (const re::DynamicString *)(a1 + 40));
  re::DynamicString::DynamicString((re::DynamicString *)v11, (const re::DynamicString *)(a1 + 72));
  v12 = *(_OWORD *)(a1 + 104);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a3, (const re::IntrospectionBase *)re::RealityFileAssetProvider::s_loadDescriptorParametersIntrospect, &v8, 0);
  if (v11[0])
  {
    if ((v11[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v11[0] + 40))();
    memset(v11, 0, sizeof(v11));
  }
  if (v10[0])
  {
    if ((v10[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v10[0] + 40))();
    memset(v10, 0, sizeof(v10));
  }
  if (v9[0])
  {
    if ((v9[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v9[0] + 40))();
    memset(v9, 0, sizeof(v9));
  }
  if (*(_QWORD *)(a3 + 80) <= 8uLL)
    re::DynamicArray<BOOL>::setCapacity((_QWORD *)(a3 + 72), 9uLL);
  v13 = (const char *)&off_24ED7C100;
  v14 = a3 + 72;
  re::DynamicArrayStreamWriter::writeBytes((re::DynamicArrayStreamWriter *)&v13, a1 + 104, 1uLL);
  return re::DynamicArrayStreamWriter::writeBytes((re::DynamicArrayStreamWriter *)&v13, a1 + 112, 8uLL);
}

uint64_t re::RealityFileAssetProvider::RealityFileAssetProvider(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  re *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  re *v16;
  unsigned __int8 v17;
  __guard *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE v23[24];
  uint64_t v24;
  _BYTE *v25;
  _BYTE v26[24];
  uint64_t v27;
  _BYTE *v28;
  _BYTE v29[24];
  uint64_t v30;
  _BYTE *v31;
  _QWORD v32[3];
  uint64_t v33;
  _QWORD *v34;
  _QWORD v35[3];
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = off_24ED2E278;
  v13 = re::globalAllocators(v12);
  *(_QWORD *)(a1 + 48) = v13[2];
  *(_QWORD *)(a1 + 56) = 0;
  v14 = re::globalAllocators((re *)v13);
  *(_QWORD *)(a1 + 88) = v14[2];
  *(_QWORD *)(a1 + 96) = 0;
  v15 = re::globalAllocators((re *)v14);
  *(_QWORD *)(a1 + 128) = v15[2];
  *(_QWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  v16 = (re *)re::DynamicString::setCapacity((_QWORD *)(a1 + 144), 0);
  *(_QWORD *)a1 = &off_24ED2FB18;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_QWORD *)(a1 + 268) = 0x7FFFFFFFLL;
  if ((v17 & 1) == 0)
  {
    if ((_DWORD)v16)
    {
      re::introspect<re::RealityFileAssetLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"RealityFileAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_RealityFileAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_RealityFileAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RealityFileAssetLoadDescriptorParameters>, 0);
    }
  }
  re::RealityFileAssetProvider::s_loadDescriptorParametersIntrospect = v18[54];
  *(_QWORD *)(a1 + 192) = a2;
  *(_QWORD *)(a1 + 200) = a3;
  *(_QWORD *)(a1 + 208) = a4;
  *(_QWORD *)(a1 + 216) = a5;
  *(_QWORD *)(a1 + 224) = a6;
  v19 = re::globalAllocators(v16);
  v20 = v19[2];
  v35[0] = &off_24ED2FBB8;
  v35[1] = a1;
  v36 = v20;
  v37 = v35;
  v21 = re::globalAllocators((re *)v19)[2];
  v32[0] = &off_24ED2FC20;
  v32[1] = a1;
  v33 = v21;
  v34 = v32;
  v30 = v36;
  v31 = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v29, (uint64_t)v35);
  v27 = 0;
  v28 = 0;
  v24 = v33;
  v25 = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v23, (uint64_t)v32);
  re::RawAssetProvider::init(a1, "RealityFileAsset", a3, (uint64_t)v29, (uint64_t)v26, (uint64_t)v23);
  if (v25)
  {
    (**(void (***)(_BYTE *))v25)(v25);
    if (v25 != v23)
      (*(void (**)(uint64_t))(*(_QWORD *)v24 + 40))(v24);
    v25 = 0;
  }
  if (v28)
  {
    (**(void (***)(_BYTE *))v28)(v28);
    if (v28 != v26)
      (*(void (**)(uint64_t))(*(_QWORD *)v27 + 40))(v27);
    v28 = 0;
  }
  if (v31)
  {
    (**(void (***)(_BYTE *))v31)(v31);
    if (v31 != v29)
      (*(void (**)(uint64_t))(*(_QWORD *)v30 + 40))(v30);
    v31 = 0;
  }
  if (v34)
  {
    (*(void (**)(_QWORD *))*v34)(v34);
    if (v34 != v32)
      (*(void (**)(uint64_t))(*(_QWORD *)v33 + 40))(v33);
  }
  if (v37)
  {
    (*(void (**)(_QWORD *))*v37)(v37);
    if (v37 != v35)
      (*(void (**)(uint64_t))(*(_QWORD *)v36 + 40))(v36);
  }
  return a1;
}

uint64_t re::RawAssetProvider::init(uint64_t a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  re::DynamicString *v11;
  _QWORD v13[2];

  v11 = (re::DynamicString *)(a1 + 144);
  v13[0] = __s;
  v13[1] = strlen(__s);
  re::DynamicString::operator=(v11, (uint64_t)v13);
  *(_QWORD *)(a1 + 184) = a3;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>(a1 + 24, a4);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>(a1 + 64, a5);
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>(a1 + 104, a6);
}

void re::RealityFileAssetProvider::~RealityFileAssetProvider(re::RealityFileAssetProvider *this)
{
  double v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24ED2FB18;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  v2 = re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 29);
  *(_QWORD *)this = off_24ED2E278;
  v3 = *((_QWORD *)this + 18);
  if (v3)
  {
    if ((*((_BYTE *)this + 152) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 20), v2);
    *((_OWORD *)this + 9) = 0u;
    *((_OWORD *)this + 10) = 0u;
  }
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 104);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 64);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 24);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::RealityFileAssetProvider::~RealityFileAssetProvider(this);
  JUMPOUT(0x2276933B8);
}

id `anonymous namespace'::makeError(_anonymous_namespace_ *this, const __CFString *a2, uint64_t a3, const char *a4)
{
  id v4;
  id v6;

  re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), 0, (uint64_t)this, &v6);
  v4 = v6;

  return v4;
}

uint64_t `anonymous namespace'::readRealityFileAssetLoadDescriptorParametersCFError(_anonymous_namespace_ *this, const re::AssetLoadDescriptor *a2)
{
  const __CFString *v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _anonymous_namespace_ *v14;
  id Error;
  _BYTE v17[8];
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  _BYTE v30[8];
  _BYTE v31[9];
  _BYTE v32[111];

  if (v30[0])
  {
    re::types::Ok<re::RealityFileAssetLoadDescriptorParameters>::Ok((uint64_t)v17, (uint64_t)v31);
    *(_BYTE *)this = 1;
    *((_BYTE *)this + 8) = v17[0];
    *((_QWORD *)this + 2) = v18;
    v6 = v20;
    v7 = v21;
    *(_OWORD *)((char *)this + 24) = v19;
    v20 = 0;
    v18 = 0;
    v19 = 0uLL;
    *((_QWORD *)this + 5) = v6;
    *((_QWORD *)this + 6) = v7;
    v8 = v23;
    *((_QWORD *)this + 7) = v22;
    *((_QWORD *)this + 8) = v8;
    v9 = v24;
    v10 = v25;
    v23 = 0;
    v24 = 0;
    v21 = 0;
    v22 = 0;
    *((_QWORD *)this + 9) = v9;
    *((_QWORD *)this + 10) = v10;
    v11 = v28;
    v13 = v26;
    v12 = v27;
    v25 = 0;
    v27 = 0;
    v28 = 0;
    *((_QWORD *)this + 12) = v12;
    *((_QWORD *)this + 13) = v11;
    *((_QWORD *)this + 11) = v13;
    *((_OWORD *)this + 7) = v29;
  }
  else
  {
    if ((v31[8] & 1) != 0)
      v14 = *(_anonymous_namespace_ **)&v32[7];
    else
      v14 = (_anonymous_namespace_ *)v32;
    *(_BYTE *)this = 0;
    *((_QWORD *)this + 1) = Error;
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v30);
}

__n128 `anonymous namespace'::getAssetDescriptor(uint64_t a1, re::RealityFile *this, uint64_t a3)
{
  char *v6;
  uint64_t AssetDescriptorWithEntryName;
  __n128 result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 v12;
  uint64_t v13;
  uint64_t v14;

  if ((*(_BYTE *)(a3 + 80) & 1) != 0)
    v6 = *(char **)(a3 + 88);
  else
    v6 = (char *)(a3 + 81);
  AssetDescriptorWithEntryName = re::RealityFile::findAssetDescriptorWithEntryName(this, v6);
  if (AssetDescriptorWithEntryName)
  {
    *(_BYTE *)a1 = 1;
    *(_QWORD *)(a1 + 8) = AssetDescriptorWithEntryName;
  }
  else
  {
    if ((*(_BYTE *)(a3 + 80) & 1) != 0)
      v9 = *(_QWORD *)(a3 + 88);
    else
      v9 = a3 + 81;
    re::DynamicString::format((re::DynamicString *)"Failed to find an asset with archive entry name %s in the reality file.", (re::DynamicString *)&v12, v9);
    result = v12;
    v10 = v13;
    v11 = v14;
    *(_BYTE *)a1 = 0;
    *(__n128 *)(a1 + 8) = result;
    *(_QWORD *)(a1 + 24) = v10;
    *(_QWORD *)(a1 + 32) = v11;
  }
  return result;
}

uint64_t *re::RealityFileAssetProvider::load@<X0>(re::RealityFileAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X2>, uint64_t a5@<X8>)
{
  const char *v11;
  _anonymous_namespace_ *v12;
  uint64_t *result;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  _anonymous_namespace_ *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  const char **v26;
  unint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  _anonymous_namespace_ *v31;
  const char *v32;
  __n128 AssetDescriptor;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  _OWORD *v40;
  const re::DynamicString *v41;
  uint64_t v42;
  re *v43;
  NSObject *v44;
  __int128 v45;
  uint64_t v46;
  char *v47;
  char *v48;
  uint64_t v49;
  _anonymous_namespace_ *v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;
  _BYTE *v54;
  __int128 v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  char *v59;
  _anonymous_namespace_ *v60;
  const re::AssetLoadDescriptor *v61;
  uint64_t v62;
  uint64_t v63;
  char v64[8];
  _BYTE v65[120];
  __int128 v66;
  uint64_t v67;
  char *v68;
  __int128 v69;
  char v70[8];
  uint64_t v71;
  char v72[8];
  uint64_t v73;
  char v74;
  _BYTE v75[23];
  _QWORD v76[2];
  _OWORD v77[2];
  int v78;
  uint64_t v79;
  uint64_t v80[3];
  char v81[8];
  uint64_t v82;
  char v83;
  char v84[8];
  char *v85;
  uint8_t buf[4];
  uint64_t v87;
  __int16 v88;
  char *v89;
  _BYTE v90[24];
  uint64_t v91;
  unsigned int v92;
  uint64_t v93;

  v93 = *MEMORY[0x24BDAC8D0];
  if ((*((_BYTE *)a2 + 8) & 1) != 0)
    v11 = (const char *)*((_QWORD *)a2 + 2);
  else
    v11 = (char *)a2 + 9;
  v12 = (_anonymous_namespace_ *)strcmp(v11, "RealityFileAsset");
  if ((_DWORD)v12)
  {
    v14 = *(_OWORD *)v90;
    v15 = *(_QWORD *)&v90[16];
    v16 = v91;
    *(_BYTE *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v14;
    *(_QWORD *)(a5 + 24) = v15;
    *(_QWORD *)(a5 + 32) = v16;
    return result;
  }
  if (!v64[0])
  {
    re::DynamicString::DynamicString((re::DynamicString *)v90, (const re::DynamicString *)v65);
    *(_BYTE *)a5 = 0;
    v20 = v91;
    *(_QWORD *)(a5 + 8) = *(_QWORD *)v90;
    *(_QWORD *)(a5 + 32) = v20;
    *(_OWORD *)(a5 + 16) = *(_OWORD *)&v90[8];
    return (uint64_t *)re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v64);
  }
  re::RealityFileRegistry::getOrMountRealityFile((re::RealityFileDescriptor *)v65, *((dispatch_queue_t **)this + 24), (uint64_t)v84);
  if (!v84[0])
  {
    v21 = (_anonymous_namespace_ *)re::WrappedError::localizedDescription((id *)&v85);
    v22 = *(_OWORD *)v90;
    v23 = *(_QWORD *)&v90[16];
    v24 = v91;
    *(_BYTE *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v22;
    *(_QWORD *)(a5 + 24) = v23;
    *(_QWORD *)(a5 + 32) = v24;
    goto LABEL_59;
  }
  v17 = v85;
  if (v85)
    v18 = v85 + 8;
  if ((*((_BYTE *)a2 + 120) & 1) != 0)
    v19 = (char *)*((_QWORD *)a2 + 16);
  else
    v19 = (char *)a2 + 121;
  v25 = re::internal::AssetTypeRegistry::assetTypeWithName(*((re::internal::AssetTypeRegistry **)this + 25), v19);
  v26 = (const char **)v25;
  if (!*((_QWORD *)this + 29))
    goto LABEL_17;
  v27 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) >> 27));
  v28 = *(unsigned int *)(*((_QWORD *)this + 30) + 4 * ((v27 ^ (v27 >> 31)) % *((unsigned int *)this + 64)));
  if ((_DWORD)v28 == 0x7FFFFFFF)
    goto LABEL_17;
  v30 = *((_QWORD *)this + 31);
  if (*(_QWORD *)(v30 + 32 * v28 + 16) != v25)
  {
    while (1)
    {
      v28 = *(_DWORD *)(v30 + 32 * v28 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v28 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v30 + 32 * v28 + 16) == v25)
        goto LABEL_21;
    }
LABEL_17:
    v29 = 0;
    goto LABEL_22;
  }
LABEL_21:
  v29 = (_QWORD *)(v30 + 32 * v28 + 24);
LABEL_22:
  if (!v81[0])
  {
    if (v29)
    {
      (*(void (**)(_QWORD, char *, _BYTE *, uint64_t, uint64_t *, __n128))(*(_QWORD *)*v29 + 32))(*v29, v17, v65, a4, &v82, AssetDescriptor);
      if (v81[0])
        goto LABEL_57;
    }
    else
    {
      re::DynamicString::DynamicString((re::DynamicString *)v90, (const re::DynamicString *)&v82);
      *(_BYTE *)a5 = 0;
      v49 = v91;
      *(_QWORD *)(a5 + 8) = *(_QWORD *)v90;
      *(_QWORD *)(a5 + 32) = v49;
      *(_OWORD *)(a5 + 16) = *(_OWORD *)&v90[8];
    }
    if (v82 && (v83 & 1) != 0)
    {
      (*(void (**)(void))(*(_QWORD *)v82 + 40))();
      if (!v17)
        goto LABEL_59;
      goto LABEL_58;
    }
LABEL_57:
    if (v17)
LABEL_58:

LABEL_59:
    re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v84);
    return (uint64_t *)re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v64);
  }
  v34 = *((_QWORD *)a2 + 15);
  v35 = v34 >> 1;
  if ((v34 & 1) == 0)
    v35 = v34 >> 1;
  if (!v35)
  {
LABEL_56:
    v51 = *(_OWORD *)v90;
    v52 = *(_QWORD *)&v90[16];
    v53 = v91;
    *(_BYTE *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v51;
    *(_QWORD *)(a5 + 24) = v52;
    *(_QWORD *)(a5 + 32) = v53;
    goto LABEL_57;
  }
  if (!v26)
  {
    if ((v34 & 1) != 0)
      v48 = (char *)*((_QWORD *)a2 + 16);
    else
      v48 = (char *)a2 + 121;
    re::DynamicString::format((re::DynamicString *)"Could not find an AssetType registered with name '%s'.", (re::DynamicString *)v90, v48);
    goto LABEL_56;
  }
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x804, a4, *v26, v32);
  v36 = v82;
  re::RealityFile::getInputStream((re::RealityFile *)v17, v82, (uint64_t)v90);
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x805, a4, *v26, v37);
  v38 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v36 + 40))(v36);
  if (!v90[0])
  {
    v50 = (_anonymous_namespace_ *)re::WrappedError::localizedDescription((id *)&v90[8]);
    if (v29)
    {
      (*(void (**)(_QWORD, char *, _BYTE *, uint64_t, __int128 *))(*(_QWORD *)*v29 + 32))(*v29, v17, v65, a4, &v66);
    }
    else
    {
      re::DynamicString::DynamicString((re::DynamicString *)v77, (const re::DynamicString *)&v66);
      *(_BYTE *)a5 = 0;
      v58 = *((_QWORD *)&v77[1] + 1);
      *(_QWORD *)(a5 + 8) = *(_QWORD *)&v77[0];
      *(_QWORD *)(a5 + 32) = v58;
      *(_OWORD *)(a5 + 16) = *(_OWORD *)((char *)v77 + 8);
    }
    if ((_QWORD)v66 && (BYTE8(v66) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v66 + 40))();
LABEL_67:
    re::Result<re::RealityFileEntryStream,re::WrappedError>::~Result((uint64_t)v90);
    if (!v17)
      goto LABEL_59;
    goto LABEL_58;
  }
  v62 = v38;
  if (v92 < 2)
  {
    v63 = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)&v90[8] + 64))(&v90[8]);
    v39 = *((_QWORD *)this + 25);
    v80[1] = 0;
    v80[2] = 0;
    v80[0] = v39;
    v78 = 0;
    memset(v77, 0, sizeof(v77));
    v79 = 0x7FFFFFFFLL;
    if (v29)
      (*(void (**)(_QWORD, _BYTE *, _OWORD *))(*(_QWORD *)*v29 + 40))(*v29, v65, v77);
    v76[0] = &off_24ED2D160;
    v76[1] = a3;
    if (v92 < 2)
    {
      if (HIDWORD(v77[1]))
        v40 = v77;
      else
        v40 = 0;
      v70[0] = 1;
      v71 = a4;
      re::AssetUtilities::loadCompiledAssetFromStream((re *)&v90[8], v80, v26, (uint64_t)v76, 0, (uint64_t)v40, v70, (uint64_t)v72);
      if (v72[0])
      {
        v41 = (const re::AssetLoadDescriptor *)((char *)a2 + 112);
        v42 = v73;
        if (v29)
        {
          v43 = (re *)(*(_QWORD *(**)(__int128 *__return_ptr, _QWORD, uint64_t, char *, _BYTE *))(*(_QWORD *)*v29 + 48))(&v66, *v29, v73, v17, v65);
          if (!(_BYTE)v66)
          {
            v44 = *re::assetsLogObjects(v43);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              if ((v67 & 1) != 0)
                v59 = v68;
              else
                v59 = (char *)&v67 + 1;
              *(_DWORD *)buf = 136315394;
              v87 = v62;
              v88 = 2080;
              v89 = v59;
              _os_log_error_impl(&dword_224FE9000, v44, OS_LOG_TYPE_ERROR, "Post reality file load processing failed asset path '%s': %s", buf, 0x16u);
            }
            if (!(_BYTE)v66 && *((_QWORD *)&v66 + 1) && (v67 & 1) != 0)
              (*(void (**)(void))(**((_QWORD **)&v66 + 1) + 40))();
          }
        }
        re::DynamicString::DynamicString((re::DynamicString *)&v66, v41);
        *(_QWORD *)&v69 = v42;
        *((_QWORD *)&v69 + 1) = v63;
        v45 = v66;
        v46 = v67;
        v47 = v68;
        *(_BYTE *)a5 = 1;
        *(_OWORD *)(a5 + 8) = v45;
        *(_QWORD *)(a5 + 24) = v46;
        *(_QWORD *)(a5 + 32) = v47;
        *(_BYTE *)(a5 + 56) = 1;
        *(_OWORD *)(a5 + 40) = v69;
      }
      else
      {
        if ((v74 & 1) != 0)
          v54 = *(_BYTE **)&v75[7];
        else
          v54 = v75;
        re::DynamicString::format((re::DynamicString *)"Failed to load compiled data for asset path '%s', due to error: %s.", (re::DynamicString *)&v66, v62, v54);
        v55 = v66;
        v56 = v67;
        v57 = v68;
        *(_BYTE *)a5 = 0;
        *(_OWORD *)(a5 + 8) = v55;
        *(_QWORD *)(a5 + 24) = v56;
        *(_QWORD *)(a5 + 32) = v57;
      }
      if (!v72[0] && v73 && (v74 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v73 + 40))();
      re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v77);
      goto LABEL_67;
    }
  }
  v60 = (_anonymous_namespace_ *)std::__throw_bad_variant_access[abi:nn180100]();
}

uint64_t *`anonymous namespace'::readRealityFileAssetLoadDescriptorParameters(_anonymous_namespace_ *this, const re::AssetLoadDescriptor *a2)
{
  _anonymous_namespace_ *v4;
  _anonymous_namespace_ *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *result;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  uint64_t *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE v41[8];
  uint64_t v42;

  v34 = 0;
  v35 = 0;
  v36 = 0;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v33, 0);
  *((_QWORD *)&v37 + 1) = 0;
  v38 = 0uLL;
  v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v37, 0);
  *((_QWORD *)&v39 + 1) = 0;
  v40 = 0uLL;
  re::DynamicString::setCapacity(&v39, 0);
  v41[0] = 0;
  v42 = 1;
  v6 = re::AssetLoadDescriptor::getIntrospectableData<re::RealityFileAssetLoadDescriptorParameters>(a2, &v32, 0);
  if ((v6 & 1) != 0)
  {
    v7 = *((_QWORD *)a2 + 11);
    if (v7)
    {
      v8 = *((_QWORD *)a2 + 13);
      *(_QWORD *)&v20 = &off_24ED7C9D0;
      *((_QWORD *)&v20 + 1) = v8;
      v21 = v7;
      re::MemoryStreamReader::readBytes((re::MemoryStreamReader *)&v20, v41, 1uLL);
      (*(void (**)(__int128 *, uint64_t *, uint64_t))(v20 + 16))(&v20, &v42, 8);
    }
    else
    {
      v41[0] = 0;
      v42 = 1;
    }
    re::types::Ok<re::RealityFileAssetLoadDescriptorParameters>::Ok((uint64_t)&v20, (uint64_t)&v32);
    *(_BYTE *)this = 1;
    *((_BYTE *)this + 8) = v20;
    *((_QWORD *)this + 2) = *((_QWORD *)&v20 + 1);
    v11 = v22;
    v12 = v23;
    *(_OWORD *)((char *)this + 24) = v21;
    v22 = 0;
    *((_QWORD *)&v20 + 1) = 0;
    v21 = 0uLL;
    *((_QWORD *)this + 5) = v11;
    *((_QWORD *)this + 6) = v12;
    v13 = v25;
    *((_QWORD *)this + 7) = v24;
    *((_QWORD *)this + 8) = v13;
    v14 = v26;
    v15 = v27;
    v25 = 0;
    v26 = 0;
    v23 = 0;
    v24 = 0;
    *((_QWORD *)this + 9) = v14;
    *((_QWORD *)this + 10) = v15;
    v16 = v30;
    v18 = v28;
    v17 = v29;
    v27 = 0;
    v29 = 0;
    v30 = 0;
    *((_QWORD *)this + 12) = v17;
    *((_QWORD *)this + 13) = v16;
    *((_QWORD *)this + 11) = v18;
    *((_OWORD *)this + 7) = v31;
  }
  else
  {
    v9 = v20;
    v10 = v21;
    *(_BYTE *)this = 0;
    *(_OWORD *)((char *)this + 8) = v9;
    *(_OWORD *)((char *)this + 24) = v10;
  }
  if ((_QWORD)v39)
  {
    if ((BYTE8(v39) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v39 + 40))();
    v39 = 0u;
    v40 = 0u;
  }
  if ((_QWORD)v37)
  {
    if ((BYTE8(v37) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v37 + 40))();
    v37 = 0u;
    v38 = 0u;
  }
  result = v33;
  if (v33)
  {
    if ((v34 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v33 + 40))();
  }
  return result;
}

uint64_t re::RealityFileAssetProvider::transformDescriptor@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  int v21;
  __int128 v22;
  __int128 v23;
  int v24;
  _BYTE v25[24];
  __int128 v26;
  char v27[8];
  uint64_t v28;
  char v29;
  _QWORD v30[4];
  _QWORD v31[4];
  char v32;
  uint64_t v33;
  char v34[8];
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  int v41;
  __int128 v42;
  __int128 v43;
  int v44;
  __int128 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  __int128 v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  int v54;
  __int128 v55;
  __int128 v56;
  int v57;
  __int128 v58;
  uint64_t v59;
  __int128 v60;
  char v61;
  char v62;
  uint64_t v63;
  char v64;
  _QWORD v65[4];
  _BYTE v66[8];
  _BYTE v67[72];
  uint64_t v68;

  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  if (v66[0])
  {
    re::RealityFileDescriptor::transform((uint64_t)v67);
    if (v61)
    {
      v27[0] = v62;
      re::DynamicString::DynamicString((re::DynamicString *)&v28, (const re::DynamicString *)&v63);
      re::DynamicString::DynamicString((re::DynamicString *)v30, (const re::DynamicString *)v65);
      re::DynamicString::DynamicString((re::DynamicString *)v31, (const re::DynamicString *)&v68);
      v32 = 0;
      v33 = 1;
      re::RealityFileAssetLoadDescriptorFactory::make(v27, (re::DynamicString *)(a1 + 112), (uint64_t)&v17);
      v34[0] = 1;
      v5 = v17;
      v6 = v18;
      v17 = 0;
      v7 = *((_QWORD *)&v18 + 1);
      v8 = v19;
      v18 = 0u;
      v19 = 0u;
      ++v21;
      ++v24;
      v9 = v26;
      v10 = *(_QWORD *)&v25[16];
      v26 = 0u;
      LOBYTE(v49) = 1;
      v51 = v7;
      v52 = v8;
      v37 = 0;
      v38 = 0;
      *(_QWORD *)&v50 = v5;
      *((_QWORD *)&v50 + 1) = v6;
      v35 = 0;
      v36 = 0;
      v39 = 0;
      v11 = v20;
      v20 = 0u;
      v53 = v11;
      v40 = 0u;
      v42 = 0u;
      v12 = v22;
      v13 = v23;
      v22 = 0u;
      v23 = 0u;
      v55 = v12;
      v56 = v13;
      v43 = 0u;
      v41 = 2;
      v44 = 2;
      v54 = 1;
      v57 = 1;
      v14 = *(_OWORD *)v25;
      memset(v25, 0, sizeof(v25));
      v58 = v14;
      v45 = 0u;
      v47 = 0;
      v48 = 0;
      v60 = v9;
      v59 = v10;
      v46 = 0;
      *(_BYTE *)a3 = 1;
      re::Optional<re::AssetLoadDescriptor>::Optional(a3 + 8, (unsigned __int8 *)&v49);
      re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)&v49);
      re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)v34);
      if (*(_QWORD *)&v25[8])
      {
        if ((v25[16] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v25[8] + 40))();
        *(_OWORD *)&v25[8] = 0u;
        v26 = 0u;
      }
      if (*((_QWORD *)&v22 + 1))
      {
        if (*(_QWORD *)v25)
          (*(void (**)(void))(**((_QWORD **)&v22 + 1) + 40))();
        *(_QWORD *)v25 = 0;
        v23 = 0uLL;
        *((_QWORD *)&v22 + 1) = 0;
        ++v24;
      }
      if (*((_QWORD *)&v19 + 1))
      {
        if ((_QWORD)v22)
          (*(void (**)(void))(**((_QWORD **)&v19 + 1) + 40))();
        *(_QWORD *)&v22 = 0;
        v20 = 0uLL;
        *((_QWORD *)&v19 + 1) = 0;
        ++v21;
      }
      if (v17 && (v18 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v17 + 40))();
      if (v31[0])
      {
        if ((v31[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v31[0] + 40))();
        memset(v31, 0, sizeof(v31));
      }
      if (v30[0])
      {
        if ((v30[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v30[0] + 40))();
        memset(v30, 0, sizeof(v30));
      }
      if (v28 && (v29 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v28 + 40))();
    }
    else
    {
      v34[0] = 0;
      LOBYTE(v49) = 0;
      *(_BYTE *)a3 = 1;
      re::Optional<re::AssetLoadDescriptor>::Optional(a3 + 8, (unsigned __int8 *)&v49);
      re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)&v49);
      re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)v34);
    }
    if (v61)
    {
      if (v65[0])
      {
        if ((v65[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v65[0] + 40))();
        memset(v65, 0, sizeof(v65));
      }
      if (v63 && (v64 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v63 + 40))();
    }
  }
  else
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v49, (const re::DynamicString *)v67);
    *(_BYTE *)a3 = 0;
    v15 = v51;
    *(_QWORD *)(a3 + 8) = v49;
    *(_QWORD *)(a3 + 32) = v15;
    *(_OWORD *)(a3 + 16) = v50;
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v66);
}

uint64_t re::RealityFileAssetProvider::getSource@<X0>(re::RealityFileAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t a3@<X8>)
{
  _BOOL8 hasURL;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v17[24];
  uint64_t v18;
  _BYTE v19[8];
  unsigned __int8 v20[120];

  if (v19[0])
  {
    hasURL = re::RealityFileDescriptor::hasURL(v20, *((_QWORD *)this + 27));
    if (hasURL)
    {
      re::RealityFileDescriptor::getURL((uint64_t)v20);
      if (v17[0])
      {
        LOBYTE(v13) = 1;
        re::DynamicString::DynamicString((re::DynamicString *)&v14, (const re::DynamicString *)&v17[8]);
        v6 = v14;
        v14 = 0uLL;
        v7 = v15;
        v8 = v16;
        v15 = 0;
        v16 = 0;
        *(_OWORD *)(a3 + 16) = v6;
        *(_QWORD *)(a3 + 32) = v7;
        *(_QWORD *)(a3 + 40) = v8;
        *(_BYTE *)a3 = 1;
        *(_BYTE *)(a3 + 8) = 1;
      }
      else
      {
        re::DynamicString::DynamicString((re::DynamicString *)&v13, (const re::DynamicString *)&v17[8]);
        *(_BYTE *)a3 = 0;
        *(_QWORD *)(a3 + 8) = v13;
        *(_QWORD *)(a3 + 32) = v15;
        *(_OWORD *)(a3 + 16) = v14;
      }
      if (*(_QWORD *)&v17[8] && (v17[16] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v17[8] + 40))();
    }
    else
    {
      v9 = *(_OWORD *)v17;
      v10 = *(_QWORD *)&v17[16];
      v11 = v18;
      *(_BYTE *)a3 = 0;
      *(_OWORD *)(a3 + 8) = v9;
      *(_QWORD *)(a3 + 24) = v10;
      *(_QWORD *)(a3 + 32) = v11;
    }
  }
  else
  {
    re::DynamicString::DynamicString((re::DynamicString *)v17, (const re::DynamicString *)v20);
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = *(_QWORD *)v17;
    *(_QWORD *)(a3 + 32) = v18;
    *(_OWORD *)(a3 + 16) = *(_OWORD *)&v17[8];
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v19);
}

double re::RealityFileAssetProvider::getFileName@<D0>(re::RealityFileAssetProvider *this@<X0>, uint64_t a2@<X8>)
{
  void *v4;
  char *v5;
  void *v6;
  void *v7;
  id v8;
  _anonymous_namespace_ *v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  double result;
  uint64_t *v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  char *v21;

  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)this + 64))(&v18);
  if ((_BYTE)v18)
  {
    v4 = (void *)MEMORY[0x24BDBCF48];
    if ((BYTE8(v20) & 1) != 0)
      v5 = v21;
    else
      v5 = (char *)&v20 + 9;
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCString:encoding:", v5, 4);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "URLWithString:", v6);
    v7 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v7, "lastPathComponent");
    v8 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v9 = (_anonymous_namespace_ *)objc_msgSend(v8, "UTF8String");
    v10 = v15;
    v15 = 0uLL;
    v11 = v16;
    v12 = v17;
    v16 = 0;
    v17 = 0;
    *(_BYTE *)a2 = 1;
    *(_BYTE *)(a2 + 8) = 1;
    *(_OWORD *)(a2 + 16) = v10;
    *(_QWORD *)(a2 + 32) = v11;
    *(_QWORD *)(a2 + 40) = v12;

    if ((_BYTE)v18)
    {
      if (!(_BYTE)v19)
        return result;
      v14 = (uint64_t *)&v20;
    }
    else
    {
      v14 = &v19;
    }
  }
  else
  {
    *(_BYTE *)a2 = 0;
    v14 = &v19;
    *(_QWORD *)(a2 + 8) = v19;
    *(_QWORD *)(a2 + 32) = v21;
    result = *(double *)&v20;
    *(_OWORD *)(a2 + 16) = v20;
    v21 = 0;
    v19 = 0;
    v20 = 0uLL;
  }
  if (*v14)
  {
    if ((v14[1] & 1) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)*v14 + 40))(*v14, v14[2]);
    result = 0.0;
    *(_OWORD *)v14 = 0u;
    *((_OWORD *)v14 + 1) = 0u;
  }
  return result;
}

uint64_t re::RealityFileAssetProvider::getDescription(re::RealityFileAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  const char *v4;
  const char *v5;
  uint64_t v6;
  char v7;
  size_t v8;
  const char *v9;
  char v10;
  size_t v11;
  const char *v12;
  char v13;
  size_t v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  size_t v18;
  const char *v20;
  _QWORD v21[3];
  _BYTE v22[24];
  _QWORD v23[4];
  _QWORD v24[4];
  _QWORD v25[4];
  uint64_t v26;

  if (v22[0])
  {
    v4 = "URL";
    switch(v22[8])
    {
      case 0:
        v5 = "None";
        v6 = 4;
        goto LABEL_5;
      case 1:
        goto LABEL_9;
      case 2:
        v4 = "Bundle";
        goto LABEL_9;
      case 3:
        v4 = "MemoryFileID";
        goto LABEL_9;
      case 4:
        v4 = "NameAlias";
LABEL_9:
        v20 = v4;
        v21[0] = strlen(v4);
        re::DynamicString::operator=(a3, (uint64_t)&v20);
        break;
      default:
        break;
    }
    v7 = v23[0];
    if ((v23[0] & 1) != 0)
      v8 = v23[0] >> 1;
    else
      v8 = LOBYTE(v23[0]) >> 1;
    if (v8)
    {
      re::DynamicString::append(a3, "/", 1uLL);
      if ((v7 & 1) != 0)
        v9 = (const char *)v23[1];
      else
        v9 = (char *)v23 + 1;
      re::DynamicString::append(a3, v9, v8);
    }
    v10 = v24[0];
    if ((v24[0] & 1) != 0)
      v11 = v24[0] >> 1;
    else
      v11 = LOBYTE(v24[0]) >> 1;
    if (v11)
    {
      re::DynamicString::append(a3, "/", 1uLL);
      if ((v10 & 1) != 0)
        v12 = (const char *)v24[1];
      else
        v12 = (char *)v24 + 1;
      re::DynamicString::append(a3, v12, v11);
    }
    v13 = v25[0];
    if ((v25[0] & 1) != 0)
      v14 = v25[0] >> 1;
    else
      v14 = LOBYTE(v25[0]) >> 1;
    if (v14)
    {
      re::DynamicString::append(a3, "/", 1uLL);
      if ((v13 & 1) != 0)
        v15 = (const char *)v25[1];
      else
        v15 = (char *)v25 + 1;
      re::DynamicString::append(a3, v15, v14);
    }
    if (v26 != 1)
    {
      re::DynamicString::format((re::DynamicString *)"<textureDownsampleLevel%d>", (re::DynamicString *)&v20, v26);
      v16 = v21[0] & 1;
      if ((v21[0] & 1) != 0)
        v17 = (const char *)v21[1];
      else
        v17 = (char *)v21 + 1;
      if ((v21[0] & 1) != 0)
        v18 = v21[0] >> 1;
      else
        v18 = LOBYTE(v21[0]) >> 1;
      re::DynamicString::append(a3, v17, v18);
      if (v20 && v16)
        (*(void (**)(void))(*(_QWORD *)v20 + 40))();
    }
  }
  else
  {
    v5 = "mangled";
    v6 = 7;
LABEL_5:
    v20 = v5;
    v21[0] = v6;
    re::DynamicString::operator=(a3, (uint64_t)&v20);
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v22);
}

uint64_t re::RealityFileAssetProvider::getAssetPathForRelease@<X0>(re::RealityFileAssetProvider *a1@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t a3@<X8>)
{
  _anonymous_namespace_ *v5;
  char *v6;
  _BYTE *v7;
  uint64_t v8;
  __int128 *v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  _BYTE v22[23];
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  _QWORD v28[3];
  _BYTE v29[8];
  uint64_t v30;
  uint64_t v31;

  if (!v29[0])
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v26, (const re::DynamicString *)&v30);
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v26;
    *(_QWORD *)(a3 + 32) = v28[0];
    *(_OWORD *)(a3 + 16) = v27;
    return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v29);
  }
  re::RealityFileAssetProvider::getFileName(a1, (uint64_t)&v26);
  if ((_BYTE)v26)
  {
    re::DynamicString::operator+((re::DynamicString *)&v23, (uint64_t)&v31, (re::DynamicString *)&v20);
    if ((v28[0] & 1) != 0)
      v6 = (char *)v28[1];
    else
      v6 = (char *)v28 + 1;
    if ((v21 & 1) != 0)
      v7 = *(_BYTE **)&v22[7];
    else
      v7 = v22;
    re::DynamicString::format((re::DynamicString *)"reality:%s/%s", (re::DynamicString *)&v17, v6, v7);
    re::DynamicString::DynamicString((re::DynamicString *)&v14, (const re::DynamicString *)&v17);
    *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 8) = v14;
    v8 = v17;
    *(_QWORD *)(a3 + 32) = v16;
    *(_OWORD *)(a3 + 16) = v15;
    if (v8 && (v18 & 1) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 40))(v8, v19);
    if (v20 && (v21 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v20 + 40))();
    if ((_QWORD)v23 && (BYTE8(v23) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v23 + 40))();
    if ((_BYTE)v26)
    {
      if (!(_BYTE)v27)
        return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v29);
      v9 = (__int128 *)((char *)&v27 + 8);
    }
    else
    {
      v9 = &v27;
    }
  }
  else
  {
    v10 = v23;
    v11 = v24;
    v12 = v25;
    *(_BYTE *)a3 = 0;
    *(_OWORD *)(a3 + 8) = v10;
    *(_QWORD *)(a3 + 24) = v11;
    *(_QWORD *)(a3 + 32) = v12;
    v9 = &v27;
  }
  if (*(_QWORD *)v9)
  {
    if ((*((_BYTE *)v9 + 8) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v9 + 40))(*(_QWORD *)v9, *((_QWORD *)v9 + 2));
    *v9 = 0u;
    v9[1] = 0u;
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v29);
}

uint64_t re::RealityFileAssetProvider::initMetadataStrings(uint64_t a1, const re::AssetLoadDescriptor *a2, uint64_t a3)
{
  re *v5;
  re::AssetMap **v6;
  char *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v11;
  uint64_t v12;
  char v13[8];
  re::AssetMap **v14;
  char v15[8];
  uint64_t v16;
  uint64_t v17;
  uint8_t buf[4];
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (v15[0])
  {
    re::RealityFileRegistry::getOrMountRealityFile((re::RealityFileDescriptor *)&v16, *(dispatch_queue_t **)(a1 + 192), (uint64_t)v13);
    if (v13[0])
    {
      v6 = v14;
      if (v14)
        v7 = v14 + 1;
      v8 = re::AssetMap::metadataForFileName(v6[14], (const re::DynamicString *)&v17);
      if (v8)
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(a3, v8);

    }
    else
    {
      v9 = *re::assetsLogObjects(v5);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        v11 = v9;
        v12 = re::WrappedError::localizedDescription((id *)&v14);
        *(_DWORD *)buf = 136315138;
        v19 = v12;
        _os_log_error_impl(&dword_224FE9000, v11, OS_LOG_TYPE_ERROR, "Cannot init metadata due to reality file load error: %s", buf, 0xCu);

      }
    }
    re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v13);
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v15);
}

uint64_t re::RealityFileAssetProvider::getPreloadableDependencies@<X0>(dispatch_queue_t **a1@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::internal::AssetTypeRegistry **a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  id v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  re::path *v18;
  const char *v19;
  _BYTE *v20;
  const char *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  _anonymous_namespace_ *v25;
  int v26;
  _anonymous_namespace_ *v27;
  uint64_t v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  __int128 v36;
  _BYTE *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int128 v48;
  char *v49;
  uint64_t v50;
  uint64_t *v51;
  __int128 v52;
  int v53;
  uint64_t v54;
  char v55[8];
  uint64_t v56;
  uint64_t *v57;
  unint64_t v58;
  unint64_t v59;
  int v60;
  uint64_t v61;
  char v62[8];
  _BYTE v63[9];
  _BYTE v64[72];
  _BYTE v65[47];

  if (!v62[0])
  {
    if ((v63[8] & 1) != 0)
      v37 = *(_BYTE **)&v64[7];
    else
      v37 = v64;
    re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), (const __CFString *)0x11, (uint64_t)v37, &v47);
    v38 = v47;
    v47 = 0;
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = v38;

    return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v62);
  }
  v61 = 0;
  v58 = 0;
  v59 = 0;
  v57 = 0;
  v60 = 0;
  re::RealityFileRegistry::getMountedRealityFile((re::RealityFileDescriptor *)v63, a1[24], (uint64_t)v55);
  if (v55[0])
  {
    v8 = v56;
    if (v56)
      v9 = (id)(v56 + 8);
    if ((v64[71] & 1) != 0)
      v10 = *(const char **)&v65[7];
    else
      v10 = v65;
    v11 = re::AssetMap::assetDependenciesWithFileName(*(re::AssetMap **)(v8 + 112), v10);
    if (v11 && (v12 = *(_QWORD *)(v11 + 16)) != 0)
    {
      v13 = 0;
      v14 = *(uint64_t **)(v11 + 32);
      v45 = 0;
      v44 = v8;
      v15 = 8 * v12;
      while (1)
      {
        v16 = *v14;
        if (*v14)
          v17 = (id)(v16 + 8);
        v18 = (re::path *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
        if (!v18)
          break;
        v20 = (_BYTE *)re::path::ext(v18, v19);
        if (*v20 != 46)
          break;
        v21 = v20 + 1;
        if (!v20[1])
          break;
        v22 = re::internal::AssetTypeRegistry::assetTypeWithCompiledExtension(*a3, v21);
        if (!v22)
        {
          re::DynamicString::format((re::DynamicString *)"Failed to find AssetType with compiled extension '%s'.", (re::DynamicString *)&v47, v21);
          if ((v48 & 1) != 0)
            v40 = (char *)*((_QWORD *)&v48 + 1);
          else
            v40 = (char *)&v48 + 1;
          v41 = 9;
          goto LABEL_56;
        }
        v23 = (_QWORD *)v22;
        v24 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
        v25 = (_anonymous_namespace_ *)((_anonymous_namespace_ *(*)(uint64_t *__return_ptr, dispatch_queue_t **, const re::AssetLoadDescriptor *, uint64_t, _QWORD))(*a1)[6])(&v47, a1, a2, v24, *v23);
        v26 = v47;
        if ((_BYTE)v47)
        {
          v54 = 0;
          v52 = 0uLL;
          v51 = 0;
          v53 = 0;
          re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(&v51, 1uLL);
          ++v53;
          v27 = re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)&v51, (re::DynamicString *)&v48);
          if (v13 >= v58)
          {
            if (v58 < v13 + 1)
            {
              if (v57)
              {
                v32 = 8;
                if (v58)
                  v32 = 2 * v58;
                if (v32 <= v13 + 1)
                  v33 = v13 + 1;
                else
                  v33 = v32;
                re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity(&v57, v33);
              }
              else
              {
                re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity(&v57, v13 + 1);
                ++v60;
              }
            }
            v13 = v59;
            v28 = v61;
          }
          else
          {
            v28 = v45;
          }
          v45 = v28;
          re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray(v28 + 40 * v13, (uint64_t *)&v51);
          v13 = ++v59;
          ++v60;
          re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v51);
        }
        else
        {
          v29 = (char *)&v48 + 9;
          if ((BYTE8(v48) & 1) != 0)
            v29 = v49;
          re::DynamicString::format((re::DynamicString *)"RealityFileAssetProvider failed to resolve child AssetLoadDescriptor due to error: %s", (re::DynamicString *)&v51, v29);
          if ((v52 & 1) != 0)
            v30 = (char *)*((_QWORD *)&v52 + 1);
          else
            v30 = (char *)&v52 + 1;
          re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), (const __CFString *)0x13, (uint64_t)v30, &v46);
          v31 = v46;
          v46 = 0;
          *(_BYTE *)a4 = 0;
          *(_QWORD *)(a4 + 8) = v31;

          if (v51 && (v52 & 1) != 0)
            (*(void (**)(void))(*v51 + 40))();
        }
        re::Result<re::AssetLoadDescriptor,re::DynamicString>::~Result((uint64_t)&v47);

        if (!v26)
          goto LABEL_60;
        ++v14;
        v15 -= 8;
        if (!v15)
        {
          re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::DynamicArray((uint64_t)&v51, (uint64_t *)&v57);
          v34 = v51;
          v51 = 0;
          v35 = v54;
          v54 = 0;
          ++v53;
          *(_BYTE *)a4 = 1;
          *(_QWORD *)(a4 + 8) = v34;
          v47 = 0;
          v36 = v52;
          v52 = 0u;
          *(_OWORD *)(a4 + 16) = v36;
          v48 = 0u;
          *(_QWORD *)(a4 + 40) = v35;
          v50 = 0;
          LODWORD(v49) = 2;
          *(_DWORD *)(a4 + 32) = 1;
          re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v47);
          re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v51);
          goto LABEL_60;
        }
      }
      v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
      re::DynamicString::format((re::DynamicString *)"Failed to parse extension from archive entry name '%s'.", (re::DynamicString *)&v47, v39);
      if ((v48 & 1) != 0)
        v40 = (char *)*((_QWORD *)&v48 + 1);
      else
        v40 = (char *)&v48 + 1;
      v41 = 18;
LABEL_56:
      re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), (const __CFString *)v41, (uint64_t)v40, &v51);
      v42 = v51;
      v51 = 0;
      *(_BYTE *)a4 = 0;
      *(_QWORD *)(a4 + 8) = v42;

      if (v47 && (v48 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v47 + 40))();

LABEL_60:
      v8 = v44;
      if (!v44)
        goto LABEL_62;
    }
    else
    {
      v54 = 0;
      v51 = 0;
      v52 = 0u;
      v53 = 1;
      *(_BYTE *)a4 = 1;
      v47 = 0;
      *(_OWORD *)(a4 + 8) = 0u;
      *(_QWORD *)(a4 + 24) = 0;
      v48 = 0u;
      *(_QWORD *)(a4 + 40) = 0;
      v50 = 0;
      LODWORD(v49) = 2;
      *(_DWORD *)(a4 + 32) = 1;
      re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v47);
      re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v51);
    }

  }
  else
  {
    re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::DynamicArray((uint64_t)&v47, (uint64_t *)&v57);
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = v47;
    *(_OWORD *)(a4 + 16) = v48;
    v47 = 0;
    v48 = 0uLL;
    *(_QWORD *)(a4 + 40) = v50;
    v50 = 0;
    LODWORD(v49) = (_DWORD)v49 + 1;
    *(_DWORD *)(a4 + 32) = 1;
    re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v47);
  }
LABEL_62:
  if (v55[0] && v56)

  re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v57);
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result((uint64_t)v62);
}

uint64_t re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::add<re::RealityFileAssetProvider::PerTypeLoadCallbacks*&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addEmplace<re::RealityFileAssetProvider::PerTypeLoadCallbacks*&>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != v6)
  {
    v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 32 * v10;
  return v12 + 24;
}

void re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_0,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_0,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::operator()@<X0>(uint64_t a1@<X0>, const char **a2@<X1>, uint64_t a3@<X8>)
{
  const char *v4;
  const char *v5;
  uint64_t v6;
  _anonymous_namespace_ *v7;
  const __CFString *v8;
  uint64_t v9;
  const char *v10;
  _anonymous_namespace_ *v11;
  id v12;
  uint64_t result;
  char *v14;
  char *v15;
  char *v16;
  const __CFString *v17;
  uint64_t v18;
  const char *v19;
  id v20;
  id v21;
  int v22;
  id v23;
  uint64_t v24;
  id v25;
  id v26;
  int v27;
  _anonymous_namespace_ *v28;
  id Error;
  char v30[8];
  id v31;
  char v32[8];
  id v33;
  char v34;
  _BYTE v35[23];
  char v36[8];
  id v37;
  uint64_t v38;
  _QWORD v39[10];
  char v40;
  _BYTE v41[39];

  v4 = *a2;
  if (((*a2)[8] & 1) != 0)
    v5 = (const char *)*((_QWORD *)v4 + 2);
  else
    v5 = v4 + 9;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = (_anonymous_namespace_ *)strcmp(v5, "RealityFileAsset");
  if (!(_DWORD)v7)
  {
    if (!(_BYTE)v38)
    {
      v24 = v39[0];
      *(_BYTE *)a3 = 0;
      *(_QWORD *)(a3 + 8) = v24;
      return re::Result<re::RealityFileAssetLoadDescriptorParameters,__CFError *>::~Result((uint64_t)&v38);
    }
    re::RealityFileRegistry::getOrMountRealityFile((re::RealityFileDescriptor *)v39, *(dispatch_queue_t **)(v6 + 192), (uint64_t)v36);
    v14 = (char *)v37;
    if (!v36[0])
    {
      v25 = v37;
      CFRetain(v25);
      *(_BYTE *)a3 = 0;
      *(_QWORD *)(a3 + 8) = v25;
LABEL_38:
      re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v36);
      return re::Result<re::RealityFileAssetLoadDescriptorParameters,__CFError *>::~Result((uint64_t)&v38);
    }
    if (v37)
      v15 = (char *)v37 + 8;
    if ((v40 & 1) != 0)
      v16 = *(char **)&v41[7];
    else
      v16 = v41;
    if (!strcmp(v16, "assetMap.json") || !strcmp(v16, "header.json") || !strcmp(v16, "dedupe.json"))
    {
      re::RealityFile::newDataByLoading((re::RealityFile *)v14, v16, (uint64_t)v32);
      v20 = v33;
      if (!v32[0])
      {
        v26 = v33;
        CFRetain(v26);
        v27 = v32[0];
        *(_BYTE *)a3 = 0;
        *(_QWORD *)(a3 + 8) = v26;
        if (v27)
          goto LABEL_36;
        v23 = v33;
LABEL_31:

LABEL_36:
        if (v14)

        goto LABEL_38;
      }
    }
    else
    {
      if (!v32[0])
      {
        if ((v34 & 1) != 0)
          v28 = *(_anonymous_namespace_ **)&v35[7];
        else
          v28 = (_anonymous_namespace_ *)v35;
        *(_BYTE *)a3 = 0;
        *(_QWORD *)(a3 + 8) = Error;
        if (!v32[0] && v33 && (v34 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v33 + 40))();
        goto LABEL_36;
      }
      re::RealityFile::newDataByLoading((re::RealityFile *)v14, (uint64_t)v33, (uint64_t)v30);
      v20 = v31;
      if (!v30[0])
      {
        v21 = v31;
        CFRetain(v21);
        v22 = v30[0];
        *(_BYTE *)a3 = 0;
        *(_QWORD *)(a3 + 8) = v21;
        if (v22)
          goto LABEL_36;
        v23 = v31;
        goto LABEL_31;
      }
    }
    *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 8) = v20;
    goto LABEL_36;
  }
  if ((v39[0] & 1) != 0)
    v11 = (_anonymous_namespace_ *)v39[1];
  else
    v11 = (_anonymous_namespace_ *)((char *)v39 + 1);
  *(_BYTE *)a3 = 0;
  *(_QWORD *)(a3 + 8) = v12;
  result = v38;
  if (v38)
  {
    if ((v39[0] & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v38 + 40))();
  }
  return result;
}

_QWORD *re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_0,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2FBB8;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_0,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2FBB8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_0,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::size()
{
  return 16;
}

void re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_1,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_1,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::operator()@<X0>(const char **a1@<X1>, const char **a2@<X2>, const char **a3@<X3>, uint64_t a4@<X8>)
{
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const __CFString *v9;
  uint64_t v10;
  const char *v11;
  _anonymous_namespace_ *v12;
  id Error;
  uint64_t result;
  _anonymous_namespace_ *RealityFileAssetLoadDescriptorParametersCFError;
  _anonymous_namespace_ *v16;
  _anonymous_namespace_ *v17;
  _anonymous_namespace_ *v18;
  __n128 v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  const char *v35;
  _QWORD v36[3];
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  char v49[8];
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  char v58;
  uint64_t v59;
  char v60[8];
  uint64_t v61;
  uint64_t v62;
  _BYTE v63[80];

  v5 = *a1;
  v6 = *a2;
  v7 = *a3;
  if (((*a1)[8] & 1) != 0)
    v8 = (const char *)*((_QWORD *)v5 + 2);
  else
    v8 = v5 + 9;
  if (!strcmp(v8, "RealityFileAsset"))
  {
    if (v60[0])
    {
      v51 = 0;
      v52 = 0;
      v53 = 0;
      v16 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v50, 0);
      *((_QWORD *)&v54 + 1) = 0;
      v55 = 0uLL;
      v17 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v54, 0);
      *((_QWORD *)&v56 + 1) = 0;
      v57 = 0uLL;
      re::DynamicString::setCapacity(&v56, 0);
      v58 = 0;
      v59 = 1;
      v49[0] = v61;
      re::DynamicString::operator=((re::DynamicString *)&v50, (re::DynamicString *)&v62);
      re::DynamicString::operator=((re::DynamicString *)&v54, (re::DynamicString *)v63);
      v35 = v6;
      v36[0] = strlen(v6);
      v18 = re::DynamicString::operator=((re::DynamicString *)&v56, (uint64_t)&v35);
      v58 = v63[64];
      re::RealityFileAssetLoadDescriptorFactory::make(v49, (re::DynamicString *)&v21, (uint64_t)&v35);
      if (v21 && (v22 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v21 + 40))();
      re::AssetLoadDescriptor::AssetLoadDescriptor((re::AssetLoadDescriptor *)&v21, (const re::AssetLoadDescriptor *)&v35);
      v19.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a4, (uint64_t)&v21);
      if ((_QWORD)v33)
      {
        if ((BYTE8(v33) & 1) != 0)
          (*(void (**)(double))(*(_QWORD *)v33 + 40))(v19.n128_f64[0]);
        v19 = 0uLL;
        v33 = 0u;
        v34 = 0u;
      }
      if (v28)
      {
        if (v32)
          (*(void (**)(__n128))(*(_QWORD *)v28 + 40))(v19);
        v32 = 0;
        v29 = 0;
        v30 = 0;
        v28 = 0;
        ++v31;
      }
      if (v23)
      {
        if (v27)
          (*(void (**)(__n128))(*(_QWORD *)v23 + 40))(v19);
        v27 = 0;
        v24 = 0;
        v25 = 0;
        v23 = 0;
        ++v26;
      }
      if (v21 && (v22 & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v21 + 40))(v19);
      if ((_QWORD)v47)
      {
        if ((BYTE8(v47) & 1) != 0)
          (*(void (**)(__n128))(*(_QWORD *)v47 + 40))(v19);
        v19 = 0uLL;
        v47 = 0u;
        v48 = 0u;
      }
      if (v42)
      {
        if (v46)
          (*(void (**)(__n128))(*(_QWORD *)v42 + 40))(v19);
        v46 = 0;
        v43 = 0;
        v44 = 0;
        v42 = 0;
        ++v45;
      }
      if (v37)
      {
        if (v41)
          (*(void (**)(__n128))(*(_QWORD *)v37 + 40))(v19);
        v41 = 0;
        v38 = 0;
        v39 = 0;
        v37 = 0;
        ++v40;
      }
      if (v35 && (v36[0] & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v35 + 40))(v19);
      if ((_QWORD)v56)
      {
        if ((BYTE8(v56) & 1) != 0)
          (*(void (**)(__n128))(*(_QWORD *)v56 + 40))(v19);
        v19 = 0uLL;
        v56 = 0u;
        v57 = 0u;
      }
      if ((_QWORD)v54)
      {
        if ((BYTE8(v54) & 1) != 0)
          (*(void (**)(__n128))(*(_QWORD *)v54 + 40))(v19);
        v19 = 0uLL;
        v54 = 0u;
        v55 = 0u;
      }
      if (v50 && (v51 & 1) != 0)
        (*(void (**)(__n128))(*v50 + 40))(v19);
    }
    else
    {
      v20 = v61;
      *(_BYTE *)a4 = 0;
      *(_QWORD *)(a4 + 8) = v20;
    }
    return re::Result<re::RealityFileAssetLoadDescriptorParameters,__CFError *>::~Result((uint64_t)v60);
  }
  else
  {
    re::DynamicString::format((re::DynamicString *)"Cannot resolve with a parent AssetLoadDescriptor of scheme %s. Expected scheme %s.", (re::DynamicString *)&v35, v8, "RealityFileAsset");
    if ((v36[0] & 1) != 0)
      v12 = (_anonymous_namespace_ *)v36[1];
    else
      v12 = (_anonymous_namespace_ *)((char *)v36 + 1);
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = Error;
    result = (uint64_t)v35;
    if (v35)
    {
      if ((v36[0] & 1) != 0)
        return (*(uint64_t (**)(void))(*(_QWORD *)v35 + 40))();
    }
  }
  return result;
}

_QWORD *re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_1,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2FC20;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_1,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2FC20;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_1,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::size()
{
  return 16;
}

uint64_t re::types::Ok<re::RealityFileAssetLoadDescriptorParameters>::Ok(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 8), (const re::DynamicString *)(a2 + 8));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 72), (const re::DynamicString *)(a2 + 72));
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  return a1;
}

uint64_t re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  if (*(_BYTE *)a1)
  {
    v3 = (_OWORD *)(a1 + 80);
    v2 = *(_QWORD *)(a1 + 80);
    if (v2)
    {
      if ((*(_BYTE *)(a1 + 88) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 96));
      *v3 = 0u;
      *(_OWORD *)(a1 + 96) = 0u;
    }
    v4 = *(_QWORD *)(a1 + 48);
    if (v4)
    {
      if ((*(_BYTE *)(a1 + 56) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 64));
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)(a1 + 64) = 0u;
    }
    v5 = (_QWORD *)(a1 + 16);
  }
  else
  {
    v5 = (_QWORD *)(a1 + 8);
  }
  if (*v5)
  {
    if ((v5[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[2]);
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
  }
  return a1;
}

uint64_t re::Result<re::RealityFileAssetLoadDescriptorParameters,__CFError *>::~Result(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  uint64_t v5;

  if (*(_BYTE *)a1)
  {
    v3 = (_OWORD *)(a1 + 80);
    v2 = *(_QWORD *)(a1 + 80);
    if (v2)
    {
      if ((*(_BYTE *)(a1 + 88) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 96));
      *v3 = 0u;
      *(_OWORD *)(a1 + 96) = 0u;
    }
    v4 = *(_QWORD *)(a1 + 48);
    if (v4)
    {
      if ((*(_BYTE *)(a1 + 56) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 64));
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)(a1 + 64) = 0u;
    }
    v5 = *(_QWORD *)(a1 + 16);
    if (v5)
    {
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a1 + 32));
      *(_OWORD *)(a1 + 16) = 0u;
      *(_OWORD *)(a1 + 32) = 0u;
    }
  }
  return a1;
}

uint64_t re::Result<re::RealityFileEntryStream,re::WrappedError>::~Result(uint64_t a1)
{
  uint64_t v2;
  char v4;

  if (*(_BYTE *)a1)
  {
    v2 = *(unsigned int *)(a1 + 224);
    if ((_DWORD)v2 != -1)
      off_24ED2FC78[v2]((int)&v4, (re::FileSeekableInputStream *)(a1 + 8));
    *(_DWORD *)(a1 + 224) = -1;
  }
  else
  {

  }
  return a1;
}

_QWORD *re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v8 + 40 * v9;
        v11 = v7 + 4;
        do
        {
          *v11 = 0;
          *(v11 - 3) = 0;
          *(v11 - 2) = 0;
          *(v11 - 4) = 0;
          *((_DWORD *)v11 - 2) = 0;
          v12 = *(_QWORD *)(v8 + 8);
          *(v11 - 4) = *(_QWORD *)v8;
          *(v11 - 3) = v12;
          *(_QWORD *)v8 = 0;
          *(_QWORD *)(v8 + 8) = 0;
          v13 = *(v11 - 2);
          *(v11 - 2) = *(_QWORD *)(v8 + 16);
          *(_QWORD *)(v8 + 16) = v13;
          v14 = *v11;
          *v11 = *(_QWORD *)(v8 + 32);
          *(_QWORD *)(v8 + 32) = v14;
          ++*(_DWORD *)(v8 + 24);
          ++*((_DWORD *)v11 - 2);
          re::DynamicArray<re::AssetLoadDescriptor>::deinit(v8);
          v11 += 5;
          v8 += 40;
        }
        while (v8 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    v6 = a2[2];
    if (v6 >= *(_QWORD *)(a1 + 16))
    {
      re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity((_QWORD *)a1, a2[2]);
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,0>(a2[4], (uint64_t *)(a2[4] + 40 * *(_QWORD *)(a1 + 16)), *(_QWORD *)(a1 + 32));
      v10 = *(_QWORD *)(a1 + 16);
      if (v10 != v6)
      {
        v11 = 5 * v10;
        v12 = (uint64_t *)(a2[4] + 8 * v11);
        v13 = *(_QWORD *)(a1 + 32) + 8 * v11;
        v14 = 40 * v6 - 8 * v11;
        do
        {
          v15 = re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray(v13, v12);
          v12 += 5;
          v13 = v15 + 40;
          v14 -= 40;
        }
        while (v14);
      }
    }
    else
    {
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,0>(a2[4], (uint64_t *)(a2[4] + 40 * v6), *(_QWORD *)(a1 + 32));
      v7 = *(_QWORD *)(a1 + 16);
      if (v6 != v7)
      {
        v8 = *(_QWORD *)(a1 + 32) + 40 * v6;
        v9 = 40 * v7 - 40 * v6;
        do
        {
          re::DynamicArray<re::AssetLoadDescriptor>::deinit(v8);
          v8 += 40;
          v9 -= 40;
        }
        while (v9);
      }
    }
    *(_QWORD *)(a1 + 16) = v6;
  }
  return a1;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,0>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t *v5;

  if ((uint64_t *)result != a2)
  {
    v5 = (uint64_t *)result;
    do
    {
      result = re::DynamicArray<re::AssetLoadDescriptor>::operator=(a3, v5);
      v5 += 5;
      a3 += 40;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addEmplace<re::RealityFileAssetProvider::PerTypeLoadCallbacks*&>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, uint64_t *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  id v15;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  v13 = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  v14 = *a5;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  if (v14)
    v15 = (id)(v14 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v13) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphNode>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_QWORD *)(v6 + 24);
        do
        {
          if ((*(_DWORD *)(v13 - 2) & 0x80000000) != 0)
          {
            v14 = *(v13 - 3);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 16) = *(v13 - 1);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 24) = *v13;
            *v13 = 0;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 4;
          --v10;
        }
        while (v10);
      }
      re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

uint64_t re::AssetLoader::registerAsset(re::AssetLoader *this, void *a2, const re::ExistingAssetInformation *a3)
{
  uint64_t v3;
  re::AssetHandle *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  _QWORD v9[2];
  uint64_t v10;
  re::AssetHandle *v11;

  (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)this + 104))(v9);
  if (v10)
  {
    v3 = 0;
    v4 = v11;
    v5 = 24 * v10;
    while (1)
    {
      v6 = *((_QWORD *)v4 + 1);
      if (v6)
      {
        v7 = atomic_load((unsigned int *)(v6 + 704));
        if (v7 != 2)
        {
          if (v7 == 3)
          {
            v3 = 2;
            goto LABEL_11;
          }
          re::AssetHandle::loadAsync(v4);
          v3 = 1;
        }
      }
      v4 = (re::AssetHandle *)((char *)v4 + 24);
      v5 -= 24;
      if (!v5)
        goto LABEL_11;
    }
  }
  v3 = 0;
LABEL_11:
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v9);
  return v3;
}

_QWORD *re::AssetLoader::findDependencies@<X0>(re::AssetLoader *this@<X0>, const re::IntrospectionBase **a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v5;
  _QWORD *result;
  uint64_t v7;
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  v5 = (_QWORD *)(*(uint64_t (**)(re::AssetLoader *))(*(_QWORD *)this + 112))(this);
  v8[0] = &off_24ED2FCA8;
  v8[1] = a3;
  v9 = v8;
  re::internal::AssetDependencyWalker::findAssetHandles(v5, a2, (uint64_t)v8);
  result = v9;
  if (v9 == v8)
  {
    v7 = 4;
    result = v8;
  }
  else
  {
    if (!v9)
      return result;
    v7 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

_QWORD *re::AssetLoader::internalFindAssetHandleFields@<X0>(re::AssetLoader *this@<X0>, const re::IntrospectionBase **a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v5;
  _QWORD *result;
  uint64_t v7;
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  v5 = (_QWORD *)(*(uint64_t (**)(re::AssetLoader *))(*(_QWORD *)this + 112))(this);
  v8[0] = &off_24ED2FD38;
  v8[1] = a3;
  v9 = v8;
  re::internal::AssetDependencyWalker::findAssetHandles(v5, a2, (uint64_t)v8);
  result = v9;
  if (v9 == v8)
  {
    v7 = 4;
    result = v8;
  }
  else
  {
    if (!v9)
      return result;
    v7 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

uint64_t re::AssetLoader::findRegistrationDependencies(re::AssetLoader *this, void *a2)
{
  return (*(uint64_t (**)(re::AssetLoader *, void *))(*(_QWORD *)this + 104))(this, a2);
}

uint64_t re::AssetLoader::createRuntimeData()
{
  return 1;
}

uint64_t re::AssetLoader::assetByteSize(re::AssetLoader *this, void *a2)
{
  return (*(uint64_t (**)(re::AssetLoader *, void *))(*(_QWORD *)this + 40))(this, a2);
}

size_t re::AssetLoader::assetIntrospectionByteSize(re::AssetLoader *this, re::AssetUtilities *a2)
{
  re **v3;
  const re::IntrospectionBase *v4;

  v3 = (re **)(*(uint64_t (**)(re::AssetLoader *))(*(_QWORD *)this + 112))(this);
  return re::AssetUtilities::computeIntrospectedDataSizeV2(a2, v3, v4);
}

uint64_t re::AssetLoader::assetNonIntrospectionNonSharedDataByteSize(re::AssetLoader *this, void *a2)
{
  return 0;
}

uint64_t re::AssetLoader::serializeAssetBlob()
{
  return 1;
}

uint64_t re::AssetLoader::cloneAsset(re::AssetLoader *this, const re::IntrospectionBase **a2, re::AssetSerializationScheme *a3)
{
  uint64_t v4;
  RESerializedPayload *v5;
  RESerializedPayload *v6;
  RESerializedPayload *v8;
  RESerializedPayload *v9;
  char v10[16];
  RESerializedPayload *v11;

  re::AssetLoader::makeSharedResourcePayload(this, a2, a3, &v11);
  v4 = (*(uint64_t (**)(re::AssetLoader *))(*(_QWORD *)this + 120))(this);
  v10[0] = 0;
  v5 = v11;
  v9 = v5;
  (*(void (**)(re::AssetLoader *, RESerializedPayload **, uint64_t, _UNKNOWN **, char *, _QWORD))(*(_QWORD *)this + 208))(this, &v9, v4, &re::PassthroughAssetSerialization::instance(void)::instance, v10, 0);

  v6 = v5;
  v8 = v6;
  (*(void (**)(re::AssetLoader *, RESerializedPayload **, uint64_t, const char *))(*(_QWORD *)this + 224))(this, &v8, v4, "unknown clone asset");

  return v4;
}

void re::AssetLoader::makeSharedResourcePayload(re::AssetLoader *this@<X0>, const re::IntrospectionBase **a2@<X1>, re::AssetSerializationScheme *a3@<X2>, RESerializedPayload **a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  RESerializedPayload *v10;
  re *v11;
  const char *v12;
  NSObject *v13;
  _QWORD v14[2];
  RESerializedPayload *v15;
  _QWORD v16[3];
  __int128 buf;
  uint64_t v18;
  re *p_buf;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v8 = (*(uint64_t (**)(re::AssetLoader *))(*(_QWORD *)this + 112))(this);
  v16[1] = 0;
  v16[2] = 0;
  v16[0] = a3;
  v14[0] = this;
  v14[1] = a2;
  v9 = re::globalAllocators((re *)v8)[2];
  *(_QWORD *)&buf = &off_24ED2FDB8;
  *((_QWORD *)&buf + 1) = v14;
  v18 = v9;
  p_buf = (re *)&buf;
  re::SerializedPayload::make(v8, a2, (uint64_t)v16, (uint64_t)&buf, &v15);
  v10 = v15;
  v15 = 0;
  v11 = p_buf;
  if (p_buf)
  {
    v11 = (re *)(**(uint64_t (***)(re *))p_buf)(p_buf);
    if (p_buf != (re *)&buf)
      v11 = (re *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 40))(v18);
  }
  if (!v10)
  {
    if (*(_DWORD *)(v8 + 16) == 8)
      v12 = *(const char **)(v8 + 48);
    else
      v12 = "<unknown>";
    v13 = *re::assetsLogObjects(v11);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v12;
      _os_log_fault_impl(&dword_224FE9000, v13, OS_LOG_TYPE_FAULT, "Asset type '%s' has not adopted resource sharing", (uint8_t *)&buf, 0xCu);
    }
  }
  *a4 = v10;
}

uint64_t re::AssetLoader::cloneAsset(re::AssetLoader *this, void *a2)
{
  uint64_t v4;
  void (**v6)(re::DefaultAssetSerialize *__hidden);
  uint64_t v7;

  re::DefaultAssetSerialize::DefaultAssetSerialize((re::DefaultAssetSerialize *)&v6, 0);
  v4 = (*(uint64_t (**)(re::AssetLoader *, void *, void (***)(re::DefaultAssetSerialize *__hidden)))(*(_QWORD *)this + 144))(this, a2, &v6);
  v6 = &off_24ED2D3D0;
  re::Optional<re::AssetPath>::~Optional((uint64_t)&v7);
  return v4;
}

void *re::AssetLoader::allocateAsset(re::AssetLoader *this)
{
  uint64_t v1;
  size_t v2;
  uint64_t *v3;
  void *v4;

  v1 = (*(uint64_t (**)(re::AssetLoader *))(*(_QWORD *)this + 112))(this);
  v2 = *(int *)(v1 + 20);
  v3 = re::globalAllocators((re *)v1);
  v4 = (void *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v3[2] + 32))(v3[2], *(unsigned int *)(v1 + 20), 1);
  bzero(v4, v2);
  (*(void (**)(uint64_t, _QWORD, void *))(v1 + 72))(v1, 0, v4);
  return v4;
}

uint64_t re::AssetLoader::allocateSampleAsset(re::AssetLoader *this)
{
  return (*(uint64_t (**)(re::AssetLoader *))(*(_QWORD *)this + 120))(this);
}

uint64_t re::AssetLoader::createRuntimeDataWithPayload(uint64_t a1, uint64_t a2, id *this, uint64_t a4)
{
  uint64_t v7;
  id v9;
  _QWORD v10[4];
  id v11[10];
  id v12;

  re::SerializedPayload::dynamicCast(this, &v12);
  if (v12)
  {
    re::SerializedPayload::blobData(&v12, &v9);
    re::DataSeekableInputStream::DataSeekableInputStream((uint64_t)v10, &v9, 1, 0);

    v7 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 24))(a1, a2, v10, a4);
    v10[0] = &off_24ED7BE48;

    v10[0] = &off_24ED7BDD0;
    re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)v11);
  }
  else
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 24))(a1, a2, 0, a4);
  }

  return v7;
}

uint64_t re::AssetLoader::initializeAssetWithSerializedDataFromPayloadWithoutRuntimeData(uint64_t a1, id *a2, uint64_t **a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  re *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  _BYTE *v15;
  NSObject *v16;
  uint64_t v18;
  _QWORD v19[3];
  id v20;
  _BYTE v21[12];
  _BYTE *v22;
  uint8_t buf[4];
  _BYTE *v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 112))(a1);
  if (*(_DWORD *)(v7 + 16) != 8)
  {
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) ", "info->type == IntrospectionType::kStructure", "initializeAssetWithSerializedDataFromPayloadWithoutRuntimeData", 209);
    _os_crash();
    __break(1u);
  }
  v9 = v7;
  re::SerializedPayload::dynamicCast(a2, &v20);
  if (v20)
  {
    v19[1] = 0;
    v19[2] = 0;
    v19[0] = a4;
    v11 = re::globalAllocators(v10);
    v12 = re::SerializedPayload::deserializeIntoStruct(&v20, v9, a3, (uint64_t)v19, v11[2]);
    v13 = v12;
    if ((v12 & 1) == 0)
    {
      v14 = *re::assetsLogObjects((re *)v12);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      {
        re::SerializedPayload::typeName(&v20, (re::DynamicString *)v21);
        if ((v21[8] & 1) != 0)
          v15 = v22;
        else
          v15 = &v21[9];
        *(_DWORD *)buf = 136315138;
        v24 = v15;
        _os_log_fault_impl(&dword_224FE9000, v14, OS_LOG_TYPE_FAULT, "Failed to deserialize payload for asset type '%s'", buf, 0xCu);
        if (*(_QWORD *)v21 && (v21[8] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)v21 + 40))();
      }
    }
  }
  else
  {
    v16 = *re::assetsLogObjects(v10);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
    {
      v18 = *(_QWORD *)(v9 + 48);
      *(_DWORD *)v21 = 136315138;
      *(_QWORD *)&v21[4] = v18;
      _os_log_fault_impl(&dword_224FE9000, v16, OS_LOG_TYPE_FAULT, "Unexpected payload object ignored by asset type '%s' (expected a serialized payload)", v21, 0xCu);
    }
    v13 = 0;
  }

  return v13;
}

uint64_t re::AssetLoader::initializeAssetWithSerializedDataFromPayload(uint64_t a1, id *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  re *v12;
  int v13;
  uint64_t v14;
  char v15;
  re *v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  id v21;
  uint8_t buf[8];
  id v23;
  id v24;

  re::SerializedPayload::dynamicCast(this, &v24);
  if (!v24)
  {
    v19 = *re::assetsLogObjects(v12);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_224FE9000, v19, OS_LOG_TYPE_DEBUG, "No serialized payload found", buf, 2u);
    }
    goto LABEL_11;
  }
  v23 = *this;
  v13 = (*(uint64_t (**)(uint64_t, id *, uint64_t, uint64_t))(*(_QWORD *)a1 + 296))(a1, &v23, a3, a4);

  if (v13)
  {
    re::SerializedPayload::serializedData(&v24, buf);
    v14 = objc_msgSend(*(id *)buf, "length");
    if (!*(_BYTE *)a5)
      *(_BYTE *)a5 = 1;
    *(_QWORD *)(a5 + 8) = v14;

    v21 = *this;
    v15 = re::AssetLoader::createRuntimeDataWithPayload(a1, a3, &v21, a6);

    if ((v15 & 1) == 0)
    {
      v17 = *re::assetsLogObjects(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl(&dword_224FE9000, v17, OS_LOG_TYPE_DEBUG, "createRuntimeData returned false for asset created from a payload", buf, 2u);
      }
      goto LABEL_8;
    }
LABEL_11:
    v18 = 1;
    goto LABEL_12;
  }
LABEL_8:
  v18 = 0;
LABEL_12:

  return v18;
}

uint64_t re::AssetLoader::postInitializeAssetFromPayload()
{
  return 1;
}

uint64_t re::AssetLoader::postInitializeAssetFromPayloadWithLogging(uint64_t a1, id *a2, uint64_t a3, const char *a4)
{
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep;
  uint64_t v9;
  std::chrono::system_clock::time_point v10;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v11;
  NSObject *v12;
  const char *v13;
  id v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  rep = std::chrono::system_clock::now().__d_.__rep_;
  v15 = *a2;
  v9 = (*(uint64_t (**)(uint64_t, id *, uint64_t))(*(_QWORD *)a1 + 216))(a1, &v15, a3);

  v10.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  v11 = rep - v10.__d_.__rep_;
  if (rep - v10.__d_.__rep_ >= 2000)
  {
    v12 = *re::assetsLogObjects((re *)v10.__d_.__rep_);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = "unknown asset";
      if (a4)
        v13 = a4;
      *(_DWORD *)buf = 136315394;
      v17 = v13;
      v18 = 2048;
      v19 = v11 / 1000;
      _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "Asset '%s' was in postInitializeAssetFromPayload for '%lld' ms.", buf, 0x16u);
    }
  }
  return v9;
}

void re::AssetLoader::resourceDidUpdate(uint64_t a1, uint64_t **a2, id *a3, uint64_t a4)
{
  id v7;

  v7 = *a3;
  re::AssetLoader::initializeAssetWithSerializedDataFromPayloadWithoutRuntimeData(a1, &v7, a2, a4);

}

uint64_t re::AssetLoader::shouldCompress(re::AssetLoader *this, void *a2)
{
  return 1;
}

void re::AssetLoader::serializableAsset(void *a1@<X1>, _QWORD *a2@<X8>)
{
  *a2 = a1;
  a2[1] = &off_24ED2FE78;
  a2[4] = a2 + 1;
}

void re::AssetLoader::checkCredentialsOfNetworkAsset(_WORD *a1@<X8>)
{
  *a1 = 257;
}

uint64_t re::AssetLoader::needsCustomSerializationCopy(re::AssetLoader *this, void *a2)
{
  return 0;
}

uint64_t re::AssetLoader::tryMakeCustomSerializationCopy(re::AssetLoader *this, void *a2)
{
  return 0;
}

void std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED2FCA8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED2FCA8;
  a2[1] = v2;
  return result;
}

re::AssetHandle *std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::operator()(uint64_t a1, re::AssetHandle **a2)
{
  return re::DynamicArray<re::AssetHandle>::add(*(_anonymous_namespace_ **)(a1 + 8), *a2);
}

uint64_t std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::target_type()
{
}

void std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED2FD38;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED2FD38;
  a2[1] = v2;
  return result;
}

_QWORD *std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;

  v3 = *a2;
  return re::DynamicArray<re::TransitionCondition *>::add(*(_QWORD **)(a1 + 8), &v3);
}

uint64_t std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::target_type()
{
}

void re::internal::CallableRef<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::~CallableRef()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableRef<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(***(_QWORD ***)(a1 + 8) + 56))(**(_QWORD **)(a1 + 8), a2, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8), 0);
}

uint64_t re::internal::CallableRef<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::cloneInto(uint64_t a1, uint64_t a2)
{
  _OWORD *v2;

  v2 = *(_OWORD **)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED2FE20;
  *(_OWORD *)(a2 + 8) = *v2;
  return a2;
}

uint64_t re::internal::CallableRef<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::moveInto(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
}

uint64_t re::internal::CallableRef<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::size()
{
  return 24;
}

void re::internal::Callable<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 56))(*(_QWORD *)(a1 + 8), a2, *(_QWORD *)(a1 + 16), 0);
}

uint64_t re::internal::Callable<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2FE20;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2FE20;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::size()
{
  return 24;
}

void std::__function::__func<re::AssetLoader::serializableAsset(void *)::$_0,std::allocator<re::AssetLoader::serializableAsset(void *)::$_0>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::AssetLoader::serializableAsset(void *)::$_0,std::allocator<re::AssetLoader::serializableAsset(void *)::$_0>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24ED2FE78;
  return result;
}

void std::__function::__func<re::AssetLoader::serializableAsset(void *)::$_0,std::allocator<re::AssetLoader::serializableAsset(void *)::$_0>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2FE78;
}

uint64_t std::__function::__func<re::AssetLoader::serializableAsset(void *)::$_0,std::allocator<re::AssetLoader::serializableAsset(void *)::$_0>,void ()(void *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AssetLoader::serializableAsset(void *)::$_0,std::allocator<re::AssetLoader::serializableAsset(void *)::$_0>,void ()(void *)>::target_type()
{
}

void `anonymous namespace'::assetLoadRequestAllocator(_anonymous_namespace_ *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
      byte_255827498 = 0;
      unk_255827490 = "AssetLoadRequest allocator";
    }
  }
}

re::AssetLoadRequest *re::AssetLoadRequest::AssetLoadRequest(re::AssetLoadRequest *this)
{
  _anonymous_namespace_ *v2;
  re::AssetLoadRequest::Data *v3;
  re::AssetLoadRequest::Data *v4;
  uint64_t v5;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED2FEF8;
  *((_QWORD *)this + 3) = 0;
  v4 = re::AssetLoadRequest::Data::Data(v3);
  v5 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v4;
  if (v5)

  return this;
}

re::AssetLoadRequest::Data *re::AssetLoadRequest::Data::Data(re::AssetLoadRequest::Data *this)
{
  _anonymous_namespace_ *v2;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = off_24ED2FF28;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_BYTE *)this + 64) = 0;
  *((_WORD *)this + 40) = 0;
  *((_BYTE *)this + 82) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_QWORD *)this + 15) = 0;
  re::DynamicString::setCapacity((_QWORD *)this + 12, 0);
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_BYTE *)this + 144) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_DWORD *)this + 56) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 260) = 0u;
  *(_QWORD *)((char *)this + 276) = 0x7FFFFFFFLL;
  *((_QWORD *)this + 37) = 0;
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 36) = 0;
  *((_DWORD *)this + 78) = 1;
  *((_DWORD *)this + 84) = 0;
  *((_QWORD *)this + 40) = 0;
  *((_QWORD *)this + 41) = 0;
  *(_QWORD *)((char *)this + 349) = 0;
  *((_QWORD *)this + 43) = 0;
  return this;
}

void re::AssetLoadRequest::setShouldLoadAndWaitForResourceSharingClients(re::AssetLoadRequest *this@<X0>, char a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  os_unfair_lock_s *v8;
  _BYTE *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;

  v8 = (os_unfair_lock_s *)(*((_QWORD *)this + 3) + 192);
  os_unfair_lock_lock(v8);
  v9 = (_BYTE *)*((_QWORD *)this + 3);
  if (v9[352])
  {
    v10 = "Cannot call AssetLoadRequest::setShouldLoadAndWaitForResourceSharingClients after the AssetLoadRequest already"
          " has assets added.";
  }
  else
  {
    if (!a3 || (a2 & 1) != 0)
    {
      v9[80] = a2;
      v9[81] = a3;
      *(_BYTE *)a4 = 1;
      goto LABEL_8;
    }
    v10 = "Cannot call AssetLoadRequest::setShouldLoadAndWaitForResourceSharingClients(BOOL shouldLoad, BOOL shouldWait) "
          "with shouldLoad set to false and shouldWait set to true. An AssetLoadRequest can't wait for preloading if it w"
          "ill not initiate preloading.";
  }
  re::WrappedError::make((re::WrappedError *)CFSTR("REAssetRefErrorDomain"), (const __CFString *)4, (uint64_t)v10, &v12);
  v11 = v12;
  v12 = 0;
  *(_BYTE *)a4 = 0;
  *(_QWORD *)(a4 + 8) = v11;

LABEL_8:
  os_unfair_lock_unlock(v8);
}

void re::AssetLoadRequest::setShouldBlockECSSendsUntilCompleted(re::AssetLoadRequest *this@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;

  v6 = (os_unfair_lock_s *)(*((_QWORD *)this + 3) + 192);
  os_unfair_lock_lock(v6);
  v7 = *((_QWORD *)this + 3);
  if (*(_BYTE *)(v7 + 352))
  {
    re::WrappedError::make((re::WrappedError *)CFSTR("REAssetRefErrorDomain"), (const __CFString *)4, (uint64_t)"Cannot call AssetLoadRequest::setShouldBlockECSSendsUntilCompleted after the AssetLoadRequest already has assets added.", &v10);
    v8 = v10;
    v10 = 0;
    *(_QWORD *)(a3 + 8) = v8;

    v9 = 0;
  }
  else
  {
    *(_BYTE *)(v7 + 82) = a2;
    v9 = 1;
  }
  *(_BYTE *)a3 = v9;
  os_unfair_lock_unlock(v6);
}

uint64_t re::AssetLoadRequest::Data::addAsset(re::AssetLoadRequest::Data *this, const re::AssetHandle *a2)
{
  re *v4;
  NSObject *v5;
  uint64_t v6;
  re::AssetHandle *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  re *v12;
  NSObject *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  char *v19;
  const char *v20;
  size_t v21;
  re *v22;
  NSObject *v23;
  uint64_t v24;
  char *v25;
  int v26;
  int v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  int v32;
  _QWORD *v34;
  char *v35;
  _QWORD *v36;
  char *v37;
  _QWORD *v38;
  char *v39;
  uint64_t v40;
  _BYTE v41[8];
  id v42;
  _OWORD v43[2];
  int v44;
  uint64_t v45;
  _QWORD v46[2];
  uint64_t v47;
  int v48;
  re::AssetHandle *v49;
  _BYTE buf[22];
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  _BYTE v55[22];
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v49 = 0;
  v46[1] = 0;
  v47 = 0;
  v46[0] = 0;
  v48 = 0;
  v44 = 0;
  memset(v43, 0, sizeof(v43));
  v45 = 0x7FFFFFFFLL;
  re::AssetManager::getAssetDependenciesFromAssetProvidersRecursive(*((_QWORD *)this + 3), (_anonymous_namespace_ *)v46, (uint64_t)v43, a2, 1, (uint64_t)v41);
  if (!v41[0])
  {
    v5 = *re::assetsLogObjects(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v38 = re::AssetHandle::assetInfo(a2);
      if ((v38[17] & 1) != 0)
        v39 = (char *)v38[18];
      else
        v39 = (char *)v38 + 137;
      v40 = re::WrappedError::localizedDescription(&v42);
      *(_DWORD *)v55 = 136315394;
      *(_QWORD *)&v55[4] = v39;
      *(_WORD *)&v55[12] = 2080;
      *(_QWORD *)&v55[14] = v40;
      _os_log_error_impl(&dword_224FE9000, v5, OS_LOG_TYPE_ERROR, "Failed to add dependencies of asset '%s' to the load request due to error: %s", v55, 0x16u);
    }
    v6 = v47;
    v47 = 0;
    if (v6)
    {
      v7 = v49;
      v8 = 24 * v6;
      do
      {
        re::AssetHandle::~AssetHandle(v7);
        v7 = (re::AssetHandle *)(v9 + 24);
        v8 -= 24;
      }
      while (v8);
    }
    ++v48;
  }
  v10 = *((_QWORD *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 1664));
  re::DynamicOverflowArray<unsigned long long,1ul>::DynamicOverflowArray((uint64_t)v55, (uint64_t *)(v10 + 1672));
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 1664));
  os_unfair_lock_lock((os_unfair_lock_t)this + 48);
  v11 = *((_DWORD *)this + 84);
  v13 = *re::assetsLogObjects(v12);
  if (v11 == 2)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v34 = re::AssetHandle::assetInfo(a2);
      if ((v34[17] & 1) != 0)
        v35 = (char *)v34[18];
      else
        v35 = (char *)v34 + 137;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v35;
      _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, "AssetLoadRequest can't add asset '%s' because it is in the kError state", buf, 0xCu);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 48);
  }
  else
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v36 = re::AssetHandle::assetInfo(a2);
      if ((v36[17] & 1) != 0)
        v37 = (char *)v36[18];
      else
        v37 = (char *)v36 + 137;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v37;
      _os_log_debug_impl(&dword_224FE9000, v13, OS_LOG_TYPE_DEBUG, "AssetLoadRequest add '%s'", buf, 0xCu);
    }
    if (*((_BYTE *)this + 356))
    {
      v14 = (char *)this + 296;
      v15 = v55;
    }
    else
    {
      *((_BYTE *)this + 356) = 1;
      v15 = (char *)this + 296;
      v14 = v55;
    }
    if (v15 != v14)
    {
      v16 = *(_QWORD *)v14;
      if (*(_QWORD *)v15)
      {
        if (v16)
          re::DynamicOverflowArray<unsigned long long,1ul>::copy((uint64_t)v15, (uint64_t)v14);
        else
          *((_QWORD *)v15 + 1) = 0;
        *((_DWORD *)v15 + 4) += 2;
      }
      else if (v16)
      {
        v17 = *((_QWORD *)v14 + 1);
        *(_QWORD *)v15 = v16;
        re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(v15, v17);
        *((_DWORD *)v15 + 4) += 2;
        re::DynamicOverflowArray<unsigned long long,1ul>::copy((uint64_t)v15, (uint64_t)v14);
      }
    }
    if (*((_DWORD *)this + 84))
      *((_DWORD *)this + 84) = 0;
    if (!*((_BYTE *)this + 352))
    {
      v18 = *((_QWORD *)re::AssetHandle::assetInfo(a2) + 10);
      if (v18 == -1)
        v18 = 0;
      *((_QWORD *)this + 11) = v18;
      v19 = (char *)re::AssetHandle::assetInfo(a2);
      if ((*((_QWORD *)v19 + 17) & 1) != 0)
        v20 = (const char *)*((_QWORD *)v19 + 18);
      else
        v20 = v19 + 137;
      v21 = strlen(v20);
      *(_QWORD *)buf = v20;
      *(_QWORD *)&buf[8] = v21;
      v22 = re::DynamicString::operator=((re::AssetLoadRequest::Data *)((char *)this + 96), (uint64_t)buf);
      v23 = *re::assetsLogObjects(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        v24 = *((_QWORD *)this + 11);
        if ((*((_BYTE *)this + 104) & 1) != 0)
          v25 = (char *)*((_QWORD *)this + 14);
        else
          v25 = (char *)this + 105;
        v26 = *((unsigned __int8 *)this + 81);
        v27 = *((unsigned __int8 *)this + 82);
        *(_DWORD *)buf = 134218754;
        *(_QWORD *)&buf[4] = v24;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v25;
        v51 = 1024;
        v52 = v26;
        v53 = 1024;
        v54 = v27;
        _os_log_impl(&dword_224FE9000, v23, OS_LOG_TYPE_DEFAULT, "AssetLoadRequest started loading first asset with id %llu (%s). m_shouldWaitForPeers = %u, m_shouldBlockECSUpdatesUntilCompleted = %u", buf, 0x22u);
      }
      *((std::chrono::steady_clock::time_point *)this + 16) = std::chrono::steady_clock::now();
      *((_BYTE *)this + 144) = 1;
    }
    *((_BYTE *)this + 352) = 1;
    if ((v55[16] & 1) != 0)
      v28 = &v56;
    else
      v28 = v57;
    *(_QWORD *)buf = v28;
    *(_QWORD *)&buf[8] = *(_QWORD *)&v55[8];
    *((_BYTE *)this + 354) = re::AssetLoadRequest::Data::addAssetToLoadingSet_stateLocked((uint64_t)this, (uint64_t *)a2, (uint64_t)buf) ^ 1;
    if (v47)
    {
      v29 = (uint64_t *)v49;
      v30 = 24 * v47;
      do
      {
        if ((v55[16] & 1) != 0)
          v31 = &v56;
        else
          v31 = v57;
        *(_QWORD *)buf = v31;
        *(_QWORD *)&buf[8] = *(_QWORD *)&v55[8];
        v32 = re::AssetLoadRequest::Data::addAssetToLoadingSet_stateLocked((uint64_t)this, v29, (uint64_t)buf) ^ 1;
        if (*((_BYTE *)this + 354))
          LOBYTE(v32) = 1;
        *((_BYTE *)this + 354) = v32;
        v29 += 3;
        v30 -= 24;
      }
      while (v30);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 48);
    atomic_store(1u, (unsigned __int8 *)(*((_QWORD *)this + 3) + 704));
  }
  if (*(_QWORD *)v55 && (v55[16] & 1) == 0)
    (*(void (**)(void))(**(_QWORD **)v55 + 40))();
  if (!v41[0])

  re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v43);
  return re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v46);
}

uint64_t re::AssetLoadRequest::Data::addAssetToLoadingSet_stateLocked(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  int canShareAssetOverNetwork;
  unsigned int v8;
  uint64_t v9;
  re *CombinedLoadState;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  _QWORD *v16;
  char *v17;
  const char *v18;
  uint64_t v19;
  _QWORD *v21;
  char *v22;
  _QWORD *v23;
  char *v24;
  uint64_t v25[3];
  char v26;
  char v27;
  uint8_t buf[24];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (a2[1]
    && (v6 = a1 + 240,
        !re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::contains(a1 + 240, (uint64_t)a2)))
  {
    re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(v6, (re::AssetHandle *)a2);
    v8 = atomic_load((unsigned int *)(a2[1] + 704));
    canShareAssetOverNetwork = re::AssetManager::canShareAssetOverNetwork(*(os_unfair_lock_s **)(a1 + 24), (const re::AssetHandle *)a2);
    memset(v25, 0, sizeof(v25));
    v27 = 0;
    re::AssetHandle::operator=(v25, a2);
    v26 = canShareAssetOverNetwork;
    v9 = *(_QWORD *)(a1 + 24);
    if (*(_BYTE *)(a1 + 81))
      *(_OWORD *)buf = *(_OWORD *)a3;
    else
      memset(buf, 0, 16);
    CombinedLoadState = (re *)re::AssetManager::getCombinedLoadState(v9, (re::AssetHandle *)v25, canShareAssetOverNetwork, v8, (uint64_t)buf);
    switch((_DWORD)CombinedLoadState)
    {
      case 2:
        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add(a1 + 200, (re::AssetHandle *)v25);
        v14 = *(_QWORD *)(a1 + 288);
        if (v14)
          re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(v14 + 24, (re::AssetHandle *)a2);
        if (*(_BYTE *)(a1 + 81))
          *(_OWORD *)buf = *(_OWORD *)a3;
        else
          memset(buf, 0, 16);
        re::AssetLoadRequest::Data::processFailedAsset_stateLocked(a1, a2[1], (uint64_t)buf);
        LOBYTE(canShareAssetOverNetwork) = 0;
        break;
      case 1:
        LOBYTE(canShareAssetOverNetwork) = re::AssetLoadRequest::Data::checkAssetDependencies_stateLocked(a1, (uint64_t)v25, a3);
        break;
      case 0:
        if (*(_BYTE *)(a1 + 80))
        {
          if (*(_QWORD *)(a3 + 8))
          {
            if (v26)
            {
              v12 = *(_QWORD *)(a1 + 24);
              if (*(_QWORD *)(v12 + 1208))
              {
                if (!*(_BYTE *)(v12 + 1443))
                {
                  CombinedLoadState = (re *)re::AssetHandle::assetInfo((re::AssetHandle *)a2);
                  v11 = *((_QWORD *)CombinedLoadState + 10);
                  if ((unint64_t)(v11 + 1) >= 2)
                    re::NetworkActionQueue::queueSyncActionPreloadOnLocalPeer((re::NetworkActionQueue *)(*(_QWORD *)(a1 + 24) + 768), v11);
                }
              }
            }
          }
        }
        switch(v8)
        {
          case 0u:
            v13 = *re::assetsLogObjects(CombinedLoadState);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            {
              v21 = re::AssetHandle::assetInfo((re::AssetHandle *)a2);
              if ((v21[17] & 1) != 0)
                v22 = (char *)v21[18];
              else
                v22 = (char *)v21 + 137;
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v22;
              _os_log_debug_impl(&dword_224FE9000, v13, OS_LOG_TYPE_DEBUG, "AssetLoadRequest async loading '%s'", buf, 0xCu);
            }
            re::AssetManager::loadAssetAsync(*(re::AssetManager **)(a1 + 24), (os_unfair_lock_s *)a2[1], 0);
            goto LABEL_33;
          case 1u:
            v15 = *re::assetsLogObjects(CombinedLoadState);
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              goto LABEL_33;
            v16 = re::AssetHandle::assetInfo((re::AssetHandle *)a2);
            if ((v16[17] & 1) != 0)
              v17 = (char *)v16[18];
            else
              v17 = (char *)v16 + 137;
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v17;
            v18 = "AssetLoadRequest already loading '%s'";
            break;
          case 2u:
            v15 = *re::assetsLogObjects(CombinedLoadState);
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              goto LABEL_33;
            v23 = re::AssetHandle::assetInfo((re::AssetHandle *)a2);
            if ((v23[17] & 1) != 0)
              v24 = (char *)v23[18];
            else
              v24 = (char *)v23 + 137;
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v24;
            v18 = "AssetLoadRequest already loaded '%s', but still waiting on peer";
            break;
          case 3u:
            re::internal::assertLog((re::internal *)4, v11, "assertion failure: '%s' (%s:line %i) The combined load state is not kFailed even though the local load state is kLoadFailed.", "!\"Unreachable code\"", "addAssetToLoadingSet_stateLocked", 238);
            _os_crash();
            __break(1u);
            JUMPOUT(0x22526520CLL);
          default:
            goto LABEL_33;
        }
        _os_log_debug_impl(&dword_224FE9000, v15, OS_LOG_TYPE_DEBUG, v18, buf, 0xCu);
LABEL_33:
        LOBYTE(canShareAssetOverNetwork) = re::AssetLoadRequest::Data::checkAssetDependencies_stateLocked(a1, (uint64_t)v25, a3);
        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add(a1 + 200, (re::AssetHandle *)v25);
        v19 = *(_QWORD *)(a1 + 288);
        if (v19)
          re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(v19 + 24, (re::AssetHandle *)a2);
        break;
    }
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v25);
  }
  else
  {
    LOBYTE(canShareAssetOverNetwork) = 1;
  }
  return canShareAssetOverNetwork & 1;
}

uint64_t re::AssetLoadRequest::Data::checkAssetDependencies_stateLocked(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7;
  int hasLoadingAssetPointer;
  uint64_t v9;
  re *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint8_t buf[4];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a2 + 25))
    return 1;
  v7 = *(_QWORD *)(a2 + 8);
  v18 = 0;
  hasLoadingAssetPointer = re::internal::AssetEntry::hasLoadingAssetPointer((re::internal::AssetEntry *)v7);
  v9 = 712;
  if (hasLoadingAssetPointer)
    v9 = 720;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(&v18, *(_QWORD *)(v7 + v9));
  v11 = v18;
  if (!v18)
    return 1;
  *(_BYTE *)(a2 + 25) = 1;
  v12 = *(_QWORD *)(v11 + 24);
  v13 = *re::assetsLogObjects(v10);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    if ((*(_BYTE *)(v7 + 168) & 1) != 0)
      v17 = *(_QWORD *)(v7 + 176);
    else
      v17 = v7 + 169;
    *(_DWORD *)buf = 136315138;
    v20 = v17;
    _os_log_debug_impl(&dword_224FE9000, v13, OS_LOG_TYPE_DEBUG, "AssetLoadRequest getting dependencies for '%s'", buf, 0xCu);
  }
  v14 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 1104), *(_QWORD *)(v7 + 264));
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v14 + 104))(buf, v14, v12);
  if (!v21)
  {
LABEL_11:
    re::DynamicArray<re::AssetHandle>::deinit((uint64_t)buf);
    if (v18)

    return 1;
  }
  v15 = v22;
  v16 = 24 * v21;
  while ((re::AssetLoadRequest::Data::addAssetToLoadingSet_stateLocked(a1, v15, a3) & 1) != 0)
  {
    v15 += 24;
    v16 -= 24;
    if (!v16)
      goto LABEL_11;
  }
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)buf);
  if (v18)

  return 0;
}

re::AssetHandle *re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add(uint64_t a1, re::AssetHandle *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  re::AssetHandle *result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  result = re::AssetHandle::AssetHandle((re::AssetHandle *)(*(_QWORD *)(a1 + 32) + 32 * v5), a2);
  *((_WORD *)result + 12) = *((_WORD *)a2 + 12);
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::AssetLoadRequest::Data::processFailedAsset_stateLocked(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  re *v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  uint64_t v11;
  _BYTE *v12;
  id *v13;
  id v14;
  id v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  _BYTE *v23;
  id v24;
  id v25;
  uint64_t v26;
  id v27;
  _BYTE buf[12];
  __int16 v29;
  _BYTE v30[10];
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v6 = (os_unfair_lock_s *)(a2 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 384));
  v8 = *(_QWORD *)(a2 + 728);
  if (*(_BYTE *)(v8 + 208))
  {
    if ((*(_BYTE *)(v8 + 224) & 1) != 0)
      v9 = *(const char **)(v8 + 232);
    else
      v9 = (const char *)(v8 + 225);
  }
  else
  {
    v9 = "Load failure on peer.";
  }
  v10 = *re::assetsLogObjects(v7);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    if ((*(_BYTE *)(a2 + 168) & 1) != 0)
      v26 = *(_QWORD *)(a2 + 176);
    else
      v26 = a2 + 169;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v26;
    v29 = 2080;
    *(_QWORD *)v30 = v9;
    _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "AssetLoadRequest failed because asset failed to load '%s' (%s)", buf, 0x16u);
  }
  *(_DWORD *)(a1 + 336) = 2;
  if ((*(_BYTE *)(a2 + 168) & 1) != 0)
    v11 = *(_QWORD *)(a2 + 176);
  else
    v11 = a2 + 169;
  re::DynamicString::format((re::DynamicString *)"failed to load '%s' (%s)", (re::DynamicString *)buf, v11, v9);
  if ((buf[8] & 1) != 0)
    v12 = *(_BYTE **)&v30[2];
  else
    v12 = &buf[9];
  re::WrappedError::make((re::WrappedError *)CFSTR("REAssetLoadRequestErrorDomain"), (const __CFString *)0xC8, (uint64_t)v12, &v27);
  v13 = (id *)(a1 + 344);
  if (v13 != &v27)
  {
    v14 = v27;
    v27 = 0;
    v15 = *v13;
    *v13 = v14;

  }
  v16 = *(_QWORD *)(a3 + 8);
  if (v16)
  {
    v17 = *(_QWORD **)a3;
    v18 = *(_QWORD *)a3 + 8 * v16;
    v19 = *(_QWORD *)(a2 + 528);
    while (1)
    {
      v20 = a2 + 544;
      if ((*(_DWORD *)(a2 + 536) & 1) == 0)
        v20 = *(_QWORD *)(a2 + 552);
      if (v19)
      {
        v21 = (_DWORD *)(v20 + 28);
        v22 = 32 * v19;
        while (*(_QWORD *)(v21 - 7) != *v17)
        {
          v21 += 8;
          v22 -= 32;
          if (!v22)
            goto LABEL_26;
        }
        if (*((_BYTE *)v21 - 4) && *v21 == 400)
          break;
      }
LABEL_26:
      if (++v17 == (_QWORD *)v18)
        goto LABEL_27;
    }
    re::DynamicString::append((re::DynamicString *)buf, " Resource memory limit hit cannot load asset!", 0x2DuLL);
    if ((buf[8] & 1) != 0)
      v23 = *(_BYTE **)&v30[2];
    else
      v23 = &buf[9];
    re::WrappedError::make((re::WrappedError *)CFSTR("REResourceLimitErrorDomain"), (const __CFString *)0x12C, (uint64_t)v23, &v27);
    if (v13 != &v27)
    {
      v24 = v27;
      v27 = 0;
      v25 = *v13;
      *v13 = v24;

    }
  }
LABEL_27:
  if (*(_QWORD *)buf && (buf[8] & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)buf + 40))();
  os_unfair_lock_unlock(v6);
}

void re::AssetLoadRequest::Data::update(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  re *v3;
  unsigned int v4;
  uint64_t os_unfair_lock_opaque;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint32_t v12;
  uint32_t v13;
  unint64_t v14;
  uint64_t v15;
  _anonymous_namespace_ *v16;
  unint64_t v17;
  char v18;
  unint64_t v19;
  os_unfair_lock_s *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t *v28;
  int v29;
  char v30;
  char *v31;
  uint64_t v32;
  int CombinedLoadState;
  uint64_t v34;
  uint64_t v35;
  __int128 *v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  int v43;
  uint64_t v44;
  int os_unfair_lock_opaque_low;
  re::AssetLoadRequest::Data *v46;
  int v47;
  uint64_t v48;
  char v49[8];
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  int v53;
  unint64_t v54;
  unint64_t *v55;
  _QWORD v56[2];
  char v57;
  uint64_t v58;
  _BYTE v59[18];
  __int16 v60;
  uint64_t v61;
  __int16 v62;
  unint64_t v63;
  uint8_t buf[16];
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v2 = this + 48;
  os_unfair_lock_lock(this + 48);
  v4 = this[84]._os_unfair_lock_opaque - 1;
  if (v4 <= 1)
  {
    if (!BYTE2(this[88]._os_unfair_lock_opaque))
    {
      os_unfair_lock_unlock(v2);
      return;
    }
    BYTE2(this[88]._os_unfair_lock_opaque) = 0;
  }
  os_unfair_lock_opaque = this[68]._os_unfair_lock_opaque;
  if ((_DWORD)os_unfair_lock_opaque)
  {
    v6 = 0;
    v7 = (int *)(*(_QWORD *)&this[64]._os_unfair_lock_opaque + 8);
    while (1)
    {
      v8 = *v7;
      v7 += 10;
      if (v8 < 0)
        break;
      if (os_unfair_lock_opaque == ++v6)
      {
        LODWORD(v6) = this[68];
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)os_unfair_lock_opaque != (_DWORD)v6)
  {
    v9 = v6;
    do
    {
      v10 = *(_QWORD *)(*(_QWORD *)&this[64]._os_unfair_lock_opaque + 40 * v9 + 24);
      if (!atomic_load((unsigned int *)(v10 + 704)))
      {
        v21 = *re::assetsLogObjects(v3);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          if ((*(_BYTE *)(v10 + 168) & 1) != 0)
            v48 = *(_QWORD *)(v10 + 176);
          else
            v48 = v10 + 169;
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v48;
          _os_log_error_impl(&dword_224FE9000, v21, OS_LOG_TYPE_ERROR, "AssetLoadRequest failed because asset got unloaded '%s'", buf, 0xCu);
        }
        LODWORD(v14) = 1;
        goto LABEL_80;
      }
      if (this[68]._os_unfair_lock_opaque <= (v6 + 1))
        v12 = v6 + 1;
      else
        v12 = this[68]._os_unfair_lock_opaque;
      while (1)
      {
        v9 = (v6 + 1);
        if (v12 - 1 == (_DWORD)v6)
          break;
        LODWORD(v6) = v6 + 1;
        v13 = v9;
        if ((*(_DWORD *)(*(_QWORD *)&this[64]._os_unfair_lock_opaque + 40 * v9 + 8) & 0x80000000) != 0)
          goto LABEL_20;
      }
      v13 = v12;
LABEL_20:
      LODWORD(v6) = v13;
    }
    while ((_DWORD)os_unfair_lock_opaque != v13);
  }
  v14 = 1;
  if (v4 < 2)
    goto LABEL_80;
  v15 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  os_unfair_lock_lock((os_unfair_lock_t)(v15 + 1664));
  re::DynamicOverflowArray<unsigned long long,1ul>::DynamicOverflowArray((uint64_t)v56, (uint64_t *)(v15 + 1672));
  os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 1664));
  v51 = 0;
  v52 = 0;
  v53 = 1;
  v54 = 0;
  v55 = 0;
  if (LOBYTE(this[89]._os_unfair_lock_opaque))
  {
    v17 = *(_QWORD *)&this[76]._os_unfair_lock_opaque;
    re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(&v51, v17);
    v18 = v53;
    v53 += 2;
    if ((v18 & 1) != 0)
      v19 = 1;
    else
      v19 = v54;
    if (v19 < v17)
      re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(&v51, v17);
    if ((this[78]._os_unfair_lock_opaque & 1) != 0)
      v20 = this + 80;
    else
      v20 = *(os_unfair_lock_s **)&this[82]._os_unfair_lock_opaque;
    v22 = *(_QWORD *)&this[76]._os_unfair_lock_opaque;
    if (v22)
    {
      v14 = 8 * v22;
      do
      {
        *(_QWORD *)v59 = *(_QWORD *)&v20->_os_unfair_lock_opaque;
        re::DynamicOverflowArray<unsigned long long,1ul>::indexOf((uint64_t)v56, v59, (uint64_t)buf);
        if (buf[0])
          re::DynamicOverflowArray<unsigned long long,1ul>::add((uint64_t)&v51, v59);
        v20 += 2;
        v14 -= 8;
      }
      while (v14);
    }
  }
  if ((int)*(_QWORD *)&this[54]._os_unfair_lock_opaque < 1)
  {
LABEL_62:
    LODWORD(v14) = 0;
    goto LABEL_74;
  }
  v23 = *(_QWORD *)&this[54]._os_unfair_lock_opaque + 1;
  while (1)
  {
    v24 = (v23 - 2);
    v25 = *(_QWORD *)&this[54]._os_unfair_lock_opaque;
    if (v25 <= v24)
    {
      v58 = 0;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v59 = 136315906;
      *(_QWORD *)&v59[4] = "operator[]";
      *(_WORD *)&v59[12] = 1024;
      *(_DWORD *)&v59[14] = 789;
      v60 = 2048;
      v61 = (v23 - 2);
      v62 = 2048;
      v63 = v25;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_92:
      v58 = 0;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v59 = 136315906;
      *(_QWORD *)&v59[4] = "operator[]";
      *(_WORD *)&v59[12] = 1024;
      *(_DWORD *)&v59[14] = 789;
      v60 = 2048;
      v61 = (v23 - 2);
      v62 = 2048;
      v63 = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_93:
      v58 = 0;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v59 = 136315906;
      *(_QWORD *)&v59[4] = "operator[]";
      *(_WORD *)&v59[12] = 1024;
      *(_DWORD *)&v59[14] = 789;
      v60 = 2048;
      v61 = (v23 - 2);
      v62 = 2048;
      v63 = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_94:
      v58 = 0;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v59 = 136315906;
      *(_QWORD *)&v59[4] = "operator[]";
      *(_WORD *)&v59[12] = 1024;
      *(_DWORD *)&v59[14] = 789;
      v60 = 2048;
      v61 = (v23 - 2);
      v62 = 2048;
      v63 = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_95:
      re::internal::assertLog((re::internal *)4, v40, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "update", 345);
      _os_crash();
      __break(1u);
    }
    re::AssetHandle::AssetHandle((re::AssetHandle *)v49, (const re::AssetHandle *)(*(_QWORD *)&this[58]._os_unfair_lock_opaque + 32 * v24));
    v26 = atomic_load((unsigned int *)(v50 + 704));
    v14 = *(_QWORD *)&this[54]._os_unfair_lock_opaque;
    if (v14 <= v24)
      goto LABEL_92;
    v27 = *(_QWORD *)&this[58]._os_unfair_lock_opaque + 32 * v24;
    if ((v53 & 1) != 0)
      v28 = &v54;
    else
      v28 = v55;
    *(_QWORD *)buf = v28;
    *(_QWORD *)&buf[8] = v52;
    if (!re::AssetLoadRequest::Data::checkAssetDependencies_stateLocked((uint64_t)this, v27, (uint64_t)buf))
      goto LABEL_73;
    v14 = *(_QWORD *)&this[54]._os_unfair_lock_opaque;
    if (v14 <= v24)
      goto LABEL_93;
    v14 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
    v29 = *(unsigned __int8 *)(*(_QWORD *)&this[58]._os_unfair_lock_opaque + 32 * v24 + 24);
    if (BYTE1(this[20]._os_unfair_lock_opaque))
    {
      re::DynamicOverflowArray<unsigned long long,1ul>::DynamicOverflowArray((uint64_t)buf, (uint64_t *)&v51);
      v30 = v65;
      v31 = (char *)v66;
      v32 = *(_QWORD *)&buf[8];
    }
    else
    {
      v32 = 0;
      v31 = 0;
      memset(buf, 0, sizeof(buf));
      v30 = 1;
      LODWORD(v65) = 1;
      *((_QWORD *)&v65 + 1) = 0;
      *(_QWORD *)&v66 = 0;
    }
    if ((v30 & 1) != 0)
      v31 = (char *)&v65 + 8;
    *(_QWORD *)v59 = v31;
    *(_QWORD *)&v59[8] = v32;
    CombinedLoadState = re::AssetManager::getCombinedLoadState(v14, (re::AssetHandle *)v49, v29 != 0, v26, (uint64_t)v59);
    if (*(_QWORD *)buf && (v65 & 1) == 0)
      (*(void (**)(void))(**(_QWORD **)buf + 40))();
    if (CombinedLoadState)
    {
      v14 = *(_QWORD *)&this[54]._os_unfair_lock_opaque;
      if (v14 <= v24)
        goto LABEL_94;
      if (v14 - 1 > v24)
      {
        v34 = *(_QWORD *)&this[58]._os_unfair_lock_opaque;
        v35 = v34 + 32 * v14;
        v36 = (__int128 *)(v34 + 32 * v24);
        v37 = *v36;
        *(_QWORD *)v36 = 0;
        v38 = *(_QWORD *)(v35 - 24);
        *(_QWORD *)v36 = *(_QWORD *)(v35 - 32);
        *((_QWORD *)v36 + 1) = v38;
        *(_OWORD *)(v35 - 32) = v37;
        v39 = *((_QWORD *)v36 + 2);
        *((_QWORD *)v36 + 2) = *(_QWORD *)(v35 - 16);
        *(_QWORD *)(v35 - 16) = v39;
        *((_WORD *)v36 + 12) = *(_WORD *)(v35 - 8);
        v14 = *(_QWORD *)&this[54]._os_unfair_lock_opaque;
      }
      re::AssetHandle::~AssetHandle((re::AssetHandle *)(*(_QWORD *)&this[58]._os_unfair_lock_opaque + 32 * v14 - 32));
      --*(_QWORD *)&this[54]._os_unfair_lock_opaque;
      ++this[56]._os_unfair_lock_opaque;
      if (CombinedLoadState != 1)
        break;
    }
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v49);
    if ((unint64_t)--v23 <= 1)
      goto LABEL_62;
  }
  if (CombinedLoadState != 2)
    goto LABEL_95;
  if (BYTE1(this[20]._os_unfair_lock_opaque))
  {
    re::DynamicOverflowArray<unsigned long long,1ul>::DynamicOverflowArray((uint64_t)buf, (uint64_t *)&v51);
    v41 = *(_QWORD *)&buf[8];
    if ((v65 & 1) != 0)
      v42 = (char *)&v65 + 8;
    else
      v42 = (char *)v66;
  }
  else
  {
    v41 = 0;
    memset(buf, 0, sizeof(buf));
    LODWORD(v65) = 1;
    v42 = (char *)&v65 + 8;
    *((_QWORD *)&v65 + 1) = 0;
    *(_QWORD *)&v66 = 0;
  }
  *(_QWORD *)v59 = v42;
  *(_QWORD *)&v59[8] = v41;
  re::AssetLoadRequest::Data::processFailedAsset_stateLocked((uint64_t)this, v50, (uint64_t)v59);
  if (*(_QWORD *)buf)
  {
    v43 = v65;
    if ((v65 & 1) == 0)
    {
      (*(void (**)(void))(**(_QWORD **)buf + 40))();
      v43 = v65;
    }
    LODWORD(v65) = (v43 | 1) + 2;
  }
LABEL_73:
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v49);
  LODWORD(v14) = 1;
LABEL_74:
  if (v51 && (v53 & 1) == 0)
    (*(void (**)(void))(*v51 + 40))();
  if (v56[0] && (v57 & 1) == 0)
    (*(void (**)(void))(*(_QWORD *)v56[0] + 40))();
LABEL_80:
  v44 = *(_QWORD *)&this[54]._os_unfair_lock_opaque;
  os_unfair_lock_opaque_low = LOBYTE(this[88]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2);
  re::AssetLoadRequest::Data::checkForLongLoadAndLogDetails((re::AssetLoadRequest::Data *)this);
  if ((_DWORD)v14)
  {
    v46 = (re::AssetLoadRequest::Data *)this;
    v47 = 0;
    goto LABEL_85;
  }
  if (!v44 && os_unfair_lock_opaque_low)
  {
    v46 = (re::AssetLoadRequest::Data *)this;
    v47 = 1;
LABEL_85:
    re::AssetLoadRequest::Data::complete((uint64_t)v46, v47, 0);
  }
}

void re::AssetLoadRequest::Data::checkForLongLoadAndLogDetails(re::AssetLoadRequest::Data *this)
{
  std::chrono::steady_clock::time_point v2;
  double v3;
  double v4;
  uint64_t v5;
  re *v6;
  NSObject *v7;
  _BOOL8 v8;
  uint64_t v9;
  double LoggingThreshold;
  const char *v11;
  uint64_t v12;
  int v13;
  const re::AssetHandle *v14;
  const re::AssetHandle *v15;
  uint64_t v16;
  unsigned int v17;
  re *v18;
  char *v19;
  unint64_t v20;
  char v21;
  unint64_t v22;
  int v23;
  _DWORD *v24;
  const char **v25;
  _DWORD *v26;
  const char **v27;
  uint64_t v28;
  __int128 *v29;
  const char **v30;
  __int128 *v31;
  const char **v32;
  __int128 v33;
  int v34;
  NSObject *v35;
  const char *v36;
  _DWORD *v37;
  unsigned int v38;
  const char *v39;
  NSObject *v40;
  const char *v41;
  uint32_t v42;
  NSObject *v43;
  NSObject *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint8_t v49[24];
  uint8_t v50[4];
  char *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  const char *v55;
  _BYTE buf[22];
  __int16 v57;
  const char *v58;
  _QWORD v59[6];

  v59[4] = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 144))
  {
    v2.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    v3 = 0.0;
    if (*((_BYTE *)this + 144))
      v3 = 1.0;
    v4 = *((double *)this + 17) + (double)(v2.__d_.__rep_ - *((_QWORD *)this + 16)) / 1000000000.0 * v3;
    {
      os_unfair_lock_lock((os_unfair_lock_t)this + 48);
      v5 = *((_QWORD *)this + 27);
      v7 = *re::assetsLogObjects(v6);
      v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
      if (v8)
      {
        v9 = *((_QWORD *)this + 11);
        v11 = "and contains these assets:";
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v9;
        if (!v5)
          v11 = "";
        *(_WORD *)&buf[12] = 2048;
        *(double *)&buf[14] = LoggingThreshold;
        v57 = 2080;
        v58 = v11;
        _os_log_impl(&dword_224FE9000, v7, OS_LOG_TYPE_DEFAULT, "AssetLoadRequest with first assetId %llu exceeded loading threshold of %f seconds %s", buf, 0x20u);
      }
      v46 = 0;
      while (1)
      {
        v12 = *((_QWORD *)this + 27);
        if (v12)
          break;
LABEL_63:
        if (++v46 == 4)
        {
          *((double *)this + 17) = *((double *)this + 17)
                                 + (double)(std::chrono::steady_clock::now().__d_.__rep_ - *((_QWORD *)this + 16))
                                 / 1000000000.0;
          *((_BYTE *)this + 144) = 0;
          os_unfair_lock_unlock((os_unfair_lock_t)this + 48);
          return;
        }
      }
      v13 = dword_2260F8F4C[v46];
      v14 = (const re::AssetHandle *)*((_QWORD *)this + 29);
      v15 = (const re::AssetHandle *)((char *)v14 + 32 * v12);
      v47 = v13 - 1;
      v48 = v13;
      while (1)
      {
        v16 = *((_QWORD *)v14 + 1);
        os_unfair_lock_lock((os_unfair_lock_t)(v16 + 384));
        v17 = atomic_load((unsigned int *)(v16 + 704));
        if (v17 == v13)
          break;
LABEL_62:
        os_unfair_lock_unlock((os_unfair_lock_t)(v16 + 384));
        v14 = (const re::AssetHandle *)((char *)v14 + 32);
        if (v14 == v15)
          goto LABEL_63;
      }
      re::AssetHandle::AssetHandle((re::AssetHandle *)v49, v14);
      v18 = (re *)re::AssetHandle::assetInfo((re::AssetHandle *)v49);
      if ((*((_QWORD *)v18 + 17) & 1) != 0)
        v19 = (char *)*((_QWORD *)v18 + 18);
      else
        v19 = (char *)v18 + 137;
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      *(_DWORD *)&buf[16] = 1;
      v58 = 0;
      v59[0] = 0;
      if (!*(_QWORD *)(v16 + 520))
        goto LABEL_67;
      v20 = *(_QWORD *)(v16 + 528);
      *(_QWORD *)buf = *(_QWORD *)(v16 + 520);
      re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::setCapacity((uint64_t *)buf, v20);
      v21 = buf[16];
      *(_DWORD *)&buf[16] += 2;
      v22 = *(_QWORD *)(v16 + 528);
      if (v22 >= *(_QWORD *)&buf[8])
      {
        re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::setCapacity((uint64_t *)buf, *(_QWORD *)(v16 + 528));
        if ((*(_DWORD *)(v16 + 536) & 1) != 0)
          v26 = (_DWORD *)(v16 + 544);
        else
          v26 = *(_DWORD **)(v16 + 552);
        if ((buf[16] & 1) != 0)
          v27 = &v58;
        else
          v27 = (const char **)v59[0];
        v18 = (re *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState*>(v26, &v26[8 * *(_QWORD *)&buf[8]], (uint64_t)v27);
        if ((*(_BYTE *)(v16 + 536) & 1) != 0)
          v28 = v16 + 544;
        else
          v28 = *(_QWORD *)(v16 + 552);
        if (*(_QWORD *)&buf[8] != v22)
        {
          v29 = (__int128 *)(v28 + 32 * v22);
          v30 = (const char **)v59[0];
          if ((buf[16] & 1) != 0)
            v30 = &v58;
          v31 = (__int128 *)(v28 + 32 * *(_QWORD *)&buf[8]);
          v32 = &v30[4 * *(_QWORD *)&buf[8]];
          do
          {
            v33 = *v31;
            v32[2] = (const char *)*((_QWORD *)v31 + 2);
            *(_OWORD *)v32 = v33;
            v34 = *((unsigned __int8 *)v31 + 24);
            *((_BYTE *)v32 + 24) = v34;
            if (v34)
              *((_DWORD *)v32 + 7) = *((_DWORD *)v31 + 7);
            v31 += 2;
            v32 += 4;
          }
          while (v31 != v29);
        }
      }
      else
      {
        v23 = v21 & 1;
        v24 = (*(_DWORD *)(v16 + 536) & 1) != 0 ? (_DWORD *)(v16 + 544) : *(_DWORD **)(v16 + 552);
        v25 = v23 ? &v58 : (const char **)v59[0];
        v18 = (re *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState*>(v24, &v24[8 * v22], (uint64_t)v25);
      }
      *(_QWORD *)&buf[8] = v22;
      if (v22)
      {
        v35 = *re::assetsLogObjects(v18);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
LABEL_58:
          if (*(_QWORD *)buf)
          {
            if ((buf[16] & 1) == 0)
              (*(void (**)(void))(**(_QWORD **)buf + 40))();
          }
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v49);
          v13 = v48;
          goto LABEL_62;
        }
        v36 = "Unloaded";
        if (v47 <= 2)
          v36 = off_24ED2FFE0[v47];
        v37 = (_DWORD *)(v59[0] + 8);
        if ((buf[16] & 1) != 0)
          v37 = v59;
        v38 = *v37 - 1;
        v39 = "Unloaded";
        if (v38 <= 2)
          v39 = off_24ED2FFE0[v38];
        *(_DWORD *)v50 = 136315650;
        v51 = v19;
        v52 = 2080;
        v53 = v36;
        v54 = 2080;
        v55 = v39;
        v40 = v35;
        v41 = "%s has local load state: %s and backboardd load state is: %s";
        v42 = 32;
      }
      else
      {
LABEL_67:
        if (*((_BYTE *)this + 80))
        {
          v43 = *re::assetsLogObjects(v18);
          v18 = (re *)os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v18)
          {
            *(_DWORD *)v50 = 136315138;
            v51 = v19;
            _os_log_impl(&dword_224FE9000, v43, OS_LOG_TYPE_DEFAULT, "%s has not received any backboardd client load states", v50, 0xCu);
          }
        }
        v44 = *re::assetsLogObjects(v18);
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          goto LABEL_58;
        v45 = "Unloaded";
        if (v47 <= 2)
          v45 = off_24ED2FFE0[v47];
        *(_DWORD *)v50 = 136315394;
        v51 = v19;
        v52 = 2080;
        v53 = v45;
        v40 = v44;
        v41 = "%s has local load state: %s";
        v42 = 22;
      }
      _os_log_impl(&dword_224FE9000, v40, OS_LOG_TYPE_DEFAULT, v41, v50, v42);
      goto LABEL_58;
    }
  }
}

void re::AssetLoadRequest::Data::complete(uint64_t a1, int a2, int a3)
{
  os_unfair_lock_s *v6;
  int v7;
  re *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  int v13;
  id v14;
  uint64_t v15;
  id *v16;
  NSObject *v17;
  re::AssetLoadRequest::Data *v18;
  _QWORD v19[5];
  int v20;
  char v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  const char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v6 = (os_unfair_lock_s *)(a1 + 192);
  if (a2)
    v7 = 1;
  else
    v7 = 2;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
  *(_DWORD *)(a1 + 336) = v7;
  os_unfair_lock_unlock(v6);
  v9 = *re::assetsLogObjects(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v10 = *(_QWORD *)(a1 + 88);
    if ((*(_BYTE *)(a1 + 104) & 1) != 0)
      v11 = *(_QWORD *)(a1 + 112);
    else
      v11 = a1 + 105;
    v12 = "failed";
    *(_DWORD *)buf = 134218498;
    v23 = v10;
    v24 = 2080;
    if (a2)
      v12 = "succeeded";
    v25 = v11;
    v26 = 2080;
    v27 = v12;
    _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEFAULT, "AssetLoadRequest with first assetId %llu (%s) %s loading.", buf, 0x20u);
  }
  if (*(_BYTE *)(a1 + 144))
  {
    *(double *)(a1 + 136) = *(double *)(a1 + 136)
                          + (double)(std::chrono::steady_clock::now().__d_.__rep_ - *(_QWORD *)(a1 + 128))
                          / 1000000000.0;
    *(_BYTE *)(a1 + 144) = 0;
  }
  if (*(_QWORD *)(a1 + 56))
  {
    os_unfair_lock_lock(v6);
    v13 = *(unsigned __int8 *)(a1 + 353);
    *(_BYTE *)(a1 + 353) = 1;
    os_unfair_lock_unlock(v6);
    if (!v13)
    {
      v14 = (id)(a1 + 8);
      if (a3 == 1 || *(_BYTE *)(a1 + 64))
      {
        if (*(_BYTE *)(a1 + 64))
          v16 = (id *)(a1 + 72);
        else
          v16 = (id *)(*(_QWORD *)(a1 + 24) + 584);
        v17 = *v16;
        v19[0] = MEMORY[0x24BDAC760];
        v19[1] = 0x40000000;
        v19[2] = ___ZN2re16AssetLoadRequest4Data8completeEbNS0_11QueueOptionE_block_invoke;
        v19[3] = &__block_descriptor_tmp_4;
        v19[4] = a1;
        v21 = a2;
        v20 = v7;
        dispatch_async(v17, v19);

      }
      else
      {
        buf[0] = a2;
        v15 = *(_QWORD *)(a1 + 56);
        if (v15)
        {
          (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v15 + 48))(v15, buf);
          os_unfair_lock_lock(v6);
          *(_BYTE *)(a1 + 353) = 0;
          os_unfair_lock_unlock(v6);

        }
        else
        {
          v18 = (re::AssetLoadRequest::Data *)std::__throw_bad_function_call[abi:nn180100]();
          re::AssetLoadRequest::Data::progress(v18);
        }
      }
    }
  }
}

float re::AssetLoadRequest::Data::progress(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  float v3;

  v2 = this + 48;
  os_unfair_lock_lock(this + 48);
  v3 = 1.0;
  if (this[84]._os_unfair_lock_opaque != 1)
    v3 = 1.0
       - exp2f(-(float)((unint64_t)this[67]._os_unfair_lock_opaque - *(_QWORD *)&this[54]._os_unfair_lock_opaque));
  os_unfair_lock_unlock(v2);
  return v3;
}

BOOL re::AssetLoadRequest::Data::tryStopRequest(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  int v3;
  void **v4;
  id v5;
  void *v6;
  id v8;

  v2 = this + 48;
  os_unfair_lock_lock(this + 48);
  v3 = BYTE1(this[88]._os_unfair_lock_opaque);
  if (!BYTE1(this[88]._os_unfair_lock_opaque) && !this[84]._os_unfair_lock_opaque)
  {
    this[84]._os_unfair_lock_opaque = 2;
    re::WrappedError::make((re::WrappedError *)CFSTR("REAssetLoadRequestErrorDomain"), (const __CFString *)0x64, (uint64_t)"Cancelled", &v8);
    v4 = (void **)&this[86];
    if (&this[86] != (os_unfair_lock_s *)&v8)
    {
      v5 = v8;
      v8 = 0;
      v6 = *v4;
      *v4 = v5;

    }
  }
  os_unfair_lock_unlock(v2);
  return v3 == 0;
}

void re::AssetLoadRequest::Data::setCompletionHandler(uint64_t a1, uint64_t a2, id *a3)
{
  _QWORD *v6;
  id v7;
  id v8;
  unsigned __int8 v9[8];
  id v10;

  v6 = (_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 56))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
    *(_DWORD *)(a1 + 336) = 0;
    *(_BYTE *)(a1 + 352) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
  }
  std::function<void ()(BOOL)>::operator=(v6, a2);
  if (!a3 || (v7 = *(id *)(*(_QWORD *)(a1 + 24) + 584), v8 = *a3, v7, v8 == v7))
  {
    v9[0] = 0;
  }
  else
  {
    v9[0] = 1;
    v10 = *a3;
  }
  re::Optional<re::dispatch::Queue>::operator=(a1 + 64, v9);
  if (v9[0])

}

_QWORD *std::function<void ()(BOOL)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v6, a2);
  std::__function::__value_func<void ()(BOOL)>::swap[abi:nn180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

uint64_t re::Optional<re::dispatch::Queue>::operator=(uint64_t a1, unsigned __int8 *a2)
{
  int v3;
  BOOL v4;
  BOOL v5;
  BOOL v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;

  v3 = *a2;
  if (*(_BYTE *)a1)
    v4 = 0;
  else
    v4 = v3 == 0;
  if (!v4)
  {
    if (*(_BYTE *)a1)
      v5 = v3 == 0;
    else
      v5 = 0;
    if (v5)
    {

      *(_BYTE *)a1 = 0;
    }
    else
    {
      if (*(_BYTE *)a1)
        v6 = 1;
      else
        v6 = v3 == 0;
      if (v6)
      {
        if ((unsigned __int8 *)a1 != a2)
        {
          v7 = *((_QWORD *)a2 + 1);
          *((_QWORD *)a2 + 1) = 0;
          v8 = *(void **)(a1 + 8);
          *(_QWORD *)(a1 + 8) = v7;

        }
      }
      else
      {
        *(_BYTE *)a1 = 1;
        v9 = *((_QWORD *)a2 + 1);
        *((_QWORD *)a2 + 1) = 0;
        *(_QWORD *)(a1 + 8) = v9;
      }
    }
  }
  return a1;
}

void ___ZN2re16AssetLoadRequest4Data8completeEbNS0_11QueueOptionE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;

  v1 = *(_QWORD *)(a1 + 32);
  v4 = *(_BYTE *)(a1 + 44);
  v2 = *(_QWORD *)(v1 + 56);
  if (v2)
  {
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v4);
    os_unfair_lock_lock((os_unfair_lock_t)(v1 + 192));
    *(_BYTE *)(v1 + 353) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 192));

  }
  else
  {
    v3 = std::__throw_bad_function_call[abi:nn180100]();
    re::AssetLoadRequest::Data::waitForCompletion(v3);
  }
}

void re::AssetLoadRequest::Data::waitForCompletion(uint64_t a1, int a2)
{
  NSObject *v4;
  char *v5;
  uint64_t v6;
  NSObject *v7;
  char *v8;
  uint64_t v9;
  int v10;
  int v11;
  re *v12;
  BOOL v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  os_unfair_lock_s **v17;
  os_unfair_lock_s *v18;
  os_unfair_lock_s *v19;
  re *v20;
  int v21;
  NSObject *v22;
  int v23;
  char *v24;
  NSObject *v25;
  int v26;
  int v27;
  uint8_t buf[4];
  char *v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  if (a2 == 1)
  {
    v7 = *re::assetsLogObjects((re *)a1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v8 = *(char **)(a1 + 88);
      if ((*(_BYTE *)(a1 + 104) & 1) != 0)
        v9 = *(_QWORD *)(a1 + 112);
      else
        v9 = a1 + 105;
      v26 = *(unsigned __int8 *)(a1 + 81);
      v27 = *(unsigned __int8 *)(a1 + 82);
      *(_DWORD *)buf = 134218754;
      v29 = v8;
      v30 = 2080;
      v31 = v9;
      v32 = 1024;
      v33 = v26;
      v34 = 1024;
      v35 = v27;
      _os_log_debug_impl(&dword_224FE9000, v7, OS_LOG_TYPE_DEBUG, "Blocking a non-engine queue waiting for AssetLoadRequest. First asset is %llu (%s). m_shouldWaitForPeers = %u. m_shouldBlockECSUpdatesUntilCompleted = %u.", buf, 0x22u);
    }
  }
  else if (!a2)
  {
    v4 = *re::assetsLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(char **)(a1 + 88);
      if ((*(_BYTE *)(a1 + 104) & 1) != 0)
        v6 = *(_QWORD *)(a1 + 112);
      else
        v6 = a1 + 105;
      v10 = *(unsigned __int8 *)(a1 + 81);
      v11 = *(unsigned __int8 *)(a1 + 82);
      *(_DWORD *)buf = 134218754;
      v29 = v5;
      v30 = 2080;
      v31 = v6;
      v32 = 1024;
      v33 = v10;
      v34 = 1024;
      v35 = v11;
      _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "Blocking engine queue waiting for AssetLoadRequest! First asset is %llu (%s). m_shouldWaitForPeers = %u.m_shouldBlockECSUpdatesUntilCompleted = %u.", buf, 0x22u);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
  v13 = *(_BYTE *)(a1 + 353) == 0;
  v14 = *(_DWORD *)(a1 + 336);
  if (*(_BYTE *)(a1 + 353) || (v14 - 1) >= 2)
  {
    while (1)
    {
      if (v14 || *(_QWORD *)(a1 + 216))
      {
        if (!a2 && *(_BYTE *)(a1 + 81) && !*(_BYTE *)(*(_QWORD *)(a1 + 24) + 1444))
        {
          v25 = *re::assetsLogObjects(v12);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "AssetLoadRequest failed because waitForCompletion was called while this request is configured to wait for peers to load with AssetLoadRequest::setShouldLoadAndWaitForResourceSharingClients() or REAssetLoadRequestSetLoadAndWaitForResourceSharingClients.", buf, 2u);
          }
          goto LABEL_50;
        }
        v15 = *(_QWORD *)(a1 + 216);
        if (v15)
        {
          v16 = 32 * v15;
          v17 = (os_unfair_lock_s **)(*(_QWORD *)(a1 + 232) + 8);
          while (1)
          {
            v18 = *v17;
            v19 = *v17 + 96;
            os_unfair_lock_lock(v19);
            if (BYTE1(v18[104]._os_unfair_lock_opaque))
              break;
            os_unfair_lock_unlock(v19);
            v17 += 4;
            v16 -= 32;
            if (!v16)
              goto LABEL_24;
          }
          v22 = *re::assetsLogObjects(v20);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            if ((v18[42]._os_unfair_lock_opaque & 1) != 0)
              v24 = *(char **)&v18[44]._os_unfair_lock_opaque;
            else
              v24 = (char *)&v18[42]._os_unfair_lock_opaque + 1;
            *(_DWORD *)buf = 136315138;
            v29 = v24;
            _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, "AssetLoadRequest failed because waitForCompletion can't be called on an asset that is loading over the network. For '%s'", buf, 0xCu);
          }
          os_unfair_lock_unlock(v19);
          v21 = 0;
          LOBYTE(v16) = 1;
        }
        else
        {
          LOBYTE(v16) = 0;
LABEL_24:
          v21 = 0;
        }
      }
      else
      {
        LOBYTE(v16) = 0;
        v21 = 1;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
      re::AssetLoadRequest::Data::checkForLongLoadAndLogDetails((re::AssetLoadRequest::Data *)a1);
      if ((v16 & 1) != 0 || v21)
      {
        re::AssetLoadRequest::Data::complete(a1, v21, a2);
        goto LABEL_41;
      }
      if (v13)
        break;
      if (a2 == 1)
        goto LABEL_40;
LABEL_41:
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
      v13 = *(_BYTE *)(a1 + 353) == 0;
      v14 = *(_DWORD *)(a1 + 336);
      if (!*(_BYTE *)(a1 + 353) && (v14 - 1) <= 1)
        goto LABEL_50;
    }
    if (a2 == 1)
    {
      re::AssetManager::waitForLoadQueueToComplete(*(_QWORD *)(a1 + 24), 1);
    }
    else
    {
      if (a2)
        goto LABEL_41;
      re::AssetManager::waitForLoadQueueToComplete(*(_QWORD *)(a1 + 24), 0);
      if (!*(_BYTE *)(a1 + 81))
        goto LABEL_41;
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
      v23 = *(_DWORD *)(a1 + 336);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
      if (v23)
        goto LABEL_41;
      re::AssetManager::update(*(re::AssetManager **)(a1 + 24), 0, 0);
    }
LABEL_40:
    usleep(0x3E8u);
    goto LABEL_41;
  }
LABEL_50:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
}

double `anonymous namespace'::longLoadLoggingThreshold(_anonymous_namespace_ *this)
{
  unsigned __int8 v1;
  const char *v3;
  double v4;
  _BYTE v5[8];
  double v6;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FD170);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FD170))
  {
    re::Defaults::doubleValue((re::Defaults *)"longLoadLoggingThreshold", v3, (uint64_t)v5);
    v4 = v6;
    if (!v5[0])
      v4 = 4.0;
    _MergedGlobals_59 = *(_QWORD *)&v4;
    __cxa_guard_release(&qword_2540FD170);
  }
  return *(double *)&_MergedGlobals_59;
}

void re::AssetLoadRequest::getStatistics(re::AssetLoadRequest *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3;
  re *v4;
  uint64_t v5;
  uint64_t v6;
  id v7;
  uint64_t v8;

  v3 = *((_QWORD *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 192));
  v5 = *(_QWORD *)(v3 + 288);
  if (v5)
  {
    *a2 = v5;
LABEL_6:
    v7 = (id)(v5 + 8);
    goto LABEL_7;
  }
  re::make::shared::object<re::AssetLoadRequest::LoadStatistics>(v4, &v8);
  v6 = *(_QWORD *)(v3 + 288);
  v5 = v8;
  *(_QWORD *)(v3 + 288) = v8;
  v8 = v6;
  if (v6)
  {

    v5 = *(_QWORD *)(v3 + 288);
  }
  *a2 = v5;
  if (v5)
    goto LABEL_6;
LABEL_7:
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 192));
}

double re::AssetLoadRequest::LoadStatistics::forEachStat(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  char *v15;
  size_t v16;
  unint64_t v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  size_t v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  size_t v33;
  uint64_t v34;
  _anonymous_namespace_ *v35;
  int v36;
  uint64_t v37;
  int *v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unsigned int v46;
  unsigned int v47;
  unint64_t v48;
  uint64_t v49;
  double v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t *v54;
  BOOL v55;
  uint64_t v56;
  __n128 v57;
  __n128 *v58;
  uint64_t v61;
  unsigned int v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t *v72;
  unint64_t v73;
  unint64_t v74;
  int v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  unsigned int v79;
  uint64_t v80;
  char v81;

  v2 = a1;
  v79 = 0;
  v77 = 0u;
  v78 = 0u;
  v80 = 0x7FFFFFFFLL;
  v69 = *(unsigned int *)(a1 + 56);
  v3 = 0;
  if ((_DWORD)v69)
  {
    v4 = (int *)(*(_QWORD *)(a1 + 40) + 8);
    while (1)
    {
      v5 = *v4;
      v4 += 10;
      if (v5 < 0)
        break;
      if (v69 == ++v3)
      {
        LODWORD(v3) = *(_DWORD *)(a1 + 56);
        break;
      }
    }
  }
  if ((_DWORD)v69 == (_DWORD)v3)
  {
    v6 = 0;
    v7 = 0;
    goto LABEL_50;
  }
  v61 = 0;
  v8 = 0;
  v62 = 0;
  v63 = 0;
  v9 = 0;
  v10 = 0;
  v64 = 0;
  v68 = 0;
  v11 = v3;
  do
  {
    v12 = *(_QWORD *)(*(_QWORD *)(v2 + 40) + 40 * v11 + 24);
    v70 = v9;
    v71 = v8;
    if (*(_BYTE *)(v12 + 744) && *(_BYTE *)(v12 + 760))
    {
      v13 = 0;
      v65 = (*(_BYTE *)(v12 + 752) - *(_BYTE *)(v12 + 736));
      v66 = (*(_QWORD *)(v12 + 752) - *(_QWORD *)(v12 + 736)) & 0xFFFFFFFFFFFFFF00;
    }
    else
    {
      v65 = 0;
      v66 = 0;
      v13 = 1;
    }
    v67 = *(_QWORD *)(v12 + 768);
    v14 = *(unsigned __int8 *)(v12 + 776);
    v15 = **(char ***)(v12 + 264);
    v16 = re::RigEvaluation::HashString::operator()((int)&v72, v15);
    v17 = v77;
    if (!(_QWORD)v77 || (v18 = *(unsigned int *)(v71 + 4 * (v16 % v68)), (_DWORD)v18 == 0x7FFFFFFF))
    {
LABEL_17:
      v76 = 0uLL;
      if ((v13 & 1) != 0)
        goto LABEL_19;
LABEL_18:
      *(_QWORD *)&v76 = (v66 | v65) + v76;
      goto LABEL_19;
    }
    while (1)
    {
      v16 = strcmp(*(const char **)(v10 + 72 * v18 + 16), v15);
      if (!(_DWORD)v16)
        break;
      v18 = *(_DWORD *)(v10 + 72 * v18 + 8) & 0x7FFFFFFF;
      if (v18 == 0x7FFFFFFF)
        goto LABEL_17;
    }
    v34 = v10 + 72 * v18;
    re::DynamicString::DynamicString((re::DynamicString *)&v72, (const re::DynamicString *)(v34 + 24));
    v76 = *(_OWORD *)(v34 + 56);
    if ((v13 & 1) == 0)
      goto LABEL_18;
LABEL_19:
    if (v14)
      *((_QWORD *)&v76 + 1) += v67;
    v19 = re::RigEvaluation::HashString::operator()((int)&v81, v15);
    v9 = v70;
    if (!v17)
      goto LABEL_24;
    v17 = v19 % v64;
    v20 = *(unsigned int *)(v71 + 4 * v17);
    if ((_DWORD)v20 == 0x7FFFFFFF)
    {
      v68 = v64;
LABEL_24:
      v21 = v63;
LABEL_25:
      v22 = v80;
      if ((_DWORD)v80 == 0x7FFFFFFF)
      {
        v23 = v70;
        if (v70 == (_DWORD)v21)
        {
          v24 = v19;
          re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::setCapacity((uint64_t)&v77, 2 * v62);
          v19 = v24;
          v23 = v79;
          v17 = v24 % DWORD2(v78);
          v21 = DWORD2(v78);
          v10 = v78;
          v61 = *((_QWORD *)&v77 + 1);
        }
        v25 = v23 + 1;
        v79 = v23 + 1;
        v22 = v70;
        v26 = v21;
        v27 = *(_DWORD *)(v10 + 72 * v70 + 8);
        v8 = v61;
        v64 = v26;
        v63 = v26;
        v68 = v26;
        v28 = v70;
      }
      else
      {
        v27 = *(_DWORD *)(v10 + 72 * v80 + 8);
        LODWORD(v80) = v27 & 0x7FFFFFFF;
        v25 = v70;
        v28 = v22;
        v8 = v71;
      }
      v29 = 9 * v22;
      *(_DWORD *)(v10 + 8 * v29 + 8) = v27 | 0x80000000;
      v10 = v78;
      v30 = v78 + 8 * v29;
      *(_DWORD *)(v30 + 8) = *(_DWORD *)(v30 + 8) & 0x80000000 | *(_DWORD *)(v8 + 4 * v17);
      *(_QWORD *)v30 = v19;
      *(_QWORD *)(v30 + 16) = v15;
      re::DynamicString::DynamicString((re::DynamicString *)(v30 + 24), (const re::DynamicString *)&v72);
      *(_OWORD *)(v30 + 56) = v76;
      *(_DWORD *)(v8 + 4 * v17) = v28;
      v62 = ++HIDWORD(v78);
      ++HIDWORD(v80);
      v9 = v25;
      goto LABEL_31;
    }
    v33 = v19;
    while (strcmp(*(const char **)(v10 + 72 * v20 + 16), v15))
    {
      v20 = *(_DWORD *)(v10 + 72 * v20 + 8) & 0x7FFFFFFF;
      if (v20 == 0x7FFFFFFF)
      {
        v68 = v64;
        v21 = v63;
        v19 = v33;
        goto LABEL_25;
      }
    }
    v68 = v64;
    v8 = v71;
LABEL_31:
    a1 = (uint64_t)v72;
    if (v72 && (v73 & 1) != 0)
      a1 = (*(uint64_t (**)(void))(*v72 + 40))();
    if (*(_DWORD *)(v2 + 56) <= (v3 + 1))
      v31 = v3 + 1;
    else
      v31 = *(_DWORD *)(v2 + 56);
    while (1)
    {
      v11 = (v3 + 1);
      if (v31 - 1 == (_DWORD)v3)
        break;
      LODWORD(v3) = v3 + 1;
      v32 = v11;
      if ((*(_DWORD *)(*(_QWORD *)(v2 + 40) + 40 * v11 + 8) & 0x80000000) != 0)
        goto LABEL_41;
    }
    v32 = v31;
LABEL_41:
    LODWORD(v3) = v32;
  }
  while ((_DWORD)v69 != v32);
  v7 = v62;
  v6 = v79;
LABEL_50:
  *(_QWORD *)&v76 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v35 = (_anonymous_namespace_ *)re::DynamicArray<re::AssetLoadRequest::LoadStatistics::AssetTypeStats>::setCapacity(&v72, v7);
  v36 = ++v75;
  v37 = 0;
  if (v6)
  {
    v38 = (int *)(v78 + 8);
    while (1)
    {
      v39 = *v38;
      v38 += 18;
      if (v39 < 0)
        break;
      if (v6 == ++v37)
      {
        LODWORD(v37) = v6;
        break;
      }
    }
  }
  if (v6 == (_DWORD)v37)
  {
    v40 = v76;
    v41 = v74;
  }
  else
  {
    v42 = v37;
    v43 = v78;
    v41 = v74;
    do
    {
      if (v41 >= v73)
      {
        if (v73 < v41 + 1)
        {
          if (v72)
          {
            if (v73)
              v44 = 2 * v73;
            else
              v44 = 8;
            if (v44 <= v41 + 1)
              v45 = v41 + 1;
            else
              v45 = v44;
            re::DynamicArray<re::AssetLoadRequest::LoadStatistics::AssetTypeStats>::setCapacity(&v72, v45);
            v36 = v75;
          }
          else
          {
            re::DynamicArray<re::AssetLoadRequest::LoadStatistics::AssetTypeStats>::setCapacity(&v72, v41 + 1);
            v36 = v75 + 1;
          }
        }
        v41 = v74;
      }
      v40 = v76;
      v35 = re::DynamicString::DynamicString((re::DynamicString *)(v76 + 48 * v41), (const re::DynamicString *)(v43 + 72 * v42 + 24));
      *((_OWORD *)v35 + 2) = *(_OWORD *)(v43 + 72 * v42 + 56);
      v74 = ++v41;
      v75 = ++v36;
      if (v6 <= (int)v37 + 1)
        v46 = v37 + 1;
      else
        v46 = v6;
      while (1)
      {
        v42 = (v37 + 1);
        if (v46 - 1 == (_DWORD)v37)
          break;
        LODWORD(v37) = v37 + 1;
        v47 = v42;
        if ((*(_DWORD *)(v43 + 72 * v42 + 8) & 0x80000000) != 0)
          goto LABEL_77;
      }
      v47 = v46;
LABEL_77:
      LODWORD(v37) = v47;
    }
    while (v6 != v47);
  }
  v48 = 126 - 2 * __clz(v41);
  if (v41)
    v49 = v48;
  else
    v49 = 0;
  std::__introsort<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>,false>((_OWORD *)(v40 + 48 * v41), (__int128 *)(v40 + 48 * v41), v40, v40, v49, 1);
  if (v41)
  {
    v51 = v41 - 1;
    if (v41 - 1 >= 9)
      v51 = 9;
    v52 = v51 + 1;
    v53 = v40;
    do
    {
      (*(void (**)(uint64_t, uint64_t))(a2 + 16))(a2, v53);
      v53 += 48;
      --v52;
    }
    while (v52);
  }
  v54 = v72;
  if (v72)
    v55 = v40 == 0;
  else
    v55 = 1;
  if (!v55)
  {
    if (v41)
    {
      v56 = 48 * v41;
      v57 = 0uLL;
      v58 = (__n128 *)v40;
      do
      {
        if (v58->n128_u64[0])
        {
          if ((v58->n128_u8[8] & 1) != 0)
          {
            (*(void (**)(unint64_t, unint64_t, __n128))(*(_QWORD *)v58->n128_u64[0] + 40))(v58->n128_u64[0], v58[1].n128_u64[0], v57);
            v57 = 0uLL;
          }
          *v58 = v57;
          v58[1] = v57;
        }
        v58 += 3;
        v56 -= 48;
      }
      while (v56);
    }
    v50 = (*(double (**)(uint64_t *, uint64_t))(*v54 + 40))(v54, v40);
  }
  return re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::deinit((uint64_t *)&v77, v50);
}

void re::AssetLoadRequest::addAsset(re::AssetLoadRequest::Data **this, const re::AssetHandle *a2)
{
  re::AssetLoadRequest::Data *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  re::AssetLoadRequest::Data **v8;

  re::AssetLoadRequest::Data::addAsset(this[3], a2);
  v4 = this[3];
  if (*((_BYTE *)v4 + 82))
  {
    v5 = *((_QWORD *)a2 + 1);
    if (v5)
      *(_BYTE *)(v5 + 259) = 1;
    v6 = *(_QWORD *)(*((_QWORD *)v4 + 3) + 1216);
    if (v6)
    {
      v8 = this;
      v7 = this + 1;
      (*(void (**)(uint64_t, re::AssetLoadRequest::Data ***))(*(_QWORD *)v6 + 8))(v6, &v8);
      if (v8)

    }
  }
}

void re::AssetLoadRequest::error(re::AssetLoadRequest *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;

  v3 = *((_QWORD *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 192));
  *a2 = *(id *)(v3 + 344);
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 192));
}

_QWORD *re::AssetLoadRequest::setCompletionHandler(uint64_t a1, uint64_t a2, id *a3)
{
  uint64_t v4;
  _QWORD *result;
  uint64_t v6;
  _BYTE v7[24];
  _BYTE *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 24);
  std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v7, a2);
  re::AssetLoadRequest::Data::setCompletionHandler(v4, (uint64_t)v7, a3);
  result = v8;
  if (v8 == v7)
  {
    v6 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      return result;
    v6 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v6))();
}

void re::AssetLoadRequest::~AssetLoadRequest(re::AssetLoadRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 192));
  *(_BYTE *)(v2 + 355) = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 192));
  v3 = *((_QWORD *)this + 3);
  v4 = *(_QWORD *)(v3 + 24);
  if (!v4 || (atomic_store(1u, (unsigned __int8 *)(v4 + 704)), (v3 = *((_QWORD *)this + 3)) != 0))
  {

    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::AssetLoadRequest::~AssetLoadRequest(this);
  JUMPOUT(0x2276933B8);
}

void re::AssetLoadRequest::Data::~Data(re::AssetLoadRequest::Data *this)
{
  uint64_t v2;
  re::AssetLoadRequest::Data *v3;
  uint64_t v4;

  re::ThreadSafeValue<re::AssetLoadRequest::Data::State,re::UnfairLock>::~ThreadSafeValue((uint64_t)this + 192);
  v2 = *((_QWORD *)this + 12);
  if (v2)
  {
    if ((*((_BYTE *)this + 104) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 14));
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
  }
  if (*((_BYTE *)this + 64))

  v3 = (re::AssetLoadRequest::Data *)*((_QWORD *)this + 7);
  if (v3 == (re::AssetLoadRequest::Data *)((char *)this + 32))
  {
    v4 = 4;
    v3 = (re::AssetLoadRequest::Data *)((char *)this + 32);
    goto LABEL_11;
  }
  if (v3)
  {
    v4 = 5;
LABEL_11:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  re::AssetLoadRequest::Data *v3;
  uint64_t v4;

  re::ThreadSafeValue<re::AssetLoadRequest::Data::State,re::UnfairLock>::~ThreadSafeValue((uint64_t)this + 192);
  v2 = *((_QWORD *)this + 12);
  if (v2)
  {
    if ((*((_BYTE *)this + 104) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 14));
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
  }
  if (*((_BYTE *)this + 64))

  v3 = (re::AssetLoadRequest::Data *)*((_QWORD *)this + 7);
  if (v3 == (re::AssetLoadRequest::Data *)((char *)this + 32))
  {
    v4 = 4;
    v3 = (re::AssetLoadRequest::Data *)((char *)this + 32);
  }
  else
  {
    if (!v3)
    {
LABEL_12:
      *(_QWORD *)this = &off_24ED426B8;
      objc_destructInstance((char *)this + 8);
      JUMPOUT(0x2276933ACLL);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  goto LABEL_12;
}

double re::make::shared::object<re::AssetLoadRequest::LoadStatistics>@<D0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;
  double result;

  v3 = re::globalAllocators(a1);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3[2] + 32))(v3[2], 72, 8);
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_QWORD *)(v4 + 64) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v4, 0);
  *(_QWORD *)v4 = &off_24ED2FFA8;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_DWORD *)(v4 + 56) = 0;
  *(_QWORD *)&result = 0x7FFFFFFFLL;
  *(_QWORD *)(v4 + 60) = 0x7FFFFFFFLL;
  *a2 = v4;
  return result;
}

void re::AssetLoadRequest::LoadStatistics::~LoadStatistics(re::AssetLoadRequest::LoadStatistics *this)
{
  re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 32 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 32 * v9;
        v11 = v7;
        do
        {
          *v11 = 0;
          v11[1] = 0;
          v11[2] = 0;
          v11[1] = *(_QWORD *)(v8 + 8);
          *(_QWORD *)(v8 + 8) = 0;
          v12 = *v11;
          *v11 = 0;
          *v11 = *(_QWORD *)v8;
          *(_QWORD *)v8 = v12;
          v13 = v11[2];
          v11[2] = *(_QWORD *)(v8 + 16);
          *(_QWORD *)(v8 + 16) = v13;
          *((_WORD *)v11 + 12) = *(_WORD *)(v8 + 24);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v8);
          v8 += 32;
          v11 += 4;
          v10 -= 32;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

_QWORD *std::__function::__value_func<void ()(BOOL)>::swap[abi:nn180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

_DWORD *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState*>(_DWORD *result, _DWORD *a2, uint64_t a3)
{
  uint64_t v3;
  _DWORD *v4;
  __int128 v5;
  int v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  _DWORD *v10;

  if (result != a2)
  {
    v3 = a3 + 24;
    v4 = result + 7;
    do
    {
      v5 = *(_OWORD *)(v4 - 7);
      *(_QWORD *)(v3 - 8) = *(_QWORD *)(v4 - 3);
      *(_OWORD *)(v3 - 24) = v5;
      v6 = *((unsigned __int8 *)v4 - 4);
      if (*(_BYTE *)v3)
        v7 = 0;
      else
        v7 = v6 == 0;
      if (!v7)
      {
        if (*(_BYTE *)v3)
          v8 = v6 == 0;
        else
          v8 = 0;
        if (v8)
        {
          *(_BYTE *)v3 = 0;
        }
        else
        {
          if (*(_BYTE *)v3)
            v9 = 1;
          else
            v9 = v6 == 0;
          if (!v9)
            *(_BYTE *)v3 = 1;
          *(_DWORD *)(v3 + 4) = *v4;
        }
      }
      v10 = v4 - 7;
      v3 += 32;
      v4 += 8;
    }
    while (v10 + 8 != a2);
  }
  return result;
}

double re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::deinit(uint64_t *a1, double result)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  __n128 v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __n128 *v12;
  uint64_t v13;

  v3 = *a1;
  if (v3)
  {
    v4 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v4)
    {
      v5 = 0;
      v6 = 0;
      v7 = 0uLL;
      do
      {
        v8 = a1[2];
        v9 = v8 + v5;
        v10 = *(_DWORD *)(v8 + v5 + 8);
        if (v10 < 0)
        {
          *(_DWORD *)(v9 + 8) = v10 & 0x7FFFFFFF;
          v13 = *(_QWORD *)(v9 + 24);
          v12 = (__n128 *)(v9 + 24);
          v11 = v13;
          if (v13)
          {
            if ((*(_BYTE *)(v8 + v5 + 32) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v8 + v5 + 40), v7);
              v7 = 0uLL;
            }
            *v12 = v7;
            v12[1] = v7;
            v4 = *((unsigned int *)a1 + 8);
          }
        }
        ++v6;
        v5 += 72;
      }
      while (v6 < v4);
      v3 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  signed int v24;
  _BYTE v25[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(_QWORD *)&v25[36] = 0x7FFFFFFFLL;
      re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init((uint64_t)v25, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v25;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v25[8];
      *(_OWORD *)v25 = v5;
      *(_QWORD *)&v25[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v25[24];
      *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = v6 + 32;
        do
        {
          if ((*(_DWORD *)(v13 - 24) & 0x80000000) != 0)
          {
            v14 = *(_QWORD *)(v13 - 32);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 72 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 72 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 72 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 72 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 72 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72 * v17) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72 * v17 + 16) = *(_QWORD *)(v13 - 16);
            v21 = *(_QWORD *)(a1 + 16) + 72 * v17;
            *(_OWORD *)(v21 + 40) = 0u;
            *(_OWORD *)(v21 + 24) = 0u;
            *(_QWORD *)(v21 + 24) = *(_QWORD *)(v13 - 8);
            *(_QWORD *)(v13 - 8) = 0;
            v22 = *(_QWORD *)(v21 + 40);
            *(_QWORD *)(v21 + 40) = *(_QWORD *)(v13 + 8);
            *(_QWORD *)(v13 + 8) = v22;
            *(_QWORD *)(v21 + 48) = *(_QWORD *)(v13 + 16);
            *(_QWORD *)(v13 + 16) = 0;
            v23 = *(_QWORD *)(v21 + 32);
            *(_QWORD *)(v21 + 32) = *(_QWORD *)v13;
            *(_QWORD *)v13 = v23;
            v7 = *(_OWORD *)(v13 + 24);
            *(_OWORD *)(v21 + 56) = v7;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 72;
          --v10;
        }
        while (v10);
      }
      re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::deinit((uint64_t *)v25, *(double *)&v7);
    }
  }
  else
  {
    if (a2)
      v24 = a2;
    else
      v24 = 3;
  }
}

void re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 72 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

_QWORD *re::DynamicArray<re::AssetLoadRequest::LoadStatistics::AssetTypeStats>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  __int128 v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::AssetLoadRequest::LoadStatistics::AssetTypeStats>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          v2 = 48 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 48 * v9;
        v11 = (uint64_t *)(v8 + 16);
        v12 = 0uLL;
        v13 = v7;
        do
        {
          *(_OWORD *)v13 = v12;
          *((_OWORD *)v13 + 1) = v12;
          *v13 = *(v11 - 2);
          *(v11 - 2) = 0;
          v14 = *v11;
          v13[3] = v11[1];
          v11[1] = 0;
          v16 = v13[1];
          v15 = v13[2];
          v17 = *(v11 - 1);
          v13[2] = v14;
          *v11 = v15;
          v13[1] = v17;
          *(v11 - 1) = v16;
          *((_OWORD *)v13 + 2) = *((_OWORD *)v11 + 1);
          v18 = *(v11 - 2);
          if (v18)
          {
            if ((*(_BYTE *)(v11 - 1) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 40))(v18, *v11);
              v12 = 0uLL;
            }
            *((_OWORD *)v11 - 1) = v12;
            *(_OWORD *)v11 = v12;
          }
          v11 += 6;
          v13 += 6;
          v10 -= 48;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>,false>(_OWORD *a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  __int128 *v10;
  uint64_t v11;
  __int128 *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  __int128 *v23;
  __int128 *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  __int128 *v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __int128 *v44;
  uint64_t v45;
  __int128 *v46;
  uint64_t v47;
  char *v48;
  re::DynamicString *v49;
  uint64_t v50;
  uint64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  __int128 *v55;
  int64_t v56;
  uint64_t v57;
  uint64_t v58;
  __int128 *v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  BOOL v63;
  uint64_t v64;
  unint64_t v65;
  __int128 *v66;
  re::DynamicString *v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  BOOL v71;
  uint64_t v72;
  int64_t v73;
  uint64_t v74;
  __int128 *v75;
  __int128 *v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  BOOL v81;
  uint64_t v82;
  char *v83;
  __int128 *v84;
  __int128 *v85;
  unint64_t v86;
  __int128 *v87;
  uint64_t v88;
  uint64_t v89;
  __int128 *v90;
  re::DynamicString *v91;
  __int128 *v93;
  re::DynamicString *v94;
  __int128 *v95;
  re::DynamicString *v96;
  re::DynamicString *v97;
  re::DynamicString *v98;
  unint64_t v99;
  re::DynamicString *v100;
  uint64_t v101;
  uint64_t v102;
  re::DynamicString *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(uint64_t a1, uint64_t a2)
{
  re::DynamicString *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;

  v3 = (re::DynamicString *)(a2 - 48);
  v5 = *(_QWORD *)(a1 - 48);
  v4 = a1 - 48;
  v7 = v5;
  *(_QWORD *)v4 = 0;
  v9 = *(_QWORD *)(v4 + 16);
  *(_QWORD *)(v4 + 16) = 0;
  v10 = *(_QWORD *)(v4 + 24);
  *(_QWORD *)(v4 + 24) = 0;
  v8 = *(_QWORD *)(v4 + 8);
  *(_QWORD *)(v4 + 8) = 0;
  v11 = *(_OWORD *)(v4 + 32);
  *((_OWORD *)re::DynamicString::operator=((re::DynamicString *)v4, (re::DynamicString *)(a2 - 48)) + 2) = *(_OWORD *)(a2 - 16);
  re::DynamicString::operator=(v3, (re::DynamicString *)&v7);
  *(_OWORD *)(a2 - 16) = v11;
  result = v7;
  if (v7)
  {
    if ((v8 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v7 + 40))();
  }
  return result;
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v9 = *(_QWORD *)(a4 - 16);
  v10 = *(_QWORD *)(a6 - 16);
  if (v9 < *(_QWORD *)(a2 - 16))
  {
    v11 = a2;
    if (v10 >= v9)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2, a4);
      if (*(_QWORD *)(a6 - 16) >= *(_QWORD *)(a4 - 16))
        return;
      v11 = a4;
    }
    v12 = a6;
    goto LABEL_9;
  }
  if (v10 < v9)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a4, a6);
    if (*(_QWORD *)(a4 - 16) < *(_QWORD *)(a2 - 16))
    {
      v11 = a2;
      v12 = a4;
LABEL_9:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(v11, v12);
    }
  }
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  re::DynamicString *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;

  v6 = 1;
  switch(0xAAAAAAAAAAAAAAABLL * ((a2 - a4) >> 4))
  {
    case 0uLL:
    case 1uLL:
      return v6;
    case 2uLL:
      if (*(_QWORD *)(a4 + 32) < *(_QWORD *)(a2 - 16))
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2, a4 + 48);
      return v6;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(a1, a2, a2 - 48, a2 - 48, a3, a4 + 48);
      return v6;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(a1, a2, a2 - 48, a2 - 48, a2 - 96, a2 - 96, a3, a4 + 48);
      return v6;
    case 5uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(a1, a2, a2 - 48, a2 - 48, a2 - 96, a2 - 96, a2 - 144, a2 - 144);
      if (*(_QWORD *)(a4 + 32) < *(_QWORD *)(a2 - 160))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2 - 144, a4 + 48);
        if (*(_QWORD *)(a2 - 160) < *(_QWORD *)(a2 - 112))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2 - 96, a2 - 144);
          if (*(_QWORD *)(a2 - 112) < *(_QWORD *)(a2 - 64))
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2 - 48, a2 - 96);
            if (*(_QWORD *)(a2 - 64) < *(_QWORD *)(a2 - 16))
              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2, a2 - 48);
          }
        }
      }
      return 1;
    default:
      v7 = a2 - 96;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(a1, a2, a2 - 48, a2 - 48, a2 - 96, a2 - 96);
      v8 = a2 - 144;
      if (a2 - 144 == a4)
        return 1;
      v9 = 0;
      v10 = 0;
      break;
  }
  while (1)
  {
    v11 = v8 - 48;
    if (*(_QWORD *)(v8 - 16) < *(_QWORD *)(v7 - 16))
      break;
LABEL_15:
    v9 -= 48;
    v7 = v8;
    v8 -= 48;
    if (v11 == a4)
      return 1;
  }
  v16 = *(_QWORD *)(v8 - 48);
  *(_QWORD *)(v8 - 48) = 0;
  v18 = *(_QWORD *)(v8 - 32);
  *(_QWORD *)(v8 - 32) = 0;
  v19 = *(_QWORD *)(v8 - 24);
  *(_QWORD *)(v8 - 24) = 0;
  v17 = *(_QWORD *)(v8 - 40);
  *(_QWORD *)(v8 - 40) = 0;
  v20 = *(_OWORD *)(v8 - 16);
  v12 = v9;
  do
  {
    v13 = a2 + v12;
    v14 = (re::DynamicString *)(a2 + v12 - 144);
    re::DynamicString::operator=((re::DynamicString *)(a2 + v12 - 192), v14);
    *(_OWORD *)(a2 + v12 - 160) = *(_OWORD *)(a2 + v12 - 112);
    if (v12 == 96)
      break;
    v12 += 48;
  }
  while ((unint64_t)v20 < *(_QWORD *)(v13 - 64));
  re::DynamicString::operator=(v14, (re::DynamicString *)&v16);
  *(_OWORD *)(v13 - 112) = v20;
  if (++v10 != 8)
  {
    if (v16 && (v17 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    goto LABEL_15;
  }
  v6 = v11 == a4;
  if (v16 && (v17 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v16 + 40))();
  return v6;
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(a1, a2, a3, a4, a5, a6);
  if (*(_QWORD *)(a8 - 16) < *(_QWORD *)(a6 - 16))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a6, a8);
    if (*(_QWORD *)(a6 - 16) < *(_QWORD *)(a4 - 16))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a4, a6);
      if (*(_QWORD *)(a4 - 16) < *(_QWORD *)(a2 - 16))
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2, a4);
    }
  }
}

uint64_t re::ThreadSafeValue<re::AssetLoadRequest::Data::State,re::UnfairLock>::~ThreadSafeValue(uint64_t a1)
{
  uint64_t v2;
  __n128 v3;
  uint64_t v4;
  re::AssetHandle *v5;
  uint64_t v6;
  uint64_t v7;

  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1 + 104);
  v2 = *(_QWORD *)(a1 + 96);
  if (v2)
  {

    *(_QWORD *)(a1 + 96) = 0;
  }
  v3.n128_f64[0] = re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)(a1 + 48));
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v5 = *(re::AssetHandle **)(a1 + 40);
    if (v5)
    {
      v6 = *(_QWORD *)(a1 + 24);
      if (v6)
      {
        v7 = 32 * v6;
        do
        {
          re::AssetHandle::~AssetHandle(v5);
          v5 = (re::AssetHandle *)((char *)v5 + 32);
          v7 -= 32;
        }
        while (v7);
        v4 = *(_QWORD *)(a1 + 8);
        v5 = *(re::AssetHandle **)(a1 + 40);
      }
      (*(void (**)(uint64_t, re::AssetHandle *, __n128))(*(_QWORD *)v4 + 40))(v4, v5, v3);
    }
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    ++*(_DWORD *)(a1 + 32);
  }
  return a1;
}

uint64_t *re::allocInfo_NetworkAssetSerializationService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_60);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_60))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FD180, 0);
    *(uint64_t *)((char *)&qword_2540FD190 + 6) = 0;
    qword_2540FD190 = 0;
    qword_2540FD1A0 = 0;
    qword_2540FD1A8 = 0xFFFFFFFFLL;
    qword_2540FD180 = (uint64_t)&off_24ED7DAA8;
    qword_2540FD1B0 = (uint64_t)"NetworkAssetSerializationService";
    dword_2540FD1B8 = 0;
    unk_2540FD1C0 = 0u;
    unk_2540FD1D0 = 0u;
    unk_2540FD1E0 = 0u;
    qword_2540FD1F0 = 0;
    __cxa_guard_release(&_MergedGlobals_60);
  }
  return &qword_2540FD180;
}

void re::initInfo_NetworkAssetSerializationService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0xD4DD228B7CB34A8ELL;
  v5[1] = "NetworkAssetSerializationService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_NetworkAssetSerializationService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_NetworkAssetSerializationService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"NetworkAssetSerializationService", (uint64_t (*)(re::internal *))re::allocInfo_NetworkAssetSerializationService, (re::IntrospectionBase *(*)(void))re::initInfo_NetworkAssetSerializationService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NetworkAssetSerializationService>, this);
}

void re::SerializedPayload::make(uint64_t a1@<X0>, const re::IntrospectionBase **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, RESerializedPayload **a5@<X8>)
{
  _anonymous_namespace_ *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  re *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  const char *v20;
  RESerializedPayload *v21;
  _QWORD v22[2];
  uint8_t v23[8];
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint8_t buf[4];
  _anonymous_namespace_ *v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a1 + 16) == 8)
  {
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", *(_QWORD *)(a1 + 48));
    v10 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
    v27 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    re::DynamicArray<char>::setCapacity(v23, 0x100uLL);
    ++v26;
    v22[0] = &off_24ED7C100;
    v22[1] = v23;
    if ((v11 & 1) != 0)
    {
      v12 = v25;
      v13 = *(_QWORD *)(a4 + 32);
      if (!v13)
      {
        v16 = 0;
        v17 = 0;
        v15 = v27;
LABEL_14:
        v21 = -[RESerializedPayload initWithTypeName:serializedBytes:size:blobBytes:size:]([RESerializedPayload alloc], "initWithTypeName:serializedBytes:size:blobBytes:size:", v10, v15, v12, v17, v16);
        *a5 = v21;

LABEL_19:
        if (*(_QWORD *)v23)
        {
          if (v27)
            (*(void (**)(void))(**(_QWORD **)v23 + 40))();
        }

        return;
      }
      v14 = (re *)(*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 16))(v13, v22);
      if ((v14 & 1) != 0)
      {
        v15 = v27;
        v16 = v25 - v12;
        if (v25 == v12)
          v17 = 0;
        else
          v17 = v27 + v12;
        goto LABEL_14;
      }
      v19 = *re::foundationSerializationLogObjects(v14);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        v29 = v10;
        v20 = "Failed to serialize blob for payload of type %@";
        goto LABEL_17;
      }
    }
    else
    {
      v19 = *re::foundationSerializationLogObjects((re *)v11);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        v29 = v10;
        v20 = "Failed to serialize payload of type %@";
LABEL_17:
        _os_log_fault_impl(&dword_224FE9000, v19, OS_LOG_TYPE_FAULT, v20, buf, 0xCu);
      }
    }
    *a5 = 0;
    goto LABEL_19;
  }
  v18 = *re::foundationSerializationLogObjects((re *)a1);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v23 = 0;
    _os_log_fault_impl(&dword_224FE9000, v18, OS_LOG_TYPE_FAULT, "Serializing payloads for types other than structs is not supported", v23, 2u);
  }
  *a5 = 0;
}

void re::SerializedPayload::dynamicCast(id *this@<X0>, _QWORD *a2@<X8>)
{
  id v4;
  id v5;

  v5 = *this;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v4 = v5;
  else
    v4 = 0;
  *a2 = v4;

}

uint64_t re::SerializedPayload::deserializeIntoStruct(id *a1, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t a5)
{
  void *v10;
  id v11;
  void *v12;
  char v13;
  _anonymous_namespace_ *v14;
  id v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  int v27;
  void *v28;
  _BYTE buf[24];
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 16) == 8)
  {
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", *(_QWORD *)(a2 + 48));
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = *a1;
    objc_msgSend(v11, "typeName");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = objc_msgSend(v10, "isEqualToString:", v12);

    if ((v13 & 1) != 0)
    {
      objc_msgSend(v11, "serializedData");
      v15 = (id)objc_claimAutoreleasedReturnValue();

      v16 = objc_retainAutorelease(v15);
      *(_QWORD *)buf = &off_24ED7C9D0;
      *(_QWORD *)&buf[8] = objc_msgSend(v16, "bytes");
      *(_QWORD *)&buf[16] = objc_msgSend(v16, "length");
      v30 = 0;
      v18 = v17;
      if ((v17 & 1) == 0)
      {
        v19 = *re::foundationSerializationLogObjects((re *)v17);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          v25 = v19;
          objc_msgSend(v11, "typeName");
          v26 = (void *)objc_claimAutoreleasedReturnValue();
          v27 = 138412290;
          v28 = v26;
          _os_log_fault_impl(&dword_224FE9000, v25, OS_LOG_TYPE_FAULT, "Failed to deserialize payload of type %@", (uint8_t *)&v27, 0xCu);

        }
      }

    }
    else
    {
      v21 = *re::foundationSerializationLogObjects(v14);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
      {
        v23 = v21;
        objc_msgSend(v11, "typeName");
        v24 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v10;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v24;
        _os_log_fault_impl(&dword_224FE9000, v23, OS_LOG_TYPE_FAULT, "Tried to deserialize a payload into a structure with an unexpected type name (expected '%@', got '%@')", buf, 0x16u);

      }
      v18 = 0;
    }

  }
  else
  {
    v20 = *re::foundationSerializationLogObjects((re *)a1);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_224FE9000, v20, OS_LOG_TYPE_FAULT, "Serializing payloads for types other than structs is not supported", buf, 2u);
    }
    return 0;
  }
  return v18;
}

void re::SerializedPayload::typeName(id *this@<X0>, re::DynamicString *a2@<X8>)
{
  _anonymous_namespace_ *v3;
  id v4;

  objc_msgSend(*this, "typeName");
  v4 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v3 = (_anonymous_namespace_ *)objc_msgSend(v4, "UTF8String");

}

void re::SerializedPayload::serializedData(id *this@<X0>, _QWORD *a2@<X8>)
{
  id v3;

  objc_msgSend(*this, "serializedData");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  *a2 = v3;

}

void re::SerializedPayload::blobData(id *this@<X0>, _QWORD *a2@<X8>)
{
  id v3;

  objc_msgSend(*this, "blobData");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  *a2 = v3;

}

uint64_t re::AssetSignpost::fireImpulse(re::AssetSignpost *this, unsigned int a2, const char *a3, const char *a4)
{
  uint64_t result;
  char __dst[8];

  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
  {
    if (a3)
      strncpy(__dst, a3, 8uLL);
    return kdebug_trace();
  }
  return result;
}

re::internal::AriadneSignpostScopeGuard *re::AssetSignpost::ScopeGuard::ScopeGuard(re::AssetSignpost::ScopeGuard *this, int a2, uint64_t a3, const char *__src)
{
  char __dst[8];

  if (__src)
    strncpy(__dst, __src, 8uLL);
  return re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard(this, a2, a3);
}

void re::RealityFileRegistry::init(void **this)
{
  dispatch_queue_t v2;
  _anonymous_namespace_ *v3;

  v2 = dispatch_queue_create("com.apple.CoreRE.reality-file-registry-queue", 0);
  re::ObjCObject::operator=(this, v2);

  this[10] = (void *)8;
}

void re::RealityFileRegistry::getOrMountRealityFile(dispatch_queue_t *this@<X0>, const re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  char *v4;
  char *v5;
  char v6;
  _QWORD v7[8];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t);
  void (*v12)(uint64_t);
  uint64_t v13;
  id v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  void (*v19)(uint64_t);
  const char *v20;
  uint64_t v21;

  v15 = 0;
  v16 = &v15;
  v17 = 0x3812000000;
  v18 = __Block_byref_object_copy__0;
  v19 = __Block_byref_object_dispose__0;
  v20 = "";
  v21 = 0;
  v8 = 0;
  v9 = &v8;
  v10 = 0x3812000000;
  v11 = __Block_byref_object_copy__1;
  v12 = __Block_byref_object_dispose__2;
  v13 = 0;
  v14 = 0;
  v7[0] = MEMORY[0x24BDAC760];
  v7[1] = 3221225472;
  v7[2] = ___ZN2re19RealityFileRegistry21getOrMountRealityFileERKNS_13DynamicStringE_block_invoke;
  v7[3] = &unk_24ED30000;
  v7[6] = this;
  v7[7] = a2;
  v7[4] = &v15;
  v7[5] = &v8;
  dispatch_sync(*this, v7);
  v4 = (char *)v16[6];
  if (v4)
  {
    v5 = v4 + 8;
    v6 = 1;
  }
  else
  {
    v4 = (char *)(id)v9[6];
    v6 = 0;
  }
  *(_BYTE *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v4;
  _Block_object_dispose(&v8, 8);

  _Block_object_dispose(&v15, 8);
  if (v21)

}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 48);
  if (v1)
  {

    *(_QWORD *)(a1 + 48) = 0;
  }
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(result + 48) = v2;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)(result + 80) = 0;
  *(_QWORD *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = 0;
  *(_QWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 72) = 0;
  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  v3 = *(_QWORD *)(result + 64);
  *(_QWORD *)(result + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v3;
  v4 = *(_QWORD *)(result + 80);
  *(_QWORD *)(result + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v4;
  ++*(_DWORD *)(a2 + 72);
  ++*(_DWORD *)(result + 72);
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{

}

{
  re::DynamicInlineArray<re::VideoObject<re::VideoPixelBufferBase>,2ul>::clear(a1 + 48);
}

void ___ZN2re19RealityFileRegistry21getOrMountRealityFileERKNS_13DynamicStringE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t **v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  re::RealityFile *v7;
  const re::DynamicString *v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  __int128 v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE v26[8];
  char *v27;
  char *v28;
  __int128 v29;
  uint64_t v30;
  int v31;
  char v32;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = re::RealityFileRegistryLRUCache::tryGet((re::RealityFileRegistryLRUCache *)(v2 + 8), *(const re::DynamicString **)(a1 + 56));
  if (!v3)
  {
    v6 = *(_QWORD *)(a1 + 56);
    if ((*(_BYTE *)(v6 + 8) & 1) != 0)
      v7 = *(re::RealityFile **)(v6 + 16);
    else
      v7 = (re::RealityFile *)(v6 + 9);
    re::RealityFile::makeByOpeningFileAtURL(v7, (uint64_t)v26);
    if (!v26[0])
    {
      re::ObjCObject::operator=((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48), (id *)&v27);
LABEL_28:
      re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v26);
      return;
    }
    v8 = *(const re::DynamicString **)(a1 + 56);
    v9 = (uint64_t **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v2 + 32, (uint64_t)v8);
    if (v9)
    {
      v10 = *v9;
      v11 = **v9;
      *(_QWORD *)(v11 + 8) = (*v9)[1];
      *(_QWORD *)v10[1] = v11;
      --*(_QWORD *)(v2 + 24);
      std::__destroy_at[abi:nn180100]<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,0>(v10 + 2);
      operator delete(v10);
      re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v2 + 32, (uint64_t)v8);
    }
LABEL_11:
    if (*(_QWORD *)(v2 + 80) <= (unint64_t)*(unsigned int *)(v2 + 60))
    {
      v12 = (_QWORD *)(v2 + 8);
      while (v12 != *(_QWORD **)(v2 + 16))
      {
        v12 = (_QWORD *)*v12;
        if (!*((_DWORD *)v12 + 14))
        {
          re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v2 + 32, (uint64_t)(v12 + 2));
          v13 = (_QWORD *)*v12;
          v13[1] = v12[1];
          *(_QWORD *)v12[1] = v13;
          --*(_QWORD *)(v2 + 24);
          std::__destroy_at[abi:nn180100]<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,0>(v12 + 2);
          operator delete(v12);
          goto LABEL_11;
        }
      }
    }
    v14 = v27;
    if (v27)
      v15 = v27 + 8;
    re::DynamicString::DynamicString((re::DynamicString *)&v28, v8);
    v31 = 1;
    v16 = (char *)operator new(0x40uLL);
    *((_QWORD *)v16 + 2) = v28;
    v17 = v30;
    v18 = v29;
    v28 = 0;
    *((_QWORD *)&v29 + 1) = 0;
    v30 = 0;
    *(_OWORD *)(v16 + 24) = v18;
    *((_QWORD *)v16 + 5) = v17;
    *((_QWORD *)v16 + 6) = v14;
    *((_DWORD *)v16 + 14) = 1;
    *(_QWORD *)v16 = v2 + 8;
    v19 = *(_QWORD **)(v2 + 16);
    *((_QWORD *)v16 + 1) = v19;
    *v19 = v16;
    v20 = *(_QWORD *)(v2 + 24) + 1;
    *(_QWORD *)(v2 + 16) = v16;
    *(_QWORD *)(v2 + 24) = v20;
    v28 = v16;
    v21 = re::Hash<re::DynamicString>::operator()((uint64_t)&v32, (uint64_t)v8);
    v22 = v21;
    if (*(_QWORD *)(v2 + 32))
    {
      v23 = v21 % *(unsigned int *)(v2 + 56);
      v24 = *(unsigned int *)(*(_QWORD *)(v2 + 40) + 4 * v23);
      if ((_DWORD)v24 != 0x7FFFFFFF)
      {
        v25 = *(_QWORD *)(v2 + 48);
        while (!re::DynamicString::operator==(v25 + 56 * v24 + 16, (uint64_t)v8))
        {
          v24 = *(_DWORD *)(v25 + 56 * v24 + 8) & 0x7FFFFFFF;
          if (v24 == 0x7FFFFFFF)
            goto LABEL_26;
        }
        goto LABEL_27;
      }
    }
    else
    {
      LODWORD(v23) = 0;
    }
LABEL_26:
    re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(v2 + 32, v23, v22, v8, &v28);
    ++*(_DWORD *)(v2 + 72);
LABEL_27:
    re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), (uint64_t)v27);
    goto LABEL_28;
  }
  v4 = (uint64_t *)v3;
  v5 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v2 + 32, *(_QWORD *)(a1 + 56));
  if (v5)
    ++*(_DWORD *)(*(_QWORD *)v5 + 56);
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), *v4);
}

uint64_t **re::RealityFileRegistryLRUCache::tryGet(re::RealityFileRegistryLRUCache *this, const re::DynamicString *a2)
{
  uint64_t **result;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  result = (uint64_t **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this + 24, (uint64_t)a2);
  if (result)
  {
    v4 = (uint64_t *)*((_QWORD *)this + 1);
    v5 = *result;
    if (v4 != *result)
    {
      v6 = (uint64_t *)v5[1];
      if (v6 != v4)
      {
        v7 = *v5;
        *(_QWORD *)(v7 + 8) = v6;
        *(_QWORD *)v5[1] = v7;
        v8 = *v4;
        *(_QWORD *)(v8 + 8) = v5;
        *v5 = v8;
        *v4 = (uint64_t)v5;
        v5[1] = (uint64_t)v4;
      }
    }
    return (uint64_t **)(v5 + 6);
  }
  return result;
}

void re::RealityFileRegistry::getMountedRealityFile(dispatch_queue_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  id v5;
  _QWORD v6[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t);
  void (*v11)(uint64_t);
  const char *v12;
  uint64_t v13;

  v7 = 0;
  v8 = &v7;
  v9 = 0x3812000000;
  v10 = __Block_byref_object_copy__0;
  v11 = __Block_byref_object_dispose__0;
  v12 = "";
  v13 = 0;
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 3221225472;
  v6[2] = ___ZN2re19RealityFileRegistry21getMountedRealityFileERKNS_13DynamicStringE_block_invoke;
  v6[3] = &unk_24ED30028;
  v6[5] = a1;
  v6[6] = a2;
  v6[4] = &v7;
  dispatch_sync(*a1, v6);
  v4 = v8[6];
  if (v4)
  {
    *(_QWORD *)(a3 + 8) = v4;
    v5 = (id)(v4 + 8);
    LOBYTE(v4) = 1;
  }
  *(_BYTE *)a3 = v4;
  _Block_object_dispose(&v7, 8);
  if (v13)

}

void ___ZN2re19RealityFileRegistry21getMountedRealityFileERKNS_13DynamicStringE_block_invoke(uint64_t a1)
{
  uint64_t *v2;

  v2 = (uint64_t *)re::RealityFileRegistryLRUCache::tryGet((re::RealityFileRegistryLRUCache *)(*(_QWORD *)(a1 + 40) + 8), *(const re::DynamicString **)(a1 + 48));
  if (v2)
    re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), *v2);
}

uint64_t re::RealityFileRegistry::unmountRealityFile(dispatch_queue_t *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD block[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re19RealityFileRegistry18unmountRealityFileERKNS_13DynamicStringE_block_invoke;
  block[3] = &unk_24ED30028;
  block[5] = a1;
  block[6] = a2;
  block[4] = &v5;
  dispatch_sync(*a1, block);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___ZN2re19RealityFileRegistry18unmountRealityFileERKNS_13DynamicStringE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  int v4;

  v2 = a1[5] + 32;
  result = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v2, a1[6]);
  if (result)
  {
    v4 = *(_DWORD *)(*(_QWORD *)result + 56);
    if (v4)
    {
      result = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v2, a1[6]);
      if (result)
        --*(_DWORD *)(*(_QWORD *)result + 56);
      LOBYTE(v4) = 1;
    }
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = v4;
  return result;
}

uint64_t re::RealityFileRegistry::mountRealityFileFromBuffer@<X0>(dispatch_queue_t *this@<X0>, const re::Data *a2@<X1>, uint64_t a3@<X8>)
{
  id v5;
  char v6;
  _QWORD v8[6];
  _BYTE v9[16];
  unsigned __int8 v10[8];
  id v11;
  uuid_t out;

  re::RealityFile::makeByReadingBuffer(a2, (uint64_t)v10);
  if (v10[0])
  {
    uuid_generate_random(out);
    v5 = (id)((*(_QWORD *)&out[8] + (*(_QWORD *)out << 6) + (*(_QWORD *)out >> 2) - 0x61C8864680B583E9) ^ *(_QWORD *)out);
    v8[0] = MEMORY[0x24BDAC760];
    v8[1] = 3321888768;
    v8[2] = ___ZN2re19RealityFileRegistry26mountRealityFileFromBufferERKNS_4DataE_block_invoke;
    v8[3] = &__block_descriptor_64_a8_48c69_ZTSN2re6ResultINS_9SharedPtrINS_11RealityFileEEENS_12WrappedErrorEEE_e5_v8__0l;
    v8[4] = this;
    v8[5] = v5;
    re::Result<re::SharedPtr<re::RealityFile>,re::WrappedError>::Result((uint64_t)v9, v10);
    dispatch_sync(*this, v8);
    re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v9);
    v6 = 1;
  }
  else
  {
    v5 = v11;
    v6 = 0;
  }
  *(_BYTE *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  return re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v10);
}

void ___ZN2re19RealityFileRegistry26mountRealityFileFromBufferERKNS_4DataE_block_invoke(_QWORD *a1)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  uint64_t v16;

  v3 = a1[4];
  v2 = a1[5];
  LODWORD(v4) = *(_QWORD *)(v3 + 88);
  v5 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
  v6 = v5 ^ (v5 >> 31);
  if (*(_QWORD *)(v3 + 88))
  {
    v4 = v6 % *(unsigned int *)(v3 + 112);
    v7 = *(unsigned int *)(*(_QWORD *)(v3 + 96) + 4 * v4);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v16 = *(_QWORD *)(v3 + 104);
      if (*(_QWORD *)(v16 + 32 * v7 + 16) == v2)
        return;
      while (1)
      {
        v7 = *(_DWORD *)(v16 + 32 * v7 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v7 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v16 + 32 * v7 + 16) == v2)
          return;
      }
    }
  }
  v8 = *(unsigned int *)(v3 + 124);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(v3 + 120);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(v3 + 112))
    {
      re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(v3 + 88, 2 * *(_DWORD *)(v3 + 116));
      LODWORD(v4) = v6 % *(unsigned int *)(v3 + 112);
      v9 = *(_DWORD *)(v3 + 120);
      v2 = a1[5];
    }
    *(_DWORD *)(v3 + 120) = v9 + 1;
    v10 = *(_QWORD *)(v3 + 104);
    v11 = *(_DWORD *)(v10 + 32 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(v3 + 104);
    v11 = *(_DWORD *)(v10 + 32 * v8 + 8);
    *(_DWORD *)(v3 + 124) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 32 * v8 + 8) = v11 | 0x80000000;
  v12 = v4;
  v13 = *(_QWORD *)(v3 + 96);
  *(_DWORD *)(*(_QWORD *)(v3 + 104) + 32 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(v3 + 104) + 32 * v8 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v4);
  *(_QWORD *)(*(_QWORD *)(v3 + 104) + 32 * v8) = v6;
  *(_QWORD *)(*(_QWORD *)(v3 + 104) + 32 * v8 + 16) = v2;
  v14 = a1[7];
  *(_QWORD *)(*(_QWORD *)(v3 + 104) + 32 * v8 + 24) = v14;
  if (v14)
  {
    v15 = (id)(v14 + 8);
    v13 = *(_QWORD *)(v3 + 96);
  }
  *(_DWORD *)(v13 + 4 * v12) = v8;
  ++*(_DWORD *)(v3 + 116);
  ++*(_DWORD *)(v3 + 128);
}

uint64_t __copy_helper_block_a8_48c69_ZTSN2re6ResultINS_9SharedPtrINS_11RealityFileEEENS_12WrappedErrorEEE(uint64_t a1, uint64_t a2)
{
  return re::Result<re::SharedPtr<re::RealityFile>,re::WrappedError>::Result(a1 + 48, (unsigned __int8 *)(a2 + 48));
}

uint64_t __destroy_helper_block_a8_48c69_ZTSN2re6ResultINS_9SharedPtrINS_11RealityFileEEENS_12WrappedErrorEEE(uint64_t a1)
{
  return re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result(a1 + 48);
}

void re::RealityFileRegistry::tryGetRealityFile(dispatch_queue_t *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  id v6;
  _QWORD block[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = 0;
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re19RealityFileRegistry17tryGetRealityFileEy_block_invoke;
  block[3] = &unk_24ED30028;
  block[4] = &v8;
  block[5] = this;
  block[6] = a2;
  dispatch_sync(*this, block);
  v4 = (uint64_t *)v9[3];
  if (v4)
  {
    v5 = *v4;
    *a3 = v5;
    if (v5)
      v6 = (id)(v5 + 8);
  }
  else
  {
    *a3 = 0;
  }
  _Block_object_dispose(&v8, 8);
}

uint64_t re::RealityFileRegistry::unmountRealityFile(dispatch_queue_t *this, uint64_t a2)
{
  uint64_t v2;
  _QWORD block[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re19RealityFileRegistry18unmountRealityFileEy_block_invoke;
  block[3] = &unk_24ED30028;
  block[4] = &v5;
  block[5] = this;
  block[6] = a2;
  dispatch_sync(*this, block);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void ___ZN2re19RealityFileRegistry18unmountRealityFileEy_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  int v19;

  v2 = a1[5];
  v3 = *(_QWORD *)(v2 + 88);
  if (v3)
  {
    v4 = a1[6];
    v5 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) >> 27));
    v6 = (v5 ^ (v5 >> 31)) % *(unsigned int *)(v2 + 112);
    v7 = *(_QWORD *)(v2 + 96);
    v8 = *(unsigned int *)(v7 + 4 * v6);
    if ((_DWORD)v8 == 0x7FFFFFFF)
    {
LABEL_3:
      LOBYTE(v3) = 0;
      goto LABEL_13;
    }
    v9 = *(_QWORD *)(v2 + 104);
    v10 = v9 + 32 * v8;
    if (*(_QWORD *)(v10 + 16) != v4)
    {
      while (1)
      {
        v11 = v8;
        v12 = *(_DWORD *)(v9 + 32 * v8 + 8);
        v8 = v12 & 0x7FFFFFFF;
        if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF)
          goto LABEL_3;
        v13 = v9 + 32 * v8;
        if (*(_QWORD *)(v13 + 16) == v4)
        {
          *(_DWORD *)(v9 + 32 * v11 + 8) = *(_DWORD *)(v9 + 32 * v11 + 8) & 0x80000000 | *(_DWORD *)(v13 + 8) & 0x7FFFFFFF;
          goto LABEL_9;
        }
      }
    }
    *(_DWORD *)(v7 + 4 * v6) = *(_DWORD *)(v10 + 8) & 0x7FFFFFFF;
LABEL_9:
    v14 = *(_QWORD *)(v2 + 104) + 32 * v8;
    v15 = *(_DWORD *)(v14 + 8);
    if (v15 < 0)
    {
      *(_DWORD *)(v14 + 8) = v15 & 0x7FFFFFFF;
      v18 = *(_QWORD *)(v14 + 24);
      v17 = (_QWORD *)(v14 + 24);
      v16 = v18;
      if (v18)
      {

        *v17 = 0;
      }
    }
    v19 = *(_DWORD *)(v2 + 128);
    *(_DWORD *)(*(_QWORD *)(v2 + 104) + 32 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(v2 + 104) + 32 * v8 + 8) & 0x80000000 | *(_DWORD *)(v2 + 124);
    --*(_DWORD *)(v2 + 116);
    *(_DWORD *)(v2 + 124) = v8;
    *(_DWORD *)(v2 + 128) = v19 + 1;
    LOBYTE(v3) = 1;
  }
LABEL_13:
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = v3;
}

void re::RealityFileRegistry::getOrMountRealityFile(re::RealityFileDescriptor *this@<X1>, dispatch_queue_t *a2@<X0>, uint64_t a3@<X8>)
{
  int v5;
  uint64_t v6;
  BOOL v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  _BYTE v20[23];
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  _BYTE v26[7];
  _BYTE *v27;

  v5 = *(unsigned __int8 *)this;
  if ((v5 - 1) < 2)
  {
LABEL_4:
    re::RealityFileDescriptor::getURL((uint64_t)this);
    if ((_BYTE)v23)
    {
      v6 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a2 + 4), (uint64_t)&v24);
      if (v6)
        v7 = *(_DWORD *)(*(_QWORD *)v6 + 56) != 0;
      else
        v7 = 0;
      re::RealityFileRegistry::getOrMountRealityFile(a2, (const re::DynamicString *)&v24, a3);
      if (*(_BYTE *)a3)
      {
        if (!v7)
        {
          v13 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a2 + 4), (uint64_t)&v24);
          if (v13)
            --*(_DWORD *)(*(_QWORD *)v13 + 56);
        }
      }
    }
    else
    {
      if ((v25 & 1) != 0)
        v8 = v27;
      else
        v8 = v26;
      re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), (const __CFString *)0xD, (uint64_t)v8, &v18);
      v9 = v18;
      v18 = 0;
      *(_BYTE *)a3 = 0;
      *(_QWORD *)(a3 + 8) = v9;

    }
LABEL_25:
    if (v24)
    {
      if ((v25 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v24 + 40))();
    }
    return;
  }
  if (v5 != 3)
  {
    if (v5 != 4)
    {
      re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), (const __CFString *)0xA, (uint64_t)"The realityFileDescriptor is invalid.", &v23);
      v12 = v23;
      v23 = 0;
      *(_BYTE *)a3 = 0;
      *(_QWORD *)(a3 + 8) = v12;

      return;
    }
    goto LABEL_4;
  }
  re::RealityFileDescriptor::getMemoryFileID(this);
  if ((_BYTE)v23)
  {
    re::RealityFileRegistry::tryGetRealityFile(a2, v24, &v22);
    v10 = v22;
    if (v22)
    {
      v11 = (id)(v22 + 8);
      *(_BYTE *)a3 = 1;
      *(_QWORD *)(a3 + 8) = v10;

    }
    else
    {
      re::DynamicString::format((re::DynamicString *)"No reality file is registered with MemoryFileID %llu.", (re::DynamicString *)&v18, v24);
      if ((v19 & 1) != 0)
        v16 = *(_BYTE **)&v20[7];
      else
        v16 = v20;
      re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), (const __CFString *)0xC, (uint64_t)v16, &v21);
      v17 = v21;
      v21 = 0;
      *(_BYTE *)a3 = 0;
      *(_QWORD *)(a3 + 8) = v17;

      if (v18 && (v19 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v18 + 40))();
    }
  }
  else
  {
    if ((v25 & 1) != 0)
      v14 = v27;
    else
      v14 = v26;
    re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), (const __CFString *)0xC, (uint64_t)v14, &v18);
    v15 = v18;
    v18 = 0;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v15;

  }
  if (!(_BYTE)v23)
    goto LABEL_25;
}

void re::RealityFileRegistry::getMountedRealityFile(re::RealityFileDescriptor *this@<X1>, dispatch_queue_t *a2@<X0>, uint64_t a3@<X8>)
{
  int v5;
  char v6;
  uint64_t v7;
  char v8;
  unint64_t v9;
  char v10;

  v5 = *(unsigned __int8 *)this;
  if ((v5 - 1) < 2)
    goto LABEL_4;
  if (v5 != 3)
  {
    if (v5 != 4)
    {
      *(_BYTE *)a3 = 0;
      return;
    }
LABEL_4:
    re::RealityFileDescriptor::getURL((uint64_t)this);
    if (v8)
    {
      re::RealityFileRegistry::getMountedRealityFile(a2, (uint64_t)&v9, a3);
      goto LABEL_12;
    }
LABEL_11:
    *(_BYTE *)a3 = 0;
LABEL_12:
    if (v9)
    {
      if ((v10 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v9 + 40))();
    }
    return;
  }
  re::RealityFileDescriptor::getMemoryFileID(this);
  if (!v8)
    goto LABEL_11;
  re::RealityFileRegistry::tryGetRealityFile(a2, v9, &v7);
  v6 = v7;
  if (v7)
  {
    *(_QWORD *)(a3 + 8) = v7;
    v6 = 1;
  }
  *(_BYTE *)a3 = v6;
  if (!v8)
    goto LABEL_12;
}

uint64_t re::RealityFileRegistry::unmountRealityFile(dispatch_queue_t *a1, re::RealityFileDescriptor *this)
{
  int v3;
  uint64_t v4;
  char v6;
  unint64_t v7;
  char v8;

  v3 = *(unsigned __int8 *)this;
  if ((v3 - 1) >= 2)
  {
    if (v3 == 3)
    {
      re::RealityFileDescriptor::getMemoryFileID(this);
      if (v6)
        return re::RealityFileRegistry::unmountRealityFile(a1, v7);
      goto LABEL_8;
    }
    if (v3 != 4)
      return 0;
  }
  re::RealityFileDescriptor::getURL((uint64_t)this);
  if (!v6)
  {
LABEL_8:
    v4 = 0;
    goto LABEL_9;
  }
  v4 = re::RealityFileRegistry::unmountRealityFile(a1, (uint64_t)&v7);
LABEL_9:
  if (v7 && (v8 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v7 + 40))();
  return v4;
}

unint64_t re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(uint64_t a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int *v14;
  int v15;
  uint64_t v16;
  _OWORD *v17;
  unint64_t v18;
  int v19;
  char v20;

  result = re::Hash<re::DynamicString>::operator()((uint64_t)&v20, a2);
  if (*(_QWORD *)a1)
  {
    v5 = result % *(unsigned int *)(a1 + 24);
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(unsigned int *)(v6 + 4 * v5);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *(_QWORD *)(a1 + 16);
      result = re::DynamicString::operator==(v8 + 56 * v7 + 16, a2);
      if ((result & 1) != 0)
      {
        *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v8 + 56 * v7 + 8) & 0x7FFFFFFF;
LABEL_8:
        v11 = *(_QWORD *)(a1 + 16);
        v12 = v11 + 56 * v7;
        v15 = *(_DWORD *)(v12 + 8);
        v14 = (int *)(v12 + 8);
        v13 = v15;
        if (v15 < 0)
        {
          *v14 = v13 & 0x7FFFFFFF;
          v16 = v11 + 56 * v7;
          v18 = *(_QWORD *)(v16 + 16);
          v17 = (_OWORD *)(v16 + 16);
          result = v18;
          if (v18)
          {
            if ((*(_BYTE *)(v11 + 56 * v7 + 24) & 1) != 0)
              result = (*(uint64_t (**)(unint64_t, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v11 + 56 * v7 + 32));
            *v17 = 0u;
            v17[1] = 0u;
          }
          v11 = *(_QWORD *)(a1 + 16);
          v13 = *(_DWORD *)(v11 + 56 * v7 + 8);
        }
        v19 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v11 + 56 * v7 + 8) = *(_DWORD *)(a1 + 36) | v13 & 0x80000000;
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v7;
        *(_DWORD *)(a1 + 40) = v19 + 1;
      }
      else
      {
        while (1)
        {
          v9 = v7;
          v10 = *(_DWORD *)(v8 + 56 * v7 + 8);
          v7 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          result = re::DynamicString::operator==(v8 + 56 * v7 + 16, a2);
          if ((result & 1) != 0)
          {
            *(_DWORD *)(v8 + 56 * v9 + 8) = *(_DWORD *)(v8 + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(v8 + 56 * v7 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

void re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  signed int v22;
  _BYTE v23[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(_QWORD *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphNode>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v23, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v23;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)v23 = v5;
      *(_QWORD *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = v7;
        v13 = DWORD1(v9);
        v14 = (_QWORD *)(v6 + 24);
        do
        {
          if ((*(_DWORD *)(v14 - 2) & 0x80000000) != 0)
          {
            v15 = *(v14 - 3);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * v13));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 32 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18) = v15;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 16) = *(v14 - 1);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 24) = *v14;
            *v14 = 0;
            *(_DWORD *)(v12 + 4 * v17) = v18;
            v13 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v13;
            v10 = *(_DWORD *)&v23[32];
          }
          ++v11;
          v14 += 4;
        }
        while (v11 < v10);
      }
      re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2)
      v22 = a2;
    else
      v22 = 3;
  }
}

uint64_t re::Result<re::SharedPtr<re::RealityFile>,re::WrappedError>::Result(uint64_t a1, unsigned __int8 *a2)
{
  int v3;
  uint64_t v4;
  id v5;

  v3 = *a2;
  *(_BYTE *)a1 = v3;
  v4 = *((_QWORD *)a2 + 1);
  if (v3)
  {
    *(_QWORD *)(a1 + 8) = v4;
    if (v4)
      v5 = (id)(v4 + 8);
  }
  else
  {
    *(_QWORD *)(a1 + 8) = (id)v4;
  }
  return a1;
}

re::DynamicString *re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, const re::DynamicString *a4, _QWORD *a5)
{
  uint64_t v10;
  int v11;
  int v12;
  signed int v13;
  uint64_t v14;
  BOOL v15;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  unsigned int v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  signed int v25;
  re::DynamicString *result;
  _BYTE v27[44];

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      v12 = *(_DWORD *)(a1 + 28);
      v13 = 2 * v12;
      v14 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v13)
          v15 = (_DWORD)v10 == v13;
        else
          v15 = 1;
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v27, 0, 36);
          *(_QWORD *)&v27[36] = 0x7FFFFFFFLL;
          re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v27, v14, v13);
          v16 = *(_OWORD *)v27;
          *(_OWORD *)v27 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          v17 = *(_QWORD *)&v27[16];
          *(_QWORD *)&v27[16] = *(_QWORD *)(a1 + 16);
          *(_QWORD *)(a1 + 16) = v17;
          v19 = *(_OWORD *)&v27[24];
          *(_OWORD *)&v27[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_OWORD *)&v27[24];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = DWORD2(v18);
          if (DWORD2(v18))
          {
            v21 = 0;
            v22 = 0;
            do
            {
              if ((*(_DWORD *)(*(_QWORD *)&v27[16] + v21 + 8) & 0x80000000) != 0)
              {
                re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v27[16] + v21) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v27[16] + v21), *(_QWORD *)&v27[16] + v21 + 16, *(_QWORD *)&v27[16] + v21 + 48);
                v20 = *(_DWORD *)&v27[32];
              }
              ++v22;
              v21 += 56;
            }
            while (v22 < v20);
          }
          re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v27, *(double *)&v18);
        }
      }
      else
      {
        if (v13)
          v25 = 2 * v12;
        else
          v25 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_DWORD *)(v23 + 56 * v10 + 8);
  }
  else
  {
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_DWORD *)(v23 + 56 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 56 * v10 + 8) = v24 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10) = a3;
  result = re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 16), a4);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 48) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

void re::ResourceSharingManager::xpcInterface(_QWORD *a1@<X8>)
{
  id v3;

  objc_msgSend(MEMORY[0x24BDD1990], "interfaceWithProtocol:", &unk_255838E58);
  v3 = (id)objc_claimAutoreleasedReturnValue();
  *a1 = v3;

}

void re::ResourceSharingManager::~ResourceSharingManager(void **this)
{
  char *v2;

  re::ResourceSharingManager::deinit(this);
  re::DynamicArray<re::ResourceSharingManager::Connection>::deinit((uint64_t)(this + 8));
  v2 = (char *)this[7];
  if (v2)
  {

    this[7] = 0;
  }

}

{
  re::ResourceSharingManager::~ResourceSharingManager(this);
  JUMPOUT(0x2276933B8);
}

void **re::ResourceSharingManager::deinit(void **this)
{
  void **v1;
  NSObject *v2;
  char *v3;
  _QWORD block[5];

  if (*((_BYTE *)this + 16))
  {
    v1 = this;
    (*(void (**)(void *, _QWORD))(*(_QWORD *)this[3] + 232))(this[3], 0);
    v2 = v1[5];
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZN2re22ResourceSharingManager6deinitEv_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = v1;
    dispatch_sync(v2, block);
    re::DynamicArray<re::ResourceSharingManager::Connection>::deinit((uint64_t)(v1 + 8));
    v3 = (char *)v1[7];
    if (v3)
    {

      v1[7] = 0;
    }
    v1[6] = 0;
    re::ObjCObject::operator=(v1 + 5, 0);
    this = re::ObjCObject::operator=(v1 + 4, 0);
    v1[3] = 0;
    *((_BYTE *)v1 + 16) = 0;
  }
  return this;
}

void `non-virtual thunk to're::ResourceSharingManager::~ResourceSharingManager(void **this)
{
  re::ResourceSharingManager::~ResourceSharingManager(this - 1);
}

{
  re::ResourceSharingManager::~ResourceSharingManager(this - 1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::ResourceSharingManager::init(re::ResourceSharingManager *this, AssetService *a2, id *a3, uint64_t a4)
{
  NSObject *v6;
  NSObject *v7;
  dispatch_queue_t v8;
  re *v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  char *v12;
  uint64_t result;
  uint64_t v14;

  *((_QWORD *)this + 3) = a2;
  re::ObjCObject::operator=((id *)this + 4, a3);
  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v6 = objc_claimAutoreleasedReturnValue();
  dispatch_get_global_queue(21, 0);
  v7 = objc_claimAutoreleasedReturnValue();
  v8 = dispatch_queue_create_with_target_V2("com.apple.RealityKit.resource-sharing", v6, v7);
  re::ObjCObject::operator=((void **)this + 5, v8);

  *((_QWORD *)this + 6) = a4;
  re::make::shared::object<re::internal::ResourceRequestQueue>(v9, &v14);
  v11 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = v14;
  v14 = v11;
  if (v11)

  v12 = (char *)this + 64;
  re::DynamicArray<re::ResourceSharingManager::Connection>::setCapacity(v12, 2uLL);
  ++*((_DWORD *)v12 + 6);
  result = (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)v12 - 5) + 232))(*((_QWORD *)v12 - 5), v12 - 56);
  *(v12 - 48) = 1;
  return result;
}

void ___ZN2re22ResourceSharingManager6deinitEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  re::PeerIDValidator *v6;
  __int128 *v7;
  void *v8;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 80);
  if (v2)
  {
    v3 = *(_QWORD *)(v1 + 96);
    v4 = 168 * v2;
    do
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(v3 + 72);
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(v3 + 120);
      re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear(v3 + 24);
      v5 = *(_QWORD *)(v3 + 16);
      v7 = re::PeerIDValidator::instance(v6);
      re::PeerIDValidator::remove_impl((re::PeerIDValidator *)v7, v5);
      objc_msgSend(*(id *)v3, "invalidate");
      objc_msgSend(*(id *)(v3 + 8), "invalidate");
      re::ObjCObject::operator=((void **)v3, 0);
      v8 = *(void **)(v3 + 8);
      *(_QWORD *)(v3 + 8) = 0;

      v3 += 168;
      v4 -= 168;
    }
    while (v4);
  }
}

void re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 32 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 32;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t re::DynamicArray<re::ResourceSharingManager::Connection>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = (uint64_t *)(v3 + 72);
        v6 = 168 * v4;
        do
        {
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v5 + 6);
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v5);
          re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit(v5 - 6);

          v5 += 21;
          v6 -= 168;
        }
        while (v6);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::ResourceSharingManager::connect(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  REResourceSharingClientObject *v6;
  REResourceSharingClientObject *v7;
  uint64_t v8;
  REResourceSharingClientObject *v9;
  REResourceSharingClientObject *v10;
  NSObject *v11;
  void *v12;
  NSObject *v13;
  REResourceSharingClientObject *v14;
  void *v15;
  id v16;
  _QWORD block[4];
  REResourceSharingClientObject *v18;
  __int128 *p_buf;
  uint64_t v20;
  uint64_t v21;
  id v22;
  _QWORD v23[4];
  REResourceSharingClientObject *v24;
  _QWORD v25[4];
  REResourceSharingClientObject *v26;
  id v27;
  __int128 buf;
  uint64_t v29;
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  v6 = -[REResourceSharingClientObject initWithAssetService:resourceSharingManager:peerID:]([REResourceSharingClientObject alloc], "initWithAssetService:resourceSharingManager:peerID:", *(_QWORD *)(a1 + 24), a1, a3);
  re::xpc::Connection::makeWithListenerEndpoint(a2, &v27);
  v7 = v6;
  *(_QWORD *)&buf = v7;
  re::xpc::Connection::setExportedObject(&v27, (const re::ObjCObject *)&buf);

  re::ResourceSharingManager::xpcInterface(&buf);
  re::xpc::Connection::setExportedInterface(&v27, (uint64_t *)&buf);

  re::ResourceFetchManager::xpcInterface(&buf);
  re::xpc::Connection::setRemoteObjectInterface(&v27, (uint64_t *)&buf);

  re::xpc::Connection::setQueue(&v27, (const re::dispatch::Queue *)(a1 + 40));
  v8 = MEMORY[0x24BDAC760];
  v25[0] = MEMORY[0x24BDAC760];
  v25[1] = 3221225472;
  v25[2] = ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke;
  v25[3] = &unk_24ED2D4C0;
  v9 = v7;
  v26 = v9;
  objc_msgSend(v27, "setInterruptionHandler:", v25);
  v23[0] = v8;
  v23[1] = 3221225472;
  v23[2] = ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke_54;
  v23[3] = &unk_24ED2D4C0;
  v10 = v9;
  v24 = v10;
  v11 = *re::resourceSharingLogObjects((re *)objc_msgSend(v27, "setInvalidationHandler:", v23));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = a3;
    _os_log_debug_impl(&dword_224FE9000, v11, OS_LOG_TYPE_DEBUG, "Establishing new resource connection with peer ID %llu", (uint8_t *)&buf, 0xCu);
  }
  *(_QWORD *)&buf = 0;
  *((_QWORD *)&buf + 1) = &buf;
  v29 = 0x2020000000;
  v30 = 1;
  v12 = *(void **)(a1 + 40);
  block[0] = v8;
  block[1] = 3321888768;
  block[2] = ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke_55;
  block[3] = &unk_24ED30128;
  p_buf = &buf;
  v20 = a1;
  v21 = a3;
  v13 = v12;
  v22 = v27;
  v14 = v10;
  v18 = v14;
  dispatch_sync(v13, block);

  if (*(_BYTE *)(*((_QWORD *)&buf + 1) + 24))
  {
    v15 = (void *)objc_opt_new();
    objc_msgSend(v27, "resume");
    re::xpc::Connection::remoteObjectProxy(&v27, &v16);
    objc_msgSend(v16, "associateConnectionWithPeerID:clientPorts:", *(_QWORD *)(a1 + 48), v15);

    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 24) + 376))(*(_QWORD *)(a1 + 24), a3);
  }

  _Block_object_dispose(&buf, 8);
}

void ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke(id *a1)
{
  NSObject *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  id v6;
  id v7;
  uint8_t buf[4];
  id v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *re::resourceSharingLogObjects((re *)a1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = a1[4];
    *(_DWORD *)buf = 138412290;
    v9 = v3;
    _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEFAULT, "Resource connection with server %@ was interrupted", buf, 0xCu);
  }
  v4 = objc_msgSend(a1[4], "resourceSharingManager");
  if (v4)
  {
    v5 = v4;
    v6 = a1[4];
    v7 = v6;
    re::ResourceSharingManager::connectionInterruptedOrInvalidated(v5, &v7);

  }
}

void re::ResourceSharingManager::connectionInterruptedOrInvalidated(uint64_t a1, id *a2)
{
  re::PeerIDValidator *v4;
  __int128 *v5;
  re *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  id v13;
  NSObject *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  id v23;
  unsigned int v24;
  int v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t *v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t i;
  uint64_t v43;
  uint64_t v44;
  re *v45;
  NSObject *v46;
  id *v47;
  uint8_t buf[16];
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 40));
  v47 = a2;
  v4 = (re::PeerIDValidator *)objc_msgSend(*a2, "peerID");
  v5 = re::PeerIDValidator::instance(v4);
  re::PeerIDValidator::remove_impl((re::PeerIDValidator *)v5, (unint64_t)v4);
  v7 = *(_QWORD *)(a1 + 80);
  if (!v7)
  {
LABEL_5:
    v12 = *re::resourceSharingLogObjects(v6);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      return;
    v13 = *a2;
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = v13;
    v14 = v12;
    v15 = "Resource connection with server %@ interrupted/invalidated: not found in connection list";
LABEL_49:
    _os_log_debug_impl(&dword_224FE9000, v14, OS_LOG_TYPE_DEBUG, v15, buf, 0xCu);

    return;
  }
  v8 = 0;
  v9 = *(_QWORD *)(a1 + 96);
  v10 = 120;
  while (1)
  {
    v11 = v9 + v10;
    if (*(id *)(v9 + v10 - 112) == *a2)
      break;
    ++v8;
    v10 += 168;
    if (v7 == v8)
      goto LABEL_5;
  }
  v16 = *(unsigned int *)(v11 - 64);
  if ((_DWORD)v16)
  {
    v17 = 0;
    v18 = (int *)(*(_QWORD *)(v9 + v10 - 80) + 8);
    while (1)
    {
      v19 = *v18;
      v18 += 6;
      if (v19 < 0)
        break;
      if (v16 == ++v17)
      {
        LODWORD(v17) = *(_DWORD *)(v11 - 64);
        break;
      }
    }
  }
  else
  {
    LODWORD(v17) = 0;
  }
  if ((_DWORD)v16 != (_DWORD)v17)
  {
    v20 = v17;
    v21 = v9 + v10;
    do
    {
      v22 = *(_QWORD *)(*(_QWORD *)(v21 - 80) + 24 * v20 + 16) + 72;
      v23 = *a2;
      re::DynamicArray<REResourceSharingClientObject * {__strong}>::remove(v22, (uint64_t)v23);

      v24 = *(_DWORD *)(v11 - 64);
      if (v24 <= (int)v17 + 1)
        v24 = v17 + 1;
      v25 = v17;
      while (1)
      {
        v20 = (v25 + 1);
        if (v24 - 1 == v25)
          break;
        ++v25;
        LODWORD(v17) = v20;
        if ((*(_DWORD *)(*(_QWORD *)(v21 - 80) + 24 * v20 + 8) & 0x80000000) != 0)
          goto LABEL_22;
      }
      LODWORD(v17) = v24;
LABEL_22:
      ;
    }
    while ((_DWORD)v16 != (_DWORD)v17);
    v7 = *(_QWORD *)(a1 + 80);
  }
  if (v7 <= v8)
  {
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    *(_OWORD *)buf = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_51;
  }
  re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear(*(_QWORD *)(a1 + 96) + v10 - 96);
  if (*(_QWORD *)(a1 + 80) <= v8)
  {
LABEL_51:
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    *(_OWORD *)buf = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_52;
  }
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 96) + v10 - 120), "invalidate");
  if (*(_QWORD *)(a1 + 80) <= v8)
  {
LABEL_52:
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    *(_OWORD *)buf = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_53;
  }
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 96) + v10 - 112), "invalidate");
  if (*(_QWORD *)(a1 + 80) <= v8)
  {
LABEL_53:
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    *(_OWORD *)buf = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    *(_OWORD *)buf = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 24) + 384))(*(_QWORD *)(a1 + 24), *(_QWORD *)(*(_QWORD *)(a1 + 96) + v10 - 104));
  v26 = *(_QWORD *)(a1 + 80);
  if (v26 <= v8)
    goto LABEL_54;
  if (v26 - 1 > v8)
  {
    v27 = *(_QWORD *)(a1 + 96);
    v28 = v27 + 168 * v26;
    v29 = v10 - 168 * v26;
    v30 = v27 + v10;
    if (v29 != -48)
    {
      v31 = *(_QWORD *)(v28 - 168);
      *(_QWORD *)(v28 - 168) = 0;
      v32 = *(void **)(v30 - 120);
      *(_QWORD *)(v30 - 120) = v31;

    }
    v33 = *(_QWORD *)(v28 - 160);
    *(_QWORD *)(v28 - 160) = 0;
    v34 = *(void **)(v30 - 112);
    *(_QWORD *)(v30 - 112) = v33;

    *(_QWORD *)(v30 - 104) = *(_QWORD *)(v28 - 152);
    if (v29 != -48)
    {
      v35 = (uint64_t *)(v30 - 96);
      v36 = (uint64_t *)(v28 - 144);
      v37 = *(_QWORD *)(v30 - 96);
      if (!v37 || (v38 = *v36, v37 == *v36))
      {
        re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v35, v36);
      }
      else
      {
        re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear((uint64_t)v35);
        if (v38)
        {
          v39 = *(_DWORD *)(v28 - 116);
          if (*(_DWORD *)(v27 + v10 - 72) < v39)
            re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::setCapacity((uint64_t)v35, v39);
          v40 = *(unsigned int *)(v28 - 112);
          if ((_DWORD)v40)
          {
            v41 = 0;
            for (i = 0; i < v40; ++i)
            {
              v43 = *(_QWORD *)(v28 - 128) + v41;
              if ((*(_DWORD *)(v43 + 8) & 0x80000000) != 0)
              {
                re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::addAsCopy((uint64_t)v35, *(_QWORD *)v43 % (unint64_t)*(unsigned int *)(v27 + v10 - 72), *(_QWORD *)v43, (uint64_t *)(v43 + 16));
                v40 = *(unsigned int *)(v28 - 112);
              }
              v41 += 24;
            }
          }
          ++*(_DWORD *)(v27 + v10 - 56);
        }
      }
    }
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(v27 + v10 - 48, v28 - 96);
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(v27 + v10, v28 - 48);
    v26 = *(_QWORD *)(a1 + 80);
  }
  v44 = *(_QWORD *)(a1 + 96) + 168 * v26;
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(v44 - 48));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(v44 - 96));
  re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)(v44 - 144));

  --*(_QWORD *)(a1 + 80);
  ++*(_DWORD *)(a1 + 88);
  v46 = *re::resourceSharingLogObjects(v45);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
  {
    v13 = *v47;
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = v13;
    v14 = v46;
    v15 = "Resource connection with server %@ interrupted/invalidated: removed from connection list";
    goto LABEL_49;
  }
}

void ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke_54(id *a1)
{
  NSObject *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  id v6;
  id v7;
  uint8_t buf[4];
  id v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *re::resourceSharingLogObjects((re *)a1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = a1[4];
    *(_DWORD *)buf = 138412290;
    v9 = v3;
    _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEFAULT, "Resource connection with server %@ was invalidated", buf, 0xCu);
  }
  v4 = objc_msgSend(a1[4], "resourceSharingManager");
  if (v4)
  {
    v5 = v4;
    v6 = a1[4];
    v7 = v6;
    re::ResourceSharingManager::connectionInterruptedOrInvalidated(v5, &v7);

  }
}

void ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke_55(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  __int128 *v4;
  id v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[48];
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27[3];
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33[3];
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v2 = *(_QWORD *)(a1 + 48);
  *(_DWORD *)&v21[8] = objc_msgSend(*(id *)(a1 + 64), "processIdentifier", *(_QWORD *)(a1 + 56));
  v3 = *(void **)(a1 + 64);
  if (v3)
    v3 = (void *)objc_msgSend(v3, "auditToken");
  else
    memset(&v21[12], 0, 32);
  *(_DWORD *)&v21[44] = 0;
  v4 = re::PeerIDValidator::instance((re::PeerIDValidator *)v3);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = re::PeerIDValidator::validateOrAdd_impl(v4, (uint64_t)v21);
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
  {
    v5 = *(id *)(a1 + 64);
    v6 = (_anonymous_namespace_ *)*(id *)(a1 + 32);
    v7 = v6;
    v8 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)&v21[16] = v8;
    v26 = 0;
    v35 = 0x7FFFFFFF00000000;
    v36 = 0;
    v32 = 0;
    v34 = 0;
    v9 = *(_QWORD *)(v2 + 72);
    v10 = *(_QWORD *)(v2 + 80);
    if (v10 >= v9)
    {
      v11 = v10 + 1;
      if (v9 < v10 + 1)
      {
        if (*(_QWORD *)(v2 + 64))
        {
          v12 = 2 * v9;
          v13 = v9 == 0;
          v14 = 8;
          if (!v13)
            v14 = v12;
          if (v14 <= v11)
            v15 = v11;
          else
            v15 = v14;
          re::DynamicArray<re::ResourceSharingManager::Connection>::setCapacity((_QWORD *)(v2 + 64), v15);
        }
        else
        {
          re::DynamicArray<re::ResourceSharingManager::Connection>::setCapacity((_QWORD *)(v2 + 64), v11);
          ++*(_DWORD *)(v2 + 88);
        }
      }
      v10 = *(_QWORD *)(v2 + 80);
    }
    v16 = *(_QWORD *)(v2 + 96) + 168 * v10;
    *(_OWORD *)v21 = 0u;
    *(_QWORD *)v16 = v5;
    *(_QWORD *)(v16 + 8) = v7;
    *(_DWORD *)(v16 + 64) = 0;
    *(_QWORD *)(v16 + 16) = v8;
    *(_QWORD *)(v16 + 24) = 0;
    *(_QWORD *)&v21[24] = 0;
    *(_QWORD *)(v16 + 32) = 0;
    *(_QWORD *)&v21[32] = 0;
    *(_QWORD *)(v16 + 40) = 0;
    *(_QWORD *)&v21[40] = 0;
    *(_DWORD *)(v16 + 48) = 0;
    v22 = 0;
    *(_DWORD *)(v16 + 52) = 0;
    v23 = 0;
    *(_DWORD *)(v16 + 56) = 0;
    v24 = 0;
    *(_DWORD *)(v16 + 60) = 0x7FFFFFFF;
    v25 = 0x7FFFFFFF;
    *(_DWORD *)(v16 + 104) = 0;
    *(_QWORD *)(v16 + 96) = 0;
    *(_OWORD *)(v16 + 80) = 0u;
    *(_DWORD *)(v16 + 112) = 0;
    *(_QWORD *)(v16 + 72) = 0;
    v27[0] = 0;
    v17 = *(_QWORD *)(v16 + 80);
    *(_QWORD *)(v16 + 80) = 0;
    v27[1] = v17;
    v18 = *(_QWORD *)(v16 + 88);
    *(_QWORD *)(v16 + 88) = 0;
    v27[2] = v18;
    LODWORD(v18) = *(_DWORD *)(v16 + 96);
    *(_DWORD *)(v16 + 96) = 0;
    v28 = v18;
    LODWORD(v18) = *(_DWORD *)(v16 + 100);
    *(_DWORD *)(v16 + 100) = 0;
    v29 = v18;
    LODWORD(v18) = *(_DWORD *)(v16 + 104);
    *(_DWORD *)(v16 + 104) = 0;
    v30 = v18;
    *(_DWORD *)(v16 + 108) = 0x7FFFFFFF;
    v31 = 0x7FFFFFFF;
    *(_DWORD *)(v16 + 152) = 0;
    *(_QWORD *)(v16 + 144) = 0;
    *(_OWORD *)(v16 + 128) = 0u;
    *(_DWORD *)(v16 + 160) = 0;
    *(_QWORD *)(v16 + 120) = 0;
    v33[0] = 0;
    v19 = *(_QWORD *)(v16 + 128);
    *(_QWORD *)(v16 + 128) = 0;
    v33[1] = v19;
    v20 = *(_QWORD *)(v16 + 136);
    *(_QWORD *)(v16 + 136) = 0;
    v33[2] = v20;
    LODWORD(v20) = *(_DWORD *)(v16 + 144);
    *(_DWORD *)(v16 + 144) = 0;
    LODWORD(v34) = v20;
    LODWORD(v20) = *(_DWORD *)(v16 + 148);
    *(_DWORD *)(v16 + 148) = HIDWORD(v34);
    HIDWORD(v34) = v20;
    LODWORD(v20) = *(_DWORD *)(v16 + 152);
    *(_DWORD *)(v16 + 152) = v35;
    LODWORD(v35) = v20;
    *(_DWORD *)(v16 + 156) = HIDWORD(v35);
    HIDWORD(v35) = 0x7FFFFFFF;
    ++*(_QWORD *)(v2 + 80);
    ++*(_DWORD *)(v2 + 88);
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v33);
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v27);
    re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)&v21[24]);

  }
}

id __copy_helper_block_a8_64c25_ZTSN2re3xpc10ConnectionE(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 64);
  *(_QWORD *)(a1 + 64) = result;
  return result;
}

void __destroy_helper_block_a8_64c25_ZTSN2re3xpc10ConnectionE(uint64_t a1)
{

}

uint64_t re::ResourceSharingManager::connectedPeers@<X0>(re::ResourceSharingManager *this@<X0>, uint64_t a2@<X8>)
{
  NSObject *v3;
  uint64_t result;
  _QWORD block[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  uint64_t (*v10)(uint64_t);
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;

  v6 = 0;
  v7 = &v6;
  v8 = 0x5812000000;
  v9 = __Block_byref_object_copy__1;
  v10 = __Block_byref_object_dispose__1;
  v16 = 0;
  v11 = "";
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v3 = *((_QWORD *)this + 5);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZNK2re22ResourceSharingManager14connectedPeersEv_block_invoke;
  block[3] = &unk_24ED30160;
  block[4] = &v6;
  block[5] = this;
  dispatch_sync(v3, block);
  re::DynamicArray<char const*>::DynamicArray(a2, v7 + 6);
  _Block_object_dispose(&v6, 8);
  result = v12;
  if (v12)
  {
    if (v16)
      return (*(uint64_t (**)(void))(*(_QWORD *)v12 + 40))();
  }
  return result;
}

uint64_t __Block_byref_object_dispose__1(uint64_t a1)
{
  uint64_t result;
  _QWORD *v3;

  v3 = (_QWORD *)(a1 + 48);
  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    if (*(_QWORD *)(a1 + 80))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 80) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 72);
  }
  return result;
}

void re::ResourceSharingManager::pushDirectCommit(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  id v5;
  _QWORD block[4];
  id v7;
  uint64_t v8;

  v3 = a2;
  dispatch_assert_queue_not_V2(*(dispatch_queue_t *)(a1 + 40));
  v4 = *(NSObject **)(a1 + 40);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re22ResourceSharingManager16pushDirectCommitEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
  block[3] = &unk_24ED30188;
  v7 = v3;
  v8 = a1;
  v5 = v3;
  dispatch_sync(v4, block);

}

void ___ZN2re22ResourceSharingManager16pushDirectCommitEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  id *v4;
  uint64_t v5;
  void *v6;
  REXPCObject *v7;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(v1 + 80);
  if (v2)
  {
    v4 = *(id **)(v1 + 96);
    v5 = 168 * v2;
    do
    {
      re::ResourceFetchManager::Connection::remoteObjectProxy(v4);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      v7 = -[REXPCObject initWithObject:]([REXPCObject alloc], "initWithObject:", *(_QWORD *)(a1 + 32));
      objc_msgSend(v6, "receiveDirectResourceCommit:", v7);

      v4 += 21;
      v5 -= 168;
    }
    while (v5);
  }
}

void re::ResourceSharingManager::sendReferenceObject(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  id v5;
  _QWORD block[4];
  id v7;
  uint64_t v8;

  v3 = a2;
  dispatch_assert_queue_not_V2(*(dispatch_queue_t *)(a1 + 40));
  v4 = *(NSObject **)(a1 + 40);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re22ResourceSharingManager19sendReferenceObjectEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
  block[3] = &unk_24ED30188;
  v7 = v3;
  v8 = a1;
  v5 = v3;
  dispatch_sync(v4, block);

}

void ___ZN2re22ResourceSharingManager19sendReferenceObjectEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  id *v4;
  uint64_t v5;
  void *v6;
  REXPCObject *v7;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(v1 + 80);
  if (v2)
  {
    v4 = *(id **)(v1 + 96);
    v5 = 168 * v2;
    do
    {
      re::ResourceFetchManager::Connection::remoteObjectProxy(v4);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      v7 = -[REXPCObject initWithObject:]([REXPCObject alloc], "initWithObject:", *(_QWORD *)(a1 + 32));
      objc_msgSend(v6, "receiveReferenceObject:", v7);

      v4 += 21;
      v5 -= 168;
    }
    while (v5);
  }
}

uint64_t re::ResourceSharingManager::decodeShaderGraph@<X0>(dispatch_queue_t *this@<X0>, const re::Data *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  uint64_t v7;
  re *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  id *v12;
  uint64_t v13;
  void *v14;
  char v15;
  id v16;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[6];
  _QWORD v21[5];
  id v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t (*v26)(uint64_t, uint64_t);
  void (*v27)(uint64_t);
  uint64_t v28;
  id v29;
  _QWORD block[6];
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t (*v35)(uint64_t);
  const char *v36;
  _QWORD v37[3];
  int v38;
  uint64_t v39;
  __int128 buf;
  uint64_t v41;
  uint64_t (*v42)(uint64_t, uint64_t);
  void (*v43)(uint64_t);
  uint64_t v44;
  id v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_not_V2(this[5]);
  v31 = 0;
  v32 = &v31;
  v33 = 0x5812000000;
  v34 = __Block_byref_object_copy__59;
  v35 = __Block_byref_object_dispose__60;
  v39 = 0;
  v36 = "";
  memset(v37, 0, sizeof(v37));
  v38 = 0;
  v6 = this[5];
  v7 = MEMORY[0x24BDAC760];
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re22ResourceSharingManager17decodeShaderGraphERKNS_4DataE_block_invoke;
  block[3] = &unk_24ED30160;
  block[4] = &v31;
  block[5] = this;
  dispatch_sync(v6, block);
  if ((unint64_t)v32[8] >= 2)
  {
    v9 = *re::resourceSharingLogObjects(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v18 = v32[8];
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v18;
      _os_log_error_impl(&dword_224FE9000, v9, OS_LOG_TYPE_ERROR, "Expected num connections <= 1, have %zu", (uint8_t *)&buf, 0xCu);
    }
  }
  *(_QWORD *)&buf = 0;
  *((_QWORD *)&buf + 1) = &buf;
  v41 = 0x3812000000;
  v42 = __Block_byref_object_copy__62;
  v43 = __Block_byref_object_dispose__63;
  v44 = 0;
  objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("No XPC connection"), 0, 0);
  v45 = (id)objc_claimAutoreleasedReturnValue();

  v23 = 0;
  v24 = &v23;
  v25 = 0x3812000000;
  v26 = __Block_byref_object_copy__66;
  v27 = __Block_byref_object_dispose__67;
  v28 = 0;
  v29 = 0;
  v10 = v32[8];
  if (!v10)
    goto LABEL_9;
  v19 = a3;
  v11 = 8 * v10;
  v12 = (id *)v32[10];
  do
  {
    v21[0] = v7;
    v21[1] = 3221225472;
    v21[2] = ___ZN2re22ResourceSharingManager17decodeShaderGraphERKNS_4DataE_block_invoke_68;
    v21[3] = &unk_24ED301B0;
    v21[4] = &buf;
    re::xpc::Connection::syncRemoteObjectProxy(v12, (uint64_t)v21, &v22);
    v13 = *(_QWORD *)a2;
    v20[0] = v7;
    v20[1] = 3221225472;
    v20[2] = ___ZN2re22ResourceSharingManager17decodeShaderGraphERKNS_4DataE_block_invoke_2;
    v20[3] = &unk_24ED301D8;
    v20[4] = &buf;
    v20[5] = &v23;
    objc_msgSend(v22, "decodeShaderGraph:withReply:", v13, v20);

    ++v12;
    v11 -= 8;
  }
  while (v11);
  v14 = (void *)v24[6];
  a3 = v19;
  if (v14)
  {
    v15 = 1;
  }
  else
  {
LABEL_9:
    v15 = 0;
    v14 = *(void **)(*((_QWORD *)&buf + 1) + 48);
  }
  v16 = v14;
  *(_BYTE *)a3 = v15;
  *(_QWORD *)(a3 + 8) = v16;
  _Block_object_dispose(&v23, 8);

  _Block_object_dispose(&buf, 8);
  _Block_object_dispose(&v31, 8);
  return re::DynamicArray<re::ObjCObject>::deinit((uint64_t)v37);
}

uint64_t __Block_byref_object_copy__59(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)(result + 80) = 0;
  *(_QWORD *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = 0;
  *(_QWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 72) = 0;
  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  v3 = *(_QWORD *)(result + 64);
  *(_QWORD *)(result + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v3;
  v4 = *(_QWORD *)(result + 80);
  *(_QWORD *)(result + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v4;
  ++*(_DWORD *)(a2 + 72);
  ++*(_DWORD *)(result + 72);
  return result;
}

uint64_t __Block_byref_object_dispose__60(uint64_t a1)
{
  return re::DynamicArray<re::ObjCObject>::deinit(a1 + 48);
}

uint64_t __Block_byref_object_copy__62(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__63(uint64_t a1)
{

}

uint64_t __Block_byref_object_copy__66(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__67(uint64_t a1)
{

}

void ___ZN2re22ResourceSharingManager17decodeShaderGraphERKNS_4DataE_block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v5;
  void **v6;
  void *v7;
  id v8;

  v8 = a2;
  v5 = a3;
  if (v5)
  {
    v6 = (void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48);
    v7 = v5;
LABEL_5:
    re::ObjCObject::operator=(v6, v7);
    goto LABEL_6;
  }
  if (v8)
  {
    v6 = (void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48);
    v7 = v8;
    goto LABEL_5;
  }
LABEL_6:

}

void re::ResourceSharingManager::payloadDidChange(dispatch_queue_t *this, const re::AssetHandle *a2)
{
  NSObject *v4;
  _QWORD v5[6];

  dispatch_assert_queue_V2(this[4]);
  v4 = this[5];
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 3221225472;
  v5[2] = ___ZN2re22ResourceSharingManager16payloadDidChangeERKNS_11AssetHandleE_block_invoke;
  v5[3] = &__block_descriptor_48_e5_v8__0l;
  v5[4] = this;
  v5[5] = a2;
  dispatch_sync(v4, v5);
}

void ___ZN2re22ResourceSharingManager16payloadDidChangeERKNS_11AssetHandleE_block_invoke(uint64_t a1)
{
  const re::AssetHandle *v2;
  void *v3;
  re *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  NSObject *v18;
  __int128 v19;
  uint64_t v20;
  id *v21;
  id *v22;
  id v23;
  char v24;
  re *v25;
  re *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  id v31;
  NSObject *v32;
  char *v33;
  void *v34;
  int v35;
  void *v36;
  void *v37;
  id v38;
  id v39;
  id v40;
  void *v41;
  re::AssetHandle *v42;
  NSObject *v43;
  _QWORD *v44;
  char *v45;
  uint64_t v46;
  __int128 v47;
  id *v48;
  char v49[8];
  id v50;
  char v51[8];
  re *v52;
  uint8_t buf[4];
  _BYTE v54[18];
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v2 = *(const re::AssetHandle **)(a1 + 32);
  v3 = re::AssetHandle::assetInfo(*(re::AssetHandle **)(a1 + 40));
  v4 = (re *)re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)v3 + 96);
  v5 = *((_QWORD *)v2 + 10);
  if (v5)
  {
    v6 = 0;
    v7 = *((_QWORD *)v2 + 12);
    v8 = v7 + 168 * v5;
    do
    {
      v9 = *(unsigned int *)(v7 + 56);
      if ((_DWORD)v9)
      {
        v10 = 0;
        v11 = (int *)(*(_QWORD *)(v7 + 40) + 8);
        while (1)
        {
          v12 = *v11;
          v11 += 6;
          if (v12 < 0)
            break;
          if (v9 == ++v10)
          {
            LODWORD(v10) = *(_DWORD *)(v7 + 56);
            break;
          }
        }
      }
      else
      {
        LODWORD(v10) = 0;
      }
      if ((_DWORD)v9 != (_DWORD)v10)
      {
        v13 = v10;
        v14 = *(_QWORD *)(v7 + 40);
        while (1)
        {
          v15 = *(_QWORD *)(v14 + 24 * v13 + 16);
          if (*(re **)(v15 + 56) == v4)
            break;
          if (v9 <= (int)v10 + 1)
            v16 = v10 + 1;
          else
            v16 = *(_DWORD *)(v7 + 56);
          while (1)
          {
            v13 = (v10 + 1);
            if (v16 - 1 == (_DWORD)v10)
              break;
            LODWORD(v10) = v10 + 1;
            v17 = v13;
            if ((*(_DWORD *)(v14 + 24 * v13 + 8) & 0x80000000) != 0)
              goto LABEL_19;
          }
          v17 = v16;
LABEL_19:
          LODWORD(v10) = v17;
          if ((_DWORD)v9 == v17)
            goto LABEL_22;
        }
        v6 = (_QWORD *)v15;
      }
LABEL_22:
      v7 += 168;
    }
    while (v7 != v8);
    if (v6 && v6[11])
    {
      v18 = *re::resourceSharingLogObjects(v4);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        v42 = *(re::AssetHandle **)(a1 + 40);
        v43 = v18;
        v44 = re::AssetHandle::assetInfo(v42);
        if ((v44[17] & 1) != 0)
          v45 = (char *)v44[18];
        else
          v45 = (char *)v44 + 137;
        v46 = v6[11];
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)v54 = v45;
        *(_WORD *)&v54[8] = 2048;
        *(_QWORD *)&v54[10] = v46;
        _os_log_debug_impl(&dword_224FE9000, v43, OS_LOG_TYPE_DEBUG, "Sending updated resource payload for '%s' to %zu subscribed servers", buf, 0x16u);

      }
      re::ResourceSharingManager::makeFetchRequestResult((re::ResourceSharingManager *)v49, v2, *(const re::AssetHandle **)(a1 + 40));
      v20 = v6[11];
      if (v20)
      {
        v21 = (id *)v6[13];
        v22 = &v21[v20];
        *(_QWORD *)&v19 = 138412290;
        v47 = v19;
        v48 = v22;
        do
        {
          v23 = *v21;
          v24 = v49[0];
          v25 = (re *)v50;
          v26 = v25;
          v27 = *((_QWORD *)v2 + 10);
          if (v27)
          {
            v28 = *((_QWORD *)v2 + 12);
            v29 = 168 * v27;
            while (*(id *)(v28 + 8) != v23)
            {
              v28 += 168;
              v29 -= 168;
              if (!v29)
                goto LABEL_32;
            }
            if ((v6[4] & 1) != 0)
              v33 = (char *)v6[5];
            else
              v33 = (char *)v6 + 33;
            objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v33, v47);
            v34 = (void *)objc_claimAutoreleasedReturnValue();
            v51[0] = v24;
            v52 = v26;
            re::ResourceSharingManager::validateResult((uint64_t)buf, (uint64_t)v2, v28, v6, (uint64_t)v51);

            v35 = buf[0];
            v36 = *(void **)&v54[4];
            if (buf[0])
              v37 = *(void **)&v54[4];
            else
              v37 = 0;
            v38 = objc_retainAutorelease(v37);
            if (v35)
              v39 = 0;
            else
              v39 = v36;
            v40 = objc_retainAutorelease(v39);

            re::ResourceFetchManager::Connection::remoteObjectProxy((id *)v28);
            v41 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v41, "resourceAtAssetPath:payloadDidUpdate:error:", v34, v38, v40);

            v22 = v48;
          }
          else
          {
LABEL_32:
            v30 = *re::resourceSharingLogObjects(v25);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
            {
              v31 = v23;
              *(_DWORD *)buf = v47;
              *(_QWORD *)v54 = v31;
              v32 = v30;
              _os_log_fault_impl(&dword_224FE9000, v32, OS_LOG_TYPE_FAULT, "No resource connection exists for server %@", buf, 0xCu);

            }
          }

          ++v21;
        }
        while (v21 != v22);
      }

    }
  }
}

uint64_t re::ResourceSharingManager::makeFetchRequestResult(re::ResourceSharingManager *this, const re::AssetHandle *a2, const re::AssetHandle *a3)
{
  uint64_t v6;
  _anonymous_namespace_ *v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  re *v11;
  NSObject *v12;
  id v13;
  re *v14;
  NSObject *v15;
  id v16;
  uint64_t result;
  NSObject *v18;
  _QWORD *v19;
  char *v20;
  NSObject *v21;
  _QWORD *v22;
  char *v23;
  id v24;
  id v25;
  _BYTE v26[24];
  id v27;
  uint64_t v28;
  char v29;
  _BYTE v30[23];
  uint8_t buf[40];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v6 = *((_QWORD *)a2 + 6);
  memset(buf, 0, 32);
  v7 = (_anonymous_namespace_ *)snprintf_l((char *)buf, 0x20uLL, 0, "%llu", v6);
  if (((_DWORD)v7 - 32) <= 0xFFFFFFE0)
  {
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) ", "0 < ret && ret < sizeof(str)", "peerIDToString", 202);
    _os_crash();
    __break(1u);
  }
  v9 = *((_QWORD *)a2 + 3);
  re::AssetHandle::AssetHandle((re::AssetHandle *)v26, a3);
  if ((v29 & 1) != 0)
    v10 = *(_BYTE **)&v30[7];
  else
    v10 = v30;
  (*(void (**)(id *__return_ptr, uint64_t, _BYTE *, _BYTE *))(*(_QWORD *)v9 + 224))(&v27, v9, v26, v10);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v26);
  if (v27)
  {
    v12 = *re::resourceSharingLogObjects(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      v18 = v12;
      v19 = re::AssetHandle::assetInfo(a3);
      if ((v19[17] & 1) != 0)
        v20 = (char *)v19[18];
      else
        v20 = (char *)v19 + 137;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v20;
      _os_log_debug_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEBUG, "Responding to resource fetch request for '%s'", buf, 0xCu);

    }
    v13 = v27;
    *(_BYTE *)this = 1;
    *((_QWORD *)this + 1) = v13;
  }
  else
  {
    re::makeResourceSharingError((__CFString *)1, 0, &v25);
    v15 = *re::resourceSharingLogObjects(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v21 = v15;
      v22 = re::AssetHandle::assetInfo(a3);
      if ((v22[17] & 1) != 0)
        v23 = (char *)v22[18];
      else
        v23 = (char *)v22 + 137;
      v24 = v25;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v23;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v24;
      _os_log_error_impl(&dword_224FE9000, v21, OS_LOG_TYPE_ERROR, "Failed to handle resource fetch request for '%s': %@", buf, 0x16u);

    }
    v16 = v25;
    *(_BYTE *)this = 0;
    *((_QWORD *)this + 1) = v16;

  }
  result = v28;
  if (v28)
  {
    if ((v29 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v28 + 40))();
  }
  return result;
}

void `non-virtual thunk to're::ResourceSharingManager::payloadDidChange(dispatch_queue_t *this, const re::AssetHandle *a2)
{
  re::ResourceSharingManager::payloadDidChange(this - 1, a2);
}

void re::ResourceSharingManager::pushLoadAsset(re::ResourceSharingManager *this, const re::AssetHandle *a2, char a3)
{
  NSObject *v3;
  _QWORD block[6];
  char v5;

  v3 = *((_QWORD *)this + 5);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re22ResourceSharingManager13pushLoadAssetERKNS_11AssetHandleEb_block_invoke;
  block[3] = &__block_descriptor_49_e5_v8__0l;
  block[4] = this;
  block[5] = a2;
  v5 = a3;
  dispatch_sync(v3, block);
}

void ___ZN2re22ResourceSharingManager13pushLoadAssetERKNS_11AssetHandleEb_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  id *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  uint64_t v10;
  void *v11;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 80);
  if (v2)
  {
    v4 = *(id **)(v1 + 96);
    v5 = 168 * v2;
    do
    {
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      if (v6)
        v7 = *(_QWORD **)(v6 + 264);
      else
        v7 = 0;
      re::ResourceFetchManager::Connection::remoteObjectProxy(v4);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      v9 = re::AssetHandle::assetInfo(*(re::AssetHandle **)(a1 + 40));
      if (v9[10] == -1)
        v10 = 0;
      else
        v10 = v9[10];
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", *v7);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "pushLoadResourceWithAssetId:assetType:isPriorityAsset:", v10, v11, *(unsigned __int8 *)(a1 + 48));

      v4 += 21;
      v5 -= 168;
    }
    while (v5);
  }
}

void `non-virtual thunk to're::ResourceSharingManager::pushLoadAsset(re::ResourceSharingManager *this, const re::AssetHandle *a2, char a3)
{
  re::ResourceSharingManager::pushLoadAsset((re::ResourceSharingManager *)((char *)this - 8), a2, a3);
}

void re::ResourceSharingManager::releaseAsset(re::ResourceSharingManager *this, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *((_QWORD *)this + 5);
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = ___ZN2re22ResourceSharingManager12releaseAssetEy_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = this;
  v3[5] = a2;
  dispatch_sync(v2, v3);
}

void ___ZN2re22ResourceSharingManager12releaseAssetEy_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  id *v4;
  uint64_t v5;
  void *v6;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 80);
  if (v2)
  {
    v4 = *(id **)(v1 + 96);
    v5 = 168 * v2;
    do
    {
      re::ResourceFetchManager::Connection::remoteObjectProxy(v4);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "releaseResourceWithAssetId:", *(_QWORD *)(a1 + 40));

      v4 += 21;
      v5 -= 168;
    }
    while (v5);
  }
}

void `non-virtual thunk to're::ResourceSharingManager::releaseAsset(re::ResourceSharingManager *this, uint64_t a2)
{
  re::ResourceSharingManager::releaseAsset((re::ResourceSharingManager *)((char *)this - 8), a2);
}

unint64_t re::ResourceSharingManager::drainResourceRequestQueue(re::ResourceSharingManager *this, dispatch_time_t a2)
{
  dispatch_time_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;

  v3 = *((_QWORD *)this + 7);
  v4 = *(_QWORD *)(v3 + 48);
  re::internal::ResourceRequestQueue::flushSync(v3, a2);
  v5 = *(_QWORD *)(*((_QWORD *)this + 7) + 48);
  v6 = v4 >= v5;
  v7 = v4 - v5;
  if (v6)
    return v7;
  else
    return 0;
}

unint64_t `non-virtual thunk to're::ResourceSharingManager::drainResourceRequestQueue(re::ResourceSharingManager *this, dispatch_time_t a2)
{
  dispatch_time_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;

  v3 = *((_QWORD *)this + 6);
  v4 = *(_QWORD *)(v3 + 48);
  re::internal::ResourceRequestQueue::flushSync(v3, a2);
  v5 = *(_QWORD *)(*((_QWORD *)this + 6) + 48);
  v6 = v4 >= v5;
  v7 = v4 - v5;
  if (v6)
    return v7;
  else
    return 0;
}

void re::DynamicArray<REResourceSharingClientObject * {__strong}>::remove(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  v3 = *(_QWORD **)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 16);
  v5 = &v3[v4];
  v6 = v3;
  if (v4)
  {
    v7 = 8 * v4;
    v6 = *(_QWORD **)(a1 + 32);
    while (*v6 != a2)
    {
      ++v6;
      v7 -= 8;
      if (!v7)
      {
        v6 = &v3[v4];
        break;
      }
    }
  }
  v8 = v6 - v3;
  if (v8 != v4)
  {
    if (v4 <= v8)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v4 - 1 > v8)
    {
      v9 = *(v5 - 1);
      *(v5 - 1) = 0;
      v10 = *(_QWORD *)(a1 + 32);
      v11 = *(void **)(v10 + 8 * v8);
      *(_QWORD *)(v10 + 8 * v8) = v9;

      v4 = *(_QWORD *)(a1 + 16);
      v3 = *(_QWORD **)(a1 + 32);
    }

    --*(_QWORD *)(a1 + 16);
    ++*(_DWORD *)(a1 + 24);
  }
}

uint64_t ___ZN2re22ResourceSharingManager19enqueueFetchRequestENS0_12FetchRequestE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  uint64_t v5;
  NSObject *v6;
  re *v7;
  const char **v8;
  NSObject *v9;
  _QWORD *v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  re *v14;
  unsigned int v15;
  void *v16;
  NSObject *v17;
  id v18;
  void *v19;
  id v20;
  unsigned int v21;
  _BOOL4 v22;
  NSObject *v23;
  _BOOL4 v24;
  NSObject *v25;
  void (*v26)(uint64_t);
  const char *v27;
  re *v28;
  unsigned int v29;
  NSObject *v30;
  void *v31;
  void *v32;
  NSObject *v33;
  uint64_t result;
  NSObject *v35;
  void (*v36)(uint64_t);
  void (*v37)(uint64_t);
  int v38;
  uint64_t v39;
  char v40;
  _QWORD v41[4];
  uint64_t v42;
  id v43;
  void *aBlock;
  id v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t (*v49)(uint64_t, uint64_t);
  void (*v50)(uint64_t);
  id v51;
  _BYTE v52[8];
  id v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD block[6];
  int v57;
  _QWORD v58[4];
  _QWORD v59[5];
  id v60;
  id v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  __int128 buf;
  void (*v67)(uint64_t);
  void *v68;
  uint64_t *v69;
  __int128 *v70;
  _QWORD v71[2];
  _DWORD v72[4];
  __int128 v73;
  __int128 v74;
  _QWORD v75[5];
  id v76;
  id v77;
  __int128 v78;
  uint64_t v79;
  uint64_t (*v80)(uint64_t, uint64_t);
  void (*v81)(uint64_t);
  id v82;
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v38 = *(_DWORD *)(a1 + 40);
  re::DynamicString::DynamicString((re::DynamicString *)&v39, (const re::DynamicString *)(a1 + 48));
  re::DynamicString::DynamicString((re::DynamicString *)v41, (const re::DynamicString *)(a1 + 80));
  v3 = *(void **)(a1 + 120);
  v42 = *(_QWORD *)(a1 + 112);
  v43 = v3;
  aBlock = _Block_copy(*(const void **)(a1 + 128));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  v62 = 0;
  v63 = &v62;
  v64 = 0x2020000000;
  v65 = 0;
  v4 = *(void **)(v2 + 40);
  v5 = MEMORY[0x24BDAC760];
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3321888768;
  block[2] = ___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke;
  block[3] = &unk_24ED302D0;
  v57 = v38;
  block[5] = v2;
  v6 = v4;
  re::DynamicString::DynamicString((re::DynamicString *)v58, (const re::DynamicString *)&v39);
  re::DynamicString::DynamicString((re::DynamicString *)v59, (const re::DynamicString *)v41);
  v59[4] = v42;
  v60 = v43;
  v61 = _Block_copy(aBlock);
  block[4] = &v62;
  dispatch_sync(v6, block);

  if (v63[3])
  {
    (***(void (****)(uint64_t *__return_ptr, _QWORD, int *))(v2 + 24))(&v54, *(_QWORD *)(v2 + 24), &v38);
    if (v55)
      v8 = *(const char ***)(v55 + 264);
    else
      v8 = 0;
    v10 = re::AssetHandle::assetInfo((re::AssetHandle *)&v54);
    if (v10[10] == -1)
      LODWORD(v12) = 0;
    else
      v12 = v10[10];
    if (v8)
      v13 = *v8;
    else
      v13 = 0;
    v14 = (re *)re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x80D, v12, v13, v11);
    if (v55)
    {
      v15 = atomic_load((unsigned int *)(v55 + 704));
      if (v15 == 2)
      {
        re::ResourceSharingManager::makeFetchRequestResult((re::ResourceSharingManager *)v52, (const re::AssetHandle *)v2, (const re::AssetHandle *)&v54);
        *(_QWORD *)&v78 = 0;
        *((_QWORD *)&v78 + 1) = &v78;
        v79 = 0x3032000000;
        v80 = __Block_byref_object_copy__87;
        v81 = __Block_byref_object_dispose__88;
        v82 = 0;
        v46 = 0;
        v47 = &v46;
        v48 = 0x3032000000;
        v49 = __Block_byref_object_copy__87;
        v50 = __Block_byref_object_dispose__88;
        v51 = 0;
        v16 = *(void **)(v2 + 40);
        *(_QWORD *)&buf = v5;
        *((_QWORD *)&buf + 1) = 3321888768;
        v67 = ___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke_89;
        v68 = &unk_24ED30308;
        v71[1] = v2;
        v69 = &v62;
        v17 = v16;
        re::AssetHandle::AssetHandle((re::AssetHandle *)v72, (const re::AssetHandle *)&v54);
        BYTE8(v73) = v52[0];
        v18 = v53;
        *(_QWORD *)&v74 = v18;
        v70 = &v78;
        v71[0] = &v46;
        dispatch_sync(v17, &buf);

        v19 = aBlock;
        v20 = *(id *)(*((_QWORD *)&v78 + 1) + 40);
        v45 = v20;

        re::AssetHandle::~AssetHandle((re::AssetHandle *)v72);
        _Block_object_dispose(&v46, 8);

        _Block_object_dispose(&v78, 8);
LABEL_38:
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v54);
        goto LABEL_39;
      }
      v21 = atomic_load((unsigned int *)(v55 + 704));
      v22 = v21 == 3;
    }
    else
    {
      v22 = 0;
    }
    v23 = *re::resourceSharingLogObjects(v14);
    v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG);
    if (v22)
    {
      if (!v24)
      {
LABEL_28:
        v31 = aBlock;
        re::ResourceSharingManager::makeFetchRequestError((re::ResourceSharingManager *)&buf);

        goto LABEL_38;
      }
      v25 = v23;
      v67 = 0;
      v68 = 0;
      buf = (unint64_t)v39;
      re::DynamicString::setCapacity(&buf, 0);
      re::AssetPath::fullAssetPath((re::DynamicString *)&v38, (re::DynamicString *)&buf);
      if ((BYTE8(buf) & 1) != 0)
        v26 = v67;
      else
        v26 = (void (*)(uint64_t))((char *)&buf + 9);
      LODWORD(v78) = 136315138;
      *(_QWORD *)((char *)&v78 + 4) = v26;
      v27 = "Handled resource fetch request for '%s': asset loading has already failed";
    }
    else
    {
      if (v24)
      {
        v35 = v23;
        v67 = 0;
        v68 = 0;
        buf = (unint64_t)v39;
        re::DynamicString::setCapacity(&buf, 0);
        re::AssetPath::fullAssetPath((re::DynamicString *)&v38, (re::DynamicString *)&buf);
        v36 = (BYTE8(buf) & 1) != 0 ? v67 : (void (*)(uint64_t))((char *)&buf + 9);
        LODWORD(v78) = 136315138;
        *(_QWORD *)((char *)&v78 + 4) = v36;
        _os_log_debug_impl(&dword_224FE9000, v35, OS_LOG_TYPE_DEBUG, "Requesting async load of '%s' due to resource fetch request", (uint8_t *)&v78, 0xCu);

        if ((_QWORD)buf)
        {
          if ((BYTE8(buf) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)buf + 40))();
        }
      }
      re::AssetHandle::loadAsync((re::AssetHandle *)&v54);
      if (!v55 || (v29 = atomic_load((unsigned int *)(v55 + 704)), v29 != 3))
      {
        v32 = *(void **)(v2 + 40);
        *(_QWORD *)&buf = v5;
        *((_QWORD *)&buf + 1) = 3321888768;
        v67 = ___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke_90;
        v68 = &unk_24ED30340;
        v69 = &v62;
        v70 = (__int128 *)v2;
        v33 = v32;
        re::AssetHandle::AssetHandle((re::AssetHandle *)v71, (const re::AssetHandle *)&v54);
        v72[2] = v38;
        re::DynamicString::DynamicString((re::DynamicString *)&v73, (const re::DynamicString *)&v39);
        re::DynamicString::DynamicString((re::DynamicString *)v75, (const re::DynamicString *)v41);
        v75[4] = v42;
        v76 = v43;
        v77 = _Block_copy(aBlock);
        dispatch_sync(v33, &buf);

        if (v75[0])
        {
          if ((v75[1] & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v75[0] + 40))();
          memset(v75, 0, 32);
        }
        if ((_QWORD)v73)
        {
          if ((BYTE8(v73) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v73 + 40))();
          v73 = 0u;
          v74 = 0u;
        }
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v71);
        goto LABEL_38;
      }
      v30 = *re::resourceSharingLogObjects(v28);
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        goto LABEL_28;
      v25 = v30;
      v67 = 0;
      v68 = 0;
      buf = (unint64_t)v39;
      re::DynamicString::setCapacity(&buf, 0);
      re::AssetPath::fullAssetPath((re::DynamicString *)&v38, (re::DynamicString *)&buf);
      if ((BYTE8(buf) & 1) != 0)
        v37 = v67;
      else
        v37 = (void (*)(uint64_t))((char *)&buf + 9);
      LODWORD(v78) = 136315138;
      *(_QWORD *)((char *)&v78 + 4) = v37;
      v27 = "Handled resource fetch request for '%s': asset loading failed to begin";
    }
    _os_log_debug_impl(&dword_224FE9000, v25, OS_LOG_TYPE_DEBUG, v27, (uint8_t *)&v78, 0xCu);

    if ((_QWORD)buf && (BYTE8(buf) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)buf + 40))();
    goto LABEL_28;
  }
  v9 = *re::resourceSharingLogObjects(v7);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
  {
    LODWORD(buf) = 138412290;
    *(_QWORD *)((char *)&buf + 4) = v43;
    _os_log_fault_impl(&dword_224FE9000, v9, OS_LOG_TYPE_FAULT, "No resource connection exists for server %@", (uint8_t *)&buf, 0xCu);
  }
LABEL_39:

  if (v59[0])
  {
    if ((v59[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v59[0] + 40))();
    memset(v59, 0, 32);
  }
  if (v58[0])
  {
    if ((v58[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v58[0] + 40))();
    memset(v58, 0, sizeof(v58));
  }
  _Block_object_dispose(&v62, 8);

  if (v41[0])
  {
    if ((v41[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v41[0] + 40))();
    memset(v41, 0, sizeof(v41));
  }
  result = v39;
  if (v39)
  {
    if ((v40 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v39 + 40))();
  }
  return result;
}

void *__copy_helper_block_a8_40c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *result;

  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 48), (const re::DynamicString *)(a2 + 48));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 80), (const re::DynamicString *)(a2 + 80));
  v4 = *(void **)(a2 + 120);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 120) = v4;
  result = _Block_copy(*(const void **)(a2 + 128));
  *(_QWORD *)(a1 + 128) = result;
  return result;
}

double __destroy_helper_block_a8_40c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(uint64_t a1)
{
  double result;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 88) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
    result = 0.0;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
  }
  v4 = *(_QWORD *)(a1 + 48);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 56) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 64));
    result = 0.0;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
  }
  return result;
}

uint64_t ___ZN2re22ResourceSharingManager25enqueueUnsubscribeRequestENS0_18UnsubscribeRequestE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  const re::DynamicString *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  _QWORD v10[5];
  uint64_t v11;
  char v12;
  uint64_t v13;
  id v14;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(void **)(v2 + 40);
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 3321888768;
  v10[2] = ___ZN2re22ResourceSharingManager25enqueueUnsubscribeRequestENS0_18UnsubscribeRequestE_block_invoke_2;
  v10[3] = &__block_descriptor_80_a8_40c54_ZTSKN2re22ResourceSharingManager18UnsubscribeRequestE_e5_v8__0l;
  v10[4] = v2;
  v4 = (const re::DynamicString *)(a1 + 40);
  v5 = v3;
  re::DynamicString::DynamicString((re::DynamicString *)&v11, v4);
  v14 = *(id *)(a1 + 72);
  dispatch_sync(v5, v10);

  result = v11;
  if (v11)
  {
    if ((v12 & 1) != 0)
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 40))(v11, v13, v6, v7, v8);
  }
  return result;
}

uint64_t ___ZN2re22ResourceSharingManager25enqueueUnsubscribeRequestENS0_18UnsubscribeRequestE_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  _BOOL8 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  NSObject *v22;
  uint64_t result;
  unint64_t v24;
  id v25;
  re *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  int v34;
  _BYTE *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  int v47;
  NSObject *v48;
  _BYTE *v49;
  uint64_t v50;
  char v51;
  _BYTE v52[7];
  _BYTE *v53;
  id v54;
  uint8_t buf[4];
  id v56;
  __int16 v57;
  _BYTE *v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  re::DynamicString::DynamicString((re::DynamicString *)&v50, (const re::DynamicString *)(a1 + 40));
  v54 = *(id *)(a1 + 72);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 40));
  v4 = *(_QWORD *)(v2 + 80);
  if (v4)
  {
    v5 = 0;
    v6 = *(_QWORD *)(v2 + 96);
    v7 = 168 * v4;
    while (*(id *)(v6 + v5 + 8) != v54)
    {
      v5 += 168;
      if (v7 == v5)
        goto LABEL_5;
    }
    v9 = *(unsigned int *)(v6 + v5 + 56);
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = (int *)(*(_QWORD *)(v6 + v5 + 40) + 8);
      while (1)
      {
        v12 = *v11;
        v11 += 6;
        if (v12 < 0)
          break;
        if (v9 == ++v10)
        {
          LODWORD(v10) = *(_DWORD *)(v6 + v5 + 56);
          break;
        }
      }
    }
    else
    {
      LODWORD(v10) = 0;
    }
    if ((_DWORD)v9 == (_DWORD)v10)
    {
LABEL_24:
      v22 = *re::resourceSharingLogObjects((re *)v3);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        if ((v51 & 1) != 0)
          v35 = v53;
        else
          v35 = v52;
        *(_DWORD *)buf = 138412546;
        v56 = v54;
        v57 = 2080;
        v58 = v35;
        _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, "Resource connection %@ ignored an unsubscribe request for '%s': no subscription exists", buf, 0x16u);
      }
    }
    else
    {
      v13 = v10;
      v14 = v6 + v5;
      v15 = *(_QWORD *)(v6 + v5 + 40);
      while (1)
      {
        v16 = v15 + 24 * v13;
        v19 = *(_QWORD *)(v16 + 16);
        v17 = (unint64_t *)(v16 + 16);
        v18 = v19;
        v3 = re::DynamicString::operator==(v19 + 24, (uint64_t)&v50);
        if (v3)
          break;
        if (v9 <= (int)v10 + 1)
          v20 = v10 + 1;
        else
          v20 = v9;
        while (1)
        {
          v13 = (v10 + 1);
          if (v20 - 1 == (_DWORD)v10)
            break;
          LODWORD(v10) = v10 + 1;
          v21 = v13;
          if ((*(_DWORD *)(v15 + 24 * v13 + 8) & 0x80000000) != 0)
            goto LABEL_23;
        }
        v21 = v20;
LABEL_23:
        LODWORD(v10) = v21;
        if ((_DWORD)v9 == v21)
          goto LABEL_24;
      }
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(v6 + v5 + 72, *(_QWORD *)(v18 + 64));
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(v6 + v5 + 120, *(_QWORD *)(*v17 + 64));
      v24 = *v17;
      if (*v17)
        v25 = (id)(v24 + 8);
      re::DynamicArray<REResourceSharingClientObject * {__strong}>::remove(v24 + 72, (uint64_t)v54);
      v27 = *(unsigned int *)(v6 + v5 + 48);
      if ((_DWORD)v27)
      {
        v28 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v24 ^ (v24 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v24 ^ (v24 >> 30))) >> 27));
        v29 = (v28 ^ (v28 >> 31)) % v27;
        v30 = *(_QWORD *)(v6 + v5 + 32);
        v31 = *(unsigned int *)(v30 + 4 * v29);
        if ((_DWORD)v31 != 0x7FFFFFFF)
        {
          v32 = *(_QWORD *)(v14 + 40);
          if (*(_QWORD *)(v32 + 24 * v31 + 16) == v24)
          {
            *(_DWORD *)(v30 + 4 * v29) = *(_DWORD *)(v32 + 24 * v31 + 8) & 0x7FFFFFFF;
LABEL_42:
            v36 = *(_QWORD *)(v14 + 40);
            v37 = v36 + 24 * v31;
            v40 = *(_DWORD *)(v37 + 8);
            v38 = (int *)(v37 + 8);
            v39 = v40;
            if (v40 < 0)
            {
              *v38 = v39 & 0x7FFFFFFF;
              v41 = v36 + 24 * v31;
              v44 = *(_QWORD *)(v41 + 16);
              v43 = (_QWORD *)(v41 + 16);
              v42 = v44;
              if (v44)
              {

                *v43 = 0;
              }
            }
            v45 = (_DWORD *)(v6 + v5);
            v46 = *(_QWORD *)(v14 + 40) + 24 * v31;
            *(_DWORD *)(v46 + 8) = *(_DWORD *)(v46 + 8) & 0x80000000 | *(_DWORD *)(v6 + v5 + 60);
            v45[13] = *(_DWORD *)(v6 + v5 + 52) - 1;
            v47 = *(_DWORD *)(v6 + v5 + 64) + 1;
            v45[15] = v31;
            v45[16] = v47;
          }
          else
          {
            while (1)
            {
              v33 = v31;
              v34 = *(_DWORD *)(v32 + 24 * v31 + 8);
              v31 = v34 & 0x7FFFFFFF;
              if ((v34 & 0x7FFFFFFF) == 0x7FFFFFFF)
                break;
              if (*(_QWORD *)(v32 + 24 * v31 + 16) == v24)
              {
                *(_DWORD *)(v32 + 24 * v33 + 8) = *(_DWORD *)(v32 + 24 * v33 + 8) & 0x80000000 | *(_DWORD *)(v32 + 24 * v31 + 8) & 0x7FFFFFFF;
                goto LABEL_42;
              }
            }
          }
        }
      }
      v48 = *re::resourceSharingLogObjects(v26);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        if ((v51 & 1) != 0)
          v49 = v53;
        else
          v49 = v52;
        *(_DWORD *)buf = 138412546;
        v56 = v54;
        v57 = 2080;
        v58 = v49;
        _os_log_debug_impl(&dword_224FE9000, v48, OS_LOG_TYPE_DEBUG, "Resource connection %@ unsubscribed from '%s'", buf, 0x16u);
        if (!v24)
          goto LABEL_25;
      }
      else if (!v24)
      {
        goto LABEL_25;
      }

    }
  }
  else
  {
LABEL_5:
    v8 = *re::resourceSharingLogObjects((re *)v3);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138412290;
      v56 = v54;
      _os_log_fault_impl(&dword_224FE9000, v8, OS_LOG_TYPE_FAULT, "No resource connection exists for server %@", buf, 0xCu);
    }
  }
LABEL_25:

  result = v50;
  if (v50)
  {
    if ((v51 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v50 + 40))();
  }
  return result;
}

id __copy_helper_block_a8_40c54_ZTSKN2re22ResourceSharingManager18UnsubscribeRequestE(uint64_t a1, uint64_t a2)
{
  id result;

  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  result = *(id *)(a2 + 72);
  *(_QWORD *)(a1 + 72) = result;
  return result;
}

double __destroy_helper_block_a8_40c54_ZTSKN2re22ResourceSharingManager18UnsubscribeRequestE(uint64_t a1)
{
  double result;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    result = 0.0;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  return result;
}

uint64_t ___ZN2re22ResourceSharingManager24enqueueSetOptionsRequestENS0_17SetOptionsRequestE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  const re::DynamicString *v4;
  NSObject *v5;
  uint64_t result;
  _QWORD block[5];
  uint64_t v8;
  char v9;
  id v10;
  id v11;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(void **)(v2 + 40);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3321888768;
  block[2] = ___ZN2re22ResourceSharingManager24enqueueSetOptionsRequestENS0_17SetOptionsRequestE_block_invoke_2;
  block[3] = &__block_descriptor_88_a8_40c52_ZTSN2re22ResourceSharingManager17SetOptionsRequestE_e5_v8__0l;
  block[4] = v2;
  v4 = (const re::DynamicString *)(a1 + 40);
  v5 = v3;
  re::DynamicString::DynamicString((re::DynamicString *)&v8, v4);
  v10 = *(id *)(a1 + 72);
  v11 = *(id *)(a1 + 80);
  dispatch_sync(v5, block);

  result = v8;
  if (v8)
  {
    if ((v9 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v8 + 40))();
  }
  return result;
}

uint64_t ___ZN2re22ResourceSharingManager24enqueueSetOptionsRequestENS0_17SetOptionsRequestE_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  re *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  int v19;
  NSObject *v20;
  uint64_t result;
  re *v22;
  unsigned int v23;
  NSObject *v24;
  NSObject *v25;
  _BYTE *v26;
  uint64_t v27;
  void *v28;
  unsigned int v29;
  os_log_t *v30;
  NSObject *v31;
  _BYTE *v32;
  _BYTE *v33;
  _BYTE *v34;
  _BYTE *v35;
  id v36;
  id v37;
  NSObject *v38;
  uint64_t v39;
  char v40;
  _BYTE v41[7];
  _BYTE *v42;
  id v43;
  id v44;
  uint8_t v45[4];
  id v46;
  __int16 v47;
  _BYTE *v48;
  __int16 v49;
  id v50;
  uint8_t buf[4];
  id v52;
  __int16 v53;
  _BYTE v54[10];
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  re::DynamicString::DynamicString((re::DynamicString *)&v39, (const re::DynamicString *)(a1 + 40));
  v43 = *(id *)(a1 + 72);
  v44 = *(id *)(a1 + 80);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 40));
  v3 = (re *)re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)&v39);
  v4 = *(_QWORD *)(v2 + 80);
  if (!v4)
  {
LABEL_5:
    v7 = *re::resourceSharingLogObjects(v3);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138412290;
      v52 = v43;
      _os_log_fault_impl(&dword_224FE9000, v7, OS_LOG_TYPE_FAULT, "No resource connection exists for server %@", buf, 0xCu);
    }
    goto LABEL_25;
  }
  v5 = *(_QWORD *)(v2 + 96) + 40;
  v6 = 168 * v4;
  while (*(id *)(v5 - 32) != v43)
  {
    v5 += 168;
    v6 -= 168;
    if (!v6)
      goto LABEL_5;
  }
  v8 = *(unsigned int *)(v5 + 16);
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = (int *)(*(_QWORD *)v5 + 8);
    while (1)
    {
      v11 = *v10;
      v10 += 6;
      if (v11 < 0)
        break;
      if (v8 == ++v9)
      {
        LODWORD(v9) = *(_DWORD *)(v5 + 16);
        break;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if ((_DWORD)v8 == (_DWORD)v9)
  {
LABEL_24:
    v20 = *re::resourceSharingLogObjects(v3);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      if ((v40 & 1) != 0)
        v33 = v42;
      else
        v33 = v41;
      *(_DWORD *)buf = 138412546;
      v52 = v43;
      v53 = 2080;
      *(_QWORD *)v54 = v33;
      _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, "Resource connection %@ ignored a set-options request for '%s': no subscription exists", buf, 0x16u);
    }
    goto LABEL_25;
  }
  v12 = v9;
  v13 = *(_QWORD *)v5;
  while (1)
  {
    v14 = v13 + 24 * v12;
    v17 = *(_QWORD *)(v14 + 16);
    v16 = (uint64_t *)(v14 + 16);
    v15 = v17;
    if (*(re **)(v17 + 56) == v3)
      break;
    if (v8 <= (int)v9 + 1)
      v18 = v9 + 1;
    else
      v18 = v8;
    while (1)
    {
      v12 = (v9 + 1);
      if (v18 - 1 == (_DWORD)v9)
        break;
      LODWORD(v9) = v9 + 1;
      v19 = v12;
      if ((*(_DWORD *)(v13 + 24 * v12 + 8) & 0x80000000) != 0)
        goto LABEL_23;
    }
    v19 = v18;
LABEL_23:
    LODWORD(v9) = v19;
    if ((_DWORD)v8 == v19)
      goto LABEL_24;
  }
  v22 = (re *)(*(_QWORD *(**)(uint8_t *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)(v2 + 24) + 112))(buf, *(_QWORD *)(v2 + 24), v15 + 24);
  if (!buf[0])
  {
    v25 = *re::resourceSharingLogObjects(v22);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v26 = v42;
      if ((v40 & 1) == 0)
        v26 = v41;
      v27 = *v16;
      if ((*(_BYTE *)(*v16 + 32) & 1) != 0)
        v28 = *(void **)(v27 + 40);
      else
        v28 = (void *)(v27 + 33);
      *(_DWORD *)v45 = 138412802;
      v46 = v43;
      v47 = 2080;
      v48 = v26;
      v49 = 2080;
      v50 = v28;
      _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "Resource connection %@ has a subscription for '%s', but no AssetHandle '%s' could be found in AssetService.", v45, 0x20u);
    }
    goto LABEL_47;
  }
  if (!*(_QWORD *)&v54[2])
  {
    v31 = *re::resourceSharingLogObjects(v22);
    goto LABEL_46;
  }
  v23 = atomic_load((unsigned int *)(*(_QWORD *)&v54[2] + 704));
  if (v23 != 2)
  {
    v29 = atomic_load((unsigned int *)(*(_QWORD *)&v54[2] + 704));
    v30 = (os_log_t *)re::resourceSharingLogObjects(v22);
    v31 = *v30;
    if (v29 == 3)
    {
      if (os_log_type_enabled(*v30, OS_LOG_TYPE_DEBUG))
      {
        if ((v40 & 1) != 0)
          v32 = v42;
        else
          v32 = v41;
        *(_DWORD *)v45 = 136315138;
        v46 = v32;
        _os_log_debug_impl(&dword_224FE9000, v31, OS_LOG_TYPE_DEBUG, "Handled set-options request for '%s': asset loading has already failed", v45, 0xCu);
      }
      goto LABEL_47;
    }
LABEL_46:
    if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
    {
      if ((v40 & 1) != 0)
        v34 = v42;
      else
        v34 = v41;
      *(_DWORD *)v45 = 136315138;
      v46 = v34;
      _os_log_fault_impl(&dword_224FE9000, v31, OS_LOG_TYPE_FAULT, "Set-options request for '%s' arrived while asset is loading, which isn't yet implemented", v45, 0xCu);
    }
    goto LABEL_47;
  }
  v24 = *re::resourceSharingLogObjects(v22);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
  {
    if ((v40 & 1) != 0)
      v35 = v42;
    else
      v35 = v41;
    v36 = v43;
    v37 = v44;
    *(_DWORD *)v45 = 138412802;
    v46 = v36;
    v47 = 2080;
    v48 = v35;
    v49 = 2112;
    v50 = v37;
    v38 = v24;
    _os_log_debug_impl(&dword_224FE9000, v38, OS_LOG_TYPE_DEBUG, "Resource connection %@ set payload options on '%s': %@", v45, 0x20u);

  }
  re::AssetManager::setAssetPayloadRequestOptions(*(_QWORD *)(*(_QWORD *)&v54[2] + 24), *(uint64_t *)&v54[2], &v44);
LABEL_47:
  if (buf[0])
    re::AssetHandle::~AssetHandle((re::AssetHandle *)((char *)&v52 + 4));
LABEL_25:

  result = v39;
  if (v39)
  {
    if ((v40 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v39 + 40))();
  }
  return result;
}

id __copy_helper_block_a8_40c52_ZTSN2re22ResourceSharingManager17SetOptionsRequestE(_QWORD *a1, id *a2)
{
  id result;

  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 5), (const re::DynamicString *)(a2 + 5));
  a1[9] = a2[9];
  result = a2[10];
  a1[10] = result;
  return result;
}

double __destroy_helper_block_a8_40c52_ZTSN2re22ResourceSharingManager17SetOptionsRequestE(uint64_t a1)
{
  double result;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    result = 0.0;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  return result;
}

void *__copy_helper_block_a8_48c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *result;

  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 56), (const re::DynamicString *)(a2 + 56));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 88), (const re::DynamicString *)(a2 + 88));
  v4 = *(void **)(a2 + 128);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 128) = v4;
  result = _Block_copy(*(const void **)(a2 + 136));
  *(_QWORD *)(a1 + 136) = result;
  return result;
}

double __destroy_helper_block_a8_48c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(uint64_t a1)
{
  double result;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 88);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 96) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 104));
    result = 0.0;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
  }
  v4 = *(_QWORD *)(a1 + 56);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 64) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 72));
    result = 0.0;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 72) = 0u;
  }
  return result;
}

uint64_t __Block_byref_object_copy__87(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__88(uint64_t a1)
{

}

void ___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke_89(uint64_t a1)
{
  Connection *v2;
  uint64_t v3;
  _QWORD *v4;
  int v5;
  void *v6;
  void *v7;
  id v8;
  _BYTE v9[8];
  id v10;
  _BYTE v11[8];
  void *v12;
  _QWORD *v13;

  v2 = *(Connection **)(a1 + 56);
  re::ResourceSharingManager::findOrAddSubscription((re::ResourceSharingManager *)&v13, v2, *(const re::AssetHandle **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), (re::AssetHandle *)(a1 + 64));
  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v4 = v13;
  v9[0] = *(_BYTE *)(a1 + 88);
  v10 = *(id *)(a1 + 96);
  re::ResourceSharingManager::validateResult((uint64_t)v11, (uint64_t)v2, v3, v4, (uint64_t)v9);

  v5 = v11[0];
  v6 = v12;
  if (v11[0])
    v7 = v12;
  else
    v7 = 0;
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), v7);
  if (v5)
    v8 = 0;
  else
    v8 = v6;
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), v8);

}

id re::ResourceSharingManager::findOrAddSubscription(re::ResourceSharingManager *this, Connection *a2, const re::AssetHandle *a3, re::AssetHandle *a4)
{
  void *v8;
  re *v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t *v34;
  uint64_t v35;
  _anonymous_namespace_ *v36;
  char *v37;
  const char *v38;
  size_t v39;
  uint64_t v40;
  id result;
  uint64_t v42;
  void *v43;
  _QWORD v44[2];

  v8 = re::AssetHandle::assetInfo(a4);
  v9 = (re *)re::Hash<re::DynamicString>::operator()((uint64_t)v44, (uint64_t)v8 + 96);
  v10 = *((unsigned int *)a3 + 14);
  if ((_DWORD)v10)
  {
    v11 = 0;
    v12 = (int *)(*((_QWORD *)a3 + 5) + 8);
    while (1)
    {
      v13 = *v12;
      v12 += 6;
      if (v13 < 0)
        break;
      if (v10 == ++v11)
      {
        LODWORD(v11) = *((_DWORD *)a3 + 14);
        break;
      }
    }
  }
  else
  {
    LODWORD(v11) = 0;
  }
  if ((_DWORD)v10 != (_DWORD)v11)
  {
    v14 = v11;
    v15 = *((_QWORD *)a3 + 5);
    while (1)
    {
      v16 = *(_QWORD *)(v15 + 24 * v14 + 16);
      if (*(re **)(v16 + 56) == v9)
        break;
      if (v10 <= (int)v11 + 1)
        v17 = v11 + 1;
      else
        v17 = *((_DWORD *)a3 + 14);
      while (1)
      {
        v14 = (v11 + 1);
        if (v17 - 1 == (_DWORD)v11)
          break;
        LODWORD(v11) = v11 + 1;
        v18 = v14;
        if ((*(_DWORD *)(v15 + 24 * v14 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      v18 = v17;
LABEL_17:
      LODWORD(v11) = v18;
      if ((_DWORD)v10 == v18)
        goto LABEL_18;
    }
    *(_QWORD *)this = v16;
    v43 = (void *)(v16 + 8);
    return v43;
  }
LABEL_18:
  v19 = *((_QWORD *)a2 + 10);
  if (v19)
  {
    v20 = *((_QWORD *)a2 + 12);
    v21 = v20 + 168 * v19;
    while (1)
    {
      if (*((_QWORD *)a3 + 1) != *(_QWORD *)(v20 + 8))
      {
        v22 = *(unsigned int *)(v20 + 56);
        if ((_DWORD)v22)
        {
          v23 = 0;
          v24 = (int *)(*(_QWORD *)(v20 + 40) + 8);
          while (1)
          {
            v25 = *v24;
            v24 += 6;
            if (v25 < 0)
              break;
            if (v22 == ++v23)
            {
              LODWORD(v23) = *(_DWORD *)(v20 + 56);
              break;
            }
          }
        }
        else
        {
          LODWORD(v23) = 0;
        }
        if ((_DWORD)v22 != (_DWORD)v23)
          break;
      }
LABEL_38:
      v20 += 168;
      if (v20 == v21)
        goto LABEL_39;
    }
    v26 = v23;
    v27 = *(_QWORD *)(v20 + 40);
    while (1)
    {
      v28 = v27 + 24 * v26;
      v31 = *(_QWORD *)(v28 + 16);
      v30 = (uint64_t *)(v28 + 16);
      v29 = v31;
      if (*(re **)(v31 + 56) == v9)
        break;
      if (v22 <= (int)v23 + 1)
        v32 = v23 + 1;
      else
        v32 = *(_DWORD *)(v20 + 56);
      while (1)
      {
        v26 = (v23 + 1);
        if (v32 - 1 == (_DWORD)v23)
          break;
        LODWORD(v23) = v23 + 1;
        v33 = v26;
        if ((*(_DWORD *)(v27 + 24 * v26 + 8) & 0x80000000) != 0)
          goto LABEL_37;
      }
      v33 = v32;
LABEL_37:
      LODWORD(v23) = v33;
      if ((_DWORD)v22 == v33)
        goto LABEL_38;
    }
    re::DynamicArray<REResourceSharingClientObject * {__strong}>::add(v29 + 72, (id *)a3 + 1);
    result = (id)re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::add((uint64_t)a3 + 24, v30);
    v42 = *v30;
    *(_QWORD *)this = *v30;
    if (v42)
    {
      v43 = (void *)(v42 + 8);
      return v43;
    }
  }
  else
  {
LABEL_39:
    v34 = re::globalAllocators(v9);
    v35 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v34[2] + 32))(v34[2], 160, 8);
    *(_OWORD *)v35 = 0u;
    *(_OWORD *)(v35 + 16) = 0u;
    *(_OWORD *)(v35 + 32) = 0u;
    *(_OWORD *)(v35 + 48) = 0u;
    *(_OWORD *)(v35 + 64) = 0u;
    *(_OWORD *)(v35 + 80) = 0u;
    *(_OWORD *)(v35 + 96) = 0u;
    *(_OWORD *)(v35 + 112) = 0u;
    *(_OWORD *)(v35 + 128) = 0u;
    *(_OWORD *)(v35 + 144) = 0u;
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)v35, 0);
    *(_QWORD *)v35 = &off_24ED30510;
    *(_OWORD *)(v35 + 40) = 0u;
    *(_OWORD *)(v35 + 24) = 0u;
    re::DynamicString::setCapacity((_QWORD *)(v35 + 24), 0);
    *(_DWORD *)(v35 + 96) = 0;
    *(_QWORD *)(v35 + 72) = 0;
    *(_QWORD *)(v35 + 80) = 0;
    *(_QWORD *)(v35 + 88) = 0;
    *(_QWORD *)(v35 + 152) = 0;
    *(_OWORD *)(v35 + 104) = 0u;
    *(_OWORD *)(v35 + 120) = 0u;
    *(_OWORD *)(v35 + 132) = 0u;
    *(_QWORD *)this = v35;
    v37 = (char *)re::AssetHandle::assetInfo(a4);
    if ((*((_QWORD *)v37 + 13) & 1) != 0)
      v38 = (const char *)*((_QWORD *)v37 + 14);
    else
      v38 = v37 + 105;
    v39 = strlen(v38);
    v44[0] = v38;
    v44[1] = v39;
    re::DynamicString::operator=((re::DynamicString *)(v35 + 24), (uint64_t)v44);
    *(_QWORD *)(v35 + 56) = re::Hash<re::DynamicString>::operator()((uint64_t)v44, v35 + 24);
    v40 = *((_QWORD *)re::AssetHandle::assetInfo(a4) + 10);
    if (v40 == -1)
      v40 = 0;
    *(_QWORD *)(v35 + 64) = v40;
    re::DynamicArray<REResourceSharingClientObject * {__strong}>::add(v35 + 72, (id *)a3 + 1);
    return (id)re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::add((uint64_t)a3 + 24, (uint64_t *)this);
  }
  return result;
}

void re::ResourceSharingManager::validateResult(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5)
{
  void *v7;
  id v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  void *v30;
  re *v31;
  NSObject *v32;
  re *v33;
  NSObject *v34;
  id v35;
  id v36;
  char *v37;
  uint64_t v38;
  uint64_t (*v39)(uint64_t);
  NSObject *v40;
  uint64_t v41;
  re *v42;
  id v43;
  uint64_t v44;
  id v45;
  re *v46;
  uint8_t buf[4];
  uint64_t v48;
  __int16 v49;
  re *v50;
  __int16 v51;
  id v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v7 = *(void **)(a5 + 8);
  if (*(_BYTE *)a5 && v7)
  {
    v11 = objc_retainAutorelease(v7);
    v44 = a3 + 72;
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a3 + 72, a4[8]);
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a3 + 120, a4[8]);
    v12 = *(unsigned int *)(a3 + 152);
    if ((_DWORD)v12)
    {
      v13 = 0;
      v14 = (int *)(*(_QWORD *)(a3 + 136) + 8);
      while (1)
      {
        v15 = *v14;
        v14 += 8;
        if (v15 < 0)
          break;
        if (v12 == ++v13)
        {
          LODWORD(v13) = *(_DWORD *)(a3 + 152);
          break;
        }
      }
    }
    else
    {
      LODWORD(v13) = 0;
    }
    if ((_DWORD)v12 == (_DWORD)v13)
    {
      v16 = 0;
    }
    else
    {
      v16 = 0;
      v17 = v13;
      v18 = *(_QWORD *)(a3 + 136);
      do
      {
        v16 += *(_QWORD *)(v18 + 32 * v17 + 24);
        if (v12 <= (int)v13 + 1)
          v19 = v13 + 1;
        else
          v19 = *(_DWORD *)(a3 + 152);
        v20 = v13;
        while (1)
        {
          v17 = (v20 + 1);
          if (v19 - 1 == v20)
            break;
          ++v20;
          LODWORD(v13) = v17;
          if ((*(_DWORD *)(v18 + 32 * v17 + 8) & 0x80000000) != 0)
            goto LABEL_21;
        }
        LODWORD(v13) = v19;
LABEL_21:
        ;
      }
      while ((_DWORD)v12 != (_DWORD)v13);
    }
    v21 = *(unsigned int *)(a3 + 104);
    if ((_DWORD)v21)
    {
      v22 = 0;
      v23 = (int *)(*(_QWORD *)(a3 + 88) + 8);
      while (1)
      {
        v24 = *v23;
        v23 += 8;
        if (v24 < 0)
          break;
        if (v21 == ++v22)
        {
          LODWORD(v22) = *(_DWORD *)(a3 + 104);
          break;
        }
      }
    }
    else
    {
      LODWORD(v22) = 0;
    }
    if ((_DWORD)v21 == (_DWORD)v22)
    {
      v25 = 0;
    }
    else
    {
      v25 = 0;
      v26 = v22;
      v27 = *(_QWORD *)(a3 + 88);
      do
      {
        v25 += *(_QWORD *)(v27 + 32 * v26 + 24);
        if (v21 <= (int)v22 + 1)
          v28 = v22 + 1;
        else
          v28 = *(_DWORD *)(a3 + 104);
        v29 = v22;
        while (1)
        {
          v26 = (v29 + 1);
          if (v28 - 1 == v29)
            break;
          ++v29;
          LODWORD(v22) = v26;
          if ((*(_DWORD *)(v27 + 32 * v26 + 8) & 0x80000000) != 0)
            goto LABEL_39;
        }
        LODWORD(v22) = v28;
LABEL_39:
        ;
      }
      while ((_DWORD)v21 != (_DWORD)v22);
    }
    v30 = v11;
    v31 = (re *)malloc_size(v11);
    v46 = v31;
    v32 = *re::resourceSharingLogObjects(v31);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      if ((a4[4] & 1) != 0)
        v37 = (char *)a4[5];
      else
        v37 = (char *)a4 + 33;
      *(_DWORD *)buf = 136315394;
      v48 = (uint64_t)v37;
      v49 = 2048;
      v50 = v31;
      _os_log_debug_impl(&dword_224FE9000, v32, OS_LOG_TYPE_DEBUG, "Asset '%s' estimated to be size:%zu", buf, 0x16u);
    }
    if ((unint64_t)v31 + v25 + v16 <= (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 24) + 400))(*(_QWORD *)(a2 + 24)))
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace<unsigned long &>(v44, a4 + 8, &v46);
      v36 = *(id *)(a5 + 8);
      *(_BYTE *)a1 = 1;
      *(_QWORD *)(a1 + 8) = v36;
    }
    else
    {
      re::makeResourceSharingError((__CFString *)0x258, 0, &v45);
      v34 = *re::resourceSharingLogObjects(v33);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        v38 = *(_QWORD *)(a2 + 24);
        v39 = *(uint64_t (**)(uint64_t))(*(_QWORD *)v38 + 400);
        v40 = v34;
        v41 = v39(v38);
        if ((a4[4] & 1) != 0)
          v42 = (re *)a4[5];
        else
          v42 = (re *)((char *)a4 + 33);
        v43 = v45;
        *(_DWORD *)buf = 134218498;
        v48 = v41;
        v49 = 2080;
        v50 = v42;
        v51 = 2112;
        v52 = v43;
        _os_log_error_impl(&dword_224FE9000, v40, OS_LOG_TYPE_ERROR, "Specified upperBound limit of %zu was hit. Failed send payload for '%s': %@", buf, 0x20u);

      }
      v35 = v45;
      *(_BYTE *)a1 = 0;
      *(_QWORD *)(a1 + 8) = v35;

    }
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)a5;
    *(_QWORD *)(a5 + 8) = 0;
    *(_QWORD *)(a1 + 8) = v7;
  }
}

id __copy_helper_block_a8_64c23_ZTSKN2re11AssetHandleE88c63_ZTSN2re6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEE(uint64_t a1, uint64_t a2)
{
  id result;

  re::AssetHandle::AssetHandle((re::AssetHandle *)(a1 + 64), (const re::AssetHandle *)(a2 + 64));
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a2 + 88);
  result = *(id *)(a2 + 96);
  *(_QWORD *)(a1 + 96) = result;
  return result;
}

void __destroy_helper_block_a8_64c23_ZTSKN2re11AssetHandleE88c63_ZTSN2re6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEE(uint64_t a1)
{
  re::AssetHandle *v1;

  v1 = (re::AssetHandle *)(a1 + 64);

  re::AssetHandle::~AssetHandle(v1);
}

void re::`anonymous namespace'::internalSendFetchResponse(void *a1, _QWORD *a2, void *a3, re::AssetHandle *a4)
{
  id v7;
  _QWORD *v8;
  const char *v9;
  uint64_t v10;
  const char **v11;
  const char *v12;
  uint64_t v13;
  void (**v14)(id, _QWORD, id);

  v7 = a3;
  v14 = a1;
  v8 = re::AssetHandle::assetInfo(a4);
  v10 = *((_QWORD *)a4 + 1);
  if (v10 && (v11 = *(const char ***)(v10 + 264)) != 0)
    v12 = *v11;
  else
    v12 = 0;
  if (v8[10] == -1)
    LODWORD(v13) = 0;
  else
    v13 = v8[10];
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x80E, v13, v12, v9);
  v14[2](v14, *a2, v7);

}

void re::`anonymous namespace'::sendFetchResponse(void *a1, uint64_t a2, re::AssetHandle *a3)
{
  id v5;
  _QWORD *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  const char **v10;
  const char *v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;

  v5 = a1;
  v6 = re::AssetHandle::assetInfo(a3);
  if (v6[10] == -1)
    LODWORD(v8) = 0;
  else
    v8 = v6[10];
  v9 = *((_QWORD *)a3 + 1);
  if (v9 && (v10 = *(const char ***)(v9 + 264)) != 0)
    v11 = *v10;
  else
    v11 = 0;
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x80E, v8, v11, v7);
  if (*(_BYTE *)a2)
    v12 = *(void **)(a2 + 8);
  else
    v12 = 0;
  v13 = objc_retainAutorelease(v12);
  if (*(_BYTE *)a2)
    v14 = 0;
  else
    v14 = *(id *)(a2 + 8);
  v15 = objc_retainAutorelease(v14);

  v16 = v13;
  v17 = v16;

}

void re::ResourceSharingManager::makeFetchRequestError(re::ResourceSharingManager *this)
{
  uint64_t v2;
  uint64_t v3;

  re::makeResourceSharingError((__CFString *)0x190, 0, &v3);
  v2 = v3;
  v3 = 0;
  *(_BYTE *)this = 0;
  *((_QWORD *)this + 1) = v2;

}

void ___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke_90(uint64_t a1)
{
  Connection *v2;
  const re::AssetHandle *v3;
  uint64_t v4;
  uint64_t v5;
  re::AssetLoadRequest::Data **v6;
  id v7;
  id v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  _anonymous_namespace_ *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  BOOL v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD v26[3];
  _QWORD *v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = *(Connection **)(a1 + 40);
  v3 = (const re::AssetHandle *)(a1 + 48);
  re::ResourceSharingManager::findOrAddSubscription((re::ResourceSharingManager *)&v25, v2, *(const re::AssetHandle **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), (re::AssetHandle *)(a1 + 48));
  v4 = v25;
  if (!*(_QWORD *)(v25 + 112))
  {
    (*(void (**)(_QWORD *__return_ptr))(**((_QWORD **)v2 + 3) + 208))(v26);
    v5 = *(_QWORD *)(v4 + 112);
    v6 = (re::AssetLoadRequest::Data **)v26[0];
    *(_QWORD *)(v4 + 112) = v26[0];
    v26[0] = v5;
    if (v5)
    {

      v6 = *(re::AssetLoadRequest::Data ***)(v4 + 112);
    }
    v7 = (id)(v4 + 8);
    v26[0] = &off_24ED30420;
    v26[1] = v2;
    v26[2] = v4;
    v8 = (id)(v4 + 8);
    v27 = v26;
    re::AssetLoadRequest::setCompletionHandler((uint64_t)v6, (uint64_t)v26, 0);
    v9 = v27;
    if (v27 == v26)
    {
      v10 = 4;
      v9 = v26;
    }
    else
    {
      if (!v27)
      {
LABEL_9:

        re::AssetLoadRequest::addAsset(v6, v3);
        goto LABEL_10;
      }
      v10 = 5;
    }
    (*(void (**)(void))(*v9 + 8 * v10))();
    goto LABEL_9;
  }
LABEL_10:
  v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v12 = (re *)*(id *)(a1 + 160);
  v13 = re::globalAllocators(v12);
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13[2] + 32))(v13[2], 40, 8);
  *(_OWORD *)v14 = 0u;
  *(_OWORD *)(v14 + 16) = 0u;
  *(_QWORD *)(v14 + 32) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v14, 0);
  *(_QWORD *)v14 = &off_24ED30558;
  *(_QWORD *)(v14 + 24) = 0;
  *(_QWORD *)(v14 + 32) = v11;
  v15 = _Block_copy(v12);

  v16 = *(void **)(v14 + 24);
  *(_QWORD *)(v14 + 24) = v15;

  v18 = *(_QWORD *)(v4 + 128);
  v19 = *(_QWORD *)(v4 + 136);
  if (v19 >= v18)
  {
    v20 = v19 + 1;
    if (v18 < v19 + 1)
    {
      if (*(_QWORD *)(v4 + 120))
      {
        v21 = 2 * v18;
        v22 = v18 == 0;
        v23 = 8;
        if (!v22)
          v23 = v21;
        if (v23 <= v20)
          v24 = v20;
        else
          v24 = v23;
        re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((_QWORD *)(v4 + 120), v24);
      }
      else
      {
        re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((_QWORD *)(v4 + 120), v20);
        ++*(_DWORD *)(v4 + 144);
      }
    }
    v19 = *(_QWORD *)(v4 + 136);
  }
  *(_QWORD *)(*(_QWORD *)(v4 + 152) + 8 * v19) = v14;
  *(_QWORD *)(v4 + 136) = v19 + 1;
  ++*(_DWORD *)(v4 + 144);

}

void *__copy_helper_block_a8_48c23_ZTSKN2re11AssetHandleE72c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *result;

  re::AssetHandle::AssetHandle((re::AssetHandle *)(a1 + 48), (const re::AssetHandle *)(a2 + 48));
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 80), (const re::DynamicString *)(a2 + 80));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 112), (const re::DynamicString *)(a2 + 112));
  v4 = *(void **)(a2 + 152);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 152) = v4;
  result = _Block_copy(*(const void **)(a2 + 160));
  *(_QWORD *)(a1 + 160) = result;
  return result;
}

void __destroy_helper_block_a8_48c23_ZTSKN2re11AssetHandleE72c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 112);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 120) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 128));
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 88) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 48));
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int *v13;
  int v14;
  int v15;

  if (*(_QWORD *)result)
  {
    v2 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v3 = (v2 ^ (v2 >> 31)) % *(unsigned int *)(result + 24);
    v4 = *(_QWORD *)(result + 8);
    v5 = *(unsigned int *)(v4 + 4 * v3);
    if ((_DWORD)v5 != 0x7FFFFFFF)
    {
      v6 = *(_QWORD *)(result + 16);
      v7 = v6 + 32 * v5;
      if (*(_QWORD *)(v7 + 16) == a2)
      {
        *(_DWORD *)(v4 + 4 * v3) = *(_DWORD *)(v7 + 8) & 0x7FFFFFFF;
LABEL_8:
        v10 = *(_QWORD *)(result + 16);
        v11 = v10 + 32 * v5;
        v14 = *(_DWORD *)(v11 + 8);
        v13 = (int *)(v11 + 8);
        v12 = v14;
        if (v14 < 0)
        {
          *v13 = v12 & 0x7FFFFFFF;
          v10 = *(_QWORD *)(result + 16);
          v12 = *(_DWORD *)(v10 + 32 * v5 + 8);
        }
        v15 = *(_DWORD *)(result + 40);
        *(_DWORD *)(v10 + 32 * v5 + 8) = *(_DWORD *)(result + 36) | v12 & 0x80000000;
        --*(_DWORD *)(result + 28);
        *(_DWORD *)(result + 36) = v5;
        *(_DWORD *)(result + 40) = v15 + 1;
      }
      else
      {
        while (1)
        {
          v8 = v5;
          v5 = *(_DWORD *)(v6 + 32 * v5 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          v9 = v6 + 32 * v5;
          if (*(_QWORD *)(v9 + 16) == a2)
          {
            *(_DWORD *)(v6 + 32 * v8 + 8) = *(_DWORD *)(v6 + 32 * v8 + 8) & 0x80000000 | *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace<unsigned long &>(uint64_t result, uint64_t *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = result;
  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)result)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(result + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(result + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    result = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(result, v9, v8, a2, a3);
    goto LABEL_9;
  }
  v11 = *(_QWORD *)(result + 16);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != v6)
  {
    v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  *(_QWORD *)(v11 + 32 * v10 + 24) = *a3;
LABEL_9:
  ++*(_DWORD *)(v5 + 40);
  return result;
}

id re::DynamicArray<REResourceSharingClientObject * {__strong}>::add(uint64_t a1, id *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  id result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v6)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  v11 = *(_QWORD *)(a1 + 32);
  result = *a2;
  *(_QWORD *)(v11 + 8 * v5) = result;
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::add(uint64_t result, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = result;
  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(result + 24);
  if ((_DWORD)v7)
  {
    v8 = v6 % v7;
    v9 = *(unsigned int *)(*(_QWORD *)(result + 8) + 4 * (v6 % v7));
    if ((_DWORD)v9 != 0x7FFFFFFF)
    {
      v10 = *(_QWORD *)(result + 16);
      if (*(_QWORD *)(v10 + 24 * v9 + 16) == v4)
        return result;
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v9 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v10 + 24 * v9 + 16) == v4)
          return result;
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  result = re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::addAsCopy(result, v8, v6, a2);
  ++*(_DWORD *)(v3 + 40);
  return result;
}

void re::make::shared::object<re::internal::ResourceRequestQueue>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;

  v3 = re::globalAllocators(a1);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3[2] + 32))(v3[2], 80, 8);
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v4, 0);
  *(_QWORD *)v4 = &off_24ED303D8;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 64) = 0;
  *(_QWORD *)(v4 + 40) = 0;
  *(_QWORD *)(v4 + 48) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  *(_DWORD *)(v4 + 56) = 0;
  *(_BYTE *)(v4 + 72) = 0;
  *a2 = v4;
}

void re::internal::ResourceRequestQueue::~ResourceRequestQueue(re::internal::ResourceRequestQueue *this)
{
  *(_QWORD *)this = &off_24ED303D8;
  re::DynamicArray<re::ObjCObject>::deinit((uint64_t)this + 32);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED303D8;
  re::DynamicArray<re::ObjCObject>::deinit((uint64_t)this + 32);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::DynamicArray<re::ResourceSharingManager::Connection>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  __int128 *v8;
  uint64_t v9;
  __int128 *v10;
  _QWORD *v11;
  __int128 v12;
  _QWORD *v13;
  void *v14;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::ResourceSharingManager::Connection>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA8uLL))
        {
          v2 = 168 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 168 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 168, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (__int128 *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = (__int128 *)((char *)v8 + 168 * v9);
        v11 = v7;
        do
        {
          v12 = *v8;
          *(_QWORD *)v8 = 0;
          *((_QWORD *)v8 + 1) = 0;
          *(_OWORD *)v11 = v12;
          v11[2] = *((_QWORD *)v8 + 2);
          *(_OWORD *)(v11 + 5) = 0u;
          *((_DWORD *)v11 + 14) = 0;
          *(_OWORD *)(v11 + 3) = 0u;
          *(_QWORD *)((char *)v11 + 60) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v11 + 3, (uint64_t *)v8 + 3);
          *((_DWORD *)v11 + 26) = 0;
          *(_OWORD *)(v11 + 11) = 0u;
          *(_OWORD *)(v11 + 9) = 0u;
          *(_QWORD *)((char *)v11 + 108) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v11 + 9, (uint64_t *)v8 + 9);
          *(_OWORD *)(v11 + 15) = 0u;
          v13 = v11 + 15;
          *((_DWORD *)v13 + 8) = 0;
          *((_OWORD *)v13 + 1) = 0u;
          *(_QWORD *)((char *)v13 + 36) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v13, (uint64_t *)v8 + 15);
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v8 + 15);
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v8 + 9);
          re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)v8 + 3);

          v14 = *(void **)v8;
          v8 = (__int128 *)((char *)v8 + 168);

          v11 = v13 + 6;
        }
        while (v8 != v10);
        v8 = (__int128 *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  unint64_t v18;

  if (a1 != a2)
  {
    if (!*(_QWORD *)a1 || (v4 = *(_QWORD *)a2, *(_QWORD *)a1 == *(_QWORD *)a2))
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, (uint64_t *)a2);
    }
    else
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
      if (v4)
      {
        v5 = *(_DWORD *)(a2 + 28);
        if (*(_DWORD *)(a1 + 24) < v5)
          re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v5);
        v6 = *(unsigned int *)(a2 + 32);
        if ((_DWORD)v6)
        {
          v7 = 0;
          for (i = 0; i < v6; ++i)
          {
            v9 = (unint64_t *)(*(_QWORD *)(a2 + 16) + v7);
            if ((v9[1] & 0x80000000) != 0)
            {
              v10 = *v9;
              v11 = *(unsigned int *)(a1 + 24);
              v12 = *v9 % v11;
              v13 = *(unsigned int *)(a1 + 36);
              if ((_DWORD)v13 == 0x7FFFFFFF)
              {
                v13 = *(unsigned int *)(a1 + 32);
                v14 = v13;
                if ((_DWORD)v13 == (_DWORD)v11)
                {
                  re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
                  v12 = v10 % *(unsigned int *)(a1 + 24);
                  v14 = *(_DWORD *)(a1 + 32);
                }
                *(_DWORD *)(a1 + 32) = v14 + 1;
                v15 = *(_QWORD *)(a1 + 16);
                v16 = *(_DWORD *)(v15 + 32 * v13 + 8);
              }
              else
              {
                v15 = *(_QWORD *)(a1 + 16);
                v16 = *(_DWORD *)(v15 + 32 * v13 + 8);
                *(_DWORD *)(a1 + 36) = v16 & 0x7FFFFFFF;
              }
              *(_DWORD *)(v15 + 32 * v13 + 8) = v16 | 0x80000000;
              v17 = *(_QWORD *)(a1 + 8);
              *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v13 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v13 + 8) & 0x80000000 | *(_DWORD *)(v17 + 4 * v12);
              *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v13) = v10;
              v18 = v9[3];
              *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v13 + 16) = v9[2];
              *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v13 + 24) = v18;
              *(_DWORD *)(v17 + 4 * v12) = v13;
              ++*(_DWORD *)(a1 + 28);
              v6 = *(unsigned int *)(a2 + 32);
            }
            v7 += 32;
          }
        }
        ++*(_DWORD *)(a1 + 40);
      }
    }
  }
  return a1;
}

uint64_t re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;

  v7 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v7 == 0x7FFFFFFF)
  {
    v7 = *(unsigned int *)(a1 + 32);
    v8 = v7;
    if ((_DWORD)v7 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_DWORD *)(v9 + 24 * v7 + 8);
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_DWORD *)(v9 + 24 * v7 + 8);
    *(_DWORD *)(a1 + 36) = v10 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v9 + 24 * v7 + 8) = v10 | 0x80000000;
  v11 = a2;
  v12 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7) = a3;
  v13 = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7 + 16) = *a4;
  if (v13)
  {
    v14 = (id)(v13 + 8);
    v12 = *(_QWORD *)(a1 + 8);
  }
  *(_DWORD *)(v12 + 4 * v11) = v7;
  ++*(_DWORD *)(a1 + 28);
  return v7;
}

void re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphNode>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 16), (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 24));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  v13 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

_QWORD *re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  id *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  id v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (id *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 8 * v9;
        v11 = v7;
        do
        {
          *v11++ = *v8;
          v12 = *v8++;

          v10 -= 8;
        }
        while (v10);
        v8 = (id *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, id *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

_QWORD *std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::~__func(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24ED30420;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::~__func(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24ED30420;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  id v5;

  v2 = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *v2 = &off_24ED30420;
  v2[1] = v4;
  v2[2] = v3;
  if (v3)
    v5 = (id)(v3 + 8);
  return v2;
}

_QWORD *std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::__clone(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  v3 = result[1];
  v2 = result[2];
  *a2 = &off_24ED30420;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
    return (id)(v2 + 8);
  return result;
}

void std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::destroy(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
  {

    *(_QWORD *)(a1 + 16) = 0;
  }
}

void std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::destroy_deallocate(_QWORD *__p)
{
  uint64_t v2;

  v2 = __p[2];
  if (v2)

  operator delete(__p);
}

uint64_t std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::operator()(_anonymous_namespace_ *a1, unsigned __int8 *a2)
{
  int v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  id v7;
  char v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  id v13;
  NSObject *v14;
  id v15;
  uint64_t v16;
  id v17;
  void *v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  id v22;
  uint64_t result;
  id v24;
  _anonymous_namespace_ *v25;
  id v26;
  _QWORD v27[7];
  uint64_t v28;
  uint64_t v29;
  char v30;
  id v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t (*v35)(uint64_t, uint64_t);
  void (*v36)(uint64_t);
  id v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t (*v41)(uint64_t, uint64_t);
  void (*v42)(uint64_t);
  id v43;
  _BYTE v44[8];
  id v45;
  uint64_t v46;
  _BYTE v47[24];
  _QWORD block[6];
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  uint64_t (*v54)(uint64_t);
  const char *v55;
  _QWORD v56[3];
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  double (*v62)(uint64_t, _QWORD *);
  double (*v63)(uint64_t);
  const char *v64;
  __int128 v65;
  __int128 v66;

  v3 = *a2;
  v4 = *((_QWORD *)a1 + 1);
  v59 = 0;
  v60 = &v59;
  v62 = __Block_byref_object_copy__136;
  v63 = __Block_byref_object_dispose__137;
  v61 = 0x5012000000;
  v64 = "";
  v65 = 0u;
  v66 = 0u;
  re::DynamicString::setCapacity(&v65, 0);
  v50 = 0;
  v51 = &v50;
  v52 = 0x5812000000;
  v53 = __Block_byref_object_copy__139;
  v54 = __Block_byref_object_dispose__140;
  v58 = 0;
  v55 = "";
  memset(v56, 0, sizeof(v56));
  v57 = 0;
  v5 = *(id *)(v4 + 40);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3321888768;
  block[2] = ___ZZN2re22ResourceSharingManager22createAssetLoadRequestERKNS_9SharedPtrINS0_12SubscriptionEEERKNS_11AssetHandleEENK3__0clEb_block_invoke;
  block[3] = &unk_24ED30488;
  v25 = a1;
  v6 = *((_QWORD *)a1 + 2);
  v49 = v6;
  if (v6)
    v7 = (id)(v6 + 8);
  block[4] = &v59;
  block[5] = &v50;
  dispatch_sync(v5, block);

  (*(void (**)(uint64_t *__return_ptr, _QWORD, uint64_t *))(**(_QWORD **)(v4 + 24) + 112))(&v46, *(_QWORD *)(v4 + 24), v60 + 6);
  if (v3 && (_BYTE)v46)
    re::ResourceSharingManager::makeFetchRequestResult((re::ResourceSharingManager *)v44, (const re::AssetHandle *)v4, (const re::AssetHandle *)v47);
  else
    re::ResourceSharingManager::makeFetchRequestError((re::ResourceSharingManager *)v44);
  v8 = v44[0];
  v9 = (uint64_t *)v51[10];
  v10 = v51[8];
  if (v44[0])
  {
    if (v10)
    {
      v24 = v45;
      v11 = 8 * v10;
      do
      {
        v12 = *v9;
        if (*v9)
          v13 = (id)(v12 + 8);
        v38 = 0;
        v39 = &v38;
        v40 = 0x3032000000;
        v41 = __Block_byref_object_copy__87;
        v42 = __Block_byref_object_dispose__88;
        v43 = 0;
        v32 = 0;
        v33 = &v32;
        v34 = 0x3032000000;
        v35 = __Block_byref_object_copy__87;
        v36 = __Block_byref_object_dispose__88;
        v37 = 0;
        v14 = *(id *)(v4 + 40);
        v27[0] = MEMORY[0x24BDAC760];
        v27[1] = 3321888768;
        v27[2] = ___ZZN2re22ResourceSharingManager22createAssetLoadRequestERKNS_9SharedPtrINS0_12SubscriptionEEERKNS_11AssetHandleEENK3__0clEb_block_invoke_142;
        v27[3] = &unk_24ED304C0;
        v27[6] = v4;
        v28 = v12;
        if (v12)
          v15 = (id)(v12 + 8);
        v16 = *((_QWORD *)v25 + 2);
        v29 = v16;
        if (v16)
          v17 = (id)(v16 + 8);
        v30 = v8;
        v31 = v24;
        v27[4] = &v38;
        v27[5] = &v32;
        dispatch_sync(v14, v27);

        v18 = *(void **)(v12 + 24);
        v19 = (id)v39[5];
        v26 = v19;

        if (v29)
        {

          v29 = 0;
        }
        if (v28)
        {

          v28 = 0;
        }
        _Block_object_dispose(&v32, 8);

        _Block_object_dispose(&v38, 8);
        ++v9;
        v11 -= 8;
      }
      while (v11);
    }
  }
  else if (v10)
  {
    v20 = 8 * v10;
    do
    {
      v21 = *v9;
      if (*v9)
        v22 = (id)(v21 + 8);

      ++v9;
      v20 -= 8;
    }
    while (v20);
  }

  if ((_BYTE)v46)
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v47);
  if (v49)

  _Block_object_dispose(&v50, 8);
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)v56);
  _Block_object_dispose(&v59, 8);
  result = v65;
  if ((_QWORD)v65)
  {
    if ((BYTE8(v65) & 1) != 0)
      return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v65 + 40))(v65, v66);
  }
  return result;
}

uint64_t std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::target_type()
{
}

double __Block_byref_object_copy__136(uint64_t a1, _QWORD *a2)
{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)(a1 + 72) = a2[9];
  v3 = a2[7];
  *(_QWORD *)(a1 + 48) = a2[6];
  a2[6] = 0;
  v4 = a2[8];
  a2[9] = 0;
  v6 = *(_QWORD *)(a1 + 56);
  v5 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 56) = v3;
  *(_QWORD *)(a1 + 64) = v4;
  a2[7] = v6;
  a2[8] = v5;
  return result;
}

double __Block_byref_object_dispose__137(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;

  v3 = (_OWORD *)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 56) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 64));
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  return result;
}

uint64_t __Block_byref_object_copy__139(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)(result + 80) = 0;
  *(_QWORD *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = 0;
  *(_QWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 72) = 0;
  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  v3 = *(_QWORD *)(result + 64);
  *(_QWORD *)(result + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v3;
  v4 = *(_QWORD *)(result + 80);
  *(_QWORD *)(result + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v4;
  ++*(_DWORD *)(a2 + 72);
  ++*(_DWORD *)(result + 72);
  return result;
}

uint64_t __Block_byref_object_dispose__140(uint64_t a1)
{
  return re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit(a1 + 48);
}

void ___ZZN2re22ResourceSharingManager22createAssetLoadRequestERKNS_9SharedPtrINS0_12SubscriptionEEERKNS_11AssetHandleEENK3__0clEb_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  re::DynamicString::operator=((re::DynamicString *)(*(_QWORD *)(a1[4] + 8) + 48), (re::DynamicString *)(a1[6] + 24));
  v2 = a1[6];
  v3 = (uint64_t *)(v2 + 120);
  v4 = *(_QWORD *)(a1[5] + 8);
  if (v4 + 48 != v2 + 120)
  {
    v5 = *v3;
    if (*(_QWORD *)(v4 + 48))
    {
      v6 = v4 + 48;
      if (v5)
      {
        re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::copy(v6, v2 + 120);
        ++*(_DWORD *)(v4 + 72);
      }
      else
      {
        re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::clear(v6);
      }
    }
    else if (v5)
    {
      v7 = *(_QWORD *)(v2 + 136);
      *(_QWORD *)(v4 + 48) = v5;
      re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((_QWORD *)(v4 + 48), v7);
      ++*(_DWORD *)(v4 + 72);
      re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::copy(v4 + 48, (uint64_t)v3);
    }
  }
  v8 = a1[6];
  v9 = *(_QWORD *)(v8 + 112);
  if (v9)
  {

    *(_QWORD *)(v8 + 112) = 0;
    v8 = a1[6];
  }
  re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::clear(v8 + 120);
}

void re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = 8 * v2;
    do
    {
      if (*(_QWORD *)v3)
      {

        *(_QWORD *)v3 = 0;
      }
      v3 += 8;
      v4 -= 8;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *__copy_helper_block_a8_48c65_ZTSRKN2re9SharedPtrINS_22ResourceSharingManager12SubscriptionEEE(_QWORD *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  result[6] = v2;
  if (v2)
    return (id)(v2 + 8);
  return result;
}

void ___ZZN2re22ResourceSharingManager22createAssetLoadRequestERKNS_9SharedPtrINS0_12SubscriptionEEERKNS_11AssetHandleEENK3__0clEb_block_invoke_142(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  void *v5;
  id v6;
  _BYTE v7[8];
  id v8;
  _BYTE v9[8];
  id v10;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32);
  v4 = *(_QWORD **)(a1 + 64);
  v7[0] = *(_BYTE *)(a1 + 72);
  v8 = *(id *)(a1 + 80);
  re::ResourceSharingManager::validateResult((uint64_t)v9, v2, v3, v4, (uint64_t)v7);

  if (*(_BYTE *)(a1 + 72))
    v5 = *(void **)(a1 + 80);
  else
    v5 = 0;
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v5);
  if (*(_BYTE *)(a1 + 72))
    v6 = 0;
  else
    v6 = *(id *)(a1 + 80);
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), v6);

}

id __copy_helper_block_a8_56c61_ZTSN2re9SharedPtrINS_22ResourceSharingManager10CompletionEEE64c65_ZTSRKN2re9SharedPtrINS_22ResourceSharingManager12SubscriptionEEE72c63_ZTSN2re6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  id v5;
  uint64_t v6;
  id v7;
  id result;

  v4 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 56) = v4;
  if (v4)
    v5 = (id)(v4 + 8);
  v6 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 64) = v6;
  if (v6)
    v7 = (id)(v6 + 8);
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  result = *(id *)(a2 + 80);
  *(_QWORD *)(a1 + 80) = result;
  return result;
}

void __destroy_helper_block_a8_56c61_ZTSN2re9SharedPtrINS_22ResourceSharingManager10CompletionEEE64c65_ZTSRKN2re9SharedPtrINS_22ResourceSharingManager12SubscriptionEEE72c63_ZTSN2re6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEE(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 56);
  if (v2)
  {

    *(_QWORD *)(a1 + 56) = 0;
  }
}

void re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  id v13;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= *(_QWORD *)(a1 + 16))
  {
    re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((_QWORD *)a1, *(_QWORD *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 8 * *(_QWORD *)(a1 + 16)), *(uint64_t **)(a1 + 32));
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v4)
    {
      v9 = (uint64_t *)(*(_QWORD *)(a2 + 32) + 8 * v8);
      v10 = (uint64_t *)(*(_QWORD *)(a1 + 32) + 8 * v8);
      v11 = 8 * v4 - 8 * v8;
      do
      {
        v12 = *v9;
        *v10 = *v9;
        if (v12)
          v13 = (id)(v12 + 8);
        ++v9;
        ++v10;
        v11 -= 8;
      }
      while (v11);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 8 * v4), *(uint64_t **)(a1 + 32));
    v5 = *(_QWORD *)(a1 + 16);
    if (v4 != v5)
    {
      v6 = *(_QWORD *)(a1 + 32) + 8 * v4;
      v7 = 8 * v5 - 8 * v4;
      do
      {
        if (*(_QWORD *)v6)
        {

          *(_QWORD *)v6 = 0;
        }
        v6 += 8;
        v7 -= 8;
      }
      while (v7);
    }
  }
  *(_QWORD *)(a1 + 16) = v4;
}

void re::ResourceSharingManager::Subscription::~Subscription(re::ResourceSharingManager::Subscription *this)
{
  re::ResourceSharingManager::Subscription::~Subscription(this);
  JUMPOUT(0x2276933B8);
}

{
  uint64_t v2;
  uint64_t v3;
  void **v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;

  *(_QWORD *)this = &off_24ED30510;
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)this + 120);
  v2 = *((_QWORD *)this + 14);
  if (v2)
  {

    *((_QWORD *)this + 14) = 0;
  }
  v3 = *((_QWORD *)this + 9);
  if (v3)
  {
    v4 = (void **)*((_QWORD *)this + 13);
    if (v4)
    {
      v5 = *((_QWORD *)this + 11);
      if (v5)
      {
        v6 = 8 * v5;
        do
        {
          v7 = *v4++;

          v6 -= 8;
        }
        while (v6);
        v3 = *((_QWORD *)this + 9);
        v4 = (void **)*((_QWORD *)this + 13);
      }
      (*(void (**)(uint64_t, void **))(*(_QWORD *)v3 + 40))(v3, v4);
    }
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 11) = 0;
    *((_QWORD *)this + 9) = 0;
    ++*((_DWORD *)this + 24);
  }
  v8 = *((_QWORD *)this + 3);
  if (v8)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *((_QWORD *)this + 5));
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

void re::ResourceSharingManager::Completion::~Completion(id *this)
{

  *this = &off_24ED426B8;
  objc_destructInstance(this + 1);
}

{

  *this = &off_24ED426B8;
  objc_destructInstance(this + 1);
  JUMPOUT(0x2276933B8);
}

uint64_t *re::allocInfo_DynamicAssetHeader(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FD200);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FD200))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FD290, 0);
    *(uint64_t *)((char *)&qword_2540FD2A0 + 6) = 0;
    qword_2540FD2A0 = 0;
    qword_2540FD2B0 = 0;
    qword_2540FD2B8 = 0xFFFFFFFFLL;
    qword_2540FD290 = (uint64_t)&off_24ED7DAA8;
    qword_2540FD2C0 = (uint64_t)"DynamicAssetHeader";
    dword_2540FD2C8 = 0;
    xmmword_2540FD2D0 = 0u;
    unk_2540FD2E0 = 0u;
    xmmword_2540FD2F0 = 0u;
    qword_2540FD300 = 0;
    __cxa_guard_release(&qword_2540FD200);
  }
  return &qword_2540FD290;
}

void re::initInfo_DynamicAssetHeader(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  __int128 v9;
  _QWORD v10[2];
  __int128 v11;

  v10[0] = 0x8CA13F8BC694F7FCLL;
  v10[1] = "DynamicAssetHeader";
  re::StringID::destroyString((re::StringID *)v10);
  *((_OWORD *)this + 2) = v11;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FD210);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FD210);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::introspect_AssetSerializationFormat((re *)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "assetSerializationFormat";
      *(_QWORD *)(v8 + 16) = &qword_2540FD248;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_2540FD208 = v8;
      __cxa_guard_release(&qword_2540FD210);
    }
  }
  *((_QWORD *)this + 2) = 0x400000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 8) = &qword_2540FD208;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::DynamicAssetHeader>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::DynamicAssetHeader>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::DynamicAssetHeader>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::DynamicAssetHeader>;
  re::IntrospectionRegistry::add(this, v3);
  v9 = v11;
}

void re::introspect_AssetSerializationFormat(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  StringID v38;
  _QWORD v39[2];
  _QWORD v40[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540FD218);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540FD218);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "Unknown";
      qword_2540FD228 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "JSON";
      qword_2540FD230 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "Binary";
      qword_2540FD238 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *(_QWORD *)(v34 + 8) = 3;
      *(_QWORD *)(v34 + 16) = "OPACK";
      qword_2540FD240 = v34;
      __cxa_guard_release(&qword_2540FD218);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540FD220);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540FD220))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540FD248, "AssetSerializationFormat", 4, 4, 1, 1);
    qword_2540FD248 = (uint64_t)&off_24ED7D9E8;
    qword_2540FD288 = (uint64_t)&re::introspect_AssetSerializationFormat(BOOL)::enumTable;
    dword_2540FD258 = 9;
    __cxa_guard_release(&qword_2540FD220);
  }
  if ((_MergedGlobals_61 & 1) == 0)
  {
    _MergedGlobals_61 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FD248, a2);
    v36 = 0x69029CD6B845AE2ELL;
    v37 = "AssetSerializationFormat";
    v40[0] = 208862;
    v40[1] = "int";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v40);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v40);
      v6 = (unsigned int *)qword_2540FD288;
      v39[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v40, &v36, 1, 1, (uint64_t)v39);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v38.var0 = 2 * v12;
            v38.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v40, v16, &v38);
            re::StringID::destroyString((re::StringID *)&v38);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v38.var0 = 2 * v20;
              v38.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v40, v24, &v38);
              re::StringID::destroyString((re::StringID *)&v38);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v40, v25);
      xmmword_2540FD268 = (__int128)v38;
      re::StringID::destroyString((re::StringID *)&v36);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v40);
      re::internal::assertLog((re::internal *)5, v35, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "AssetSerializationFormat", v36, v37);
      _os_crash();
      __break(1u);
    }
  }
}

