void sub_1B18AF0B4(const __CFString *a1, uint64_t a2)
{
  CFIndex Length;
  CFIndex v5;
  const __CFAllocator *v6;
  const __CFString *v7;
  CFIndex v8;
  CFMutableStringRef MutableCopy;
  CFIndex v10;
  CFIndex v11;
  CFIndex v12;
  const __CFString *v13;
  CFComparisonResult v14;
  char v15;
  CFIndex v16;
  CFIndex v17;
  CFIndex v18;
  CFStringRef v19;
  int v20;
  int v21;
  CFIndex v22;
  CFIndex v23;
  __CFString *v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  const __CFString *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  CFRange v59;
  CFRange v60;
  CFRange v61;
  CFRange v62;
  CFRange v63;
  CFRange v64;

  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v44 = 0u;
  Length = CFStringGetLength(a1);
  sub_1B179F0E8((uint64_t)&v44, a1, 0, Length, 1);
  sub_1B179F7E4((uint64_t)&v44, 1);
  if (sub_1B179F7DC((uint64_t)&v44))
    sub_1B179F7E4((uint64_t)&v44, 1);
  v59.location = sub_1B179F17C((uint64_t)&v44);
  v59.length = v5;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v59);
  sub_1B179F7E4((uint64_t)&v44, 1);
  v60.location = sub_1B179F17C((uint64_t)&v44);
  v60.length = v8;
  if (CFStringCompareWithOptions(a1, CFSTR("<"), v60, 0))
  {
    MutableCopy = (CFMutableStringRef)v7;
  }
  else
  {
    MutableCopy = CFStringCreateMutableCopy(v6, 0, v7);
    do
    {
      v10 = sub_1B179F17C((uint64_t)&v44);
      v12 = v11;
      v61.location = v10;
      v61.length = v11;
      v13 = CFStringCreateWithSubstring(v6, a1, v61);
      CFStringAppend(MutableCopy, v13);
      CFRelease(v13);
      v62.location = v10;
      v62.length = v12;
      v14 = CFStringCompareWithOptions(a1, CFSTR(">"), v62, 0);
      v15 = sub_1B179F7E4((uint64_t)&v44, 1);
    }
    while (v14 && (v15 & 1) != 0);
    CFRelease(v7);
  }
  if (sub_1B179F7DC((uint64_t)&v44))
    sub_1B179F7E4((uint64_t)&v44, 1);
  v16 = sub_1B179F17C((uint64_t)&v44);
  v18 = v17;
  v63.location = v16;
  v63.length = v17;
  v19 = CFStringCreateWithSubstring(v6, a1, v63);
  if (CFStringGetLength(MutableCopy) >= 1)
  {
    v20 = sub_1B179E324(MutableCopy);
    if (v20)
    {
      v21 = v20;
      v22 = v16 + v18;
      v23 = CFStringGetLength(a1);
      if (v23 > v22)
      {
        v64.location = v22;
        v64.length = v23 - v22;
        v24 = (__CFString *)CFStringCreateWithSubstring(v6, a1, v64);
        v27 = objc_msgSend_rangeOfString_(v24, v25, (uint64_t)CFSTR("="), v26, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58);
        if (v28)
        {
          v30 = (const __CFString *)objc_msgSend_substringFromIndex_(v24, v28, v27 + 1, v29);
          v37 = (const void *)sub_1B191E290(v21, 1, v31, v32, v33, v34, v35, v36);
          sub_1B191E834((uint64_t)v37, v30, v38, v39, v40, v41, v42, v43);
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 40), v19, v37);
          CFRelease(v37);
        }
        CFRelease(v24);
      }
    }
  }
  if (CFStringGetLength(v19) >= 1 && CFStringGetLength(MutableCopy) >= 1)
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 32), v19, MutableCopy);
  if (v19)
    CFRelease(v19);
  if (MutableCopy)
    CFRelease(MutableCopy);
}

void sub_1B18AF380(const __CFString *a1, uint64_t a2)
{
  CFIndex Length;
  CFIndex v5;
  const __CFAllocator *v6;
  CFStringRef v7;
  CFIndex v8;
  CFStringRef v9;
  _OWORD v10[15];
  CFRange v11;
  CFRange v12;

  memset(v10, 0, sizeof(v10));
  Length = CFStringGetLength(a1);
  sub_1B179F0E8((uint64_t)v10, a1, 0, Length, 1);
  sub_1B179F174((uint64_t)v10);
  if (sub_1B179F7DC((uint64_t)v10))
    sub_1B179F174((uint64_t)v10);
  v11.location = sub_1B179F17C((uint64_t)v10);
  v11.length = v5;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v11);
  sub_1B179F174((uint64_t)v10);
  if (sub_1B179F7DC((uint64_t)v10))
    sub_1B179F174((uint64_t)v10);
  v12.location = sub_1B179F17C((uint64_t)v10);
  v12.length = v8;
  v9 = CFStringCreateWithSubstring(v6, a1, v12);
  if (CFStringGetLength(v9) >= 1 && CFStringGetLength(v7) >= 1)
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 48), v9, v7);
  if (v9)
    CFRelease(v9);
  if (v7)
    CFRelease(v7);
}

CFMutableDictionaryRef sub_1B18AF4C0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v4;
  const CFDictionaryKeyCallBacks *v5;
  const CFDictionaryValueCallBacks *v6;
  CFMutableDictionaryRef result;

  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  if ((a1 & 1) != 0)
  {
    Mutable = 0;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  }
  else
  {
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *(_QWORD *)a2 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    *(_QWORD *)(a2 + 8) = CFStringCreateMutable(v4, 0);
    Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  *(_QWORD *)(a2 + 16) = Mutable;
  v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  *(_QWORD *)(a2 + 24) = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E0C9B390], 0);
  v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  *(_QWORD *)(a2 + 56) = CFDictionaryCreateMutable(v4, 0, v5, MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(a2 + 32) = CFDictionaryCreateMutable(v4, 0, v5, v6);
  *(_QWORD *)(a2 + 40) = CFDictionaryCreateMutable(v4, 0, v5, v6);
  *(_QWORD *)(a2 + 48) = CFDictionaryCreateMutable(v4, 0, v5, v6);
  result = CFDictionaryCreateMutable(v4, 0, v5, v6);
  *(_QWORD *)(a2 + 64) = result;
  return result;
}

void sub_1B18AF5FC(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  v2 = *(const void **)a1;
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)a1 = 0;
  }
  v3 = *(const void **)(a1 + 8);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v6 = *(const void **)(a1 + 56);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v7 = *(const void **)(a1 + 40);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v8 = *(const void **)(a1 + 32);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v9 = *(const void **)(a1 + 48);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v10 = *(const void **)(a1 + 64);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 64) = 0;
  }
}

void sub_1B18B0B40(_Unwind_Exception *a1)
{
  prof_endFlame();
  _Unwind_Resume(a1);
}

void sub_1B18B1CC4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  char v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFDictionary *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _BOOL4 v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const __CFDictionary *v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _BOOL4 v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  const char *v73;
  _BOOL4 v74;
  const void *v75;

  v9 = *(_QWORD *)(a1 + 48);
  if (v9 || (v9 = objc_msgSend_worldRef(*(void **)(a1 + 32), a2, a3, a4)) != 0)
  {
    sub_1B187973C(v9, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    v10 = 0;
  }
  else
  {
    v10 = 1;
  }
  v11 = (_QWORD *)objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  v19 = sub_1B1814720(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 184), v12, v13, v14, v15, v16, v17, v18);
  if (v19 && (v27 = sub_1B186CFA8(v19, v20, v21, v22, v23, v24, v25, v26)) != 0)
  {
    v29 = (uint64_t)v27;
    v30 = sub_1B186503C((uint64_t)v27, v28, v21, v22, v23, v24, v25, v26);
    v38 = sub_1B1866598(v29, v31, v32, v33, v34, v35, v36, v37) != 0;
  }
  else
  {
    v30 = 0;
    v38 = 0;
  }
  sub_1B1813FE4(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 184), v11, v21, v22, v23, v24, v25, v26);
  if (v11)
  {
    v46 = sub_1B186CFA8((uint64_t)v11, v39, v40, v41, v42, v43, v44, v45);
    if (v46)
    {
      v54 = (uint64_t)v46;
      v55 = sub_1B186503C((uint64_t)v46, (uint64_t)v47, v48, v49, v50, v51, v52, v53);
      v63 = sub_1B1866598(v54, v56, v57, v58, v59, v60, v61, v62) != 0;
    }
    else
    {
      v55 = 0;
      v63 = 0;
    }
    v64 = (void *)objc_msgSend_defaultCenter(MEMORY[0x1E0CB37D0], v47, v48, v49);
    v72 = sub_1B17C6244(v11, v65, v66, v67, v68, v69, v70, v71);
    objc_msgSend_postNotificationName_object_(v64, v73, (uint64_t)CFSTR("kCFXWorldDidUpdateNotification"), v72);
    v74 = v55 != v30 || v63;
    if (v74 || v38)
    {
      v75 = (const void *)sub_1B17C6244(v11, v39, v40, v41, v42, v43, v44, v45);
      sub_1B194F874(CFSTR("kCFXNotificationEngineContextInvalidatePasses"), v75, 0, 1u);
    }
  }
  if ((v10 & 1) == 0)
    sub_1B18797B4(v9, v39, v40, v41, v42, v43, v44, v45);
}

float sub_1B18B1E54(float a1, double a2)
{
  double v3;
  float v4;
  float v5;

  v3 = __tanpi(a1 / 360.0);
  v4 = atan(v3 * a2);
  if (v4 < 0.0)
  {
    v5 = 3.14159265 - v4;
    v4 = v5;
  }
  return v4 * 114.591559;
}

float sub_1B18B1EC0(float a1, double a2)
{
  double v3;
  float v4;
  float v5;

  v3 = __tanpi(a1 / 360.0);
  v4 = atan(v3 / a2);
  if (v4 < 0.0)
  {
    v5 = 3.14159265 - v4;
    v4 = v5;
  }
  return v4 * 114.591559;
}

CFTypeRef sub_1B18B1FBC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (const void *)objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  return sub_1B18148C4(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 184), v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B18B273C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;

  v8 = sub_1B1814A78(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v8)
    return 0;
  if ((*(_WORD *)(v8 + 252) & 0x200) == 0)
  {
    if ((*(_WORD *)(v8 + 256) & 0x200) == 0)
      return 0;
    v8 = *(_QWORD *)(v8 + 296);
  }
  return MEMORY[0x1E0DE7D20](v8, sel__wantsCustomMainPassProcessForRenderer_, v8, v9);
}

uint64_t sub_1B18B2778(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  const char *v10;
  uint64_t v11;

  result = sub_1B1814A78(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    if ((*(_WORD *)(result + 252) & 0x200) != 0)
    {
      v11 = 0;
      result = objc_msgSend__customMainPassProcessUsesExtraRenderTargetForRenderer_pixelFormat_((void *)result, v10, result, (uint64_t)&v11);
    }
    else
    {
      if ((*(_WORD *)(result + 256) & 0x200) == 0)
        return 0;
      v11 = 0;
      result = objc_msgSend__customMainPassProcessUsesExtraRenderTargetForRenderer_pixelFormat_(*(void **)(result + 296), v10, result, (uint64_t)&v11);
    }
    *a2 = v11;
  }
  return result;
}

uint64_t sub_1B18B27E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;

  v9 = sub_1B1814A78(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v9)
    return 0;
  v10 = v9;
  if ((*(_WORD *)(v9 + 252) & 0x200) == 0)
  {
    if ((*(_WORD *)(v9 + 256) & 0x200) == 0)
      return 0;
    v9 = *(_QWORD *)(v9 + 296);
  }
  return MEMORY[0x1E0DE7D20](v9, sel__usesSpecificMainPassClearColorForRenderer_clearColor_, v10, a2);
}

BOOL sub_1B18B28E4(uint64_t a1, void *a2, _BYTE *a3, uint64_t a4)
{
  uint64_t v5;

  v5 = objc_msgSend_camera(a2, (const char *)a2, (uint64_t)a3, a4);
  if (v5)
    *a3 = 1;
  return v5 != 0;
}

void sub_1B18B2AAC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t *v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(uint64_t **)(v4 + 184);
  if (v5)
  {
    v6 = (const void *)objc_msgSend_worldRef(*(void **)(v4 + 8), a2, a3, a4);
    sub_1B18155AC(v5, v6, v7, v8, v9, v10, v11, v12);
  }
}

uint64_t sub_1B18B2AEC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1B18B2BBC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t *v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(uint64_t **)(v4 + 184);
  if (v5)
  {
    v6 = (const void *)objc_msgSend_worldRef(*(void **)(v4 + 8), a2, a3, a4);
    sub_1B18155AC(v5, v6, v7, v8, v9, v10, v11, v12);
  }
}

uint64_t sub_1B18B31B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id *v18;
  id *v19;
  uint64_t v20;

  result = sub_1B1814A78(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v17 = result;
    v18 = (id *)sub_1B1813884(a1, v10, v11, v12, v13, v14, v15, v16);
    v19 = sub_1B193E758(v18);
    return MEMORY[0x1E0DE7D20](v17, sel__willRenderWorld_, v19, v20);
  }
  return result;
}

uint64_t sub_1B18B31FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id *v18;
  id *v19;
  uint64_t v20;

  result = sub_1B1814A78(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v17 = result;
    v18 = (id *)sub_1B1813884(a1, v10, v11, v12, v13, v14, v15, v16);
    v19 = sub_1B193E758(v18);
    return MEMORY[0x1E0DE7D20](v17, sel__didRenderWorld_, v19, v20);
  }
  return result;
}

uint64_t sub_1B18B3244(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;

  result = sub_1B1814A78(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
    return MEMORY[0x1E0DE7D20](result, sel__readSubdivCacheForHash_, a2, v10);
  return result;
}

uint64_t sub_1B18B3278(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  result = sub_1B1814A78(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
    return MEMORY[0x1E0DE7D20](result, sel__writeSubdivCacheForHash_dataProvider_, a2, a3);
  return result;
}

uint64_t sub_1B18B32B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  const char *v10;
  uint64_t v11;

  result = sub_1B1814A78(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v11 = result;
    if ((*(_WORD *)(result + 252) & 0x200) != 0)
      result = objc_msgSend__encodeCustomMainPassProcessForRenderer_atTime_helper_((void *)result, v10, result, a2, *(double *)(result + 128));
    if ((*(_WORD *)(v11 + 256) & 0x200) != 0)
      return objc_msgSend__encodeCustomMainPassProcessForRenderer_atTime_helper_(*(void **)(v11 + 296), v10, *(_QWORD *)(v11 + 296), a2, *(double *)(v11 + 128));
  }
  return result;
}

void sub_1B18B4750(_Unwind_Exception *a1)
{
  prof_endFlame();
  _Unwind_Resume(a1);
}

uint64_t sub_1B18B4EA8(uint64_t result, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  if (a3 >= 1)
  {
    v20 = v9;
    v21 = v8;
    v22 = v7;
    v23 = v6;
    v24 = v5;
    v25 = v4;
    v26 = v10;
    v27 = v11;
    v12 = a3;
    v13 = (uint64_t *)a2;
    v14 = result;
    do
    {
      v15 = *(void **)(v14 + 32);
      v16 = *v13++;
      v17 = objc_msgSend_nodeWithNodeRef_(VFXNode, a2, v16, a4, v20, v21, v22, v23, v24, v25, v26, v27);
      result = objc_msgSend_addObject_(v15, v18, v17, v19);
      --v12;
    }
    while (v12);
  }
  return result;
}

void sub_1B18B52F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B1814BD0(*(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_1B18B5390(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B1814C8C(*(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

double sub_1B18B543C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double result;

  *(_QWORD *)&result = sub_1B1814D90(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), a3, a4, a5, a6, a7, a8).n128_u64[0];
  return result;
}

_QWORD *sub_1B18B58D0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 184);
  v5 = objc_msgSend_nodeRef(*(void **)(a1 + 40), a2, a3, a4);
  return sub_1B19496A8(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B18B6C54(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  void *v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t i;
  void *v35;
  void *v36;
  uint64_t isHidden;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t *v54;
  const char *v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  const char *v64;
  uint64_t v65;
  unint64_t v66;
  void *v67;
  const char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  void *v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  const char *v85;
  uint64_t v86;
  uint64_t v87;
  _QWORD block[5];
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  _BYTE v93[128];
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v5 = (void *)objc_msgSend_world(*(void **)(a1 + 32), a2, a3, a4);
  v9 = (void *)objc_msgSend_rootNode(v5, v6, v7, v8);
  objc_msgSend_childNodesPassingTest_(v9, v10, (uint64_t)&unk_1E63D8538, v11);
  v15 = (void *)objc_msgSend_world(*(void **)(a1 + 32), v12, v13, v14);
  v19 = (void *)objc_msgSend_rootNode(v15, v16, v17, v18);
  v22 = (void *)objc_msgSend_childNodesPassingTest_(v19, v20, (uint64_t)&unk_1E63D8558, v21);
  v26 = (void *)objc_msgSend_array(MEMORY[0x1E0C99DE8], v23, v24, v25);
  v89 = 0u;
  v90 = 0u;
  v91 = 0u;
  v92 = 0u;
  v28 = objc_msgSend_countByEnumeratingWithState_objects_count_(v22, v27, (uint64_t)&v89, (uint64_t)v93, 16);
  if (v28)
  {
    v32 = v28;
    v33 = *(_QWORD *)v90;
    do
    {
      for (i = 0; i != v32; ++i)
      {
        if (*(_QWORD *)v90 != v33)
          objc_enumerationMutation(v22);
        v35 = *(void **)(*((_QWORD *)&v89 + 1) + 8 * i);
        v36 = (void *)MEMORY[0x1E0CB37E8];
        isHidden = objc_msgSend_isHidden(v35, v29, v30, v31);
        v40 = objc_msgSend_numberWithBool_(v36, v38, isHidden, v39);
        objc_msgSend_addObject_(v26, v41, v40, v42);
        v46 = objc_msgSend_nodeRef(v35, v43, v44, v45);
        sub_1B186A51C(v46, 1, v47, v48, v49, v50, v51, v52);
      }
      v32 = objc_msgSend_countByEnumeratingWithState_objects_count_(v22, v29, (uint64_t)&v89, (uint64_t)v93, 16);
    }
    while (v32);
  }
  objc_msgSend_updateAtTime_(*(void **)(a1 + 32), v29, v30, v31, *(double *)(*(_QWORD *)(a1 + 32) + 128));
  v53 = sub_1B1813E3C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184));
  v54 = (uint64_t *)sub_1B17A78E0();
  sub_1B19AADC8(v53, v54);
  objc_msgSend_beginFrame_(*(void **)(*(_QWORD *)(a1 + 32) + 240), v55, 0, v56);
  sub_1B19AA81C(v53, v57, v58, v59);
  objc_msgSend_endFrameWaitingUntilCompleted_status_error_(*(void **)(*(_QWORD *)(a1 + 32) + 240), v60, 1, 0, 0);
  if (objc_msgSend_count(v26, v61, v62, v63))
  {
    v66 = 0;
    do
    {
      v67 = (void *)objc_msgSend_objectAtIndexedSubscript_(v22, v64, v66, v65);
      v71 = objc_msgSend_nodeRef(v67, v68, v69, v70);
      v74 = (void *)objc_msgSend_objectAtIndexedSubscript_(v26, v72, v66, v73);
      v78 = objc_msgSend_BOOLValue(v74, v75, v76, v77);
      sub_1B186A51C(v71, v78, v79, v80, v81, v82, v83, v84);
      ++v66;
    }
    while (v66 < objc_msgSend_count(v26, v85, v86, v87));
  }
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_1B18B6FAC;
  block[3] = &unk_1E63D8580;
  block[4] = *(_QWORD *)(a1 + 48);
  dispatch_async(MEMORY[0x1E0C80D38], block);
}

uint64_t sub_1B18B6EC0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;

  result = objc_msgSend_light(a2, (const char *)a2, a3, a4);
  if (result)
  {
    v9 = objc_msgSend_nodeRef(a2, v6, v7, v8);
    if (sub_1B186C66C(v9, v10, v11, v12, v13, v14, v15, v16))
    {
      return 0;
    }
    else
    {
      v20 = (void *)objc_msgSend_light(a2, v17, v18, v19);
      result = objc_msgSend_isBaked(v20, v21, v22, v23);
      if ((_DWORD)result)
      {
        v27 = (void *)objc_msgSend_light(a2, v24, v25, v26);
        if (objc_msgSend_type(v27, v28, v29, v30) == 2)
        {
          return 1;
        }
        else
        {
          v34 = (void *)objc_msgSend_light(a2, v31, v32, v33);
          result = objc_msgSend_type(v34, v35, v36, v37);
          if (result != 1)
          {
            v41 = (void *)objc_msgSend_light(a2, v38, v39, v40);
            return objc_msgSend_type(v41, v42, v43, v44) == 3;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1B18B6F54(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;

  result = objc_msgSend_light(a2, (const char *)a2, a3, a4);
  if (result)
  {
    v9 = (void *)objc_msgSend_light(a2, v6, v7, v8);
    result = 0;
    if (objc_msgSend_type(v9, v10, v11, v12) == 4)
    {
      v16 = (void *)objc_msgSend_light(a2, v13, v14, v15);
      if (!objc_msgSend_probeType(v16, v17, v18, v19))
        return 1;
    }
  }
  return result;
}

uint64_t sub_1B18B6FAC(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(void))(result + 16))();
  return result;
}

uint64_t sub_1B18B7024(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  id v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;

  v5 = objc_msgSend__engineContext(*(void **)(a1 + 32), a2, a3, a4);
  result = objc_msgSend_isAborting(*(void **)(a1 + 40), v6, v7, v8);
  if ((result & 1) == 0)
  {
    objc_msgSend_lock(*(void **)(a1 + 32), v10, v11, v12);
    v20 = sub_1B1813884(v5, v13, v14, v15, v16, v17, v18, v19);
    sub_1B187973C(v20, v21, v22, v23, v24, v25, v26, v27);
    sub_1B1815D90(v5, 1);
    sub_1B1815DB8(v5, *(_DWORD *)(a1 + 48));
    sub_1B1815DC8(v5, *(_BYTE *)(a1 + 56));
    v28 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
    objc_msgSend__beginFrame(*(void **)(a1 + 32), v29, v30, v31);
    objc_msgSend__render(*(void **)(a1 + 32), v32, v33, v34);
    sub_1B1815DC8(v5, 1);
    sub_1B1815D90(v5, 0);
    objc_msgSend__endFrame(*(void **)(a1 + 32), v35, v36, v37);
    sub_1B18797B4(v20, v38, v39, v40, v41, v42, v43, v44);
    if (*(_BYTE *)(a1 + 57))
      objc_msgSend__jitterRedisplay(*(void **)(*(_QWORD *)(a1 + 32) + 296), v45, v46, v47);
    objc_msgSend_drain(v28, v45, v46, v47);
    return objc_msgSend_unlock(*(void **)(a1 + 32), v48, v49, v50);
  }
  return result;
}

uint64_t sub_1B18B717C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 240), sel_addCommandBufferScheduledHandler_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18B71E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 240), sel_addCommandBufferCompletedHandler_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18B72A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 240), sel_addDrawablePresentedHandler_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18B730C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 240), sel__allowGPUBackgroundExecution, a3, a4);
}

void sub_1B18B7498(uint64_t a1)
{
  sub_1B1813DD0(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 32), *(void **)(a1 + 40));
}

uint64_t CFXGetSharedCommandQueueForDevice(uint64_t a1)
{
  void *v1;

  v1 = sub_1B18F8C8C((uint64_t)VFXMTLResourceManager, a1);
  return sub_1B18FD780((uint64_t)v1);
}

const void *sub_1B18B7594(void *a1)
{
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  const void *v6;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
    return 0;
  v5 = (const void *)objc_msgSend_CGImage(a1, v2, v3, v4);
  v6 = v5;
  if (v5)
    CFRetain(v5);
  return v6;
}

void VFXSetPerformanceStatisticsEnabled(int a1)
{
  if (qword_1ED4C1EE8 != -1)
    dispatch_once(&qword_1ED4C1EE8, &unk_1E63D0F50);
  if ((byte_1EEF66078 != 0) != a1)
  {
    byte_1EEF66078 = a1;
    if (a1)
    {
      if (qword_1EEF660B0 != -1)
        dispatch_once(&qword_1EEF660B0, &unk_1E63D86D0);
    }
  }
}

uint64_t sub_1B18B7680()
{
  if (qword_1ED4C1EE8 != -1)
    dispatch_once(&qword_1ED4C1EE8, &unk_1E63D0F50);
  return byte_1EEF66078;
}

void sub_1B18B76C0()
{
  char *v0;

  v0 = getenv("VFX_ENABLE_COLLECTION");
  if (v0 && !strcmp(v0, "YES"))
  {
    byte_1EEF66078 = 1;
    if (qword_1EEF660B0 != -1)
      dispatch_once(&qword_1EEF660B0, &unk_1E63D86D0);
  }
}

float sub_1B18B7724(uint64_t a1, _BYTE *a2, int a3)
{
  double v3;
  float v4;
  _BYTE *v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float result;

  *a2 = 2;
  v3 = *(double *)(a1 + 328);
  if (v3 == 0.0)
    v4 = 0.0;
  else
    v4 = 1.0 / v3;
  v5 = &a2[52 * a3];
  *((_DWORD *)v5 + 1) = *(_DWORD *)(a1 + 4);
  *((_DWORD *)v5 + 2) = vcvtas_u32_f32(v4);
  v6.f64[0] = *(float64_t *)(a1 + 96);
  v7.f64[0] = *(float64_t *)(a1 + 120);
  v8.f64[0] = *(float64_t *)(a1 + 168);
  v7.f64[1] = *(double *)(a1 + 128) + *(double *)(a1 + 136) + *(double *)(a1 + 144);
  v6.f64[1] = *(float64_t *)(a1 + 112);
  *(float32x4_t *)(v5 + 12) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v6), v7);
  v6.f64[0] = *(float64_t *)(a1 + 152);
  v8.f64[1] = *(float64_t *)(a1 + 184);
  v6.f64[1] = *(float64_t *)(a1 + 104);
  *(float32x4_t *)(v5 + 28) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v6), v8);
  *(float *)v6.f64 = *(double *)(a1 + 192);
  *((_DWORD *)v5 + 11) = LODWORD(v6.f64[0]);
  result = *(double *)(a1 + 288);
  *((float *)v5 + 13) = result;
  *((_DWORD *)v5 + 12) = *(_DWORD *)(a1 + 280);
  a2[1] = a3;
  return result;
}

void sub_1B18B77D8(uint64_t a1)
{
  if (qword_1EEF66080 != -1)
    dispatch_once(&qword_1EEF66080, &unk_1E63D1970);
  os_unfair_lock_lock((os_unfair_lock_t)&dword_1EEF66088);
  sub_1B18B7724(a1, &_vfxPerformanceData, (byte_1EEFD4E05 & 1) == 0);
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_1EEF66088);
}

void sub_1B18B784C()
{
  dword_1EEF66088 = 0;
}

__n128 VFXGetPerformanceStatistics@<Q0>(_OWORD *a1@<X8>)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __n128 result;

  if (qword_1EEF66080 != -1)
    dispatch_once(&qword_1EEF66080, &unk_1E63D1A30);
  os_unfair_lock_lock((os_unfair_lock_t)&dword_1EEF66088);
  v2 = unk_1EEFD4E54;
  a1[4] = xmmword_1EEFD4E44;
  a1[5] = v2;
  *(_OWORD *)((char *)a1 + 92) = unk_1EEFD4E60;
  v3 = unk_1EEFD4E14;
  *a1 = _vfxPerformanceData;
  a1[1] = v3;
  v4 = unk_1EEFD4E34;
  a1[2] = xmmword_1EEFD4E24;
  a1[3] = v4;
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_1EEF66088);
  return result;
}

void sub_1B18B78D8()
{
  dword_1EEF66088 = 0;
}

void *VFXGetPerformanceStatisticsAsPlist()
{
  uint64_t v0;
  uint64_t v1;
  _OWORD v3[7];

  memset(v3, 0, 108);
  VFXGetPerformanceStatistics(v3);
  return sub_1B18B7924((unsigned __int8 *)v3, (const char *)BYTE1(v3[0]), v0, v1);
}

void *sub_1B18B7924(unsigned __int8 *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  int v4;
  void *v6;
  unsigned int *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  double v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  double v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  double v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  double v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  double v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  double v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  double v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  double v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  double v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  const char *v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  double v73;
  unsigned __int8 *v74;
  uint64_t v75;
  const char *v76;
  const char *v77;
  uint64_t v78;
  uint64_t v79;
  const char *v80;
  const char *v81;
  void *v82;
  const char *v83;
  uint64_t v84;
  uint64_t v85;
  const char *v86;
  const char *v87;
  uint64_t v88;
  uint64_t v89;
  const char *v90;
  const char *v91;
  uint64_t v92;
  uint64_t v93;
  const char *v94;

  v4 = (int)a2;
  v6 = (void *)objc_msgSend_dictionary(MEMORY[0x1E0C99E08], a2, a3, a4);
  v7 = (unsigned int *)&a1[52 * v4];
  v10 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v8, v7[2], v9);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v11, v10, (uint64_t)CFSTR("vfx.fps"));
  v14 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v12, v7[1], v13);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v15, v14, (uint64_t)CFSTR("vfx.primcnt"));
  LODWORD(v16) = v7[3];
  v20 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v17, v18, v19, v16);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v21, v20, (uint64_t)CFSTR("vfx.frmtime"));
  LODWORD(v22) = v7[4];
  v26 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v23, v24, v25, v22);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v27, v26, (uint64_t)CFSTR("vfx.phytime"));
  LODWORD(v28) = v7[5];
  v32 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v29, v30, v31, v28);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v33, v32, (uint64_t)CFSTR("vfx.prttime"));
  LODWORD(v34) = v7[6];
  v38 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v35, v36, v37, v34);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v39, v38, (uint64_t)CFSTR("vfx.animtime"));
  LODWORD(v40) = v7[9];
  v44 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v41, v42, v43, v40);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v45, v44, (uint64_t)CFSTR("vfx.clientTime"));
  LODWORD(v46) = v7[7];
  v50 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v47, v48, v49, v46);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v51, v50, (uint64_t)CFSTR("vfx.rendertime"));
  LODWORD(v52) = v7[8];
  v56 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v53, v54, v55, v52);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v57, v56, (uint64_t)CFSTR("vfx.consttime"));
  LODWORD(v58) = v7[10];
  v62 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v59, v60, v61, v58);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v63, v62, (uint64_t)CFSTR("vfx.cpuidletime"));
  LODWORD(v64) = v7[11];
  v68 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v65, v66, v67, v64);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v69, v68, (uint64_t)CFSTR("vfx.cawaittime"));
  if (*a1 < 2u)
  {
    objc_msgSend_setObject_forKeyedSubscript_(v6, v70, (uint64_t)&unk_1E6478BB0, (uint64_t)CFSTR("vfx.shaderCompilationTime"));
    objc_msgSend_setObject_forKeyedSubscript_(v6, v81, (uint64_t)&unk_1E6478BB0, (uint64_t)CFSTR("vfx.shaderGenerationCount"));
  }
  else
  {
    v74 = &a1[52 * v4];
    LODWORD(v73) = *((_DWORD *)v74 + 13);
    v75 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v70, v71, v72, v73);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v76, v75, (uint64_t)CFSTR("vfx.shaderCompilationTime"));
    v79 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v77, *((unsigned int *)v74 + 12), v78);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v80, v79, (uint64_t)CFSTR("vfx.shaderGenerationCount"));
  }
  v82 = (void *)sub_1B18B7BD0();
  v85 = objc_msgSend_objectForKeyedSubscript_(v82, v83, (uint64_t)CFSTR("Device Utilization %"), v84);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v86, v85, (uint64_t)CFSTR("vfx.deviceutil"));
  v89 = objc_msgSend_objectForKeyedSubscript_(v82, v87, (uint64_t)CFSTR("Renderer Utilization %"), v88);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v90, v89, (uint64_t)CFSTR("vfx.rendererutil"));
  v93 = objc_msgSend_objectForKeyedSubscript_(v82, v91, (uint64_t)CFSTR("Tiler Utilization %"), v92);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v94, v93, (uint64_t)CFSTR("vfx.tilerutil"));

  return v6;
}

uint64_t sub_1B18B7BD0()
{
  const char *v0;
  uint64_t v1;
  uint64_t v2;
  double v3;
  io_registry_entry_t v4;
  mach_port_t v5;
  const __CFDictionary *v6;
  CFTypeRef CFProperty;
  uint64_t v8;
  io_iterator_t existing;

  v3 = CACurrentMediaTime();
  if (v3 - *(double *)&qword_1EEF55830 > 1.0)
  {
    v4 = dword_1EEF6608C;
    if (!dword_1EEF6608C)
    {
      existing = 0;
      v5 = *MEMORY[0x1E0CBBAA8];
      v6 = IOServiceMatching("IOAcceleratorES");
      if (!IOServiceGetMatchingServices(v5, v6, &existing))
        dword_1EEF6608C = IOIteratorNext(existing);
      IOObjectRelease(existing);
      v4 = dword_1EEF6608C;
    }
    CFProperty = IORegistryEntryCreateCFProperty(v4, CFSTR("PerformanceStatistics"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (CFProperty)
    {
      v8 = (uint64_t)CFProperty;
      if (qword_1EEF66090)
        CFRelease((CFTypeRef)qword_1EEF66090);
      qword_1EEF66090 = v8;
    }
    qword_1EEF55830 = *(_QWORD *)&v3;
  }
  return objc_msgSend_copy((void *)qword_1EEF66090, v0, v1, v2);
}

uint64_t _VFXStartCollectingPerformanceStatisticsForPid(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t mapped_memory_cache_for_task;
  unsigned __int8 v8;
  char *v9;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  __n128 (*v14)(__n128 *, __n128 *);
  uint64_t (*v15)();
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int *v20;

  v19 = a1;
  v1 = CSSymbolicatorCreateWithPid();
  v3 = v2;
  if ((CSIsNull() & 1) != 0)
    return 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x4012000000;
  v14 = sub_1B18B7EA4;
  v15 = nullsub_79;
  v18 = 0;
  v16 = "";
  v17 = 0;
  CSSymbolicatorForeachSymbolWithMangledNameAtTime();
  v5 = v12[6];
  v6 = v12[7];
  if (CSIsNull()
    || (CSSymbolicatorGetTask(), (mapped_memory_cache_for_task = create_mapped_memory_cache_for_task()) == 0))
  {
    CSRelease();
    v4 = 0;
  }
  else
  {
    v8 = atomic_load((unsigned __int8 *)&qword_1EEF660E0);
    if ((v8 & 1) == 0 && __cxa_guard_acquire(&qword_1EEF660E0))
    {
      xmmword_1EEF660B8 = 0u;
      unk_1EEF660C8 = 0u;
      dword_1EEF660D8 = 1065353216;
      __cxa_atexit((void (*)(void *))sub_1B18B7FF0, &xmmword_1EEF660B8, &dword_1B178D000);
      __cxa_guard_release(&qword_1EEF660E0);
    }
    v20 = &v19;
    v9 = sub_1B18B8764((uint64_t)&xmmword_1EEF660B8, &v19, (uint64_t)&unk_1B22458B0, &v20);
    *((_QWORD *)v9 + 3) = v1;
    *((_QWORD *)v9 + 4) = v3;
    *((_QWORD *)v9 + 5) = v5;
    *((_QWORD *)v9 + 6) = v6;
    v4 = 1;
    *((_QWORD *)v9 + 7) = mapped_memory_cache_for_task;
  }
  _Block_object_dispose(&v11, 8);
  return v4;
}

void sub_1B18B7E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 sub_1B18B7EA4(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

uint64_t sub_1B18B7EB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  result = CSIsNull();
  if ((result & 1) == 0)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_QWORD *)(v7 + 48) = a2;
    *(_QWORD *)(v7 + 56) = a3;
  }
  return result;
}

uint64_t _VFXStopCollectingPerformanceStatisticsForPid(int a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  _QWORD v4[5];
  int v5;

  v5 = a1;
  v1 = atomic_load((unsigned __int8 *)&qword_1EEF660E0);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_1EEF660E0))
  {
    xmmword_1EEF660B8 = 0u;
    unk_1EEF660C8 = 0u;
    dword_1EEF660D8 = 1065353216;
    __cxa_atexit((void (*)(void *))sub_1B18B7FF0, &xmmword_1EEF660B8, &dword_1B178D000);
    __cxa_guard_release(&qword_1EEF660E0);
  }
  sub_1B18B8990((uint64_t)v4, (uint64_t)&xmmword_1EEF660B8);
  v2 = sub_1B18B8C24(v4, &v5);
  if (v2)
  {
    destroy_mapped_memory_cache();
    v2[5] = 0;
    v2[6] = 0;
    v2[7] = 0;
    CSRelease();
    v2[3] = 0;
    v2[4] = 0;
    sub_1B179C954(v4, v2);
  }
  sub_1B185B888((uint64_t)v4);
  return 1;
}

void sub_1B18B7FD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1B185B888((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t *_VFXGetPerformanceStatisticsForPid(int a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  _QWORD v4[5];
  int v5;

  v5 = a1;
  v1 = atomic_load((unsigned __int8 *)&qword_1EEF660E0);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_1EEF660E0))
  {
    xmmword_1EEF660B8 = 0u;
    unk_1EEF660C8 = 0u;
    dword_1EEF660D8 = 1065353216;
    __cxa_atexit((void (*)(void *))sub_1B18B7FF0, &xmmword_1EEF660B8, &dword_1B178D000);
    __cxa_guard_release(&qword_1EEF660E0);
  }
  sub_1B18B8990((uint64_t)v4, (uint64_t)&xmmword_1EEF660B8);
  v2 = sub_1B18B8C24(v4, &v5);
  if (v2)
  {
    if (CSSymbolGetRange())
    {
      clear_mapped_memory();
      v2 = 0;
      mapped_memory_read();
    }
    else
    {
      v2 = 0;
    }
  }
  sub_1B185B888((uint64_t)v4);
  return v2;
}

void sub_1B18B80F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_1B185B888((uint64_t)va);
  _Unwind_Resume(a1);
}

void *_VFXGetCollectedShadersForPid()
{
  const char *v0;
  uint64_t v1;
  void *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  void *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  void *v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t i;
  void *v32;
  uint64_t v33;
  void *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  void *v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  void *v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t (*v61)(uint64_t, uint64_t, uint64_t);
  void *v62;
  _QWORD *v63;
  _QWORD v64[8];
  _BYTE v65[128];
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  CSSymbolicatorCreateWithPid();
  if ((CSIsNull() & 1) != 0)
  {
    v2 = &unk_1E6478BC0;
  }
  else
  {
    v64[0] = 0;
    v64[1] = v64;
    v64[2] = 0x4012000000;
    v64[3] = sub_1B18B7EA4;
    v64[4] = nullsub_79;
    v64[7] = 0;
    v64[5] = "";
    v64[6] = 0;
    v59 = MEMORY[0x1E0C809B0];
    v60 = 3221225472;
    v61 = sub_1B18B871C;
    v62 = &unk_1E63D8690;
    v63 = v64;
    CSSymbolicatorForeachSymbolWithMangledNameAtTime();
    if (CSIsNull())
    {
      CSRelease();
      v2 = &unk_1E6478BE8;
    }
    else
    {
      CSSymbolicatorGetTask();
      if (create_mapped_memory_cache_for_task())
      {
        if (CSSymbolGetRange())
        {
          clear_mapped_memory();
          v58 = 0;
          v2 = &unk_1E6478C60;
          mapped_memory_read();
        }
        else
        {
          v2 = &unk_1E6478C38;
        }
      }
      else
      {
        CSRelease();
        v2 = &unk_1E6478C10;
      }
    }
    _Block_object_dispose(v64, 8);
  }
  v53 = v2;
  if (objc_msgSend_valueForKey_(v2, v0, (uint64_t)CFSTR("containerPath"), v1))
  {
    v6 = (void *)objc_msgSend_defaultManager(MEMORY[0x1E0CB3620], v3, v4, v5);
    v10 = (void *)objc_msgSend_temporaryDirectory(v6, v7, v8, v9);
    v13 = (void *)objc_msgSend_URLByAppendingPathComponent_(v10, v11, (uint64_t)CFSTR("VFXShaderCache"), v12);
    v17 = (void *)objc_msgSend_path(v13, v14, v15, v16);
    v53 = (void *)objc_msgSend_dictionary(MEMORY[0x1E0C99E08], v18, v19, v20);
    v52 = (void *)objc_msgSend_defaultManager(MEMORY[0x1E0CB3620], v21, v22, v23);
    v56 = 0u;
    v57 = 0u;
    v54 = 0u;
    v55 = 0u;
    v25 = (void *)objc_msgSend_contentsOfDirectoryAtPath_error_(v52, v24, (uint64_t)v17, 0);
    v29 = objc_msgSend_countByEnumeratingWithState_objects_count_(v25, v26, (uint64_t)&v54, (uint64_t)v65, 16);
    if (v29)
    {
      v30 = *(_QWORD *)v55;
      do
      {
        for (i = 0; i != v29; ++i)
        {
          if (*(_QWORD *)v55 != v30)
            objc_enumerationMutation(v25);
          v32 = *(void **)(*((_QWORD *)&v54 + 1) + 8 * i);
          if (objc_msgSend_hasPrefix_(v32, v27, (uint64_t)CFSTR("commonProfile_"), v28))
          {
            v34 = (void *)objc_msgSend_pathExtension(v32, v27, v33, v28);
            if (objc_msgSend_isEqualToString_(v34, v35, (uint64_t)CFSTR("metal"), v36))
            {
              v37 = objc_msgSend_stringByAppendingPathComponent_(v17, v27, (uint64_t)v32, v28);
              v39 = objc_msgSend_stringWithContentsOfFile_encoding_error_(MEMORY[0x1E0CB3940], v38, v37, 4, 0);
              v42 = (void *)objc_msgSend_substringFromIndex_(v32, v40, 14, v41);
              v46 = objc_msgSend_stringByDeletingPathExtension(v42, v43, v44, v45);
              if (v39)
              {
                v28 = v46;
                if (v46)
                {
                  objc_msgSend_setValue_forKey_(v53, v27, v39, v46);
                  v49 = objc_msgSend_fileURLWithPath_(MEMORY[0x1E0C99E98], v47, v37, v48);
                  objc_msgSend_removeItemAtURL_error_(v52, v50, v49, 0);
                }
              }
            }
          }
        }
        v29 = objc_msgSend_countByEnumeratingWithState_objects_count_(v25, v27, (uint64_t)&v54, (uint64_t)v65, 16);
      }
      while (v29);
    }
  }
  return v53;
}

void sub_1B18B8520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VFXGetShaderCollectionOutputURL(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;

  v4 = (void *)objc_msgSend_defaultManager(MEMORY[0x1E0CB3620], a2, a3, a4);
  v8 = (void *)objc_msgSend_temporaryDirectory(v4, v5, v6, v7);
  return objc_msgSend_URLByAppendingPathComponent_(v8, v9, (uint64_t)CFSTR("VFXShaderCache"), v10);
}

CFTypeRef VFXSetShaderCollectionEnabled(CFTypeRef result, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  if (byte_1EEF66098 != (_DWORD)result)
  {
    byte_1EEF66098 = (char)result;
    if ((_DWORD)result)
    {
      v4 = (void *)objc_msgSend_defaultManager(MEMORY[0x1E0CB3620], a2, a3, a4);
      v8 = (void *)objc_msgSend_temporaryDirectory(v4, v5, v6, v7);
      v11 = (void *)objc_msgSend_URLByAppendingPathComponent_(v8, v9, (uint64_t)CFSTR("VFXShaderCache"), v10);
      v15 = (void *)objc_msgSend_defaultManager(MEMORY[0x1E0CB3620], v12, v13, v14);
      v19 = objc_msgSend_path(v11, v16, v17, v18);
      if (objc_msgSend_fileExistsAtPath_(v15, v20, v19, v21))
        objc_msgSend_removeItemAtURL_error_(v15, v22, (uint64_t)v11, 0);
      v29 = 0;
      if ((objc_msgSend_createDirectoryAtURL_withIntermediateDirectories_attributes_error_(v15, v22, (uint64_t)v11, 1, 0, &v29) & 1) == 0)
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: unable to create the shader cache folder at %@ (%@)"), v23, v24, v25, v26, v27, v28, (uint64_t)v11);
        v11 = 0;
      }
      return sub_1B17A01FC(v11);
    }
  }
  return result;
}

BOOL sub_1B18B864C()
{
  if (byte_1EEF66098)
    return 1;
  if (qword_1EEF660A0 != -1)
    dispatch_once(&qword_1EEF660A0, &unk_1E63D86B0);
  return byte_1EEF660A8 != 0;
}

uint64_t sub_1B18B86A8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t result;

  v4 = (void *)objc_msgSend_standardUserDefaults(MEMORY[0x1E0C99EA0], a2, a3, a4);
  result = objc_msgSend_BOOLForKey_(v4, v5, (uint64_t)CFSTR("com.apple.vfx.traceResources"), v6);
  byte_1EEF660A8 = result;
  return result;
}

char *sub_1B18B86D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  void *PathComponent;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  char *result;

  v4 = (void *)objc_msgSend_defaultManager(MEMORY[0x1E0CB3620], a2, a3, a4);
  v8 = (void *)objc_msgSend_temporaryDirectory(v4, v5, v6, v7);
  v12 = (void *)objc_msgSend_path(v8, v9, v10, v11);
  PathComponent = (void *)objc_msgSend_stringByDeletingLastPathComponent(v12, v13, v14, v15);
  v20 = (const char *)objc_msgSend_UTF8String(PathComponent, v17, v18, v19);
  result = strncpy(byte_1EEFD4D01, v20, 0x100uLL);
  result[256] = 0;
  return result;
}

uint64_t sub_1B18B871C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  result = CSIsNull();
  if ((result & 1) == 0)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_QWORD *)(v7 + 48) = a2;
    *(_QWORD *)(v7 + 56) = a3;
  }
  return result;
}

char *sub_1B18B8764(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  char *v11;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = (char *)*v10;
      if (*v10)
      {
        do
        {
          v12 = *((_QWORD *)v11 + 1);
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = *(char **)v11;
        }
        while (v11);
      }
    }
  }
  v11 = (char *)operator new(0x40uLL);
  *(_QWORD *)v11 = 0;
  *((_QWORD *)v11 + 1) = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_QWORD *)v11 + 7) = 0;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    sub_1B179C4B4(a1, v18);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v20)
  {
    *(_QWORD *)v11 = *v20;
LABEL_38:
    *v20 = v11;
    goto LABEL_39;
  }
  *(_QWORD *)v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v19 + 8 * v4) = a1 + 16;
  if (*(_QWORD *)v11)
  {
    v21 = *(_QWORD *)(*(_QWORD *)v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8)
        v21 %= v8;
    }
    else
    {
      v21 &= v8 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_1B18B897C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18B8990(uint64_t a1, uint64_t a2)
{
  int *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_1B179C4B4(a1, *(_QWORD *)(a2 + 8));
  for (i = *(int **)(a2 + 16); i; i = *(int **)i)
    sub_1B18B8A04(a1, i + 4, (_OWORD *)i + 1);
  return a1;
}

void sub_1B18B89EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B185B888(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1B18B8A04(uint64_t a1, int *a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  __int128 v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x40uLL);
  *v10 = 0;
  v10[1] = v6;
  v12 = a3[1];
  *((_OWORD *)v10 + 1) = *a3;
  *((_OWORD *)v10 + 2) = v12;
  *((_OWORD *)v10 + 3) = a3[2];
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    sub_1B179C4B4(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *v10 = *v20;
LABEL_38:
    *v20 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v19 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v21 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_1B18B8C10(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1B18B8C24(_QWORD *a1, int *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t **v6;
  uint64_t *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*(_QWORD *)&v2 <= v3)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  for (result = *v6; result; result = (uint64_t *)*result)
  {
    v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3)
        return result;
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(_QWORD *)&v2)
          v8 %= *(_QWORD *)&v2;
      }
      else
      {
        v8 &= *(_QWORD *)&v2 - 1;
      }
      if (v8 != v5)
        return 0;
    }
  }
  return result;
}

uint64_t sub_1B18B8F48(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  BOOL v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  float v28;
  double v29;

  result = objc_msgSend__sliderHandle(*(void **)(a1 + 48), a2, a3, a4);
  if (result)
  {
    v6 = result;
    v7 = *(float *)(a1 + 32);
    v8 = *(float *)(a1 + 36);
    v9 = *(float *)(a1 + 40);
    v10 = fabsf(v9) <= 0.70711;
    v11 = (float)(v8 * v8) + (float)(v7 * v7);
    v12 = 1.0 / sqrtf(v11);
    v13 = -(float)(v8 * v12);
    v14 = v7 * v12;
    v15 = -(float)(v9 * (float)(v7 * v12));
    v16 = v9 * v13;
    v17 = v11 * v12;
    v18 = 0.0;
    v19 = (float)(v9 * v9) + (float)(v8 * v8);
    v20 = 1.0 / sqrtf(v19);
    v21 = -(float)(v9 * v20);
    v22 = v8 * v20;
    v23 = v19 * v20;
    v24 = v7 * v21;
    if (v10)
    {
      v23 = v15;
    }
    else
    {
      v14 = v21;
      v13 = 0.0;
      v18 = v22;
      v16 = -(float)(v7 * v22);
    }
    LODWORD(v25) = *(_DWORD *)(a1 + 32);
    *((float *)&v25 + 1) = v13;
    HIDWORD(v27) = 0;
    *((_QWORD *)&v25 + 1) = LODWORD(v23);
    LODWORD(v26) = *(_DWORD *)(a1 + 36);
    *((float *)&v26 + 1) = v14;
    *((_QWORD *)&v26 + 1) = LODWORD(v16);
    LODWORD(v27) = *(_DWORD *)(a1 + 40);
    if (v10)
      v28 = v17;
    else
      v28 = v24;
    *((float *)&v27 + 1) = v18;
    *((float *)&v27 + 2) = v28;
    *(_OWORD *)(result + 80) = v25;
    *(_OWORD *)(result + 96) = v26;
    *(_OWORD *)(result + 112) = v27;
    v29 = sub_1B21F94C0((float32x4_t *)result, (float32x4_t *)(*(_QWORD *)(result + 40) + 16), (float32x4_t *)(*(_QWORD *)(result + 48) + 16));
    return (*(uint64_t (**)(uint64_t, double))(*(_QWORD *)v6 + 16))(v6, v29);
  }
  return result;
}

uint64_t sub_1B18B90E4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  BOOL v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  float v28;
  double v29;

  result = objc_msgSend__sliderHandle(*(void **)(a1 + 48), a2, a3, a4);
  if (result)
  {
    v6 = result;
    v7 = *(float *)(a1 + 32);
    v8 = *(float *)(a1 + 36);
    v9 = *(float *)(a1 + 40);
    v10 = fabsf(v9) <= 0.70711;
    v11 = (float)(v8 * v8) + (float)(v7 * v7);
    v12 = 1.0 / sqrtf(v11);
    v13 = -(float)(v8 * v12);
    v14 = v7 * v12;
    v15 = -(float)(v9 * (float)(v7 * v12));
    v16 = v9 * v13;
    v17 = v11 * v12;
    v18 = 0.0;
    v19 = (float)(v9 * v9) + (float)(v8 * v8);
    v20 = 1.0 / sqrtf(v19);
    v21 = -(float)(v9 * v20);
    v22 = v8 * v20;
    v23 = v19 * v20;
    v24 = v7 * v21;
    if (v10)
    {
      v23 = v15;
    }
    else
    {
      v14 = v21;
      v13 = 0.0;
      v18 = v22;
      v16 = -(float)(v7 * v22);
    }
    LODWORD(v25) = *(_DWORD *)(a1 + 32);
    *((float *)&v25 + 1) = v13;
    HIDWORD(v27) = 0;
    *((_QWORD *)&v25 + 1) = LODWORD(v23);
    LODWORD(v26) = *(_DWORD *)(a1 + 36);
    *((float *)&v26 + 1) = v14;
    *((_QWORD *)&v26 + 1) = LODWORD(v16);
    LODWORD(v27) = *(_DWORD *)(a1 + 40);
    if (v10)
      v28 = v17;
    else
      v28 = v24;
    *((float *)&v27 + 1) = v18;
    *((float *)&v27 + 2) = v28;
    *(_OWORD *)(result + 144) = v25;
    *(_OWORD *)(result + 160) = v26;
    *(_OWORD *)(result + 176) = v27;
    v29 = sub_1B21F94C0((float32x4_t *)result, (float32x4_t *)(*(_QWORD *)(result + 40) + 16), (float32x4_t *)(*(_QWORD *)(result + 48) + 16));
    return (*(uint64_t (**)(uint64_t, double))(*(_QWORD *)v6 + 16))(v6, v29);
  }
  return result;
}

uint64_t sub_1B18B9280(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  __int128 v7;
  double v8;

  result = objc_msgSend__sliderHandle(*(void **)(a1 + 48), a2, a3, a4);
  if (result)
  {
    v6 = result;
    v7 = *(_OWORD *)(a1 + 32);
    HIDWORD(v7) = 0;
    *(_OWORD *)(result + 128) = v7;
    v8 = sub_1B21F94C0((float32x4_t *)result, (float32x4_t *)(*(_QWORD *)(result + 40) + 16), (float32x4_t *)(*(_QWORD *)(result + 48) + 16));
    return (*(uint64_t (**)(uint64_t, double))(*(_QWORD *)v6 + 16))(v6, v8);
  }
  return result;
}

uint64_t sub_1B18B9370(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  __int128 v7;
  double v8;

  result = objc_msgSend__sliderHandle(*(void **)(a1 + 48), a2, a3, a4);
  if (result)
  {
    v6 = result;
    v7 = *(_OWORD *)(a1 + 32);
    HIDWORD(v7) = 0;
    *(_OWORD *)(result + 192) = v7;
    v8 = sub_1B21F94C0((float32x4_t *)result, (float32x4_t *)(*(_QWORD *)(result + 40) + 16), (float32x4_t *)(*(_QWORD *)(result + 48) + 16));
    return (*(uint64_t (**)(uint64_t, double))(*(_QWORD *)v6 + 16))(v6, v8);
  }
  return result;
}

float sub_1B18B9464(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  float result;

  v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    result = *(float *)(a1 + 40);
    *(float *)(v5 + 212) = result;
  }
  return result;
}

float sub_1B18B9528(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  float result;

  v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    result = *(float *)(a1 + 40);
    *(float *)(v5 + 216) = result;
  }
  return result;
}

void sub_1B18B95EC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  float v7;

  v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    v6 = v5;
    v7 = fmodf(*(float *)(a1 + 40), 6.2832);
    if (v7 >= -3.1416)
    {
      if (v7 > 3.1416)
        v7 = v7 + -6.2832;
    }
    else
    {
      v7 = v7 + 6.2832;
    }
    *(float *)(v6 + 220) = v7;
  }
}

void sub_1B18B9700(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  float v7;

  v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    v6 = v5;
    v7 = fmodf(*(float *)(a1 + 40), 6.2832);
    if (v7 >= -3.1416)
    {
      if (v7 > 3.1416)
        v7 = v7 + -6.2832;
    }
    else
    {
      v7 = v7 + 6.2832;
    }
    *(float *)(v6 + 224) = v7;
  }
}

uint64_t sub_1B18B9814(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  float v6;

  result = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (result)
  {
    v6 = *(float *)(a1 + 40);
    *(_BYTE *)(result + 1216) = v6 != 0.0;
    *(float *)(result + 1220) = v6;
  }
  return result;
}

float sub_1B18B98E4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  float result;

  v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    result = *(float *)(a1 + 40);
    *(float *)(v5 + 1224) = result;
  }
  return result;
}

uint64_t sub_1B18B99A8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  float v6;

  result = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (result)
  {
    v6 = *(float *)(a1 + 40);
    *(_BYTE *)(result + 1232) = v6 != 0.0;
    *(float *)(result + 1236) = v6;
  }
  return result;
}

float sub_1B18B9A78(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  float result;

  v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    result = *(float *)(a1 + 40);
    *(float *)(v5 + 1240) = result;
  }
  return result;
}

void sub_1B18B9D94(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B21FF5FC(v1);
  _Unwind_Resume(a1);
}

void sub_1B18BA2D4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v10;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFArray *v18;
  const __CFArray *v19;
  CFIndex Count;
  CFIndex v21;
  CFIndex v22;
  const void *ValueAtIndex;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const __CFAllocator *v32;
  __CFArray *Mutable;
  CFIndex v34;
  CFDataRef *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  CFDataRef *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t Length;
  const UInt8 *BytePtr;
  uint64_t v52;
  const UInt8 *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  unsigned int v58;
  CFIndex v59;
  __CFArray *v60;
  CFDataRef v61;
  _OWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  CFDataRef v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  const UInt8 *v78;
  const UInt8 *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t j;
  int v87;
  unsigned int v88;
  _DWORD *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  unint64_t v97;
  unint64_t v98;
  int v99;
  int v100;
  int v101;
  int v102;
  unsigned int v103;
  int v104;
  unsigned int v105;
  unsigned int v106;
  int v107;
  unint64_t v108;
  int v109;
  unsigned int v110;
  int v111;
  int v112;
  uint64_t v113;
  unsigned int v114;
  unint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  CFDataRef v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  __CFArray *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  __CFArray *v150;
  UInt8 *bytes;
  const __CFAllocator *v152;
  const __CFAllocator *allocator;
  uint64_t v154;
  int v155;
  int v156;
  int v157;
  int v158;
  _DWORD *v159;
  int v160;
  size_t v161;
  const UInt8 *v162;
  int v163;
  int v164;
  unsigned int *v165;
  uint64_t i;
  uint64_t v167;
  uint64_t v168;
  int v169;
  uint64_t v170;
  __CFArray *v171;
  CFMutableArrayRef v172;
  unsigned int v173[3];

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  v10 = *(const void **)(a1 + 112);
  if (v10)
  {
    if (*(_QWORD *)(a1 + 144))
      return;
    CFRelease(v10);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v11 = *(const void **)(a1 + 144);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 144) = 0;
  }
  free(*(void **)(a1 + 168));
  *(_QWORD *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 160) = 0;
  free(*(void **)(a1 + 176));
  *(_QWORD *)(a1 + 176) = 0;
  v171 = 0;
  v172 = 0;
  v170 = 0;
  v169 = 0;
  v168 = 0;
  sub_1B18BB530(a1, &v172, &v171, &v170, &v169, &v168);
  v18 = v172;
  if (!v172)
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Failed to build renderable data for mesh %p"), v12, v13, v14, v15, v16, v17, a1);
    v127 = v171;
    if (!v171)
      return;
    goto LABEL_217;
  }
  v19 = v171;
  if (!v171)
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Failed to build renderable data for mesh %p"), v12, v13, v14, v15, v16, v17, a1);
    v127 = v18;
LABEL_217:
    CFRelease(v127);
    return;
  }
  Count = CFArrayGetCount(v172);
  if (Count < 1)
  {
LABEL_14:
    ValueAtIndex = 0;
  }
  else
  {
    v21 = Count;
    v22 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v18, v22);
      if (!sub_1B17ED7B4((uint64_t)ValueAtIndex, v24, v25, v26, v27, v28, v29, v30))
        break;
      if (v21 == ++v22)
        goto LABEL_14;
    }
  }
  v31 = CFArrayGetCount(v19);
  v32 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v31, MEMORY[0x1E0C9B378]);
  if (v31 < 1)
    goto LABEL_219;
  allocator = v32;
  v34 = 0;
  v152 = (const __CFAllocator *)*MEMORY[0x1E0C9AE10];
  for (i = v31; i != v34; v31 = i)
  {
    v35 = (CFDataRef *)CFArrayGetValueAtIndex(v171, v34);
    v42 = v35;
    if (*((_BYTE *)v35 + 88) != 4)
    {
      v62 = CFRetain(v35);
      if (!v62)
        goto LABEL_216;
      goto LABEL_37;
    }
    if (!v35[12])
      goto LABEL_216;
    if (sub_1B17A47BC((uint64_t)v35) != 1)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. %s - Cannot create a renderable topology from indexed vertices"), v43, v44, v45, v46, v47, v48, (uint64_t)"channelCount == 1");
      goto LABEL_216;
    }
    v49 = *((unsigned __int8 *)v42 + 80);
    Length = CFDataGetLength(v42[12]);
    BytePtr = CFDataGetBytePtr(v42[12]);
    v52 = *((unsigned int *)v42 + 26);
    if (!(_DWORD)v52)
    {
      v62 = (_OWORD *)sub_1B17A39B4();
      sub_1B17A3C5C((uint64_t)v62, 0, 0, 0, 0, v67, v68, v69);
      if (!v62)
        goto LABEL_216;
      goto LABEL_37;
    }
    v53 = BytePtr;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    LOBYTE(v57) = 1;
    do
    {
      v54 += v49;
      if (v54 > Length)
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: __readIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v55);
LABEL_214:
        if ((byte_1EEF660E9 & 1) == 0)
        {
          byte_1EEF660E9 = 1;
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: %s - Invalid polygon edge count (%u)"), v36, v37, v38, v39, v40, v41, (uint64_t)"__CFXMeshElementCreateRenderablePrimitiveTypeCopy");
        }
LABEL_216:
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v36, v37, v38, v39, v40, v41, (uint64_t)"renderableElement");
        v127 = Mutable;
        goto LABEL_217;
      }
      switch((_DWORD)v49)
      {
        case 4:
          v58 = *(_DWORD *)&BytePtr[4 * v55];
          break;
        case 2:
          v58 = *(unsigned __int16 *)&BytePtr[2 * v55];
          break;
        case 1:
          v58 = BytePtr[v55];
          break;
        default:
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. %s - unsupported index size (%ld)"), v36, v37, v38, v39, v40, v41, (uint64_t)"false");
          goto LABEL_214;
      }
      if (v58 <= 2)
        goto LABEL_214;
      ++v55;
      v57 = (v58 == 3) & v57;
      v56 += v58 - 2;
    }
    while (v52 != v55);
    v167 = *((unsigned int *)v42 + 26);
    if (v57)
    {
      v59 = CFDataGetLength(v42[12]);
      v60 = Mutable;
      v61 = CFDataCreate(allocator, &v53[v167 * (unint64_t)v49], v59 - v167 * (unint64_t)v49);
      v62 = (_OWORD *)sub_1B17A39B4();
      sub_1B17A3C5C((uint64_t)v62, 0, *((unsigned int *)v42 + 26), v61, v49, v63, v64, v65);
      v66 = v61;
      Mutable = v60;
      CFRelease(v66);
      if (!v62)
        goto LABEL_216;
      goto LABEL_37;
    }
    v161 = v56 * 3 * v49;
    bytes = (UInt8 *)malloc_type_malloc(v161, 0x9DD64415uLL);
    if (!bytes)
      goto LABEL_216;
    v145 = a2;
    v71 = 0;
    v154 = 0;
    v72 = 0;
    v73 = v167;
    v147 = v167 + 2;
    v148 = v167 + 1;
    v146 = v167 + 3;
    v150 = Mutable;
    v162 = v53;
    while (2)
    {
      v74 = v71 + 1;
      if ((v71 + 1) * v49 > Length)
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: __readIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v71);
        goto LABEL_45;
      }
      if ((_DWORD)v49 == 4)
      {
        v75 = *(_DWORD *)&v53[4 * v71];
      }
      else if ((_DWORD)v49 == 2)
      {
        v75 = *(unsigned __int16 *)&v53[2 * v71];
      }
      else
      {
        v75 = v53[v71];
      }
      if (v75 < 3)
        goto LABEL_206;
      v76 = v75;
      v77 = (v72 + v73);
      if (v49 * (unint64_t)(v77 + v75 - 1) > Length)
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: __CFXMeshElementCreateRenderablePrimitiveTypeCopy - polygon %u (%u vertices, indices [%u, %u]) does not fit in index buffer (%u elements)"), v36, v37, v38, v39, v40, v41, v71);
        v73 = v167;
        v56 -= (v76 - 2);
        goto LABEL_54;
      }
      if (v75 == 4)
      {
        if (v49 * (unint64_t)(v77 + 1) <= Length)
        {
          v79 = v162;
          if ((_DWORD)v49 == 4)
          {
            v102 = *(_DWORD *)&v162[4 * v77];
          }
          else if ((_DWORD)v49 == 2)
          {
            v102 = *(unsigned __int16 *)&v162[2 * v77];
          }
          else
          {
            v102 = v162[v77];
          }
          v164 = v102;
        }
        else
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: __readIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, (v72 + v73));
          v164 = 0;
          v79 = v162;
        }
        v105 = v72 + v148;
        v156 = v72;
        if (v49 * (unint64_t)(v72 + v148 + 1) <= Length)
        {
          if ((_DWORD)v49 == 4)
          {
            v109 = *(_DWORD *)&v79[4 * v105];
          }
          else if ((_DWORD)v49 == 2)
          {
            v109 = *(unsigned __int16 *)&v79[2 * v105];
          }
          else
          {
            v109 = v79[v105];
          }
        }
        else
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: __readIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, (v72 + v148));
          v109 = 0;
        }
        v110 = v156 + v147;
        if (v49 * (unint64_t)(v156 + v147 + 1) <= Length)
        {
          if ((_DWORD)v49 == 4)
          {
            v111 = *(_DWORD *)&v79[4 * v110];
          }
          else if ((_DWORD)v49 == 2)
          {
            v111 = *(unsigned __int16 *)&v79[2 * v110];
          }
          else
          {
            v111 = v79[v110];
          }
          v160 = v111;
        }
        else
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: __readIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, (v156 + v147));
          v160 = 0;
        }
        v114 = v146 + v156;
        if (v49 * (unint64_t)(v146 + v156 + 1) > Length)
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: __readIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, (v146 + v156));
          v149 = 0;
          goto LABEL_148;
        }
        if ((_DWORD)v49 == 4)
        {
          v149 = *(_DWORD *)&v79[4 * v114];
LABEL_148:
          v115 = v161;
        }
        else
        {
          v115 = v161;
          if ((_DWORD)v49 == 2)
            v116 = *(unsigned __int16 *)&v79[2 * v114];
          else
            v116 = v79[v114];
          v149 = v116;
        }
        v118 = (v154 + 1);
        if (v49 * (unint64_t)v118 <= v115)
        {
          if ((_DWORD)v49 == 4)
          {
            *(_DWORD *)&bytes[4 * v154] = v164;
          }
          else if ((_DWORD)v49 == 2)
          {
            *(_WORD *)&bytes[2 * v154] = v164;
          }
          else
          {
            bytes[v154] = v164;
          }
        }
        else
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v154);
          v115 = v161;
        }
        v119 = (v154 + 2);
        if (v49 * (unint64_t)v119 <= v115)
        {
          if ((_DWORD)v49 == 4)
          {
            *(_DWORD *)&bytes[4 * v118] = v109;
          }
          else if ((_DWORD)v49 == 2)
          {
            *(_WORD *)&bytes[2 * v118] = v109;
          }
          else
          {
            bytes[v118] = v109;
          }
        }
        else
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v118);
          v115 = v161;
        }
        v120 = (v154 + 3);
        Mutable = v150;
        if (v49 * (unint64_t)v120 <= v115)
        {
          if ((_DWORD)v49 == 4)
          {
            *(_DWORD *)&bytes[4 * v119] = v160;
          }
          else if ((_DWORD)v49 == 2)
          {
            *(_WORD *)&bytes[2 * v119] = v160;
          }
          else
          {
            bytes[v119] = v160;
          }
        }
        else
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v119);
          v115 = v161;
        }
        v121 = (v154 + 4);
        if (v49 * (unint64_t)v121 <= v115)
        {
          if ((_DWORD)v49 == 4)
          {
            *(_DWORD *)&bytes[4 * v120] = v164;
          }
          else if ((_DWORD)v49 == 2)
          {
            *(_WORD *)&bytes[2 * v120] = v164;
          }
          else
          {
            bytes[v120] = v164;
          }
        }
        else
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v120);
          v115 = v161;
        }
        v122 = (v154 + 5);
        if (v49 * (unint64_t)v122 <= v115)
        {
          if ((_DWORD)v49 == 4)
          {
            *(_DWORD *)&bytes[4 * v121] = v160;
          }
          else if ((_DWORD)v49 == 2)
          {
            *(_WORD *)&bytes[2 * v121] = v160;
          }
          else
          {
            bytes[v121] = v160;
          }
        }
        else
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v121);
          v115 = v161;
        }
        v158 = v156 + 4;
        v154 = (v154 + 6);
        v53 = v162;
        if (v49 * (unint64_t)v154 <= v115)
        {
          if ((_DWORD)v49 != 4)
          {
            v73 = v167;
            if ((_DWORD)v49 == 2)
              *(_WORD *)&bytes[2 * v122] = v149;
            else
              bytes[v122] = v149;
            goto LABEL_205;
          }
          *(_DWORD *)&bytes[4 * v122] = v149;
        }
        else
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v122);
        }
LABEL_204:
        v73 = v167;
        goto LABEL_205;
      }
      if (v75 != 3)
      {
        if (!ValueAtIndex)
        {
LABEL_54:
          Mutable = v150;
          v53 = v162;
          goto LABEL_206;
        }
        v155 = v72;
        v165 = (unsigned int *)malloc_type_malloc(4 * v75, 0x100004052888210uLL);
        for (j = 0; j != v76; ++j)
        {
          v87 = v77 + j;
          if (v49 * (unint64_t)(v77 + j + 1) <= Length)
          {
            if ((_DWORD)v49 == 4)
            {
              v88 = *(_DWORD *)&v162[4 * v87];
            }
            else if ((_DWORD)v49 == 2)
            {
              v88 = *(unsigned __int16 *)&v162[2 * v87];
            }
            else
            {
              v88 = v162[v87];
            }
          }
          else
          {
            sub_1B17C4408(16, (uint64_t)CFSTR("Error: __readIndexInBuffer - index (%u) out of bounds (%lu)"), v80, v81, v82, v83, v84, v85, v77 + j);
            v88 = 0;
          }
          v165[j] = v88;
        }
        v173[0] = 0;
        v89 = sub_1B1940ACC((uint64_t)ValueAtIndex, v165, v76, (int *)v173, v82, v83, v84, v85);
        v96 = v76 - 2;
        Mutable = v150;
        if (v173[0])
        {
          v159 = v89;
          if (v173[0] == 3 * v96)
          {
            v97 = 0;
            v98 = v161;
            do
            {
              v99 = v154 + v97;
              if (v49 * (unint64_t)(v154 + v97 + 1) <= v98)
              {
                v100 = v159[v97];
                if ((_DWORD)v49 == 4)
                {
                  *(_DWORD *)&bytes[4 * v99] = v100;
                }
                else if ((_DWORD)v49 == 2)
                {
                  *(_WORD *)&bytes[2 * v99] = v100;
                }
                else
                {
                  bytes[v99] = v100;
                }
              }
              else
              {
                sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v90, v91, v92, v93, v94, v95, v154 + v97);
                v98 = v161;
              }
              ++v97;
            }
            while (v97 < v173[0]);
            v154 = (v154 + v97);
            Mutable = v150;
            v89 = v159;
LABEL_91:
            free(v89);
LABEL_92:
            free(v165);
            v72 = v76 + v155;
            v53 = v162;
LABEL_45:
            v73 = v167;
            goto LABEL_206;
          }
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: Inconsistent index count after triangulation."), v90, v91, v92, v93, v94, v95, v143);
          v89 = v159;
        }
        v56 -= v96;
        if (v89)
          goto LABEL_91;
        goto LABEL_92;
      }
      if (v49 * (unint64_t)(v77 + 1) <= Length)
      {
        v78 = v162;
        if ((_DWORD)v49 == 4)
        {
          v101 = *(_DWORD *)&v162[4 * v77];
        }
        else if ((_DWORD)v49 == 2)
        {
          v101 = *(unsigned __int16 *)&v162[2 * v77];
        }
        else
        {
          v101 = v162[v77];
        }
        v163 = v101;
      }
      else
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: __readIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, (v72 + v73));
        v163 = 0;
        v78 = v162;
      }
      v103 = v72 + v148;
      if (v49 * (unint64_t)(v72 + v148 + 1) <= Length)
      {
        if ((_DWORD)v49 == 4)
        {
          v104 = *(_DWORD *)&v78[4 * v103];
        }
        else if ((_DWORD)v49 == 2)
        {
          v104 = *(unsigned __int16 *)&v78[2 * v103];
        }
        else
        {
          v104 = v78[v103];
        }
        v144 = v104;
      }
      else
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: __readIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, (v72 + v148));
        v144 = 0;
      }
      v106 = v72 + v147;
      v157 = v72;
      if (v49 * (unint64_t)(v72 + v147 + 1) > Length)
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: __readIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, (v72 + v147));
        v107 = 0;
        goto LABEL_125;
      }
      if ((_DWORD)v49 == 4)
      {
        v107 = *(_DWORD *)&v78[4 * v106];
LABEL_125:
        v108 = v161;
      }
      else
      {
        v108 = v161;
        if ((_DWORD)v49 == 2)
          v107 = *(unsigned __int16 *)&v78[2 * v106];
        else
          v107 = v78[v106];
      }
      v112 = v154;
      v113 = (v154 + 1);
      if (v49 * (unint64_t)v113 <= v108)
      {
        if ((_DWORD)v49 == 4)
        {
          v112 = v154;
          *(_DWORD *)&bytes[4 * v154] = v163;
        }
        else
        {
          v112 = v154;
          if ((_DWORD)v49 == 2)
            *(_WORD *)&bytes[2 * v154] = v163;
          else
            bytes[v154] = v163;
        }
      }
      else
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v154);
        v108 = v161;
      }
      v117 = (v112 + 2);
      if (v49 * (unint64_t)v117 <= v108)
      {
        if ((_DWORD)v49 == 4)
        {
          *(_DWORD *)&bytes[4 * v113] = v144;
        }
        else if ((_DWORD)v49 == 2)
        {
          *(_WORD *)&bytes[2 * v113] = v144;
        }
        else
        {
          bytes[v113] = v144;
        }
      }
      else
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v113);
        v108 = v161;
      }
      v158 = v157 + 3;
      v154 = (v154 + 3);
      v53 = v162;
      if (v49 * (unint64_t)v154 > v108)
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v36, v37, v38, v39, v40, v41, v117);
        goto LABEL_171;
      }
      if ((_DWORD)v49 == 4)
      {
        *(_DWORD *)&bytes[4 * v117] = v107;
LABEL_171:
        Mutable = v150;
        goto LABEL_204;
      }
      v73 = v167;
      if ((_DWORD)v49 == 2)
        *(_WORD *)&bytes[2 * v117] = v107;
      else
        bytes[v117] = v107;
      Mutable = v150;
LABEL_205:
      v72 = v158;
LABEL_206:
      v71 = v74;
      if (v74 != v73)
        continue;
      break;
    }
    v123 = CFDataCreateWithBytesNoCopy(allocator, bytes, v56 * 3 * v49, v152);
    v62 = (_OWORD *)sub_1B17A39B4();
    sub_1B17A3C5C((uint64_t)v62, 0, v56, v123, v49, v124, v125, v126);
    CFRelease(v123);
    a2 = v145;
    if (!v62)
      goto LABEL_216;
LABEL_37:
    v70 = sub_1B1874C3C(a1, v34);
    if (v70)
    {
      v62[11] = *(_OWORD *)(v70 + 176);
      v62[12] = *(_OWORD *)(v70 + 192);
    }
    CFArrayAppendValue(Mutable, v62);
    CFRelease(v62);
    ++v34;
  }
  v19 = v171;
LABEL_219:
  CFRelease(v19);
  if (v31 != CFArrayGetCount(Mutable))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Consistency error: there must be as many renderable elements as original elements"), v128, v129, v130, v131, v132, v133, (uint64_t)"elementCount == CFArrayGetCount(deindexedTriangleElements)");
  *(_QWORD *)(a1 + 112) = v172;
  *(_QWORD *)(a1 + 144) = Mutable;
  v134 = v170;
  *(_DWORD *)(a1 + 160) = v169;
  v135 = v168;
  *(_QWORD *)(a1 + 168) = v134;
  *(_QWORD *)(a1 + 176) = v135;
  sub_1B1873BA0(a1);
  if ((a2 & 1) == 0)
    sub_1B1873DD4(a1, v136, v137, v138, v139, v140, v141, v142);
}

void sub_1B18BB530(uint64_t a1, CFMutableArrayRef *a2, __CFArray **a3, _QWORD *a4, _DWORD *a5, _QWORD *a6)
{
  _QWORD *v6;
  CFMutableArrayRef *v10;
  uint64_t v11;
  CFIndex Count;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  const __CFAllocator *v22;
  unsigned __int8 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  CFIndex v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  BOOL v43;
  const __CFAllocator *v44;
  const CFArrayCallBacks *v45;
  CFAllocatorRef v46;
  uint64_t v47;
  uint64_t *v48;
  unsigned __int8 v49;
  size_t v50;
  const __CFAllocator *v51;
  uint64_t v52;
  const void *ValueAtIndex;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int8 v68;
  unsigned int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  __CFArray *v104;
  CFIndex v105;
  const __CFAllocator *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unsigned int v132;
  unint64_t v133;
  UInt8 *v134;
  const UInt8 *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  _OWORD *v145;
  char v146;
  char v147;
  CFAllocatorRef v148;
  char **v149;
  int v150;
  uint64_t v151;
  uint64_t v152;
  size_t v153;
  char *v154;
  char *v155;
  unsigned int v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  const UInt8 *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  int v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  int v181;
  int v182;
  char *v183;
  _DWORD *v184;
  int v185;
  char *v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  char *v191;
  char *v192;
  int v193;
  CFDataRef v194;
  const void *v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  size_t v199;
  uint64_t v200;
  char v201;
  int v202;
  char **v203;
  _DWORD *v204;
  int v205;
  int v206;
  CFAllocatorRef v207;
  char **v208;
  int v209;
  uint64_t v210;
  uint64_t v211;
  size_t v212;
  char *v213;
  char *v214;
  const UInt8 *v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  int v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  char *v231;
  _DWORD *v232;
  char *v233;
  uint64_t v234;
  unint64_t v235;
  uint64_t v236;
  unint64_t v237;
  char *v238;
  char *v239;
  int v240;
  _DWORD *v241;
  uint64_t v242;
  size_t v243;
  void *v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  __int16 *v252;
  CFAllocatorRef v253;
  const __CFAllocator *v254;
  uint64_t v255;
  __int16 v256;
  uint64_t v257;
  CFDataRef v258;
  uint64_t v259;
  const void *v260;
  void **v261;
  CFAllocatorRef v262;
  void *v263;
  const __CFAllocator *v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  __CFArray **v271;
  __CFArray **v272;
  _DWORD *v273;
  CFIndex v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  unsigned int v281;
  unsigned int v282;
  CFIndex v283;
  uint64_t v284;
  uint64_t v285;
  unsigned int v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  const __CFArray *v293;
  __CFArray *MutableCopy;
  __CFArray *Mutable;
  CFIndex v296;
  uint64_t v297;
  CFDataRef *v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  int v306;
  unsigned int v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  unsigned int v323;
  unint64_t v324;
  void *v325;
  uint64_t v326;
  const UInt8 *BytePtr;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  CFDataRef v340;
  const void *v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  _DWORD *v346;
  _QWORD *v347;
  _QWORD *v348;
  uint64_t *v349;
  CFMutableArrayRef *v350;
  __CFArray **v351;
  size_t v352;
  CFAllocatorRef v353;
  CFArrayRef v354;
  CFMutableArrayRef v355;
  uint64_t v356;
  int v357;
  CFIndex v358;
  CFIndex v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  __int128 *v364;
  int v365;
  const UInt8 *v366;
  uint64_t v367;
  _DWORD *v368;
  char **v369;
  const __CFAllocator *v370;
  unint64_t v371;
  CFMutableArrayRef v372;
  CFAllocatorRef v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  void (*v378)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v379;
  _QWORD *v380;
  void *v381;
  uint64_t v382;
  unint64_t v383;
  unsigned int v384;
  __int128 v385;
  __int128 v386;
  __int128 v387;
  uint64_t v388;
  __int128 v389;
  __int128 v390;
  __int128 v391;
  uint64_t v392;
  _QWORD v393[3];
  int v394;
  uint64_t v395;

  v6 = a6;
  v10 = a2;
  v11 = a1;
  v395 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  v359 = CFArrayGetCount(*(CFArrayRef *)(v11 + 96));
  v373 = (CFAllocatorRef)Count;
  v360 = v11;
  if (Count < 1)
  {
    v21 = 0;
    goto LABEL_131;
  }
  v20 = 0;
  v21 = 0;
  v22 = 0;
  while (1)
  {
    v23 = sub_1B1875D40(v11, (uint64_t)v22, v14, v15, v16, v17, v18, v19);
    if (!v22)
    {
      v21 = v23;
      goto LABEL_7;
    }
    if ((_DWORD)v21 != v23)
      break;
LABEL_7:
    v22 = (const __CFAllocator *)((char *)v22 + 1);
    v20 = (uint64_t)v22 >= (uint64_t)v373;
    if (v373 == v22)
      goto LABEL_131;
  }
  if (v20 || v359 < 1)
    goto LABEL_131;
  v24 = sub_1B1874C3C(v11, 0);
  v348 = a4;
  if (!sub_1B17A4F2C(v24, v25, v26, v27, v28, v29, v30, v31))
    goto LABEL_20;
  v32 = v6;
  v33 = 1;
  do
  {
    v34 = v33;
    if (sub_1B17A47BC(v24) >= 2 && (byte_1EEF660E8 & 1) == 0)
    {
      byte_1EEF660E8 = 1;
      sub_1B17C4408(16, (uint64_t)CFSTR("Warning: Mesh element %p of mesh %p has %d channels but they all define the same topology"), v14, v15, v16, v17, v18, v19, v24);
    }
    if (v359 == v34)
      break;
    v24 = sub_1B1874C3C(v360, v34);
    v42 = sub_1B17A4F2C(v24, v35, v36, v37, v38, v39, v40, v41);
    v33 = v34 + 1;
  }
  while (v42);
  v43 = v34 < v359;
  v6 = v32;
  v11 = v360;
  if (!v43)
  {
LABEL_131:
    v281 = sub_1B1874BE0(v11, v13, v14, v15, v16, v17, v18, v19);
    v282 = v281;
    if (v281)
    {
      v283 = 0;
      v284 = v281;
      while (1)
      {
        v285 = sub_1B1874C3C(v11, v283);
        v286 = sub_1B17A47BC(v285);
        if (v286 <= v21)
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Requested channel (%d) does not exist in element (%p)"), v287, v288, v289, v290, v291, v292, v21);
          return;
        }
        if (v286 >= 2)
          break;
        if (v284 == ++v283)
          goto LABEL_136;
      }
      v350 = v10;
      v351 = a3;
      v375 = *MEMORY[0x1E0C9AE00];
      Mutable = CFArrayCreateMutable((CFAllocatorRef)v375, v282, MEMORY[0x1E0C9B378]);
      MutableCopy = Mutable;
      v296 = 0;
      v374 = v21;
      v373 = (CFAllocatorRef)*MEMORY[0x1E0C9AE10];
      if (v282 <= 1)
        v297 = 1;
      else
        v297 = v282;
      v372 = Mutable;
      v371 = v297;
      do
      {
        v298 = (CFDataRef *)sub_1B1874C3C(v11, v296);
        if (sub_1B17A47BC((uint64_t)v298) == 1)
        {
          CFArrayAppendValue(MutableCopy, v298);
        }
        else
        {
          v306 = sub_1B17A426C((uint64_t)v298, v299, v300, v301, v302, v303, v304, v305);
          v307 = sub_1B17A47FC((uint64_t)v298);
          v315 = sub_1B17A5150((uint64_t)v298, v308, v309, v310, v311, v312, v313, v314);
          v323 = sub_1B17A4304((uint64_t)v298, v316, v317, v318, v319, v320, v321, v322);
          if (v306 == 4)
          {
            v324 = v315 * (unint64_t)(v323 + v307);
            v325 = malloc_type_malloc(v324, 0xBA2B2CF1uLL);
            v326 = v307;
            BytePtr = CFDataGetBytePtr(v298[12]);
            memcpy(v325, BytePtr, v307 * (unint64_t)v315);
          }
          else
          {
            v324 = v323 * (unint64_t)v315;
            v325 = malloc_type_malloc(v324, 0x142254F0uLL);
            v326 = v307;
            v307 = 0;
          }
          v393[0] = 0;
          v393[1] = v393;
          v393[2] = 0x2000000000;
          v394 = 0;
          v392 = 0;
          v390 = 0u;
          v391 = 0u;
          v389 = 0u;
          sub_1B17A4804((uint64_t)v298, v374, v328, v329, v330, v331, v332, v333, (uint64_t)&v389);
          v385 = v389;
          v386 = v390;
          v387 = v391;
          v388 = v392;
          v376 = MEMORY[0x1E0C809B0];
          v377 = 0x40000000;
          v378 = sub_1B18BC6A8;
          v379 = &unk_1E63D86F8;
          v384 = v307;
          v381 = v325;
          v380 = v393;
          v382 = v315;
          v383 = v324;
          sub_1B17A5198((uint64_t *)&v385, (uint64_t)&v376, v334, v335, v336, v337, v338, v339);
          v340 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)v375, (const UInt8 *)v325, v324, v373);
          v341 = (const void *)sub_1B17A39B4();
          sub_1B17A3C5C((uint64_t)v341, v306, v326, v340, v315, v342, v343, v344);
          MutableCopy = v372;
          CFArrayAppendValue(v372, v341);
          CFRelease(v340);
          CFRelease(v341);
          _Block_object_dispose(v393, 8);
          v11 = v360;
          v297 = v371;
        }
        ++v296;
      }
      while (v297 != v296);
      a3 = v351;
      v10 = v350;
      if (MutableCopy)
      {
LABEL_151:
        *v10 = CFArrayCreateMutableCopy((CFAllocatorRef)v375, 0, *(CFArrayRef *)(v11 + 64));
        *a3 = MutableCopy;
      }
    }
    else
    {
LABEL_136:
      v293 = *(const __CFArray **)(v11 + 96);
      v375 = *MEMORY[0x1E0C9AE00];
      MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)v375, 0, v293);
      if (MutableCopy)
        goto LABEL_151;
    }
  }
  else
  {
LABEL_20:
    v346 = a5;
    v347 = v6;
    v350 = v10;
    v351 = a3;
    v44 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v45 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    v46 = v373;
    v355 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFIndex)v373, MEMORY[0x1E0C9B378]);
    v370 = v44;
    v354 = CFArrayCreateMutable(v44, v359, v45);
    v345 = (uint64_t)&v345;
    MEMORY[0x1E0C80A78](v354, v47);
    v48 = &v345 - 8 * (_QWORD)v46;
    v49 = 0;
    LODWORD(v50) = 0;
    v51 = 0;
    v349 = v48;
    do
    {
      v52 = v360;
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v360 + 64), (CFIndex)v51);
      v61 = sub_1B17EE3B4((uint64_t)ValueAtIndex, v54, v55, v56, v57, v58, v59, v60);
      v68 = sub_1B1875D40(v52, (uint64_t)v51, v62, v63, v64, v65, v66, v67);
      v69 = sub_1B18F39CC(v61);
      v70 = sub_1B18F3854(v61);
      v71 = sub_1B18F385C(v61);
      v79 = sub_1B179E250(v70, v72, v73, v74, v75, v76, v77, v78);
      if (v70 == 14 && v71 == 3)
      {
        v88 = 4 * sub_1B179E250(14, v80, v81, v82, v83, v84, v85, v86);
        v71 = 4;
      }
      else
      {
        v88 = v79 * v71;
      }
      *v48 = (uint64_t)ValueAtIndex;
      v48[1] = v61;
      *((_BYTE *)v48 + 16) = v68;
      v48[3] = v88;
      *((_WORD *)v48 + 16) = v70;
      v48[5] = v71;
      *((_DWORD *)v48 + 14) = 0;
      *((_DWORD *)v48 + 15) = v69;
      v48[6] = (uint64_t)malloc_type_malloc(v88 * v69, 0x97DC89ADuLL);
      v96 = sub_1B17ED7B4((uint64_t)ValueAtIndex, v89, v90, v91, v92, v93, v94, v95);
      if (v96)
        v50 = v50;
      else
        v50 = v69;
      if (!v96)
        v49 = v68;
      v51 = (const __CFAllocator *)((char *)v51 + 1);
      v48 += 8;
    }
    while (v373 != v51);
    v389 = 0uLL;
    *(_QWORD *)&v390 = 0;
    v352 = v50;
    v368 = malloc_type_calloc(v50, 4uLL, 0x100004052888210uLL);
    *(_QWORD *)&v386 = 0;
    *((_QWORD *)&v385 + 1) = 0;
    *(_QWORD *)&v385 = (char *)&v385 + 8;
    v103 = v360;
    v104 = v355;
    if (v359 < 1)
      goto LABEL_88;
    v105 = 0;
    v365 = 0;
    v367 = v49;
    v364 = &v390;
    v353 = (CFAllocatorRef)*MEMORY[0x1E0C9AE10];
    v369 = (char **)(v349 + 6);
    v106 = v370;
    do
    {
      v107 = sub_1B1874C3C(v103, v105);
      v115 = sub_1B17A426C(v107, v108, v109, v110, v111, v112, v113, v114);
      v116 = sub_1B17A47FC(v107);
      v124 = sub_1B17A5150(v107, v117, v118, v119, v120, v121, v122, v123);
      v132 = sub_1B17A4304(v107, v125, v126, v127, v128, v129, v130, v131);
      v358 = v105;
      v357 = v115;
      v356 = v132;
      if (v115 == 4)
      {
        v133 = (v132 + v116) * v124;
        v134 = (UInt8 *)malloc_type_malloc(v133, 0x3EFDF2C3uLL);
        v135 = CFDataGetBytePtr(*(CFDataRef *)(v107 + 96));
        v366 = v134;
        memcpy(v134, v135, v116 * v124);
        v361 = v116;
      }
      else
      {
        v133 = v132 * (unint64_t)v124;
        v366 = (const UInt8 *)malloc_type_malloc(v133, 0xD3679E4FuLL);
        v361 = 0;
      }
      v362 = v116;
      if (v116 < 1)
      {
        v363 = 0;
      }
      else
      {
        v142 = 0;
        v363 = 0;
        v372 = (CFMutableArrayRef)v124;
        v371 = v133;
        do
        {
          v375 = sub_1B17A4914(v107, v142, v136, v137, v138, v139, v140, v141);
          if (v375 >= 1)
          {
            v143 = 0;
            v374 = v363 + v361;
            do
            {
              v144 = v386;
              v376 = v107;
              v377 = v142;
              v378 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v143;
              LODWORD(v379) = v386;
              v145 = sub_1B18BC7D0((uint64_t **)&v385, &v376, (uint64_t)&v376);
              v147 = v146;
              if (v124 * (unint64_t)(v374 + v143 + 1) <= v133)
              {
                v185 = *((_DWORD *)v145 + 14);
                switch((_DWORD)v124)
                {
                  case 4:
                    *(_DWORD *)&v366[4 * (v374 + v143)] = v185;
                    break;
                  case 2:
                    *(_WORD *)&v366[2 * (v374 + v143)] = v185;
                    break;
                  case 1:
                    v366[(v374 + v143)] = v185;
                    break;
                  default:
                    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. %s - unsupported index size (%ld)"), v136, v137, v138, v139, v140, v141, (uint64_t)"false");
                    break;
                }
              }
              else
              {
                sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), v136, v137, v138, v139, v140, v141, v374 + v143);
              }
              v148 = v373;
              v149 = v369;
              if (v147)
              {
                do
                {
                  v151 = *((unsigned int *)v149 + 2);
                  v150 = *((_DWORD *)v149 + 3);
                  if (v150 == (_DWORD)v151)
                  {
                    v152 = (2 * v150);
                    *((_DWORD *)v149 + 3) = v152;
                    v153 = (size_t)*(v149 - 3);
                    v154 = (char *)malloc_type_realloc(*v149, v153 * v152, 0xDEE44663uLL);
                    *v149 = v154;
                  }
                  else
                  {
                    v154 = *v149;
                    v153 = (size_t)*(v149 - 3);
                  }
                  v155 = &v154[v153 * v151];
                  v156 = sub_1B17A4A74(v107, v142, v143, *((unsigned __int8 *)v149 - 32), v138, v139, v140, v141);
                  v163 = sub_1B18F39D4(*(v149 - 5), v156, v157, v158, v159, v160, v161, v162);
                  if (v163)
                  {
                    memcpy(v155, v163, v153);
                  }
                  else
                  {
                    bzero(v155, v153);
                    v166 = (uint64_t)*(v149 - 6);
                    v174 = sub_1B17ED7B4(v166, v167, v168, v169, v170, v171, v172, v173);
                    sub_1B17ED08C(v174);
                    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Deindexer failed - Source %p (%@) has no original data at index %u"), v175, v176, v177, v178, v179, v180, v166);
                  }
                  if ((_DWORD)v151 != v144)
                    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Deindexer failed - Hash value inconsistency"), v164, v165, v138, v139, v140, v141, (uint64_t)"value == sourceInfo.dataVectorCount");
                  *((_DWORD *)v149 + 2) = v151 + 1;
                  v149 += 8;
                  v148 = (CFAllocatorRef)((char *)v148 - 1);
                }
                while (v148);
                v181 = sub_1B17A4A74(v107, v142, v143, v367, v138, v139, v140, v141);
                v182 = v181;
                v183 = (char *)*((_QWORD *)&v389 + 1);
                if (*((_QWORD *)&v389 + 1) >= (unint64_t)v390)
                {
                  v186 = (char *)v389;
                  v187 = (uint64_t)(*((_QWORD *)&v389 + 1) - v389) >> 2;
                  v188 = v187 + 1;
                  v124 = (uint64_t)v372;
                  if ((unint64_t)(v187 + 1) >> 62)
LABEL_153:
                    abort();
                  v189 = v390 - v389;
                  if ((uint64_t)(v390 - v389) >> 1 > v188)
                    v188 = v189 >> 1;
                  if ((unint64_t)v189 >= 0x7FFFFFFFFFFFFFFCLL)
                    v190 = 0x3FFFFFFFFFFFFFFFLL;
                  else
                    v190 = v188;
                  if (v190)
                  {
                    v191 = (char *)sub_1B17F7E58((uint64_t)v364, v190);
                    v183 = (char *)*((_QWORD *)&v389 + 1);
                    v186 = (char *)v389;
                  }
                  else
                  {
                    v191 = 0;
                  }
                  v106 = v370;
                  v192 = &v191[4 * v187];
                  *(_DWORD *)v192 = v182;
                  v184 = v192 + 4;
                  while (v183 != v186)
                  {
                    v193 = *((_DWORD *)v183 - 1);
                    v183 -= 4;
                    *((_DWORD *)v192 - 1) = v193;
                    v192 -= 4;
                  }
                  *(_QWORD *)&v389 = v192;
                  *((_QWORD *)&v389 + 1) = v184;
                  *(_QWORD *)&v390 = &v191[4 * v190];
                  if (v186)
                    operator delete(v186);
                }
                else
                {
                  **((_DWORD **)&v389 + 1) = v181;
                  v184 = v183 + 4;
                  v106 = v370;
                  v124 = (uint64_t)v372;
                }
                *((_QWORD *)&v389 + 1) = v184;
                if (!v368[v182])
                  v368[v182] = (unint64_t)((unint64_t)v184 - v389) >> 2;
              }
              else
              {
                v365 = 1;
                v106 = v370;
                v124 = (uint64_t)v372;
              }
              ++v143;
              v133 = v371;
            }
            while (v143 != v375);
          }
          v363 += v375;
          ++v142;
        }
        while (v142 != v362);
      }
      if (v363 != v356)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Deindexing failed - Vertex count inconsistency"), v136, v137, v138, v139, v140, v141, (uint64_t)"overallVertexIndex == (CFIndex)indexCount");
      v194 = CFDataCreateWithBytesNoCopy(v106, v366, v133, v353);
      v195 = (const void *)sub_1B17A39B4();
      sub_1B17A3C5C((uint64_t)v195, v357, v362, v194, v124, v196, v197, v198);
      CFArrayAppendValue(v354, v195);
      CFRelease(v195);
      CFRelease(v194);
      v105 = v358 + 1;
      v103 = v360;
      v104 = v355;
    }
    while (v358 + 1 != v359);
    if ((v365 & 1) == 0)
LABEL_88:
      sub_1B17C4408(0, (uint64_t)CFSTR("Warning: Mesh %p has multiple channels but deindexing didn't have any effect"), v97, v98, v99, v100, v101, v102, v103);
    v199 = v352;
    if ((_DWORD)v352)
    {
      v200 = 0;
      v201 = 0;
      v202 = 0;
      v203 = (char **)(v349 + 6);
      v204 = v368;
      do
      {
        v205 = v204[v200];
        if (v205)
        {
          v206 = v205 - 1;
        }
        else
        {
          sub_1B17C4408(0, (uint64_t)CFSTR("Warning: Deindexing - Vertex at index %u of %u is not used by any geometry element"), v97, v98, v99, v100, v101, v102, v200);
          v207 = v373;
          v208 = v203;
          if ((v201 & 1) != 0)
          {
            v201 = 1;
            v206 = v202;
            v104 = v355;
            v199 = v352;
          }
          else
          {
            do
            {
              v210 = *((unsigned int *)v208 + 2);
              v209 = *((_DWORD *)v208 + 3);
              if (v209 == (_DWORD)v210)
              {
                v211 = (2 * v209);
                *((_DWORD *)v208 + 3) = v211;
                v212 = (size_t)*(v208 - 3);
                v213 = (char *)malloc_type_realloc(*v208, v212 * v211, 0x20C5E437uLL);
                *v208 = v213;
              }
              else
              {
                v213 = *v208;
                v212 = (size_t)*(v208 - 3);
              }
              v214 = &v213[v212 * v210];
              v215 = sub_1B18F39D4(*(v208 - 5), 0, v97, v98, v99, v100, v101, v102);
              if (v215)
              {
                memcpy(v214, v215, v212);
              }
              else
              {
                bzero(v214, v212);
                v216 = (uint64_t)*(v208 - 6);
                v224 = sub_1B17ED7B4(v216, v217, v218, v219, v220, v221, v222, v223);
                sub_1B17ED08C(v224);
                sub_1B17C4408(16, (uint64_t)CFSTR("Error: Deindexer failed - Source %p (%@) has no original data at index %u"), v225, v226, v227, v228, v229, v230, v216);
              }
              *((_DWORD *)v208 + 2) = v210 + 1;
              v208 += 8;
              v207 = (CFAllocatorRef)((char *)v207 - 1);
            }
            while (v207);
            v231 = (char *)*((_QWORD *)&v389 + 1);
            if (*((_QWORD *)&v389 + 1) >= (unint64_t)v390)
            {
              v233 = (char *)v389;
              v234 = (uint64_t)(*((_QWORD *)&v389 + 1) - v389) >> 2;
              v235 = v234 + 1;
              if ((unint64_t)(v234 + 1) >> 62)
                goto LABEL_153;
              v236 = v390 - v389;
              if ((uint64_t)(v390 - v389) >> 1 > v235)
                v235 = v236 >> 1;
              if ((unint64_t)v236 >= 0x7FFFFFFFFFFFFFFCLL)
                v237 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v237 = v235;
              if (v237)
              {
                v238 = (char *)sub_1B17F7E58((uint64_t)&v390, v237);
                v231 = (char *)*((_QWORD *)&v389 + 1);
                v233 = (char *)v389;
              }
              else
              {
                v238 = 0;
              }
              v104 = v355;
              v239 = &v238[4 * v234];
              *(_DWORD *)v239 = v200;
              v232 = v239 + 4;
              while (v231 != v233)
              {
                v240 = *((_DWORD *)v231 - 1);
                v231 -= 4;
                *((_DWORD *)v239 - 1) = v240;
                v239 -= 4;
              }
              *(_QWORD *)&v389 = v239;
              *((_QWORD *)&v389 + 1) = v232;
              *(_QWORD *)&v390 = &v238[4 * v237];
              if (v233)
                operator delete(v233);
            }
            else
            {
              **((_DWORD **)&v389 + 1) = v200;
              v232 = v231 + 4;
              v104 = v355;
            }
            v199 = v352;
            *((_QWORD *)&v389 + 1) = v232;
            v206 = ((unint64_t)((unint64_t)v232 - v389) >> 2) - 1;
            v201 = 1;
            v202 = v206;
          }
        }
        v241 = v368;
        v368[v200] = v206;
        v204 = v241;
        ++v200;
      }
      while (v200 != v199);
    }
    v242 = (*((_QWORD *)&v389 + 1) - (_QWORD)v389) >> 2;
    v243 = (*((_QWORD *)&v389 + 1) - v389) & 0x3FFFFFFFCLL;
    v244 = malloc_type_malloc(v243, 0x2B0A4ADAuLL);
    memcpy(v244, (const void *)v389, v243);
    v252 = (__int16 *)(v349 + 4);
    v253 = v373;
    v254 = v370;
    do
    {
      v255 = *((unsigned int *)v252 + 6);
      v256 = sub_1B17ED7B4(*((_QWORD *)v252 - 4), v245, v246, v247, v248, v249, v250, v251);
      v257 = *((_QWORD *)v252 - 1);
      v258 = CFDataCreate(v254, *((const UInt8 **)v252 + 2), v257 * v255);
      v260 = (const void *)sub_1B17ED264(v256, v258, *v252, *((_QWORD *)v252 + 1), v255, v257, 0, v259);
      CFArrayAppendValue(v104, v260);
      CFRelease(v260);
      CFRelease(v258);
      v252 += 32;
      v253 = (CFAllocatorRef)((char *)v253 - 1);
    }
    while (v253);
    v261 = (void **)(v349 + 6);
    v262 = v373;
    do
    {
      v263 = *v261;
      v261 += 8;
      free(v263);
      v262 = (CFAllocatorRef)((char *)v262 - 1);
    }
    while (v262);
    v264 = (const __CFAllocator *)CFArrayGetCount(v104);
    v271 = v351;
    v272 = v350;
    v273 = v346;
    if (v373 != v264)
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Deindexing failed - Count of deindexed mesh sources does not match count of indexed mesh sources"), v265, v266, v267, v268, v269, v270, (uint64_t)"sourceCount == CFArrayGetCount(deindexedSources)");
    v274 = CFArrayGetCount(v354);
    if (v359 != v274)
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Deindexing failed - Count of deindexed mesh elements does not match count of indexed mesh elements"), v275, v276, v277, v278, v279, v280, (uint64_t)"elementCount == CFArrayGetCount(deindexedElements)");
    *v272 = v104;
    *v271 = v354;
    *v348 = v244;
    *v273 = v242;
    *v347 = v368;
    sub_1B1805B90((uint64_t)&v385, *((_QWORD **)&v385 + 1));
    if ((_QWORD)v389)
    {
      *((_QWORD *)&v389 + 1) = v389;
      operator delete((void *)v389);
    }
  }
}

void sub_1B18BC6A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v8 = a4;
  if ((_DWORD)a4)
  {
    v11 = 0;
    do
    {
      v12 = v11 + *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + *(_DWORD *)(a1 + 64);
      v13 = *(_QWORD *)(a1 + 48);
      if (v13 * (unint64_t)(v12 + 1) <= *(_QWORD *)(a1 + 56))
      {
        v14 = *(_QWORD *)(a1 + 40);
        v15 = *(_DWORD *)(a3 + 4 * v11);
        switch(v13)
        {
          case 4:
            *(_DWORD *)(v14 + 4 * v12) = v15;
            break;
          case 2:
            *(_WORD *)(v14 + 2 * v12) = v15;
            break;
          case 1:
            *(_BYTE *)(v14 + v12) = v15;
            break;
          default:
            sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. %s - unsupported index size (%ld)"), a3, a4, a5, a6, a7, a8, (uint64_t)"false");
            break;
        }
      }
      else
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)"), a3, a4, a5, a6, a7, a8, v11 + (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + *(_DWORD *)(a1 + 64)));
      }
      ++v11;
    }
    while (v8 != v11);
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v8;
}

_OWORD *sub_1B18BC7D0(uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  void **v5;
  _OWORD *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = (void **)sub_1B18BC860((uint64_t)a1, &v9, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = operator new(0x40uLL);
    v6[2] = *(_OWORD *)a3;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a3 + 16);
    *((_DWORD *)v6 + 14) = *(_DWORD *)(a3 + 24);
    sub_1B181D728(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

_QWORD *sub_1B18BC860(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = v4 + 4;
        if (!sub_1B18BC8FC(v7, a3, v4 + 4))
          break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!sub_1B18BC8FC(v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

BOOL sub_1B18BC8FC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL8 result;

  v5 = sub_1B17A47BC(*a2);
  if (v5 != sub_1B17A47BC(*a3))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Two elements in the same mesh do not have the same number of index channels"), v6, v7, v8, v9, v10, v11, (uint64_t)"channelCount == CFXMeshElementGetIndicesChannelCount(rhs.element)");
  if (!v5)
    return 0;
  v12 = 0;
  v13 = v5 - 1;
  do
  {
    v14 = sub_1B17A4A74(*a2, a2[1], a2[2], v12, v8, v9, v10, v11);
    v19 = sub_1B17A4A74(*a3, a3[1], a3[2], v12, v15, v16, v17, v18);
    result = v14 < v19;
  }
  while (v14 >= v19 && v14 <= v19 && v13 != v12++);
  return result;
}

BOOL sub_1B18BCE30(void *a1, char *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;

  v7 = objc_msgSend_rangeOfString_(a1, a2, (uint64_t)CFSTR("."), a4);
  v9 = v8;
  if (v8 == 1)
  {
    v10 = v7;
    *(_QWORD *)a2 = objc_msgSend_substringWithRange_(a1, (const char *)1, 0, v7);
    v14 = objc_msgSend_length(a1, v11, v12, v13);
    v16 = objc_msgSend_substringWithRange_(a1, v15, v10 + 1, v14 + ~v10);
  }
  else
  {
    v16 = 0;
    *(_QWORD *)a2 = a1;
  }
  *a3 = v16;
  return v9 == 1;
}

CFTypeRef sub_1B18BCED0(void *a1)
{
  uint64_t v2;

  v2 = sub_1B18FEB10();
  return sub_1B18FEDC8(v2, a1);
}

void sub_1B18BCEF4(const void *a1, void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = sub_1B18FEB10();
  sub_1B18FEEA8(v4, a2, a1, v5, v6, v7, v8, v9);
}

uint64_t sub_1B18BCF20(const void *a1, uint64_t a2)
{
  void *v3;
  const char *v4;

  v3 = (void *)sub_1B18831BC(a1);
  return objc_msgSend_vfx_CFXColorIgnoringColorSpace_success_(v3, v4, a2, 0);
}

double sub_1B18BCF48(const void *a1)
{
  void *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  CGColor *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v1 = (void *)sub_1B18831BC(a1);
  v5 = (CGColor *)objc_msgSend_CGColor(v1, v2, v3, v4);
  if (v5)
    return sub_1B179D268(v5, v6, v7, v8, v9, v10, v11, v12);
  else
    return 0.0;
}

uint64_t sub_1B18BCF74(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_vfx_colorWithCFXColor_(MEMORY[0x1E0DC3658], a2, a1, a4);
}

uint64_t sub_1B18BCF84(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const char *v5;
  uint64_t v6;
  const char *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if ((objc_msgSend_isEqualToString_(a1, a2, (uint64_t)CFSTR("directional"), a4) & 1) != 0)
    return 2;
  if ((objc_msgSend_isEqualToString_(a1, v5, (uint64_t)CFSTR("spot"), v6) & 1) != 0)
    return 3;
  if ((objc_msgSend_isEqualToString_(a1, v8, (uint64_t)CFSTR("omni"), v9) & 1) != 0)
    return 1;
  if ((objc_msgSend_isEqualToString_(a1, v10, (uint64_t)CFSTR("ambient"), v11) & 1) != 0)
    return 0;
  if ((objc_msgSend_isEqualToString_(a1, v12, (uint64_t)CFSTR("area"), v13) & 1) != 0)
    return 5;
  if ((objc_msgSend_isEqualToString_(a1, v14, (uint64_t)CFSTR("ies"), v15) & 1) != 0)
    return 6;
  if ((objc_msgSend_isEqualToString_(a1, v16, (uint64_t)CFSTR("probe"), v17) & 1) == 0)
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: unknown legacy light type: %@"), v18, v19, v20, v21, v22, v23, (uint64_t)a1);
    return 2;
  }
  return 4;
}

uint64_t sub_1B18BD07C(void *a1, CFTypeRef cf, uint64_t a3)
{
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  CGColor *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v5 = (void *)sub_1B18831BC(cf);
  v9 = (CGColor *)objc_msgSend_CGColor(v5, v6, v7, v8);
  if (v9)
    *(double *)&v17 = sub_1B179D268(v9, (uint64_t)v10, v11, v12, v13, v14, v15, v16);
  else
    v17 = xmmword_1B2244E20;
  v19 = v17;
  return objc_msgSend_encodeBytes_length_forKey_(a1, v10, (uint64_t)&v19, 16, a3);
}

uint64_t sub_1B18BD108(void *a1, const char *a2)
{
  float32x4_t *v2;
  float32x4_t v3;
  CGColorRef v4;
  const char *v5;
  uint64_t v6;
  CGColorRef v7;
  uint64_t v8;
  uint64_t v10;

  v10 = 0;
  v2 = (float32x4_t *)objc_msgSend_decodeBytesForKey_returnedLength_(a1, a2, (uint64_t)a2, (uint64_t)&v10);
  v3 = 0uLL;
  if (v10 == 16)
    v3 = *v2;
  v4 = sub_1B179D614(v3);
  if (!v4)
    return 0;
  v7 = v4;
  v8 = objc_msgSend_colorWithCGColor_(MEMORY[0x1E0DC3658], v5, (uint64_t)v4, v6);
  CFRelease(v7);
  return v8;
}

uint64_t sub_1B18BD180(void *a1, const char *a2, double a3)
{
  _QWORD v4[2];

  v4[1] = *MEMORY[0x1E0C80C00];
  *(double *)v4 = a3;
  return objc_msgSend_encodeBytes_length_forKey_(a1, a2, (uint64_t)v4, 8, a2);
}

uint64_t sub_1B18BD1D8(void *a1, const char *a2, __n128 a3)
{
  unint64_t v4;
  unsigned __int32 v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4 = a3.n128_u64[0];
  v5 = a3.n128_u32[2];
  return objc_msgSend_encodeBytes_length_forKey_(a1, a2, (uint64_t)&v4, 12, a2);
}

uint64_t sub_1B18BD23C(void *a1, const char *a2, __n128 a3)
{
  __n128 v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  return objc_msgSend_encodeBytes_length_forKey_(a1, a2, (uint64_t)&v4, 16, a2);
}

uint64_t sub_1B18BD294(void *a1, const char *a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6)
{
  _OWORD v7[4];

  v7[0] = a3;
  v7[1] = a4;
  v7[2] = a5;
  v7[3] = a6;
  return objc_msgSend_encodeBytes_length_forKey_(a1, a2, (uint64_t)v7, 64, a2);
}

double sub_1B18BD2C4(void *a1, const char *a2)
{
  uint64_t v2;
  double result;
  uint64_t v4;

  v4 = 0;
  v2 = objc_msgSend_decodeBytesForKey_returnedLength_(a1, a2, (uint64_t)a2, (uint64_t)&v4);
  result = 0.0;
  if (v4 == 8)
    return *(double *)v2;
  return result;
}

double sub_1B18BD300(void *a1, const char *a2)
{
  uint64_t v2;
  double result;
  uint64_t v4;

  v4 = 0;
  v2 = objc_msgSend_decodeBytesForKey_returnedLength_(a1, a2, (uint64_t)a2, (uint64_t)&v4);
  result = 0.0;
  if (v4 == 12)
    return *(double *)v2;
  return result;
}

__n128 sub_1B18BD344(void *a1, const char *a2)
{
  uint64_t v2;
  __n128 result;
  uint64_t v4;

  v4 = 0;
  v2 = objc_msgSend_decodeBytesForKey_returnedLength_(a1, a2, (uint64_t)a2, (uint64_t)&v4);
  result.n128_u64[0] = 0;
  if (v4 == 16)
    return *(__n128 *)v2;
  return result;
}

__n128 sub_1B18BD380(void *a1, const char *a2)
{
  uint64_t v2;
  __int128 *v3;
  uint64_t v5;

  v5 = 0;
  v2 = objc_msgSend_decodeBytesForKey_returnedLength_(a1, a2, (uint64_t)a2, (uint64_t)&v5);
  if (v5 == 64)
    v3 = (__int128 *)v2;
  else
    v3 = &VFXMatrix4Identity;
  return (__n128)*v3;
}

uint64_t sub_1B18BD3C4(void *a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  void *v6;
  int v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  double *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v48;

  v6 = (void *)objc_msgSend_dictionary(MEMORY[0x1E0C99E08], (const char *)a2, a3, a4);
  v7 = *a2;
  v10 = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v8, *a2, v9);
  objc_msgSend_setValue_forKey_(v6, v11, v10, (uint64_t)CFSTR("type"));
  v12 = (double *)*((_QWORD *)a2 + 1);
  v23 = (void *)objc_msgSend_array(MEMORY[0x1E0C99DE8], v13, v14, v15);
  switch(v7)
  {
    case 0:
    case 1:
      v24 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E0CB3B18], v16, v17, v18, *v12, v12[1]);
      goto LABEL_6;
    case 2:
      v27 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E0CB3B18], v16, v17, v18, *v12, v12[1]);
      objc_msgSend_addObject_(v23, v28, v27, v29);
      v24 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E0CB3B18], v30, v31, v32, v12[2], v12[3]);
      goto LABEL_6;
    case 3:
      v33 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E0CB3B18], v16, v17, v18, *v12, v12[1]);
      objc_msgSend_addObject_(v23, v34, v33, v35);
      v39 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E0CB3B18], v36, v37, v38, v12[2], v12[3]);
      objc_msgSend_addObject_(v23, v40, v39, v41);
      v24 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E0CB3B18], v42, v43, v44, v12[4], v12[5]);
LABEL_6:
      objc_msgSend_addObject_(v23, v25, v24, v26);
      break;
    case 4:
      break;
    default:
      sub_1B17C4408(0, (uint64_t)CFSTR("Warning: CGPath archiving: unknown path element type"), v17, v18, v19, v20, v21, v22, v48);
      break;
  }
  objc_msgSend_setValue_forKey_(v6, v16, (uint64_t)v23, (uint64_t)CFSTR("points"));
  return objc_msgSend_addObject_(a1, v45, (uint64_t)v6, v46);
}

CGPath *sub_1B18BD514(void *a1)
{
  CGPath *Mutable;
  const char *v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  void *v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  const char *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  CGFloat v24;
  CGFloat v25;
  void *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  CGFloat v30;
  CGFloat v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  double v36;
  CGFloat v37;
  double v38;
  CGFloat v39;
  const char *v40;
  uint64_t v41;
  void *v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  CGFloat v46;
  CGFloat v47;
  void *v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  double v52;
  CGFloat v53;
  double v54;
  CGFloat v55;
  const char *v56;
  uint64_t v57;
  void *v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  double v62;
  CGFloat v63;
  double v64;
  CGFloat v65;
  const char *v66;
  uint64_t v67;
  void *v68;
  const char *v69;
  uint64_t v70;
  uint64_t v71;
  CGFloat v72;
  CGFloat v73;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  _BYTE v79[128];
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  Mutable = CGPathCreateMutable();
  v75 = 0u;
  v76 = 0u;
  v77 = 0u;
  v78 = 0u;
  v4 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v3, (uint64_t)&v75, (uint64_t)v79, 16);
  if (v4)
  {
    v7 = v4;
    v8 = *(_QWORD *)v76;
    do
    {
      for (i = 0; i != v7; ++i)
      {
        if (*(_QWORD *)v76 != v8)
          objc_enumerationMutation(a1);
        v10 = *(void **)(*((_QWORD *)&v75 + 1) + 8 * i);
        v11 = (void *)objc_msgSend_objectForKey_(v10, v5, (uint64_t)CFSTR("type"), v6);
        v15 = objc_msgSend_intValue(v11, v12, v13, v14);
        v18 = (void *)objc_msgSend_objectForKey_(v10, v16, (uint64_t)CFSTR("points"), v17);
        v19 = v18;
        switch(v15)
        {
          case 0:
            v20 = (void *)objc_msgSend_objectAtIndex_(v18, v5, 0, v6);
            objc_msgSend_VFX_CGPointValue(v20, v21, v22, v23);
            CGPathMoveToPoint(Mutable, 0, v24, v25);
            break;
          case 1:
            v26 = (void *)objc_msgSend_objectAtIndex_(v18, v5, 0, v6);
            objc_msgSend_VFX_CGPointValue(v26, v27, v28, v29);
            CGPathAddLineToPoint(Mutable, 0, v30, v31);
            break;
          case 2:
            v32 = (void *)objc_msgSend_objectAtIndex_(v18, v5, 0, v6);
            objc_msgSend_VFX_CGPointValue(v32, v33, v34, v35);
            v37 = v36;
            v39 = v38;
            v42 = (void *)objc_msgSend_objectAtIndex_(v19, v40, 1, v41);
            objc_msgSend_VFX_CGPointValue(v42, v43, v44, v45);
            CGPathAddQuadCurveToPoint(Mutable, 0, v37, v39, v46, v47);
            break;
          case 3:
            v48 = (void *)objc_msgSend_objectAtIndex_(v18, v5, 0, v6);
            objc_msgSend_VFX_CGPointValue(v48, v49, v50, v51);
            v53 = v52;
            v55 = v54;
            v58 = (void *)objc_msgSend_objectAtIndex_(v19, v56, 1, v57);
            objc_msgSend_VFX_CGPointValue(v58, v59, v60, v61);
            v63 = v62;
            v65 = v64;
            v68 = (void *)objc_msgSend_objectAtIndex_(v19, v66, 2, v67);
            objc_msgSend_VFX_CGPointValue(v68, v69, v70, v71);
            CGPathAddCurveToPoint(Mutable, 0, v53, v55, v63, v65, v72, v73);
            break;
          case 4:
            CGPathCloseSubpath(Mutable);
            break;
          default:
            continue;
        }
      }
      v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v5, (uint64_t)&v75, (uint64_t)v79, 16);
    }
    while (v7);
  }
  return Mutable;
}

uint64_t sub_1B18BD778(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  const CGPath *v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  _QWORD v23[2];
  _QWORD v24[3];

  v24[2] = *MEMORY[0x1E0C80C00];
  result = objc_msgSend_CGPath(a2, (const char *)a2, a3, a4);
  if (result)
  {
    v11 = (const CGPath *)result;
    v12 = (void *)objc_msgSend_array(MEMORY[0x1E0C99DE8], v8, v9, v10);
    CGPathApply(v11, v12, (CGPathApplierFunction)sub_1B18BD3C4);
    objc_msgSend_flatness(a2, v13, v14, v15);
    *(float *)&v16 = v16;
    v23[0] = CFSTR("path");
    v23[1] = CFSTR("flatness");
    v24[0] = v12;
    v24[1] = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v17, v18, v19, v16);
    v21 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v20, (uint64_t)v24, (uint64_t)v23, 2);
    return objc_msgSend_encodeObject_forKey_(a1, v22, v21, a3);
  }
  return result;
}

void *sub_1B18BD870(void *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  void *v13;
  const char *v14;
  uint64_t v15;
  float v16;
  void *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  float v21;
  const char *v22;
  uint64_t v23;
  CGPath *v24;
  const char *v25;
  uint64_t v26;
  CGPath *v27;
  void *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v11 = objc_msgSend_setWithObjects_(v4, v9, v5, v10, v6, v7, v8, 0);
  v13 = (void *)objc_msgSend_decodeObjectOfClasses_forKey_(a1, v12, v11, a2);
  objc_opt_class();
  v16 = -1.0;
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v17 = (void *)objc_msgSend_valueForKey_(v13, v14, (uint64_t)CFSTR("flatness"), v15);
    objc_msgSend_floatValue(v17, v18, v19, v20);
    v16 = v21;
    v13 = (void *)objc_msgSend_valueForKey_(v13, v22, (uint64_t)CFSTR("path"), v23);
  }
  v24 = sub_1B18BD514(v13);
  if (!v24)
    return 0;
  v27 = v24;
  v28 = (void *)objc_msgSend_bezierPathWithCGPath_(MEMORY[0x1E0DC3508], v25, (uint64_t)v24, v26);
  CFRelease(v27);
  if (v16 >= 0.0)
    objc_msgSend_setFlatness_(v28, v29, v30, v31, v16);
  return v28;
}

uint64_t sub_1B18BD9B8(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  const char *v14;

  v5 = objc_msgSend___CFObject(a2, (const char *)a2, a3, a4);
  result = sub_1B193E634(v5, v6, v7, v8, v9, v10, v11, v12);
  if (result)
    return objc_msgSend_encodeObject_forKey_(a1, v14, result, (uint64_t)CFSTR("entityID"));
  return result;
}

CFTypeRef sub_1B18BDA00(void *a1, void *a2)
{
  uint64_t v4;
  const char *v5;
  CFTypeRef result;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v4 = objc_opt_class();
  result = (CFTypeRef)objc_msgSend_decodeObjectOfClass_forKey_(a1, v5, v4, (uint64_t)CFSTR("entityID"));
  if (result)
  {
    v10 = result;
    v11 = objc_msgSend___CFObject(a2, v7, v8, v9);
    return sub_1B193E6E0(v11, v10, v12, v13, v14, v15, v16, v17);
  }
  return result;
}

uint64_t sub_1B18BDA60(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  const char *v6;

  result = sub_1B189EB54(a2);
  if (result)
    return objc_msgSend_encodeObject_forKey_(a1, v6, result, a3);
  return result;
}

uint64_t sub_1B18BDAB8(void *a1, const char *a2, uint64_t a3)
{
  uint64_t result;
  const char *v6;

  result = objc_msgSend_archivedDataWithRootObject_requiringSecureCoding_error_(MEMORY[0x1E0CB36F8], a2, (uint64_t)a2, 1, 0);
  if (result)
    return objc_msgSend_encodeObject_forKey_(a1, v6, result, a3);
  return result;
}

uint64_t sub_1B18BDB20(void *a1, uint64_t a2, void *a3)
{
  void *v3;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  void *v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  id v20;
  const char *v21;
  const char *v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;

  v3 = a3;
  if (a3)
  {
    v6 = objc_opt_class();
    v9 = objc_msgSend_setByAddingObject_(v3, v7, v6, v8);
  }
  else
  {
    v11 = (void *)MEMORY[0x1E0C99E60];
    v12 = objc_opt_class();
    v9 = objc_msgSend_setWithObject_(v11, v13, v12, v14);
  }
  v15 = objc_msgSend_decodeObjectOfClasses_forKey_(a1, v10, v9, a2);
  if (v15)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      if (objc_msgSend_requiresSecureCoding(a1, v16, v17, v18))
      {
        v20 = objc_alloc(MEMORY[0x1E0CB3710]);
        v23 = (void *)objc_msgSend_initForReadingFromData_error_(v20, v21, v15, 0);
        if (!v3)
        {
          if (qword_1EEF66118 != -1)
            dispatch_once(&qword_1EEF66118, &unk_1E63D8720);
          v3 = (void *)qword_1EEF66110;
        }
        v15 = objc_msgSend_decodeObjectOfClasses_forKey_(v23, v22, (uint64_t)v3, *MEMORY[0x1E0CB2CD0]);
        objc_msgSend_finishDecoding(v23, v24, v25, v26);

      }
      else
      {
        return objc_msgSend_unarchivedObjectOfClasses_fromData_error_(MEMORY[0x1E0CB3710], v19, (uint64_t)v3, v15, 0);
      }
    }
  }
  return v15;
}

void sub_1B18BDC64(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1B18BDC34);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1B18BDC88()
{
  if (qword_1EEF66118 != -1)
    dispatch_once(&qword_1EEF66118, &unk_1E63D8720);
  return qword_1EEF66110;
}

void *sub_1B18BDCC8(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  void *v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t i;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  const char *v37;
  void *result;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  void *v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  void *v47;
  const char *v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t j;
  void *v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  const char *v66;
  uint64_t v67;
  const char *v68;
  uint64_t v69;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  _QWORD v79[3];
  _QWORD v80[3];
  _BYTE v81[128];
  _BYTE v82[128];
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  v5 = (void *)objc_msgSend_animationKeys(a2, (const char *)a2, a3, a4);
  if (v5)
  {
    v9 = v5;
    if (objc_msgSend_count(v5, v6, v7, v8))
    {
      v10 = (void *)MEMORY[0x1E0C99DE8];
      v11 = objc_msgSend_count(v9, v6, v7, v8);
      v14 = (void *)objc_msgSend_arrayWithCapacity_(v10, v12, v11, v13);
      v15 = (void *)MEMORY[0x1E0C99DE8];
      v19 = objc_msgSend_count(v9, v16, v17, v18);
      v22 = (void *)objc_msgSend_arrayWithCapacity_(v15, v20, v19, v21);
      v75 = 0u;
      v76 = 0u;
      v77 = 0u;
      v78 = 0u;
      v24 = objc_msgSend_countByEnumeratingWithState_objects_count_(v9, v23, (uint64_t)&v75, (uint64_t)v82, 16);
      if (v24)
      {
        v28 = v24;
        v29 = *(_QWORD *)v76;
        do
        {
          for (i = 0; i != v28; ++i)
          {
            if (*(_QWORD *)v76 != v29)
              objc_enumerationMutation(v9);
            v31 = *(_QWORD *)(*((_QWORD *)&v75 + 1) + 8 * i);
            v32 = objc_msgSend_animationPlayerForKey_(a2, v25, v31, v27);
            objc_msgSend_addObject_(v22, v33, v31, v34);
            objc_msgSend_addObject_(v14, v35, v32, v36);
          }
          v28 = objc_msgSend_countByEnumeratingWithState_objects_count_(v9, v25, (uint64_t)&v75, (uint64_t)v82, 16);
        }
        while (v28);
      }
      if (objc_msgSend_count(v22, v25, v26, v27))
      {
        objc_msgSend_encodeObject_forKey_(a1, v6, (uint64_t)v14, (uint64_t)CFSTR("animation-players"));
        objc_msgSend_encodeObject_forKey_(a1, v37, (uint64_t)v22, (uint64_t)CFSTR("animation-keys"));
      }
    }
  }
  result = (void *)objc_msgSend__vfxBindings(a2, v6, v7, v8);
  if (result)
  {
    v42 = result;
    v43 = (void *)MEMORY[0x1E0C99DE8];
    v44 = objc_msgSend_count(result, v39, v40, v41);
    v47 = (void *)objc_msgSend_arrayWithCapacity_(v43, v45, v44, v46);
    v71 = 0u;
    v72 = 0u;
    v73 = 0u;
    v74 = 0u;
    v49 = objc_msgSend_countByEnumeratingWithState_objects_count_(v42, v48, (uint64_t)&v71, (uint64_t)v81, 16);
    if (v49)
    {
      v52 = v49;
      v53 = *(_QWORD *)v72;
      do
      {
        for (j = 0; j != v52; ++j)
        {
          if (*(_QWORD *)v72 != v53)
            objc_enumerationMutation(v42);
          v55 = (void *)objc_msgSend_valueForKey_(v42, v50, *(_QWORD *)(*((_QWORD *)&v71 + 1) + 8 * j), v51);
          if (objc_msgSend_sourceObject(v55, v56, v57, v58))
          {
            v79[0] = CFSTR("sourceObject");
            v80[0] = objc_msgSend_sourceObject(v55, v50, v59, v51);
            v79[1] = CFSTR("keyPathSrc");
            v80[1] = objc_msgSend_keyPathSrc(v55, v60, v61, v62);
            v79[2] = CFSTR("keyPathDst");
            v80[2] = objc_msgSend_keyPathDst(v55, v63, v64, v65);
            v67 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v66, (uint64_t)v80, (uint64_t)v79, 3);
            objc_msgSend_addObject_(v47, v68, v67, v69);
          }
        }
        v52 = objc_msgSend_countByEnumeratingWithState_objects_count_(v42, v50, (uint64_t)&v71, (uint64_t)v81, 16);
      }
      while (v52);
    }
    return (void *)objc_msgSend_encodeObject_forKey_(a1, v50, (uint64_t)v47, (uint64_t)CFSTR("bindings"));
  }
  return result;
}

void *sub_1B18BDFA4(void *a1, void *a2)
{
  uint64_t v4;
  const char *v5;
  void *v6;
  uint64_t v7;
  const char *v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  uint64_t v18;
  uint64_t v19;
  void *result;
  const char *v21;
  const char *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void *v26;
  void *v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  id obj;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _BYTE v45[128];
  _BYTE v46[128];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v4 = objc_opt_class();
  v6 = (void *)objc_msgSend_vfx_decodeArrayOfObjectsOfClass_forKey_(a1, v5, v4, (uint64_t)CFSTR("animation-keys"));
  v7 = objc_opt_class();
  v9 = (void *)objc_msgSend_vfx_decodeArrayOfObjectsOfClass_forKey_(a1, v8, v7, (uint64_t)CFSTR("animation-players"));
  v41 = 0u;
  v42 = 0u;
  v43 = 0u;
  v44 = 0u;
  v11 = objc_msgSend_countByEnumeratingWithState_objects_count_(v6, v10, (uint64_t)&v41, (uint64_t)v46, 16);
  if (v11)
  {
    v14 = v11;
    v15 = 0;
    v16 = *(_QWORD *)v42;
    do
    {
      for (i = 0; i != v14; ++i)
      {
        if (*(_QWORD *)v42 != v16)
          objc_enumerationMutation(v6);
        v18 = *(_QWORD *)(*((_QWORD *)&v41 + 1) + 8 * i);
        v19 = objc_msgSend_objectAtIndex_(v9, v12, v15 + i, v13);
        if (v19)
          objc_msgSend_addAnimationPlayer_forKey_(a2, v12, v19, v18);
      }
      v14 = objc_msgSend_countByEnumeratingWithState_objects_count_(v6, v12, (uint64_t)&v41, (uint64_t)v46, 16);
      v15 += i;
    }
    while (v14);
  }
  if (qword_1EEF66108 != -1)
    dispatch_once(&qword_1EEF66108, &unk_1E63D1BB0);
  result = (void *)objc_msgSend_vfx_decodeArrayOfObjectsOfClasses_forKey_(a1, v12, qword_1EEF66100, (uint64_t)CFSTR("bindings"));
  obj = result;
  if (result)
  {
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    result = (void *)objc_msgSend_countByEnumeratingWithState_objects_count_(result, v21, (uint64_t)&v37, (uint64_t)v45, 16);
    if (result)
    {
      v24 = result;
      v25 = *(_QWORD *)v38;
      do
      {
        v26 = 0;
        do
        {
          if (*(_QWORD *)v38 != v25)
            objc_enumerationMutation(obj);
          v27 = *(void **)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)v26);
          v28 = objc_msgSend_objectForKeyedSubscript_(v27, v22, (uint64_t)CFSTR("keyPathDst"), v23);
          v31 = objc_msgSend_objectForKeyedSubscript_(v27, v29, (uint64_t)CFSTR("sourceObject"), v30);
          v34 = objc_msgSend_objectForKeyedSubscript_(v27, v32, (uint64_t)CFSTR("keyPathSrc"), v33);
          objc_msgSend_bindAnimatablePath_toObject_withKeyPath_options_(a2, v35, v28, v31, v34, 0);
          v26 = (char *)v26 + 1;
        }
        while (v24 != v26);
        result = (void *)objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v22, (uint64_t)&v37, (uint64_t)v45, 16);
        v24 = result;
      }
      while (result);
    }
  }
  return result;
}

uint64_t sub_1B18BE224()
{
  if (qword_1EEF66108 != -1)
    dispatch_once(&qword_1EEF66108, &unk_1E63D1BB0);
  return qword_1EEF66100;
}

uint64_t sub_1B18BE264(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  void *PathComponent;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  const char *v41;
  uint64_t v42;
  unint64_t v43;
  __CFString *v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  const char *v52;
  uint64_t v53;
  id v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v59;
  id v60;
  const char *v61;
  uint64_t v62;
  void *v63;

  v5 = (void *)objc_msgSend_path(a1, a2, a3, a4);
  v8 = objc_msgSend_rangeOfString_(v5, v6, (uint64_t)CFSTR(".app/Contents/"), v7);
  if (!v9 || (v12 = (void *)objc_msgSend_substringFromIndex_(v5, v9, (uint64_t)&v9[v8], v11)) == 0)
  {
    v12 = (void *)objc_msgSend_path(a1, v9, v10, v11);
    if (!v12)
      return 0;
  }
  v13 = (void *)objc_msgSend_pathComponents(v12, v9, v10, v11);
  v17 = objc_msgSend_count(v13, v14, v15, v16);
  if (!v17)
    return 0;
  v21 = v17;
  v63 = a1;
  v22 = (void *)VFXGetResourceBundle(v17, v18, v19, v20);
  PathComponent = (void *)objc_msgSend_lastPathComponent(v12, v23, v24, v25);
  v30 = objc_msgSend_stringByDeletingPathExtension(PathComponent, v27, v28, v29);
  v34 = objc_msgSend_pathExtension(v12, v31, v32, v33);
  v38 = v21 - 1;
  if (v21 == 1)
  {
LABEL_12:
    v50 = (void *)MEMORY[0x1E0DC3870];
    v51 = objc_msgSend_lastPathComponent(v63, v35, v36, v37);
    v54 = (id)objc_msgSend_imageNamed_(v50, v52, v51, v53);
  }
  else
  {
    v39 = v34;
    v40 = 0;
    while (1)
    {
      v43 = objc_msgSend_count(v13, v35, v36, v37) - 1;
      v44 = &stru_1E63FD500;
      if (v43 > v40)
      {
        v44 = &stru_1E63FD500;
        v45 = v40;
        do
        {
          v46 = objc_msgSend_objectAtIndex_(v13, v41, v45, v42);
          v44 = (__CFString *)objc_msgSend_stringByAppendingPathComponent_(v44, v47, v46, v48);
          ++v45;
        }
        while (v43 != v45);
      }
      v49 = objc_msgSend_pathForResource_ofType_inDirectory_(v22, v41, v30, v39, v44);
      if (v49)
        break;
      if (++v40 == v38)
        goto LABEL_12;
    }
    v59 = v49;
    v60 = objc_alloc(MEMORY[0x1E0DC3870]);
    v54 = (id)objc_msgSend_initWithContentsOfFile_(v60, v61, v59, v62);
  }
  return objc_msgSend_CGImage(v54, v55, v56, v57);
}

void *VFXResolveImageContents(void *a1, void *a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  void *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  void *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  char v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  void *v57;
  void *v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t PathComponent;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  const char *v67;
  const char *v68;
  uint64_t v69;
  const char *v70;
  uint64_t v71;
  char v72;
  void *v73;
  const char *v74;
  uint64_t v75;
  uint64_t v76;
  void *v77;
  const char *v78;
  uint64_t v79;
  const char *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  const char *v84;
  uint64_t v85;
  void *v86;
  const char *v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  const char *v91;
  uint64_t v92;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v7 = 0;
  }
  else
  {
    objc_opt_class();
    v8 = 0;
    v7 = a1;
    a1 = 0;
    if ((objc_opt_isKindOfClass() & 1) == 0)
      return (void *)v8;
  }
  v9 = (void *)objc_msgSend_scheme(a1, v4, v5, v6);
  if (objc_msgSend_isEqualToString_(v9, v10, (uint64_t)CFSTR("imageNamed"), v11))
  {
    v15 = objc_msgSend_absoluteString(a1, v12, v13, v14);
  }
  else
  {
    if (v7)
      goto LABEL_9;
    if (!objc_msgSend_isFileURL(a1, v12, v13, v14) || objc_msgSend_query(a1, v12, v16, v14))
      goto LABEL_21;
    v15 = objc_msgSend_path(a1, v12, v16, v14);
  }
  v7 = (void *)v15;
  if (!v15)
  {
LABEL_21:
    v7 = 0;
    if (!a1)
      return 0;
    v48 = 0;
    goto LABEL_23;
  }
LABEL_9:
  if (objc_msgSend_hasPrefix_(v7, v12, (uint64_t)CFSTR("imageNamed://"), v14))
  {
    v19 = objc_msgSend_substringFromIndex_(v7, v17, 13, v18);
    v22 = objc_msgSend_imageNamed_(MEMORY[0x1E0DC3870], v20, v19, v21);
    if (v22)
      return (void *)v22;
    else
      return (void *)v19;
  }
  v23 = objc_msgSend_rangeOfString_(v7, v17, (uint64_t)CFSTR(".app/Contents/"), v18);
  if (!v24
    || (v23 = objc_msgSend_substringFromIndex_(v7, v24, (uint64_t)&v24[v23], v26)) == 0
    || (v27 = (void *)v23,
        v28 = (void *)VFXGetResourceBundle(v23, v24, v25, v26),
        v32 = objc_msgSend_stringByDeletingPathExtension(v27, v29, v30, v31),
        v36 = objc_msgSend_pathExtension(v27, v33, v34, v35),
        v23 = objc_msgSend_URLForResource_withExtension_(v28, v37, v32, v36),
        (v8 = v23) == 0))
  {
    v38 = (void *)VFXGetResourceBundle(v23, v24, v25, v26);
    v42 = objc_msgSend_stringByDeletingPathExtension(v7, v39, v40, v41);
    v46 = objc_msgSend_pathExtension(v7, v43, v44, v45);
    v8 = objc_msgSend_URLForResource_withExtension_(v38, v47, v42, v46);
    if (!v8)
    {
      if (!a1)
      {
        v52 = objc_msgSend_fileURLWithPath_(MEMORY[0x1E0C99E98], v12, (uint64_t)v7, v14);
        v57 = (void *)v52;
        v56 = 1;
        v48 = 1;
LABEL_30:
        v58 = (void *)VFXGetResourceBundle(v52, v53, v54, v55);
        PathComponent = objc_msgSend_lastPathComponent(v57, v59, v60, v61);
        v66 = objc_msgSend_pathExtension(v57, v63, v64, v65);
        v8 = objc_msgSend_URLForResource_withExtension_(v58, v67, PathComponent, v66);
        if (!v8)
        {
          v8 = (uint64_t)v57;
          if ((objc_msgSend_checkResourceIsReachableAndReturnError_(v57, v68, 0, v69) & 1) == 0)
          {
            v72 = v48 ^ 1;
            if (!a2)
              v72 = 1;
            if ((v72 & 1) != 0)
              goto LABEL_41;
            v73 = (void *)objc_msgSend_URLByAppendingPathComponent_(a2, v70, (uint64_t)v7, v71);
            v77 = (void *)objc_msgSend_URLByStandardizingPath(v73, v74, v75, v76);
            if (v77 == v73
              || (v8 = (uint64_t)v77, (objc_msgSend_checkResourceIsReachableAndReturnError_(v77, v78, 0, v79) & 1) == 0))
            {
              v8 = (uint64_t)v73;
              if ((objc_msgSend_checkResourceIsReachableAndReturnError_(v73, v78, 0, v79) & 1) == 0)
              {
                v83 = objc_msgSend_lastPathComponent(v7, v80, v81, v82);
                v86 = (void *)objc_msgSend_URLByAppendingPathComponent_(a2, v84, v83, v85);
                v90 = (void *)objc_msgSend_URLByStandardizingPath(v86, v87, v88, v89);
                if (v90 == v86
                  || (v8 = (uint64_t)v90,
                      (objc_msgSend_checkResourceIsReachableAndReturnError_(v90, v91, 0, v92) & 1) == 0))
                {
                  v8 = (uint64_t)v86;
                  if ((objc_msgSend_checkResourceIsReachableAndReturnError_(v86, v91, 0, v92) & 1) == 0)
                  {
LABEL_41:
                    if (v56)
                      return v7;
                    else
                      return a1;
                  }
                }
              }
            }
          }
        }
        return (void *)v8;
      }
      v48 = 1;
LABEL_23:
      if (!objc_msgSend_isFileURL(a1, v12, v16, v14))
        return a1;
      v52 = objc_msgSend_query(a1, v49, v50, v51);
      if (v52)
        return a1;
      v56 = 0;
      v57 = a1;
      goto LABEL_30;
    }
  }
  return (void *)v8;
}

id sub_1B18BE6FC(id result)
{
  void *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  id v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  void *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  const char *v32;
  uint64_t v33;
  void *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  double v39;
  const char *v40;
  uint64_t v41;
  void *v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  const char *v48;
  uint64_t v49;
  void *v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  const char *v56;
  uint64_t v57;
  void *v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  const char *v64;
  uint64_t v65;
  void *v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  double v71;
  double v72;
  double v73;
  double v74;
  const char *v75;
  void *v76;
  const char *v77;
  uint64_t v78;
  void *v79;
  const char *v80;
  uint64_t v81;
  uint64_t v82;
  const char *v83;
  uint64_t v84;
  uint64_t v85;
  const char *v86;
  uint64_t v87;
  void *v88;
  const char *v89;
  uint64_t v90;
  uint64_t v91;
  const char *v92;
  uint64_t v93;
  uint64_t v94;
  const char *v95;
  uint64_t v96;
  void *v97;
  const char *v98;
  uint64_t v99;
  uint64_t v100;
  const char *v101;
  uint64_t v102;
  uint64_t v103;
  const char *v104;
  uint64_t v105;
  void *v106;
  const char *v107;
  uint64_t v108;
  uint64_t v109;
  const char *v110;
  uint64_t v111;
  uint64_t v112;
  const char *v113;
  uint64_t v114;
  void *v115;
  const char *v116;
  uint64_t v117;
  uint64_t v118;
  const char *v119;
  uint64_t v120;
  uint64_t v121;
  const char *v122;
  uint64_t v123;
  void *v124;
  const char *v125;
  uint64_t v126;
  uint64_t v127;
  const char *v128;
  uint64_t v129;
  uint64_t v130;
  const char *v131;
  uint64_t v132;
  uint64_t v133;
  const char *v134;
  uint64_t v135;
  void *v136;
  uint64_t v137;
  const char *v138;
  void *v139;
  uint64_t v140;
  uint64_t v141;
  const char *v142;
  uint64_t v143;
  void *v144;
  const char *v145;
  uint64_t v146;
  uint64_t v147;
  unsigned int v148;
  const char *v149;
  uint64_t v150;
  void *v151;
  const char *v152;
  uint64_t v153;
  uint64_t v154;
  const char *v155;
  uint64_t v156;
  uint64_t v157;
  unsigned int v158;
  const char *v159;
  uint64_t v160;
  uint64_t v161;
  const char *v162;
  uint64_t v163;
  const char *v164;
  uint64_t v165;
  uint64_t v166;
  unsigned int v167;
  unsigned int v168;

  if (result)
  {
    v1 = result;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v9 = (void *)objc_msgSend_valueForKey_(v1, v2, (uint64_t)CFSTR("type"), v4);
      if (objc_msgSend_isEqualToString_(v9, v10, (uint64_t)CFSTR("MDLSkyCubeTexture"), v11))
      {
        v14 = objc_alloc(MEMORY[0x1E0CC77F0]);
        v17 = objc_msgSend_objectForKeyedSubscript_(v1, v15, (uint64_t)CFSTR("name"), v16);
        v20 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v18, (uint64_t)CFSTR("channelEncoding"), v19);
        v24 = objc_msgSend_integerValue(v20, v21, v22, v23);
        v27 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v25, (uint64_t)CFSTR("dimensions.x"), v26);
        objc_msgSend_floatValue(v27, v28, v29, v30);
        v167 = v31;
        v34 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v32, (uint64_t)CFSTR("dimensions.x"), v33);
        objc_msgSend_floatValue(v34, v35, v36, v37);
        v39 = COERCE_DOUBLE(vcvt_s32_f32((float32x2_t)__PAIR64__(v38, v167)));
        v42 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v40, (uint64_t)CFSTR("turbidity"), v41);
        objc_msgSend_floatValue(v42, v43, v44, v45);
        v47 = v46;
        v50 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v48, (uint64_t)CFSTR("sunElevation"), v49);
        objc_msgSend_floatValue(v50, v51, v52, v53);
        v55 = v54;
        v58 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v56, (uint64_t)CFSTR("upperAtmosphereScattering"), v57);
        objc_msgSend_floatValue(v58, v59, v60, v61);
        v63 = v62;
        v66 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v64, (uint64_t)CFSTR("groundAlbedo"), v65);
        objc_msgSend_floatValue(v66, v67, v68, v69);
        LODWORD(v71) = v70;
        LODWORD(v72) = v47;
        LODWORD(v73) = v55;
        LODWORD(v74) = v63;
        v76 = (void *)objc_msgSend_initWithName_channelEncoding_textureDimensions_turbidity_sunElevation_upperAtmosphereScattering_groundAlbedo_(v14, v75, v17, v24, v39, v72, v73, v74, v71);
        v79 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v77, (uint64_t)CFSTR("horizonElevation"), v78);
        objc_msgSend_floatValue(v79, v80, v81, v82);
        objc_msgSend_setHorizonElevation_(v76, v83, v84, v85);
        v88 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v86, (uint64_t)CFSTR("gamma"), v87);
        objc_msgSend_floatValue(v88, v89, v90, v91);
        objc_msgSend_setGamma_(v76, v92, v93, v94);
        v97 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v95, (uint64_t)CFSTR("exposure"), v96);
        objc_msgSend_floatValue(v97, v98, v99, v100);
        objc_msgSend_setExposure_(v76, v101, v102, v103);
        v106 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v104, (uint64_t)CFSTR("brightness"), v105);
        objc_msgSend_floatValue(v106, v107, v108, v109);
        objc_msgSend_setBrightness_(v76, v110, v111, v112);
        v115 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v113, (uint64_t)CFSTR("contrast"), v114);
        objc_msgSend_floatValue(v115, v116, v117, v118);
        objc_msgSend_setContrast_(v76, v119, v120, v121);
        v124 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v122, (uint64_t)CFSTR("saturation"), v123);
        objc_msgSend_floatValue(v124, v125, v126, v127);
        objc_msgSend_setSaturation_(v76, v128, v129, v130);
        v133 = objc_msgSend_objectForKeyedSubscript_(v1, v131, (uint64_t)CFSTR("groundColor"), v132);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v136 = (void *)MEMORY[0x1E0CB3710];
          v137 = objc_opt_class();
          v139 = (void *)objc_msgSend_unarchivedObjectOfClass_fromData_error_(v136, v138, v137, v133, 0);
          if (v139)
          {
            v141 = objc_msgSend_CGColor(v139, v134, v140, v135);
            objc_msgSend_setGroundColor_(v76, v142, v141, v143);
          }
        }
        v144 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v134, (uint64_t)CFSTR("highDynamicRangeCompression.x"), v135);
        objc_msgSend_floatValue(v144, v145, v146, v147);
        v168 = v148;
        v151 = (void *)objc_msgSend_objectForKeyedSubscript_(v1, v149, (uint64_t)CFSTR("highDynamicRangeCompression.y"), v150);
        objc_msgSend_floatValue(v151, v152, v153, v154);
        objc_msgSend_setHighDynamicRangeCompression_(v76, v155, v156, v157, COERCE_DOUBLE(__PAIR64__(v158, v168)));
        objc_msgSend_updateTexture(v76, v159, v160, v161);
        return v76;
      }
      else
      {
        result = (id)objc_msgSend_valueForKey_(v1, v12, (uint64_t)CFSTR("data"), v13);
        if (!result)
        {
          result = (id)objc_msgSend_valueForKey_(v1, v162, (uint64_t)CFSTR("path"), v163);
          if (!result)
            return (id)objc_msgSend_valueForKey_(v1, v164, (uint64_t)CFSTR("URL"), v165);
        }
      }
    }
    else
    {
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: VFXDecodemage: invalid archive"), v3, v4, v5, v6, v7, v8, v166);
      return 0;
    }
  }
  return result;
}

id sub_1B18BEA64(void *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  void *v18;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v8 = objc_msgSend_setWithObject_(v4, v6, v5, v7);
  v9 = (void *)MEMORY[0x1E0C99E60];
  v10 = objc_opt_class();
  v11 = objc_opt_class();
  v12 = objc_opt_class();
  v13 = objc_opt_class();
  v16 = objc_msgSend_setWithObjects_(v9, v14, v10, v15, v11, v12, v13, 0);
  v18 = (void *)objc_msgSend_vfx_decodeDictionaryWithKeysOfClasses_objectsOfClasses_forKey_(a1, v17, v8, v16, a2);
  return sub_1B18BE6FC(v18);
}

uint64_t sub_1B18BEB2C(void *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  const char *v6;

  v5 = sub_1B18BEB60(a1, a3);
  return objc_msgSend_encodeObject_forKey_(a1, v6, (uint64_t)v5, a2);
}

void *sub_1B18BEB60(void *a1, uint64_t a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  _BOOL4 v28;
  void *v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  CGImageRef v47;
  const char *v48;
  uint64_t v49;
  CGImage *v50;
  UIImage *v51;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v11 = (void *)objc_msgSend_options(a1, v4, v5, v6);
    v14 = (void *)objc_msgSend_objectForKeyedSubscript_(v11, v12, (uint64_t)CFSTR("VFXWorldExportEmbedImages"), v13);
    v18 = objc_msgSend_BOOLValue(v14, v15, v16, v17);
  }
  else
  {
    v18 = 0;
  }
  v19 = (void *)sub_1B1809180(a2, (uint64_t)v4, v5, v6, v7, v8, v9, v10);
  v23 = (uint64_t)v19;
  if (v19)
  {
    v24 = (void *)objc_msgSend_query(v19, v20, v21, v22);
    v28 = objc_msgSend_length(v24, v25, v26, v27) == 0;
  }
  else
  {
    v28 = 0;
  }
  v29 = (void *)objc_msgSend_dictionary(MEMORY[0x1E0C99E08], v20, v21, v22);
  v37 = v29;
  if (!v28 || v18)
  {
    v45 = sub_1B180A64C(a2, (uint64_t)v30, v31, v32, v33, v34, v35, v36);
    if (v45
      || (v47 = sub_1B1809CAC(a2, (uint64_t)v38, v39, v40, v41, v42, v43, v44)) != 0
      && (v50 = v47,
          v51 = (UIImage *)objc_msgSend_imageWithCGImage_(MEMORY[0x1E0DC3870], v48, (uint64_t)v47, v49),
          v45 = (uint64_t)UIImagePNGRepresentation(v51),
          CGImageRelease(v50),
          v45))
    {
      objc_msgSend_setObject_forKey_(v37, v38, v45, (uint64_t)CFSTR("data"));
    }
  }
  else
  {
    objc_msgSend_setObject_forKey_(v29, v30, v23, (uint64_t)CFSTR("URL"));
  }
  return v37;
}

void *sub_1B18BEC8C(void *result, const char *a2)
{
  if (a2)
    return (void *)objc_msgSend_encodeObject_forKey_(result, a2, (uint64_t)a2, (uint64_t)CFSTR("name"));
  return result;
}

uint64_t sub_1B18BECA4()
{
  if (qword_1EEF660F8 != -1)
    dispatch_once(&qword_1EEF660F8, &unk_1E63D0F70);
  return qword_1EEF660F0;
}

uint64_t sub_1B18BECE4()
{
  id v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t result;

  v0 = objc_alloc(MEMORY[0x1E0C99E60]);
  v1 = objc_opt_class();
  v2 = objc_opt_class();
  v3 = objc_opt_class();
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  result = objc_msgSend_initWithObjects_(v0, v9, v1, v10, v2, v3, v4, v5, v6, v7, v8, 0);
  qword_1EEF660F0 = result;
  return result;
}

uint64_t sub_1B18BEDCC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  id v27;

  v27 = objc_alloc(MEMORY[0x1E0C99E60]);
  v26 = objc_opt_class();
  v25 = objc_opt_class();
  v24 = objc_opt_class();
  v23 = objc_opt_class();
  v22 = objc_opt_class();
  v21 = objc_opt_class();
  v20 = objc_opt_class();
  v19 = objc_opt_class();
  v18 = objc_opt_class();
  v17 = objc_opt_class();
  v16 = objc_opt_class();
  v15 = objc_opt_class();
  v14 = objc_opt_class();
  v0 = objc_opt_class();
  v1 = objc_opt_class();
  v2 = (uint64_t)sub_1B18CC5EC();
  if (!v2)
    v2 = objc_opt_class();
  v3 = (uint64_t)sub_1B18CC5F8();
  if (!v3)
    v3 = objc_opt_class();
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  v10 = objc_opt_class();
  result = objc_msgSend_initWithObjects_(v27, v11, v26, v12, v25, v24, v23, v22, v21, v20, v19, v18, v17, v16, v15, v14, v0, v1, v2,
             v3,
             v4,
             v5,
             v6,
             v7,
             v8,
             v9,
             v10,
             0);
  qword_1EEF66100 = result;
  return result;
}

id sub_1B18BF030()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  id result;
  _QWORD v6[3];

  v6[2] = *MEMORY[0x1E0C80C00];
  if (qword_1EEF66108 != -1)
    dispatch_once(&qword_1EEF66108, &unk_1E63D1BB0);
  v0 = (void *)qword_1EEF66100;
  v6[0] = objc_opt_class();
  v6[1] = objc_opt_class();
  v2 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E0C99D20], v1, (uint64_t)v6, 2);
  result = (id)objc_msgSend_setByAddingObjectsFromArray_(v0, v3, v2, v4);
  qword_1EEF66110 = (uint64_t)result;
  return result;
}

void sub_1B18BF0F4(void *a1, uint64_t a2, void *a3)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  const void *v47;
  void *v48;
  const char *v49;
  const char *v50;
  uint64_t v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  const __CFString *v55;
  void *v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  const char *v68;
  uint64_t v69;
  uint64_t v70;
  const char *v71;
  uint64_t v72;
  uint64_t v73;
  void *v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  void *v81;
  const char *v82;
  uint64_t v83;
  uint64_t v84;
  const char *v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  const char *v89;
  uint64_t v90;
  uint64_t v91;
  const char *v92;
  uint64_t v93;
  uint64_t v94;
  void *v95;
  const char *v96;
  uint64_t v97;
  uint64_t v98;
  const char *v99;
  uint64_t v100;
  uint64_t v101;
  void *v102;
  const char *v103;
  uint64_t v104;
  uint64_t v105;
  const char *v106;
  uint64_t v107;
  uint64_t v108;
  void *v109;
  const char *v110;
  uint64_t v111;
  uint64_t v112;
  const char *v113;
  uint64_t v114;
  uint64_t v115;
  void *v116;
  const char *v117;
  uint64_t v118;
  uint64_t v119;
  const char *v120;
  uint64_t v121;
  uint64_t v122;
  void *v123;
  const char *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  const char *v128;
  uint64_t v129;
  void *v130;
  const char *v131;
  uint64_t v132;
  uint64_t v133;
  unsigned int v134;
  const char *v135;
  uint64_t v136;
  void *v137;
  const char *v138;
  uint64_t v139;
  uint64_t v140;
  unsigned int v141;
  const char *v142;
  uint64_t v143;
  void *v144;
  const char *v145;
  uint64_t v146;
  uint64_t v147;
  const char *v148;
  uint64_t v149;
  uint64_t v150;
  void *v151;
  const char *v152;
  uint64_t v153;
  uint64_t v154;
  double v155;
  const char *v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  const char *v160;
  const __CFString *v161;
  uint64_t v162;
  const char *v163;
  _QWORD v164[18];
  _QWORD v165[19];

  v165[18] = *MEMORY[0x1E0C80C00];
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v9 = (void *)objc_msgSend_options(a1, v6, v7, v8);
    v12 = (void *)objc_msgSend_objectForKeyedSubscript_(v9, v10, (uint64_t)CFSTR("VFXWorldExportEmbedImages"), v11);
    v16 = objc_msgSend_BOOLValue(v12, v13, v14, v15) ^ 1;
  }
  else
  {
    v16 = 1;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && v16)
  {
    v20 = (void *)objc_msgSend_dictionary(MEMORY[0x1E0C99E08], v17, v18, v19);
    objc_msgSend_setObject_forKey_(v20, v21, (uint64_t)a3, (uint64_t)CFSTR("path"));
LABEL_7:
    objc_msgSend_encodeObject_forKey_(a1, v22, (uint64_t)v20, a2);
    return;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & v16) == 1)
  {
    v26 = (void *)objc_msgSend_query(a3, v23, v24, v25);
    if (!objc_msgSend_length(v26, v27, v28, v29))
    {
      v20 = (void *)objc_msgSend_dictionary(MEMORY[0x1E0C99E08], v30, v31, v32);
      objc_msgSend_setObject_forKey_(v20, v50, (uint64_t)a3, (uint64_t)CFSTR("URL"));
      goto LABEL_7;
    }
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if (objc_msgSend_groundColor(a3, v33, v34, v35))
    {
      v39 = (void *)MEMORY[0x1E0DC3658];
      v40 = objc_msgSend_groundColor(a3, v36, v37, v38);
      v43 = objc_msgSend_colorWithCGColor_(v39, v41, v40, v42);
      v45 = objc_msgSend_archivedDataWithRootObject_requiringSecureCoding_error_(MEMORY[0x1E0CB36F8], v44, v43, 1, 0);
    }
    else
    {
      v45 = 0;
    }
    v165[0] = CFSTR("MDLSkyCubeTexture");
    v164[0] = CFSTR("type");
    v164[1] = CFSTR("name");
    v51 = objc_msgSend_name(a3, v36, v37, v38);
    if (v51)
      v55 = (const __CFString *)v51;
    else
      v55 = &stru_1E63FD500;
    v165[1] = v55;
    v164[2] = CFSTR("turbidity");
    v56 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_turbidity(a3, v52, v53, v54);
    v165[2] = objc_msgSend_numberWithFloat_(v56, v57, v58, v59);
    v164[3] = CFSTR("sunElevation");
    v60 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_sunElevation(a3, v61, v62, v63);
    v165[3] = objc_msgSend_numberWithFloat_(v60, v64, v65, v66);
    v164[4] = CFSTR("upperAtmosphereScattering");
    v67 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_upperAtmosphereScattering(a3, v68, v69, v70);
    v165[4] = objc_msgSend_numberWithFloat_(v67, v71, v72, v73);
    v164[5] = CFSTR("groundAlbedo");
    v74 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_groundAlbedo(a3, v75, v76, v77);
    v165[5] = objc_msgSend_numberWithFloat_(v74, v78, v79, v80);
    v164[6] = CFSTR("horizonElevation");
    v81 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_horizonElevation(a3, v82, v83, v84);
    v165[6] = objc_msgSend_numberWithFloat_(v81, v85, v86, v87);
    v164[7] = CFSTR("gamma");
    v88 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_gamma(a3, v89, v90, v91);
    v165[7] = objc_msgSend_numberWithFloat_(v88, v92, v93, v94);
    v164[8] = CFSTR("exposure");
    v95 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_exposure(a3, v96, v97, v98);
    v165[8] = objc_msgSend_numberWithFloat_(v95, v99, v100, v101);
    v164[9] = CFSTR("brightness");
    v102 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_brightness(a3, v103, v104, v105);
    v165[9] = objc_msgSend_numberWithFloat_(v102, v106, v107, v108);
    v164[10] = CFSTR("contrast");
    v109 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_contrast(a3, v110, v111, v112);
    v165[10] = objc_msgSend_numberWithFloat_(v109, v113, v114, v115);
    v164[11] = CFSTR("saturation");
    v116 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_saturation(a3, v117, v118, v119);
    v165[11] = objc_msgSend_numberWithFloat_(v116, v120, v121, v122);
    v164[12] = CFSTR("channelEncoding");
    v123 = (void *)MEMORY[0x1E0CB37E8];
    v127 = objc_msgSend_channelEncoding(a3, v124, v125, v126);
    v165[12] = objc_msgSend_numberWithInteger_(v123, v128, v127, v129);
    v164[13] = CFSTR("dimensions.x");
    v130 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_dimensions(a3, v131, v132, v133);
    v165[13] = objc_msgSend_numberWithInt_(v130, v135, v134, v136);
    v164[14] = CFSTR("dimensions.y");
    v137 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_dimensions(a3, v138, v139, v140);
    v165[14] = objc_msgSend_numberWithInt_(v137, v142, v141, v143);
    v164[15] = CFSTR("highDynamicRangeCompression.x");
    v144 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_highDynamicRangeCompression(a3, v145, v146, v147);
    v165[15] = objc_msgSend_numberWithFloat_(v144, v148, v149, v150);
    v164[16] = CFSTR("highDynamicRangeCompression.y");
    v151 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend_highDynamicRangeCompression(a3, v152, v153, v154);
    LODWORD(v155) = HIDWORD(v155);
    v159 = objc_msgSend_numberWithFloat_(v151, v156, v157, v158, v155);
    v164[17] = CFSTR("groundColor");
    if (v45)
      v161 = (const __CFString *)v45;
    else
      v161 = &stru_1E63FD500;
    v165[16] = v159;
    v165[17] = v161;
    v162 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v160, (uint64_t)v165, (uint64_t)v164, 18);
    objc_msgSend_encodeObject_forKey_(a1, v163, v162, a2);
  }
  else
  {
    v46 = objc_msgSend_copyCFXImageFromImage_(VFXMaterialProperty, v33, (uint64_t)a3, v35);
    if (v46)
    {
      v47 = (const void *)v46;
      v48 = sub_1B18BEB60(a1, v46);
      objc_msgSend_encodeObject_forKey_(a1, v49, (uint64_t)v48, a2);
      CFRelease(v47);
    }
  }
}

uint64_t sub_1B18BF5F4(void *a1, const char *a2, void *a3, uint64_t a4)
{
  void *v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  uint64_t v18;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[128];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v7 = (void *)objc_msgSend_array(MEMORY[0x1E0C99DE8], a2, (uint64_t)a3, a4);
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v9 = objc_msgSend_countByEnumeratingWithState_objects_count_(a3, v8, (uint64_t)&v20, (uint64_t)v24, 16);
  if (v9)
  {
    v12 = v9;
    v13 = *(_QWORD *)v21;
    do
    {
      v14 = 0;
      do
      {
        if (*(_QWORD *)v21 != v13)
          objc_enumerationMutation(a3);
        v15 = objc_msgSend_copyCFXImageFromImage_(VFXMaterialProperty, v10, *(_QWORD *)(*((_QWORD *)&v20 + 1) + 8 * v14), v11);
        if (v15)
        {
          v16 = sub_1B18BEB60(a1, v15);
          objc_msgSend_addObject_(v7, v17, (uint64_t)v16, v18);
        }
        ++v14;
      }
      while (v12 != v14);
      v12 = objc_msgSend_countByEnumeratingWithState_objects_count_(a3, v10, (uint64_t)&v20, (uint64_t)v24, 16);
    }
    while (v12);
  }
  return objc_msgSend_encodeObject_forKey_(a1, v10, (uint64_t)v7, (uint64_t)a2);
}

void *sub_1B18BF730(void *a1, const char *a2)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  id v15;
  const char *v16;
  uint64_t v17;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _BYTE v23[128];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (qword_1EEF660F8 != -1)
    dispatch_once(&qword_1EEF660F8, &unk_1E63D0F70);
  v4 = objc_msgSend_decodeObjectOfClasses_forKey_(a1, a2, qword_1EEF660F0, (uint64_t)a2);
  if (!v4)
    return 0;
  v8 = (void *)v4;
  v9 = (void *)objc_msgSend_array(MEMORY[0x1E0C99DE8], v5, v6, v7);
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v11 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v10, (uint64_t)&v19, (uint64_t)v23, 16);
  if (v11)
  {
    v12 = v11;
    v13 = *(_QWORD *)v20;
    do
    {
      for (i = 0; i != v12; ++i)
      {
        if (*(_QWORD *)v20 != v13)
          objc_enumerationMutation(v8);
        v15 = sub_1B18BE6FC(*(id *)(*((_QWORD *)&v19 + 1) + 8 * i));
        if (v15)
          objc_msgSend_addObject_(v9, v16, (uint64_t)v15, v17);
      }
      v12 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v16, (uint64_t)&v19, (uint64_t)v23, 16);
    }
    while (v12);
  }
  return v9;
}

void *sub_1B18BF884(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  const char *v18;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[128];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = (void *)objc_msgSend_mutableCopy(a1, a2, a3, a4);
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v6, (uint64_t)&v20, (uint64_t)v24, 16);
  if (v7)
  {
    v8 = v7;
    v9 = 0;
    v10 = *(_QWORD *)v21;
    do
    {
      v11 = 0;
      v12 = v9;
      do
      {
        if (*(_QWORD *)v21 != v10)
          objc_enumerationMutation(a1);
        v13 = *(void **)(*((_QWORD *)&v20 + 1) + 8 * v11);
        if ((objc_opt_respondsToSelector() & 1) != 0)
        {
          v17 = (void *)objc_msgSend_VFXMutableDeepCopy(v13, v14, v15, v16);
          objc_msgSend_replaceObjectAtIndex_withObject_(v5, v18, v12 + v11, (uint64_t)v17);

        }
        ++v11;
      }
      while (v8 != v11);
      v8 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v14, (uint64_t)&v20, (uint64_t)v24, 16);
      v9 = v12 + v11;
    }
    while (v8);
  }
  return v5;
}

void *sub_1B18BF9C4(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[128];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v4 = (void *)objc_msgSend_mutableCopy(a1, a2, a3, a4);
  v8 = (void *)objc_msgSend_allKeys(v4, v5, v6, v7);
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v10 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v9, (uint64_t)&v22, (uint64_t)v26, 16);
  if (v10)
  {
    v13 = v10;
    v14 = *(_QWORD *)v23;
    do
    {
      for (i = 0; i != v13; ++i)
      {
        if (*(_QWORD *)v23 != v14)
          objc_enumerationMutation(v8);
        v16 = *(_QWORD *)(*((_QWORD *)&v22 + 1) + 8 * i);
        v17 = (void *)objc_msgSend_objectForKey_(v4, v11, v16, v12);
        if ((objc_opt_respondsToSelector() & 1) != 0)
        {
          v19 = (void *)objc_msgSend_VFXMutableDeepCopy(v17, v11, v18, v12);
          objc_msgSend_setValue_forKey_(v4, v20, (uint64_t)v19, v16);

        }
      }
      v13 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v11, (uint64_t)&v22, (uint64_t)v26, 16);
    }
    while (v13);
  }
  return v4;
}

uint64_t sub_1B18C00D0(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_valueForKey_(a1, a2, (uint64_t)a2, a4);
}

uint64_t sub_1B18C00D8(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_setValue_forKey_(a1, a2, a3, (uint64_t)a2);
}

uint64_t sub_1B18C00E0(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_removeObjectForKey_(a1, a2, (uint64_t)a2, a4);
}

uint64_t sub_1B18C00E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1E0DE7D20](a1, sel_applyFunction_withContext_, a2, a3);
}

VFXOrderedDictionary *sub_1B18C00F4()
{
  return objc_alloc_init(VFXOrderedDictionary);
}

uint64_t sub_1B18C16BC(uint64_t result, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;

  if (result)
  {
    v4 = (void *)result;
    if ((objc_msgSend_isEqualToString_((void *)result, a2, *MEMORY[0x1E0CD2B68], a4) & 1) != 0)
    {
      return 0;
    }
    else if ((objc_msgSend_isEqualToString_(v4, v5, *MEMORY[0x1E0CD2B60], v6) & 1) != 0)
    {
      return 1;
    }
    else if (objc_msgSend_isEqualToString_(v4, v7, *MEMORY[0x1E0CD2B50], v8))
    {
      return 2;
    }
    else
    {
      return 3;
    }
  }
  return result;
}

uint64_t sub_1B18C1790(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  uint64_t result;
  uint64_t vars0;

  switch(a1)
  {
    case 0:
      v8 = (uint64_t *)MEMORY[0x1E0CD2B68];
      goto LABEL_7;
    case 1:
      v8 = (uint64_t *)MEMORY[0x1E0CD2B60];
      goto LABEL_7;
    case 2:
      v8 = (uint64_t *)MEMORY[0x1E0CD2B50];
      goto LABEL_7;
    case 3:
      v8 = (uint64_t *)MEMORY[0x1E0CD2B58];
LABEL_7:
      result = *v8;
      break;
    default:
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: unknown fill mode"), a3, a4, a5, a6, a7, a8, vars0);
      result = 0;
      break;
  }
  return result;
}

_QWORD *sub_1B18C18CC(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *result;
  const char *v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  _QWORD *v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t i;
  void *v22;
  double v23;
  double v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _BYTE v39[128];
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  result = (_QWORD *)objc_msgSend_count(a1, a2, a3, a4);
  if (result)
  {
    v8 = (void *)objc_msgSend_sortedArrayUsingComparator_(a1, v6, (uint64_t)&unk_1E63D0F90, v7);
    v12 = objc_msgSend_count(v8, v9, v10, v11);
    v13 = (_QWORD *)sub_1B19CE490(v12);
    v35 = 0u;
    v36 = 0u;
    v37 = 0u;
    v38 = 0u;
    v15 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v14, (uint64_t)&v35, (uint64_t)v39, 16);
    if (v15)
    {
      v19 = v15;
      v20 = *(_QWORD *)v36;
      do
      {
        for (i = 0; i != v19; ++i)
        {
          if (*(_QWORD *)v36 != v20)
            objc_enumerationMutation(v8);
          v22 = *(void **)(*((_QWORD *)&v35 + 1) + 8 * i);
          objc_msgSend_time(v22, v16, v17, v18);
          v24 = v23;
          v28 = (void *)objc_msgSend_eventBlock(v22, v25, v26, v27);
          sub_1B19CE50C(v13, v28, v29, v30, v31, v32, v33, v34, v24);
        }
        v19 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v16, (uint64_t)&v35, (uint64_t)v39, 16);
      }
      while (v19);
    }
    return v13;
  }
  return result;
}

void *sub_1B18C1A64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t i;
  float v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;

  if (!a1)
    return 0;
  v9 = sub_1B19CE864(a1, a2, a3, a4, a5, a6, a7, a8);
  v18 = (void *)objc_msgSend_arrayWithCapacity_(MEMORY[0x1E0C99DE8], v10, v9, v11);
  if (v9 >= 1)
  {
    for (i = 0; i != v9; ++i)
    {
      v20 = sub_1B19CE900(a1, i, v12, v13, v14, v15, v16, v17);
      v27 = sub_1B19CE8AC(a1, i, v21, v22, v23, v24, v25, v26);
      *(float *)&v28 = v20;
      v31 = objc_msgSend_animationEventWithKeyTime_block_(VFXAnimationEvent, v29, v27, v30, v28);
      objc_msgSend_addObject_(v18, v32, v31, v33);
    }
  }
  return v18;
}

uint64_t sub_1B18C1F14(void *a1)
{
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  void *v26;
  const char *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if (objc_msgSend_fromValue(a1, v2, v3, v4))
    {
      v8 = objc_msgSend_fromValue(a1, v5, v6, v7);
    }
    else if (objc_msgSend_toValue(a1, v5, v6, v7))
    {
      v8 = objc_msgSend_toValue(a1, v28, v29, v30);
    }
    else
    {
      v8 = objc_msgSend_byValue(a1, v28, v29, v30);
    }
    v26 = (void *)v8;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      goto LABEL_12;
    sub_1B17C4408(0, (uint64_t)CFSTR("Warning: unable to infer the type of a basic animation: %@"), v17, v18, v31, v32, v33, v34, (uint64_t)a1);
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v12 = (void *)objc_msgSend_values(a1, v9, v10, v11);
      if (objc_msgSend_count(v12, v13, v14, v15))
      {
        v23 = (void *)objc_msgSend_values(a1, v16, v17, v18);
        v26 = (void *)objc_msgSend_objectAtIndexedSubscript_(v23, v24, 0, v25);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
LABEL_12:
          v35 = (const char *)objc_msgSend_objCType(v26, v27, v17, v18);
          return sub_1B19B9BA8(v35);
        }
      }
      sub_1B17C4408(0, (uint64_t)CFSTR("Warning: unable to infer the type of a keyframed animation: %@"), v17, v18, v19, v20, v21, v22, (uint64_t)a1);
    }
  }
  return 0;
}

uint64_t sub_1B18C2048(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  const char *v5;
  uint64_t v6;

  result = objc_msgSend_animationTimingFunction(VFXTransaction, a2, a3, a4);
  if (!result)
    return objc_msgSend_functionWithName_(MEMORY[0x1E0CD27D0], v5, *MEMORY[0x1E0CD3038], v6);
  return result;
}

uint64_t sub_1B18C2084(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  uint64_t result;
  const char *v7;

  result = objc_msgSend_animationPlayerWithAnimationPlayerRef_(VFXAnimationPlayer, a2, (uint64_t)a2, a4);
  if (result)
    return objc_msgSend_setValue_forKey_(a3, v7, result, a1);
  return result;
}

_WORD *sub_1B18C20D0(void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  const char *v9;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const void *v31;
  _QWORD *v32;
  _WORD *v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v66;

  if ((_DWORD)a3 == 2)
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: animating between instances is not supported"), a3, a4, a5, a6, a7, a8, v66);
    return 0;
  }
  v8 = a3;
  v9 = a2;
  if (!(_DWORD)a2)
  {
    if (objc_msgSend_toValue(a1, a2, a3, a4))
    {
      v14 = (void *)objc_msgSend_toValue(a1, v11, v12, v13);
LABEL_10:
      v22 = (const char *)objc_msgSend_objCType(v14, v15, v16, v17);
      v9 = (const char *)sub_1B19B9BA8(v22);
      goto LABEL_11;
    }
    if (objc_msgSend_fromValue(a1, v11, v12, v13))
    {
      v14 = (void *)objc_msgSend_fromValue(a1, v18, v19, v20);
      goto LABEL_10;
    }
    if (objc_msgSend_byValue(a1, v18, v19, v20))
    {
      v14 = (void *)objc_msgSend_byValue(a1, v21, a3, a4);
      goto LABEL_10;
    }
    v9 = 0;
  }
LABEL_11:
  v23 = sub_1B191E290((int)v9, 1, a3, a4, a5, a6, a7, a8);
  if (!v23)
    return 0;
  v31 = (const void *)v23;
  v32 = (_QWORD *)sub_1B191E41C(v23, v24, v25, v26, v27, v28, v29, v30);
  v33 = (_WORD *)sub_1B185E424();
  sub_1B18C2268(v33, a1, v34, v35);
  if (objc_msgSend_toValue(a1, v36, v37, v38))
  {
    v42 = (void *)objc_msgSend_toValue(a1, v39, v40, v41);
    if (sub_1B18C22E0(v42, v9, v8, v32))
      sub_1B185E5C4((uint64_t)v33, (uint64_t)v31, v40, v41, v43, v44, v45, v46);
  }
  if (objc_msgSend_fromValue(a1, v39, v40, v41))
  {
    v50 = (void *)objc_msgSend_fromValue(a1, v47, v48, v49);
    if (sub_1B18C22E0(v50, v9, v8, v32))
      sub_1B185E69C((uint64_t)v33, (uint64_t)v31, v48, v49, v51, v52, v53, v54);
  }
  if (objc_msgSend_byValue(a1, v47, v48, v49))
  {
    v58 = (void *)objc_msgSend_byValue(a1, v55, v56, v57);
    if (sub_1B18C22E0(v58, v9, v8, v32))
      sub_1B185E774((uint64_t)v33, (uint64_t)v31, v59, v60, v61, v62, v63, v64);
  }
  CFRelease(v31);
  return v33;
}

void sub_1B18C2268(_WORD *a1, void *a2, uint64_t a3, uint64_t a4)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  const __CFString *v9;
  const __CFString *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  int isAdditive;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  int isCumulative;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  sub_1B18C82A4(a1, a2, a3, a4);
  v9 = (const __CFString *)objc_msgSend_keyPath(a2, v6, v7, v8);
  v10 = sub_1B17A02B4(v9);
  sub_1B185D040((uint64_t)a1, v10);
  if (v10)
    CFRelease(v10);
  isAdditive = objc_msgSend_isAdditive(a2, v11, v12, v13);
  sub_1B185D3F4((uint64_t)a1, isAdditive, v15, v16, v17, v18, v19, v20);
  isCumulative = objc_msgSend_isCumulative(a2, v21, v22, v23);
  sub_1B185D4A4((uint64_t)a1, isCumulative, v25, v26, v27, v28, v29, v30);
}

uint64_t sub_1B18C22E0(void *a1, const char *a2, int a3, _QWORD *a4)
{
  void *v5;
  uint64_t result;
  id v7;

  if ((_DWORD)a2 != 5)
    return sub_1B19B9DE4(a1, (uint64_t)a4, (uint64_t)a2, (uint64_t)a4);
  if (a3 != 2)
    return 0;
  v5 = (void *)objc_msgSend_copyCFXImageFromImage_(VFXMaterialProperty, a2, (uint64_t)a1, (uint64_t)a4);
  result = 0;
  if (a4)
  {
    if (v5)
    {
      *a4 = v5;
      v7 = v5;
      return 1;
    }
  }
  return result;
}

_WORD *sub_1B18C2364(void *a1, uint64_t a2, char a3)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  void *v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  unint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const __CFString *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  void *v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  const char *v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  void *v73;
  const char *v74;
  uint64_t v75;
  uint64_t v76;
  const char *v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  const char *v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  const char *v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  const char *v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  const char *v93;
  uint64_t v94;
  uint64_t v95;
  double v96;
  double v97;
  const char *v98;
  uint64_t v99;
  const char *v100;
  uint64_t v101;
  uint64_t v102;
  _BOOL4 v104;
  char isEqualToString;
  _BOOL4 v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unsigned int v113;
  const char *v114;
  uint64_t v115;
  const void *v116;
  unint64_t v117;
  double v118;
  void *v119;
  const char *v120;
  uint64_t v121;
  uint64_t v122;
  double v123;
  float v124;
  float v125;
  void *v126;
  const char *v127;
  uint64_t v128;
  uint64_t v129;
  float v130;
  void *v131;
  const char *v132;
  uint64_t v133;
  uint64_t v134;
  float v135;
  float v136;
  void *v137;
  const char *v138;
  uint64_t v139;
  uint64_t v140;
  float v141;
  float v142;
  void *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  unint64_t v149;
  double v150;
  void *v151;
  const char *v152;
  uint64_t v153;
  uint64_t v154;
  double v155;
  void *v156;
  uint64_t v157;
  const char *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  void *v163;
  const char *v164;
  void *v165;
  uint64_t *v166;
  const char *v167;
  uint64_t *v168;
  float v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  unsigned int v177;
  char v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  _BOOL4 v187;
  int v188;
  void *v189;
  char v190;
  unsigned int v191;
  _WORD *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  unint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  __int128 __src;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  uint64_t v205;

  v205 = *MEMORY[0x1E0C80C00];
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v13 = objc_msgSend_cfxAnimation(a1, v6, v7, v8);
    if (v13)
    {
      v14 = v13;
      sub_1B18C293C(v13, a1, v7, v8, v9, v10, v11, v12);
      return (_WORD *)v14;
    }
  }
  if (!(_DWORD)a2)
  {
    v15 = (void *)objc_msgSend_values(a1, v6, v7, v8);
    if (objc_msgSend_count(v15, v16, v17, v18))
    {
      v19 = (void *)objc_msgSend_values(a1, v6, v7, v8);
      v22 = (void *)objc_msgSend_objectAtIndexedSubscript_(v19, v20, 0, v21);
      v26 = (const char *)objc_msgSend_objCType(v22, v23, v24, v25);
      a2 = sub_1B19B9BA8(v26);
    }
    else
    {
      a2 = 0;
    }
  }
  v27 = sub_1B179E250(a2, (uint64_t)v6, v7, v8, v9, v10, v11, v12);
  if (v27 >= 0x41)
  {
    v185 = v27;
    v35 = CFSTR("Error: CAKeyframeAnimationToCFXAnimation :: too large value to animate : %d bytes");
LABEL_10:
    sub_1B17C4408(16, (uint64_t)v35, v29, v30, v31, v32, v33, v34, v185);
    return 0;
  }
  if (objc_msgSend_path(a1, v28, v29, v30))
  {
    NSLog(CFSTR("CAKeyframeAnimation based on CGPath are not supported"));
    return 0;
  }
  v40 = (void *)objc_msgSend_values(a1, v36, v37, v38);
  v44 = objc_msgSend_count(v40, v41, v42, v43);
  if (!v44)
  {
    v35 = CFSTR("Error: CAKeyframeAnimation has no keyframe - skipping conversion");
    goto LABEL_10;
  }
  v191 = v44;
  v192 = (_WORD *)sub_1B18071BC();
  sub_1B18C2268(v192, a1, v45, v46);
  v50 = (void *)objc_msgSend_keyTimes(a1, v47, v48, v49);
  v54 = (void *)objc_msgSend_values(a1, v51, v52, v53);
  v58 = (void *)objc_msgSend_timingFunctions(a1, v55, v56, v57);
  v189 = (void *)objc_msgSend_calculationMode(a1, v59, v60, v61);
  v65 = (void *)objc_msgSend_tensionValues(a1, v62, v63, v64);
  v69 = (void *)objc_msgSend_continuityValues(a1, v66, v67, v68);
  v73 = (void *)objc_msgSend_biasValues(a1, v70, v71, v72);
  v196 = v58;
  v197 = objc_msgSend_count(v50, v74, v75, v76);
  v80 = objc_msgSend_count(v58, v77, v78, v79);
  v195 = v65;
  v84 = objc_msgSend_count(v65, v81, v82, v83);
  v194 = v69;
  v88 = objc_msgSend_count(v69, v85, v86, v87);
  v193 = v73;
  v92 = objc_msgSend_count(v73, v89, v90, v91);
  objc_msgSend_duration(a1, v93, v94, v95);
  v97 = v96;
  v186 = *MEMORY[0x1E0CD2920];
  if (objc_msgSend_isEqualToString_(v189, v98, *MEMORY[0x1E0CD2920], v99))
  {
    v190 = a3;
    v104 = (_DWORD)a2 == 1 || (_DWORD)a2 == 6;
LABEL_32:
    v187 = v104;
    if (objc_msgSend_count(v196, v100, v101, v102))
      v111 = !v104;
    else
      v111 = 1;
    v188 = v111;
    if (objc_msgSend_count(v196, v108, v109, v110))
      v112 = v187;
    else
      v112 = 0;
    v113 = v191;
    v116 = (const void *)sub_1B17F4EEC(v191, a2, v190, v111, v112);
    v203 = 0u;
    v204 = 0u;
    __src = 0u;
    v202 = 0u;
    if (v188)
    {
      v117 = 0;
      v118 = 0.0;
      while (v50)
      {
        if (v197 > v117)
        {
          v119 = (void *)objc_msgSend_objectAtIndex_(v50, v114, v117, v115);
          objc_msgSend_doubleValue(v119, v120, v121, v122);
LABEL_44:
          v118 = v97 * v123;
        }
        v124 = 0.0;
        v125 = 0.0;
        if (v84 > v117)
        {
          v126 = (void *)objc_msgSend_objectAtIndex_(v195, v114, v117, v115);
          objc_msgSend_floatValue(v126, v127, v128, v129);
          v125 = v130;
        }
        if (v88 > v117)
        {
          v131 = (void *)objc_msgSend_objectAtIndex_(v194, v114, v117, v115);
          objc_msgSend_floatValue(v131, v132, v133, v134);
          v124 = v135;
        }
        v136 = 0.0;
        if (v92 > v117)
        {
          v137 = (void *)objc_msgSend_objectAtIndex_(v193, v114, v117, v115);
          objc_msgSend_floatValue(v137, v138, v139, v140);
          v136 = v141;
        }
        v143 = (void *)objc_msgSend_objectAtIndex_(v54, v114, v117, v115);
        sub_1B19B9DE4(v143, (uint64_t)&__src, a2, v144);
        v142 = v118;
        v118 = v142;
        sub_1B17F5020((uint64_t)v116, v117++, &__src, 0, 0, v145, v146, v147, v118, v125, v124, v136);
        if (v191 == v117)
          goto LABEL_68;
      }
      v123 = (float)((float)v117 / (float)v191);
      goto LABEL_44;
    }
    goto LABEL_54;
  }
  isEqualToString = objc_msgSend_isEqualToString_(v189, v100, *MEMORY[0x1E0CD2928], v102);
  v107 = (_DWORD)a2 == 1 || (_DWORD)a2 == 6;
  if ((isEqualToString & 1) != 0)
  {
    v190 = a3;
    v104 = v107;
    goto LABEL_32;
  }
  v113 = v191;
  v116 = (const void *)sub_1B17F4EEC(v191, a2, a3, 0, 0);
  v203 = 0u;
  v204 = 0u;
  __src = 0u;
  v202 = 0u;
LABEL_54:
  v149 = 0;
  v199 = 0;
  v200 = 0;
  v198 = 0;
  v150 = 0.0;
  do
  {
    if (!v50)
    {
      v155 = (float)((float)v149 / (float)v113);
      goto LABEL_59;
    }
    if (v197 > v149)
    {
      v151 = (void *)objc_msgSend_objectAtIndex_(v50, v114, v149, v115);
      objc_msgSend_doubleValue(v151, v152, v153, v154);
LABEL_59:
      v150 = v97 * v155;
    }
    v156 = (void *)objc_msgSend_objectAtIndex_(v54, v114, v149, v115);
    sub_1B19B9DE4(v156, (uint64_t)&__src, a2, v157);
    if ((_DWORD)a2 == 6 || (unsigned __int16)a2 == 1)
    {
      if (v80 > v149 && (v163 = (void *)objc_msgSend_objectAtIndex_(v196, v158, v149, v159)) != 0)
      {
        v165 = v163;
        v166 = &v199;
        objc_msgSend_getControlPointAtIndex_values_(v163, v164, 1, (uint64_t)&v199);
        objc_msgSend_getControlPointAtIndex_values_(v165, v167, 2, (uint64_t)&v198);
        v168 = &v200;
      }
      else
      {
        v199 = 0;
        v168 = &v200;
        v166 = &v199;
      }
    }
    else
    {
      v166 = 0;
      v168 = 0;
    }
    v169 = v150;
    v150 = v169;
    sub_1B17F5020((uint64_t)v116, v149, &__src, v168, v166, v160, v161, v162, v169, 0.0, 0.0, 0.0);
    v200 = v198;
    ++v149;
  }
  while (v113 != v149);
LABEL_68:
  v170 = objc_msgSend_calculationMode(a1, v114, v148, v115);
  if (v170 == *MEMORY[0x1E0CD2930])
  {
    v178 = 0;
    v177 = 1;
LABEL_77:
    sub_1B17F57E0((uint64_t)v116, v178, v171, v172, v173, v174, v175, v176);
    sub_1B17F5874((uint64_t)v116, v177, v179, v180, v181, v182, v183, v184);
    goto LABEL_78;
  }
  if (v170 == *MEMORY[0x1E0CD2948])
  {
    v177 = 0;
LABEL_75:
    v178 = 1;
    goto LABEL_77;
  }
  if (v170 == v186)
  {
    v178 = 0;
    v177 = 2;
    goto LABEL_77;
  }
  if (v170 == *MEMORY[0x1E0CD2928])
  {
    v177 = 2;
    goto LABEL_75;
  }
LABEL_78:
  sub_1B1807218((uint64_t)v192, (uint64_t)v116, v171, v172, v173, v174, v175, v176);
  CFRelease(v116);
  return v192;
}

uint64_t sub_1B18C293C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;

  v9 = (_QWORD *)sub_1B185DAD4(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  objc_msgSend_delegate(a2, v10, v11, v12);
  result = objc_opt_respondsToSelector();
  if ((result & 1) != 0)
    *v9 = sub_1B18C5FB4;
  v9[1] = sub_1B18C6168;
  return result;
}

_WORD *sub_1B18C2990(void *a1, void *a2)
{
  _WORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  id v13;

  v2 = sub_1B18C29E8(a1, a2);
  if (v2)
  {
    v3 = sub_1B18FF324();
    if (v3 == CFGetTypeID(v2))
    {
      v11 = (void *)sub_1B190B390((uint64_t)v2, v4, v5, v6, v7, v8, v9, v10);
      if (v11)
      {
        v12 = v11;
        v13 = v11;
        return v12;
      }
    }
  }
  return v2;
}

_WORD *sub_1B18C29E8(void *a1, void *a2)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  const __CFArray *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  objc_class *v40;
  NSString *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _WORD *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _WORD *v54;
  objc_class *v55;
  NSString *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return sub_1B18C8624(a1, (uint64_t)a2);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v8 = objc_msgSend_keyPath(a1, v5, v6, v7);
    v13 = (const __CFArray *)objc_msgSend_copyAnimationChannelForKeyPath_animation_(a2, v9, v8, (uint64_t)a1);
    if (v13
      && (v14 = (_QWORD *)objc_msgSend___CFObject(a2, v10, v11, v12), (v15 = sub_1B19C18E0(v14, v13, 1)) != 0)
      && (v23 = (const void *)v15, sub_1B19C4614(v15, v16, v17, v18, v19, v20, v21, v22)))
    {
      v31 = (const char *)sub_1B19C4770((uint64_t)v23, v24, v25, v26, v27, v28, v29, v30);
      v39 = sub_1B19C46E0((uint64_t)v23, v32, v33, v34, v35, v36, v37, v38);
      CFRelease(v23);
    }
    else
    {
      v31 = 0;
      v39 = 0;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v54 = sub_1B18C20D0(a1, v31, v39, v49, v50, v51, v52, v53);
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        v55 = (objc_class *)objc_opt_class();
        v56 = NSStringFromClass(v55);
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: Unsupported CAPropertyAnimation subclass (%@)"), v57, v58, v59, v60, v61, v62, (uint64_t)v56);
        v48 = 0;
LABEL_18:

        return v48;
      }
      v54 = sub_1B18C2364(a1, (uint64_t)v31, v39);
    }
    v48 = v54;
    if (v13)
    {
      if (v54)
        sub_1B185D040((uint64_t)v54, v13);
    }
    goto LABEL_18;
  }
  v40 = (objc_class *)objc_opt_class();
  v41 = NSStringFromClass(v40);
  sub_1B17C4408(16, (uint64_t)CFSTR("Error: Unsupported CAAnimation class (%@)"), v42, v43, v44, v45, v46, v47, (uint64_t)v41);
  return 0;
}

void *sub_1B18C2BB4(const void *a1)
{
  CFTypeID v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  VFXKeyframeAnimation *v17;
  const char *v18;
  uint64_t v19;
  VFXKeyframeAnimation *v20;
  void *v21;
  CFTypeID v22;
  CFTypeID v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const void *v42;
  double *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  double v54;
  uint64_t v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  CFTypeID v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const void *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  const void *v79;
  double *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  const char *v88;
  uint64_t v89;
  uint64_t v90;
  double v91;
  uint64_t v92;
  const char *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  const void *v108;
  double *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  const char *v117;
  uint64_t v118;
  uint64_t v119;
  double v120;
  uint64_t v121;
  const char *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  float v129;
  const char *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v134;

  if (a1)
  {
    v2 = CFGetTypeID(a1);
    if (v2 == sub_1B180713C())
    {
      if (sub_1B18072BC((uint64_t)a1, v3, v4, v5, v6, v7, v8, v9))
      {
        v17 = objc_alloc_init(VFXKeyframeAnimation);
        objc_msgSend_setCfxAnimation_(v17, v18, (uint64_t)a1, v19);
        v20 = v17;
LABEL_8:
        v21 = v20;
LABEL_31:
        v129 = sub_1B185D118((uint64_t)a1, v10, v11, v12, v13, v14, v15, v16);
        objc_msgSend_setDuration_(v21, v130, v131, v132, v129);
        return v21;
      }
    }
    else
    {
      v22 = CFGetTypeID(a1);
      if (v22 == sub_1B18FF324())
      {
        v20 = (VFXKeyframeAnimation *)sub_1B18C87D4((uint64_t)a1);
        goto LABEL_8;
      }
      v23 = CFGetTypeID(a1);
      if (v23 == sub_1B185DA94())
      {
        v21 = (void *)objc_msgSend_animation(MEMORY[0x1E0CD2710], v24, v25, v26);
        v34 = sub_1B185E704((uint64_t)a1, v27, v28, v29, v30, v31, v32, v33);
        if (v34)
        {
          v42 = (const void *)v34;
          v43 = (double *)sub_1B191E41C(v34, v35, v36, v37, v38, v39, v40, v41);
          v51 = (const char *)sub_1B191E464((uint64_t)v42, v44, v45, v46, v47, v48, v49, v50);
          v55 = sub_1B19BA16C(v43, v51, v54, v52, v53);
          if (v55)
            objc_msgSend_setFromValue_(v21, v56, v55, v58);
          else
            sub_1B17C4408(0, (uint64_t)CFSTR("Warning: VFXSimpleAnimationToCABasicAnimation - can't convert startValue"), v57, v58, v59, v60, v61, v62, v134);
          CFRelease(v42);
        }
        v71 = sub_1B185E62C((uint64_t)a1, v35, v36, v37, v38, v39, v40, v41);
        if (v71)
        {
          v79 = (const void *)v71;
          v80 = (double *)sub_1B191E41C(v71, v72, v73, v74, v75, v76, v77, v78);
          v88 = (const char *)sub_1B191E464((uint64_t)v79, v81, v82, v83, v84, v85, v86, v87);
          v92 = sub_1B19BA16C(v80, v88, v91, v89, v90);
          if (v92)
            objc_msgSend_setToValue_(v21, v93, v92, v95);
          else
            sub_1B17C4408(0, (uint64_t)CFSTR("Warning: VFXSimpleAnimationToCABasicAnimation - can't convert endValue"), v94, v95, v96, v97, v98, v99, v134);
          CFRelease(v79);
        }
        v100 = sub_1B185E7DC((uint64_t)a1, v72, v73, v74, v75, v76, v77, v78);
        if (v100)
        {
          v108 = (const void *)v100;
          v109 = (double *)sub_1B191E41C(v100, v101, v102, v103, v104, v105, v106, v107);
          v117 = (const char *)sub_1B191E464((uint64_t)v108, v110, v111, v112, v113, v114, v115, v116);
          v121 = sub_1B19BA16C(v109, v117, v120, v118, v119);
          if (v121)
            objc_msgSend_setByValue_(v21, v122, v121, v124);
          else
            sub_1B17C4408(0, (uint64_t)CFSTR("Warning: VFXSimpleAnimationToCABasicAnimation - can't convert byValue"), v123, v124, v125, v126, v127, v128, v134);
          CFRelease(v108);
        }
        sub_1B18C84B0(v21, (uint64_t)a1, v102, v103, v104, v105, v106, v107);
        goto LABEL_31;
      }
      v63 = CFGetTypeID(a1);
      if (v63 == sub_1B190B104())
      {
        v70 = (const void *)sub_1B190B2DC((uint64_t)a1);
        v21 = sub_1B18C87D4((uint64_t)v70);
        if (v70)
          CFRelease(v70);
        goto LABEL_31;
      }
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXAnimationToCAAnimation: unsupported animation"), v64, v65, v66, v67, v68, v69, v134);
    }
    v21 = 0;
    goto LABEL_31;
  }
  return 0;
}

__CFString *sub_1B18C2DEC(void *a1, __CFString *a2, uint64_t a3, uint64_t a4)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  __CFString *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  __CFString *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  __int16 *v25;
  const void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;

  if (!objc_msgSend_length(a2, (const char *)a2, a3, a4))
    return 0;
  v9 = (_QWORD *)objc_msgSend___CFObject(a1, v6, v7, v8);
  v10 = (__CFString *)sub_1B17A02B4(a2);
  v11 = sub_1B19C18E0(v9, (const __CFArray *)v10, 0);
  v19 = (const void *)v11;
  if (v11 && sub_1B19C4614(v11, v12, v13, v14, v15, v16, v17, v18))
  {
    v20 = v10;
LABEL_12:
    CFRelease(v19);
    return v20;
  }
  v21 = sub_1B19BA44C(a1, a2);
  if (v21
    && (v25 = (__int16 *)v21,
        v26 = (const void *)objc_msgSend___CFObject(a1, v22, v23, v24),
        sub_1B193EBA0(v26))
    && (sub_1B193FB20((uint64_t)v26, a2, v25, v27, v28, v29, v30, v31),
        CFRelease(v25),
        sub_1B193FCB0((uint64_t)v26, a2, v32, v33, v34, v35, v36, v37)))
  {
    v41 = (void *)MEMORY[0x1E0C99DE8];
    v42 = objc_msgSend_count(v10, v38, v39, v40);
    v20 = (__CFString *)(id)objc_msgSend_arrayWithCapacity_(v41, v43, v42 + 1, v44);
    objc_msgSend_addObject_(v20, v45, (uint64_t)CFSTR("customProperty"), v46);
    objc_msgSend_addObjectsFromArray_(v20, v47, (uint64_t)v10, v48);
  }
  else
  {
    v20 = 0;
  }
  CFRelease(v10);
  if (v19)
    goto LABEL_12;
  return v20;
}

uint64_t sub_1B18C2F24(void *a1, char *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if (a3)
  {
    if (a1)
      goto LABEL_3;
LABEL_10:
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: can't add a NULL animation to %@"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)a2);
    return 0;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), 0, a4, a5, a6, a7, a8, (uint64_t)"key");
  if (!a1)
    goto LABEL_10;
LABEL_3:
  result = objc_msgSend_animationPlayerRef(a1, a2, (uint64_t)a3, a4);
  if (result)
  {
    v15 = (uint64_t *)result;
    v16 = (_QWORD *)objc_msgSend___CFObject(a2, v12, v13, v14);
    if (v16)
    {
      v17 = v16;
      if ((sub_1B193EBA0(v16) & 1) == 0)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. VFXAddAnimationGroup target is not an entity"), v18, v19, v20, v21, v22, v23, (uint64_t)"CFTypeIsCFXEntity(rootCF)");
      sub_1B193F03C(v17, v15, a3, v19, v20, v21, v22, v23);
    }
    return 1;
  }
  return result;
}

void sub_1B18C2FF4(void *a1, char *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = (_QWORD *)objc_msgSend___CFObject(a1, a2, a3, a4);
  if (v5)
  {
    v6 = v5;
    if ((sub_1B193EBA0(v5) & 1) == 0)
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. VFXRemoveAnimation target is not an entity"), v7, v8, v9, v10, v11, v12, (uint64_t)"CFTypeIsCFXEntity(rootCF)");
    sub_1B193F164(v6, a2, 0, v8, v9, v10, v11, v12);
  }
}

void sub_1B18C3064(void *a1, char *a2, uint64_t a3, uint64_t a4, double a5)
{
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v7 = (_QWORD *)objc_msgSend___CFObject(a1, a2, a3, a4);
  if (v7)
  {
    v8 = v7;
    if ((sub_1B193EBA0(v7) & 1) == 0)
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. VFXFadeAndRemoveAnimation target is not an entity"), v9, v10, v11, v12, v13, v14, (uint64_t)"CFTypeIsCFXEntity(rootCF)");
    sub_1B193F388(v8, a2, v9, v10, v11, v12, v13, v14, a5);
  }
}

void sub_1B18C30E4(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = (void *)objc_msgSend___CFObject(a1, a2, a3, a4);
  if (v4)
  {
    v5 = v4;
    if ((sub_1B193EBA0(v4) & 1) == 0)
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. VFXRemoveAllAnimations target is not an entity"), v7, v8, v9, v10, v11, v12, (uint64_t)"CFTypeIsCFXEntity(rootCF)");
    sub_1B193E3E4(v5, v6, v7, v8, v9, v10, v11, v12);
  }
}

void sub_1B18C3148(void *a1, const char *a2, uint64_t a3, uint64_t a4, double a5)
{
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = (void *)objc_msgSend___CFObject(a1, a2, a3, a4);
  if (v6)
  {
    v7 = v6;
    if ((sub_1B193EBA0(v6) & 1) == 0)
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. VFXFadeAndRemoveAllAnimations target is not an entity"), v9, v10, v11, v12, v13, v14, (uint64_t)"CFTypeIsCFXEntity(rootCF)");
    sub_1B193F2B0(v7, v8, v9, v10, v11, v12, v13, v14, a5);
  }
}

uint64_t sub_1B18C31C0(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = (void *)objc_msgSend_valueForKey_(a1, a2, (uint64_t)CFSTR("VFXAnimationFadeInDurationKey"), a4);
  return objc_msgSend_floatValue(v4, v5, v6, v7);
}

uint64_t sub_1B18C31DC(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  const char *v6;

  v5 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], a2, a3, a4);
  return objc_msgSend_setValue_forKey_(a1, v6, v5, (uint64_t)CFSTR("VFXAnimationFadeInDurationKey"));
}

uint64_t sub_1B18C3214(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = (void *)objc_msgSend_valueForKey_(a1, a2, (uint64_t)CFSTR("VFXAnimationFadeOutDurationKey"), a4);
  return objc_msgSend_floatValue(v4, v5, v6, v7);
}

uint64_t sub_1B18C3230(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  const char *v6;

  v5 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], a2, a3, a4);
  return objc_msgSend_setValue_forKey_(a1, v6, v5, (uint64_t)CFSTR("VFXAnimationFadeOutDurationKey"));
}

uint64_t sub_1B18C3268(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = (void *)objc_msgSend_valueForKey_(a1, a2, (uint64_t)CFSTR("VFXAnimationCommitOnCompletion"), a4);
  return objc_msgSend_BOOLValue(v4, v5, v6, v7);
}

uint64_t sub_1B18C3284(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  const char *v6;

  v5 = objc_msgSend_numberWithBool_(MEMORY[0x1E0CB37E8], a2, a3, a4);
  return objc_msgSend_setValue_forKey_(a1, v6, v5, (uint64_t)CFSTR("VFXAnimationCommitOnCompletion"));
}

void sub_1B18C32BC(void *a1, const char *a2, void *a3, uint64_t a4)
{
  const char *v5;
  id v6;

  v6 = (id)objc_msgSend_copy(a3, a2, (uint64_t)a3, a4);
  objc_msgSend_setValue_forKey_(a1, v5, (uint64_t)v6, (uint64_t)CFSTR("VFXAnimationEventsKey"));

}

uint64_t sub_1B18C3304(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_valueForKey_(a1, a2, (uint64_t)CFSTR("VFXAnimationEventsKey"), a4);
}

uint64_t sub_1B18C3310(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  return objc_msgSend_caAnimation(a3, a2, (uint64_t)a3, a4);
}

void *sub_1B18C3318(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t isRemovedOnCompletion;
  const char *v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t isAdditive;
  const char *v46;
  uint64_t v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t isCumulative;
  const char *v52;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const char *v64;
  uint64_t v65;
  const char *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const char *v70;
  uint64_t v71;
  id v72;
  const char *v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  const char *v77;
  uint64_t v78;
  const char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  const char *v86;
  uint64_t v87;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  _BYTE v93[128];
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v5 = (void *)objc_msgSend_copy(a1, a2, a3, a4);
  v9 = objc_msgSend_fillMode(a1, v6, v7, v8);
  objc_msgSend_setFillMode_(v5, v10, v9, v11);
  objc_msgSend_speed(a1, v12, v13, v14);
  objc_msgSend_setSpeed_(v5, v15, v16, v17);
  v21 = objc_msgSend_autoreverses(a1, v18, v19, v20);
  objc_msgSend_setAutoreverses_(v5, v22, v21, v23);
  objc_msgSend_repeatCount(a1, v24, v25, v26);
  objc_msgSend_setRepeatCount_(v5, v27, v28, v29);
  isRemovedOnCompletion = objc_msgSend_isRemovedOnCompletion(a1, v30, v31, v32);
  objc_msgSend_setRemovedOnCompletion_(v5, v34, isRemovedOnCompletion, v35);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v39 = objc_msgSend_keyPath(a1, v36, v37, v38);
      objc_msgSend_setKeyPath_(v5, v40, v39, v41);
      isAdditive = objc_msgSend_isAdditive(a1, v42, v43, v44);
      objc_msgSend_setAdditive_(v5, v46, isAdditive, v47);
      isCumulative = objc_msgSend_isCumulative(a1, v48, v49, v50);
      objc_msgSend_setCumulative_(v5, v52, isCumulative, v53);
    }
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v57 = objc_msgSend_calculationMode(a1, v54, v55, v56);
      objc_msgSend_setCalculationMode_(v5, v58, v57, v59);
      v63 = objc_msgSend_values(a1, v60, v61, v62);
      objc_msgSend_setValues_(v5, v64, v63, v65);
      v69 = objc_msgSend_keyTimes(a1, v66, v67, v68);
      objc_msgSend_setKeyTimes_(v5, v70, v69, v71);
    }
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v72 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v89 = 0u;
    v90 = 0u;
    v91 = 0u;
    v92 = 0u;
    v76 = (void *)objc_msgSend_animations(v5, v73, v74, v75, 0);
    v78 = objc_msgSend_countByEnumeratingWithState_objects_count_(v76, v77, (uint64_t)&v89, (uint64_t)v93, 16);
    if (v78)
    {
      v82 = v78;
      v83 = *(_QWORD *)v90;
      do
      {
        v84 = 0;
        do
        {
          if (*(_QWORD *)v90 != v83)
            objc_enumerationMutation(v76);
          v85 = objc_msgSend_deepCopy(*(void **)(*((_QWORD *)&v89 + 1) + 8 * v84), v79, v80, v81);
          objc_msgSend_addObject_(v72, v86, v85, v87);
          ++v84;
        }
        while (v82 != v84);
        v82 = objc_msgSend_countByEnumeratingWithState_objects_count_(v76, v79, (uint64_t)&v89, (uint64_t)v93, 16);
      }
      while (v82);
    }
    objc_msgSend_setAnimations_(v5, v79, (uint64_t)v72, v81);
  }
  return v5;
}

uint64_t sub_1B18C3594(void *a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && (v12 = objc_msgSend_cfxAnimation(a1, v9, v10, v11)) != 0)
    return sub_1B1807304(v12, a4, a5, v13, v14, v15, v16, v17, a2);
  else
    return 0;
}

void sub_1B18C5038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18C5054(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v6;
  const char *v7;
  uint64_t result;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  double v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  double v26;
  void *v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _BYTE v35[128];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v6 = (void *)objc_msgSend_animationKeys(a2, (const char *)a2, a3, a4, 0);
  result = objc_msgSend_countByEnumeratingWithState_objects_count_(v6, v7, (uint64_t)&v31, (uint64_t)v35, 16);
  if (result)
  {
    v11 = result;
    v12 = *(_QWORD *)v32;
    do
    {
      v13 = 0;
      do
      {
        if (*(_QWORD *)v32 != v12)
          objc_enumerationMutation(v6);
        v14 = (void *)objc_msgSend_animationPlayerForKey_(a2, v9, *(_QWORD *)(*((_QWORD *)&v31 + 1) + 8 * v13), v10);
        v15 = *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
        v19 = (void *)objc_msgSend_animation(v14, v16, v17, v18);
        objc_msgSend_duration(v19, v20, v21, v22);
        if (v15 >= v26)
          v26 = v15;
        *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v26;
        v27 = *(void **)(a1 + 32);
        v28 = objc_msgSend_animation(v14, v23, v24, v25);
        objc_msgSend_addObject_(v27, v29, v28, v30);
        ++v13;
      }
      while (v11 != v13);
      result = objc_msgSend_countByEnumeratingWithState_objects_count_(v6, v9, (uint64_t)&v31, (uint64_t)v35, 16);
      v11 = result;
    }
    while (result);
  }
  return result;
}

void sub_1B18C55D4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B18C56B0(uint64_t a1)
{
  const __CFString *v2;

  v2 = sub_1B17A02B4(*(const __CFString **)(a1 + 32));
  sub_1B185D040(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), v2);
  if (v2)
    CFRelease(v2);
}

float sub_1B18C57B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v8;
  float result;

  v8 = *(double *)(a1 + 40);
  sub_1B185D0C4(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), v8, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

void sub_1B18C5868(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B185D1F4(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(float *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B18C59A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B185D69C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(double *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B18C5A5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B18089F4(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(double *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B18C5B08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B185D290(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned __int8 *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_1B18C5BB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v9 = sub_1B185DC8C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8) & 0xFE | *(_BYTE *)(a1 + 40);
  sub_1B185DCD8(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), v9, v10, v11, v12, v13, v14, v15);
}

void sub_1B18C5C88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v9 = sub_1B185DC8C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8) & 0xFD | (2
                                                                                                  * *(_BYTE *)(a1 + 40));
  sub_1B185DCD8(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), v9, v10, v11, v12, v13, v14, v15);
}

CFTypeRef sub_1B18C5D64(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (const void *)objc_msgSend_cfxTimingFunction(*(void **)(a1 + 32), a2, a3, a4);
  return sub_1B185D334(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B18C5E2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B185D5A0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned __int8 *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B18C5ED8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B185D90C(*(_WORD **)(*(_QWORD *)(a1 + 32) + 8), *(unsigned __int8 *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

_QWORD *sub_1B18C5F8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *result;

  result = (_QWORD *)sub_1B185DAD4(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8);
  *result = sub_1B18C5FB4;
  return result;
}

uint64_t sub_1B18C5FB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id *v9;
  id *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  id *v31;
  id *v32;
  _QWORD v33[6];

  v9 = (id *)sub_1B1807A58(a1, a2, a3, a4, a5, a6, a7, a8);
  v10 = sub_1B193E758(v9);
  v14 = (void *)objc_msgSend_userAnimation(v10, v11, v12, v13);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
    v14 = 0;
  v18 = objc_msgSend_delegate(v14, v15, v16, v17);
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v33[0] = MEMORY[0x1E0C809B0];
    v33[1] = 3221225472;
    v33[2] = sub_1B18C890C;
    v33[3] = &unk_1E63D8108;
    v33[4] = v18;
    v33[5] = v14;
    dispatch_async(MEMORY[0x1E0C80D38], v33);
  }
  result = objc_msgSend_animationDidStart(v10, v19, v20, v21);
  if (result)
  {
    v30 = result;
    v31 = (id *)sub_1B1807AA0(a1, v23, v24, v25, v26, v27, v28, v29);
    v32 = sub_1B193E758(v31);
    return (*(uint64_t (**)(uint64_t, id *, id *))(v30 + 16))(v30, v10, v32);
  }
  return result;
}

uint64_t sub_1B18C6140(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  result = sub_1B185DAD4(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)(result + 8) = sub_1B18C6168;
  return result;
}

uint64_t sub_1B18C6168(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  id *v11;
  id *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  id *v32;
  id *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  __CFArray *v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  const __CFArray *v71;
  id *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  id *v78;
  id *v79;
  const char *v80;
  uint64_t v81;
  uint64_t v82;
  const __CFArray *v83;
  const char *v84;
  uint64_t v85;
  uint64_t v86;
  void *v87;
  const char *v88;
  uint64_t v89;
  uint64_t v90;
  const char *v91;
  const char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const char *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  id *v108;
  id *v109;
  uint64_t v111;
  unsigned int v112;
  _QWORD block[6];
  char v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  _BYTE v119[128];
  uint64_t v120;

  v8 = a4;
  v9 = a2;
  v10 = a1;
  v120 = *MEMORY[0x1E0C80C00];
  v11 = (id *)sub_1B1807A58(a1, a2, a3, a4, a5, a6, a7, a8);
  v12 = sub_1B193E758(v11);
  v16 = (id)objc_msgSend_userAnimation(v12, v13, v14, v15);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v24 = objc_msgSend_delegate(v16, v17, v18, v19);
  else
    v24 = 0;
  if (!sub_1B185D554((uint64_t)v11, (uint64_t)v17, v18, v19, v20, v21, v22, v23))
    goto LABEL_26;
  v32 = (id *)sub_1B1807AA0(v10, v25, v26, v27, v28, v29, v30, v31);
  v33 = sub_1B193E758(v32);
  if (sub_1B185D9C8((uint64_t)v11, v34, v35, v36, v37, v38, v39, v40))
  {
    v42 = sub_1B190B104();
    if (v42 == CFGetTypeID(v11))
    {
      v111 = v8;
      v112 = v9;
      v43 = sub_1B190BD28((uint64_t)v11);
      objc_msgSend_begin(VFXTransaction, v44, v45, v46);
      objc_msgSend_setAnimationDuration_(VFXTransaction, v47, v48, v49, 0.0);
      v117 = 0u;
      v118 = 0u;
      v115 = 0u;
      v116 = 0u;
      v51 = objc_msgSend_countByEnumeratingWithState_objects_count_(v43, v50, (uint64_t)&v115, (uint64_t)v119, 16);
      if (v51)
      {
        v55 = v51;
        v56 = *(_QWORD *)v116;
        do
        {
          v57 = 0;
          do
          {
            if (*(_QWORD *)v116 != v56)
              objc_enumerationMutation(v43);
            v58 = *(_QWORD *)(*((_QWORD *)&v115 + 1) + 8 * v57);
            v59 = (void *)objc_msgSend_presentationObject(v33, v52, v53, v54);
            v62 = objc_msgSend_valueForKeyPath_(v59, v60, v58, v61);
            objc_msgSend_setValue_forKeyPath_(v33, v63, v62, v58);
            ++v57;
          }
          while (v55 != v57);
          v55 = objc_msgSend_countByEnumeratingWithState_objects_count_(v43, v52, (uint64_t)&v115, (uint64_t)v119, 16);
        }
        while (v55);
      }
      objc_msgSend_commit(VFXTransaction, v52, v53, v54);

      v9 = v112;
      v8 = v111;
    }
    else
    {
      v64 = sub_1B185D090((uint64_t)v11);
      if (v64)
      {
        v71 = (const __CFArray *)v64;
        if (v33)
        {
          v72 = v33;
        }
        else
        {
          if (v10)
          {
            while (1)
            {
              v73 = sub_1B1807DFC(v10, (uint64_t)v41, v65, v66, v67, v68, v69, v70);
              v10 = v73;
              if (!v73)
                break;
              v78 = (id *)sub_1B1807AA0(v73, (uint64_t)v41, v65, v66, v74, v75, v76, v77);
              v79 = sub_1B193E758(v78);
              if (v79)
              {
                v72 = v79;
                goto LABEL_23;
              }
            }
          }
          v72 = 0;
        }
LABEL_23:
        objc_msgSend_begin(VFXTransaction, v41, v65, v66);
        objc_msgSend_setAnimationDuration_(VFXTransaction, v80, v81, v82, 0.0);
        v83 = sub_1B17A02D0(v71);
        v87 = (void *)objc_msgSend_presentationObject(v72, v84, v85, v86);
        v90 = objc_msgSend_valueForKeyPath_(v87, v88, (uint64_t)v83, v89);
        objc_msgSend_setValue_forKeyPath_(v72, v91, v90, (uint64_t)v83);

        objc_msgSend_commit(VFXTransaction, v92, v93, v94);
      }
    }
  }
  if ((_DWORD)v9)
    v95 = objc_msgSend___removeAnimation_forKey_(v33, v41, (uint64_t)v12, v8);
  else
LABEL_26:
    v95 = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_1B18C8918;
    block[3] = &unk_1E63D87A0;
    block[4] = v24;
    block[5] = v16;
    v114 = v9;
    dispatch_async(MEMORY[0x1E0C80D38], block);
  }
  v99 = objc_msgSend_animationDidStop(v12, v96, v97, v98);
  if (v99)
  {
    v107 = v99;
    v108 = (id *)sub_1B1807AA0(v10, v100, v101, v102, v103, v104, v105, v106);
    v109 = sub_1B193E758(v108);
    (*(void (**)(uint64_t, id *, id *, uint64_t))(v107 + 16))(v107, v12, v109, v9);
  }

  return v95;
}

CFTypeRef sub_1B18C6548(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = sub_1B18C18CC(*(void **)(a1 + 40), a2, a3, a4);
  return sub_1B185DB64(v4, v5, v6, v7, v8, v9, v10, v11);
}

float sub_1B18C6628(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v8;
  float result;

  v8 = *(double *)(a1 + 40);
  sub_1B185D7D4(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), v8, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

float sub_1B18C66F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v8;
  float result;

  v8 = *(double *)(a1 + 40);
  sub_1B185D870(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), v8, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

void sub_1B18C67A4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = sub_1B190B104();
  if (v2 == CFGetTypeID(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 8)))
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: This animation can't be changed to additive. To make this animation additive first convert it to a CAAnimation, set it to additive and convert back to VFXAnimation"), v3, v4, v5, v6, v7, v8, v9);
  sub_1B185D3F4(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned __int8 *)(a1 + 40), v3, v4, v5, v6, v7, v8);
}

void sub_1B18C6890(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = sub_1B190B104();
  if (v2 == CFGetTypeID(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 8)))
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: This animation can't be changed to cumulative. To make this animation cumulative first convert it to a CAAnimation, set it to cumulative and convert back to VFXAnimation"), v3, v4, v5, v6, v7, v8, v9);
  sub_1B185D4A4(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned __int8 *)(a1 + 40), v3, v4, v5, v6, v7, v8);
}

void sub_1B18C6A70(const void *a1)
{
  CFTypeID v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFIndex v17;
  uint64_t v18;
  const void *v19;
  CFTypeID v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;

  v2 = CFGetTypeID(a1);
  if (v2 == sub_1B18FF324())
  {
    v10 = sub_1B18FF4FC((uint64_t)a1, v3, v4, v5, v6, v7, v8, v9);
    if (v10 >= 1)
    {
      v17 = 0;
      v18 = v10;
      do
      {
        v19 = sub_1B18FF544((uint64_t)a1, v17, v11, v12, v13, v14, v15, v16);
        sub_1B18C6A70(v19);
        ++v17;
      }
      while (v18 != v17);
    }
  }
  else
  {
    v20 = CFGetTypeID(a1);
    if (v20 == sub_1B180713C())
    {
      v28 = sub_1B18072BC((uint64_t)a1, v21, v22, v23, v24, v25, v26, v27);
      v35 = 0;
      sub_1B17F5E04(v28, &v35, v29, v30, v31, v32, v33, v34);
    }
  }
}

void sub_1B18C7134(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;

  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40), a4);
  if ((sub_1B18C2F24(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 36));
    objc_msgSend_removeObjectForKey_(*(void **)(*(_QWORD *)(a1 + 40) + 40), v10, *(_QWORD *)(a1 + 48), v11);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 36));
  }
}

void sub_1B18C7304(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C30E4(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B18C73B0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C3148(*(void **)(a1 + 32), a2, a3, a4, *(float *)(a1 + 40));
}

void sub_1B18C746C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C2FF4(*(void **)(a1 + 32), *(char **)(a1 + 40), a3, a4);
}

void sub_1B18C7530(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C3064(*(void **)(a1 + 32), *(char **)(a1 + 40), a3, a4, *(float *)(a1 + 48));
}

void sub_1B18C7A10(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFXBinding *v24;

  v5 = (_QWORD *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  v24 = objc_alloc_init(CFXBinding);
  v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(_QWORD *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(_QWORD *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(_QWORD *)(a1 + 64), v17);
  sub_1B193F4C8(v5, v24, v18, v19, v20, v21, v22, v23);

}

void sub_1B18C7B3C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B193F704(v5, *(const __CFString **)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B18C7BE8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B193F68C(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B18C7CCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B17F117C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(float *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B18C7D64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B17F1094(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(float *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B18C7DF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B17F1260(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned __int8 *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

CFIndex sub_1B18C7E6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B17F1368(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8);
}

CFIndex sub_1B18C7EE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B17F13FC(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8);
}

CFIndex sub_1B18C7F58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v8;

  v8 = *(double *)(a1 + 40);
  return sub_1B17F1498(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), v8, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B18C7FEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B17F1540(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(_BYTE *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B18C823C(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  double v6;
  double v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double v16;
  double v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  double v21;

  objc_msgSend_time(a2, (const char *)a2, (uint64_t)a3, a4);
  v7 = v6;
  objc_msgSend_time(a3, v8, v9, v10);
  if (v7 < v14)
    return -1;
  objc_msgSend_time(a2, v11, v12, v13);
  v17 = v16;
  objc_msgSend_time(a3, v18, v19, v20);
  return v17 != v21;
}

uint64_t sub_1B18C82A4(_WORD *a1, void *a2, uint64_t a3, uint64_t a4)
{
  double v6;
  double v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  float v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  double v35;
  float v36;
  double v37;
  double v38;
  float v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  double v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  double v67;
  const char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  float v78;
  const char *v79;
  uint64_t v80;
  uint64_t v81;
  int isRemovedOnCompletion;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  const char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  float v99;
  const char *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  float v110;
  const char *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  const char *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  const char *v125;
  uint64_t v126;
  uint64_t v127;
  char v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  const char *v135;
  uint64_t v136;
  uint64_t v137;
  void *v138;
  const char *v139;
  uint64_t v140;
  uint64_t v141;
  _QWORD *v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  const char *v149;
  uint64_t v150;
  uint64_t v151;
  double v152;
  float v153;
  const char *v154;
  uint64_t v155;
  uint64_t v156;
  double v157;
  float v158;
  const char *v159;
  uint64_t v160;
  uint64_t v161;
  double v162;
  float v163;
  const char *v164;
  uint64_t v165;
  uint64_t v166;
  double v167;
  float v168;
  const void *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  void *v182;
  const char *v183;
  id v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;

  objc_msgSend_duration(a2, (const char *)a2, a3, a4);
  v7 = v6;
  v11 = objc_msgSend_autoreverses(a2, v8, v9, v10);
  v12 = v7;
  sub_1B185D0C4((uint64_t)a1, v12, v13, v14, v15, v16, v17, v18, v19);
  objc_msgSend_repeatCount(a2, v20, v21, v22);
  v24 = v23;
  objc_msgSend_repeatDuration(a2, v25, v26, v27);
  if (v24 == 0.0)
  {
    v36 = v35;
    if (v36 != 0.0 && v7 != 0.0)
    {
      v37 = v36;
      objc_msgSend_duration(a2, v28, v29, v30);
      v39 = v37 / v38;
      if (v11)
        v24 = v39 * 0.5;
      else
        v24 = v39;
    }
  }
  sub_1B185D1F4((uint64_t)a1, v24, (uint64_t)v28, v29, v30, v31, v32, v33, v34);
  sub_1B185D290((uint64_t)a1, v11, v40, v41, v42, v43, v44, v45);
  objc_msgSend_beginTime(a2, v46, v47, v48);
  sub_1B18089F4((uint64_t)a1, v56, v49, v50, v51, v52, v53, v54, v55);
  objc_msgSend_timeOffset(a2, v57, v58, v59);
  sub_1B185D69C((uint64_t)a1, v67, v60, v61, v62, v63, v64, v65, v66);
  objc_msgSend_speed(a2, v68, v69, v70);
  sub_1B185D738((uint64_t)a1, v78, v71, v72, v73, v74, v75, v76, v77);
  isRemovedOnCompletion = objc_msgSend_isRemovedOnCompletion(a2, v79, v80, v81);
  sub_1B185D5A0((uint64_t)a1, isRemovedOnCompletion, v83, v84, v85, v86, v87, v88);
  objc_msgSend_fadeInDuration(a2, v89, v90, v91);
  sub_1B185D7D4((uint64_t)a1, v99, v92, v93, v94, v95, v96, v97, v98);
  objc_msgSend_fadeOutDuration(a2, v100, v101, v102);
  sub_1B185D870((uint64_t)a1, v110, v103, v104, v105, v106, v107, v108, v109);
  v114 = objc_msgSend_commitsOnCompletion(a2, v111, v112, v113);
  sub_1B185D90C(a1, v114, v115, v116, v117, v118, v119, v120);
  v124 = objc_msgSend_fillMode(a2, v121, v122, v123);
  v128 = sub_1B18C16BC(v124, v125, v126, v127);
  sub_1B185DCD8((uint64_t)a1, v128, v129, v130, v131, v132, v133, v134);
  v138 = (void *)objc_msgSend_animationEvents(a2, v135, v136, v137);
  v142 = sub_1B18C18CC(v138, v139, v140, v141);
  sub_1B185DB64((uint64_t)a1, v142, v143, v144, v145, v146, v147, v148);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend_mass(a2, v149, v150, v151);
    v153 = v152;
    objc_msgSend_stiffness(a2, v154, v155, v156);
    v158 = v157;
    objc_msgSend_damping(a2, v159, v160, v161);
    v163 = v162;
    objc_msgSend_initialVelocity(a2, v164, v165, v166);
    v168 = v167;
    v169 = (const void *)sub_1B18026C0(v153, v158, v163, v168);
    sub_1B185D334((uint64_t)a1, v169, v170, v171, v172, v173, v174, v175);
    CFRelease(v169);
  }
  else
  {
    v182 = (void *)objc_msgSend_timingFunction(a2, v149, v150, v151);
    if (v182)
    {
      v184 = sub_1B1881E78(v182, v183);
      sub_1B185D334((uint64_t)a1, v184, v185, v186, v187, v188, v189, v190);
    }
  }
  return sub_1B18C293C((uint64_t)a1, a2, v176, v177, v178, v179, v180, v181);
}

uint64_t sub_1B18C84B0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v10 = sub_1B185D508(a2, a2, a3, a4, a5, a6, a7, a8);
  objc_msgSend_setAdditive_(a1, v11, v10, v12);
  v20 = sub_1B185D458(a2, v13, v14, v15, v16, v17, v18, v19);
  objc_msgSend_setCumulative_(a1, v21, v20, v22);
  return sub_1B18C8500(a1, a2, v23, v24, v25, v26, v27, v28);
}

uint64_t sub_1B18C8500(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  double v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  double v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  double v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  double v75;
  const char *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  double v86;
  const char *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  const char *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  const char *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  void *v143;
  const char *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t result;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  const char *v162;
  uint64_t v163;

  v10 = sub_1B185D118(a2, a2, a3, a4, a5, a6, a7, a8);
  objc_msgSend_setDuration_(a1, v11, v12, v13, v10);
  *(float *)&v21 = sub_1B185D248(a2, v14, v15, v16, v17, v18, v19, v20);
  objc_msgSend_setRepeatCount_(a1, v22, v23, v24, v21);
  v32 = sub_1B185D2E8(a2, v25, v26, v27, v28, v29, v30, v31);
  objc_msgSend_setAutoreverses_(a1, v33, v32, v34);
  v42 = sub_1B18089AC(a2, v35, v36, v37, v38, v39, v40, v41);
  objc_msgSend_setBeginTime_(a1, v43, v44, v45, v42);
  v53 = sub_1B185D6F0(a2, v46, v47, v48, v49, v50, v51, v52);
  objc_msgSend_setTimeOffset_(a1, v54, v55, v56, v53);
  *(float *)&v64 = sub_1B185D78C(a2, v57, v58, v59, v60, v61, v62, v63);
  objc_msgSend_setSpeed_(a1, v65, v66, v67, v64);
  *(float *)&v75 = sub_1B185D828(a2, v68, v69, v70, v71, v72, v73, v74);
  objc_msgSend_setFadeInDuration_(a1, v76, v77, v78, v75);
  *(float *)&v86 = sub_1B185D8C4(a2, v79, v80, v81, v82, v83, v84, v85);
  objc_msgSend_setFadeOutDuration_(a1, v87, v88, v89, v86);
  v97 = sub_1B185D554(a2, v90, v91, v92, v93, v94, v95, v96);
  objc_msgSend_setRemovedOnCompletion_(a1, v98, v97, v99);
  v107 = sub_1B185D9C8(a2, v100, v101, v102, v103, v104, v105, v106);
  objc_msgSend_setCommitsOnCompletion_(a1, v108, v107, v109);
  v117 = sub_1B185DC8C(a2, v110, v111, v112, v113, v114, v115, v116);
  v125 = sub_1B18C1790(v117, v118, v119, v120, v121, v122, v123, v124);
  objc_msgSend_setFillMode_(a1, v126, v125, v127);
  v135 = sub_1B185DB1C(a2, v128, v129, v130, v131, v132, v133, v134);
  v143 = sub_1B18C1A64(v135, v136, v137, v138, v139, v140, v141, v142);
  objc_msgSend_setAnimationEvents_(a1, v144, (uint64_t)v143, v145);
  result = sub_1B185D3AC(a2, v146, v147, v148, v149, v150, v151, v152);
  if (result)
  {
    v161 = sub_1B1881EFC(result, v154, v155, v156, v157, v158, v159, v160);
    return objc_msgSend_setTimingFunction_(a1, v162, v161, v163);
  }
  return result;
}

_WORD *sub_1B18C8624(void *a1, uint64_t a2)
{
  _WORD *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _BYTE v51[128];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v4 = (_WORD *)sub_1B18FF3A4();
  sub_1B18C82A4(v4, a1, v5, v6);
  v47 = 0u;
  v48 = 0u;
  v49 = 0u;
  v50 = 0u;
  v10 = (void *)objc_msgSend_animations(a1, v7, v8, v9);
  v12 = objc_msgSend_countByEnumeratingWithState_objects_count_(v10, v11, (uint64_t)&v47, (uint64_t)v51, 16);
  if (v12)
  {
    v13 = v12;
    v14 = *(_QWORD *)v48;
    do
    {
      v15 = 0;
      do
      {
        if (*(_QWORD *)v48 != v14)
          objc_enumerationMutation(v10);
        v16 = *(void **)(*((_QWORD *)&v47 + 1) + 8 * v15);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v17 = (void *)sub_1B18C8624(v16, a2);
          sub_1B18FF420((uint64_t)v4, v17, v18, v19, v20, v21, v22, v23);
        }
        else
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            v27 = (void *)objc_msgSend_keyPath(v16, v24, v25, v26);
            v31 = objc_msgSend_copy(v27, v28, v29, v30);
            if (v31)
            {
              v38 = (void *)v31;
              v39 = (void *)sub_1B18C29E8(v16, a2);
              if (v39)
                sub_1B18FF420((uint64_t)v4, v39, v40, v41, v42, v43, v44, v45);

            }
            else
            {
              sub_1B17C4408(16, (uint64_t)CFSTR("Error: sub-animation %@ of %@ has no keyPath - ignoring"), v32, v33, v34, v35, v36, v37, (uint64_t)v16);
            }
          }
        }
        ++v15;
      }
      while (v13 != v15);
      v13 = objc_msgSend_countByEnumeratingWithState_objects_count_(v10, v24, (uint64_t)&v47, (uint64_t)v51, 16);
    }
    while (v13);
  }
  return v4;
}

id sub_1B18C87D4(uint64_t a1)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFArray *v16;
  const char *v17;
  uint64_t v18;
  CFIndex Count;
  const char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  CFIndex i;
  const void *v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  void *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  uint64_t v45;
  uint64_t v47;

  v2 = objc_alloc_init(MEMORY[0x1E0CD2700]);
  sub_1B18C8500(v2, a1, v3, v4, v5, v6, v7, v8);
  v16 = (const __CFArray *)sub_1B18FF594(a1, v9, v10, v11, v12, v13, v14, v15);
  if (v16)
  {
    Count = CFArrayGetCount(v16);
    v29 = (void *)objc_msgSend_arrayWithCapacity_(MEMORY[0x1E0C99DE8], v20, Count, v21);
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        v31 = sub_1B18FF544(a1, i, v23, v24, v25, v26, v27, v28);
        v32 = (void *)sub_1B18C2BB4();
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v35 = (void *)sub_1B185D090((uint64_t)v31);
          if (v35)
          {
            v43 = objc_msgSend_componentsJoinedByString_(v35, v36, (uint64_t)CFSTR("."), v38);
            objc_msgSend_setKeyPath_(v32, v44, v43, v45);
          }
          else
          {
            sub_1B17C4408(0, (uint64_t)CFSTR("Warning: VFXAnimationGroupToCAAnimationGroup - no target path"), v37, v38, v39, v40, v41, v42, v47);
          }
        }
        objc_msgSend_addObject_(v29, v33, (uint64_t)v32, v34);
      }
    }
  }
  else
  {
    v29 = (void *)objc_msgSend_arrayWithCapacity_(MEMORY[0x1E0C99DE8], v17, 0, v18);
  }
  objc_msgSend_setAnimations_(v2, v22, (uint64_t)v29, v24);
  return v2;
}

uint64_t sub_1B18C890C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel_animationDidStart_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18C8918(uint64_t a1)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel_animationDidStop_finished_, *(_QWORD *)(a1 + 40), *(unsigned __int8 *)(a1 + 48));
}

#error "1B18C9474: call analysis failed (funcsize=92)"

void sub_1B18C95C8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_1B18CA040()
{
  uint64_t result;

  result = CGImageGetImageProvider();
  if (result)
    return CGImageProviderCopyIOSurface();
  return result;
}

void sub_1B18CA7A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B18CA7BC(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_1B18CA7CC(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t sub_1B18CA7D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  v5 = objc_msgSend_sharedRegistry(VFXSourceRendererRegistry, a2, a3, a4);
  return MEMORY[0x1E0DE7D20](v5, sel_removeSourceRenderersForSource_, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v6);
}

uint64_t sub_1B18CA90C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialColor_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CAB14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialNumber_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CAD34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialLayer_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CAD40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialAsset_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CB1C4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__updateMaterialFilters(*(void **)(a1 + 32), a2, a3, a4);
}

uint64_t sub_1B18CB264(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__updateMaterialFilters(*(void **)(a1 + 32), a2, a3, a4);
}

uint64_t sub_1B18CB304(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__updateMaterialFilters(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B18CB428(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t IfNeeded;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  IfNeeded = objc_msgSend_materialPropertyCreateIfNeeded_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40) != 0, a4);
  if (IfNeeded)
    sub_1B1841FB8(IfNeeded, *(_QWORD *)(a1 + 40), v11, v12, v13, v14, v15, v16, a9);
}

void sub_1B18CB57C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t IfNeeded;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  IfNeeded = objc_msgSend_materialPropertyCreateIfNeeded_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40) != 15, a4);
  if (IfNeeded)
    sub_1B1843400(IfNeeded, *(unsigned __int8 *)(a1 + 40), v11, v12, v13, v14, v15, v16, a9);
}

void sub_1B18CB684(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v10 = objc_msgSend_materialProperty(*(void **)(a1 + 32), a2, a3, a4);
  if (v10)
    sub_1B1841E5C(v10, *(float *)(a1 + 40), v11, v12, v13, v14, v15, v16, v17, a9);
}

uint64_t sub_1B18CB864(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__updateMaterialFilters(*(void **)(a1 + 32), a2, a3, a4);
}

uint64_t sub_1B18CB9A0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__updateMaterialFilters(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B18CBAB8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (objc_msgSend_materialProperty(*(void **)(a1 + 32), a2, a3, a4))
  {
    v13 = objc_msgSend_materialProperty(*(void **)(a1 + 32), v10, v11, v12);
    sub_1B1843554(v13, *(unsigned __int8 *)(a1 + 40), v14, v15, v16, v17, v18, v19, a9);
  }
}

uint64_t sub_1B18CBC4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialImage_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CBEC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialLayer_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CBF94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialAVPlayer_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CC060(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialCaptureDevice_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CC12C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialCaptureDeviceOutputConsumerSource_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CC1F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialTextureProvider_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CC2C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updatePrecomputedLightingEnvironment_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CC514(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialUIComponent_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CC5E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialUIComponent_, *(_QWORD *)(a1 + 40), a4);
}

Class sub_1B18CC5EC()
{
  return NSClassFromString(CFSTR("AVPlayer"));
}

Class sub_1B18CC5F8()
{
  return NSClassFromString(CFSTR("AVCaptureDevice"));
}

int8x8_t sub_1B18CCC30(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int8x8_t result;

  v5 = objc_msgSend_textureSampler(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
    return sub_1B180CAE0(v5, *(float *)(a1 + 40), v6, v7, v8, v9, v10, v11, v12);
  return result;
}

uint64_t sub_1B18CCD0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__updateMaterialMTLTexture_, *(_QWORD *)(a1 + 40), a4);
}

uint64_t sub_1B18CCE54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 96), sel__updateMaterialPropertyTransform_, a3, a4);
}

void sub_1B18CD9AC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;

  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40), a4);
  if ((sub_1B18C2F24(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 24));
    objc_msgSend_removeObjectForKey_(*(void **)(*(_QWORD *)(a1 + 40) + 32), v10, *(_QWORD *)(a1 + 48), v11);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 24));
  }
}

void sub_1B18CDB7C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C30E4(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B18CDC28(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C3148(*(void **)(a1 + 32), a2, a3, a4, *(float *)(a1 + 40));
}

void sub_1B18CDCE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C2FF4(*(void **)(a1 + 32), *(char **)(a1 + 40), a3, a4);
}

void sub_1B18CDDA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C3064(*(void **)(a1 + 32), *(char **)(a1 + 40), a3, a4, *(float *)(a1 + 48));
}

void sub_1B18CE288(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFXBinding *v24;

  v5 = (_QWORD *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  v24 = objc_alloc_init(CFXBinding);
  v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(_QWORD *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(_QWORD *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(_QWORD *)(a1 + 64), v17);
  sub_1B193F4C8(v5, v24, v18, v19, v20, v21, v22, v23);

}

void sub_1B18CE3B4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B193F704(v5, *(const __CFString **)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B18CE460(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B193F68C(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B18CFF34(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = objc_msgSend_resourceManager(a2, (const char *)a2, a3, a4);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return a1;
}

uint64_t sub_1B18CFF6C(uint64_t a1)
{
  id *v2;
  id *v3;

  v2 = *(id **)(a1 + 16);
  v3 = *(id **)(a1 + 24);
  if (v2 != v3)
  {
    do
    {
      if (*v2)

      v2 += 12;
    }
    while (v2 != v3);
    v2 = *(id **)(a1 + 16);
  }
  if (v2)
  {
    *(_QWORD *)(a1 + 24) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1B18CFFCC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 16);
  if (v3)
  {
    *(_QWORD *)(v1 + 24) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B18CFFEC(uint64_t a1, unsigned __int16 *a2, void *a3, uint64_t a4)
{
  id v4;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 *v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  unint64_t v23;
  unint64_t v24;
  __int128 v25;
  __int128 v26;
  char *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  __int128 v35;
  __int128 v36;
  char *v37;
  char *v38;
  char *v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  _OWORD v55[5];
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;

  v4 = a3;
  v7 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v7)
  {
    v8 = 0;
    v9 = *(_QWORD *)(a1 + 16);
    v10 = v9 + 96 * v7;
    while (1)
    {
      if (*(unsigned __int16 *)(v9 + v8 + 8) == *a2
        && *(unsigned __int16 *)(v9 + v8 + 10) == a2[1]
        && *(unsigned __int16 *)(v9 + v8 + 12) == a2[2]
        && *(unsigned __int16 *)(v9 + v8 + 14) == a2[3]
        && *(unsigned __int8 *)(v9 + v8 + 16) == *((unsigned __int8 *)a2 + 8)
        && *(unsigned __int8 *)(v9 + v8 + 17) == *((unsigned __int8 *)a2 + 9)
        && *(unsigned __int8 *)(v9 + v8 + 18) == *((unsigned __int8 *)a2 + 10)
        && *(_QWORD *)(v9 + v8 + 24) == *((_QWORD *)a2 + 2)
        && *(_QWORD *)(v9 + v8 + 32) == *((_QWORD *)a2 + 3)
        && *(_QWORD *)(v9 + v8 + 40) == *((_QWORD *)a2 + 4)
        && *(_QWORD *)(v9 + v8 + 48) == *((_QWORD *)a2 + 5)
        && *(_QWORD *)(v9 + v8 + 56) == *((_QWORD *)a2 + 6)
        && *(_QWORD *)(v9 + v8 + 64) == *((_QWORD *)a2 + 7)
        && *(_QWORD *)(v9 + v8 + 72) == *((_QWORD *)a2 + 8)
        && *(unsigned __int8 *)(v9 + v8 + 80) == *((unsigned __int8 *)a2 + 72)
        && *(unsigned __int8 *)(v9 + v8 + 81) == *((unsigned __int8 *)a2 + 73)
        && *(unsigned __int8 *)(v9 + v8 + 82) == *((unsigned __int8 *)a2 + 74)
        && *(unsigned __int8 *)(v9 + v8 + 83) == *((unsigned __int8 *)a2 + 75))
      {
        v11 = (__int128 *)(v9 + v8);
        if (!(_DWORD)a4 || *((_DWORD *)v11 + 22) >= 3u)
          break;
      }
      v8 += 96;
      if (96 * v7 == v8)
        goto LABEL_24;
    }
    v20 = *(_QWORD *)v11;
    *((_DWORD *)v11 + 22) = 0;
    if (96 * v7 - 96 != v8)
    {
      v7 = v10 - 96;
      v45 = v11[3];
      v58 = v11[2];
      v59 = v45;
      v46 = v11[5];
      v60 = v11[4];
      v61 = v46;
      v47 = v11[1];
      v56 = *v11;
      v57 = v47;
      v48 = *(_OWORD *)(v10 - 80);
      *v11 = *(_OWORD *)(v10 - 96);
      v11[1] = v48;
      v49 = *(_OWORD *)(v10 - 16);
      v51 = *(_OWORD *)(v10 - 64);
      v50 = *(_OWORD *)(v10 - 48);
      v11[4] = *(_OWORD *)(v10 - 32);
      v11[5] = v49;
      v11[2] = v51;
      v11[3] = v50;
      v52 = v61;
      *(_OWORD *)(v7 + 64) = v60;
      *(_OWORD *)(v7 + 80) = v52;
      v53 = v59;
      *(_OWORD *)(v7 + 32) = v58;
      *(_OWORD *)(v7 + 48) = v53;
      v54 = v57;
      *(_OWORD *)v7 = v56;
      *(_OWORD *)(v7 + 16) = v54;
      LODWORD(v7) = *(_DWORD *)(a1 + 40);
    }
    *(_DWORD *)(a1 + 40) = v7 - 1;
  }
  else
  {
LABEL_24:
    if (!a3)
    {
      v4 = objc_alloc_init(MEMORY[0x1E0CC6BB0]);
      v12 = *((_OWORD *)a2 + 3);
      v55[2] = *((_OWORD *)a2 + 2);
      v55[3] = v12;
      v55[4] = *((_OWORD *)a2 + 4);
      v13 = *((_OWORD *)a2 + 1);
      v55[0] = *(_OWORD *)a2;
      v55[1] = v13;
      RGTextureDescriptorFillMTLDescriptor((unsigned __int16 *)v55, v4);
    }
    v20 = objc_msgSend_newTextureWithDescriptor_(*(void **)(a1 + 8), (const char *)a2, (uint64_t)v4, a4);
    v21 = *((_OWORD *)a2 + 3);
    v58 = *((_OWORD *)a2 + 2);
    v59 = v21;
    v60 = *((_OWORD *)a2 + 4);
    v22 = *((_OWORD *)a2 + 1);
    v56 = *(_OWORD *)a2;
    v57 = v22;
    if (v20)
    {
      v23 = *(_QWORD *)(a1 + 32);
      v24 = *(_QWORD *)(a1 + 24);
      if (v24 >= v23)
      {
        v28 = *(_QWORD *)(a1 + 16);
        v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - v28) >> 5);
        v30 = v29 + 1;
        if (v29 + 1 > 0x2AAAAAAAAAAAAAALL)
          abort();
        v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - v28) >> 5);
        if (2 * v31 > v30)
          v30 = 2 * v31;
        if (v31 >= 0x155555555555555)
          v32 = 0x2AAAAAAAAAAAAAALL;
        else
          v32 = v30;
        if (v32)
          v33 = (char *)sub_1B18D066C(a1 + 32, v32);
        else
          v33 = 0;
        v34 = &v33[96 * v29];
        v35 = v57;
        *(_OWORD *)(v34 + 8) = v56;
        *(_OWORD *)(v34 + 72) = v60;
        v36 = v58;
        *(_OWORD *)(v34 + 56) = v59;
        *(_OWORD *)(v34 + 40) = v36;
        v37 = &v33[96 * v32];
        *(_QWORD *)v34 = v20;
        *(_OWORD *)(v34 + 24) = v35;
        *((_QWORD *)v34 + 11) = 0;
        v27 = v34 + 96;
        v39 = *(char **)(a1 + 16);
        v38 = *(char **)(a1 + 24);
        if (v38 != v39)
        {
          do
          {
            v40 = *((_OWORD *)v38 - 5);
            *((_OWORD *)v34 - 6) = *((_OWORD *)v38 - 6);
            *((_OWORD *)v34 - 5) = v40;
            v41 = *((_OWORD *)v38 - 4);
            v42 = *((_OWORD *)v38 - 3);
            v43 = *((_OWORD *)v38 - 1);
            *((_OWORD *)v34 - 2) = *((_OWORD *)v38 - 2);
            *((_OWORD *)v34 - 1) = v43;
            *((_OWORD *)v34 - 4) = v41;
            *((_OWORD *)v34 - 3) = v42;
            v34 -= 96;
            v38 -= 96;
          }
          while (v38 != v39);
          v38 = *(char **)(a1 + 16);
        }
        *(_QWORD *)(a1 + 16) = v34;
        *(_QWORD *)(a1 + 24) = v27;
        *(_QWORD *)(a1 + 32) = v37;
        if (v38)
          operator delete(v38);
      }
      else
      {
        *(_QWORD *)v24 = v20;
        v25 = v56;
        *(_OWORD *)(v24 + 24) = v57;
        v26 = v59;
        *(_OWORD *)(v24 + 40) = v58;
        *(_OWORD *)(v24 + 56) = v26;
        *(_OWORD *)(v24 + 72) = v60;
        *(_OWORD *)(v24 + 8) = v25;
        v27 = (char *)(v24 + 96);
        *(_QWORD *)(v24 + 88) = 0;
      }
      *(_QWORD *)(a1 + 24) = v27;
    }
    else
    {
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: Could not create texture with descriptor : %@"), v14, v15, v16, v17, v18, v19, (uint64_t)v4);
    }
  }
  return v20;
}

void *sub_1B18D03D4(void **a1, unsigned __int16 *a2, _QWORD *a3, uint64_t a4)
{
  int v4;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  void *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  void **v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  const char *v48;
  const char *v49;
  const char *v50;
  const char *v51;
  uint64_t v52;
  _WORD v54[2];
  int v55;
  _QWORD v56[6];
  _OWORD v57[5];

  v4 = a4;
  if ((_DWORD)a4)
  {
    v8 = 0;
  }
  else
  {
    v8 = 2;
    *((_QWORD *)a2 + 5) |= 2uLL;
  }
  *((_QWORD *)a2 + 4) = v8;
  v9 = *((_OWORD *)a2 + 4);
  v10 = *((_OWORD *)a2 + 1);
  v57[0] = *(_OWORD *)a2;
  v57[1] = v10;
  v11 = *((_OWORD *)a2 + 2);
  v57[3] = *((_OWORD *)a2 + 3);
  v57[4] = v9;
  v57[2] = v11;
  v12 = (void *)sub_1B18CFFEC((uint64_t)a1, (unsigned __int16 *)v57, 0, a4);
  v13 = (unint64_t)sub_1B189D6D0() >> 3;
  v14 = v13 * *a2;
  v15 = v14 * a2[1];
  v19 = objc_msgSend_width(v12, v16, v17, v18);
  v23 = objc_msgSend_height(v12, v20, v21, v22);
  v27 = objc_msgSend_depth(v12, v24, v25, v26);
  if (v4)
  {
    memset(v56, 0, 24);
    v56[3] = v19;
    v56[4] = v23;
    v56[5] = v27;
    objc_msgSend_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage_(v12, v28, (uint64_t)v56, 0, 0, *a3, v14, v15);
  }
  else
  {
    v54[0] = v13;
    v54[1] = v14;
    v55 = v15;
    if (objc_msgSend_pixelFormat(v12, v28, v29, v30) != 23
      && objc_msgSend_pixelFormat(v12, v31, v32, v33) != 63
      && objc_msgSend_pixelFormat(v12, v31, v34, v33) != 113)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Only uint16 format are supported for the compute path of the copy buffer to texture"), v35, v33, v36, v37, v38, v39, (uint64_t)"(tex.pixelFormat == MTLPixelFormatR16Uint) || (tex.pixelFormat == MTLPixelFormatRG16Uint) || (tex.pixelFormat == MTLPixelFormatRGBA16Uint)");
    }
    v40 = objc_msgSend_computePipelineStateForKernel_(a1[1], v31, (uint64_t)CFSTR("copy_texture_3D_from_buffer_ushort"), v33);
    v44 = (void **)objc_msgSend_resourceComputeEncoder(*a1, v41, v42, v43);
    v45 = sub_1B18FD774(v40);
    objc_msgSend_setComputePipelineState_(*v44, v46, v45, v47);
    objc_msgSend_setBuffer_offset_atIndex_(*v44, v48, a3[1], a3[2], 0);
    objc_msgSend_setBytes_length_atIndex_(*v44, v49, (uint64_t)v54, 8, 1);
    objc_msgSend_setTexture_atIndex_(*v44, v50, (uint64_t)v12, 0);
    objc_msgSend_dispatchOnTexture3D_(*v44, v51, (uint64_t)v12, v52);
  }
  return v12;
}

void sub_1B18D05C4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  v3 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 24);
  if (v3 == v2)
  {
    v3 = *(_QWORD *)(a1 + 24);
  }
  else
  {
    do
    {
      v4 = *(_DWORD *)(v3 + 88);
      *(_DWORD *)(v3 + 88) = v4 + 1;
      if (v4 < 0x65)
      {
        v3 += 96;
      }
      else
      {

        v5 = *(_QWORD *)(a1 + 24);
        v6 = v5 - (v3 + 96);
        if (v5 != v3 + 96)
          memmove((void *)v3, (const void *)(v3 + 96), v5 - (v3 + 96));
        v2 = v3 + v6;
        *(_QWORD *)(a1 + 24) = v3 + v6;
      }
    }
    while (v3 != v2);
    v2 = *(_QWORD *)(a1 + 16);
  }
  *(_DWORD *)(a1 + 40) = -1431655765 * ((unint64_t)(v3 - v2) >> 5);
}

void *sub_1B18D066C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL)
    sub_1B179C4A8();
  return operator new(96 * a2);
}

uint64_t sub_1B18D06B0(uint64_t *a1)
{
  uint64_t result;

  result = sub_1B179CB60(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B18D06DC(uint64_t a1)
{
  uint64_t v2;

  if (qword_1EEF66128 != -1)
    dispatch_once_f(&qword_1EEF66128, &qword_1EEF66120, (dispatch_function_t)sub_1B18D06B0);
  v2 = sub_1B179CB90(qword_1EEF66120, 0x40uLL);
  *(_QWORD *)(v2 + 16) = a1;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 48) = -1;
  *(_QWORD *)(v2 + 56) = 0;
  *(_DWORD *)(v2 + 64) = 0;
  *(_QWORD *)(v2 + 72) = 0;
  sub_1B18D197C(v2, 1);
  return v2;
}

uint64_t sub_1B18D0764(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  return sub_1B18D07C4(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B18D07C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v10;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int *v19;
  uint64_t v20;
  char *v21;
  _QWORD *v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  unint64_t v28;
  int *v29;
  char *v30;
  int v31;
  unint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  __int128 v35;
  _OWORD *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;

  if ((_DWORD)a3 == -1)
  {
    v11 = -1;
    v12 = -1;
  }
  else
  {
    v10 = (int *)(*(_QWORD *)(a1 + 24) + 8 * (int)a3);
    v11 = *v10;
    v12 = v10[1];
  }
  v13 = v11;
  v14 = v11 + 1;
  if ((int)v14 >= *(_DWORD *)(a1 + 64))
    sub_1B18D197C(a1, v11 + 2);
  v15 = *(_QWORD *)(a1 + 56);
  v16 = v15 + 80 * v14;
  v18 = *(_DWORD *)(v16 + 72);
  v17 = *(_DWORD *)(v16 + 76);
  v19 = (int *)(v16 + 72);
  if (v18 == v17)
  {
    sub_1B18D1AF4(v15 + 80 * v14, 2 * v18);
    v18 = *v19;
  }
  v20 = v15 + 80 * v14;
  v23 = *(char **)(v20 + 24);
  v22 = (_QWORD *)(v20 + 24);
  v21 = v23;
  v24 = v18;
  if (!v18)
    goto LABEL_16;
  v25 = v18;
  v26 = v21;
  v27 = &v21[4 * v18];
  do
  {
    v28 = v25 >> 1;
    v29 = (int *)&v26[4 * (v25 >> 1)];
    v31 = *v29;
    v30 = (char *)(v29 + 1);
    v25 += ~(v25 >> 1);
    if (v12 < v31)
      v25 = v28;
    else
      v26 = v30;
  }
  while (v25);
  if (v26 == v27)
  {
LABEL_16:
    v32 = 4 * v24;
  }
  else
  {
    v32 = v26 - v21;
    sub_1B18D1EE4(a1, v14 | ((unint64_t)((unint64_t)(v26 - v21) >> 2) << 32), v13 | ((unint64_t)v12 << 32), 1, a5, a6, a7, a8);
  }
  if ((v32 >> 2) == -1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. no more handle available"), a3, a4, a5, a6, a7, a8, (uint64_t)"handle.index != kCFXTransformIndexInvalid");
  ++*v19;
  v33 = (_QWORD *)(v15 + 80 * v14);
  *(_QWORD *)(v33[5] + ((uint64_t)(v32 << 30) >> 29)) = a2;
  v34 = (uint64_t)(v32 << 30) >> 30;
  *(_DWORD *)(v33[7] + v34) = *(_DWORD *)(a2 + 216);
  *(_DWORD *)(*v22 + v34) = v12;
  *(_DWORD *)(v33[4] + v34) = -1;
  *(double *)&v35 = sub_1B18697A0(a2, a2, a3, a4, a5, a6, a7, a8);
  v36 = (_OWORD *)(v33[2] + ((uint64_t)(v32 << 30) >> 26));
  *v36 = v35;
  v36[1] = v37;
  v36[2] = v38;
  v36[3] = v39;
  v40 = v14 | (v32 << 30);
  sub_1B18D2084(a1, v40);
  v45 = sub_1B18D21A0(a1, v40);
  *(_DWORD *)(v33[6] + v34) = v45;
  if (v13 != -1)
  {
    v46 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * (int)v13 + 32);
    if (*(_DWORD *)(v46 + 4 * v12) == -1)
      *(_DWORD *)(v46 + 4 * v12) = v32 >> 2;
  }
  sub_1B18D22AC(a1, v40, v13 | ((unint64_t)v12 << 32), 0xFFFFFFFFLL, v41, v42, v43, v44);
  ++*(_DWORD *)(a1 + 72);
  return v45;
}

void sub_1B18D0A0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  sub_1B18D0A5C(a1, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B18D0A5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  int v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v42;
  int v43;
  char *v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  signed int v56;
  int *v57;
  uint64_t v58;
  int v59;
  int v60;
  int32x2_t *v61;
  int32x2_t *v62;
  int32x2_t v63;
  int32x2_t v64;
  int v65;
  int v66;
  __int32 v67;
  int v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _DWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  int v76;
  int v77;
  int v78;
  int v79;
  uint64_t v80;
  int v81;
  int v82;
  uint64_t v83;
  int v84;
  char *v85;
  int v86;
  _QWORD *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  uint64_t v94;
  int *v95;
  int v96;
  int v97;
  _DWORD *v98;
  int v99;
  uint64_t v100;
  os_unfair_lock_t v101;
  uint64_t v102;
  uint64_t v103;
  char *v104;
  uint64_t v105;

  v105 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a2 == -1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. invalid handle (%d) given"), a3, a4, a5, a6, a7, a8, (uint64_t)"hnd != kCFXTransformHandleInvalid");
  v10 = *(_QWORD *)(a1 + 24);
  v11 = (unsigned int *)(v10 + 8 * (int)a2);
  v12 = *v11;
  v13 = v11[1];
  ++*(_DWORD *)(a1 + 72);
  if ((_DWORD)v13 == -1)
  {
    *v11 = -1;
    *(_DWORD *)(v10 + 8 * (int)a2 + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(a1 + 48) = a2;
    return;
  }
  v102 = a2;
  v103 = (int)a2;
  v101 = (os_unfair_lock_t)(a1 + 76);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 76));
  v100 = (uint64_t)&v100;
  MEMORY[0x1E0C80A78](v14, v15);
  v17 = (char *)&v100 - ((v16 + 15) & 0x7FFFFFFF0);
  v18 = *(unsigned int *)(a1 + 64);
  MEMORY[0x1E0C80A78](v19, v20);
  v28 = (char *)&v100 - v27;
  v104 = (char *)&v100 - v27;
  if ((int)v18 >= 1)
  {
    memset_pattern16(v17, &unk_1B2247B50, 4 * v18);
    v28 = v104;
    memset_pattern16(v104, &unk_1B2247B60, 4 * v18);
  }
  *(_DWORD *)&v17[4 * v12] = v13;
  *(_DWORD *)&v28[4 * v12] = v13;
  v29 = v12 + 1;
  LODWORD(v30) = v18;
  if ((int)(v12 + 1) < (int)v18)
  {
    LODWORD(v31) = v12;
    v32 = v13;
    while (1)
    {
      v33 = v31 | (v13 << 32);
      v34 = v12 | (v32 << 32);
      v31 = sub_1B18D253C(a1, v33, v34, v22, v23, v24, v25, v26);
      v13 = HIDWORD(v31);
      v40 = sub_1B18D2614(a1, v33, v34, v35, v36, v37, v38, v39);
      v32 = HIDWORD(v40);
      if (HIDWORD(v31) == -1 && HIDWORD(v40) == -1)
        break;
      v12 = v40;
      if (HIDWORD(v31) == -1)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v21, v22, v23, v24, v25, v26, (uint64_t)"firstChild.index != kCFXTransformIndexInvalid");
      if ((_DWORD)v32 == -1)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v21, v22, v23, v24, v25, v26, (uint64_t)"lastChild.index != kCFXTransformIndexInvalid");
      if (v12 != (_DWORD)v31)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v21, v22, v23, v24, v25, v26, (uint64_t)"lastChild.level == firstChild.level");
      if ((int)v32 < SHIDWORD(v31))
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v21, v22, v23, v24, v25, v26, (uint64_t)"lastChild.index >= firstChild.index");
      v42 = *(int *)&v17[4 * (int)v31];
      if ((int)v42 >= SHIDWORD(v31))
        v43 = HIDWORD(v31);
      else
        v43 = *(_DWORD *)&v17[4 * (int)v31];
      *(_DWORD *)&v17[4 * (int)v31] = v43;
      v44 = v104;
      v45 = *(_DWORD *)&v104[4 * v12];
      if (v45 <= (int)v32)
        v45 = v32;
      *(_DWORD *)&v104[4 * v12] = v45;
      v46 = *(_DWORD *)&v44[4 * (int)v31];
      if (v43 <= v46)
      {
        v47 = *(_QWORD *)(a1 + 24);
        if (v42 >= v31 >> 32)
          v42 = v31 >> 32;
        v48 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * (int)v31 + 40) + 8 * v42);
        v49 = v46 - v43 + 1;
        do
        {
          v50 = *v48++;
          *(_QWORD *)(v47 + 8 * *(int *)(v50 + 88)) = -1;
          --v49;
        }
        while (v49);
      }
      ++v29;
      LODWORD(v30) = *(_DWORD *)(a1 + 64);
      if (v29 >= (int)v30)
        goto LABEL_34;
    }
    LODWORD(v30) = *(_DWORD *)(a1 + 64);
LABEL_34:
    v28 = v104;
  }
  if ((int)v30 < 1)
  {
    v93 = 0;
    v96 = v102;
    v92 = v103;
    goto LABEL_91;
  }
  v51 = 0;
  do
  {
    v52 = v51;
    v53 = *(_QWORD *)(a1 + 56);
    v54 = *(_DWORD *)&v28[4 * v51];
    v55 = *(int *)&v17[4 * v51];
    if (v54 >= (int)v55)
    {
      v58 = v53 + 80 * v51;
      v56 = v54 - v55 + 1;
      sub_1B18D2340(v58, v54 + 1, ~(v54 - v55), v22, v23, v24, v25, v26);
      v59 = *(_DWORD *)(v58 + 72);
      v57 = (int *)(v58 + 72);
      v60 = v59 - v56;
      *v57 = v59 - v56;
      if (v54 - (_DWORD)v55 == -1)
      {
        v56 = 0;
      }
      else
      {
        v61 = (int32x2_t *)(v53 + 80 * v51);
        v63 = v61[8];
        v62 = v61 + 8;
        v64 = v63;
        v65 = v63.i32[0];
        v66 = v63.i32[1];
        if (v63.i32[0] <= v63.i32[1])
        {
          if ((int)v55 <= v65)
          {
            *v62 = vmax_s32(vsub_s32(v64, vdup_n_s32(v56)), 0);
          }
          else if (v54 <= v66)
          {
            v67 = v60 - 1;
            if (v66 < v67)
              v67 = v66;
            v62->i32[1] = v67;
          }
        }
      }
    }
    else
    {
      v56 = 0;
      v57 = (int *)(v53 + 80 * v51 + 72);
    }
    ++v51;
    if (v52 + 1 < *(int *)(a1 + 64))
    {
      v68 = *(_DWORD *)&v28[4 * v51];
      v69 = *(_DWORD *)&v17[4 * v51];
      if (v68 >= v69 && *v57 >= 1)
      {
        v70 = 0;
        v71 = *(_QWORD *)(v53 + 80 * v52 + 32);
        v72 = *(_QWORD *)(a1 + 56) + 80 * v51;
        v73 = (_DWORD *)(v72 + 72);
        v74 = (_QWORD *)(v72 + 24);
        v75 = v68 + 1;
        while (1)
        {
          v76 = *(_DWORD *)(v71 + 4 * v70);
          if (v76 > v68)
            break;
          if (v76 >= v69)
          {
            if ((int)v75 >= *v73 || (v77 = v69, v70 != *(_DWORD *)(*v74 + 4 * v75)))
              v77 = -1;
            goto LABEL_58;
          }
LABEL_59:
          if (++v70 >= *v57)
            goto LABEL_60;
        }
        v77 = v69 + ~v68 + v76;
LABEL_58:
        *(_DWORD *)(v71 + 4 * v70) = v77;
        goto LABEL_59;
      }
    }
LABEL_60:
    if (v52)
    {
      v78 = *(_DWORD *)&v28[4 * (v52 - 1)];
      v79 = *(_DWORD *)&v17[4 * (v52 - 1)];
      if (v78 >= v79)
      {
        LODWORD(v80) = (_DWORD)v55 == 0x7FFFFFFF ? 0 : v55;
        v81 = *v57;
        if ((int)v80 < *v57)
        {
          v82 = v79 + ~v78;
          v83 = *(_QWORD *)(v53 + 80 * v52 + 24);
          v80 = (int)v80;
          do
          {
            v84 = *(_DWORD *)(v83 + 4 * v80);
            if (v84 >= v79)
            {
              *(_DWORD *)(v83 + 4 * v80) = v82 + v84;
              v81 = *v57;
            }
            ++v80;
          }
          while (v80 < v81);
        }
      }
    }
    v85 = v17;
    if (v56 >= 1)
    {
      if ((_DWORD)v55 == 0x7FFFFFFF)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v21, v22, v23, v24, v25, v26, (uint64_t)"firstChildToRemainAfterDeletion != INT32_MAX");
      v86 = *v57;
      if ((int)v55 < *v57)
      {
        v87 = (_QWORD *)(v53 + 80 * v52 + 40);
        v88 = *(_QWORD *)(a1 + 24);
        v89 = v55;
        do
        {
          v90 = *(_QWORD *)(*v87 + 8 * v89);
          v91 = *(int *)(v90 + 88);
          if (*(_QWORD *)(v88 + 8 * v91) != -1)
          {
            if (v52 != *(_DWORD *)(v88 + 8 * v91))
            {
              sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v21, v22, v23, v24, v25, v26, (uint64_t)"_handles[ node->_transformHandle ].level == l");
              v91 = *(int *)(v90 + 88);
              v88 = *(_QWORD *)(a1 + 24);
            }
            if (*(_DWORD *)(v88 + 8 * v91 + 4) < (int)v55)
            {
              sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v21, v22, v23, v24, v25, v26, (uint64_t)"_handles[ node->_transformHandle ].index >= minIndexToDestroyPerLevel[ l ]");
              v91 = *(int *)(v90 + 88);
              v88 = *(_QWORD *)(a1 + 24);
            }
            *(_DWORD *)(v88 + 8 * v91 + 4) -= v56;
            v86 = *v57;
          }
          ++v89;
        }
        while (v89 < v86);
      }
    }
    v30 = *(int *)(a1 + 64);
    v17 = v85;
    v28 = v104;
  }
  while (v51 < v30);
  v92 = v103;
  v93 = 0;
  if ((int)v30 < 1)
  {
    v96 = v102;
  }
  else
  {
    v94 = *(unsigned int *)(a1 + 64);
    v95 = (int *)(*(_QWORD *)(a1 + 56) + 72);
    v96 = v102;
    do
    {
      v97 = *v95;
      v95 += 20;
      if (v97)
        ++v93;
      --v94;
    }
    while (v94);
  }
LABEL_91:
  if (v93 < (int)v30)
    sub_1B18D197C(a1, v93);
  v98 = (_DWORD *)(*(_QWORD *)(a1 + 24) + 8 * v92);
  v99 = *(_DWORD *)(a1 + 48);
  *v98 = -1;
  v98[1] = v99;
  *(_DWORD *)(a1 + 48) = v96;
  os_unfair_lock_unlock(v101);
}

void sub_1B18D1138(uint64_t a1, int a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  sub_1B18D1198(a1, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B18D1198(uint64_t a1, int a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  _OWORD *v25;
  _DWORD *v26;
  int v27;
  uint64_t v28;
  _DWORD *v29;
  int v30;

  if (a2 == -1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. invalid handle (%d) given"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"hnd != kCFXTransformHandleInvalid");
  v11 = (int *)(*(_QWORD *)(a1 + 24) + 8 * a2);
  v12 = v11[1];
  if (v12 != -1)
  {
    v13 = *v11;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 76));
    *(_BYTE *)(a1 + 68) = 1;
    if (v13 >= *(_DWORD *)(a1 + 64))
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v14, v15, v16, v17, v18, v19, (uint64_t)"handle.level < _levelCount");
    v20 = *(_QWORD *)(a1 + 56);
    v21 = a3[1];
    v22 = a3[2];
    v23 = a3[3];
    v24 = v20 + 80 * v13;
    v25 = (_OWORD *)(*(_QWORD *)(v24 + 16) + ((uint64_t)v12 << 6));
    *v25 = *a3;
    v25[1] = v21;
    v25[2] = v22;
    v25[3] = v23;
    v27 = *(_DWORD *)(v24 + 64);
    v26 = (_DWORD *)(v24 + 64);
    if (v12 < v27)
      *v26 = v12;
    v28 = v20 + 80 * v13;
    v30 = *(_DWORD *)(v28 + 68);
    v29 = (_DWORD *)(v28 + 68);
    if (v12 > v30)
      *v29 = v12;
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 76));
  }
}

void sub_1B18D12BC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int *v11;
  uint64_t v12;
  int v13;

  v8 = a3;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  if (a2 == -1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. invalid handle (%d) given"), a3, a4, a5, a6, a7, a8, (uint64_t)"hnd != kCFXTransformHandleInvalid");
  v11 = (int *)(*(_QWORD *)(a1 + 24) + 8 * a2);
  v12 = v11[1];
  if ((_DWORD)v12 != -1)
  {
    v13 = *v11;
    if (*v11 >= *(_DWORD *)(a1 + 64))
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"handle.level < transformTree->_levelCount");
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * v13 + 56) + 4 * v12) = v8;
  }
}

uint64_t sub_1B18D138C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  int v14;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  if (a2 == -1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. invalid handle (%d) given"), a3, a4, a5, a6, a7, a8, (uint64_t)"hnd != kCFXTransformHandleInvalid");
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * a2);
  if (*(_BYTE *)(a1 + 68))
    sub_1B18D15D8(a1);
  if (HIDWORD(v10) == 0xFFFFFFFF)
    LODWORD(v11) = 0;
  else
    v11 = HIDWORD(v10);
  if (HIDWORD(v10) == 0xFFFFFFFF)
    v12 = 0;
  else
    v12 = -1;
  if (v10 == 0xFFFFFFFFLL)
    LODWORD(v13) = v11;
  else
    v13 = HIDWORD(v10);
  if (v10 == 0xFFFFFFFFLL)
    v14 = v12;
  else
    v14 = v10;
  return *(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * v14) + ((uint64_t)(int)v13 << 6);
}

uint64_t sub_1B18D1450(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  unint64_t v11;
  int v12;
  unint64_t v13;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  if (a2 == -1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. invalid handle (%d) given"), a3, a4, a5, a6, a7, a8, (uint64_t)"hnd != kCFXTransformHandleInvalid");
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * a2);
  v11 = HIDWORD(v10);
  if (HIDWORD(v10) == 0xFFFFFFFF)
    v12 = 0;
  else
    v12 = -1;
  if (HIDWORD(v10) == 0xFFFFFFFF)
    LODWORD(v13) = 0;
  else
    v13 = HIDWORD(v10);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * a2) == 0xFFFFFFFFLL)
  {
    LODWORD(v10) = v12;
    LODWORD(v11) = v13;
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * (int)v10 + 8) + ((uint64_t)(int)v11 << 6);
}

void sub_1B18D1504(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  sub_1B18D15D8(a1);
}

void sub_1B18D154C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  if (*(int *)(a1 + 64) >= 1)
  {
    v9 = 0;
    v10 = 0;
    do
    {
      memcpy(*(void **)(*(_QWORD *)(a1 + 56) + v9 + 8), *(const void **)(*(_QWORD *)(a1 + 56) + v9), (uint64_t)*(int *)(*(_QWORD *)(a1 + 56) + v9 + 72) << 6);
      ++v10;
      v9 += 80;
    }
    while (v10 < *(int *)(a1 + 64));
  }
}

void sub_1B18D15D8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  _DWORD *v30;
  uint64_t v31;
  _DWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  float32x4_t v40;
  int v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int v45;
  float32x4_t *v46;
  uint64_t i;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _DWORD *v59;
  int v60;
  unint64_t v61;
  uint64_t v62;
  _DWORD *v63;
  int v64;
  os_unfair_lock_s *lock;

  lock = (os_unfair_lock_s *)(a1 + 76);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 76));
  *(_BYTE *)(a1 + 68) = 0;
  if (*(_DWORD *)(a1 + 64))
  {
    v9 = sub_1B17C6244(**(_QWORD ***)(*(_QWORD *)(a1 + 56) + 40), v2, v3, v4, v5, v6, v7, v8);
    if (v9)
    {
      v17 = sub_1B187B260(v9, v10, v11, v12, v13, v14, v15, v16);
      v23 = *(_DWORD *)(a1 + 64);
      if (v23 >= 1)
      {
        v24 = v17;
        v25 = 0;
        v26 = *(uint64_t **)(a1 + 56);
        while (1)
        {
          v27 = *(_QWORD *)(a1 + 56);
          v28 = v27 + 80 * v25;
          v30 = (_DWORD *)(v28 + 68);
          v29 = *(_DWORD *)(v28 + 68);
          v32 = (_DWORD *)(v28 + 64);
          v31 = *(int *)(v28 + 64);
          if (v29 >= (int)v31)
            break;
LABEL_23:
          ++v25;
          v26 = (uint64_t *)v28;
          if (v25 >= v23)
            goto LABEL_27;
        }
        if (v25)
        {
          v33 = v27 + 80 * v25;
          v34 = *v26;
          v36 = *(_QWORD *)(v33 + 16);
          v35 = *(_QWORD *)(v33 + 24);
          v37 = v29 + 1;
          v38 = *(_QWORD *)v28 + (v31 << 6);
          v39 = v36 + (v31 << 6);
          v40 = 0uLL;
          v41 = -1;
          v42 = 0uLL;
          v43 = 0uLL;
          v44 = 0uLL;
          do
          {
            v45 = *(_DWORD *)(v35 + 4 * v31);
            if (v41 != v45)
            {
              v46 = (float32x4_t *)(v34 + ((uint64_t)v45 << 6));
              v40 = *v46;
              v42 = v46[1];
              v43 = v46[2];
              v44 = v46[3];
              v41 = *(_DWORD *)(v35 + 4 * v31);
            }
            for (i = 0; i != 64; i += 16)
              *(float32x4_t *)(v38 + i) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v42, *(float32x2_t *)(v39 + i), 1), v40, COERCE_FLOAT(*(_OWORD *)(v39 + i))), v43, *(float32x4_t *)(v39 + i), 2), v44, *(float32x4_t *)(v39 + i), 3);
            ++v31;
            v38 += 64;
            v39 += 64;
          }
          while (v37 != (_DWORD)v31);
          if (!v24)
            goto LABEL_15;
        }
        else
        {
          memcpy((void *)(*(_QWORD *)v28 + (v31 << 6)), (const void *)(*(_QWORD *)(v27 + 16) + (v31 << 6)), (uint64_t)(v29 - (int)v31 + 1) << 6);
          if (!v24)
            goto LABEL_15;
        }
        sub_1B197CF40(v24, (int *)(*(_QWORD *)(v27 + 80 * v25 + 56) + 4 * *v32), *(_QWORD *)v28 + ((unint64_t)*v32 << 6), (*v30 - *v32 + 1), v19, v20, v21, v22);
LABEL_15:
        if (v25 != *(_DWORD *)(a1 + 64) - 1)
        {
          v48 = *(_QWORD *)(a1 + 56);
          v49 = v25 + 1;
          v50 = v25 | ((unint64_t)*v32 << 32);
          v51 = v25 | ((unint64_t)*v30 << 32);
          v52 = sub_1B18D253C(a1, v50, v51, v18, v19, v20, v21, v22);
          if (HIDWORD(v52) != -1)
          {
            v58 = v48 + 80 * v49;
            v60 = *(_DWORD *)(v58 + 64);
            v59 = (_DWORD *)(v58 + 64);
            if (v60 > SHIDWORD(v52))
              *v59 = HIDWORD(v52);
          }
          v61 = sub_1B18D2614(a1, v50, v51, v53, v54, v55, v56, v57);
          if (HIDWORD(v61) != -1)
          {
            v62 = v48 + 80 * v49;
            v64 = *(_DWORD *)(v62 + 68);
            v63 = (_DWORD *)(v62 + 68);
            if (v64 < SHIDWORD(v61))
              *v63 = HIDWORD(v61);
          }
        }
        *(_QWORD *)v32 = 0x800000007FFFFFFFLL;
        v23 = *(_DWORD *)(a1 + 64);
        goto LABEL_23;
      }
    }
  }
LABEL_27:
  os_unfair_lock_unlock(lock);
}

CFStringRef sub_1B18D1830(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXTransformTree %p>"), a1);
}

CFStringRef sub_1B18D186C(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXTransformTree %p>"), a1);
}

uint64_t sub_1B18D18A8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  if (*(int *)(a1 + 64) >= 1)
  {
    v2 = 0;
    v3 = 0;
    do
    {
      sub_1B18D1924((void **)(*(_QWORD *)(a1 + 56) + v2));
      ++v3;
      v2 += 80;
    }
    while (v3 < *(int *)(a1 + 64));
  }
  free(*(void **)(a1 + 56));
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  v4 = *(void **)(a1 + 24);
  if (v4)
  {
    *(_QWORD *)(a1 + 32) = v4;
    operator delete(v4);
  }
  return a1;
}

void sub_1B18D1924(void **a1)
{
  free(*a1);
  free(a1[1]);
  free(a1[2]);
  free(a1[3]);
  free(a1[4]);
  free(a1[5]);
  free(a1[6]);
  free(a1[7]);
}

void sub_1B18D197C(uint64_t a1, int a2)
{
  char *v4;
  char *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _OWORD *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  char *v15;
  _OWORD *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;

  if (*(_DWORD *)(a1 + 64) != a2)
  {
    v4 = (char *)malloc_type_calloc(0x50uLL, a2, 0x6604B0D5uLL);
    v5 = v4;
    v6 = *(_DWORD *)(a1 + 64);
    if (v6 >= a2)
    {
      if (a2 < 1)
      {
        v20 = 0;
      }
      else
      {
        v14 = 0;
        do
        {
          v15 = &v4[v14];
          v16 = (_OWORD *)(*(_QWORD *)(a1 + 56) + v14);
          *(_OWORD *)v15 = *v16;
          v17 = v16[1];
          v18 = v16[2];
          v19 = v16[4];
          *((_OWORD *)v15 + 3) = v16[3];
          *((_OWORD *)v15 + 4) = v19;
          *((_OWORD *)v15 + 1) = v17;
          *((_OWORD *)v15 + 2) = v18;
          v14 += 80;
        }
        while (80 * a2 != v14);
        v6 = *(_DWORD *)(a1 + 64);
        v20 = a2;
      }
      if (v20 < v6)
      {
        v23 = 80 * v20;
        do
        {
          sub_1B18D1924((void **)(*(_QWORD *)(a1 + 56) + v23));
          v23 += 80;
          ++v20;
        }
        while (*(_DWORD *)(a1 + 64) > v20);
      }
    }
    else
    {
      if (v6 < 1)
      {
        LODWORD(v8) = 0;
      }
      else
      {
        v7 = 0;
        v8 = 0;
        do
        {
          v9 = &v4[v7];
          v10 = (_OWORD *)(*(_QWORD *)(a1 + 56) + v7);
          *(_OWORD *)v9 = *v10;
          v11 = v10[1];
          v12 = v10[2];
          v13 = v10[4];
          *((_OWORD *)v9 + 3) = v10[3];
          *((_OWORD *)v9 + 4) = v13;
          *((_OWORD *)v9 + 1) = v11;
          *((_OWORD *)v9 + 2) = v12;
          ++v8;
          v7 += 80;
        }
        while (v8 < *(int *)(a1 + 64));
      }
      if ((int)v8 < a2)
      {
        v21 = (uint64_t)&v4[80 * v8];
        v22 = a2 - (unint64_t)v8;
        do
        {
          sub_1B18D1AF4(v21, 0x80u);
          v21 += 80;
          --v22;
        }
        while (v22);
      }
    }
    free(*(void **)(a1 + 56));
    *(_QWORD *)(a1 + 56) = v5;
    *(_DWORD *)(a1 + 64) = a2;
  }
}

double sub_1B18D1AF4(uint64_t a1, unsigned int a2)
{
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  char *v8;
  size_t v9;
  void *v10;
  char *v11;
  void *v12;
  char *v13;
  int v14;
  uint64_t v15;
  void *v16;
  char *v17;
  int v18;
  void *v19;
  char *v20;
  uint64_t v21;
  void *v22;
  char *v23;
  size_t v24;
  void *v25;
  char *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  size_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  double result;
  void *memptr;

  v4 = (unint64_t)a2 << 6;
  v5 = *(int *)(a1 + 76);
  v6 = v5 << 6;
  v7 = *(void **)a1;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL))
    v8 = 0;
  else
    v8 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v8, v7, v5 << 6);
  v9 = (v4 - v6);
  if ((int)v9 >= 1)
    bzero(&v8[v6], (v4 - v6));
  if (v7)
    free(v7);
  *(_QWORD *)a1 = v8;
  v10 = *(void **)(a1 + 8);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL))
    v11 = 0;
  else
    v11 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v11, v10, v5 << 6);
  if ((int)v9 >= 1)
    bzero(&v11[v6], (v4 - v6));
  if (v10)
    free(v10);
  *(_QWORD *)(a1 + 8) = v11;
  v12 = *(void **)(a1 + 16);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL))
    v13 = 0;
  else
    v13 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v13, v12, v5 << 6);
  v14 = 4 * a2;
  if ((int)v9 >= 1)
    bzero(&v13[v6], v9);
  v15 = 4 * v5;
  if (v12)
    free(v12);
  *(_QWORD *)(a1 + 16) = v13;
  v16 = *(void **)(a1 + 24);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL))
    v17 = 0;
  else
    v17 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v17, v16, 4 * v5);
  v18 = v14 - v15;
  if (v14 - (int)v15 >= 1)
    bzero(&v17[v15], (v14 - v15));
  if (v16)
    free(v16);
  *(_QWORD *)(a1 + 24) = v17;
  v19 = *(void **)(a1 + 32);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL))
    v20 = 0;
  else
    v20 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v20, v19, 4 * v5);
  if (v18 >= 1)
    bzero(&v20[v15], (v14 - v15));
  v21 = 8 * v5;
  if (v19)
    free(v19);
  *(_QWORD *)(a1 + 32) = v20;
  v22 = *(void **)(a1 + 40);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 8 * a2, 0xBA8A1232uLL))
    v23 = 0;
  else
    v23 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v23, v22, 8 * v5);
  v24 = 8 * a2 - v21;
  if ((int)v24 >= 1)
    bzero(&v23[v21], v24);
  if (v22)
    free(v22);
  *(_QWORD *)(a1 + 40) = v23;
  v25 = *(void **)(a1 + 48);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL))
    v26 = 0;
  else
    v26 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v26, v25, 4 * v5);
  if (v18 >= 1)
    bzero(&v26[v15], (v14 - v15));
  if (v25)
    free(v25);
  *(_QWORD *)(a1 + 48) = v26;
  v27 = *(void **)(a1 + 56);
  v28 = *(int *)(a1 + 76);
  v29 = 4 * v28;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL))
    v30 = 0;
  else
    v30 = (char *)memptr;
  if ((_DWORD)v28)
    memcpy(v30, v27, 4 * v28);
  v31 = (v14 - v29);
  if ((int)v31 >= 1)
    bzero(&v30[v29], v31);
  if (v27)
    free(v27);
  *(_QWORD *)(a1 + 56) = v30;
  if ((int)v24 >= 1)
    bzero((void *)(*(_QWORD *)(a1 + 40) + v21), v24);
  v32 = a2 - 1;
  v33 = *(unsigned int *)(a1 + 76);
  v34 = *(_QWORD *)(a1 + 24);
  if (v33 < v32)
  {
    do
    {
      *(_DWORD *)(v34 + 4 * v33) = v33 + 1;
      ++v33;
    }
    while (v32 != v33);
  }
  *(_DWORD *)(v34 + 4 * v32) = -1;
  *(_QWORD *)&result = 0x800000007FFFFFFFLL;
  *(_QWORD *)(a1 + 64) = 0x800000007FFFFFFFLL;
  *(_DWORD *)(a1 + 76) = a2;
  return result;
}

void sub_1B18D1EE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  int v30;
  int v31;
  uint64_t v32;
  _DWORD *v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;

  v10 = a2;
  v12 = HIDWORD(a2);
  v13 = *(_QWORD *)(a1 + 56);
  v14 = a2;
  v15 = v13 + 80 * (int)a2;
  v16 = *(int *)(v15 + 72);
  if ((int)v16 > SHIDWORD(a2))
  {
    v17 = *(_QWORD *)(a1 + 24);
    v18 = (int *)(*(_QWORD *)(v13 + 80 * (int)a2 + 48) + 4 * (a2 >> 32));
    v19 = v16 - (a2 >> 32);
    do
    {
      v20 = *v18++;
      v21 = v17 + 8 * v20;
      LODWORD(v20) = *(_DWORD *)(v21 + 4);
      v22 = (_DWORD *)(v21 + 4);
      v23 = v20;
      if ((int)v20 >= SHIDWORD(a2))
        *v22 = v23 + a4;
      --v19;
    }
    while (v19);
  }
  sub_1B18D2340(v15, SHIDWORD(a2), a4, a4, a5, a6, a7, a8);
  v28 = v13 + 80 * v14;
  v31 = *(_DWORD *)(v28 + 68);
  v29 = (_DWORD *)(v28 + 68);
  v30 = v31;
  if (v31 >= (int)v12)
  {
    v32 = v13 + 80 * v14;
    v35 = *(_DWORD *)(v32 + 64);
    v33 = (_DWORD *)(v32 + 64);
    v34 = v35;
    if (v35 > (int)v12)
      *v33 = v34 + a4;
    *v29 = v30 + a4;
  }
  if ((_DWORD)a3 != -1)
    sub_1B18D24A4(*(_QWORD *)(a1 + 56) + 80 * (int)a3, SHIDWORD(a3), v12, a4, v24, v25, v26, v27);
  v36 = v10 + 1;
  if ((int)v36 < *(_DWORD *)(a1 + 64))
  {
    v37 = v12;
    while ((int)v37 >= 2)
    {
      v38 = *(_QWORD *)(v13 + 80 * v14 + 32) + 4 * v37--;
      LODWORD(v38) = *(_DWORD *)(v38 - 4);
      if ((_DWORD)v38 != -1)
        goto LABEL_18;
    }
    LODWORD(v38) = 0;
LABEL_18:
    v39 = *(_QWORD *)(a1 + 56);
    v40 = v39 + 80 * v36;
    v43 = *(_DWORD *)(v40 + 72);
    v41 = (int *)(v40 + 72);
    v42 = v43;
    if ((int)v38 < v43)
    {
      v44 = *(_QWORD *)(v39 + 80 * v36 + 24);
      v38 = (int)v38;
      do
      {
        v45 = *(_DWORD *)(v44 + 4 * v38);
        if (v45 >= (int)v12)
        {
          *(_DWORD *)(v44 + 4 * v38) = v45 + a4;
          v42 = *v41;
        }
        ++v38;
      }
      while (v38 < v42);
    }
  }
}

__n128 sub_1B18D2084(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  __int128 *v7;
  _OWORD *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float32x4_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __n128 result;
  __int128 v22;
  __int128 v23;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = a2;
  v4 = (_QWORD *)(v2 + 80 * (int)a2);
  v5 = a2 >> 32;
  v6 = a2 - 1;
  if ((_DWORD)a2 == 0x100000000)
  {
    v7 = (__int128 *)(*(_QWORD *)(v2 + 80 * (int)a2 + 16) + (v5 << 6));
    v8 = (_OWORD *)(*v4 + (v5 << 6));
    v9 = *v7;
    v10 = v7[1];
    v11 = v7[3];
    v8[2] = v7[2];
    v8[3] = v11;
    *v8 = v9;
    v8[1] = v10;
  }
  else
  {
    v13 = v2 + 80 * (int)a2;
    v14 = *(int *)(*(_QWORD *)(v13 + 24) + 4 * v5);
    sub_1B18D2084();
    v15 = 0;
    v16 = (float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * v6) + (v14 << 6));
    v17 = *v4 + (v5 << 6);
    v18 = *(_QWORD *)(v13 + 16) + (v5 << 6);
    do
    {
      *(float32x4_t *)(v17 + v15) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v16[1], *(float32x2_t *)(v18 + v15), 1), *v16, COERCE_FLOAT(*(_OWORD *)(v18 + v15))), v16[2], *(float32x4_t *)(v18 + v15), 2), v16[3], *(float32x4_t *)(v18 + v15), 3);
      v15 += 16;
    }
    while (v15 != 64);
  }
  v19 = *v4 + (v5 << 6);
  v20 = *(_QWORD *)(v2 + 80 * v3 + 8) + (v5 << 6);
  result = *(__n128 *)v19;
  v22 = *(_OWORD *)(v19 + 16);
  v23 = *(_OWORD *)(v19 + 48);
  *(_OWORD *)(v20 + 32) = *(_OWORD *)(v19 + 32);
  *(_OWORD *)(v20 + 48) = v23;
  *(__n128 *)v20 = result;
  *(_OWORD *)(v20 + 16) = v22;
  return result;
}

uint64_t sub_1B18D21A0(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  result = *(unsigned int *)(a1 + 48);
  if ((_DWORD)result == -1)
  {
    v6 = *(_QWORD *)(a1 + 40);
    v7 = *(_QWORD **)(a1 + 32);
    if ((unint64_t)v7 >= v6)
    {
      v9 = *(_QWORD *)(a1 + 24);
      v10 = ((uint64_t)v7 - v9) >> 3;
      if ((unint64_t)(v10 + 1) >> 61)
        abort();
      v11 = v6 - v9;
      v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1))
        v12 = v10 + 1;
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
        v14 = (char *)sub_1B17F812C(a1 + 40, v13);
      else
        v14 = 0;
      v15 = &v14[8 * v10];
      v16 = &v14[8 * v13];
      *(_QWORD *)v15 = a2;
      v8 = v15 + 8;
      v18 = *(char **)(a1 + 24);
      v17 = *(char **)(a1 + 32);
      if (v17 != v18)
      {
        do
        {
          v19 = *((_QWORD *)v17 - 1);
          v17 -= 8;
          *((_QWORD *)v15 - 1) = v19;
          v15 -= 8;
        }
        while (v17 != v18);
        v17 = *(char **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v15;
      *(_QWORD *)(a1 + 32) = v8;
      *(_QWORD *)(a1 + 40) = v16;
      if (v17)
        operator delete(v17);
    }
    else
    {
      *v7 = a2;
      v8 = v7 + 1;
    }
    *(_QWORD *)(a1 + 32) = v8;
    return (((unint64_t)v8 - *(_QWORD *)(a1 + 24)) >> 3) - 1;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 24) + 8 * (int)result;
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(v5 + 4);
    *(_QWORD *)v5 = a2;
  }
  return result;
}

void sub_1B18D22AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v10;
  uint64_t v12;
  uint64_t v13;

  v8 = a4;
  v10 = HIDWORD(a2);
  if ((_DWORD)a3 + 1 != (_DWORD)a2)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. child must be one level under parent"), a3, a4, a5, a6, a7, a8, (uint64_t)"newHandle.level == (parentHandle.level + 1)");
  if ((_DWORD)a3 != -1)
  {
    v12 = *(_QWORD *)(a1 + 56);
    if (v12)
    {
      v13 = *(_QWORD *)(v12 + 80 * (int)a3 + 32);
      if (*(_DWORD *)(v13 + 4 * (a3 >> 32)) == v8)
        *(_DWORD *)(v13 + 4 * (a3 >> 32)) = v10;
    }
  }
}

void sub_1B18D2340(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unsigned int v9;
  int v10;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;

  v8 = *(_DWORD *)(a1 + 72);
  v9 = v8 - a2;
  if (v8 - a2 < 0)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. can't move negative number of data"), a3, a4, a5, a6, a7, a8, (uint64_t)"countToMove >= 0");
  }
  else if (v8 != a2)
  {
    v10 = a3;
    if (v8 + (int)a3 > *(_DWORD *)(a1 + 76))
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. overflow !"), a3, a4, a5, a6, a7, a8, (uint64_t)"(handle + offset + countToMove) <= _capacity");
    v13 = (char *)(*(_QWORD *)(a1 + 24) + 4 * a2);
    memmove(&v13[4 * v10], v13, 4 * v9);
    v14 = (char *)(*(_QWORD *)(a1 + 32) + 4 * a2);
    memmove(&v14[4 * v10], v14, 4 * v9);
    v15 = (char *)(*(_QWORD *)(a1 + 40) + 8 * a2);
    memmove(&v15[8 * v10], v15, 8 * v9);
    v16 = (char *)(*(_QWORD *)(a1 + 48) + 4 * a2);
    memmove(&v16[4 * v10], v16, 4 * v9);
    v17 = (char *)(*(_QWORD *)(a1 + 56) + 4 * a2);
    memmove(&v17[4 * v10], v17, 4 * v9);
    memmove((void *)(*(_QWORD *)a1 + ((uint64_t)a2 << 6) + ((uint64_t)v10 << 6)), (const void *)(*(_QWORD *)a1 + ((uint64_t)a2 << 6)), (unint64_t)v9 << 6);
    v18 = (char *)(*(_QWORD *)(a1 + 8) + ((uint64_t)a2 << 6));
    memmove(&v18[64 * (uint64_t)v10], v18, (unint64_t)v9 << 6);
    v19 = (char *)(*(_QWORD *)(a1 + 16) + ((uint64_t)a2 << 6));
    memmove(&v19[64 * (uint64_t)v10], v19, (unint64_t)v9 << 6);
  }
}

void sub_1B18D24A4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v8 = a4;
  v9 = a3;
  v12 = *(_DWORD *)(a1 + 72);
  if (v12 <= a2)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"startParentHandle < _count");
    v12 = *(_DWORD *)(a1 + 72);
  }
  if (v12 > a2)
  {
    v13 = *(_QWORD *)(a1 + 32);
    v14 = a2;
    do
    {
      v15 = *(_DWORD *)(v13 + 4 * v14);
      if (v15 >= v9)
      {
        *(_DWORD *)(v13 + 4 * v14) = v15 + v8;
        v12 = *(_DWORD *)(a1 + 72);
      }
      ++v14;
    }
    while (v14 < v12);
  }
}

unint64_t sub_1B18D253C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int *v13;
  int v14;
  uint64_t v15;
  unsigned int v16;

  v10 = HIDWORD(a2);
  v11 = HIDWORD(a3);
  if ((_DWORD)a2 != (_DWORD)a3)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"firstHandle.level == lastHandle.level");
  if ((int)v10 > (int)v11)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"firstHandle.index <= lastHandle.index");
LABEL_9:
    v12 = -1;
    v15 = 0xFFFFFFFFLL;
    return v12 | (unint64_t)(v15 << 32);
  }
  v12 = a2 + 1;
  if ((_DWORD)a2 + 1 == *(_DWORD *)(a1 + 64))
    goto LABEL_9;
  v13 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * (int)a2 + 32) + 4 * (a2 >> 32));
  v14 = v11 - HIDWORD(a2) + 1;
  while (1)
  {
    v16 = *v13++;
    v15 = v16;
    if (v16 != -1)
      return v12 | (unint64_t)(v15 << 32);
    if (!--v14)
      goto LABEL_9;
  }
}

unint64_t sub_1B18D2614(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  unint64_t v18;
  unint64_t v19;
  int v20;

  v11 = HIDWORD(a2);
  v12 = HIDWORD(a3);
  if ((_DWORD)a2 != (_DWORD)a3)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"firstHandle.level == lastHandle.level");
  if ((int)v11 > (int)v12)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"firstHandle.index <= lastHandle.index");
LABEL_6:
    v13 = 0xFFFFFFFFLL;
    LODWORD(v14) = -1;
    return v14 | (unint64_t)(v13 << 32);
  }
  if ((_DWORD)a2 + 1 == *(_DWORD *)(a1 + 64))
    goto LABEL_6;
  v14 = (a3 + 1);
  v16 = a3 >> 32;
  while (1)
  {
    v13 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * (int)a2 + 32) + 4 * v16);
    if ((_DWORD)v13 != -1)
      break;
    if (v16-- <= a2 >> 32)
    {
      v13 = 0xFFFFFFFFLL;
      LODWORD(v14) = -1;
      return v14 | (unint64_t)(v13 << 32);
    }
  }
  v18 = sub_1B18D274C(a1, v14 | (v13 << 32));
  v19 = HIDWORD(v18);
  if (HIDWORD(v18) != -1)
  {
    do
    {
      v20 = v18;
      v13 = v19;
      v18 = sub_1B18D274C(a1, v18);
      v19 = HIDWORD(v18);
    }
    while (HIDWORD(v18) != -1);
    LODWORD(v14) = v20;
  }
  return v14 | (unint64_t)(v13 << 32);
}

unint64_t sub_1B18D274C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = HIDWORD(a2) + 1;
  if (HIDWORD(a2) + 1 < *(_DWORD *)(v2 + 80 * (int)a2 + 72)
    && (v4 = *(_QWORD *)(v2 + 80 * (int)a2 + 24), *(_DWORD *)(v4 + 4 * v3) == *(_DWORD *)(v4 + 4 * (a2 >> 32))))
  {
    return a2 | ((unint64_t)v3 << 32);
  }
  else
  {
    return -1;
  }
}

void sub_1B18D27A4()
{
  void *v0;
  const void *v1;

  if (!qword_1EEF66130)
  {
    v0 = (void *)sub_1B179CB60(&qword_1EEF66130);
    qword_1EEF66130 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C3258();
  }
}

uint64_t sub_1B18D2804(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;

  if (qword_1EEF66138 != -1)
    dispatch_once(&qword_1EEF66138, &unk_1E63D0FB0);
  v2 = sub_1B179CB90(qword_1EEF66130, 0x10uLL);
  v3 = *(void **)(a1 + 16);
  *(_QWORD *)(v2 + 16) = v3;
  *(_QWORD *)(v2 + 24) = (id)objc_msgSend_makeDefaultCamera(v3, v4, v5, v6);
  return v2;
}

void sub_1B18D287C()
{
  void *v0;
  const void *v1;

  if (!qword_1EEF66140)
  {
    v0 = (void *)sub_1B179CB60(&qword_1EEF66140);
    qword_1EEF66140 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C3258();
  }
}

uint64_t sub_1B18D28DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BOOL8 v16;
  void *v17;
  const char *v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  id v55;
  void *v56;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  const char *v60;
  uint64_t v61;
  _TtC3VFX8VFXScene *v62;
  const char *v63;
  uint64_t v64;

  if (!sub_1B187B004(a1, 1, a3, a4, a5, a6, a7, a8))
    return 0;
  if (qword_1EEF66148 != -1)
    dispatch_once(&qword_1EEF66148, &unk_1E63D8A40);
  v9 = sub_1B179CB90(qword_1EEF66140, 8uLL);
  v16 = sub_1B187B004(a1, 2, v10, v11, v12, v13, v14, v15);
  v17 = (void *)objc_opt_new();
  objc_msgSend_setWorld_(v17, v18, a1, v19);
  objc_msgSend_setIsVFX2_(v17, v20, 1, v21);
  objc_msgSend_setSetupRenderer_(v17, v22, 1, v23);
  objc_msgSend_setIsAuthoringWorld_(v17, v24, v16, v25);
  objc_msgSend_setAutomaticallyPrepareScene_(v17, v26, 0, v27);
  objc_msgSend_setEnableRuntimeScriptCompilation_(v17, v28, v16, v29);
  v37 = sub_1B187AA68(a1, v30, v31, v32, v33, v34, v35, v36);
  objc_msgSend_setMetalLibraryURL_(v17, v38, v37, v39);
  objc_msgSend_setSetupAsyncRuntime_(v17, v40, 0, v41);
  v42 = sub_1B187ADB8(a1);
  objc_msgSend_setAsyncRuntimeLock_(v17, v43, v42, v44);
  v52 = sub_1B187C160(a1, v45, v46, v47, v48, v49, v50, v51);
  objc_msgSend_setCounterStorage_(v17, v53, v52, v54);
  v55 = MTLCreateSystemDefaultDevice();
  v56 = sub_1B18F8C8C((uint64_t)VFXMTLResourceManager, (uint64_t)v55);
  v57 = sub_1B18FD780((uint64_t)v56);
  objc_msgSend_setCommandQueue_(v17, v58, v57, v59);
  objc_msgSend_registerVFX2AuthoringSystems_(v17, v60, v16, v61);
  v62 = [_TtC3VFX8VFXScene alloc];
  *(_QWORD *)(v9 + 16) = objc_msgSend_initWithOptions_(v62, v63, (uint64_t)v17, v64);

  return v9;
}

uint64_t sub_1B18D2A54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _BOOL8 v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  _TtC3VFX8VFXScene *v40;
  const char *v41;
  uint64_t v42;

  if (!sub_1B187B004(a1, 1, a3, a4, a5, a6, a7, a8))
    return 0;
  if (qword_1EEF66148 != -1)
    dispatch_once(&qword_1EEF66148, &unk_1E63D8A40);
  v9 = sub_1B179CB90(qword_1EEF66140, 8uLL);
  v10 = (void *)objc_opt_new();
  objc_msgSend_setWorld_(v10, v11, a1, v12);
  objc_msgSend_setIsVFX2_(v10, v13, 1, v14);
  objc_msgSend_setSetupRenderer_(v10, v15, 0, v16);
  v23 = sub_1B187B004(a1, 2, v17, v18, v19, v20, v21, v22);
  objc_msgSend_setIsAuthoringWorld_(v10, v24, v23, v25);
  objc_msgSend_setAutomaticallyPrepareScene_(v10, v26, 0, v27);
  v35 = sub_1B187AA68(a1, v28, v29, v30, v31, v32, v33, v34);
  objc_msgSend_setMetalLibraryURL_(v10, v36, v35, v37);
  objc_msgSend_setSetupAsyncRuntime_(v10, v38, 0, v39);
  v40 = [_TtC3VFX8VFXScene alloc];
  *(_QWORD *)(v9 + 16) = objc_msgSend_initWithOptions_(v40, v41, (uint64_t)v10, v42);

  return v9;
}

uint64_t sub_1B18D2B5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 16), sel_setSourceReplicationDelegate_, a2, a4);
}

uint64_t sub_1B18D2B68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 16), sel_setDestinationReplicationDelegate_, a2, a4);
}

uint64_t sub_1B18D2B74(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = objc_msgSend_opaqueEntityManager(*(void **)(a1 + 16), a2, a3, a4);
  return sub_1B1DABFA0(v5, a2);
}

uint64_t sub_1B18D2B9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 16), sel_selectObject_selected_, a2, a3);
}

uint64_t sub_1B18D2BAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 16), sel_buildAccelerationStructureDescriptorsWithEntity_, a2, a4);
}

uint64_t sub_1B18D2BB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 16), sel_invalidateCachedScriptParams, a3, a4);
}

uint64_t sub_1B18D2BC0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_setWorld_(*(void **)(a1 + 16), a2, (uint64_t)a2, a4);
}

uint64_t sub_1B18D2BCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;

  v10 = (void *)sub_1B1813BC4(a2, a2, a3, a4, a5, a6, a7, a8);
  v14 = (void *)objc_msgSend_renderTargetInfo(v10, v11, v12, v13);
  v17 = objc_msgSend_colorPixelFormatAtIndex_(v14, v15, 0, v16);
  objc_msgSend_depthStencilPixelFormat(v14, v18, v19, v20);
  objc_msgSend_sampleCount(v14, v21, v22, v23);
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 16), sel_encodeAuthoringWithEncoder_colorFormat_depthStencilFormat_sampleCount_, a3, v17);
}

uint64_t sub_1B18D2C40(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;

  result = sub_1B187A9C4(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v12 = result;
    result = (uint64_t)sub_1B1879C64(a1, a2);
    if (result)
      return MEMORY[0x1E0DE7D20](v12, sel_setDirectionalLightUniformOverridesOn_world_proj_, result, a3);
  }
  return result;
}

uint64_t sub_1B18D2CB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 16), sel_setDebugUIOptions_, a2, a4);
}

void sub_1B18D2CC4(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const __CFDictionary *v40;
  const __CFArray *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const __CFArray *v49;
  const __CFArray *Copy;
  void *v51;
  const void *v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  __int128 *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  const char *v73;
  uint64_t v74;
  uint64_t v75;
  double *v76;
  const char *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  const char *v81;
  uint64_t v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  void *context;
  CFRange v92;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"vfxRenderContext");
  v15 = sub_1B1813884((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v15)
  {
    v23 = (void *)v15;
    v24 = *(void **)(a1 + 16);
    v25 = (void *)sub_1B1813BC4((uint64_t)a2, v16, v17, v18, v19, v20, v21, v22);
    v26 = *(void **)(a1 + 16);
    v27 = *(_QWORD *)(a1 + 24);
    v31 = objc_msgSend_currentCommandBuffer(v25, v28, v29, v30);
    objc_msgSend_updateVFX2RenderOutputWithPointOfView_commandBuffer_(v26, v32, v27, v31);
    v40 = (const __CFDictionary *)sub_1B1879B7C((uint64_t)v23, v33, v34, v35, v36, v37, v38, v39);
    if (v40)
      CFDictionaryApplyFunction(v40, (CFDictionaryApplierFunction)sub_1B18D347C, v23);
    v41 = (const __CFArray *)sub_1B1879CA0((uint64_t)v23);
    if (v41)
    {
      v49 = v41;
      if (CFArrayGetCount(v41))
      {
        context = v23;
        Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v49);
        sub_1B1879CA8((uint64_t)v23);
        v92.length = CFArrayGetCount(Copy);
        v92.location = 0;
        CFArrayApplyFunction(Copy, v92, (CFArrayApplierFunction)sub_1B18D357C, &context);
        CFRelease(Copy);
      }
    }
    v51 = *(void **)(a1 + 24);
    v52 = sub_1B1814768(a2, v42, v43, v44, v45, v46, v47, v48);
    if (v52)
    {
      v60 = (uint64_t)v52;
      v61 = (__int128 *)sub_1B1869AC8((uint64_t)v52, (uint64_t)v53, v54, v55, v56, v57, v58, v59);
      v90 = v61[3];
      v88 = v61[2];
      v86 = v61[1];
      v84 = *v61;
      v69 = (__int128 *)sub_1B186B928(v60, v62, v63, v64, v65, v66, v67, v68);
      v89 = v69[3];
      v87 = v69[2];
      v85 = v69[1];
      v83 = *v69;
      objc_msgSend_setWorldTransform_(v51, v70, v71, v72, *(double *)&v84, *(double *)&v86, *(double *)&v88, *(double *)&v90);
      objc_msgSend_setLastFrameWorldTransform_(v51, v73, v74, v75, *(double *)&v83, *(double *)&v85, *(double *)&v87, *(double *)&v89);
      v76 = (double *)sub_1B1815A5C((uint64_t)a2, 0);
      objc_msgSend_setProjection_(v51, v77, v78, v79, *v76, v76[2], v76[4], v76[6]);
    }
    v80 = objc_msgSend_currentFrameIndex(v25, v53, v54, v55);
    objc_msgSend_updateAtTime_deltaTime_frameIndex_(v24, v81, v80, v82, a9, a10);
  }
  else
  {
    sub_1B17C4408(0, (uint64_t)CFSTR("Warning: CFXVFXSimulateAndPrepareDrawCalls -> no world yet"), v17, v18, v19, v20, v21, v22, a11);
  }
}

void sub_1B18D2EE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const __CFDictionary *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  _QWORD v37[8];
  _QWORD v38[3];
  int v39;

  v10 = sub_1B1813884(a1, a2, a3, a4, a5, a6, a7, a8);
  v18 = *(void **)(sub_1B187AA20(v10, v11, v12, v13, v14, v15, v16, v17) + 16);
  v26 = sub_1B1869D88(*(_QWORD *)(a2 + 8), v19, v20, v21, v22, v23, v24, v25);
  v34 = sub_1B18F4950((uint64_t)v26, v27, v28, v29, v30, v31, v32, v33);
  prof_beginFlame((uint64_t)"CFXVFXUpdateRendererElement", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/CFXVFX/CFXVFXRenderContext.m", 433);
  v38[0] = 0;
  v38[1] = v38;
  v38[2] = 0x2020000000;
  v39 = 0;
  v37[0] = MEMORY[0x1E0C809B0];
  v37[1] = 3221225472;
  v37[2] = sub_1B18D2FD4;
  v37[3] = &unk_1E63D8A68;
  v37[4] = v34;
  v37[5] = v38;
  v37[6] = a3;
  v37[7] = a2;
  objc_msgSend_enumerateDrawCall_(v18, v35, (uint64_t)v37, v36);
  _Block_object_dispose(v38, 8);
  prof_endFlame();
}

void sub_1B18D2FAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  prof_endFlame();
  _Unwind_Resume(a1);
}

id sub_1B18D2FD4(_QWORD *a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  id result;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  int v16;
  uint64_t v17;
  float32x4_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  float32x4_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  float32x4_t *v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  float32x4_t v47;
  float32x4_t *v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  float32x4_t v68;
  float32x4_t v69;
  _OWORD v70[2];

  v6 = (void *)a1[4];
  v7 = objc_msgSend_emitterIdentifier(a2, (const char *)a2, a3, a4);
  result = (id)objc_msgSend_isEqualToString_(v6, v8, v7, v9);
  if ((_DWORD)result)
  {
    v14 = *(_QWORD *)(a1[5] + 8);
    v17 = *(int *)(v14 + 24);
    v15 = (_DWORD *)(v14 + 24);
    v16 = v17;
    if (a1[6] == v17)
    {
      objc_msgSend_boundingBoxMin(a2, v11, v12, v13);
      v69 = v18;
      objc_msgSend_boundingBoxMax(a2, v19, v20, v21);
      v68 = v22;
      *(_WORD *)(a1[7] + 80) = *(_WORD *)(a1[7] + 80) & 0xFFF7 | (8
                                                                    * (objc_msgSend_materialType(a2, v23, v24, v25) == 0));
      *(_WORD *)(a1[7] + 80) = *(_WORD *)(a1[7] + 80) & 0xFFF8 | 4;
      v26 = (float32x4_t *)a1[7];
      v28 = v68;
      v27 = v69;
      v27.i32[3] = 1.0;
      v28.i32[3] = 1.0;
      v29 = vaddq_f32(v27, v28);
      v30 = v28;
      v31 = v27;
      v27.i64[0] = 0x3F0000003F000000;
      v27.i64[1] = 0x3F0000003F000000;
      v26[1] = vmulq_f32(v29, v27);
      v26[2] = vmulq_f32(vsubq_f32(v30, v31), v27);
      *(_DWORD *)(a1[7] + 72) = objc_msgSend_renderingOrder(a2, v32, v33, v34);
      if (objc_msgSend_isAdditive(a2, v35, v36, v37))
        v45 = 0x8000;
      else
        v45 = 0;
      *(_WORD *)(a1[7] + 80) = v45 & 0x8000 | *(_WORD *)(a1[7] + 80) & 0x7FFF;
      v46 = *(_QWORD *)(a1[7] + 8);
      if (v46)
      {
        *(double *)v47.i64 = sub_1B186B90C(v46, (uint64_t)v38, v39, v40, v41, v42, v43, v44);
        v48 = (float32x4_t *)a1[7];
        v52 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v50, v49, v48[1], 2), v51, *(float32x2_t *)v48[1].f32, 1), v47, COERCE_FLOAT(*(_OWORD *)&v48[1]));
        v52.i32[3] = HIDWORD(*(_OWORD *)&v48[1]);
        v53 = v48[2];
        v53.i32[1] = v53.i32[0];
        v53.i32[2] = (__int32)v48[2];
        v54 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v48[2].f32, 1), (int32x4_t)v48[2]), vabsq_f32(v51)), v53, vabsq_f32(v47)), (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v48[2], (int32x4_t)v48[2]), (int32x4_t)v48[2]), vabsq_f32(v49));
        v70[0] = v52;
        v70[1] = v54;
        sub_1B18693DC(v48->i64[1], v70, 0, v55, v56, v57, v58, v59);
        sub_1B186945C(*(_QWORD *)(a1[7] + 8), (__n128 *)(a1[7] + 16), v60, v61, v62, v63, v64, v65);
      }
      result = (id)objc_msgSend_customHandler(a2, v38, v39, v40);
      *(_QWORD *)(a1[7] + 48) = result;
      v66 = *(_QWORD *)(a1[5] + 8);
      v67 = *(_DWORD *)(v66 + 24);
      v15 = (_DWORD *)(v66 + 24);
      v16 = v67;
    }
    *v15 = v16 + 1;
  }
  return result;
}

uint64_t sub_1B18D3194(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Completion;
  const char *v11;
  uint64_t v12;
  _QWORD v14[5];

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"vfxRenderContext");
  Completion = objc_msgSend_recycleBuffersGetCompletion(*(void **)(a1 + 16), a2, a3, a4);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3221225472;
  v14[2] = sub_1B18D3220;
  v14[3] = &unk_1E63D8A90;
  v14[4] = Completion;
  return objc_msgSend_addCompletedHandler_(a2, v11, (uint64_t)v14, v12);
}

uint64_t sub_1B18D3220(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_1B18D322C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v16[6];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"emitter");
    if (a2)
      goto LABEL_3;
LABEL_5:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"coreEM");
    goto LABEL_3;
  }
  if (!a2)
    goto LABEL_5;
LABEL_3:
  v10 = *(void **)(a2 + 16);
  v17 = 0;
  v18 = &v17;
  v19 = 0x2020000000;
  v20 = 0;
  v11 = sub_1B18F4950(a1, a2, a3, a4, a5, a6, a7, a8);
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3221225472;
  v16[2] = sub_1B18D3334;
  v16[3] = &unk_1E63D8AB8;
  v16[4] = v11;
  v16[5] = &v17;
  objc_msgSend_enumerateDrawCall_(v10, v12, (uint64_t)v16, v13);
  v14 = *((unsigned int *)v18 + 6);
  _Block_object_dispose(&v17, 8);
  return v14;
}

void sub_1B18D331C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18D3334(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t result;

  v5 = *(void **)(a1 + 32);
  v6 = objc_msgSend_emitterIdentifier(a2, (const char *)a2, a3, a4);
  result = objc_msgSend_isEqualToString_(v5, v7, v6, v8);
  if ((_DWORD)result)
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t sub_1B18D3380(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 16), sel_setAdditiveWritesToAlpha_, a2, a4);
}

void sub_1B18D3390(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

CFStringRef sub_1B18D33CC(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXVFXRenderContext>"));
}

CFStringRef sub_1B18D33EC(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXVFXRenderContext>"));
}

void sub_1B18D3410(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

CFStringRef sub_1B18D343C(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXCoreEntityManager>"));
}

CFStringRef sub_1B18D345C(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXCoreEntityManager>"));
}

void sub_1B18D347C(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  float32x4_t *v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float v33;
  float v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  double v41;

  prof_beginFlame((uint64_t)"_updateVFXCoreFromNodes", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/CFXVFX/CFXVFXRenderContext.m", 243);
  v17 = (void *)sub_1B18F4794(a2, 1, v4, v5, v6, v7, v8, v9);
  if (v17)
  {
    v18 = (float32x4_t *)sub_1B1869AC8(a1, v10, v11, v12, v13, v14, v15, v16);
    objc_msgSend_transform(v17, v19, v20, v21);
    if ((vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(v30, v18[1]), (int8x16_t)vceqq_f32(v29, *v18)), vandq_s8((int8x16_t)vceqq_f32(v31, v18[2]), (int8x16_t)vceqq_f32(v32, v18[3])))) & 0x80000000) == 0)objc_msgSend_setTransform_(v17, v22, v23, v24);
    sub_1B186C4A8(a1, (uint64_t)v22, v23, v24, v25, v26, v27, v28);
    v34 = v33;
    objc_msgSend_opacity(v17, v35, v36, v37);
    if (*(float *)&v41 != v34)
    {
      *(float *)&v41 = v34;
      objc_msgSend_setOpacity_(v17, v38, v39, v40, v41);
    }
  }
  prof_endFlame();
}

void sub_1B18D355C(_Unwind_Exception *a1)
{
  prof_endFlame();
  _Unwind_Resume(a1);
}

void sub_1B18D357C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  int v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t SkyboxWithParameters;
  const __CFDictionary *v20;
  const char *v21;
  const __CFDictionary *v22;
  const __CFDictionary *v23;
  const char *v24;
  uint64_t v25;

  v9 = *a2;
  v10 = (void *)sub_1B187A9C4(*a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    v14 = v10;
    v15 = *(_DWORD *)(a1 + 24);
    switch(v15)
    {
      case 3:
        v20 = sub_1B1879C64(v9, *(const void **)(a1 + 16));
        if (v20)
        {
          v22 = v20;
          objc_msgSend_setLightParametersOn_parameters_(v14, v21, (uint64_t)v20, *(_QWORD *)(a1 + 40));
          MEMORY[0x1E0DE7D20](v14, sel_setShadowParametersOn_castsShadows_tiles_count_depthBias_, v22, *(unsigned __int8 *)(a1 + 48));
        }
        break;
      case 2:
        if (*(_QWORD *)(a1 + 32) == 5)
        {
          objc_msgSend_removeSkyboxes(v10, v11, v12, v13);
        }
        else
        {
          v23 = sub_1B1879C64(v9, *(const void **)(a1 + 16));
          if (!v23)
            return;
          objc_msgSend_removeLightWithId_(v14, v24, (uint64_t)v23, v25);
        }
        sub_1B1879C54(v9, *(const void **)(a1 + 16));
        break;
      case 1:
        v16 = *(_QWORD *)(a1 + 32);
        if (v16 == 5)
        {
          objc_msgSend_removeSkyboxes(v10, v11, 5, v13);
          SkyboxWithParameters = objc_msgSend_createSkyboxWithParameters_(v14, v17, *(_QWORD *)(a1 + 40), v18);
        }
        else
        {
          SkyboxWithParameters = objc_msgSend_addLightWithType_(v10, v11, v16, v13);
        }
        if (SkyboxWithParameters)
          sub_1B1879BC4(v9, *(const void **)(a1 + 16), SkyboxWithParameters);
        break;
    }
  }
}

uint64_t sub_1B18D36B4(uint64_t *a1)
{
  uint64_t result;

  result = sub_1B179CB60(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B18D36E0()
{
  uint64_t v0;

  if (qword_1ED4D0668 != -1)
    dispatch_once_f(&qword_1ED4D0668, &qword_1ED4CEE80, (dispatch_function_t)sub_1B18D36B4);
  v0 = sub_1B179CB90(qword_1ED4CEE80, 0x20uLL);
  *(_QWORD *)(v0 + 16) = sub_1B19D4D18(8, 0);
  return v0;
}

void sub_1B18D3750(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int64_t v8;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  int64_t v21;
  void *v22;

  LODWORD(v8) = a2;
  v10 = sub_1B19D4DF4(*(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  if (v10 <= v8)
    v11 = v8;
  else
    v11 = v10;
  if (v8 >= v11 >> 1)
    v8 = v11;
  else
    v8 = v8;
  if (v8 != v10)
  {
    v12 = v10;
    sub_1B19D4F1C(*(_QWORD *)(a1 + 16), v8);
    sub_1B19D4F5C(*(_DWORD **)(a1 + 16), v8);
    v20 = v8 <= v12;
    v21 = v8 - v12;
    if (!v20)
    {
      v22 = (void *)(sub_1B19D4ED4(*(_QWORD *)(a1 + 16), v13, v14, v15, v16, v17, v18, v19) + 8 * v12);
      memset(v22, 255, 8 * v21);
    }
  }
}

uint64_t sub_1B18D37E4(uint64_t result)
{
  *(_BYTE *)(result + 40) = 1;
  return result;
}

void sub_1B18D37F0(void *a1, int a2, void *__base, size_t __nel)
{
  qsort_r(__base, __nel, 4uLL, a1, (int (__cdecl *)(void *, const void *, const void *))sub_1B18D380C);
}

uint64_t sub_1B18D380C(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 *v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  unsigned int v15;

  v9 = (unsigned __int16 *)a2;
  v10 = sub_1B19D4ED4(*(_QWORD *)(a1 + 16), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  LODWORD(v9) = sub_1B19CEB9C(*v9, v9[1]);
  v11 = sub_1B19CEB9C(*a3, a3[1]);
  v12 = *(_QWORD *)(v10 + 8 * (int)v9);
  v13 = *(_QWORD *)(v10 + 8 * v11);
  v14 = v12 > v13;
  if (v12 == v13)
    v15 = 0;
  else
    v15 = -1;
  if (v14)
    return 1;
  else
    return v15;
}

CFIndex sub_1B18D3870(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  __int16 v28;
  char v29;
  BOOL v30;
  CFIndex result;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  __int16 v40;
  __int16 v41;
  void *v42;

  v10 = sub_1B19D4DAC(*(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  v18 = sub_1B1820C0C(a2, v11, v12, v13, v14, v15, v16, v17);
  v19 = sub_1B19CFC84(v18);
  if (v19 != *(_QWORD *)(a1 + 32))
  {
    *(_QWORD *)(a1 + 32) = v19;
    v27 = sub_1B19CFC54(v18, v20, v21, v22, v23, v24, v25, v26);
    v28 = 1;
    if (v27 >= 2)
    {
      v29 = 0;
      do
      {
        ++v29;
        v30 = v27 > 3;
        v27 >>= 1;
      }
      while (v30);
      v28 = (v29 + 1) & 0x1F;
    }
    *(_WORD *)(a1 + 24) = *(_WORD *)(a1 + 24) & 0xFFE0 | v28;
    *(_BYTE *)(a1 + 40) = 1;
  }
  result = sub_1B19CFC6C(v18, v20, v21, v22, v23, v24, v25, v26);
  v39 = *(unsigned __int16 *)(a1 + 24);
  if (result >= (uint64_t)(2 << (v39 >> 5)))
  {
    if (result >= 2)
    {
      v41 = 0;
      do
      {
        ++v41;
        v30 = result > 3;
        LODWORD(result) = result >> 1;
      }
      while (v30);
      v40 = (32 * v41 + 32) & 0x3E0;
    }
    else
    {
      v40 = 32;
    }
    *(_WORD *)(a1 + 24) = v40 | v39 & 0xFC1F;
    *(_BYTE *)(a1 + 40) = 1;
    goto LABEL_16;
  }
  if (*(_BYTE *)(a1 + 40))
  {
LABEL_16:
    v42 = (void *)sub_1B19D4ED4(*(_QWORD *)(a1 + 16), v32, v33, v34, v35, v36, v37, v38);
    result = (CFIndex)memset(v42, 255, 8 * v10);
    *(_BYTE *)(a1 + 40) = 0;
  }
  return result;
}

void sub_1B18D39A0(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  float32x4_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  char v67;
  char v68;
  uint64_t v69;
  int v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int v90;
  int v91;
  int v92;
  int v93;
  char v94;
  int v95;
  int v96;
  char v97;
  unint64_t v98;
  char v99;
  char v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  float32x4_t *v106;
  uint64_t v107;
  float32x4_t *v108;
  uint64_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  int32x4_t v114;
  uint64_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  uint64_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  uint64_t v125;
  float32x4_t v127;
  int32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  uint64_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v138[2];
  simd_float4x4 v139;
  simd_float4x4 v140;

  v9 = a4;
  v10 = (unsigned int *)a3;
  v12 = sub_1B1814768(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v20 = sub_1B1813884((uint64_t)a2, v13, v14, v15, v16, v17, v18, v19);
  v28 = sub_1B187B140(v20, v21, v22, v23, v24, v25, v26, v27);
  v125 = sub_1B18143C8((uint64_t)a2, v29, v30, v31, v32, v33, v34, v35);
  v43 = sub_1B1820C0C(v28, v36, v37, v38, v39, v40, v41, v42);
  if (v12)
  {
    v51 = v43;
    v139 = *(simd_float4x4 *)sub_1B1869AC8((uint64_t)v12, v44, v45, v46, v47, v48, v49, v50);
    v140 = __invert_f4(v139);
    v135 = (float32x4_t)v140.columns[1];
    v136 = (float32x4_t)v140.columns[0];
    v134 = (float32x4_t)v140.columns[2];
    v132 = (float32x4_t)v140.columns[3];
    if (v9 >= 1)
    {
      v131 = vabsq_f32((float32x4_t)v140.columns[0]);
      v129 = vabsq_f32((float32x4_t)v140.columns[2]);
      v130 = vabsq_f32((float32x4_t)v140.columns[1]);
      v133 = v51;
      while (1)
      {
        v58 = *v10++;
        v8 = v8 & 0xFFFFFFFF00000000 | v58;
        v59 = (float32x4_t *)sub_1B19CFAFC(v51, v8, v52, v53, v54, v55, v56, v57);
        v66 = (_QWORD *)sub_1B19D4E3C(*(_QWORD *)(a1 + 16), v59->u32[0], v60, v61, v62, v63, v64, v65);
        v67 = sub_1B17C2E50((uint64_t)v59);
        v68 = v67;
        if (*v66 == -1)
          break;
        if ((v67 & 1) == 0)
        {
          *v66 &= 0xFFFFFFFF00000000;
          goto LABEL_28;
        }
LABEL_40:
        if (!--v9)
          return;
      }
      v69 = sub_1B19CFC3C(v51, (uint64_t)v59, v52, v53, v54, v55, v56, v57);
      v70 = sub_1B17C2E50((uint64_t)v59);
      if (v70 && !sub_1B17C2B78((uint64_t)v59) && sub_1B17C2E80((uint64_t)v59))
      {
        v71 = (void *)sub_1B17C7D94(v125, (char *)v59, 0, a5);
        v78 = sub_1B17C7EB4(v125, v71, v72, v73, v74, v75, v76, v77);
        v79 = v51;
        v80 = v78;
        v87 = sub_1B19CFC48(v79, (uint64_t)v59, v81, v82, v83, v84, v85, v86);
      }
      else
      {
        v80 = 0;
        v87 = 0;
      }
      v88 = v59->i64[1];
      if (v88)
        v89 = sub_1B186E064(v88) << 61;
      else
        v89 = 0;
      v90 = *(unsigned __int16 *)(a1 + 24);
      v91 = (v90 >> 5) & 0x1F;
      v92 = v90 & 0x1F;
      v93 = (60 - (v91 + v92)) & ~((60 - (v91 + v92)) >> 31);
      v94 = v92;
      if ((v70 & 1) != 0)
        v95 = v91;
      else
        v95 = 0;
      if ((v70 & 1) != 0)
        v96 = v93;
      else
        v96 = 0;
      v97 = 60 - v94;
      v98 = (v69 << (61 - v94)) | v89 | ((unint64_t)(v70 ^ 1u) << (60 - v94));
      v99 = 60 - v94 - v96;
      if (v96)
      {
        v98 |= (v80 & ~(-1 << v96)) << (v97 - v96);
        v100 = v99;
      }
      else
      {
        v100 = v97;
      }
      v101 = v87 << (v100 - v95);
      if (v95)
        v102 = v101;
      else
        v102 = 0;
      *v66 = v102 | v98;
      v51 = v133;
      if ((v68 & 1) != 0)
        goto LABEL_40;
LABEL_28:
      v103 = sub_1B17C2DEC((uint64_t)v59);
      v104 = sub_1B17C2EA0((uint64_t)v59);
      if (v104)
      {
        v105 = v104;
        v106 = (float32x4_t *)sub_1B17C2EC0((uint64_t)v59);
        if (v106)
        {
          v108 = v106;
          sub_1B187484C(v105, v107, v52, v53, v54, v55, v56, v57);
          v110 = v108[11];
          v111 = v108[12];
          v110.i32[3] = 1.0;
          v111.i32[3] = 1.0;
          v112.i64[0] = 0x3F0000003F000000;
          v112.i64[1] = 0x3F0000003F000000;
          v113 = vmulq_f32(vaddq_f32(v110, v111), v112);
          v114 = (int32x4_t)vmulq_f32(vsubq_f32(v111, v110), v112);
          if (v103)
          {
            v127 = v113;
            v128 = v114;
            v115 = sub_1B1869AC8(v103, v109, v52, v53, v54, v55, v56, v57);
            v116 = *(float32x4_t *)(v115 + 16);
            v117 = *(float32x4_t *)(v115 + 32);
            v118 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(v115 + 48), v117, v127, 2), v116, *(float32x2_t *)v127.f32, 1), *(float32x4_t *)v115, v127.f32[0]);
            v118.i32[3] = v127.i32[3];
            v119 = (float32x4_t)v128;
            v119.i32[1] = v128.i32[0];
            v119.i32[2] = v128.i32[0];
            v113 = v118;
            v114 = (int32x4_t)vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v128.i8, 1), v128), vabsq_f32(v116)), v119, vabsq_f32(*(float32x4_t *)v115)), (float32x4_t)vzip2q_s32(vtrn1q_s32(v128, v128), v128), vabsq_f32(v117));
          }
          goto LABEL_38;
        }
      }
      else
      {
        if ((v59[5].i16[0] & 7) != 4)
        {
          v113 = (float32x4_t)xmmword_1B2244E20;
          v114 = (int32x4_t)xmmword_1B2246ED0;
          if (v103)
          {
            *(uint64_t *)((char *)v138[0].i64 + 4) = 0;
            v138[0].i32[0] = 0;
            sub_1B186B5BC(v103, (__n128 *)v138, v52, v53, v54, v55, v56, v57);
            v121 = v138[0];
            v121.i32[3] = 1.0;
            v122.i64[0] = 0x3F0000003F000000;
            v122.i64[1] = 0x3F0000003F000000;
            v113 = vmulq_f32(vaddq_f32(v121, (float32x4_t)xmmword_1B2244E20), v122);
            v114 = (int32x4_t)vmulq_f32(vsubq_f32((float32x4_t)xmmword_1B2244E20, v121), v122);
          }
          goto LABEL_38;
        }
        if ((v59[5].i16[0] & 0x4000) == 0)
        {
          v113 = v59[1];
          v114 = (int32x4_t)v59[2];
LABEL_38:
          v123 = (float32x4_t)v114;
          v123.i32[1] = v114.i32[0];
          v123.i32[2] = v114.i32[0];
          v124 = vaddq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v114.i8, 1), v114), v130), v123, v131), (float32x4_t)vzip2q_s32(vtrn1q_s32(v114, v114), v114), v129), vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v132, v134, v113, 2), v135, *(float32x2_t *)v113.f32, 1), v136, v113.f32[0]));
          v120 = ((v124.i32[2] >> 31) | 0x80000000) ^ v124.i32[2];
          goto LABEL_39;
        }
      }
      v120 = 3212836864;
LABEL_39:
      *v66 |= v120;
      goto LABEL_40;
    }
  }
}

_QWORD *sub_1B18D3DB4(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  _QWORD *result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v9 = *a2;
  result = (_QWORD *)sub_1B19D4DF4(*(_QWORD *)(a1 + 16), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if ((uint64_t)result > v9)
  {
    result = (_QWORD *)sub_1B19D4E3C(*(_QWORD *)(a1 + 16), v9, v11, v12, v13, v14, v15, v16);
    *result = -1;
  }
  return result;
}

uint64_t sub_1B18D3DF8(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;

  v10 = sub_1B19D4DAC(*(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  result = sub_1B19CEB9C((unsigned __int16)a2, WORD1(a2));
  if (v10 > result)
  {
    v19 = HIDWORD(a2);
    result = sub_1B19D4ED4(*(_QWORD *)(a1 + 16), v12, v13, v14, v15, v16, v17, v18);
    if (HIDWORD(a2))
    {
      v20 = result;
      v21 = a2 >> 16;
      do
      {
        result = sub_1B19CEB9C((unsigned __int16)a2, (unsigned __int16)v21);
        *(_QWORD *)(v20 + 8 * result) = -1;
        LODWORD(v21) = v21 + 1;
        LODWORD(v19) = v19 - 1;
      }
      while ((_DWORD)v19);
    }
  }
  return result;
}

void sub_1B18D3E84(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

CFStringRef sub_1B18D3EB0(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXSortSystem %p>"), a1);
}

CFStringRef sub_1B18D3EEC(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXSortSystem %p>"), a1);
}

double sub_1B18D3F28(std::string *__str, uint64_t a2, int a3)
{
  std::string::size_type size;
  int v6;
  std::string::size_type v7;
  std::string *v8;
  int v9;
  BOOL v10;
  std::string *v12;
  double result;
  std::string v14;
  char v15;

  size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  v6 = (char)size;
  v7 = 0;
  if ((size & 0x80u) != 0)
    size = __str->__r_.__value_.__l.__size_;
  if (size)
  {
    v8 = (std::string *)__str->__r_.__value_.__r.__words[0];
    if (v6 >= 0)
      v8 = __str;
    while (1)
    {
      v9 = v8->__r_.__value_.__s.__data_[v7];
      v10 = v9 == 10 || v9 == 13;
      if (!v10 && (char)v9 > 32)
        break;
      if (size == ++v7)
      {
LABEL_21:
        v7 = size;
        goto LABEL_22;
      }
    }
  }
  if (v7 < size && a3 != 0)
  {
    v12 = (std::string *)__str->__r_.__value_.__r.__words[0];
    if (v6 >= 0)
      v12 = __str;
    while (v12->__r_.__value_.__s.__data_[v7] == 44)
    {
      if (size == ++v7)
        goto LABEL_21;
    }
  }
LABEL_22:
  std::string::basic_string(&v14, __str, v7, size - v7, (std::allocator<char> *)&v15);
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  result = *(double *)&v14.__r_.__value_.__l.__data_;
  *(std::string *)a2 = v14;
  return result;
}

double sub_1B18D400C(std::string *a1, std::string *a2, std::string *a3, char a4, int a5)
{
  uint64_t size;
  std::string *v11;
  unint64_t v12;
  std::string *v13;
  int v14;
  char v16;
  char v17;
  std::string::size_type v18;

  sub_1B18D3F28(a1, (uint64_t)a2, 0);
  size = HIBYTE(a1->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) == 0)
    v11 = a1;
  else
    v11 = (std::string *)a1->__r_.__value_.__r.__words[0];
  if ((size & 0x80u) != 0)
    size = a1->__r_.__value_.__l.__size_;
  v12 = (unint64_t)v11 + size;
  v13 = v11;
  if (size >= 1)
  {
    do
    {
      v14 = v13->__r_.__value_.__s.__data_[0];
      if (v14 == 10 || v14 == 13)
        break;
      v16 = (char)v14 < 33 ? a4 : 0;
      v17 = v14 == 44 ? a5 : 0;
      if ((v16 & 1) != 0)
        break;
      if ((v17 & 1) != 0)
        break;
      v13 = (std::string *)((char *)v13 + 1);
    }
    while ((unint64_t)v13 < v12);
  }
  std::string::assign(a3, a1, 0, (char *)v13 - (char *)v11);
  if ((a1->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v18 = (std::string::size_type)a1;
  else
    v18 = a1->__r_.__value_.__r.__words[0];
  std::string::assign(a2, a1, (std::string::size_type)v13 - v18, v12 - (_QWORD)v13);
  return sub_1B18D3F28(a2, (uint64_t)a2, a5);
}

float sub_1B18D40FC(std::string *a1, std::string *a2, float *a3, char a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::string::size_type size;
  float result;
  void *v14;
  float v15;
  std::string v16;

  memset(&v16, 0, sizeof(v16));
  sub_1B18D400C(a1, a2, &v16, a4, a5);
  size = HIBYTE(v16.__r_.__value_.__r.__words[2]);
  if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v16.__r_.__value_.__l.__size_;
  if (size)
  {
    if ((*((_BYTE *)&v16.__r_.__value_.__s + 23) & 0x80) == 0)
    {
LABEL_5:
      result = atof((const char *)&v16);
      *a3 = result;
      return result;
    }
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v6, v7, v8, v9, v10, v11, (uint64_t)"!line.empty()");
    if ((*((_BYTE *)&v16.__r_.__value_.__s + 23) & 0x80) == 0)
      goto LABEL_5;
  }
  v14 = (void *)v16.__r_.__value_.__r.__words[0];
  v15 = atof(v16.__r_.__value_.__l.__data_);
  *a3 = v15;
  operator delete(v14);
  return result;
}

void sub_1B18D41A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1B18D41BC(std::string *a1, std::string *a2, int *a3, char a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::string::size_type size;
  void *v13;
  std::string v14;

  memset(&v14, 0, sizeof(v14));
  sub_1B18D400C(a1, a2, &v14, a4, a5);
  size = HIBYTE(v14.__r_.__value_.__r.__words[2]);
  if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v14.__r_.__value_.__l.__size_;
  if (size)
  {
    if ((*((_BYTE *)&v14.__r_.__value_.__s + 23) & 0x80) == 0)
    {
LABEL_5:
      *a3 = atoi((const char *)&v14);
      return;
    }
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v6, v7, v8, v9, v10, v11, (uint64_t)"!line.empty()");
    if ((*((_BYTE *)&v14.__r_.__value_.__s + 23) & 0x80) == 0)
      goto LABEL_5;
  }
  v13 = (void *)v14.__r_.__value_.__r.__words[0];
  *a3 = atoi(v14.__r_.__value_.__l.__data_);
  operator delete(v13);
}

void sub_1B18D4258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B18D4274(_BYTE *__src, size_t __len, _OWORD *a3, int a4)
{
  uint64_t v6;
  std::string *v7;
  std::string::size_type size;
  int v9;
  size_t v10;
  std::string *p_p;
  int v12;
  size_t v14;
  std::string *v15;
  int v16;
  size_t v17;
  std::string *v18;
  int v19;
  size_t v20;
  std::string *v21;
  int v22;
  int v23;
  size_t v24;
  std::string *v25;
  int v26;
  size_t v27;
  std::string *v28;
  int v29;
  BOOL v30;
  int v31;
  char *v32;
  int v33;
  char *v34;
  uint64_t v35;
  float v36;
  int data;
  uint64_t v38;
  uint64_t v39;
  float v40;
  int v41;
  float *v43;
  float v44;
  int v45;
  int v46;
  float v47;
  uint64_t v48;
  float v49;
  std::string::size_type v50;
  std::string::size_type v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  std::string __p;
  __int128 v56;
  __int128 v57;
  size_t count[2];
  __int128 v59;
  __int128 v60;
  __int128 v61;
  std::string v62;
  std::string __str;
  void *__dst;
  char v65;

  if (__len < 5)
    return 0;
  if (a4)
  {
    if (*(_DWORD *)__src != 1314080073 || __src[4] != 65)
      return 0;
  }
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  v7 = (std::string *)sub_1B18D5488(&__dst, __src, __len);
  memset(&__str, 0, sizeof(__str));
  memset(&v62, 0, sizeof(v62));
  sub_1B18D400C(v7, &__str, &v62, 0, 0);
  do
  {
    while (1)
    {
      size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        size = __str.__r_.__value_.__l.__size_;
      if (!size)
        goto LABEL_86;
      memset(&__p, 0, sizeof(__p));
      sub_1B18D400C(&__str, &__str, &__p, 0, 0);
      v9 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        v10 = __p.__r_.__value_.__l.__size_ >= 9 ? 9 : __p.__r_.__value_.__l.__size_;
      }
      else
      {
        v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]) >= 9u ? 9 : HIBYTE(__p.__r_.__value_.__r.__words[2]);
        p_p = &__p;
      }
      v12 = memcmp(p_p, "TILT=NONE", v10);
      if (v10 >= 9 && v12 == 0)
        goto LABEL_54;
      if (v9 < 0)
      {
        v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
        v14 = __p.__r_.__value_.__l.__size_ >= 0xA ? 10 : __p.__r_.__value_.__l.__size_;
      }
      else
      {
        v14 = v9 >= 0xAu ? 10 : v9;
        v15 = &__p;
      }
      v16 = memcmp(v15, "TILT= NONE", v14);
      if (v14 >= 0xA && !v16)
        goto LABEL_54;
      if (v9 < 0)
      {
        v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
        v17 = __p.__r_.__value_.__l.__size_ >= 0xA ? 10 : __p.__r_.__value_.__l.__size_;
      }
      else
      {
        v17 = v9 >= 0xAu ? 10 : v9;
        v18 = &__p;
      }
      if (((v19 = memcmp(v18, "TILT =NONE", v17), v17 < 0xA) || v19)
        && (v9 < 0
          ? (std::string *)((v21 = (std::string *)__p.__r_.__value_.__r.__words[0], __p.__r_.__value_.__l.__size_ >= 0xB)
                          ? (v20 = 11)
                          : (v20 = __p.__r_.__value_.__l.__size_))
          : (v9 >= 0xBu ? (v20 = 11) : (v20 = v9), v21 = &__p),
            (v22 = memcmp(v21, "TILT = NONE", v20), v20 < 0xB) || v22))
      {
        if (v9 < 0)
        {
          v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
          v24 = __p.__r_.__value_.__l.__size_ >= 5 ? 5 : __p.__r_.__value_.__l.__size_;
        }
        else
        {
          v24 = v9 >= 5u ? 5 : v9;
          v25 = &__p;
        }
        v26 = memcmp(v25, "TILT=", v24);
        if (v24 < 5 || v26)
        {
          if (v9 < 0)
          {
            v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
            v27 = __p.__r_.__value_.__l.__size_ >= 5 ? 5 : __p.__r_.__value_.__l.__size_;
          }
          else
          {
            v27 = v9 >= 5u ? 5 : v9;
            v28 = &__p;
          }
          v29 = memcmp(v28, "TILT =", v27);
          v30 = v27 > 4 && v29 == 0;
          v23 = v30;
        }
        else
        {
          v23 = 1;
        }
      }
      else
      {
LABEL_54:
        v23 = 3;
      }
      if (v9 < 0)
        break;
      if (v23)
        goto LABEL_85;
    }
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  while (!v23);
LABEL_85:
  if (v23 != 3)
  {
LABEL_104:
    v6 = 0;
    goto LABEL_105;
  }
LABEL_86:
  sub_1B18D40FC(&__str, &__str, (float *)&v56, 1, 0);
  v6 = 0;
  if (*(float *)&v56 >= 0.0 && *(float *)&v56 <= 32767.0)
  {
    sub_1B18D40FC(&__str, &__str, (float *)&v56 + 1, 1, 0);
    if (*((float *)&v56 + 1) < 0.0)
      goto LABEL_104;
    sub_1B18D40FC(&__str, &__str, (float *)&v56 + 2, 1, 0);
    if (*((float *)&v56 + 2) < 0.0)
      goto LABEL_104;
    sub_1B18D41BC(&__str, &__str, (int *)count + 1, 1, 0);
    if (HIDWORD(count[0]) >> 15)
      goto LABEL_104;
    sub_1B18D41BC(&__str, &__str, (int *)count, 1, 0);
    if (LODWORD(count[0]) >> 15)
      goto LABEL_104;
    sub_1B18D41BC(&__str, &__str, (int *)&v57 + 2, 1, 0);
    sub_1B18D41BC(&__str, &__str, (int *)&v57 + 3, 1, 0);
    sub_1B18D40FC(&__str, &__str, (float *)&count[1] + 1, 1, 0);
    sub_1B18D40FC(&__str, &__str, (float *)&v59, 1, 0);
    sub_1B18D40FC(&__str, &__str, (float *)&v59 + 1, 1, 0);
    sub_1B18D40FC(&__str, &__str, (float *)&v59 + 2, 1, 0);
    sub_1B18D40FC(&__str, &__str, (float *)&v59 + 3, 1, 0);
    sub_1B18D40FC(&__str, &__str, (float *)&v60, 1, 0);
    v31 = HIDWORD(count[0]);
    v32 = (char *)malloc_type_calloc(SHIDWORD(count[0]), 4uLL, 0x100004052888210uLL);
    *(_QWORD *)&v61 = v32;
    v33 = count[0];
    v34 = (char *)malloc_type_calloc(SLODWORD(count[0]), 4uLL, 0x100004052888210uLL);
    *((_QWORD *)&v60 + 1) = v34;
    if (v31 >= 1)
    {
      v35 = 0;
      v36 = -3.4028e38;
      while (1)
      {
        LODWORD(__p.__r_.__value_.__l.__data_) = 0;
        sub_1B18D40FC(&__str, &__str, (float *)&__p, 1, 1);
        data = (int)__p.__r_.__value_.__l.__data_;
        if (*(float *)&__p.__r_.__value_.__l.__data_ < v36)
          goto LABEL_103;
        *(_DWORD *)&v32[v35] = __p.__r_.__value_.__l.__data_;
        v35 += 4;
        v36 = *(float *)&data;
        if (4 * v31 == v35)
          goto LABEL_98;
      }
    }
    data = -8388609;
LABEL_98:
    v38 = v33;
    if (v33 >= 1)
    {
      v39 = 0;
      v40 = -3.4028e38;
      while (1)
      {
        LODWORD(__p.__r_.__value_.__l.__data_) = 0;
        sub_1B18D40FC(&__str, &__str, (float *)&__p, 1, 1);
        v41 = (int)__p.__r_.__value_.__l.__data_;
        if (*(float *)&__p.__r_.__value_.__l.__data_ < v40)
          break;
        *(_DWORD *)&v34[v39] = __p.__r_.__value_.__l.__data_;
        v39 += 4;
        v40 = *(float *)&v41;
        if (4 * v38 == v39)
          goto LABEL_113;
      }
LABEL_103:
      free(v32);
      free(v34);
      goto LABEL_104;
    }
    v41 = -8388609;
LABEL_113:
    LODWORD(v57) = v41;
    LODWORD(count[1]) = v38 * v31;
    v43 = (float *)malloc_type_calloc((int)v38 * v31, 4uLL, 0x100004052888210uLL);
    *((_QWORD *)&v61 + 1) = v43;
    v44 = *((float *)&v56 + 2);
    if ((int)v38 < 1)
    {
      v47 = 0.0;
    }
    else
    {
      v45 = 0;
      v46 = 0;
      v47 = 0.0;
      do
      {
        v48 = v31;
        if (v31 >= 1)
        {
          do
          {
            LODWORD(__p.__r_.__value_.__l.__data_) = 0;
            sub_1B18D40FC(&__str, &__str, (float *)&__p, 1, 1);
            v49 = *(float *)&__p.__r_.__value_.__l.__data_;
            v43[v46++] = *(float *)&__p.__r_.__value_.__l.__data_ * v44;
            if (v49 >= v47)
              v47 = v49;
            --v48;
          }
          while (v48);
        }
        ++v45;
      }
      while (v45 != (_DWORD)v38);
    }
    *((float *)&v56 + 3) = v47 * v44;
    DWORD1(v57) = data;
    sub_1B18D3F28(&__str, (uint64_t)&__str, 0);
    v50 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v50 = __str.__r_.__value_.__l.__size_;
    if (v50)
    {
      memset(&__p, 0, sizeof(__p));
      sub_1B18D400C(&__str, &__str, &__p, 1, 0);
      if (sub_1B18D4A64((const void **)&__p.__r_.__value_.__l.__data_, "END"))
        sub_1B18D3F28(&__str, (uint64_t)&__str, 0);
      v51 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v51 = __str.__r_.__value_.__l.__size_;
      if (v51)
      {
        free(v32);
        free(v34);
        free(v43);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        goto LABEL_104;
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    v52 = v59;
    a3[2] = *(_OWORD *)count;
    a3[3] = v52;
    v53 = v61;
    a3[4] = v60;
    a3[5] = v53;
    v54 = v57;
    v6 = 1;
    *a3 = v56;
    a3[1] = v54;
  }
LABEL_105:
  if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v62.__r_.__value_.__l.__data_);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v65 < 0)
    operator delete(__dst);
  return v6;
}

void sub_1B18D49F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  uint64_t v39;

  if (a15 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  if (a39 < 0)
    operator delete(a34);
  if (*(char *)(v39 - 121) < 0)
    operator delete(*(void **)(v39 - 144));
  _Unwind_Resume(exception_object);
}

BOOL sub_1B18D4A64(const void **a1, char *__s)
{
  int v4;
  size_t v5;
  const void *v6;

  v4 = *((char *)a1 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a1 + 23);
  else
    v5 = (size_t)a1[1];
  if (v5 != strlen(__s))
    return 0;
  if (v4 >= 0)
    v6 = a1;
  else
    v6 = *a1;
  return memcmp(v6, __s, v5) == 0;
}

uint64_t sub_1B18D4AD8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  int v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  size_t v30;

  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  result = objc_msgSend_dataWithContentsOfURL_(MEMORY[0x1E0C99D50], (const char *)a2, (uint64_t)a1, a4);
  if (result)
  {
    v10 = (void *)result;
    v11 = (void *)objc_msgSend_path(a1, v7, v8, v9);
    v15 = (void *)objc_msgSend_pathExtension(v11, v12, v13, v14);
    v19 = (void *)objc_msgSend_lowercaseString(v15, v16, v17, v18);
    v22 = objc_msgSend_isEqualToString_(v19, v20, (uint64_t)CFSTR("ies"), v21) ^ 1;
    v26 = (_BYTE *)objc_msgSend_bytes(v10, v23, v24, v25);
    v30 = objc_msgSend_length(v10, v27, v28, v29);
    return sub_1B18D4274(v26, v30, (_OWORD *)a2, v22);
  }
  return result;
}

void sub_1B18D4B7C(float *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;

  if (a2 <= 0)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"anglesCount > 0");
  if (*a1 <= a9)
  {
    v12 = a2 - 1;
    if (a1[v12] >= a9)
    {
      v13 = 0;
      if (a2 != 1)
      {
        while (1)
        {
          v14 = (v13 + v12 + 1) >> 1;
          if (a1[v14] <= a9)
            break;
          v15 = v14 - 1;
          v16 = "end != index - 1";
          if (v12 == v15)
            goto LABEL_10;
          v12 = v15;
LABEL_12:
          if (v13 >= v12)
            return;
        }
        v16 = "start != index";
        if (v13 != v14)
        {
          v13 = (v13 + v12 + 1) >> 1;
          goto LABEL_12;
        }
LABEL_10:
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)v16);
        goto LABEL_12;
      }
    }
  }
}

float sub_1B18D4CD0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;

  v9 = *(_DWORD *)(a1 + 32);
  v10 = *(_DWORD *)(a1 + 36);
  v11 = v9 - 1;
  if (v9 - 1 >= a2)
    v11 = a2;
  v12 = v11 & ~(v11 >> 31);
  v13 = v10 - 1;
  if (v10 - 1 >= (int)a3)
    v13 = a3;
  v14 = v13 & ~(v13 >> 31);
  if (v12 >= v9)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"x < anglesNumH");
  if (v14 >= v10)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"y < anglesNumV");
  return *(float *)(*(_QWORD *)(a1 + 88) + 4 * (v14 + v12 * v10));
}

float sub_1B18D4D74(uint64_t a1, float a2, float a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  int v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float v29;
  float32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  float v51;
  float32x4_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  float v73;
  float32x4_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  float v96;
  float32x4_t v97;
  float32x4_t v105;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float32x4_t v123;
  float v124;
  float v125;
  float32x4_t v126;
  float v127;
  float32x4_t v128;

  v12 = vcvtms_s32_f32(a2);
  LODWORD(v10) = vcvtms_s32_f32(a3);
  v13 = a2 - (float)(int)floorf(a2);
  v119 = a3 - (float)(int)floorf(a3);
  v127 = sub_1B18D4CD0(a1, v12 - 1, (v10 - 1), a6, a7, a8, a9, a10);
  v124 = sub_1B18D4CD0(a1, v12, (v10 - 1), v14, v15, v16, v17, v18);
  v120 = sub_1B18D4CD0(a1, v12 + 1, (v10 - 1), v19, v20, v21, v22, v23);
  v29 = sub_1B18D4CD0(a1, v12 + 2, (v10 - 1), v24, v25, v26, v27, v28);
  v30.i64[0] = __PAIR64__(LODWORD(v124), LODWORD(v127));
  v30.i64[1] = __PAIR64__(LODWORD(v29), LODWORD(v120));
  v128 = v30;
  v125 = sub_1B18D4CD0(a1, v12 - 1, v10, v31, v32, v33, v34, v35);
  v121 = sub_1B18D4CD0(a1, v12, v10, v36, v37, v38, v39, v40);
  v116 = sub_1B18D4CD0(a1, v12 + 1, v10, v41, v42, v43, v44, v45);
  v51 = sub_1B18D4CD0(a1, v12 + 2, v10, v46, v47, v48, v49, v50);
  v52.i64[0] = __PAIR64__(LODWORD(v121), LODWORD(v125));
  v52.i64[1] = __PAIR64__(LODWORD(v51), LODWORD(v116));
  v126 = v52;
  v122 = sub_1B18D4CD0(a1, v12 - 1, (v10 + 1), v53, v54, v55, v56, v57);
  v117 = sub_1B18D4CD0(a1, v12, (v10 + 1), v58, v59, v60, v61, v62);
  v114 = sub_1B18D4CD0(a1, v12 + 1, (v10 + 1), v63, v64, v65, v66, v67);
  v73 = sub_1B18D4CD0(a1, v12 + 2, (v10 + 1), v68, v69, v70, v71, v72);
  v74.i64[0] = __PAIR64__(LODWORD(v117), LODWORD(v122));
  v74.i64[1] = __PAIR64__(LODWORD(v73), LODWORD(v114));
  v123 = v74;
  v75 = (v10 + 2);
  v118 = sub_1B18D4CD0(a1, v12 - 1, v75, v76, v77, v78, v79, v80);
  v115 = sub_1B18D4CD0(a1, v12, v75, v81, v82, v83, v84, v85);
  v113 = sub_1B18D4CD0(a1, v12 + 1, v75, v86, v87, v88, v89, v90);
  v96 = sub_1B18D4CD0(a1, v12 + 2, v75, v91, v92, v93, v94, v95);
  v97.i64[0] = __PAIR64__(LODWORD(v115), LODWORD(v118));
  v97.i64[1] = __PAIR64__(LODWORD(v96), LODWORD(v113));
  _Q5 = v97;
  __asm { FMOV            V0.4S, #3.0 }
  v97.i64[0] = 0x3F0000003F000000;
  v97.i64[1] = 0x3F0000003F000000;
  __asm { FMOV            V2.4S, #-3.0 }
  v105 = vmlaq_f32(vmlaq_f32(vmlsq_f32(vmulq_f32(vmulq_f32(v126, _Q0), v97), v97, v128), v97, vmulq_f32(v123, _Q2)), v97, _Q5);
  __asm { FMOV            V2.4S, #5.0 }
  _Q6 = vmlaq_n_f32(v126, vmlaq_n_f32(vmulq_f32(vsubq_f32(v123, v128), v97), vmlaq_n_f32(vaddq_f32(v123, vaddq_f32(v123, vmlsq_f32(v128, v97, vmlaq_f32(_Q5, _Q2, v126)))), v105, v119), v119), v119);
  _S4 = 3.0;
  __asm { FMLA            S3, S4, V6.S[1] }
  _S4 = -3.0;
  __asm { FMLA            S3, S4, V6.S[2] }
  _Q5.i32[0] = 5.0;
  __asm { FMLA            S2, S5, V6.S[1] }
  return _Q6.f32[1]
       + (float)((float)((float)((float)(_Q6.f32[2] - _Q6.f32[0]) * 0.5)
                       + (float)((float)((float)(_Q6.f32[2]
                                               + (float)(_Q6.f32[2] + (float)(_Q6.f32[0] - (float)(_Q2.f32[0] * 0.5))))
                                       + (float)((float)((float)(_Q6.f32[3] + _S3) * 0.5) * v13))
                               * v13))
               * v13);
}

uint64_t sub_1B18D503C(uint64_t a1, int16x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  int16x4_t *v12;
  float v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  float v21;
  float v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _BYTE *v37;
  uint64_t v38;
  float v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  _BOOL4 v43;
  int16x4_t *v49;
  float v50;
  uint64_t v51;
  float *v52;
  float v53;
  int32x4_t *v54;
  int32x4_t *v55;
  int v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  __int16 v61;
  __int16 v62;
  int v63;
  int32x4_t v64;
  int32x4_t v65;
  int32x4_t *v66;
  int16x4_t v67;
  int16x4_t v68;
  char v69;
  _BYTE v71[4];
  _BOOL4 v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int32x4_t v76;
  int32x4_t *v77;
  uint64_t v78;

  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v78 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (!(_DWORD)a3)
      goto LABEL_6;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"data");
    if (!(_DWORD)v11)
    {
LABEL_6:
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"width > 0 && height > 0");
      goto LABEL_7;
    }
  }
  if (!v10)
    goto LABEL_6;
LABEL_7:
  if (v9 != 1 && v9 != 4)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"channelCount == 1 || channelCount == 4");
  if (v8 > 4 || ((1 << v8) & 0x16) == 0)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"channelSize == 1 || channelSize == 2 || channelSize == 4");
  v14 = *(float *)(a1 + 12);
  v17 = MEMORY[0x1E0C80A78](a1, a2);
  v19 = (float *)&v71[-v18];
  if ((_DWORD)v11)
  {
    v20 = 0;
    v21 = *(float *)&v17 / 180.0;
    do
    {
      v22 = acosf((float)((float)((float)v20 * -2.0) * (float)(1.0 / (float)v11)) + 1.0)
          / 3.14159265
          * 180.0;
      sub_1B18D4B7C(*(float **)(a1 + 80), *(_DWORD *)(a1 + 36), v23, v24, v25, v26, v27, v28, v21 * v22);
      v19[v20++] = v29;
    }
    while (v11 != v20);
  }
  v74 = v11;
  MEMORY[0x1E0C80A78](v15, v16);
  v37 = &v71[-v36];
  if (v10)
  {
    v38 = 0;
    v39 = 1.0 / v14;
    do
    {
      sub_1B18D4B7C(*(float **)(a1 + 72), *(_DWORD *)(a1 + 32), v30, v31, v32, v33, v34, v35, (float)((float)(1.0 / (float)v10) * (float)v38) * 180.0);
      *(_DWORD *)&v37[4 * v38++] = v41;
    }
    while (v10 != v38);
    v42 = 0;
    v43 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    v76 = _Q0;
    v49 = v12;
    v77 = (int32x4_t *)v12;
    v73 = v11;
    do
    {
      v75 = v42;
      if ((_DWORD)v11)
      {
        v72 = v43;
        v50 = *(float *)&v37[4 * v42];
        v51 = v74;
        v52 = v19;
        do
        {
          v53 = v39 * sub_1B18D4D74(a1, v50, *v52, v40, v30, v31, v32, v33, v34, v35);
          switch(v8)
          {
            case 1u:
              v56 = (int)(float)((float)(v53 * 255.0) + 0.5);
              if (v9 == 4)
              {
                v12->i8[0] = v56;
                v12->i8[1] = v56;
                v12->i8[2] = v56;
                v12->i8[3] = -1;
                v12 = (int16x4_t *)((char *)v12 + 4);
              }
              else
              {
                if (v9 != 1)
                  goto LABEL_48;
                v12->i8[0] = v56;
                v12 = (int16x4_t *)((char *)v12 + 1);
              }
              break;
            case 2u:
              v57 = HIWORD(LODWORD(v53)) & 0x8000;
              v58 = (LODWORD(v53) >> 23);
              v59 = v58 - 112;
              v60 = v58 - 113;
              v61 = v57 | 0x7BFF;
              if (v58 == 255)
                v61 = v57 | ((LODWORD(v53) & 0x7FFFFF) != 0) | 0x7C00;
              if (v58 >= 0x71)
                v62 = v61;
              else
                v62 = HIWORD(v53) & 0x8000;
              v63 = HIWORD(LODWORD(v53)) & 0x8000 | (LODWORD(v53) >> 13) & 0x3FF | (v59 << 10);
              if (v60 > 0x1D)
                LOWORD(v63) = v62;
              if (v9 == 4)
              {
                v67 = (int16x4_t)-1;
                v67.i16[0] = v63;
                v68 = vzip1_s16(v67, v67);
                v68.i16[2] = v63;
                *v49++ = v68;
              }
              else
              {
                if (v9 != 1)
                {
LABEL_48:
                  v69 = v72;
                  return v69 & 1;
                }
                v49->i16[0] = v63;
                v49 = (int16x4_t *)((char *)v49 + 2);
              }
              break;
            case 4u:
              if (v9 == 4)
              {
                v64 = v76;
                *(float *)v64.i32 = v53;
                v65 = vzip1q_s32(v64, v64);
                *(float *)&v65.i32[2] = v53;
                v66 = v77;
                *v77 = v65;
                v55 = v66 + 1;
              }
              else
              {
                if (v9 != 1)
                  goto LABEL_48;
                v54 = v77;
                *(float *)v77->i32 = v53;
                v55 = (int32x4_t *)((char *)v54->i64 + 4);
              }
              v77 = v55;
              break;
            default:
              goto LABEL_48;
          }
          ++v52;
          --v51;
        }
        while (v51);
      }
      v42 = v75 + 1;
      v43 = v75 + 1 >= (unint64_t)v10;
      LODWORD(v11) = v73;
    }
    while (v75 + 1 != v10);
  }
  v69 = 1;
  return v69 & 1;
}

void sub_1B18D5448(void **a1)
{
  free(a1[9]);
  a1[9] = 0;
  free(a1[10]);
  a1[10] = 0;
  free(a1[11]);
  a1[11] = 0;
}

_QWORD *sub_1B18D5488(_QWORD *__dst, void *__src, size_t __len)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v6 = __dst;
    if (!__len)
      goto LABEL_9;
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

void sub_1B18D552C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;

  if (*(uint64_t *)(a1 + 72) >= 1)
  {
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(a1 + 80);
      *(_QWORD *)(*(_QWORD *)(v3 + 8 * v2) + 40) = 0;
      CFRelease(*(CFTypeRef *)(v3 + 8 * v2++));
    }
    while (v2 < *(_QWORD *)(a1 + 72));
  }
  v4 = *(void **)(a1 + 80);
  if (v4)
    free(v4);
  v5 = *(const __CFArray **)(a1 + 120);
  if (v5)
  {
    Count = CFArrayGetCount(v5);
    if (Count >= 1)
    {
      v7 = Count;
      for (i = 0; i != v7; ++i)
        *((_QWORD *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 120), i) + 16) = 0;
    }
  }
  if ((*(_BYTE *)(a1 + 88) & 0x10) != 0)
    sub_1B18D561C(a1);
  v9 = *(const void **)(a1 + 120);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v10 = *(const void **)(a1 + 104);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v11 = *(const void **)(a1 + 144);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 144) = 0;
  }
  v12 = *(const void **)(a1 + 152);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a1 + 152) = 0;
  }

}

void sub_1B18D561C(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 96);
  if (v2)
  {
    if (*(_QWORD *)v2)
    {
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(v2 + 16), (CFDictionaryApplierFunction)sub_1B18D7130, *(void **)v2);
      v2 = *(_QWORD *)(a1 + 96);
    }
    if (*(_QWORD *)(v2 + 16))
    {
      CFRelease(*(CFTypeRef *)(v2 + 16));
      v2 = *(_QWORD *)(a1 + 96);
      *(_QWORD *)(v2 + 16) = 0;
    }
    if (*(_QWORD *)v2)
    {
      free(*(void **)v2);
      v2 = *(_QWORD *)(a1 + 96);
    }
    free((void *)v2);
    *(_QWORD *)(a1 + 96) = 0;
  }
}

uint64_t sub_1B18D5690()
{
  if (qword_1ED4CEC68 != -1)
    dispatch_once(&qword_1ED4CEC68, &unk_1E63D0FD0);
  return qword_1ED4CEC70;
}

void sub_1B18D56D0()
{
  if (!qword_1ED4CEC70)
  {
    qword_1ED4CEC70 = sub_1B179CB60(&qword_1ED4CEC70);
    qword_1ED4BDDE8 = (uint64_t)sub_1B18D7194;
  }
}

uint64_t sub_1B18D5720(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"description");
  if (qword_1ED4CEC68 != -1)
    dispatch_once(&qword_1ED4CEC68, &unk_1E63D0FD0);
  v10 = sub_1B179CB90(qword_1ED4CEC70, 0x90uLL);
  sub_1B18D57EC(v10, a1, v11, v12, v13, v14, v15, v16);
  if (!v10)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v18, v19, v20, v21, v22, v23, (uint64_t)"td");
  *(_QWORD *)(v10 + 112) = a2;
  sub_1B18D5864(v10, v17, v18, v19, v20, v21, v22, v23);
  *(_DWORD *)(v10 + 92) = -1;
  return v10;
}

CFTypeRef sub_1B18D57EC(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"td");
  result = *(CFTypeRef *)(a1 + 104);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 104) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 104) = result;
  }
  return result;
}

uint64_t sub_1B18D5864(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  CFIndex v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t i;
  void *v36;
  void *v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __CFString *v45;
  const char *v46;
  uint64_t v47;
  unsigned __int8 v48;
  CFComparisonResult v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const char *v54;
  CFTypeID v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  CFTypeID v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t j;
  const __CFString *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  const char *v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  const char *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  const void *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  const char *v112;
  uint64_t v113;
  const void *v114;
  const char *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  const void *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  const char *v129;
  uint64_t v130;
  const void *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  const char *v138;
  uint64_t v139;
  void *v140;
  const char *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  char v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  const __CFDictionary *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  const __CFDictionary *v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  const char *v171;
  uint64_t v172;
  void *v173;
  const char *v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  const void *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  const void *v191;
  const char *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  const __CFDictionary *v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  const char *v211;
  uint64_t v212;
  CFMutableSetRef Mutable;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  __CFSet *v220;
  uint64_t v221;
  char v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t *v227;
  uint64_t v228;
  unint64_t v229;
  unint64_t v230;
  unsigned int v231;
  _DWORD *v232;
  unsigned int v233;
  const void *v234;
  unsigned int v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t *v241;
  int v242;
  uint64_t v243;
  unsigned int v244;
  uint64_t v245;
  uint64_t v246;
  BOOL v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  _BOOL4 v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  char v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  char v274;
  char v275;
  uint64_t v277;
  uint64_t size;
  id obj;
  CFTypeRef cf;
  CFTypeRef cfa;
  void *v282;
  int v283;
  unsigned __int8 v284;
  __int128 v285;
  __int128 v286;
  __int128 v287;
  __int128 v288;
  __int128 v289;
  __int128 v290;
  __int128 v291;
  __int128 v292;
  _BYTE v293[128];
  _BYTE v294[128];
  uint64_t v295;

  v295 = *MEMORY[0x1E0C80C00];
  v9 = *(_BYTE *)(a1 + 88);
  if ((v9 & 1) != 0)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. compiling a renderGraph twice"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph->_isCompiled==false");
    v9 = *(_BYTE *)(a1 + 88);
  }
  *(_BYTE *)(a1 + 88) = v9 | 1;
  v10 = *(void **)(a1 + 104);
  cf = *(CFTypeRef *)(a1 + 112);
  *(_QWORD *)(a1 + 144) = (id)objc_msgSend_valueForKey_(v10, a2, (uint64_t)CFSTR("bundle"), a4);
  *(_QWORD *)(a1 + 152) = (id)objc_msgSend_valueForKey_(v10, v11, (uint64_t)CFSTR("metalLibraryName"), v12);
  v15 = (void *)objc_msgSend_valueForKey_(v10, v13, (uint64_t)CFSTR("sequence"), v14);
  v282 = (void *)objc_msgSend_valueForKey_(v10, v16, (uint64_t)CFSTR("passes"), v17);
  obj = v15;
  size = objc_msgSend_count(v15, v18, v19, v20);
  v26 = (void *)objc_msgSend_valueForKey_(v10, v21, (uint64_t)CFSTR("symbols"), v22);
  if (!*(_QWORD *)(a1 + 96))
  {
    *(_QWORD *)(a1 + 96) = malloc_type_calloc(0x18uLL, 1uLL, 0xBF75870FuLL);
    *(_BYTE *)(a1 + 88) |= 0x10u;
  }
  v27 = objc_msgSend_count(v26, v23, v24, v25);
  *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16) = CFDictionaryCreateMutable(0, v27, MEMORY[0x1E0C9B390], 0);
  v291 = 0u;
  v292 = 0u;
  v289 = 0u;
  v290 = 0u;
  v29 = objc_msgSend_countByEnumeratingWithState_objects_count_(v26, v28, (uint64_t)&v289, (uint64_t)v294, 16);
  if (v29)
  {
    v33 = v29;
    v34 = *(_QWORD *)v290;
    do
    {
      for (i = 0; i != v33; ++i)
      {
        if (*(_QWORD *)v290 != v34)
          objc_enumerationMutation(v26);
        v36 = *(void **)(*((_QWORD *)&v289 + 1) + 8 * i);
        v37 = (void *)objc_msgSend_valueForKey_(v26, v30, (uint64_t)v36, v32);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          if (!objc_msgSend_valueForKey_(v37, v38, (uint64_t)CFSTR("semantic"), v40))
          {
            v45 = (__CFString *)objc_msgSend_valueForKey_(v37, v30, (uint64_t)CFSTR("type"), v32);
            if ((objc_msgSend_isEqualToString_(v45, v46, (uint64_t)CFSTR("color"), v47) & 1) == 0
              && (objc_msgSend_isEqualToString_(v45, v30, (uint64_t)CFSTR("depth"), v32) & 1) == 0)
            {
              v48 = sub_1B179E2A4(v45);
              v49 = sub_1B179E324(v45);
              if ((_DWORD)v49)
                sub_1B18D6528(a1, v36, v49, v48, v50, v51, v52, v53);
            }
          }
        }
        else
        {
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: invalue description for input named %@ - expect a dictionary"), v39, v40, v41, v42, v43, v44, (uint64_t)v36);
        }
      }
      v33 = objc_msgSend_countByEnumeratingWithState_objects_count_(v26, v30, (uint64_t)&v289, (uint64_t)v294, 16);
    }
    while (v33);
  }
  if (!size)
  {
    if (objc_msgSend_count(v282, v30, v31, v32))
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXFXRenderGraphCompile - invalid description (sequence missing or empty) %@"), v64, v65, v66, v67, v68, v69, (uint64_t)v10);
    return 1;
  }
  *(_QWORD *)(a1 + 80) = malloc_type_calloc(8uLL, size, 0xDF1982DDuLL);
  *(_QWORD *)(a1 + 64) = size;
  if (cf)
  {
    v55 = CFGetTypeID(cf);
    if (v55 == sub_1B187A3A8())
    {
      v63 = sub_1B187A934((uint64_t)cf, v56, v57, v58, v59, v60, v61, v62);
    }
    else
    {
      v70 = CFGetTypeID(cf);
      if (v70 == sub_1B1869F5C())
        v63 = (uint64_t)cf;
      else
        v63 = 0;
    }
  }
  else
  {
    v63 = 0;
  }
  v287 = 0u;
  v288 = 0u;
  v285 = 0u;
  v286 = 0u;
  v71 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v54, (uint64_t)&v285, (uint64_t)v293, 16);
  if (v71)
  {
    v72 = v71;
    v73 = 0;
    cfa = *(CFTypeRef *)v286;
    do
    {
      for (j = 0; j != v72; ++j)
      {
        if (*(CFTypeRef *)v286 != cfa)
          objc_enumerationMutation(obj);
        v75 = *(const __CFString **)(*((_QWORD *)&v285 + 1) + 8 * j);
        v76 = sub_1B19ACAD0();
        sub_1B19ACFA0(v76, v75, v77, v78, v79, v80, v81, v82);
        v85 = (void *)objc_msgSend_valueForKey_(v282, v83, (uint64_t)v75, v84);
        sub_1B19AD2C8(v76, v85, (uint64_t)v10, v86, v87, v88, v89, v90);
        if (!sub_1B19ACE28(v76, v91, v92, v93, v94, v95, v96, v97))
        {
          v105 = (const void *)objc_msgSend_objectForKey_(v85, v98, (uint64_t)CFSTR("program"), v100);
          sub_1B19ACB84(v76, v105, v106, v107, v108, v109, v110, v111);
          v114 = (const void *)objc_msgSend_objectForKey_(v85, v112, (uint64_t)CFSTR("metalLibraryFile"), v113);
          if (v114)
            sub_1B19ACCEC(v76, v114, v116, v117, v118, v119, v120, v121);
          v122 = (const void *)objc_msgSend_objectForKey_(v85, v115, (uint64_t)CFSTR("metalVertexShader"), v117);
          sub_1B19ACBFC(v76, v122, v123, v124, v125, v126, v127, v128);
          v131 = (const void *)objc_msgSend_objectForKey_(v85, v129, (uint64_t)CFSTR("metalFragmentShader"), v130);
          sub_1B19ACC74(v76, v131, v132, v133, v134, v135, v136, v137);
          v140 = (void *)objc_msgSend_objectForKey_(v85, v138, (uint64_t)CFSTR("clientProgram"), v139);
          if (v140)
            v148 = objc_msgSend_BOOLValue(v140, v141, v142, v143);
          else
            v148 = 1;
          sub_1B19ACD64(v76, v148, v142, v143, v144, v145, v146, v147);
        }
        v149 = *(_DWORD *)(v76 + 24);
        if (v149 == 6 || v149 == 3)
        {
          v150 = *(_QWORD *)(v76 + 96);
          if (v150)
          {
            v151 = sub_1B18786DC(v150, (uint64_t)v98, v99, v100, v101, v102, v103, v104);
            if (v151)
            {
              v157 = v151;
              if (*(uint64_t *)(v151 + 72) <= 0)
                sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. CFXFXRenderGraphGetPassAtIndex index %ld is out of bounds (%ld)"), v152, v100, v153, v154, v155, v156, (uint64_t)"index < renderGraph->_count");
              v158 = **(_QWORD **)(v157 + 80);
              if (v158)
              {
                v159 = (const __CFDictionary *)objc_msgSend_valueForKey_(v85, v98, (uint64_t)CFSTR("inputs"), v100);
                sub_1B19AE718(v158, v159, v157, v160, v161, v162, v163, v164);
              }
            }
          }
        }
        v165 = (const __CFDictionary *)objc_msgSend_valueForKey_(v85, v98, (uint64_t)CFSTR("inputs"), v100);
        sub_1B19AE718(v76, v165, a1, v166, v167, v168, v169, v170);
        v173 = (void *)objc_msgSend_valueForKey_(v10, v171, (uint64_t)CFSTR("owners"), v172);
        v176 = objc_msgSend_objectAtIndex_(v173, v174, v73 + j, v175);
        v177 = sub_1B18D6C9C((uint64_t)CFSTR("pointOfView"), v85, a1, v176, v63, (const void **)(v76 + 504));
        if (v177)
          sub_1B19AD0E0(v76, v177, v178, v179, v180, v181, v182, v183);
        v184 = (const void *)sub_1B18D6C9C((uint64_t)CFSTR("mirrorNode"), v85, a1, v176, v63, (const void **)(v76 + 496));
        if (v184)
          sub_1B19AD1A4(v76, v184, v185, v186, v187, v188, v189, v190);
        v191 = (const void *)sub_1B18D6C9C((uint64_t)CFSTR("node"), v85, a1, v176, v63, (const void **)(v76 + 488));
        if (v191)
          sub_1B19AD12C(v76, v191, v193, v194, v195, v196, v197, v198);
        v199 = (const __CFDictionary *)objc_msgSend_valueForKey_(v85, v192, (uint64_t)CFSTR("outputs"), v194);
        sub_1B19AEA54(v76, v199, a1, v200, v201, v202, v203, v204);
        sub_1B18D62F4((_QWORD *)a1, (CFTypeRef)v76, v205, v206, v207, v208, v209, v210, v277);
        CFRelease((CFTypeRef)v76);
      }
      v72 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v211, (uint64_t)&v285, (uint64_t)v293, 16);
      v73 += j;
    }
    while (v72);
  }
  v212 = *(_QWORD *)(a1 + 72);
  Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  v220 = Mutable;
  if (v212 < 1)
  {
    CFRelease(Mutable);
    v265 = *(_BYTE *)(a1 + 88);
    goto LABEL_118;
  }
  v221 = 0;
  v283 = 0;
  v222 = 0;
  do
  {
    v223 = sub_1B18D6464(a1, v221, v214, v215, v216, v217, v218, v219);
    v225 = v223;
    if ((v222 & 1) == 0 && (v283 & 1) == 0)
    {
      v226 = *(_QWORD *)(v223 + 520);
      if (v226 < 1)
        goto LABEL_66;
      v222 = 0;
      v227 = *(uint64_t **)(v223 + 512);
      do
      {
        v228 = *v227++;
        v222 |= *(_BYTE *)(v228 + 88);
        --v226;
      }
      while (v226);
    }
    if ((v222 & 1) != 0)
    {
      v222 = 1;
      goto LABEL_67;
    }
LABEL_66:
    v222 = 0;
    v283 |= *(unsigned __int8 *)(v223 + 186) >> 7;
LABEL_67:
    if (*(_DWORD *)(v223 + 440))
    {
      v229 = 0;
      do
      {
        v284 = 0;
        v230 = *(_QWORD *)(v225 + 432) + (v229 << 6);
        v233 = *(_DWORD *)(v230 + 20);
        v232 = (_DWORD *)(v230 + 20);
        v231 = v233;
        v234 = *(const void **)(v232 - 3);
        if (v234)
        {
          if (v231 > 0x7FFFFFFD)
          {
            if (v231 == 0x7FFFFFFF)
              v235 = 0x7FFFFFFF;
            else
              v235 = 2147483646;
          }
          else
          {
            v235 = sub_1B18D6D84(a1, v234, v221, (uint64_t)&v284, 0, v217, v218, v219);
          }
          if (!CFSetContainsValue(v220, v234))
          {
            CFSetAddValue(v220, v234);
            *(_DWORD *)(*(_QWORD *)(v225 + 432) + (v229 << 6) + 20) = v235;
          }
          if (v284)
            *(_DWORD *)(v225 + 184) |= 0x10u;
          if (v235 >= 2)
            *(_DWORD *)(v225 + 184) |= 0x400000u;
        }
        else
        {
          *v232 = v231 + 1;
          v236 = v221 + 1;
          if (v221 + 1 < v212)
          {
            do
            {
              v237 = sub_1B18D6464(a1, v236, v214, v215, v216, v217, v218, v219);
              v238 = *(_QWORD *)(v237 + 520);
              if (v238 >= 1)
              {
                v239 = *(_QWORD *)(v237 + 512);
                do
                {
                  if ((*(_BYTE *)(*(_QWORD *)v239 + 88) & 3) != 0)
                    ++*(_DWORD *)(*(_QWORD *)(v225 + 432) + (v229 << 6) + 20);
                  v239 += 8;
                  --v238;
                }
                while (v238);
              }
              v240 = *(unsigned int *)(v237 + 440);
              if ((_DWORD)v240)
              {
                v241 = (uint64_t *)(*(_QWORD *)(v237 + 432) + 8);
                LOBYTE(v242) = 1;
                do
                {
                  v243 = *v241;
                  v241 += 8;
                  v242 = (v243 != 0) & v242;
                  --v240;
                }
                while (v240);
              }
              else
              {
                v242 = 1;
              }
              ++v236;
            }
            while (v236 < v212 && v242);
          }
        }
        ++v229;
      }
      while (v229 < *(unsigned int *)(v225 + 440));
    }
    v244 = *(_DWORD *)(v225 + 184);
    if ((v244 & 0x800010) == 0x800000)
    {
      v284 = 0;
      sub_1B18D6D84(a1, CFSTR("COLOR"), v221, (uint64_t)&v284, 1, v217, v218, v219);
      v244 = *(_DWORD *)(v225 + 184) & 0xFFFFFFEF | (16 * v284);
      *(_DWORD *)(v225 + 184) = v244;
    }
    if ((v244 & 0x400000) == 0)
    {
      if ((v244 & 0x800000) != 0)
      {
        v245 = *(_QWORD *)(a1 + 72);
        v246 = v221 + 1;
        if (v221 + 1 < v245)
        {
          v247 = 1;
          while (1)
          {
            v248 = sub_1B18D6464(a1, v246, v214, v215, v216, v217, v218, v219);
            v249 = *(_QWORD *)(v248 + 520);
            if (v249 >= 1)
              break;
LABEL_106:
            v247 = ++v246 < v245;
            if (v246 == v245)
              goto LABEL_107;
          }
          v250 = *(_QWORD *)(v248 + 512);
          while ((*(_BYTE *)(*(_QWORD *)v250 + 88) & 1) == 0)
          {
            v250 += 8;
            if (!--v249)
              goto LABEL_106;
          }
LABEL_107:
          v244 = *(_DWORD *)(v225 + 184);
          if (v247)
            goto LABEL_110;
        }
      }
      if ((v244 & 0x1000000) != 0
        && (v251 = sub_1B18D6BE8(a1, v221, v214, v215, v216, v217, v218, v219), v244 = *(_DWORD *)(v225 + 184), v251))
      {
LABEL_110:
        *(_DWORD *)(v225 + 184) = v244 | 0x400000;
      }
      else if ((v244 & 0x1A00000) == 0x200000)
      {
        v252 = sub_1B19AD04C(v225, v224, v214, v215, v216, v217, v218, v219);
        sub_1B17C4408(0, (uint64_t)CFSTR("Info: pass named %@ appears to be useless - skipping"), v253, v254, v255, v256, v257, v258, v252);
        sub_1B19ACB7C(v225, 0);
      }
    }
    ++v221;
  }
  while (v221 != v212);
  CFRelease(v220);
  v265 = *(_BYTE *)(a1 + 88);
  if ((v283 & 1) != 0)
    v265 |= 8u;
LABEL_118:
  *(_BYTE *)(a1 + 88) = v265 | 4;
  if (size >= 1)
  {
    v266 = sub_1B18D6464(a1, size - 1, v259, v260, v261, v262, v263, v264);
    if (v266)
    {
      if ((*(_BYTE *)(v266 + 185) & 1) != 0)
      {
        if (sub_1B19ACE70(v266, v267, v268, v269, v270, v271, v272, v273))
          v275 = 4;
        else
          v275 = 0;
        v274 = *(_BYTE *)(a1 + 88) & 0xFB | v275;
      }
      else
      {
        v274 = *(_BYTE *)(a1 + 88) & 0xFB;
      }
      *(_BYTE *)(a1 + 88) = v274;
    }
  }
  return 1;
}

uint64_t sub_1B18D623C(size_t a1)
{
  uint64_t v2;
  void *v3;

  if (qword_1ED4CEC68 != -1)
    dispatch_once(&qword_1ED4CEC68, &unk_1E63D0FD0);
  v2 = sub_1B179CB90(qword_1ED4CEC70, 0x90uLL);
  if (a1)
    v3 = malloc_type_calloc(8uLL, a1, 0x4CD25E05uLL);
  else
    v3 = 0;
  *(_QWORD *)(v2 + 80) = v3;
  *(_QWORD *)(v2 + 64) = a1;
  *(_DWORD *)(v2 + 92) = -1;
  return v2;
}

uint64_t sub_1B18D62C8()
{
  uint64_t result;

  result = qword_1EEF66150;
  if (!qword_1EEF66150)
  {
    result = sub_1B18D623C(0);
    qword_1EEF66150 = result;
  }
  return result;
}

void sub_1B18D62F4(_QWORD *a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFTypeRef v11;
  uint64_t v12;
  uint64_t v13;

  if (a1)
  {
    if (cf)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
    if (cf)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"pass");
LABEL_3:
  if (a1[9] >= a1[8])
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXFXRenderGraphAppendPass out of capacity"), a3, a4, a5, a6, a7, a8, a9);
  }
  else
  {
    v11 = CFRetain(cf);
    v13 = a1[9];
    v12 = a1[10];
    a1[9] = v13 + 1;
    *(_QWORD *)(v12 + 8 * v13) = v11;
    *((_QWORD *)cf + 5) = a1;
  }
}

uint64_t sub_1B18D63A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  return *(_QWORD *)(a1 + 72);
}

uint64_t sub_1B18D63F0(uint64_t a1, CFTypeRef cf1)
{
  uint64_t v2;
  uint64_t v5;
  const void *v6;

  v2 = *(_QWORD *)(a1 + 72);
  if (v2 < 1)
    return 0;
  v5 = 0;
  while (1)
  {
    v6 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v5) + 16);
    if (v6)
      break;
LABEL_6:
    if (++v5 >= v2)
      return 0;
  }
  if (!CFEqual(cf1, v6))
  {
    v2 = *(_QWORD *)(a1 + 72);
    goto LABEL_6;
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v5);
}

uint64_t sub_1B18D6464(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  if (*(_QWORD *)(a1 + 72) <= a2)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. CFXFXRenderGraphGetPassAtIndex index %ld is out of bounds (%ld)"), a3, a4, a5, a6, a7, a8, (uint64_t)"index < renderGraph->_count");
  return *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * a2);
}

uint64_t sub_1B18D64E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  return *(_QWORD *)(a1 + 104);
}

void sub_1B18D6528(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  int v9;
  _QWORD *v12;
  const __CFDictionary *Mutable;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const void *v26;
  uint64_t v27;
  uint64_t v28;
  __CFDictionary *v29;

  v8 = a4;
  v9 = a3;
  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
    if (key)
      goto LABEL_3;
LABEL_16:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"symbolName");
    goto LABEL_3;
  }
  if (!key)
    goto LABEL_16;
LABEL_3:
  v12 = *(_QWORD **)(a1 + 96);
  if (!v12
    || *v12
    && (sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Must declare upfront"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph->_parameterStorage == NULL || renderGraph->_parameterStorage->storage == NULL"), (v12 = *(_QWORD **)(a1 + 96)) == 0))
  {
    v12 = malloc_type_calloc(0x18uLL, 1uLL, 0xBF75870FuLL);
    *(_QWORD *)(a1 + 96) = v12;
    *(_BYTE *)(a1 + 88) |= 0x10u;
  }
  Mutable = (const __CFDictionary *)v12[2];
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], 0);
    *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16) = Mutable;
  }
  if (CFDictionaryGetValue(Mutable, key))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Cannot declare twice the same symbol (%@)"), v15, v16, v17, v18, v19, v20, (uint64_t)"CFDictionaryGetValue(renderGraph->_parameterStorage->parameters, symbolName) == 0");
  v21 = *(int **)(a1 + 96);
  if (v9 == 5)
  {
    v22 = *v21;
    v23 = *((_QWORD *)v21 + 1);
    v24 = (v22 + (int)v23) & 7;
  }
  else
  {
    v24 = 0;
    v23 = *((_QWORD *)v21 + 1);
  }
  v25 = v8;
  v26 = (const void *)((((_DWORD)v23 + (_DWORD)v24) << 16) | ((unint64_t)v8 << 8) | v9 & 0x3F);
  v27 = v24 + sub_1B179E250(v9, v14, v15, v16, v17, v18, v19, v20) * v25;
  v28 = *(_QWORD *)(a1 + 96);
  v29 = *(__CFDictionary **)(v28 + 16);
  *(_QWORD *)(v28 + 8) += v27;
  CFDictionarySetValue(v29, key, v26);
}

void sub_1B18D66B4(uint64_t a1, void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  const void *Value;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFTypeID v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const void *v35;
  int v36;
  size_t v37;
  uint64_t *v38;
  uint64_t v39;
  const void *v40;
  uint64_t *v41;
  uint64_t v42;
  const void *v43;

  v8 = a4;
  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
    if (a2)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"paramName");
LABEL_3:
  if (!*(_QWORD *)(a1 + 96))
  {
    *(_QWORD *)(a1 + 96) = malloc_type_calloc(0x18uLL, 1uLL, 0xBF75870FuLL);
    *(_BYTE *)(a1 + 88) |= 0x10u;
  }
  sub_1B18D6900((_QWORD *)a1);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 96) + 16), a2);
  if (Value)
  {
    v20 = WORD1(Value);
    if ((Value & 0x3F) == 5)
    {
      if (v8 != 1)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Assumed count is 1"), v14, v15, v16, v17, v18, v19, (uint64_t)"count == 1");
      if (a3)
      {
        v21 = CFGetTypeID(a3);
        if (v21 == sub_1B18091DC())
        {
          v22 = sub_1B18091DC();
          if (v22 == CFGetTypeID(a3))
          {
            v35 = (const void *)sub_1B18D694C(a1, a2, 0, v24, v25, v26, v27, v28);
            if (!v35)
            {
              v35 = (const void *)sub_1B192097C();
              sub_1B18D66B4(a1, a2, v35, 1);
              CFRelease(v35);
            }
            sub_1B1920A08((uint64_t)v35, a3, v29, v30, v31, v32, v33, v34);
          }
          else
          {
            sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXFXRenderGraphSetValueForSymbol - expect an image for paramName %@"), v23, v24, v25, v26, v27, v28, (uint64_t)a2);
          }
        }
        else
        {
          v41 = *(uint64_t **)(a1 + 96);
          v42 = *v41;
          v43 = *(const void **)(*v41 + v20);
          if (v43 != a3)
          {
            if (v43)
            {
              CFRelease(v43);
              *(_QWORD *)(v42 + v20) = 0;
            }
            *(_QWORD *)(v42 + v20) = CFRetain(a3);
          }
        }
      }
      else
      {
        v38 = *(uint64_t **)(a1 + 96);
        v39 = *v38;
        v40 = *(const void **)(*v38 + v20);
        if (v40)
        {
          CFRelease(v40);
          *(_QWORD *)(v39 + v20) = 0;
        }
      }
    }
    else if (a3)
    {
      if (BYTE1(Value) >= v8)
        v36 = v8;
      else
        v36 = BYTE1(Value);
      v37 = sub_1B179E250(Value & 0x3F, v13, v14, v15, v16, v17, v18, v19) * v36;
      memcpy((void *)(**(_QWORD **)(a1 + 96) + v20), a3, v37);
    }
  }
  else
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXFXRenderGraphSetValueForSymbol - unknown param named %@"), v14, v15, v16, v17, v18, v19, (uint64_t)a2);
  }
}

_QWORD *sub_1B18D6900(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)result[12];
  if (v1 && !*v1)
  {
    v2 = result;
    result = (_QWORD *)v1[1];
    if (result)
    {
      result = malloc_type_calloc((size_t)result, 1uLL, 0x39AC6DDAuLL);
      *(_QWORD *)v2[12] = result;
    }
  }
  return result;
}

uint64_t sub_1B18D694C(uint64_t a1, void *a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  __int16 v18;

  if (a1)
  {
    if (a2)
      goto LABEL_4;
    goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  if (!a2)
LABEL_3:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"paramName");
LABEL_4:
  sub_1B18D6900((_QWORD *)a1);
  v18 = 0;
  v15 = sub_1B18D6A34(a1, a2, &v18, 0, v11, v12, v13, v14);
  if (v15 == -1)
    return 0;
  v16 = v15;
  if (a3)
    *a3 = v18;
  sub_1B18D6900((_QWORD *)a1);
  result = **(_QWORD **)(a1 + 96) + v16;
  if (v18 == 5)
    return *(_QWORD *)result;
  return result;
}

void sub_1B18D6A2C(uint64_t a1, void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B18D66B4(a1, a2, a3, 1, a5, a6, a7, a8);
}

uint64_t sub_1B18D6A34(uint64_t a1, void *key, _WORD *a3, BOOL *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  const __CFDictionary *v13;
  unint64_t Value;
  char v15;
  uint64_t result;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
    if (key)
      goto LABEL_3;
LABEL_13:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"paramName");
    goto LABEL_3;
  }
  if (!key)
    goto LABEL_13;
LABEL_3:
  v12 = *(_QWORD *)(a1 + 96);
  if (v12
    && (v13 = *(const __CFDictionary **)(v12 + 16)) != 0
    && (Value = (unint64_t)CFDictionaryGetValue(v13, key),
        Value & 0xFFFFFFFF0000FFFFLL | ((unint64_t)WORD1(Value) << 16)))
  {
    v15 = Value;
    result = WORD1(Value);
    if (a3)
      *a3 = v15 & 0x3F;
    if (a4)
      *a4 = (v15 & 0x40) != 0;
  }
  else
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXFXRenderGraphGetValueForSymbol - unknown param named %@"), (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)key);
    return -1;
  }
  return result;
}

uint64_t sub_1B18D6B18(uint64_t a1, void *a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int16 v18;

  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
    if (a2)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"paramName");
LABEL_3:
  sub_1B18D6900((_QWORD *)a1);
  v18 = 0;
  v15 = sub_1B18D6A34(a1, a2, &v18, 0, v11, v12, v13, v14);
  if (v15 == -1)
    return 0;
  v16 = v15;
  if (a3)
    *a3 = v18;
  sub_1B18D6900((_QWORD *)a1);
  return **(_QWORD **)(a1 + 96) + v16;
}

BOOL sub_1B18D6BE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  v10 = *(_QWORD *)(a1 + 72);
  v11 = a2 + 1;
  if (v11 >= v10)
  {
    return 0;
  }
  else
  {
    v12 = 1;
    while (1)
    {
      v13 = sub_1B18D6464(a1, v11, a3, a4, a5, a6, a7, a8);
      v14 = *(_QWORD *)(v13 + 520);
      if (v14 >= 1)
        break;
LABEL_9:
      v12 = ++v11 < v10;
      if (v11 == v10)
        return v12;
    }
    v15 = *(_QWORD *)(v13 + 512);
    while ((*(_BYTE *)(*(_QWORD *)v15 + 88) & 2) == 0)
    {
      v15 += 8;
      if (!--v14)
        goto LABEL_9;
    }
  }
  return v12;
}

uint64_t sub_1B18D6C9C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, const void **a6)
{
  uint64_t v8;
  void *v10;
  const char *v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v21;

  v8 = a4;
  v10 = (void *)objc_msgSend_objectForKey_(a2, (const char *)a2, a1, a4);
  if (v10)
  {
    v13 = v10;
    if (objc_msgSend_isEqualToString_(v10, v11, (uint64_t)CFSTR("self"), v12))
    {
      if (!v8)
      {
        if (!a3)
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v14, v15, v16, v17, v18, v19, (uint64_t)"td");
        return *(_QWORD *)(a3 + 112);
      }
      return v8;
    }
    if (a5)
      return sub_1B186BF28(a5, (uint64_t)v13, v14, v15, v16, v17, v18, v19);
    v21 = *a6;
    if (*a6 != v13)
    {
      if (v21)
      {
        CFRelease(v21);
        *a6 = 0;
      }
      v8 = 0;
      *a6 = CFRetain(v13);
      return v8;
    }
  }
  return 0;
}

uint64_t sub_1B18D6D84(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  unint64_t v21;
  uint64_t v22;
  const void *v23;
  char v24;
  int v26;
  _BYTE *v27;
  uint64_t v28;

  v8 = a5;
  v12 = a1;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  v13 = *(_QWORD *)(v12 + 72);
  v14 = a3 + 1;
  v27 = (_BYTE *)a4;
  v26 = v8;
  if (a3 + 1 >= v13)
  {
    LOBYTE(v16) = 0;
    LOBYTE(v15) = 0;
    v17 = 1;
  }
  else
  {
    v15 = 0;
    v16 = 0;
    v17 = 1;
    v28 = v12;
    do
    {
      v18 = sub_1B18D6464(v12, v14, a3, a4, a5, a6, a7, a8);
      if (*(uint64_t *)(v18 + 520) >= 1)
      {
        v19 = 0;
        do
        {
          v20 = *(const void **)(*(_QWORD *)(*(_QWORD *)(v18 + 512) + 8 * v19) + 56);
          if (v20 && CFEqual(v20, a2))
          {
            ++v17;
            v16 |= v15 ^ 1;
          }
          ++v19;
        }
        while (v19 < *(_QWORD *)(v18 + 520));
      }
      if (*(_DWORD *)(v18 + 440))
      {
        v21 = 0;
        v22 = 8;
        do
        {
          v23 = *(const void **)(*(_QWORD *)(v18 + 432) + v22);
          if (v23 && CFEqual(v23, a2))
          {
            v15 |= v16 ^ 1;
            ++v17;
          }
          ++v21;
          v22 += 64;
        }
        while (v21 < *(unsigned int *)(v18 + 440));
      }
      ++v14;
      v12 = v28;
    }
    while (v14 != v13);
  }
  if (v27)
  {
    if (v26)
      v24 = ~(_BYTE)v15;
    else
      v24 = v16;
    *v27 = v24 & 1;
  }
  return v17;
}

uint64_t sub_1B18D6F04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  return (*(unsigned __int8 *)(a1 + 88) >> 1) & 1;
}

uint64_t sub_1B18D6F50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  return (*(unsigned __int8 *)(a1 + 88) >> 2) & 1;
}

void sub_1B18D6F9C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v10;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  if (a2)
    v10 = 4;
  else
    v10 = 0;
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a1 + 88) & 0xFB | v10;
}

uint64_t sub_1B18D7000(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  return *(_QWORD *)(a1 + 128);
}

void sub_1B18D7048(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t i;
  void (*v11)(void);

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  v9 = *(_QWORD *)(a1 + 72);
  if (v9 >= 1)
  {
    for (i = 0; i != v9; ++i)
    {
      v11 = *(void (**)(void))(sub_1B18D6464(a1, i, a3, a4, a5, a6, a7, a8) + 232);
      if (v11)
        v11();
    }
  }
}

uint64_t sub_1B18D70D0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (result)
  {
    v8 = result;
    if (*(uint64_t *)(result + 72) <= 0)
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. CFXFXRenderGraphGetPassAtIndex index %ld is out of bounds (%ld)"), a3, a4, a5, a6, a7, a8, (uint64_t)"index < renderGraph->_count");
    return sub_1B19ACE28(**(_QWORD **)(v8 + 80), a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

void sub_1B18D7130(uint64_t a1, int a2, uint64_t a3)
{
  const void *v3;

  if ((a2 & 0x3F) == 5)
  {
    v3 = *(const void **)(a3 + HIWORD(a2));
    if (v3)
      CFRelease(v3);
  }
}

CFStringRef sub_1B18D7154(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXFXRenderGraph>"));
}

CFStringRef sub_1B18D7174(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXFXRenderGraph>"));
}

__CFArray *sub_1B18D7194(uint64_t a1)
{
  __CFArray *Mutable;
  uint64_t v3;
  uint64_t v4;
  CFStringRef v5;
  __CFDictionary *v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  __CFDictionary *v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  uint64_t v15;
  int v16;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (*(uint64_t *)(a1 + 72) >= 1)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = CFStringCreateWithFormat(0, 0, CFSTR("pass %d"), v4);
      v6 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v16 = 2;
      valuePtr = 5;
      v15 = *(_QWORD *)(a1 + 80) + v3;
      v7 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      v8 = CFNumberCreate(0, kCFNumberSInt32Type, &v16);
      v9 = CFNumberCreate(0, kCFNumberLongType, &v15);
      CFDictionarySetValue(v6, CFSTR("name"), v5);
      CFDictionarySetValue(v6, CFSTR("type"), v7);
      CFDictionarySetValue(v6, CFSTR("address"), v9);
      CFDictionarySetValue(v6, CFSTR("semantic"), v8);
      CFArrayAppendValue(Mutable, v6);
      CFRelease(v8);
      CFRelease(v6);
      CFRelease(v9);
      CFRelease(v7);
      CFRelease(v5);
      ++v4;
      v3 += 8;
    }
    while (v4 < *(_QWORD *)(a1 + 72));
  }
  v10 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v16 = 2;
  valuePtr = 5;
  v15 = a1 + 104;
  v11 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v12 = CFNumberCreate(0, kCFNumberSInt32Type, &v16);
  v13 = CFNumberCreate(0, kCFNumberLongType, &v15);
  CFDictionarySetValue(v10, CFSTR("name"), CFSTR("plist"));
  CFDictionarySetValue(v10, CFSTR("type"), v11);
  CFDictionarySetValue(v10, CFSTR("address"), v13);
  CFDictionarySetValue(v10, CFSTR("semantic"), v12);
  CFArrayAppendValue(Mutable, v10);
  CFRelease(v12);
  CFRelease(v10);
  CFRelease(v13);
  CFRelease(v11);
  return Mutable;
}

uint64_t sub_1B18D742C(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  char v7;
  int v8;
  __int16 v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  BOOL v17;
  int v18;

  if (a4 == a3)
    return 0;
  v4 = 0;
  *(_WORD *)(a1 + 7) = 257;
  *(_BYTE *)(a1 + 9) = 1;
  if (a4 > 36755)
  {
    if (a4 > 37807)
    {
      switch(a4)
      {
        case 37808:
        case 37840:
          v5 = 2;
          goto LABEL_66;
        case 37809:
        case 37841:
          *(_DWORD *)a1 = 2;
          v6 = 83952768;
          goto LABEL_86;
        case 37810:
        case 37842:
          *(_DWORD *)a1 = 2;
          v13 = 83952768;
          goto LABEL_49;
        case 37811:
        case 37843:
          *(_DWORD *)a1 = 2;
          v13 = 100729984;
          goto LABEL_49;
        case 37812:
        case 37844:
          *(_DWORD *)a1 = 2;
          v14 = 100729984;
          goto LABEL_51;
        case 37813:
        case 37845:
          *(_DWORD *)a1 = 2;
          v13 = 134284416;
          goto LABEL_49;
        case 37814:
        case 37846:
          *(_DWORD *)a1 = 2;
          v14 = 134284416;
          goto LABEL_51;
        case 37815:
        case 37847:
          *(_DWORD *)a1 = 2;
          v15 = 134284416;
          goto LABEL_53;
        case 37816:
        case 37848:
          *(_DWORD *)a1 = 2;
          v13 = 167838848;
LABEL_49:
          *(_DWORD *)(a1 + 4) = v13;
          v7 = 5;
          goto LABEL_87;
        case 37817:
        case 37849:
          *(_DWORD *)a1 = 2;
          v14 = 167838848;
LABEL_51:
          *(_DWORD *)(a1 + 4) = v14;
          v7 = 6;
          goto LABEL_87;
        case 37818:
        case 37850:
          *(_DWORD *)a1 = 2;
          v15 = 167838848;
LABEL_53:
          *(_DWORD *)(a1 + 4) = v15;
          v7 = 8;
          goto LABEL_87;
        case 37819:
        case 37851:
          *(_DWORD *)a1 = 2;
          v16 = 167838848;
          goto LABEL_56;
        case 37820:
        case 37852:
          *(_DWORD *)a1 = 2;
          v16 = 201393280;
LABEL_56:
          *(_DWORD *)(a1 + 4) = v16;
          v7 = 10;
          goto LABEL_87;
        case 37821:
        case 37853:
          *(_DWORD *)a1 = 2;
          *(_DWORD *)(a1 + 4) = 201393280;
          v7 = 12;
          goto LABEL_87;
        default:
          return v4;
      }
    }
    switch(a4)
    {
      case 37488:
      case 37489:
        *(_DWORD *)a1 = 5;
        v6 = 67109184;
        goto LABEL_86;
      case 37490:
      case 37491:
        *(_DWORD *)a1 = 5;
        v6 = 67109504;
        goto LABEL_86;
      case 37492:
      case 37493:
        v11 = 5;
        goto LABEL_60;
      case 37494:
      case 37495:
        v12 = 5;
        goto LABEL_85;
      case 37496:
      case 37497:
        v5 = 5;
        goto LABEL_66;
      default:
        switch(a4)
        {
          case 36756:
            goto LABEL_26;
          case 36757:
            goto LABEL_69;
          case 36758:
          case 36762:
            return v4;
          case 36759:
            *(_BYTE *)(a1 + 6) = 1;
            *(_WORD *)(a1 + 4) = 1056;
LABEL_119:
            LODWORD(v4) = 72;
            goto LABEL_210;
          case 36760:
            goto LABEL_70;
          case 36761:
            goto LABEL_71;
          case 36763:
            goto LABEL_72;
          default:
            if (a4 == 36975)
              goto LABEL_79;
            break;
        }
        break;
    }
    return v4;
  }
  if (a4 > 35839)
  {
    if (a4 > 36193)
    {
      if (a4 > 36491)
      {
        if ((a4 - 36492) < 2)
        {
          v7 = 4;
          *(_DWORD *)a1 = 4;
          v8 = 67175552;
        }
        else
        {
          if ((a4 - 36494) >= 2)
            return v4;
          v7 = 4;
          *(_DWORD *)a1 = 4;
          v8 = 67109760;
        }
      }
      else if ((a4 - 36283) < 2)
      {
        v7 = 4;
        *(_DWORD *)a1 = 4;
        v8 = 67109184;
      }
      else
      {
        if ((a4 - 36285) >= 2)
        {
          if (a4 != 36194)
            return v4;
          *(_BYTE *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 784;
          goto LABEL_118;
        }
        v7 = 4;
        *(_DWORD *)a1 = 4;
        v8 = 67109504;
      }
      *(_DWORD *)(a1 + 4) = v8;
      goto LABEL_87;
    }
    if (a4 > 35900)
    {
      if (a4 <= 35917)
      {
        if (a4 == 35901)
        {
LABEL_74:
          *(_BYTE *)(a1 + 6) = 1;
          v9 = 800;
LABEL_80:
          *(_WORD *)(a1 + 4) = v9;
          goto LABEL_88;
        }
        if (a4 == 35907)
        {
          *(_BYTE *)(a1 + 6) = 1;
          *(_WORD *)(a1 + 4) = 1056;
          v17 = a3 == 32993;
          LODWORD(v4) = 71;
          v18 = 81;
LABEL_139:
          if (v17)
            LODWORD(v4) = v18;
          goto LABEL_210;
        }
        v10 = 35917;
LABEL_83:
        if (a4 != v10)
          return v4;
        v12 = 3;
LABEL_85:
        *(_DWORD *)a1 = v12;
        v6 = 67175488;
        goto LABEL_86;
      }
      if ((a4 - 35918) >= 2)
        return v4;
LABEL_65:
      v5 = 3;
LABEL_66:
      *(_DWORD *)a1 = v5;
      v6 = 67175552;
LABEL_86:
      *(_DWORD *)(a1 + 4) = v6;
      v7 = 4;
LABEL_87:
      *(_BYTE *)(a1 + 8) = v7;
LABEL_88:
      v4 = 1;
      if (a4 > 36755)
      {
        if (a4 > 37807)
        {
          switch(a4)
          {
            case 37808:
              LODWORD(v4) = 204;
              goto LABEL_210;
            case 37809:
              LODWORD(v4) = 205;
              goto LABEL_210;
            case 37810:
              LODWORD(v4) = 206;
              goto LABEL_210;
            case 37811:
              LODWORD(v4) = 207;
              goto LABEL_210;
            case 37812:
              LODWORD(v4) = 208;
              goto LABEL_210;
            case 37813:
              LODWORD(v4) = 210;
              goto LABEL_210;
            case 37814:
              LODWORD(v4) = 211;
              goto LABEL_210;
            case 37815:
              LODWORD(v4) = 212;
              goto LABEL_210;
            case 37816:
              LODWORD(v4) = 213;
              goto LABEL_210;
            case 37817:
              LODWORD(v4) = 214;
              goto LABEL_210;
            case 37818:
              LODWORD(v4) = 215;
              goto LABEL_210;
            case 37819:
              LODWORD(v4) = 216;
              goto LABEL_210;
            case 37820:
              LODWORD(v4) = 217;
              goto LABEL_210;
            case 37821:
              LODWORD(v4) = 218;
              goto LABEL_210;
            case 37840:
              LODWORD(v4) = 186;
              goto LABEL_210;
            case 37841:
              LODWORD(v4) = 187;
              goto LABEL_210;
            case 37842:
              LODWORD(v4) = 188;
              goto LABEL_210;
            case 37843:
              LODWORD(v4) = 189;
              goto LABEL_210;
            case 37844:
              LODWORD(v4) = 190;
              goto LABEL_210;
            case 37845:
              LODWORD(v4) = 192;
              goto LABEL_210;
            case 37846:
              LODWORD(v4) = 193;
              goto LABEL_210;
            case 37847:
              LODWORD(v4) = 194;
              goto LABEL_210;
            case 37848:
              LODWORD(v4) = 195;
              goto LABEL_210;
            case 37849:
              LODWORD(v4) = 196;
              goto LABEL_210;
            case 37850:
              LODWORD(v4) = 197;
              goto LABEL_210;
            case 37851:
              LODWORD(v4) = 198;
              goto LABEL_210;
            case 37852:
              LODWORD(v4) = 199;
              goto LABEL_210;
            case 37853:
              LODWORD(v4) = 200;
              goto LABEL_210;
            default:
              return v4;
          }
          return v4;
        }
        switch(a4)
        {
          case 37488:
            LODWORD(v4) = 170;
            break;
          case 37489:
            LODWORD(v4) = 172;
            break;
          case 37490:
            LODWORD(v4) = 174;
            break;
          case 37491:
            LODWORD(v4) = 176;
            break;
          case 37492:
            LODWORD(v4) = 180;
            break;
          case 37493:
            LODWORD(v4) = 181;
            break;
          case 37494:
            LODWORD(v4) = 182;
            break;
          case 37495:
            LODWORD(v4) = 183;
            break;
          case 37496:
            LODWORD(v4) = 178;
            break;
          case 37497:
            LODWORD(v4) = 179;
            break;
          default:
            switch(a4)
            {
              case 36756:
                LODWORD(v4) = 12;
                goto LABEL_210;
              case 36757:
                LODWORD(v4) = 32;
                goto LABEL_210;
              case 36758:
              case 36762:
                return v4;
              case 36759:
                goto LABEL_119;
              case 36760:
                LODWORD(v4) = 22;
                goto LABEL_210;
              case 36761:
                LODWORD(v4) = 62;
                goto LABEL_210;
              case 36763:
                LODWORD(v4) = 112;
                goto LABEL_210;
              default:
                if (a4 != 36975)
                  return v4;
                LODWORD(v4) = 91;
                break;
            }
            break;
        }
LABEL_210:
        *(_DWORD *)(a1 + 24) = v4;
        return 1;
      }
      if (a4 <= 34835)
      {
        v4 = 25;
        switch(a4)
        {
          case 33321:
            LODWORD(v4) = 10;
            goto LABEL_210;
          case 33322:
            LODWORD(v4) = 20;
            goto LABEL_210;
          case 33323:
            LODWORD(v4) = 30;
            goto LABEL_210;
          case 33324:
            LODWORD(v4) = 60;
            goto LABEL_210;
          case 33325:
            goto LABEL_210;
          case 33326:
            goto LABEL_132;
          case 33327:
            goto LABEL_134;
          case 33328:
            goto LABEL_136;
          case 33329:
            LODWORD(v4) = 14;
            goto LABEL_210;
          case 33330:
            LODWORD(v4) = 13;
            goto LABEL_210;
          case 33331:
            LODWORD(v4) = 24;
            goto LABEL_210;
          case 33332:
            LODWORD(v4) = 23;
            goto LABEL_210;
          case 33333:
            LODWORD(v4) = 54;
            goto LABEL_210;
          case 33334:
            LODWORD(v4) = 53;
            goto LABEL_210;
          case 33335:
            LODWORD(v4) = 34;
            goto LABEL_210;
          case 33336:
            LODWORD(v4) = 33;
            goto LABEL_210;
          case 33337:
            LODWORD(v4) = 64;
            goto LABEL_210;
          case 33338:
            LODWORD(v4) = 63;
            goto LABEL_210;
          case 33339:
            LODWORD(v4) = 104;
            goto LABEL_210;
          case 33340:
            LODWORD(v4) = 103;
            goto LABEL_210;
          default:
            if (a4 == 32857)
            {
              LODWORD(v4) = 90;
            }
            else
            {
              if (a4 != 32859)
                return v4;
              LODWORD(v4) = 110;
            }
            break;
        }
        goto LABEL_210;
      }
      if (a4 <= 35897)
      {
        if (a4 <= 35839)
        {
          switch(a4)
          {
            case 35412:
              LODWORD(v4) = 161;
              goto LABEL_210;
            case 35413:
              LODWORD(v4) = 163;
              goto LABEL_210;
            case 35414:
              LODWORD(v4) = 165;
              goto LABEL_210;
            case 35415:
              LODWORD(v4) = 167;
              goto LABEL_210;
            default:
              if (a4 == 34836)
                goto LABEL_123;
              if (a4 == 34842)
                goto LABEL_122;
              return v4;
          }
        }
        switch(a4)
        {
          case 35840:
            LODWORD(v4) = 162;
            goto LABEL_210;
          case 35841:
            LODWORD(v4) = 160;
            goto LABEL_210;
          case 35842:
            LODWORD(v4) = 166;
            goto LABEL_210;
          case 35843:
            LODWORD(v4) = 164;
            goto LABEL_210;
          default:
            return v4;
        }
        return v4;
      }
      if (a4 > 36213)
      {
        if (a4 <= 36225)
        {
          if (a4 == 36214)
          {
            LODWORD(v4) = 113;
          }
          else
          {
            if (a4 != 36220)
              return v4;
            LODWORD(v4) = 73;
          }
        }
        else
        {
          switch(a4)
          {
            case 36226:
              LODWORD(v4) = 124;
              break;
            case 36232:
              LODWORD(v4) = 114;
              break;
            case 36238:
              LODWORD(v4) = 74;
              break;
            default:
              return v4;
          }
        }
        goto LABEL_210;
      }
      if (a4 <= 35906)
      {
        if (a4 == 35898)
        {
          LODWORD(v4) = 92;
        }
        else
        {
          if (a4 != 35901)
            return v4;
          LODWORD(v4) = 93;
        }
        goto LABEL_210;
      }
      if (a4 != 36194)
      {
        if (a4 != 36208)
          return v4;
        LODWORD(v4) = 123;
        goto LABEL_210;
      }
LABEL_118:
      LODWORD(v4) = 40;
      goto LABEL_210;
    }
    switch(a4)
    {
      case 35840:
LABEL_38:
        v11 = 1;
LABEL_60:
        *(_DWORD *)a1 = v11;
        v6 = 67109696;
        goto LABEL_86;
      case 35841:
LABEL_34:
        *(_DWORD *)a1 = 1;
        v6 = 134218560;
        goto LABEL_86;
      case 35842:
LABEL_40:
        v12 = 1;
        goto LABEL_85;
      case 35843:
LABEL_39:
        *(_DWORD *)a1 = 1;
        v6 = 134284352;
        goto LABEL_86;
      default:
        if (a4 == 35898)
          goto LABEL_74;
        break;
    }
  }
  else
  {
    if (a4 <= 33777)
    {
      switch(a4)
      {
        case 33321:
LABEL_26:
          *(_BYTE *)(a1 + 6) = 0;
          v9 = 264;
          goto LABEL_80;
        case 33322:
LABEL_70:
          *(_BYTE *)(a1 + 6) = 0;
          v9 = 272;
          goto LABEL_80;
        case 33323:
LABEL_69:
          *(_BYTE *)(a1 + 6) = 0;
          v9 = 528;
          goto LABEL_80;
        case 33324:
LABEL_71:
          *(_BYTE *)(a1 + 6) = 0;
          v9 = 544;
          goto LABEL_80;
        case 33325:
          *(_BYTE *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 272;
          LODWORD(v4) = 25;
          goto LABEL_210;
        case 33326:
          *(_BYTE *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 288;
LABEL_132:
          LODWORD(v4) = 55;
          goto LABEL_210;
        case 33327:
          *(_BYTE *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 544;
LABEL_134:
          LODWORD(v4) = 65;
          goto LABEL_210;
        case 33328:
          *(_BYTE *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 576;
LABEL_136:
          LODWORD(v4) = 105;
          goto LABEL_210;
        default:
          switch(a4)
          {
            case 32854:
              *(_BYTE *)(a1 + 6) = 1;
              *(_WORD *)(a1 + 4) = 1040;
              LODWORD(v4) = 42;
              goto LABEL_210;
            case 32855:
              *(_BYTE *)(a1 + 6) = 1;
              *(_WORD *)(a1 + 4) = 1040;
              LODWORD(v4) = 41;
              goto LABEL_210;
            case 32856:
              *(_BYTE *)(a1 + 6) = 1;
              *(_WORD *)(a1 + 4) = 1056;
              v17 = a3 == 32993;
              LODWORD(v4) = 70;
              v18 = 80;
              goto LABEL_139;
            case 32857:
LABEL_79:
              *(_BYTE *)(a1 + 6) = 1;
              v9 = 1056;
              goto LABEL_80;
            case 32858:
              return v4;
            case 32859:
LABEL_72:
              *(_BYTE *)(a1 + 6) = 1;
              v9 = 1088;
              goto LABEL_80;
            default:
              v10 = 33777;
              goto LABEL_83;
          }
      }
      return v4;
    }
    if (a4 <= 35411)
    {
      if ((a4 - 33778) >= 2)
      {
        if (a4 == 34836)
        {
          *(_BYTE *)(a1 + 6) = 1;
          *(_WORD *)(a1 + 4) = 1152;
LABEL_123:
          LODWORD(v4) = 125;
        }
        else
        {
          if (a4 != 34842)
            return v4;
          *(_BYTE *)(a1 + 6) = 1;
          *(_WORD *)(a1 + 4) = 1088;
LABEL_122:
          LODWORD(v4) = 115;
        }
        goto LABEL_210;
      }
      goto LABEL_65;
    }
    switch(a4)
    {
      case 35412:
        goto LABEL_34;
      case 35413:
        goto LABEL_38;
      case 35414:
        goto LABEL_39;
      case 35415:
        goto LABEL_40;
      default:
        return v4;
    }
  }
  return v4;
}

uint64_t sub_1B18D7EFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BOOL8 v16;
  __CFString *v17;
  __CFString *v18;

  if (sub_1B180A64C(a1, a2, a3, a4, a5, a6, a7, a8))
    return 1;
  v17 = sub_1B18090EC(a1, v9, v10, v11, v12, v13, v14, v15);
  if (!v17)
    return 0;
  v18 = v17;
  v16 = CFEqual(v17, CFSTR("ktx")) != 0;
  CFRelease(v18);
  return v16;
}

uint64_t sub_1B18D7F60(uint64_t a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  NSObject *v13;
  const __CFData *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFData *v22;
  unint64_t Length;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const __CFString *v30;
  int v31;
  unint64_t v32;
  const UInt8 *BytePtr;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  NSObject *v38;
  const UInt8 *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  CFMutableArrayRef *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  const __CFString *v57;
  int v58;
  uint64_t v59;
  unint64_t v60;
  int v61;
  int v62;
  uint64_t v63;
  CFIndex v64;
  unint64_t v65;
  CFDataRef v66;
  uint64_t v67;
  int v68;
  unint64_t v69;
  os_signpost_id_t v70;
  uint8_t buf[4];
  int v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v2 = sub_1B17C439C();
  v3 = os_signpost_id_generate(v2);
  v4 = sub_1B17C439C();
  v12 = v3 - 1;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v13 = v4;
    if (os_signpost_enabled(v4))
    {
      *(_DWORD *)buf = 67109120;
      v72 = 1;
      _os_signpost_emit_with_name_impl(&dword_1B178D000, v13, OS_SIGNPOST_INTERVAL_BEGIN, v3, "LoadImage (KTX)", "dd %d", buf, 8u);
    }
  }
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v6, v7, v8, v9, v10, v11, (uint64_t)"image");
  v14 = (const __CFData *)sub_1B180A64C(a1, v5, v6, v7, v8, v9, v10, v11);
  if (v14)
  {
    v22 = v14;
    CFRetain(v14);
  }
  else
  {
    v36 = sub_1B1809180(a1, v15, v16, v17, v18, v19, v20, v21);
    if (!v36 || (v22 = (const __CFData *)sub_1B19AA5B0(v36)) == 0)
    {
      v35 = 0;
      goto LABEL_20;
    }
  }
  Length = CFDataGetLength(v22);
  if (Length > 0x3F)
  {
    v32 = Length;
    BytePtr = CFDataGetBytePtr(v22);
    if (*(_QWORD *)BytePtr != 0xBB31312058544BABLL || *((_DWORD *)BytePtr + 2) != 169478669)
      goto LABEL_15;
    v40 = BytePtr;
    if (*((_DWORD *)BytePtr + 3) != 67305985)
    {
      v30 = CFSTR("Error: Only big endian ktx are supported");
      v31 = 16;
      goto LABEL_10;
    }
    sub_1B180AEF8(a1);
    sub_1B1809348(a1, 0, 0, COERCE_DOUBLE(vcvt_f32_u32(*(uint32x2_t *)(v40 + 36))));
    if (*((_DWORD *)v40 + 13) == 6)
      sub_1B180B05C(a1, 3, v41, v42, v43, v44, v45, v46);
    v47 = (CFMutableArrayRef *)sub_1B1809424(a1);
    if ((sub_1B18D742C((uint64_t)v47, v48, *((_DWORD *)v40 + 6), *((_DWORD *)v40 + 7)) & 1) == 0)
    {
      v57 = CFSTR("Error: Unsupported format in KTX file");
      v58 = 16;
LABEL_54:
      sub_1B17C4408(v58, (uint64_t)v57, v49, v50, v51, v52, v53, v54, v67);
      sub_1B180AEF8(a1);
      goto LABEL_15;
    }
    v55 = *(unsigned int *)v47;
    if ((_DWORD)v55)
    {
      v56 = (v55 - 5) < 0xFFFFFFFE;
      if ((_DWORD)v55 == 2)
      {
        v56 = sub_1B179FEA0();
        v55 = *(unsigned int *)v47;
      }
      if ((_DWORD)v55 == 5)
      {
        if ((sub_1B179FEA0() & 1) == 0)
        {
          v55 = *(unsigned int *)v47;
LABEL_53:
          v67 = v55;
          v57 = CFSTR("Warning: Compression type %d not supported");
          v58 = 0;
          goto LABEL_54;
        }
      }
      else if ((v56 & 1) == 0)
      {
        goto LABEL_53;
      }
    }
    v59 = 0;
    v60 = *((unsigned int *)v40 + 15) + 64;
    if (*((_DWORD *)v40 + 13) <= 1u)
      v61 = 1;
    else
      v61 = *((_DWORD *)v40 + 13);
    if (*((_DWORD *)v40 + 14) <= 1u)
      v62 = 1;
    else
      v62 = *((_DWORD *)v40 + 14);
    v68 = v62;
    v69 = v3 - 1;
    v70 = v3;
    while (v60 <= v32)
    {
      v63 = 0;
      v64 = *(unsigned int *)&v40[v60];
      v60 += 4;
      while (1)
      {
        v65 = v60 + v64;
        if (v60 + v64 > v32)
          break;
        v66 = CFDataCreate(0, &v40[v60], v64);
        CFArrayAppendValue(v47[4], v66);
        CFRelease(v66);
        v60 = (v65 + 3) & 0xFFFFFFFFFFFFFFFCLL;
        v63 = (v63 + 1);
        if (v61 == (_DWORD)v63)
          goto LABEL_50;
      }
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: overflow reading slice[%d] / mip[%d] (%zu > %zu)"), v49, v50, v51, v52, v53, v54, v63);
LABEL_50:
      v59 = (v59 + 1);
      v35 = 1;
      v12 = v69;
      v3 = v70;
      if ((_DWORD)v59 == v68)
        goto LABEL_16;
    }
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: overflow reading mip[%d] (%zu > %zu)"), v49, v50, v51, v52, v53, v54, v59);
    v35 = 1;
    goto LABEL_16;
  }
  v30 = CFSTR("Warning: KTX file seems too small or is not a KTX");
  v31 = 0;
LABEL_10:
  sub_1B17C4408(v31, (uint64_t)v30, v24, v25, v26, v27, v28, v29, v67);
LABEL_15:
  v35 = 0;
LABEL_16:
  CFRelease(v22);
LABEL_20:
  v37 = sub_1B17C439C();
  if (v12 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v38 = v37;
    if (os_signpost_enabled(v37))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1B178D000, v38, OS_SIGNPOST_INTERVAL_END, v3, "LoadImage (KTX)", "", buf, 2u);
    }
  }
  return v35;
}

uint64_t sub_1B18D8310(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  id v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  signed int v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  id v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  uint64_t v64;
  const char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  const char *v71;
  uint64_t v72;
  void *v73;
  const char *v74;
  uint64_t v75;
  uint64_t v76;
  void *v77;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  void *v81;
  const char *v82;
  uint64_t v83;
  uint64_t v84;
  void *v85;
  const char *v86;
  uint64_t v87;
  uint64_t v88;
  const char *v89;
  uint64_t v90;
  uint64_t v91;
  void *v92;
  __int128 v93;
  uint64_t v94;
  signed int v95;
  uint64_t v96;
  __int128 v97;
  uint64_t v98;
  const char *v99;
  uint64_t v100;
  uint64_t v101;
  const char *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  const char *v106;
  uint64_t v107;
  uint64_t v108;
  __int128 v109;
  int v110;
  int v111;
  int v112;
  const char *v113;
  uint64_t v114;
  uint64_t v115;
  const char *v116;
  uint64_t v117;
  uint64_t v118;
  const char *v119;
  uint64_t v120;
  void *v121;
  const char *v122;
  const char *v123;
  void *v124;
  uint64_t v125;
  int v126;
  uint64_t i;
  const char *v128;
  const char *v129;
  uint64_t v130;
  uint64_t v131;
  unint64_t v133;
  const __CFString *v134;
  const char *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  const __CFString *v150;
  uint64_t v151;
  uint64_t v152;
  uint32x2_t v153[3];
  uint64_t v154;
  __int128 v155;
  unsigned int v156;
  _QWORD v157[6];
  _QWORD v158[3];
  __int128 v159;
  uint64_t v160;
  unint64_t v161;
  uint64_t v162;
  __int128 v163;
  _OWORD v164[2];
  uint64_t v165;

  v4 = a1;
  v165 = *MEMORY[0x1E0C80C00];
  v5 = objc_msgSend_width(a1, a2, a3, a4);
  v9 = objc_msgSend_height(v4, v6, v7, v8);
  v13 = objc_msgSend_depth(v4, v10, v11, v12);
  if (objc_msgSend_textureType(v4, v14, v15, v16) == 5)
    v20 = 6;
  else
    v20 = 1;
  v21 = objc_msgSend_mipmapLevelCount(v4, v17, v18, v19);
  v154 = v21;
  if (objc_msgSend_storageMode(v4, v22, v23, v24) == 2)
  {
    v151 = v9;
    v152 = v5;
    v28 = objc_alloc_init(MEMORY[0x1E0CC6BB0]);
    v32 = objc_msgSend_textureType(v4, v29, v30, v31);
    objc_msgSend_setTextureType_(v28, v33, v32, v34);
    v38 = objc_msgSend_pixelFormat(v4, v35, v36, v37);
    objc_msgSend_setPixelFormat_(v28, v39, v38, v40);
    v44 = objc_msgSend_width(v4, v41, v42, v43);
    objc_msgSend_setWidth_(v28, v45, v44, v46);
    v50 = objc_msgSend_height(v4, v47, v48, v49);
    objc_msgSend_setHeight_(v28, v51, v50, v52);
    v56 = objc_msgSend_depth(v4, v53, v54, v55);
    objc_msgSend_setDepth_(v28, v57, v56, v58);
    v62 = objc_msgSend_mipmapLevelCount(v4, v59, v60, v61);
    objc_msgSend_setMipmapLevelCount_(v28, v63, v62, v64);
    objc_msgSend_setUsage_(v28, v65, 0, v66);
    v70 = (void *)objc_msgSend_device(v4, v67, v68, v69);
    v73 = (void *)objc_msgSend_newTextureWithDescriptor_(v70, v71, (uint64_t)v28, v72);
    v77 = (void *)objc_msgSend_device(v4, v74, v75, v76);
    v81 = (void *)objc_msgSend_newCommandQueue(v77, v78, v79, v80);
    v85 = (void *)objc_msgSend_commandBuffer(v81, v82, v83, v84);
    v92 = (void *)objc_msgSend_blitCommandEncoder(v85, v86, v87, v88);
    if (v21)
    {
      v94 = 0;
      *(_QWORD *)&v93 = __PAIR64__(v151, v152);
      v95 = v13;
      do
      {
        v96 = 0;
        *(_OWORD *)v153[0].i8 = v93;
        *(_QWORD *)&v97 = (int)v93;
        *((_QWORD *)&v97 + 1) = SDWORD1(v93);
        v155 = v97;
        v98 = v95;
        do
        {
          v159 = v155;
          v160 = v98;
          v161 = 0;
          v162 = 0;
          *(_QWORD *)&v163 = 0;
          memset(v158, 0, sizeof(v158));
          objc_msgSend_copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_(v92, v89, (uint64_t)v4, v96, v94, &v161, &v159, v73, v96, v94, v158);
          ++v96;
        }
        while (v20 != v96);
        *((uint32x2_t *)&v93 + 1) = v153[1];
        *(uint32x2_t *)&v93 = vshl_u32(v153[0], (uint32x2_t)vcgt_s32((int32x2_t)v153[0], (int32x2_t)0x100000001));
        v95 = v98 >> ((int)v98 > 1);
        ++v94;
        v21 = v154;
      }
      while (v94 != v154);
    }
    objc_msgSend_endEncoding(v92, v89, v90, v91);
    objc_msgSend_commit(v85, v99, v100, v101);
    objc_msgSend_waitUntilCompleted(v85, v102, v103, v104);

    v4 = v73;
    v9 = v151;
    v5 = v152;
  }
  memset(v164, 0, sizeof(v164));
  v163 = 0u;
  v161 = 0xBB31312058544BABLL;
  v162 = 0x40302010A1A0A0DLL;
  v105 = objc_msgSend_pixelFormat(v4, v25, v26, v27);
  if (v105 > 79)
  {
    switch(v105)
    {
      case 'P':
        v109 = xmmword_1B2247D30;
        goto LABEL_24;
      case 's':
        v109 = xmmword_1B2247D60;
        v112 = 8;
        goto LABEL_26;
      case 'Q':
        v109 = xmmword_1B2247D80;
        goto LABEL_24;
    }
LABEL_36:
    v150 = sub_1B189D744(v105);
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Unsupported pixel format %@ (%u) in KTX encoder"), v144, v145, v146, v147, v148, v149, (uint64_t)v150);
    return 0;
  }
  switch(v105)
  {
    case 10:
      v109 = xmmword_1B2247D50;
      v110 = 1;
      break;
    case 25:
      v109 = xmmword_1B2247D40;
      v110 = 2;
      break;
    case 71:
      v109 = xmmword_1B2247D70;
LABEL_24:
      v112 = 4;
LABEL_26:
      v156 = v112;
      v111 = 6408;
      goto LABEL_27;
    default:
      goto LABEL_36;
  }
  v156 = v110;
  v111 = 6403;
LABEL_27:
  v163 = v109;
  LODWORD(v164[0]) = v111;
  if (objc_msgSend_textureType(v4, v106, v107, v108) != 2 && objc_msgSend_textureType(v4, v113, v114, v115) != 5)
  {
    v133 = objc_msgSend_textureType(v4, v113, v114, v115);
    v134 = sub_1B189DB14(v133);
    objc_msgSend_textureType(v4, v135, v136, v137);
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Unsupported texture type %@ (%u) in KTX encoder"), v138, v139, v140, v141, v142, v143, (uint64_t)v134);
    return 0;
  }
  DWORD1(v164[0]) = objc_msgSend_width(v4, v113, v114, v115);
  DWORD2(v164[0]) = objc_msgSend_height(v4, v116, v117, v118);
  *(_QWORD *)((char *)v164 + 12) = 0;
  *(_QWORD *)((char *)&v164[1] + 4) = __PAIR64__(v21, v20);
  v121 = (void *)objc_msgSend_dataWithCapacity_(MEMORY[0x1E0C99DF0], v119, 0, v120);
  objc_msgSend_appendBytes_length_(v121, v122, (uint64_t)&v161, 64);
  v124 = malloc_type_malloc(v9 * v5 * v156, 0x34030420uLL);
  if (v21)
  {
    v125 = 0;
    v126 = v9;
    do
    {
      LODWORD(v158[0]) = v5 * v156 * v126;
      objc_msgSend_appendBytes_length_(v121, v123, (uint64_t)v158, 4);
      for (i = 0; i != v20; ++i)
      {
        memset(v157, 0, 24);
        v157[3] = (int)v5;
        v157[4] = v126;
        v157[5] = 1;
        objc_msgSend_getBytes_bytesPerRow_bytesPerImage_fromRegion_mipmapLevel_slice_(v4, v123, (uint64_t)v124, (int)(v5 * v156), LODWORD(v158[0]), v157, v125, i);
        objc_msgSend_appendBytes_length_(v121, v128, (uint64_t)v124, LODWORD(v158[0]));
      }
      LODWORD(v5) = v5 >> ((int)v5 > 1);
      v126 = v126 >> (v126 > 1);
      ++v125;
    }
    while (v125 != v154);
  }
  free(v124);
  return objc_msgSend_copy(v121, v129, v130, v131);
}

void sub_1B18D8EB0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B18DA318(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

uint64_t sub_1B18D8F70(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  return sub_1B18DA474(v5, (unint64_t)(float)*(unint64_t *)(a1 + 40));
}

uint64_t sub_1B18D90B8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  return sub_1B18DA454(v5, *(float *)(a1 + 40));
}

uint64_t sub_1B18D9208(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  return sub_1B18DA464(v5, *(float *)(a1 + 40));
}

void sub_1B18D93CC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B18DA238(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B18D9514(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B18DA158(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B18D96C4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B18DA3E0(v5, *(_QWORD *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B18D980C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B18DA078(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

uint64_t sub_1B18D9C0C(uint64_t a1, float32x4_t *a2, __n128 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x2_t a9)
{
  __n128 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __n128 v19;
  int8x16_t v20;
  float32x4_t v21;
  int32x4_t v22;
  unint64_t v23;
  float32x4_t v24;
  int8x16_t v27;

  v12 = (__n128 *)sub_1B17C6244((_QWORD *)a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (v12)
  {
    v27.i32[2] = 0;
    v27.i64[0] = 0;
    v19 = sub_1B187AD68(v12, (__n128 *)&v27, v13, v14, v15, v16, v17, v18);
    v20 = v27;
  }
  else
  {
    v20 = (int8x16_t)xmmword_1B2244DD0;
  }
  v19.n128_u64[0] = (unint64_t)vbsl_s8((int8x8_t)vceqz_f32(*(float32x2_t *)(a1 + 228)), (int8x8_t)vdup_lane_s32(a9, 0), *(int8x8_t *)(a1 + 228));
  if (*(float *)&v20.i32[1] == 0.0)
  {
    if (*(float *)&v20.i32[2] == 0.0)
    {
      v24.i32[0] = 0;
      v24.i32[3] = 0;
      v24.f32[1] = -v19.n128_f32[0];
      v24.f32[2] = -v19.n128_f32[1];
      *a2 = v24;
      v20.i32[0] = 925353388;
      v19 = (__n128)vextq_s8(vextq_s8(v20, v20, 4uLL), (int8x16_t)v19, 0xCuLL);
    }
    else
    {
      *(float *)&v23 = -v19.n128_f32[0];
      *((float *)&v23 + 1) = -v19.n128_f32[1];
      *a2 = (float32x4_t)v23;
      v19.n128_u32[2] = 925353388;
    }
  }
  else
  {
    v21 = vnegq_f32((float32x4_t)vzip1q_s32((int32x4_t)v19, (int32x4_t)v19));
    v21.i32[1] = 0;
    *a2 = v21;
    v22 = vdupq_n_s32(0x3727C5ACu);
    v19 = (__n128)vextq_s8((int8x16_t)vzip1q_s32(v22, (int32x4_t)v19), (int8x16_t)v22, 4uLL);
  }
  *a3 = v19;
  return 1;
}

uint64_t sub_1B18D9D1C()
{
  if (qword_1ED4CEC78 != -1)
    dispatch_once(&qword_1ED4CEC78, &unk_1E63D0FF0);
  return qword_1ED4CEC80;
}

double sub_1B18D9D5C()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double result;

  if (!qword_1ED4CEC80)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEC80);
    qword_1ED4CEC80 = (uint64_t)v0;
    v1 = (const void *)sub_1B17A12B4();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("reflectionFalloffEnd"), 0xD8u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("reflectionFalloffStart"), 0xD4u, 1, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("reflectivity"), 0xD0u, 1, 0, 0, 0, v6, v7);
    sub_1B19C326C(CFSTR("width"), 0xE4u, 1, 0, 0, 0, v8, v9);
    sub_1B19C326C(CFSTR("length"), 0xE8u, 1, 0, 0, 0, v10, v11);
    sub_1B19C3258();
    unk_1ED4BDEC8 = xmmword_1E63D2F18;
    unk_1ED4BDED8 = xmmword_1E63D2F28;
    qword_1ED4BDEC0 = (uint64_t)sub_1B18DA4C4;
    unk_1ED4BDEE8 = unk_1E63D2F38;
    qword_1ED4BDEF8 = 0;
    unk_1ED4BDF00 = sub_1B18DACD8;
    *(_QWORD *)&result = 0x1B18DAD0CLL;
    xmmword_1ED4BDEB0 = xmmword_1E63D2F08;
  }
  return result;
}

float sub_1B18D9FEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  return *(float *)(a1 + 208);
}

void sub_1B18DA034(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;

  sub_1B17A20D4(a1, a2, a3, a4, a5, a6, a7, a8);
  v16 = (const void *)sub_1B17C6244(a1, v9, v10, v11, v12, v13, v14, v15);
  sub_1B194F874(CFSTR("kCFXNotificationEngineContextInvalidatePasses"), v16, 0, 1u);
}

void sub_1B18DA078(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  float v11;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  v11 = *(float *)(a1 + 208);
  if (a9 != 0.0 && v11 == 0.0)
  {
    *(float *)(a1 + 208) = a9;
LABEL_8:
    sub_1B18DA034((_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
    return;
  }
  *(float *)(a1 + 208) = a9;
  if (a9 == 0.0 && v11 != 0.0)
    goto LABEL_8;
}

float sub_1B18DA110(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  return *(float *)(a1 + 212);
}

void sub_1B18DA158(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  float v11;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  v11 = *(float *)(a1 + 212);
  if (a9 != 0.0 && v11 == 0.0)
  {
    *(float *)(a1 + 212) = a9;
LABEL_8:
    sub_1B18DA034((_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
    return;
  }
  *(float *)(a1 + 212) = a9;
  if (a9 == 0.0 && v11 != 0.0)
    goto LABEL_8;
}

float sub_1B18DA1F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  return *(float *)(a1 + 216);
}

void sub_1B18DA238(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  float v11;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  v11 = *(float *)(a1 + 216);
  if (a9 != 0.0 && v11 == 0.0)
  {
    *(float *)(a1 + 216) = a9;
LABEL_8:
    sub_1B18DA034((_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
    return;
  }
  *(float *)(a1 + 216) = a9;
  if (a9 == 0.0 && v11 != 0.0)
    goto LABEL_8;
}

float sub_1B18DA2D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  return *(float *)(a1 + 220);
}

void sub_1B18DA318(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  if (a9 != 0.0 && *(float *)(a1 + 220) != a9)
  {
    *(float *)(a1 + 220) = a9;
    sub_1B18DA034((_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B18DA398(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  return *(unsigned int *)(a1 + 224);
}

void sub_1B18DA3E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  if (*(_DWORD *)(a1 + 224) != v8)
  {
    *(_DWORD *)(a1 + 224) = v8;
    sub_1B18DA034((_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

float sub_1B18DA44C(uint64_t a1)
{
  return *(float *)(a1 + 228);
}

uint64_t sub_1B18DA454(uint64_t result, float a2)
{
  *(float *)(result + 228) = a2;
  return result;
}

float sub_1B18DA45C(uint64_t a1)
{
  return *(float *)(a1 + 232);
}

uint64_t sub_1B18DA464(uint64_t result, float a2)
{
  *(float *)(result + 232) = a2;
  return result;
}

uint64_t sub_1B18DA46C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 240);
}

uint64_t sub_1B18DA474(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 240) = a2;
  return result;
}

CFStringRef sub_1B18DA484(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXFloor>"));
}

CFStringRef sub_1B18DA4A4(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXFloor>"));
}

__CFArray *sub_1B18DA4C4(uint64_t a1)
{
  __CFArray *Mutable;
  const CFDictionaryKeyCallBacks *v3;
  const CFDictionaryValueCallBacks *v4;
  __CFDictionary *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  __CFDictionary *v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  __CFDictionary *v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  __CFDictionary *v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFNumberRef v20;
  __CFDictionary *v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  __CFDictionary *v25;
  CFNumberRef v26;
  CFNumberRef v27;
  CFNumberRef v28;
  __CFDictionary *v29;
  CFNumberRef v30;
  CFNumberRef v31;
  CFNumberRef v32;
  __CFDictionary *v33;
  CFNumberRef v34;
  CFNumberRef v35;
  CFNumberRef v36;
  __CFArray *v37;
  uint64_t v39;
  int v40;
  int valuePtr;
  CFRange v42;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v40 = 0;
  valuePtr = 1;
  v39 = a1 + 208;
  v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  v8 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v5, CFSTR("name"), CFSTR("reflectivity"));
  CFDictionarySetValue(v5, CFSTR("type"), v6);
  CFDictionarySetValue(v5, CFSTR("address"), v8);
  CFDictionarySetValue(v5, CFSTR("semantic"), v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v40 = 0;
  valuePtr = 1;
  v39 = a1 + 212;
  v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  v12 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v9, CFSTR("name"), CFSTR("reflectionFalloffStart"));
  CFDictionarySetValue(v9, CFSTR("type"), v10);
  CFDictionarySetValue(v9, CFSTR("address"), v12);
  CFDictionarySetValue(v9, CFSTR("semantic"), v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  v13 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v40 = 0;
  valuePtr = 1;
  v39 = a1 + 216;
  v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  v16 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v13, CFSTR("name"), CFSTR("reflectionFalloffEnd"));
  CFDictionarySetValue(v13, CFSTR("type"), v14);
  CFDictionarySetValue(v13, CFSTR("address"), v16);
  CFDictionarySetValue(v13, CFSTR("semantic"), v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  v17 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v40 = 0;
  valuePtr = 1;
  v39 = a1 + 220;
  v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  v20 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v17, CFSTR("name"), CFSTR("resolutionScaleFactor"));
  CFDictionarySetValue(v17, CFSTR("type"), v18);
  CFDictionarySetValue(v17, CFSTR("address"), v20);
  CFDictionarySetValue(v17, CFSTR("semantic"), v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  v21 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v40 = 0;
  valuePtr = 1;
  v39 = a1 + 224;
  v22 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  v24 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v21, CFSTR("name"), CFSTR("sampleCount"));
  CFDictionarySetValue(v21, CFSTR("type"), v22);
  CFDictionarySetValue(v21, CFSTR("address"), v24);
  CFDictionarySetValue(v21, CFSTR("semantic"), v23);
  CFArrayAppendValue(Mutable, v21);
  CFRelease(v23);
  CFRelease(v21);
  CFRelease(v24);
  CFRelease(v22);
  v25 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v40 = 0;
  valuePtr = 2;
  v39 = a1 + 240;
  v26 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v27 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  v28 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v25, CFSTR("name"), CFSTR("reflectionBitMask"));
  CFDictionarySetValue(v25, CFSTR("type"), v26);
  CFDictionarySetValue(v25, CFSTR("address"), v28);
  CFDictionarySetValue(v25, CFSTR("semantic"), v27);
  CFArrayAppendValue(Mutable, v25);
  CFRelease(v27);
  CFRelease(v25);
  CFRelease(v28);
  CFRelease(v26);
  v29 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v40 = 0;
  valuePtr = 1;
  v39 = a1 + 228;
  v30 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v31 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  v32 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v29, CFSTR("name"), CFSTR("width"));
  CFDictionarySetValue(v29, CFSTR("type"), v30);
  CFDictionarySetValue(v29, CFSTR("address"), v32);
  CFDictionarySetValue(v29, CFSTR("semantic"), v31);
  CFArrayAppendValue(Mutable, v29);
  CFRelease(v31);
  CFRelease(v29);
  CFRelease(v32);
  CFRelease(v30);
  v33 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v40 = 0;
  valuePtr = 1;
  v39 = a1 + 232;
  v34 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v35 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  v36 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v33, CFSTR("name"), CFSTR("length"));
  CFDictionarySetValue(v33, CFSTR("type"), v34);
  CFDictionarySetValue(v33, CFSTR("address"), v36);
  CFDictionarySetValue(v33, CFSTR("semantic"), v35);
  CFArrayAppendValue(Mutable, v33);
  CFRelease(v35);
  CFRelease(v33);
  CFRelease(v36);
  CFRelease(v34);
  v37 = sub_1B17A0AD4(a1);
  v42.length = CFArrayGetCount(v37);
  v42.location = 0;
  CFArrayAppendArray(Mutable, v37, v42);
  CFRelease(v37);
  return Mutable;
}

uint64_t sub_1B18DAC70(uint64_t a1, int32x2_t a2, uint64_t a3, float32x4_t *a4, __n128 *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  a2.i32[0] = *(_DWORD *)"(knN";
  sub_1B18D9C0C(a1, a4, a5, (uint64_t)a5, a6, a7, a8, a9, a2);
  return 1;
}

const void *sub_1B18DAC98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  result = (const void *)sub_1B17A0848(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
    return (const void *)sub_1B17C5D30(result, a2, a3, v11, v12, v13, v14, v15);
  return result;
}

uint64_t sub_1B18DACD8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v10;

  v10 = (const void *)sub_1B193E634(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B17987F8(v10, a2))
    return a1;
  else
    return 0;
}

void sub_1B18DAD0C(uint64_t a1, void *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((void *)(a1 + 208) == __dst)
  {
    sub_1B18DA078(a1, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8, *__src);
  }
  else if ((void *)(a1 + 216) == __dst)
  {
    sub_1B18DA238(a1, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8, *__src);
  }
  else
  {
    memcpy(__dst, __src, __n);
  }
}

void sub_1B18DB31C(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

CFStringRef sub_1B18DB3E0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  return sub_1B193E5B0(v5, *(CFStringRef *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B18DB6D4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = objc_msgSend_meshRef(*(void **)(a1 + 40), a2, a3, a4);
  sub_1B17A14D4(v4, v5, v6, v7, v8, v9, v10, v11);
}

_QWORD *sub_1B18DBA94(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(const void **)(*(_QWORD *)(a1 + 32) + 8);
  v5 = objc_msgSend_coreEntityHandleRef(*(void **)(a1 + 40), a2, a3, a4);
  return sub_1B17C5C00(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B18DBD40(uint64_t a1)
{
  sub_1B17A0A54(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), 0);
}

__n128 sub_1B18DBD50(float32x4_t *a1)
{
  float32x4_t v1;
  float32x4_t v2;
  float32x4_t v3;
  __n128 result;
  _OWORD v5[2];

  v1 = a1[2];
  v2 = a1[3];
  v1.i32[3] = 1.0;
  v2.i32[3] = 1.0;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  v5[0] = vmulq_f32(vaddq_f32(v1, v2), v3);
  v5[1] = vmulq_f32(vsubq_f32(v2, v1), v3);
  sub_1B17A0A54(*(_QWORD *)(a1[4].i64[0] + 8), v5);
  return result;
}

uint64_t sub_1B18DC030(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_setValue_forKey_(*(void **)(a1 + 32), a2, a3, (uint64_t)a2);
}

uint64_t sub_1B18DC170(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_setValue_forUndefinedKey_(*(void **)(a1 + 32), a2, a3, (uint64_t)a2);
}

id sub_1B18DC2FC(VFXModel *self, SEL a2)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  const char *v13;
  uint64_t v14;

  v4 = (void *)objc_msgSend_copy(self, a2, v2, v3);
  v8 = (void *)objc_msgSend_mesh(v4, v5, v6, v7);
  v12 = (id)objc_msgSend_interleavedCopy(v8, v9, v10, v11);
  objc_msgSend_setMesh_(v4, v13, (uint64_t)v12, v14);
  return v4;
}

id sub_1B18DC338(VFXModel *self, SEL a2)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  const char *v13;
  uint64_t v14;

  v4 = (void *)objc_msgSend_copy(self, a2, v2, v3);
  v8 = (void *)objc_msgSend_mesh(v4, v5, v6, v7);
  v12 = (id)objc_msgSend__renderableCopy(v8, v9, v10, v11);
  objc_msgSend_setMesh_(v4, v13, (uint64_t)v12, v14);
  return v4;
}

uint64_t sub_1B18DC558(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_addWorldReference_(a2, (const char *)a2, *(_QWORD *)(a1 + 32), a4);
}

uint64_t sub_1B18DC610(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_removeWorldReference_(a2, (const char *)a2, *(_QWORD *)(a1 + 32), a4);
}

void sub_1B18DC72C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B18DC9C8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v6 = (void *)objc_msgSend_materialRef(*(void **)(a1 + 40), a2, a3, a4);
  sub_1B17A1D38(v5, v6, *(_QWORD *)(a1 + 48), v7, v8, v9, v10, v11);
}

void sub_1B18DCAE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B17A1BFC(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(_QWORD *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_1B18DCBE0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v6 = (void *)objc_msgSend_materialRef(*(void **)(a1 + 40), a2, a3, a4);
  sub_1B17A1DB4(v5, v6, *(_QWORD *)(a1 + 48), v7, v8, v9, v10, v11);
}

void sub_1B18DD044(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v4)
    sub_1B17A1C8C(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B18DD5FC(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  double v23;
  _BOOL4 v24;

  v6 = objc_msgSend_thresholdMode(a2, (const char *)a2, (uint64_t)a3, a4);
  v10 = (void *)objc_msgSend_thresholdValue(a2, v7, v8, v9);
  objc_msgSend_doubleValue(v10, v11, v12, v13);
  v15 = v14;
  v19 = (void *)objc_msgSend_thresholdValue(a3, v16, v17, v18);
  objc_msgSend_doubleValue(v19, v20, v21, v22);
  v24 = v15 > v23;
  if (!v6)
    v24 = v15 < v23;
  if (v24)
    return -1;
  else
    return 1;
}

void sub_1B18DD674(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD v19[5];

  v5 = (void *)MEMORY[0x1E0C99DE8];
  v6 = objc_msgSend_count(*(void **)(a1 + 32), a2, a3, a4);
  v9 = objc_msgSend_arrayWithCapacity_(v5, v7, v6, v8);
  v10 = *(void **)(a1 + 32);
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 3221225472;
  v19[2] = sub_1B18DD700;
  v19[3] = &unk_1E63D6788;
  v19[4] = v9;
  objc_msgSend_enumerateObjectsUsingBlock_(v10, v11, (uint64_t)v19, v12);
  sub_1B17A179C(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), v9, v13, v14, v15, v16, v17, v18);
}

uint64_t sub_1B18DD700(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;

  v4 = *(void **)(a1 + 32);
  v5 = objc_msgSend___CFObject(a2, (const char *)a2, a3, a4);
  return objc_msgSend_addObject_(v4, v6, v5, v7);
}

void sub_1B18DD830(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
    sub_1B184A9CC(v5, *(_DWORD *)(a1 + 40));
}

void sub_1B18DD920(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  __n128 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (__n128 *)objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
    sub_1B184A850(v5, *(unsigned __int8 *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B18DD9F4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  __n128 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (__n128 *)objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
    sub_1B184A96C(v5, *(unsigned __int8 *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B18DDAFC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  const void *v10;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    v9 = (__n128 *)v5;
    v10 = (const void *)objc_msgSend_meshElement(*(void **)(*(_QWORD *)(a1 + 32) + 112), v6, v7, v8);
    sub_1B184AAC4(v9, v10);
  }
}

void sub_1B18DDC24(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  const void *v10;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    v9 = (__n128 *)v5;
    v10 = (const void *)objc_msgSend_meshSource(*(void **)(*(_QWORD *)(a1 + 32) + 104), v6, v7, v8);
    sub_1B184AA40(v9, v10);
  }
}

void sub_1B18DE21C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;

  sub_1B193FB20(*(_QWORD *)(a1 + 40), *(void **)(a1 + 32), *(__int16 **)(a1 + 48), a4, a5, a6, a7, a8);
  v9 = *(const void **)(a1 + 48);
  if (v9)
    CFRelease(v9);
}

void sub_1B18DE25C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 *v9;
  uint64_t v10;
  void *v11;
  __int16 *v12;

  v9 = *(__int16 **)(a1 + 48);
  if (v9)
  {
    sub_1B193FB20(*(_QWORD *)(a1 + 56), *(void **)(a1 + 32), v9, a4, a5, a6, a7, a8);
    CFRelease(*(CFTypeRef *)(a1 + 48));
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 56);
    v11 = *(void **)(a1 + 32);
    v12 = *(__int16 **)(a1 + 40);
    if (v12)
      sub_1B193FB20(v10, v11, v12, a4, a5, a6, a7, a8);
    else
      sub_1B193FC30(v10, v11, 0, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B18DE354(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const char *v5;
  uint64_t v6;

  objc_opt_class();
  result = objc_opt_isKindOfClass();
  if ((result & 1) != 0)
    return objc_msgSend_addObject_(*(void **)(a1 + 32), v5, a2, v6);
  return result;
}

uint64_t sub_1B18DE520(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_compare_(a2, (const char *)a2, a3, a4);
}

uint64_t sub_1B18DE5C8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result;
  const char *v6;
  uint64_t v7;

  result = sub_1B188E0C8(a3);
  if ((_DWORD)result)
    return objc_msgSend_addObject_(*(void **)(a1 + 32), v6, a2, v7);
  return result;
}

uint64_t sub_1B18DE6A8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result;
  const char *v6;
  uint64_t v7;

  result = sub_1B188E0C8(a3);
  if ((_DWORD)result)
    return objc_msgSend_addObject_(*(void **)(a1 + 32), v6, (uint64_t)a3, v7);
  return result;
}

void sub_1B18DEA54(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;

  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40), a4);
  if ((sub_1B18C2F24(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 56));
    objc_msgSend_removeObjectForKey_(*(void **)(*(_QWORD *)(a1 + 40) + 64), v10, *(_QWORD *)(a1 + 48), v11);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 56));
  }
}

void sub_1B18DEC24(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C30E4(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B18DECD0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C3148(*(void **)(a1 + 32), a2, a3, a4, *(float *)(a1 + 40));
}

void sub_1B18DED8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C2FF4(*(void **)(a1 + 32), *(char **)(a1 + 40), a3, a4);
}

void sub_1B18DEE50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C3064(*(void **)(a1 + 32), *(char **)(a1 + 40), a3, a4, *(float *)(a1 + 48));
}

void sub_1B18DF330(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFXBinding *v24;

  v5 = (_QWORD *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  v24 = objc_alloc_init(CFXBinding);
  v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(_QWORD *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(_QWORD *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(_QWORD *)(a1 + 64), v17);
  sub_1B193F4C8(v5, v24, v18, v19, v20, v21, v22, v23);

}

void sub_1B18DF45C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B193F704(v5, *(const __CFString **)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B18DF508(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B193F68C(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t VFXVector3EqualToVector3(float32x4_t a1, float32x4_t a2)
{
  int16x4_t v2;
  __int8 v3;

  v2 = vmovn_s32(vceqq_f32(a1, a2));
  if ((v2.i16[0] & v2.i16[1] & 1) != 0)
    v3 = v2.i8[4];
  else
    v3 = 0;
  return v3 & 1;
}

uint64_t VFXVector4EqualToVector4(float32x4_t a1, float32x4_t a2)
{
  __int8 v2;
  int32x4_t v3;
  int16x4_t v4;

  v2 = 0;
  v3 = vceqq_f32(a1, a2);
  v4 = vmovn_s32(v3);
  if ((v4.i8[4] & 1) != 0 && (vand_s8(*(int8x8_t *)v3.i8, (int8x8_t)vdup_n_s32(v4.u16[1])).u8[0] & 1) != 0)
    v2 = v4.i8[6];
  return v2 & 1;
}

float64x2_t sub_1B18DFCCC(float32x2_t *a1, float64x2_t *a2)
{
  float64x2_t result;
  float64x2_t v3;
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;

  result = vcvtq_f64_f32(*a1);
  v3 = vcvtq_f64_f32(a1[1]);
  v4 = vcvtq_f64_f32(a1[2]);
  v5 = vcvtq_f64_f32(a1[3]);
  v6 = vcvtq_f64_f32(a1[4]);
  v7 = vcvtq_f64_f32(a1[5]);
  v8 = vcvtq_f64_f32(a1[6]);
  v9 = vcvtq_f64_f32(a1[7]);
  *a2 = result;
  a2[1] = v3;
  a2[2] = v4;
  a2[3] = v5;
  a2[4] = v6;
  a2[5] = v7;
  a2[6] = v8;
  a2[7] = v9;
  return result;
}

float64x2_t sub_1B18DFD10(float32x4_t *a1, float64x2_t *a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float64x2_t result;
  float32x4_t v5;

  v2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(a2[2]), a2[3]);
  v3 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(a2[4]), a2[5]);
  result = a2[7];
  v5 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(a2[6]), result);
  *a1 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*a2), a2[1]);
  a1[1] = v2;
  a1[2] = v3;
  a1[3] = v5;
  return result;
}

double VFXMatrix4Scale(float32x4_t a1, double a2, double a3, double a4, float a5)
{
  double result;

  *(_QWORD *)&result = vmulq_n_f32(a1, a5).u64[0];
  return result;
}

__n64 VFXMatrix4MakeRotation(float a1, float32x4_t a2, float32_t a3, float32_t a4)
{
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  int8x16_t v8;
  int32x4_t v9;
  __float2 v15;
  float32x4_t v16;
  float32x4_t v17;
  __n64 result;
  float32x4_t v19;
  float32x4_t v20;

  a2.f32[1] = a3;
  a2.f32[2] = a4;
  v4 = vmulq_f32(a2, a2);
  v4.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u64[0];
  v5 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 0);
  v5.i32[3] = 0;
  v6 = vrsqrteq_f32(v5);
  v7 = vmulq_f32(v6, vrsqrtsq_f32(v5, vmulq_f32(v6, v6)));
  v8 = (int8x16_t)vmulq_f32(v7, vrsqrtsq_f32(v5, vmulq_f32(v7, v7)));
  v9 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v4.f32[0] != 0.0)), 0x1FuLL));
  v9.i32[3] = 0;
  __asm { FMOV            V4.4S, #1.0 }
  v19 = vmulq_f32(a2, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v9), v8, _Q4));
  v20 = (float32x4_t)_Q4;
  v15 = __sincosf_stret(a1);
  v16 = v19;
  v17 = vmulq_f32(v16, v16);
  result.n64_u32[0] = vmlaq_n_f32(v17, vsubq_f32(v20, v17), v15.__cosval).u32[0];
  result.n64_f32[1] = (float)((float)(1.0 - v15.__cosval) * vmulq_lane_f32(v16, *(float32x2_t *)v16.f32, 1).f32[0])
                    - COERCE_FLOAT(vmulq_n_f32(v19, -*(float *)&v15).i32[2]);
  return result;
}

BOOL VFXMatrix4EqualToMatrix4(__n128 a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8)
{
  _OWORD v9[4];
  _OWORD __s1[4];

  __s1[0] = a1;
  __s1[1] = a2;
  __s1[2] = a3;
  __s1[3] = a4;
  v9[0] = a5;
  v9[1] = a6;
  v9[2] = a7;
  v9[3] = a8;
  return memcmp(__s1, v9, 0x40uLL) == 0;
}

BOOL VFXMatrix4IsIdentity(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  _OWORD v5[4];
  _OWORD __s1[4];

  __s1[0] = a1;
  __s1[1] = a2;
  __s1[2] = a3;
  __s1[3] = a4;
  v5[0] = xmmword_1B2244DB0;
  v5[1] = xmmword_1B2244DD0;
  v5[2] = xmmword_1B2244D90;
  v5[3] = xmmword_1B2244E20;
  return memcmp(__s1, v5, 0x40uLL) == 0;
}

double VFXMatrix4Rotate(__n128 a1, float32x4_t a2, __n128 a3, __n128 a4, float a5, float32_t a6, float32_t a7, float32_t a8)
{
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  uint64_t v12;
  float32x4_t v15;
  _OWORD v18[4];
  _OWORD v19[4];

  v15 = a2;
  a2.f32[0] = a6;
  *(__n64 *)v8.f32 = VFXMatrix4MakeRotation(a5, a2, a7, a8);
  v12 = 0;
  v18[0] = a1;
  v18[1] = v15;
  v18[2] = a3;
  v18[3] = a4;
  memset(v19, 0, sizeof(v19));
  do
  {
    v19[v12] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v8, COERCE_FLOAT(v18[v12])), v9, *(float32x2_t *)&v18[v12], 1), v10, (float32x4_t)v18[v12], 2), v11, (float32x4_t)v18[v12], 3);
    ++v12;
  }
  while (v12 != 4);
  return *(double *)v19;
}

uint64_t sub_1B18DFFAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFDictionary *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  unsigned __int8 v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t i;
  _OWORD *v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  __int16 v76;
  __n128 v77;
  char v78;
  __int128 v79;
  char v80;
  char v81;
  uint64_t v82;
  int v83;
  __int16 v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v72 = a2;
  *((_QWORD *)&v72 + 1) = a3;
  v10 = atomic_load((unsigned __int8 *)&qword_1EEF66160);
  if ((v10 & 1) == 0 && __cxa_guard_acquire(&qword_1EEF66160))
  {
    byte_1EEF66158 = 1;
    __cxa_guard_release(&qword_1EEF66160);
  }
  if (byte_1EEF66158)
    v11 = 0xDFD87824203AD5B5;
  else
    v11 = 0;
  sub_1B182AAEC(a1, a2, a3, a4, v11, a5);
  *(_QWORD *)a1 = &off_1E63CE5C8;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 400) = 0;
  v19 = sub_1B1814768(*(uint64_t **)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
  v27 = sub_1B186CFA8((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26);
  if (v27)
  {
    if (sub_1B18650B8((uint64_t)v27, v28, v29, v30, v31, v32, v33, v34))
      v35 = 2560;
    else
      v35 = 512;
  }
  else
  {
    v35 = 512;
  }
  v37 = a4[4];
  v36 = a4[5];
  *(_QWORD *)&v73 = *(_QWORD *)(a1 + 368);
  v75 = 0;
  v74 = (unint64_t)sub_1B1814768((uint64_t *)v73, v28, v29, v30, v31, v32, v33, v34);
  v77 = sub_1B181537C(*(_QWORD *)(a1 + 368), 0, v38, v39, v40, v41, v42, v43);
  v78 = 1;
  v79 = xmmword_1B2245710;
  v80 = *(_BYTE *)(a1 + 376);
  v81 = 2;
  v82 = 34;
  v83 = 1;
  v84 = 1;
  *(_QWORD *)(a1 + 384) = sub_1B17CA2A0(v72, *((uint64_t *)&v72 + 1), (uint64_t *)&v72, (uint64_t *)&v73, &v74);
  v44 = v72;
  v45 = *(_QWORD *)(a1 + 368);
  *(_QWORD *)&v74 = 0;
  WORD4(v74) = v35;
  BYTE10(v74) = *(_BYTE *)(a1 + 377);
  v75 = 2;
  v76 = 0;
  v46 = atomic_load((unsigned __int8 *)&qword_1EEF66160);
  if ((v46 & 1) == 0)
  {
    v71 = v72;
    v70 = __cxa_guard_acquire(&qword_1EEF66160);
    v44 = v71;
    if (v70)
    {
      byte_1EEF66158 = 1;
      __cxa_guard_release(&qword_1EEF66160);
      v44 = v71;
    }
  }
  if (byte_1EEF66158)
    v47 = 0xDFD87824203AD5B5;
  else
    v47 = 0;
  v77.n128_u64[0] = v47;
  v73 = v44;
  v48 = sub_1B179C1C0(&v73, 0x40u, 8u);
  sub_1B182CDF0(v48, v45, (uint64_t)&v74, *(_QWORD *)(a1 + 384));
  *(_QWORD *)(a1 + 392) = v49;
  if (v37)
    CFX::RG::Pass::renderTo(a1, v37, 0x100000002, 0);
  if (v36)
    CFX::RG::Pass::renderTo(a1, v36, 0x200000002, -1);
  CFX::RG::Pass::renderTo(a1, a4[6], 0x100000002, 3);
  CFX::RG::Pass::renderTo(a1, a4[7], 0x100000002, 1);
  CFX::RG::Pass::renderTo(a1, a4[8], 0x100000002, 2);
  CFX::RG::Pass::renderTo(a1, a4[9], 0x100000002, 0);
  CFX::RG::Pass::renderTo(a1, a4[10], 0x100000002, 4);
  CFX::RG::Pass::renderTo(a1, a4[11], 0x100000002, 5);
  CFX::RG::Pass::renderTo(a1, a4[12], 0x100000002, 6);
  for (i = 0; i != 256; i += 32)
  {
    v51 = (_OWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1) + i);
    *v51 = 0u;
    v51[1] = 0u;
  }
  sub_1B1815A88(*(_QWORD *)(a1 + 368), a4[10] != 0);
  sub_1B19610E0(*(__n128 **)(a1 + 384), v52, v53, v54);
  sub_1B196142C(*(_QWORD *)(a1 + 384), v55, v56, v57, v58, v59, v60, v61);
  sub_1B1961820(*(_QWORD *)(a1 + 384));
  sub_1B196184C(*(_QWORD *)(a1 + 384), v62, v63, v64, v65, v66, v67, v68);
  return a1;
}

void sub_1B18E0338(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B18E0364(CFX::RG::Pass *this, uint64_t a2)
{
  uint64_t v4;
  CFX::CrossFrameResourceManager *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v4 = *((_QWORD *)this + 50);
  if (!v4)
  {
    v5 = *(CFX::CrossFrameResourceManager **)(a2 + 32);
    v6 = CFX::RG::Pass::hash(this);
    *((_QWORD *)this + 50) = sub_1B18E0420(v5, v6);
    v7 = sub_1B1877ABC();
    sub_1B193E5B0(v7, CFSTR("--GBufferMaterial--"), v8, v9, v10, v11, v12, v13);
    v21 = sub_1B187813C(v7, v14, v15, v16, v17, v18, v19, v20);
    sub_1B18412A8(v21, 0, v22, v23, v24, v25, v26, v27);
    v4 = *((_QWORD *)this + 50);
    v28 = *(const void **)(v4 + 16);
    if (v28 != (const void *)v7)
    {
      v29 = *((_QWORD *)this + 50);
      if (v28)
      {
        CFRelease(v28);
        v29 = *((_QWORD *)this + 50);
      }
      *(_QWORD *)(v4 + 16) = v7;
      v4 = v29;
    }
  }
  sub_1B19618B0(*((_QWORD *)this + 48), v4 + 32, 0x10u);
  sub_1B182CE18(*((_QWORD *)this + 49), (const char *)a2, v30, v31);
  sub_1B1961A30(*((uint64_t **)this + 48), *(const char **)a2, *(_QWORD *)(a2 + 8), v32);
}

uint64_t sub_1B18E0420(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v4)
  {
    v4 = operator new();
    sub_1B18E06F4(v4);
    CFX::CrossFrameResourceManager::set((uint64_t)a1, a2, v4);
  }
  return v4;
}

void sub_1B18E0488(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E22E18](v1, 0x10A1C407E34DEDDLL);
  _Unwind_Resume(a1);
}

void sub_1B18E04AC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B182CE18(*(_QWORD *)(a1 + 392), a2, a3, a4);
}

void sub_1B18E04B4(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  float32x2_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x2_t v10;
  uint64_t v11;
  int8x16_t *v12;
  int8x16_t v13;
  int8x16_t v14;
  uint64_t v15;
  float32x4_t *v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _OWORD *v27;
  _OWORD v28[4];
  _OWORD v29[4];

  sub_1B182D4E8(*(_QWORD *)(a1 + 392), a2, a3, 0);
  sub_1B1961910(*(_QWORD *)(a1 + 384), *(_QWORD *)(a1 + 400) + 32, 0x10u);
  sub_1B1961970(*(_QWORD *)(a1 + 384), *(_QWORD *)(a1 + 400) + 1056, 0x10u);
  sub_1B19619D0(*(_QWORD *)(a1 + 384), *(_QWORD *)(a1 + 400) + 2080, 0x10u);
  if (sub_1B1816000(*(_QWORD *)(a1 + 368)) && *(_BYTE *)(*(_QWORD *)(a1 + 384) + 132))
  {
    v6 = 0;
    do
    {
      v7 = sub_1B1816010(*(float32x2_t **)(a1 + 368), 0, v4, v5);
      v10 = sub_1B1816010(*(float32x2_t **)(a1 + 368), (const char *)1, v8, v9);
      v11 = 0;
      v12 = (int8x16_t *)(*(_QWORD *)(a1 + 400) + (v6 << 6));
      v13 = v12[132];
      *(float32x2_t *)v14.i8 = vadd_f32(vsub_f32(v10, v7), *(float32x2_t *)v13.i8);
      v14.i64[1] = vextq_s8(v13, v13, 8uLL).u64[0];
      v12[132] = v14;
      v15 = *(_QWORD *)(a1 + 400);
      v16 = (float32x4_t *)(v15 + (v6 << 6));
      v17 = v16[130];
      v18 = v16[131];
      v19 = v16[132];
      v20 = v16[133];
      v21 = v16[67];
      v22 = v16[68];
      v23 = v16[69];
      v28[0] = v16[66];
      v28[1] = v21;
      v28[2] = v22;
      v28[3] = v23;
      do
      {
        v29[v11] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, COERCE_FLOAT(v28[v11])), v18, *(float32x2_t *)&v28[v11], 1), v19, (float32x4_t)v28[v11], 2), v20, (float32x4_t)v28[v11], 3);
        ++v11;
      }
      while (v11 != 4);
      v24 = v29[1];
      v25 = v29[2];
      v26 = v29[3];
      v27 = (_OWORD *)(v15 + (v6 << 6));
      v27[2] = v29[0];
      v27[3] = v24;
      v27[4] = v25;
      v27[5] = v26;
      ++v6;
    }
    while (v6 < *(unsigned __int8 *)(*(_QWORD *)(a1 + 384) + 132));
  }
}

uint64_t sub_1B18E0610(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unint64_t v11;
  unint64_t v13;

  v10 = sub_1B1813884(a2[1], (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v11 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v10) ^ ((0x9DDFEA08EB382D69 * v10) >> 47));
  v13 = 0x9DDFEA08EB382D69 * (v11 ^ (v11 >> 47));
  return sub_1B18E0678(a1, a2, (uint64_t *)&v13);
}

uint64_t sub_1B18E0678(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B18E07F8(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

void sub_1B18E06D0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B18E06F4(uint64_t result)
{
  uint64_t i;
  _OWORD *v2;

  *(_BYTE *)(result + 8) = 0;
  *(_QWORD *)result = &off_1E63CE5A8;
  *(_QWORD *)(result + 16) = 0;
  for (i = 1056; i != 2080; i += 64)
  {
    v2 = (_OWORD *)(result + i);
    *(_OWORD *)(result + i - 1024) = xmmword_1B2244DB0;
    *(_OWORD *)(result + i - 1008) = xmmword_1B2244DD0;
    *(_OWORD *)(result + i - 992) = xmmword_1B2244D90;
    *(_OWORD *)(result + i - 976) = xmmword_1B2244E20;
    *v2 = xmmword_1B2244DB0;
    v2[1] = xmmword_1B2244DD0;
    v2[2] = xmmword_1B2244D90;
    v2[3] = xmmword_1B2244E20;
    v2[64] = xmmword_1B2244DB0;
    v2[65] = xmmword_1B2244DD0;
    v2[66] = xmmword_1B2244D90;
    v2[67] = xmmword_1B2244E20;
  }
  return result;
}

_QWORD *sub_1B18E0778(_QWORD *a1)
{
  const void *v2;

  *a1 = &off_1E63CE5A8;
  v2 = (const void *)a1[2];
  if (v2)
    CFRelease(v2);
  return a1;
}

void sub_1B18E07B0(_QWORD *a1)
{
  const void *v1;

  *a1 = &off_1E63CE5A8;
  v1 = (const void *)a1[2];
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B18E07F8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x198u, 8u);
  return sub_1B18DFFAC(v8, *a3, a3[1], a4, *a5);
}

uint64_t sub_1B18E0854(uint64_t a1, float a2)
{
  float v3;
  __float2 v4;
  __float2 v5;
  __float2 v6;
  __float2 v7;
  __float2 v8;
  __float2 v9;
  __float2 v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _OWORD v23[3];
  __int128 v24;
  __int128 v25;
  __int128 v26;

  v3 = (1.0 - a2) * 6.28318531;
  v10 = __sincosf_stret(v3);
  v11 = 0;
  v12.i32[3] = 0;
  v12.i64[0] = LODWORD(v10.__cosval);
  v13.i64[0] = LODWORD(v10.__sinval);
  v13.i64[1] = LODWORD(v10.__cosval);
  v24 = xmmword_1B2244DB0;
  v25 = xmmword_1B2244DD0;
  v26 = xmmword_1B2246580;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  do
  {
    v12.f32[2] = -v10.__sinval;
    *(__int128 *)((char *)&v19 + v11) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v12, COERCE_FLOAT(*(__int128 *)((char *)&v24 + v11))), (float32x4_t)xmmword_1B2244DD0, *(float32x2_t *)((char *)&v24 + v11), 1), v13, *(float32x4_t *)((char *)&v24 + v11), 2);
    v11 += 16;
  }
  while (v11 != 48);
  v14 = 0;
  v23[0] = v19;
  v23[1] = v20;
  v23[2] = v21;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  do
  {
    *(__int128 *)((char *)&v24 + v14 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2247E00, COERCE_FLOAT(v23[v14])), (float32x4_t)xmmword_1B2247E10, *(float32x2_t *)&v23[v14], 1), (float32x4_t)xmmword_1B2244D90, (float32x4_t)v23[v14], 2);
    ++v14;
  }
  while (v14 != 3);
  v15 = v24;
  v16 = v25;
  v17 = v26;
  HIDWORD(v15) = 0;
  HIDWORD(v16) = 0;
  HIDWORD(v17) = 0;
  v19 = v15;
  v20 = v16;
  v21 = v17;
  v22 = xmmword_1B2244E20;
  return sub_1B17B04C0(a1, (float *)&v19, *(_QWORD *)&v4, *(_QWORD *)&v5, *(_QWORD *)&v6, *(_QWORD *)&v7, *(_QWORD *)&v8, *(_QWORD *)&v9);
}

void sub_1B18E09B0(float *a1, int a2, float a3, float a4, float a5, double a6, double a7, float a8, float a9)
{
  BOOL v11;
  float v12;
  float v13;
  double v14;
  __double2 v15;
  float v16;
  float v17;
  float v18;
  double v19;
  __double2 v20;
  float v21;
  uint64_t v22;

  v11 = a5 < 0.0;
  v12 = -1.0;
  if (!v11)
    v12 = 1.0;
  if (a2 == 3)
  {
    v18 = (1.0 - a8 + (float)((float)(a4 * a8) / a3)) * 0.5;
    v19 = v18;
    v20 = __sincos_stret(a9 * 6.28318531);
    v21 = v19 * v20.__cosval + 0.5;
    *a1 = v21;
    v17 = v19 * v20.__sinval + 0.5;
    v22 = 1;
  }
  else
  {
    if (a2 == 1)
    {
      *a1 = 0.0;
      a1[1] = v12;
      v17 = 0.0;
    }
    else
    {
      if (a2)
        return;
      v13 = (float)(a4 * a8) + (1.0 - a8) * a3;
      v14 = (float)(v12 * v13);
      v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      v16 = v15.__sinval * v14;
      *a1 = v16;
      a1[1] = a5;
      v17 = v15.__cosval * v13;
    }
    v22 = 2;
  }
  a1[v22] = v17;
}

void sub_1B18E0AD4(float *a1, int a2, float a3, float a4, float a5, double a6, double a7, float a8, float a9)
{
  double v11;
  float v12;
  double v13;
  __double2 v14;
  __double2 v15;
  float v16;
  float v17;
  uint64_t v18;
  __double2 v19;
  __double2 v20;
  float v21;
  float sinval;
  float v23;

  v11 = 1.0 - a8;
  if (a2 == 3)
  {
    *a1 = a9;
    v18 = 1;
  }
  else
  {
    v12 = (a5 + -0.5) * a8 + (a4 + -0.5) * v11;
    if (a2 == 1)
    {
      v19 = __sincos_stret(v12 * 3.14159265);
      v20 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      v21 = v20.__sinval * v19.__cosval;
      sinval = v19.__sinval;
      *a1 = v21;
      a1[1] = sinval;
      v11 = v20.__cosval * v19.__cosval;
    }
    else
    {
      if (a2)
        return;
      v13 = a3;
      v14 = __sincos_stret(v12 * 3.14159265);
      v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      v16 = v15.__sinval * (v14.__cosval * v13);
      v17 = v14.__sinval * v13;
      *a1 = v16;
      a1[1] = v17;
      v11 = v15.__cosval * (v14.__cosval * v13);
    }
    v18 = 2;
  }
  v23 = v11;
  a1[v18] = v23;
}

void sub_1B18E0BF8(float *a1, int a2, float a3, float a4, double a5, double a6, double a7, float a8, float a9)
{
  BOOL v12;
  float v13;
  double v14;
  __double2 v15;
  float v16;
  float v17;
  float cosval;
  __double2 v19;
  float sinval;

  v12 = a4 <= 0.0;
  v13 = 3.1416;
  if (v12)
    v13 = 0.0;
  if (a2 == 3)
  {
    if (a4 <= 0.0)
    {
      *a1 = 1.0 - a9;
      a1[1] = a8;
    }
    else
    {
      *a1 = a9;
      a1[1] = 1.0 - a8;
    }
  }
  else
  {
    if (a2 == 1)
    {
      v19 = __sincos_stret(v13 + a9 * 6.28318531);
      sinval = v19.__sinval;
      *a1 = sinval;
      a1[1] = 0.0;
      cosval = v19.__cosval;
    }
    else
    {
      if (a2)
        return;
      v14 = a3;
      v15 = __sincos_stret(v13 + a9 * 6.28318531);
      v16 = v15.__sinval * v14;
      v17 = (a8 + -0.5) * a4;
      *a1 = v16;
      a1[1] = v17;
      cosval = v15.__cosval * v14;
    }
    a1[2] = cosval;
  }
}

void sub_1B18E0CF0(float *a1, int a2, float a3, float a4, float a5, double a6, double a7, float a8, float a9)
{
  double v13;
  double v14;
  __double2 v15;
  float v16;
  float v17;
  float v18;
  __double2 v19;
  float sinval;
  float v21;
  float cosval;
  float v23;

  if (a2 == 3)
  {
    *a1 = a9;
    a1[1] = 1.0 - a8;
  }
  else
  {
    if (a2 == 1)
    {
      v19 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      sinval = v19.__sinval;
      v21 = (float)(a4 - a3) / a5;
      cosval = v19.__cosval;
      v23 = sqrtf((float)((float)(v21 * v21) + (float)(sinval * sinval)) + (float)(cosval * cosval));
      *a1 = sinval / v23;
      a1[1] = v21 / v23;
      v18 = cosval / v23;
    }
    else
    {
      if (a2)
        return;
      v13 = a8;
      v14 = (float)(a3 * a8) + (1.0 - a8) * a4;
      v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      v16 = v14 * v15.__sinval;
      v17 = (v13 + -0.5) * a5;
      *a1 = v16;
      a1[1] = v17;
      v18 = v14 * v15.__cosval;
    }
    a1[2] = v18;
  }
}

void sub_1B18E0E00(float *a1, int a2, float a3, float a4, double a5, double a6, double a7, float a8, float a9)
{
  double v11;
  double v12;
  __double2 v13;
  double v14;
  __double2 v15;
  float v16;
  float v17;
  double v18;
  float v19;
  uint64_t v20;
  __double2 v21;
  __double2 v22;
  float v23;
  float sinval;

  if (a2 == 3)
  {
    *a1 = a9;
    v19 = 1.0 - a8;
    v20 = 1;
  }
  else
  {
    if (a2 == 1)
    {
      v21 = __sincos_stret((a8 + -0.5) * 6.28318531);
      v22 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      v23 = v21.__cosval * v22.__sinval;
      sinval = v21.__sinval;
      *a1 = v23;
      a1[1] = sinval;
      v18 = v21.__cosval * v22.__cosval;
    }
    else
    {
      if (a2)
        return;
      v11 = a3;
      v12 = a4;
      v13 = __sincos_stret((a8 + -0.5) * 6.28318531);
      v14 = v11 + v12 * v13.__cosval;
      v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      v16 = v15.__sinval * v14;
      v17 = v13.__sinval * v12;
      *a1 = v16;
      a1[1] = v17;
      v18 = v15.__cosval * v14;
    }
    v19 = v18;
    v20 = 2;
  }
  a1[v20] = v19;
}

void sub_1B18E0F14(float *a1, int a2, int a3, float a4, float a5, double a6, double a7, double a8, float a9, float a10)
{
  double v15;
  __double2 v16;
  double v17;
  double cosval;
  __double2 v19;
  float v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  uint64_t v26;
  double v27;
  double v28;
  double v29;
  double v30;
  __double2 v31;
  __double2 v32;
  float v33;
  float v34;
  __double2 v35;
  float v36;
  __double2 v37;
  __double2 v38;
  float v39;
  float v40;
  __double2 v41;
  float sinval;
  float v43;

  if (a2 == 3)
  {
    *a1 = a10;
    v22 = (float)(a4 / a5);
    v23 = 1.0 - v22;
    v24 = 1.0 - a9;
    v25 = (float)((float)(a4 / a5) * a9) + (1.0 - v22) * v24;
    v26 = 1;
    v27 = v24 * v22;
    v28 = v24 + a9 * v23;
    if (!a3)
      v27 = v28;
    if (a3 == 1)
      v27 = v25;
    else
      v26 = 1;
    goto LABEL_24;
  }
  if (a2 != 1)
  {
    if (a2)
      return;
    if (a3 == 2)
    {
      v30 = a4;
      v31 = __sincos_stret(a9 * 1.57079633);
      v32 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
      v33 = v31.__cosval * v30 * v32.__sinval;
      v34 = a5 * 0.5 + v30 * v31.__sinval - v30;
      *a1 = v33;
      a1[1] = v34;
      v27 = v31.__cosval * v30 * v32.__cosval;
    }
    else
    {
      if (a3 == 1)
      {
        v17 = a4;
        v35 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
        cosval = v35.__cosval;
        v20 = v35.__sinval * v17;
        v21 = (a9 + -0.5) * (float)(a5 + (float)(a4 * -2.0));
      }
      else
      {
        if (a3)
          return;
        v15 = a4;
        v16 = __sincos_stret((a9 + -1.0) * 1.57079633);
        v17 = v16.__cosval * v15;
        v19 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
        cosval = v19.__cosval;
        v20 = v19.__sinval * (v16.__cosval * v15);
        v21 = a5 * -0.5 + v15 * v16.__sinval + v15;
      }
      v36 = v21;
      *a1 = v20;
      a1[1] = v36;
      v27 = cosval * v17;
    }
    goto LABEL_23;
  }
  if (a3 == 2)
  {
    v29 = a9;
  }
  else
  {
    if (a3 == 1)
    {
      v41 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
      v27 = v41.__cosval;
      sinval = v41.__sinval;
      *a1 = sinval;
      a1[1] = 0.0;
      goto LABEL_23;
    }
    if (a3)
      return;
    v29 = a9 + -1.0;
  }
  v37 = __sincos_stret(v29 * 1.57079633);
  v38 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
  v39 = v37.__cosval * v38.__sinval;
  v40 = v37.__sinval;
  *a1 = v39;
  a1[1] = v40;
  v27 = v37.__cosval * v38.__cosval;
LABEL_23:
  v26 = 2;
LABEL_24:
  v43 = v27;
  a1[v26] = v43;
}

void sub_1B18E11A0(uint64_t a1, int a2, float a3, float32x4_t a4, float a5, float a6, float a7, float a8, float a9)
{
  float32x2_t v12;
  int v13;
  float v14;
  double v15;
  double v16;
  double cosval;
  __double2 v18;
  float v19;
  double v20;
  double v21;
  __double2 v22;
  float v23;
  double v24;
  double v25;
  double v26;
  __double2 v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float32x2_t v33;
  float v34;
  double v35;
  double v36;
  float32x2_t v37;
  float32x4_t v38;
  float v39;
  float v40;
  float32_t v41;
  int32x4_t v42;
  float32x2_t v43;
  float32x2_t v44;
  float v51;
  double v52;
  __double2 v53;
  float v54;
  float v56;
  float v57;

  _S21 = a3;
  v12 = vcvt_f32_s32((int32x2_t)(*(_QWORD *)&vceqz_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32((int)a7), (int8x8_t)0x200000001)) | 0x100000001));
  if (((int)a7 & 4) != 0)
    v13 = 1;
  else
    v13 = -1;
  v14 = (float)v13;
  if (a9 != 0.0)
  {
    if (a8 != 0.0)
    {
      v29 = _S21 / 1.41421356;
      v30 = _S21 / 1.73205081;
      v31 = v29 * v12.f32[0];
      v32 = v29 * v14;
      v33 = vmul_n_f32(v12, v30);
      v34 = vmuls_lane_f32(v29, v12, 1);
      v35 = 1.0 - a8;
      v36 = 1.0 - a9;
      v37.i32[0] = 0;
      v37.f32[1] = v34;
      v38 = (float32x4_t)vcvtq_f64_f32(vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(v37, a8)), (float64x2_t)0, v35)));
      *(float32x2_t *)v38.f32 = vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(v33, a8)), (float64x2_t)COERCE_UNSIGNED_INT64(v31), v35)), a9)), (float64x2_t)v38, v36));
      v39 = (float)(v32 * a8) + v35 * (float)(v14 * _S21);
      v40 = (float)((float)(v30 * v14) * a8) + v35 * v32;
      v41 = (float)(v40 * a9) + v36 * v39;
      v38.f32[2] = v41;
      v42 = (int32x4_t)vmulq_f32(v38, v38);
      v42.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v42, 2), vadd_f32(*(float32x2_t *)v42.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v42.i8, 1))).u32[0];
      v43 = vrsqrte_f32((float32x2_t)v42.u32[0]);
      v44 = vmul_f32(v43, vrsqrts_f32((float32x2_t)v42.u32[0], vmul_f32(v43, v43)));
      _Q0 = vmulq_n_f32(v38, vmul_f32(v44, vrsqrts_f32((float32x2_t)v42.u32[0], vmul_f32(v44, v44))).f32[0]);
      if (!a2)
      {
        a4.f32[1] = a5;
        *(float32x2_t *)a4.f32 = vmla_n_f32(*(float32x2_t *)a4.f32, *(float32x2_t *)_Q0.f32, _S21);
        __asm { FMLA            S3, S21, V0.S[2] }
        a4.i32[2] = _S3;
        _Q0 = a4;
      }
      *(_QWORD *)a1 = _Q0.i64[0];
      v51 = _Q0.f32[2];
      goto LABEL_20;
    }
    if (a2 != 1)
    {
      if (a2)
        return;
      v20 = a4.f32[0];
      v21 = (float)(_S21 * v12.f32[0]);
      v56 = a6;
      v57 = _S21;
      v22 = __sincos_stret(a9 * 0.785398163);
      cosval = v22.__cosval;
      v23 = v20 + v21 * v22.__sinval;
      *(float *)a1 = v23;
      *(float *)(a1 + 4) = a5;
      goto LABEL_12;
    }
    v52 = v12.f32[0];
    v53 = __sincos_stret(a9 * 0.785398163);
    v26 = v53.__cosval;
    v54 = v53.__sinval * v52;
    *(float *)a1 = v54;
    *(_DWORD *)(a1 + 4) = 0;
LABEL_18:
    v24 = v26 * v14;
    goto LABEL_19;
  }
  if (a2 == 1)
  {
    *(_DWORD *)a1 = 0;
    v25 = v12.f32[1];
    v27 = __sincos_stret(a8 * 0.785398163);
    v26 = v27.__cosval;
    v28 = v27.__sinval * v25;
    *(float *)(a1 + 4) = v28;
    goto LABEL_18;
  }
  if (a2)
    return;
  *(_DWORD *)a1 = a4.i32[0];
  v15 = a5;
  v16 = vmuls_lane_f32(_S21, v12, 1);
  v56 = a6;
  v57 = _S21;
  v18 = __sincos_stret(a8 * 0.785398163);
  cosval = v18.__cosval;
  v19 = v15 + v16 * v18.__sinval;
  *(float *)(a1 + 4) = v19;
LABEL_12:
  v24 = v56 + (float)(v14 * v57) * cosval;
LABEL_19:
  v51 = v24;
LABEL_20:
  *(float *)(a1 + 8) = v51;
}

void sub_1B18E1458(float *a1, int a2, int a3, int a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, double a12)
{
  float v16;
  double v20;
  float v21;
  __float2 v22;
  float32x4_t v23;
  float32x4_t v24;
  float v25;
  __float2 v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float v32;
  float32x4_t v33;
  float v34;
  float32x2_t v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float32x2_t v41;
  double v42;
  double v43;
  double v44;
  __double2 v45;
  float v46;
  float v47;
  float cosval;
  double v49;
  double v50;
  double v51;
  float v52;
  float v53;
  double v54;
  float v55;
  double v56;
  __double2 v57;
  float sinval;
  float v59;
  float v60;
  float v61;
  uint64_t v62;
  int v63;
  float v64;
  float v65;
  float v66;
  float32x2_t v67;
  __double2 v68;
  double v69;
  double v70;
  __double2 v71;
  float v72;
  double v73;
  double v74;
  __double2 v75;
  float v76;
  float32x4_t v77;
  float v78;
  float v80;
  float v81;
  float v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  double v87;
  float v88;
  double v89;
  float v90;
  float32x4_t v91;
  float32x4_t v92;

  *(float *)&a12 = a8;
  v16 = a6;
  if (a9 >= 4.0)
  {
    v27 = (float32x4_t)xmmword_1B2244DB0;
    if (a9 == 4.0)
    {
      v91 = (float32x4_t)xmmword_1B2246F40;
      v31 = (float32x4_t)xmmword_1B2246F30;
      v29 = (float32x4_t)xmmword_1B2246F20;
      v92 = (float32x4_t)xmmword_1B2244DB0;
      v30 = (float32x4_t)xmmword_1B2246F10;
    }
    else
    {
      v91 = (float32x4_t)xmmword_1B2246F20;
      v31 = (float32x4_t)xmmword_1B2246F10;
      v29 = (float32x4_t)xmmword_1B2246F40;
      v92 = (float32x4_t)xmmword_1B2244DB0;
      v30 = (float32x4_t)xmmword_1B2246F30;
    }
  }
  else
  {
    v20 = a9;
    v21 = a9 * 1.57079633;
    v82 = a5;
    v87 = a12;
    v78 = a7;
    v22 = __sincosf_stret(v21);
    v23.i32[3] = 0;
    v23.i64[0] = LODWORD(v22.__cosval);
    v23.f32[2] = -v22.__sinval;
    v24.i64[0] = LODWORD(v22.__sinval);
    v24.i64[1] = LODWORD(v22.__cosval);
    v91 = v24;
    v92 = v23;
    v25 = v20 * -1.57079633;
    v26 = __sincosf_stret(v25);
    a7 = v78;
    v16 = a6;
    v27.i32[3] = 0;
    v27.i64[0] = LODWORD(v26.__cosval);
    v27.f32[2] = -v26.__sinval;
    a5 = v82;
    a12 = v87;
    v28.i64[0] = LODWORD(v26.__sinval);
    v28.i64[1] = LODWORD(v26.__cosval);
    v29 = v28;
    v30 = (float32x4_t)xmmword_1B2244DD0;
    v31 = (float32x4_t)xmmword_1B2244DD0;
  }
  v33 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v29, a7), v30, v16), v27, a5);
  v32 = fabsf(v33.f32[0]);
  *(float32x2_t *)v33.f32 = vabs_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v33, (int8x16_t)v33, 4uLL));
  if (a2 == 3)
  {
    v39 = *(float *)&a12 / v32;
    if (a4)
    {
      if (a4 != 2)
      {
        if (a4 != 1)
          goto LABEL_40;
        v40 = v39 * a11;
LABEL_39:
        *a1 = v40;
LABEL_40:
        v52 = 1.0 - a10;
        v53 = *(float *)&a12 / v33.f32[0];
        if (a3)
        {
          if (a3 != 1)
          {
            v55 = v52 * v53;
            goto LABEL_46;
          }
          v54 = v52 + (1.0 - v53) * (1.0 - v52);
        }
        else
        {
          v54 = (1.0 - v53) * v52 + (1.0 - v52) * v53;
        }
        v55 = v54;
LABEL_46:
        a1[1] = v55;
        return;
      }
      v51 = a11;
      v49 = 1.0 - a11;
      v50 = 1.0 - v39;
    }
    else
    {
      v49 = 1.0 - a11;
      v50 = v39;
      v51 = (1.0 - v50) * a11;
    }
    v40 = v51 + v49 * v50;
    goto LABEL_39;
  }
  v34 = v32 * 0.5;
  v35 = vmul_f32(*(float32x2_t *)v33.f32, (float32x2_t)0x3F0000003F000000);
  if (a2 != 1)
  {
    if (a2)
      return;
    v36 = v33.f32[0] + (float)(*(float *)&a12 * -2.0);
    if (a4 != 2)
    {
      if (a4 != 1)
      {
        if (!a4)
        {
          v37 = (a11 + -0.5) * (float)(v32 + (float)(*(float *)&a12 * -2.0));
          *a1 = v37;
          if (a3 != 2)
          {
            if (a3 != 1)
            {
              if (!a3)
              {
                v38 = (a10 + -0.5) * v36;
                a1[1] = v38;
                a1[2] = v35.f32[1];
              }
              goto LABEL_70;
            }
            v69 = (float)(*(float *)&a12 - v35.f32[0]);
            v70 = *(float *)&a12;
            v85 = v31;
            v90 = *(float *)&a12;
            v81 = v35.f32[1];
            v71 = __sincos_stret(a10 * 0.785398163 + -0.785398163);
            v31 = v85;
            v72 = v69 + v70 * v71.__sinval;
            v73 = (float)(v81 - v90) + v70 * v71.__cosval;
            goto LABEL_69;
          }
          v67 = vsub_f32(v35, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a12, 0));
          v89 = *(float *)&a12;
          v84 = v31;
          v68 = __sincos_stret(a10 * 0.785398163);
          v31 = v84;
          v41 = vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(v67), (float64x2_t)v68, v89));
          goto LABEL_64;
        }
        goto LABEL_70;
      }
      v83 = v31;
      if (a3 != 2)
      {
        if (a3 != 1)
        {
          if (a3)
            goto LABEL_70;
          v42 = (float)(*(float *)&a12 - v34);
          v43 = *(float *)&a12;
          v44 = a11 * 0.785398163 + -0.785398163;
LABEL_35:
          v88 = *(float *)&a12;
          v80 = v35.f32[1];
          v45 = __sincos_stret(v44);
          v46 = v42 + v43 * v45.__sinval;
          v47 = (a10 + -0.5) * v36;
          *a1 = v46;
          a1[1] = v47;
          v31 = v83;
          cosval = (float)(v80 - v88) + v43 * v45.__cosval;
LABEL_56:
          a1[2] = cosval;
          goto LABEL_70;
        }
        goto LABEL_61;
      }
      goto LABEL_60;
    }
    v83 = v31;
    if (a3 != 2)
    {
      if (a3 != 1)
      {
        if (a3)
          goto LABEL_70;
        v42 = (float)(v34 - *(float *)&a12);
        v43 = *(float *)&a12;
        v44 = a11 * 0.785398163;
        goto LABEL_35;
      }
      goto LABEL_58;
    }
LABEL_57:
    v33.f32[0] = v34 - *(float *)&a12;
    v59 = v35.f32[0] - *(float *)&a12;
    v60 = v35.f32[1] - *(float *)&a12;
    v61 = 7.0;
    v62 = (uint64_t)a1;
    v63 = a2;
    v64 = *(float *)&a12;
    v65 = a10;
LABEL_59:
    v66 = a11;
LABEL_62:
    sub_1B18E11A0(v62, v63, v64, v33, v59, v60, v61, v65, v66);
    v31 = v83;
    goto LABEL_70;
  }
  if (a4 == 2)
  {
    v83 = v31;
    if (a3 == 2)
      goto LABEL_57;
    if (a3 == 1)
    {
LABEL_58:
      v33.f32[0] = v34 - *(float *)&a12;
      v59 = *(float *)&a12 - v35.f32[0];
      v60 = v35.f32[1] - *(float *)&a12;
      v65 = 1.0 - a10;
      v61 = 5.0;
      v62 = (uint64_t)a1;
      v63 = a2;
      v64 = *(float *)&a12;
      goto LABEL_59;
    }
    if (a3)
      goto LABEL_70;
    v56 = a11 * 0.785398163;
LABEL_55:
    v57 = __sincos_stret(v56);
    v31 = v83;
    sinval = v57.__sinval;
    *a1 = sinval;
    a1[1] = 0.0;
    cosval = v57.__cosval;
    goto LABEL_56;
  }
  if (a4 == 1)
  {
    v83 = v31;
    if (a3 == 2)
    {
LABEL_60:
      v33.f32[0] = *(float *)&a12 - v34;
      v59 = v35.f32[0] - *(float *)&a12;
      v60 = v35.f32[1] - *(float *)&a12;
      v66 = 1.0 - a11;
      v61 = 6.0;
      v62 = (uint64_t)a1;
      v63 = a2;
      v64 = *(float *)&a12;
      v65 = a10;
      goto LABEL_62;
    }
    if (a3 == 1)
    {
LABEL_61:
      v33.f32[0] = *(float *)&a12 - v34;
      v59 = *(float *)&a12 - v35.f32[0];
      v60 = v35.f32[1] - *(float *)&a12;
      v65 = 1.0 - a10;
      v66 = 1.0 - a11;
      v61 = 4.0;
      v62 = (uint64_t)a1;
      v63 = a2;
      v64 = *(float *)&a12;
      goto LABEL_62;
    }
    if (a3)
      goto LABEL_70;
    v56 = a11 * 0.785398163 + -0.785398163;
    goto LABEL_55;
  }
  if (a4)
    goto LABEL_70;
  *a1 = 0.0;
  switch(a3)
  {
    case 2:
      v74 = a10 * 0.785398163;
LABEL_68:
      v86 = v31;
      v75 = __sincos_stret(v74);
      v73 = v75.__cosval;
      v31 = v86;
      v72 = v75.__sinval;
LABEL_69:
      v76 = v73;
      a1[1] = v72;
      a1[2] = v76;
      break;
    case 1:
      v74 = a10 * 0.785398163 + -0.785398163;
      goto LABEL_68;
    case 0:
      v41 = (float32x2_t)0x3F80000000000000;
LABEL_64:
      *(float32x2_t *)(a1 + 1) = v41;
      break;
  }
LABEL_70:
  v77 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v91, a1[2]), v31, a1[1]), v92, *a1);
  *(_QWORD *)a1 = v77.i64[0];
  a1[2] = v77.f32[2];
}

void sub_1B18E1A64(float *a1, int a2, float a3, float a4, float a5, float a6, double a7, float a8, float a9)
{
  double v13;
  float v14;
  __float2 v15;
  float v16;
  __float2 v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float v21;
  float v22;
  double v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;

  v13 = a6;
  v14 = a6 * 1.57079633;
  v15 = __sincosf_stret(v14);
  v16 = v13 * -1.57079633;
  v17 = __sincosf_stret(v16);
  v18.i32[3] = 0;
  v18.i64[0] = LODWORD(v17.__cosval);
  v18.f32[2] = -v17.__sinval;
  v19.i64[0] = LODWORD(v17.__sinval);
  v19.i64[1] = LODWORD(v17.__cosval);
  v20 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v19, a5), (float32x4_t)xmmword_1B2244DD0, a4), v18, a3);
  v21 = fabsf(v20.f32[1]);
  v22 = fabsf(v20.f32[2]);
  if (a2)
  {
    if (a2 == 1)
    {
      v20.f32[0] = v22 * 0.5;
      v27 = sqrtf((float)(v20.f32[1] * v20.f32[1]) + (float)(v20.f32[0] * v20.f32[0]));
      v25 = v20.f32[0] / v27;
      v26 = v21 / v27;
      v24 = 0.0;
    }
    else
    {
      if (a2 == 3)
      {
        *a1 = a9;
        a1[1] = 1.0 - a8;
        return;
      }
      v24 = *a1;
      v25 = a1[1];
      v26 = a1[2];
    }
  }
  else
  {
    v23 = 1.0 - a8;
    v24 = (a9 + -0.5) * (v23 * fabsf(v20.f32[0]));
    v25 = v21 * a8;
    v26 = v23 * (v22 * 0.5);
  }
  v28.i32[3] = 0;
  v28.i64[0] = LODWORD(v15.__cosval);
  v28.f32[2] = -v15.__sinval;
  v29.i64[0] = LODWORD(v15.__sinval);
  v29.i64[1] = LODWORD(v15.__cosval);
  v30 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v29, v26), (float32x4_t)xmmword_1B2244DD0, v25), v28, v24);
  *(_QWORD *)a1 = v30.i64[0];
  a1[2] = v30.f32[2];
}

uint64_t sub_1B18E1C00(void (*a1)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float), unsigned int a2, int *a3, int a4, int a5, int a6, int *a7, int a8, float a9, float a10, float a11, float a12, float a13, float a14)
{
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __CFData *Mutable;
  uint64_t v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  const __CFData *v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  int v53;
  _BOOL4 v54;
  int v55;
  int v56;
  int v57;
  __int16 v58;
  __int16 v59;
  int v60;
  int v61;
  UInt8 *v62;
  __CFData *v63;
  CFIndex v64;
  UInt8 *v65;
  __CFData *v66;
  CFIndex v67;
  __CFData *v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  int v74;
  int v75;
  BOOL v76;
  int v77;
  int v78;
  int v79;
  int v80;
  UInt8 *v81;
  __CFData *v82;
  int v83;
  CFIndex v84;
  UInt8 *v85;
  __CFData *v86;
  CFIndex v87;
  __CFData *v88;
  const void *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  CFDataRef Copy;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  const CFArrayCallBacks *v100;
  const __CFArray *v101;
  const __CFArray *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t i;
  const void *v110;
  const __CFAllocator *allocator;
  uint64_t v113;
  uint64_t v114;
  int v115;
  __int16 v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  int v120;
  __int16 v123;
  int v124;
  __int16 v125;
  int v126;
  _BOOL4 v127;
  uint64_t v128;
  int v129;
  int v130;
  int v131;
  uint64_t v133;
  CFTypeRef cf;
  void *values[3];
  UInt8 v137[8];
  int v138;
  int v139;
  _BYTE v140[12];
  _DWORD v141[3];
  uint64_t v142;

  v142 = *MEMORY[0x1E0C80C00];
  if (!sub_1B17A4260(a2))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v24, v25, v26, v27, v28, v29, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  values[0] = (void *)sub_1B18E24E0(a1, 0, a3, a4, a7, a8, a9, a10, a11, a12, a13, a14);
  values[1] = (void *)sub_1B18E24E0(a1, 1, a3, a4, a7, a8, a9, a10, a11, a12, a13, a14);
  values[2] = (void *)sub_1B18E24E0(a1, 3, a3, a4, a7, a8, a9, a10, a11, a12, a13, a14);
  cf = 0;
  if (!sub_1B17A4260(a2))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v30, v31, v32, v33, v34, v35, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v133 = (a4 - 1);
  v37 = 0;
  if (a4 >= 1)
  {
    v38 = a3;
    v39 = a4;
    do
    {
      v40 = *v38++;
      v37 += v40 + 1;
      --v39;
    }
    while (v39);
  }
  v41 = Mutable;
  if (a8 < 1)
  {
    v47 = 0;
    v48 = 2;
    goto LABEL_116;
  }
  v42 = 0;
  v43 = a8;
  v44 = a7;
  v113 = a8;
  do
  {
    v45 = *v44++;
    v42 += v45 + 1;
    --v43;
  }
  while (v43);
  v131 = a5;
  v120 = v37;
  if (v42 * v37 >= 0x10000)
  {
    v69 = 0;
    v47 = 0;
    v115 = 0;
    v48 = 4;
    while (1)
    {
      v70 = a7[v69];
      if (v70 < 1)
        goto LABEL_115;
      v71 = 0;
      v124 = v37 * v115;
      v126 = v37 + v37 * v115;
      v117 = v69;
      do
      {
        if (a4 < 1)
          goto LABEL_114;
        v72 = 0;
        v73 = 0;
        v119 = v71;
        v128 = v71 | v69;
        do
        {
          v74 = a3[v72];
          v130 = v73;
          if (v74 >= 1)
          {
            v75 = 0;
            if (a6)
              v76 = v72 == v133;
            else
              v76 = 0;
            v77 = v76;
            v78 = v126 + v73;
            v79 = v124 + v73;
            do
            {
              *(_DWORD *)v140 = v79 + v75;
              *(_DWORD *)&v140[4] = v78 + v75 + 1;
              v80 = v75 + 1;
              *(_DWORD *)&v140[8] = v79 + v75 + 1;
              v141[0] = v79 + v75;
              v141[1] = v78 + v75;
              v141[2] = *(_DWORD *)&v140[4];
              if (!a5 || v75 | v72)
              {
                if (v80 == v74)
                  v83 = v77;
                else
                  v83 = 0;
                if (v83 == 1)
                {
                  switch(a2)
                  {
                    case 3u:
                      *(_DWORD *)v137 = v79 + v75;
                      *(_DWORD *)&v137[4] = v78 + v75 + 1;
                      goto LABEL_103;
                    case 2u:
                      *(_DWORD *)v137 = v79 + v75;
                      *(_DWORD *)&v137[4] = v78 + v75;
                      v138 = v78 + v75;
                      v139 = v78 + v75 + 1;
LABEL_99:
                      v85 = v137;
                      v86 = v41;
                      v87 = 16;
LABEL_104:
                      CFDataAppendBytes(v86, v85, v87);
                      Mutable = v41;
                      v47 += 2;
                      break;
                    case 0u:
                      v82 = v41;
                      v81 = (UInt8 *)v141;
                      goto LABEL_90;
                  }
                }
                else
                {
                  switch(a2)
                  {
                    case 3u:
LABEL_96:
                      *(_DWORD *)v137 = v79 + v75;
                      *(_DWORD *)&v137[4] = v79 + v75 + 1;
LABEL_103:
                      v85 = v137;
                      v86 = v41;
                      v87 = 8;
                      goto LABEL_104;
                    case 2u:
                      *(_DWORD *)v137 = v79 + v75;
                      *(_DWORD *)&v137[4] = v78 + v75;
                      v138 = v78 + v75;
                      v139 = v78 + v75 + 1;
                      v88 = Mutable;
                      CFDataAppendBytes(Mutable, v137, 16);
                      if (v128)
                      {
                        v47 += 2;
                      }
                      else
                      {
                        *(_DWORD *)v137 = *(_DWORD *)v140;
                        *(_DWORD *)&v137[4] = *(_DWORD *)&v140[8];
                        CFDataAppendBytes(v88, v137, 8);
                        v47 += 3;
                      }
                      a5 = v131;
                      if (v72 != v133 || v75 != a3[v72] - 1)
                      {
                        Mutable = v41;
                        break;
                      }
                      *(_QWORD *)v137 = *(_QWORD *)&v140[4];
                      v81 = v137;
                      v82 = v41;
                      v84 = 8;
                      goto LABEL_91;
                    case 0u:
                      v85 = v140;
                      v86 = v41;
                      v87 = 24;
                      goto LABEL_104;
                  }
                }
              }
              else
              {
                switch(a2)
                {
                  case 3u:
                    goto LABEL_96;
                  case 2u:
                    *(_DWORD *)v137 = v79 + v75;
                    *(_DWORD *)&v137[4] = v78 + v75 + 1;
                    v138 = v79 + v75;
                    v139 = v79 + v75 + 1;
                    goto LABEL_99;
                  case 0u:
                    v81 = v140;
                    v82 = v41;
LABEL_90:
                    v84 = 12;
LABEL_91:
                    CFDataAppendBytes(v82, v81, v84);
                    Mutable = v41;
                    ++v47;
                    break;
                }
              }
              v74 = a3[v72];
              ++v75;
            }
            while (v80 < v74);
          }
          v73 = v130 + v74 + 1;
          ++v72;
        }
        while (v72 != a4);
        LODWORD(v37) = v120;
        v69 = v117;
        v71 = v119;
        v70 = a7[v117];
        v48 = 4;
LABEL_114:
        ++v71;
        v126 += v37;
        v124 += v37;
      }
      while (v71 < v70);
LABEL_115:
      v115 += v70 + 1;
      if (++v69 == v113)
        goto LABEL_116;
    }
  }
  v46 = 0;
  v47 = 0;
  v116 = 0;
  v48 = 2;
  do
  {
    v49 = a7[v46];
    if (v49 < 1)
      goto LABEL_60;
    v50 = 0;
    v114 = v46;
    do
    {
      v51 = v50 + 1;
      if (a4 < 1)
        goto LABEL_59;
      v52 = 0;
      v53 = 0;
      v54 = v46 == 0;
      v118 = v50 + 1;
      v123 = (v116 + v51) * v37;
      v125 = (v116 + v50) * v37;
      if ((_WORD)v50)
        v54 = 0;
      v127 = v54;
      do
      {
        v55 = a3[v52];
        v129 = v53;
        if (v55 >= 1)
        {
          v56 = 0;
          v57 = 0;
          v58 = v53 + v125;
          v59 = v53 + v123;
          do
          {
            *(_WORD *)v140 = v57 + v58;
            v60 = v57 + 1;
            *(_WORD *)&v140[2] = v57 + 1 + v59;
            *(_WORD *)&v140[4] = v57 + 1 + v58;
            *(_WORD *)&v140[6] = v57 + v58;
            *(_WORD *)&v140[8] = v57 + v59;
            *(_WORD *)&v140[10] = *(_WORD *)&v140[2];
            v61 = (__int16)(v57 + 1);
            if (v52 || (_WORD)v57 || !a5)
            {
              if (v52 == v133 && a6 && v55 == v61)
              {
                switch(a2)
                {
                  case 3u:
                    *(_WORD *)v137 = v57 + v58;
                    *(_WORD *)&v137[2] = v57 + 1 + v59;
                    goto LABEL_46;
                  case 2u:
                    *(_WORD *)v137 = v57 + v58;
                    *(_WORD *)&v137[2] = v57 + v59;
                    *(_WORD *)&v137[4] = v57 + v59;
                    *(_WORD *)&v137[6] = v57 + 1 + v59;
LABEL_44:
                    v65 = v137;
                    v66 = v41;
                    v67 = 8;
LABEL_47:
                    CFDataAppendBytes(v66, v65, v67);
                    Mutable = v41;
                    v47 += 2;
                    break;
                  case 0u:
                    v63 = v41;
                    v62 = &v140[6];
                    goto LABEL_35;
                }
              }
              else
              {
                switch(a2)
                {
                  case 3u:
LABEL_41:
                    *(_WORD *)v137 = v57 + v58;
                    *(_WORD *)&v137[2] = v57 + 1 + v58;
LABEL_46:
                    v65 = v137;
                    v66 = v41;
                    v67 = 4;
                    goto LABEL_47;
                  case 2u:
                    *(_WORD *)v137 = v57 + v58;
                    *(_WORD *)&v137[2] = v57 + v59;
                    *(_WORD *)&v137[4] = v57 + v59;
                    *(_WORD *)&v137[6] = v57 + 1 + v59;
                    v68 = Mutable;
                    CFDataAppendBytes(Mutable, v137, 8);
                    if (v127)
                    {
                      *(_WORD *)v137 = *(_WORD *)v140;
                      *(_WORD *)&v137[2] = *(_WORD *)&v140[4];
                      CFDataAppendBytes(v68, v137, 4);
                      v47 += 3;
                    }
                    else
                    {
                      v47 += 2;
                    }
                    a5 = v131;
                    if (v52 != v133 || a3[v52] - 1 != v56)
                    {
                      Mutable = v41;
                      break;
                    }
                    *(_DWORD *)v137 = *(_DWORD *)&v140[2];
                    v62 = v137;
                    v63 = v41;
                    v64 = 4;
                    goto LABEL_36;
                  case 0u:
                    v65 = v140;
                    v66 = v41;
                    v67 = 12;
                    goto LABEL_47;
                }
              }
            }
            else
            {
              switch(a2)
              {
                case 3u:
                  goto LABEL_41;
                case 2u:
                  *(_WORD *)v137 = v57 + v58;
                  *(_WORD *)&v137[2] = v57 + 1 + v59;
                  *(_WORD *)&v137[4] = v57 + v58;
                  *(_WORD *)&v137[6] = v57 + 1 + v58;
                  goto LABEL_44;
                case 0u:
                  v62 = v140;
                  v63 = v41;
LABEL_35:
                  v64 = 6;
LABEL_36:
                  CFDataAppendBytes(v63, v62, v64);
                  Mutable = v41;
                  ++v47;
                  break;
              }
            }
            v55 = a3[v52];
            v56 = v61;
            v57 = v60;
          }
          while (v55 > (__int16)v60);
        }
        v53 = v129 + v55 + 1;
        ++v52;
      }
      while (v52 != a4);
      LOWORD(v37) = v120;
      v46 = v114;
      v49 = a7[v114];
      v48 = 2;
      v51 = v118;
LABEL_59:
      v50 = v51;
    }
    while (v49 > (__int16)v51);
LABEL_60:
    v116 += v49 + 1;
    ++v46;
  }
  while (v46 != v113);
LABEL_116:
  v89 = (const void *)sub_1B17A39B4();
  sub_1B17A43C4((uint64_t)v89, 0, v90, v91, v92, v93, v94, v95);
  Copy = CFDataCreateCopy(allocator, v41);
  sub_1B17A3C5C((uint64_t)v89, a2, v47, Copy, v48, v97, v98, v99);
  CFRelease(Copy);
  CFRelease(v41);
  cf = v89;
  v140[2] = 0;
  *(_WORD *)v140 = 0;
  v100 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  v101 = CFArrayCreate(allocator, (const void **)values, 3, MEMORY[0x1E0C9B378]);
  v102 = CFArrayCreate(allocator, &cf, 1, v100);
  v108 = sub_1B17AF674(v101, v102, (uint64_t)v140, v103, v104, v105, v106, v107);
  CFRelease(v101);
  CFRelease(v102);
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  for (i = 0; i != 3; ++i)
  {
    v110 = values[i];
    if (v110)
    {
      CFRelease(v110);
      values[i] = 0;
    }
  }
  return v108;
}

uint64_t sub_1B18E24E0(void (*a1)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float), uint64_t a2, int *a3, int a4, int *a5, int a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  uint64_t v23;
  int v24;
  uint64_t v25;
  int *v26;
  int v27;
  int v28;
  uint64_t v29;
  int *v30;
  int v31;
  uint64_t v32;
  __CFData *Mutable;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  float v38;
  int v39;
  int v40;
  CFDataRef Copy;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const __CFAllocator *allocator;
  int v49;
  uint64_t v50;
  uint64_t v51;
  int v53;
  UInt8 bytes[12];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v23 = a4;
  v24 = a4;
  if (a4 >= 1)
  {
    v25 = a4;
    v26 = a3;
    v24 = a4;
    do
    {
      v27 = *v26++;
      v24 += v27;
      --v25;
    }
    while (v25);
  }
  v51 = a6;
  v28 = a6;
  if (a6 >= 1)
  {
    v29 = a6;
    v30 = a5;
    v28 = a6;
    do
    {
      v31 = *v30++;
      v28 += v31;
      --v29;
    }
    while (v29);
  }
  if ((_DWORD)a2 == 3)
    v32 = 2;
  else
    v32 = 3;
  v49 = v28 * v24;
  v50 = v32;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4 * v28 * v24 * (int)v32);
  if (a6 >= 1)
  {
    v34 = 0;
    do
    {
      v35 = a5[v34];
      if ((v35 & 0x80000000) == 0)
      {
        v36 = 0;
        do
        {
          if (a4 >= 1)
          {
            v37 = 0;
            v53 = v36;
            v38 = (float)v36 * a12;
            do
            {
              v39 = a3[v37];
              if ((v39 & 0x80000000) == 0)
              {
                v40 = -1;
                do
                {
                  a1(bytes, a2, v37, v34, a7, a8, a9, a10, a11, (float)((float)++v40 / (float)v39) + 0.0, (float)(v38 / (float)a5[v34]) + 0.0);
                  CFDataAppendBytes(Mutable, bytes, (4 * v50));
                  v39 = a3[v37];
                }
                while (v40 < v39);
              }
              ++v37;
            }
            while (v37 != v23);
            v35 = a5[v34];
            v36 = v53;
          }
        }
        while (v36++ < v35);
      }
      ++v34;
    }
    while (v34 != v51);
  }
  Copy = CFDataCreateCopy(allocator, Mutable);
  v46 = sub_1B17ED204(Copy, a2, v49, v50, 1, v43, v44, v45);
  CFRelease(Mutable);
  CFRelease(Copy);
  return v46;
}

uint64_t sub_1B18E2750(unsigned int a1, int a2, float a3, float a4, float a5, float a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v19;
  int v20;

  if (!sub_1B17A4260(a1))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v12, v13, v14, v15, v16, v17, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  v19 = a2;
  v20 = 1;
  return sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E09B0, a1, &v20, 1, 0, a4 == 0.0, &v19, 1, a3, a4, a5, 0.0, 0.0, a6);
}

uint64_t sub_1B18E2808(unsigned int a1, uint64_t a2, int a3, float a4, float a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  float v18;
  float v19;
  float v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const void *v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  float v35;
  __float2 v36;
  __float2 v37;
  __float2 v38;
  __float2 v39;
  __float2 v40;
  __float2 v41;
  __float2 v42;
  uint64_t v43;
  float32x4_t v44;
  float32x4_t v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  const __CFArray *v50;
  uint64_t i;
  const void *v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  int v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  void *values;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  if (!sub_1B17A4260(a1))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v10, v11, v12, v13, v14, v15, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  if (a4 <= 0.0)
    return 0;
  if (a3 == 1)
    return sub_1B17C55C8(a1, a2, a4);
  v57 = a2;
  if (a5 == 1.0)
  {
    v18 = 0.0;
    if (a3 == 2)
      v18 = 0.5;
    return sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E0AD4, a1, &v57, 1, a3 != 2, 1, &v57, 1, a4, v18, 1.0, 0.0, 0.0, 1.0);
  }
  else
  {
    v65 = 0;
    v66 = 0;
    v19 = 0.0;
    if (a3 == 2)
    {
      v19 = 0.5;
      v20 = 0.25;
    }
    else
    {
      v20 = 0.5;
    }
    values = (void *)sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E0AD4, a1, &v57, 1, a3 != 2, 1, &v57, 1, a4, v19, 1.0, 0.0, 0.0, a5);
    v21 = sub_1B18E2750(a1, a2, a4, 0.0, 0.0, v20);
    v28 = (const void *)v21;
    v29 = 0;
    v55 = 0u;
    v56 = 0u;
    v53 = 0u;
    v54 = 0u;
    v58 = xmmword_1B2244DB0;
    v59 = xmmword_1B2246F30;
    v60 = xmmword_1B2246F40;
    v61 = 0u;
    v62 = 0u;
    v63 = 0u;
    do
    {
      *(__int128 *)((char *)&v61 + v29) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2247E20, COERCE_FLOAT(*(__int128 *)((char *)&v58 + v29))), (float32x4_t)xmmword_1B2244DD0, *(float32x2_t *)((char *)&v58 + v29), 1), (float32x4_t)xmmword_1B2247E30, *(float32x4_t *)((char *)&v58 + v29), 2);
      v29 += 16;
    }
    while (v29 != 48);
    v30 = 0;
    v58 = v61;
    v59 = v62;
    v60 = v63;
    v61 = 0u;
    v62 = 0u;
    v63 = 0u;
    do
    {
      *(__int128 *)((char *)&v61 + v30) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2244DB0, COERCE_FLOAT(*(__int128 *)((char *)&v58 + v30))), (float32x4_t)xmmword_1B22465B0, *(float32x2_t *)((char *)&v58 + v30), 1), (float32x4_t)xmmword_1B2244D90, *(float32x4_t *)((char *)&v58 + v30), 2);
      v30 += 16;
    }
    while (v30 != 48);
    v31 = v61;
    v32 = v62;
    v33 = v63;
    HIDWORD(v31) = 0;
    HIDWORD(v32) = 0;
    HIDWORD(v33) = 0;
    v53 = v31;
    v54 = v32;
    v55 = v33;
    v56 = xmmword_1B2244E20;
    v34 = sub_1B17B04C0(v21, (float *)&v53, v22, v23, v24, v25, v26, v27);
    v65 = v34;
    if (v28)
      CFRelease(v28);
    v35 = (1.0 - a5) * 6.28318531;
    v42 = __sincosf_stret(v35);
    v43 = 0;
    v44.i32[3] = 0;
    v44.i64[0] = LODWORD(v42.__cosval);
    v45.i64[0] = LODWORD(v42.__sinval);
    v45.i64[1] = LODWORD(v42.__cosval);
    v58 = xmmword_1B2244DB0;
    v59 = xmmword_1B2244DD0;
    v60 = xmmword_1B2246580;
    v61 = 0u;
    v62 = 0u;
    v63 = 0u;
    do
    {
      v44.f32[2] = -v42.__sinval;
      *(__int128 *)((char *)&v61 + v43) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v44, COERCE_FLOAT(*(__int128 *)((char *)&v58 + v43))), (float32x4_t)xmmword_1B2244DD0, *(float32x2_t *)((char *)&v58 + v43), 1), v45, *(float32x4_t *)((char *)&v58 + v43), 2);
      v43 += 16;
    }
    while (v43 != 48);
    v46 = 0;
    v58 = v61;
    v59 = v62;
    v60 = v63;
    v61 = 0u;
    v62 = 0u;
    v63 = 0u;
    do
    {
      *(__int128 *)((char *)&v61 + v46) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2247E00, COERCE_FLOAT(*(__int128 *)((char *)&v58 + v46))), (float32x4_t)xmmword_1B2247E10, *(float32x2_t *)((char *)&v58 + v46), 1), (float32x4_t)xmmword_1B2244D90, *(float32x4_t *)((char *)&v58 + v46), 2);
      v46 += 16;
    }
    while (v46 != 48);
    v47 = v61;
    v48 = v62;
    v49 = v63;
    HIDWORD(v47) = 0;
    HIDWORD(v48) = 0;
    HIDWORD(v49) = 0;
    v53 = v47;
    v54 = v48;
    v55 = v49;
    v56 = xmmword_1B2244E20;
    v66 = sub_1B17B04C0(v34, (float *)&v53, *(_QWORD *)&v36, *(_QWORD *)&v37, *(_QWORD *)&v38, *(_QWORD *)&v39, *(_QWORD *)&v40, *(_QWORD *)&v41);
    v50 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 3, MEMORY[0x1E0C9B378]);
    v17 = sub_1B17AF75C(v50);
    CFRelease(v50);
    for (i = 0; i != 24; i += 8)
    {
      v52 = *(void **)((char *)&values + i);
      if (v52)
      {
        CFRelease(v52);
        *(void **)((char *)&values + i) = 0;
      }
    }
  }
  return v17;
}

uint64_t sub_1B18E2C84(unsigned int a1, int a2, uint64_t a3, float a4, float a5, float a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void **v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  const void *v22;
  float v23;
  __float2 v24;
  __float2 v25;
  __float2 v26;
  __float2 v27;
  __float2 v28;
  __float2 v29;
  __float2 v30;
  uint64_t v31;
  float32x4_t v32;
  float32x4_t v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const void *v46;
  uint64_t v47;
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  const __CFArray *v54;
  uint64_t v55;
  const void *v56;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  int v62;
  int v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;

  if (!sub_1B17A4260(a1))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v12, v13, v14, v15, v16, v17, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  if (a4 <= 0.0)
    return 0;
  v63 = a3;
  v62 = a2;
  v18 = (const void **)malloc_type_calloc(5uLL, 8uLL, 0x2004093837F09uLL);
  if (a5 <= 0.0)
  {
    v19 = 0;
  }
  else
  {
    v19 = 1;
    *v18 = (const void *)sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E0BF8, a1, &v63, 1, 0, 0, &v62, 1, a4, a5, 0.0, 0.0, 0.0, a6);
  }
  v21 = v19 + 1;
  v18[v19] = (const void *)sub_1B18E2750(a1, a2, a4, 0.0, a5 * 0.5, a6);
  if (a5 > 0.0)
  {
    v22 = (const void *)sub_1B18E2750(a1, a2, a4, 0.0, a5 * -0.5, a6);
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v23 = a6 * 6.28318531;
    v30 = __sincosf_stret(v23);
    v31 = 0;
    v32.i32[3] = 0;
    v32.i64[0] = LODWORD(v30.__cosval);
    v33.i64[0] = LODWORD(v30.__sinval);
    v33.i64[1] = LODWORD(v30.__cosval);
    v64 = xmmword_1B2244DB0;
    v65 = xmmword_1B2244DD0;
    v66 = xmmword_1B2246580;
    v67 = 0u;
    v68 = 0u;
    v69 = 0u;
    do
    {
      v32.f32[2] = -v30.__sinval;
      *(__int128 *)((char *)&v67 + v31) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v32, COERCE_FLOAT(*(__int128 *)((char *)&v64 + v31))), (float32x4_t)xmmword_1B2244DD0, *(float32x2_t *)((char *)&v64 + v31), 1), v33, *(float32x4_t *)((char *)&v64 + v31), 2);
      v31 += 16;
    }
    while (v31 != 48);
    v34 = 0;
    v64 = v67;
    v65 = v68;
    v66 = v69;
    v67 = 0u;
    v68 = 0u;
    v69 = 0u;
    do
    {
      *(__int128 *)((char *)&v67 + v34) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2244DB0, COERCE_FLOAT(*(__int128 *)((char *)&v64 + v34))), (float32x4_t)xmmword_1B22465B0, *(float32x2_t *)((char *)&v64 + v34), 1), (float32x4_t)xmmword_1B2244D90, *(float32x4_t *)((char *)&v64 + v34), 2);
      v34 += 16;
    }
    while (v34 != 48);
    v35 = v67;
    v36 = v68;
    v37 = v69;
    HIDWORD(v35) = 0;
    HIDWORD(v36) = 0;
    HIDWORD(v37) = 0;
    v58 = v35;
    v59 = v36;
    v60 = v37;
    v61 = xmmword_1B2244E20;
    v38 = v19 | 2;
    v18[v21] = (const void *)sub_1B17B04C0((uint64_t)v22, (float *)&v58, *(_QWORD *)&v24, *(_QWORD *)&v25, *(_QWORD *)&v26, *(_QWORD *)&v27, *(_QWORD *)&v28, *(_QWORD *)&v29);
    if (v22)
      CFRelease(v22);
    if (a6 >= 1.0)
    {
      v21 = v19 | 2;
    }
    else
    {
      v39 = sub_1B19077CC(a1, 1, a3, 0, a4, a5, 0.0);
      v46 = (const void *)v39;
      v47 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v64 = xmmword_1B2244DB0;
      v65 = xmmword_1B2244DD0;
      v66 = xmmword_1B2246580;
      v67 = 0u;
      v68 = 0u;
      v69 = 0u;
      do
      {
        *(__int128 *)((char *)&v67 + v47) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2245D50, COERCE_FLOAT(*(__int128 *)((char *)&v64 + v47))), (float32x4_t)xmmword_1B2244DD0, *(float32x2_t *)((char *)&v64 + v47), 1), (float32x4_t)xmmword_1B2245D60, *(float32x4_t *)((char *)&v64 + v47), 2);
        v47 += 16;
      }
      while (v47 != 48);
      v48 = 0;
      v64 = v67;
      v65 = v68;
      v66 = v69;
      v67 = 0u;
      v68 = 0u;
      v69 = 0u;
      do
      {
        *(__int128 *)((char *)&v67 + v48) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2244DB0, COERCE_FLOAT(*(__int128 *)((char *)&v64 + v48))), (float32x4_t)xmmword_1B22465B0, *(float32x2_t *)((char *)&v64 + v48), 1), (float32x4_t)xmmword_1B2244D90, *(float32x4_t *)((char *)&v64 + v48), 2);
        v48 += 16;
      }
      while (v48 != 48);
      v49 = v67;
      v50 = v68;
      v51 = v69;
      HIDWORD(v49) = 0;
      HIDWORD(v50) = 0;
      HIDWORD(v51) = 0;
      *(_QWORD *)&v52 = 0;
      *((float *)&v52 + 2) = a4 * -0.5;
      HIDWORD(v52) = 1.0;
      v58 = v49;
      v59 = v50;
      v60 = v51;
      v61 = v52;
      v53 = sub_1B17B04C0(v39, (float *)&v58, v40, v41, v42, v43, v44, v45);
      v18[v38] = (const void *)v53;
      if (v46)
      {
        CFRelease(v46);
        v53 = (uint64_t)v18[v38];
      }
      v21 = v19 | 4;
      v18[v19 + 3] = (const void *)sub_1B18E0854(v53, a6);
    }
  }
  v54 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v18, v21, MEMORY[0x1E0C9B378]);
  v20 = sub_1B17AF75C(v54);
  CFRelease(v54);
  v55 = 0;
  do
  {
    v56 = v18[v55];
    if (v56)
    {
      CFRelease(v56);
      v18[v55] = 0;
    }
    ++v55;
  }
  while (v21 != v55);
  free(v18);
  return v20;
}

uint64_t sub_1B18E30F4(unsigned int a1, int a2, int a3, float a4, float a5, float a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFIndex v23;
  uint64_t v24;
  const __CFArray *v25;
  uint64_t v26;
  uint64_t v27;
  const void *v28;
  int v30;
  int v31;
  void *values;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!sub_1B17A4260(a1))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v12, v13, v14, v15, v16, v17, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  v18 = 0;
  if (a4 >= 0.0 && a5 >= 0.0)
  {
    v18 = 0;
    v19 = a5 == 0.0 && a4 == 0.0;
    if (!v19 && a6 > 0.0)
    {
      v30 = a2;
      v31 = a3;
      if (a4 <= 0.0)
        v20 = 0;
      else
        v20 = sub_1B18E2750(a1, a2, a4, 0.0, a6 * 0.5, 1.0);
      if (a5 <= 0.0)
        v21 = 0;
      else
        v21 = sub_1B18E2750(a1, a2, a5, 0.0, a6 * -0.5, 1.0);
      v33 = 0;
      v34 = 0;
      values = (void *)sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E0CF0, a1, &v31, 1, v21 == 0, v20 == 0, &v30, 1, a4, a5, a6, 0.0, 0.0, 1.0);
      if (v20 && v21)
      {
        v33 = v20;
        v22 = 3;
        v23 = 2;
      }
      else
      {
        v23 = 1;
        v24 = v20 | v21;
        if (v20)
          v21 = v20;
        if (!v24)
          goto LABEL_24;
        v22 = 2;
      }
      *(&values + v23) = (void *)v21;
      v23 = v22;
LABEL_24:
      v25 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, v23, MEMORY[0x1E0C9B378]);
      v18 = sub_1B17AF75C(v25);
      CFRelease(v25);
      v26 = 0;
      v27 = 8 * v23;
      do
      {
        v28 = *(void **)((char *)&values + v26);
        if (v28)
        {
          CFRelease(v28);
          *(void **)((char *)&values + v26) = 0;
        }
        v26 += 8;
      }
      while (v27 != v26);
    }
  }
  return v18;
}

uint64_t sub_1B18E3318(unsigned int a1, int a2, uint64_t a3, float a4, float a5, float a6, float a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void **v21;
  uint64_t v22;
  CFIndex v23;
  const void *v24;
  float v25;
  __float2 v26;
  __float2 v27;
  __float2 v28;
  __float2 v29;
  __float2 v30;
  __float2 v31;
  __float2 v32;
  uint64_t v33;
  float32x4_t v34;
  float32x4_t v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  const __CFArray *v54;
  uint64_t v55;
  const void *v56;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;

  if (!sub_1B17A4260(a1))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v14, v15, v16, v17, v18, v19, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  v20 = 0;
  if (a4 > a5)
    a4 = a5;
  if (a5 > 0.0 && a4 >= 0.0)
  {
    v21 = (const void **)malloc_type_calloc(6uLL, 8uLL, 0x2004093837F09uLL);
    if (a6 <= 0.0)
    {
      v22 = 0;
    }
    else
    {
      LODWORD(v58) = a2;
      LODWORD(v65) = a3;
      *v21 = (const void *)sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E0BF8, a1, (int *)&v65, 1, 0, 0, (int *)&v58, 1, a5, a6, 0.0, 0.0, 0.0, a7);
      v21[1] = (const void *)sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E0BF8, a1, (int *)&v65, 1, 0, 0, (int *)&v58, 1, -a4, -a6, 0.0, 0.0, 0.0, a7);
      v22 = 2;
    }
    v23 = v22 | 1;
    v21[v22] = (const void *)sub_1B18E2750(a1, a2, a5, a4, a6 * 0.5, a7);
    if (a6 > 0.0)
    {
      v24 = (const void *)sub_1B18E2750(a1, a2, a5, a4, a6 * -0.5, a7);
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v25 = a7 * 6.28318531;
      v32 = __sincosf_stret(v25);
      v33 = 0;
      v34.i32[3] = 0;
      v34.i64[0] = LODWORD(v32.__cosval);
      v35.i64[0] = LODWORD(v32.__sinval);
      v35.i64[1] = LODWORD(v32.__cosval);
      v62 = xmmword_1B2244DB0;
      v63 = xmmword_1B2244DD0;
      v64 = xmmword_1B2246580;
      v65 = 0u;
      v66 = 0u;
      v67 = 0u;
      do
      {
        v34.f32[2] = -v32.__sinval;
        *(__int128 *)((char *)&v65 + v33) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v34, COERCE_FLOAT(*(__int128 *)((char *)&v62 + v33))), (float32x4_t)xmmword_1B2244DD0, *(float32x2_t *)((char *)&v62 + v33), 1), v35, *(float32x4_t *)((char *)&v62 + v33), 2);
        v33 += 16;
      }
      while (v33 != 48);
      v36 = 0;
      v62 = v65;
      v63 = v66;
      v64 = v67;
      v65 = 0u;
      v66 = 0u;
      v67 = 0u;
      do
      {
        *(__int128 *)((char *)&v65 + v36) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2244DB0, COERCE_FLOAT(*(__int128 *)((char *)&v62 + v36))), (float32x4_t)xmmword_1B22465B0, *(float32x2_t *)((char *)&v62 + v36), 1), (float32x4_t)xmmword_1B2244D90, *(float32x4_t *)((char *)&v62 + v36), 2);
        v36 += 16;
      }
      while (v36 != 48);
      v37 = v65;
      v38 = v66;
      v39 = v67;
      HIDWORD(v37) = 0;
      HIDWORD(v38) = 0;
      HIDWORD(v39) = 0;
      v58 = v37;
      v59 = v38;
      v60 = v39;
      v61 = xmmword_1B2244E20;
      v21[v23] = (const void *)sub_1B17B04C0((uint64_t)v24, (float *)&v58, *(_QWORD *)&v26, *(_QWORD *)&v27, *(_QWORD *)&v28, *(_QWORD *)&v29, *(_QWORD *)&v30, *(_QWORD *)&v31);
      if (v24)
        CFRelease(v24);
      if (a7 >= 1.0)
      {
        v23 = v22 + 2;
      }
      else
      {
        v40 = sub_1B19077CC(a1, 1, a3, 0, a5 - a4, a6, 0.0);
        v47 = 0;
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v62 = xmmword_1B2244DB0;
        v63 = xmmword_1B2244DD0;
        v64 = xmmword_1B2246580;
        v65 = 0u;
        v66 = 0u;
        v67 = 0u;
        do
        {
          *(__int128 *)((char *)&v65 + v47) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2245D50, COERCE_FLOAT(*(__int128 *)((char *)&v62 + v47))), (float32x4_t)xmmword_1B2244DD0, *(float32x2_t *)((char *)&v62 + v47), 1), (float32x4_t)xmmword_1B2245D60, *(float32x4_t *)((char *)&v62 + v47), 2);
          v47 += 16;
        }
        while (v47 != 48);
        v48 = 0;
        v62 = v65;
        v63 = v66;
        v64 = v67;
        v65 = 0u;
        v66 = 0u;
        v67 = 0u;
        do
        {
          *(__int128 *)((char *)&v65 + v48) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2244DB0, COERCE_FLOAT(*(__int128 *)((char *)&v62 + v48))), (float32x4_t)xmmword_1B22465B0, *(float32x2_t *)((char *)&v62 + v48), 1), (float32x4_t)xmmword_1B2244D90, *(float32x4_t *)((char *)&v62 + v48), 2);
          v48 += 16;
        }
        while (v48 != 48);
        v49 = v65;
        v50 = v66;
        HIDWORD(v49) = 0;
        HIDWORD(v50) = 0;
        v51 = v67;
        HIDWORD(v51) = 0;
        *(_QWORD *)&v52 = 0;
        *((float *)&v52 + 2) = (float)(a4 + a5) * -0.5;
        HIDWORD(v52) = 1.0;
        v58 = v49;
        v59 = v50;
        v60 = v51;
        v61 = v52;
        v53 = sub_1B17B04C0(v40, (float *)&v58, v41, v42, v43, v44, v45, v46);
        v21[v22 + 2] = (const void *)v53;
        v23 = v22 | 4;
        v21[v22 + 3] = (const void *)sub_1B18E0854(v53, a7);
      }
    }
    v54 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v21, v23, MEMORY[0x1E0C9B378]);
    v20 = sub_1B17AF75C(v54);
    CFRelease(v54);
    v55 = 0;
    do
    {
      v56 = v21[v55];
      if (v56)
      {
        CFRelease(v56);
        v21[v55] = 0;
      }
      ++v55;
    }
    while (v23 != v55);
    free(v21);
  }
  return v20;
}

uint64_t sub_1B18E37D8(unsigned int a1, int a2, int a3, int a4, float a5, float a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  float v19;
  int v20;
  int v21[3];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!sub_1B17A4260(a1))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v12, v13, v14, v15, v16, v17, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  result = 0;
  if (a5 > 0.0 && a6 > 0.0)
  {
    v19 = a6 * 0.5;
    v21[0] = a4;
    v21[1] = a3;
    if ((float)(a6 * 0.5) > a5)
      v19 = a5;
    v21[2] = a4;
    v20 = a2;
    return sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E0F14, a1, v21, 3, 1, 1, &v20, 1, v19, a6, 0.0, 0.0, 0.0, 1.0);
  }
  return result;
}

uint64_t sub_1B18E38DC(unsigned int a1, int a2, int a3, float a4, float a5, float a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  const __CFArray *v32;
  uint64_t i;
  const void *v34;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  int v40;
  int v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  void *values;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (!sub_1B17A4260(a1))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v12, v13, v14, v15, v16, v17, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  v18 = 0;
  if (a4 > 0.0 && a5 > 0.0)
  {
    v40 = a2;
    v41 = a3;
    if (a6 == 1.0)
    {
      return sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E0E00, a1, &v41, 1, 0, 0, &v40, 1, a4, a5, 0.0, 0.0, 0.0, 1.0);
    }
    else
    {
      v49 = 0;
      v50 = 0;
      values = (void *)sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E0E00, a1, &v41, 1, 0, 0, &v40, 1, a4, a5, 0.0, 0.0, 0.0, a6);
      v19 = sub_1B18E2750(a1, a3, a5, 0.0, 0.0, 1.0);
      v26 = 0;
      v38 = 0u;
      v39 = 0u;
      v36 = 0u;
      v37 = 0u;
      v42 = xmmword_1B2244DB0;
      v43 = xmmword_1B2244DD0;
      v44 = xmmword_1B2246580;
      v45 = 0u;
      v46 = 0u;
      v47 = 0u;
      do
      {
        *(__int128 *)((char *)&v45 + v26) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2247E40, COERCE_FLOAT(*(__int128 *)((char *)&v42 + v26))), (float32x4_t)xmmword_1B2244DD0, *(float32x2_t *)((char *)&v42 + v26), 1), (float32x4_t)xmmword_1B2247E50, *(float32x4_t *)((char *)&v42 + v26), 2);
        v26 += 16;
      }
      while (v26 != 48);
      v27 = 0;
      v42 = v45;
      v43 = v46;
      v44 = v47;
      v45 = 0u;
      v46 = 0u;
      v47 = 0u;
      do
      {
        *(__int128 *)((char *)&v45 + v27) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B2247E60, COERCE_FLOAT(*(__int128 *)((char *)&v42 + v27))), (float32x4_t)xmmword_1B2247E70, *(float32x2_t *)((char *)&v42 + v27), 1), (float32x4_t)xmmword_1B2244D90, *(float32x4_t *)((char *)&v42 + v27), 2);
        v27 += 16;
      }
      while (v27 != 48);
      v28 = v45;
      v29 = v46;
      HIDWORD(v28) = 0;
      v30 = v47;
      HIDWORD(v29) = 0;
      HIDWORD(v30) = 0;
      *(_QWORD *)&v31 = 0;
      *((float *)&v31 + 2) = -a4;
      HIDWORD(v31) = 1.0;
      v36 = v28;
      v37 = v29;
      v38 = v30;
      v39 = v31;
      v49 = sub_1B17B04C0(v19, (float *)&v36, v20, v21, v22, v23, v24, v25);
      v50 = sub_1B18E0854(v49, a6);
      v32 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 3, MEMORY[0x1E0C9B378]);
      v18 = sub_1B17AF75C(v32);
      CFRelease(v32);
      for (i = 0; i != 24; i += 8)
      {
        v34 = *(void **)((char *)&values + i);
        if (v34)
        {
          CFRelease(v34);
          *(void **)((char *)&values + i) = 0;
        }
      }
    }
  }
  return v18;
}

uint64_t sub_1B18E3BCC(unsigned int a1, int a2, int a3, int a4, uint64_t a5, unsigned int a6, float a7, float a8, float a9, float a10)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  double v29;
  double v30;
  float v31;
  unint64_t v32;
  unint64_t v33;
  int v34;
  int v35;
  const __CFArray *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const CFArrayCallBacks *v43;
  __CFArray *Mutable;
  __CFArray *v45;
  uint64_t v46;
  unint64_t v47;
  int v48;
  char v49;
  uint64_t v50;
  const void *ValueAtIndex;
  char v52;
  CFIndex v53;
  const void *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const void *v63;
  const void *v64;
  const void *v65;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t i;
  const void *v74;
  uint64_t v75;
  int v76;
  const __CFArray *theArray;
  void *values[2];
  __int128 v79;
  uint64_t v80;
  uint64_t v81;
  int v82[3];
  int v83[3];
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  if (!sub_1B17A4260(a1))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v20, v21, v22, v23, v24, v25, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  if (a7 < 0.0 || a8 < 0.0)
    return 0;
  v26 = 0;
  if (a9 >= 0.0 && a10 >= 0.0)
  {
    v28 = 0;
    v29 = a9;
    v30 = a7 * 0.5;
    if (v30 >= a8 * 0.5)
      v30 = a8 * 0.5;
    if (v30 >= v29 * 0.5)
      v30 = v29 * 0.5;
    if (v30 <= a10)
    {
      v31 = v30;
      a10 = v31;
    }
    if (a5 >= 0)
      v32 = a5;
    else
      v32 = a5 + 1;
    v33 = v32 >> 1;
    if ((unint64_t)(a5 + 1) < 3)
      LODWORD(v33) = 1;
    v83[1] = v33;
    v83[2] = v33;
    v82[1] = v33;
    v82[2] = v33;
    if (a10 == 0.0)
      v34 = 1;
    else
      v34 = 3;
    *(_OWORD *)values = 0u;
    v79 = 0u;
    v83[0] = a3;
    do
    {
      if ((v28 & 0x7FFFFFFD) != 0)
        v35 = a4;
      else
        v35 = a2;
      v82[0] = v35;
      values[v28] = (void *)sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E1458, a1, v83, v34, 0, 0, v82, v34, a7, a8, a9, a10, (float)(int)v28, 1.0);
      ++v28;
    }
    while (v28 != 4);
    v83[0] = a4;
    v82[0] = a2;
    v80 = sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E1458, a1, v83, v34, 0, 0, v82, v34, a7, a8, a9, a10, 4.0, 1.0);
    v81 = sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E1458, a1, v83, v34, 0, 0, v82, v34, a7, a8, a9, a10, 5.0, 1.0);
    v36 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)values, 6, MEMORY[0x1E0C9B378]);
    v26 = sub_1B17AF75C(v36);
    CFRelease(v36);
    if (a6)
    {
      v75 = v26;
      theArray = (const __CFArray *)sub_1B1876264(v26, 0, v37, v38, v39, v40, v41, v42);
      v43 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      Mutable = CFArrayCreateMutable(0, 6, MEMORY[0x1E0C9B378]);
      v45 = CFArrayCreateMutable(0, 6, v43);
      v46 = 0;
      v47 = 0;
      v48 = 0;
      v49 = 4;
      v50 = 1;
      do
      {
        if (((1 << ((a6 >> (4 * v47)) & 0xF)) & v48) != 0)
        {
          ++v46;
        }
        else
        {
          v76 = v48;
          CFArrayRemoveAllValues(Mutable);
          ValueAtIndex = CFArrayGetValueAtIndex(theArray, v47);
          CFArrayAppendValue(Mutable, ValueAtIndex);
          if (v47 <= 4)
          {
            v52 = v49;
            v53 = v50;
            do
            {
              if (((a6 >> (4 * v47)) & 0xF) == ((a6 >> v52) & 0xF))
              {
                v54 = CFArrayGetValueAtIndex(theArray, v53);
                CFArrayAppendValue(Mutable, v54);
              }
              ++v53;
              v52 += 4;
            }
            while (v53 != 6);
          }
          if (CFArrayGetCount(Mutable) < 2)
          {
            v63 = CFArrayGetValueAtIndex(Mutable, 0);
            v62 = (uint64_t)CFRetain(v63);
          }
          else
          {
            v62 = sub_1B17A3F4C(Mutable, v55, v56, v57, v58, v59, v60, v61);
          }
          v64 = (const void *)v62;
          if (v46 >= 1)
          {
            do
            {
              v65 = (const void *)sub_1B17A3A60();
              CFArrayAppendValue(v45, v65);
              --v46;
            }
            while (v46);
          }
          if (!v64)
          {
            CFRelease(v45);
            CFRelease(Mutable);
            v26 = v75;
            goto LABEL_49;
          }
          v48 = v76 | (1 << ((a6 >> (4 * v47)) & 0xF));
          CFArrayAppendValue(v45, v64);
          CFRelease(v64);
          v46 = 0;
        }
        ++v50;
        v49 += 4;
      }
      while (v47++ < 5);
      CFRelease(Mutable);
      v26 = v75;
      if (v45)
      {
        sub_1B18762F4(v75, v45, v67, v68, v69, v70, v71, v72);
        CFRelease(v45);
      }
    }
LABEL_49:
    for (i = 0; i != 6; ++i)
    {
      v74 = values[i];
      if (v74)
      {
        CFRelease(v74);
        values[i] = 0;
      }
    }
  }
  return v26;
}

uint64_t sub_1B18E4054(unsigned int a1, uint64_t a2, int a3, uint64_t a4, float a5, float a6, float a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  const void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFArray *v29;
  uint64_t v30;
  uint64_t i;
  const void *v32;
  _OWORD v34[4];
  int v35;
  void *values[2];
  __int128 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (!sub_1B17A4260(a1))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Mesh type has to define a topology"), v14, v15, v16, v17, v18, v19, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  v20 = 0;
  *(_OWORD *)values = 0u;
  v37 = 0u;
  do
  {
    LODWORD(v34[0]) = a3;
    if ((v20 & 1) != 0)
      v21 = a4;
    else
      v21 = a2;
    v35 = v21;
    values[v20] = (void *)sub_1B18E1C00((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B18E1A64, a1, (int *)v34, 1, 0, 1, &v35, 1, a5, a6, a7, (float)(int)v20, 0.0, 1.0);
    ++v20;
  }
  while (v20 != 4);
  v22 = (const void *)sub_1B19077CC(a1, a2, a4, 0, a5, a7, 0.0);
  v34[0] = xmmword_1B2244DB0;
  v34[1] = xmmword_1B2246F10;
  v34[2] = xmmword_1B2246F20;
  v34[3] = xmmword_1B2244E20;
  v38 = sub_1B17B04C0((uint64_t)v22, (float *)v34, v23, v24, v25, v26, v27, v28);
  if (v22)
    CFRelease(v22);
  v29 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)values, 5, MEMORY[0x1E0C9B378]);
  v30 = sub_1B17AF75C(v29);
  CFRelease(v29);
  for (i = 0; i != 5; ++i)
  {
    v32 = values[i];
    if (v32)
    {
      CFRelease(v32);
      values[i] = 0;
    }
  }
  return v30;
}

uint64_t sub_1B18E423C(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  CFIndex v20;

  if (*(_QWORD *)(result + 104))
  {
    v1 = result;
    free(*(void **)(result + 96));
    *(_QWORD *)(v1 + 96) = malloc_type_malloc(4 * *(_QWORD *)(v1 + 104), 0x100004052888210uLL);
    result = sub_1B17C6244((_QWORD *)v1, v2, v3, v4, v5, v6, v7, v8);
    if (*(uint64_t *)(v1 + 104) >= 1)
    {
      v9 = result;
      v10 = 0;
      do
      {
        result = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 88), v10);
        if (result
          && (v18 = result, result = sub_1B17C6244((_QWORD *)result, v11, v12, v13, v14, v15, v16, v17), result == v9))
        {
          v19 = *(_DWORD *)(v18 + 88);
        }
        else
        {
          v19 = -1;
        }
        v20 = *(_QWORD *)(v1 + 104);
        *(_DWORD *)(*(_QWORD *)(v1 + 96) + 4 * v10++) = v19;
      }
      while (v10 < v20);
    }
  }
  return result;
}

uint64_t sub_1B18E42EC()
{
  if (qword_1ED4CEE70 != -1)
    dispatch_once(&qword_1ED4CEE70, &unk_1E63D1030);
  return qword_1ED4CEE78;
}

double sub_1B18E432C()
{
  double result;

  if (!qword_1ED4CEE78)
  {
    qword_1ED4CEE78 = sub_1B179CB60(&qword_1ED4CEE78);
    qword_1ED4BED18 = (uint64_t)sub_1B18E5BE4;
    *(_QWORD *)&result = 0x1B18E622CLL;
    unk_1ED4BED30 = xmmword_1E63D31B8;
    unk_1ED4BED40 = *(_OWORD *)&off_1E63D31C8;
    qword_1ED4BED50 = 0;
    unk_1ED4BED58 = sub_1B18E6274;
  }
  return result;
}

double sub_1B18E43A0()
{
  uint64_t v0;
  double result;

  if (qword_1ED4CEE70 != -1)
    dispatch_once(&qword_1ED4CEE70, &unk_1E63D1030);
  v0 = sub_1B179CB90(qword_1ED4CEE78, 0xB0uLL);
  *(_BYTE *)(v0 + 176) = 1;
  result = 0.0;
  *(_OWORD *)(v0 + 144) = xmmword_1B2244E20;
  *(_OWORD *)(v0 + 160) = xmmword_1B2246ED0;
  return result;
}

uint64_t sub_1B18E4404(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  sub_1B18E43A0();
  v3 = v2;
  sub_1B18E4434(v2, a1, v4, v5, v6, v7, v8, v9);
  return v3;
}

double sub_1B18E4434(uint64_t a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double result;

  v9 = *(void **)(a1 + 72);
  if (v9 != cf)
  {
    if (v9)
    {
      sub_1B17C5DD0(v9, *(_QWORD *)(a1 + 48), a3, a4, a5, a6, a7, a8);
      v11 = *(const void **)(a1 + 72);
      if (v11)
        CFRelease(v11);
    }
    *(_QWORD *)(a1 + 72) = cf;
    if (cf)
    {
      CFRetain(cf);
      sub_1B17C5FC0((uint64_t *)cf, *(_QWORD *)(a1 + 48), v12, v13, v14, v15, v16, v17);
    }
    *(_BYTE *)(a1 + 176) = 1;
    result = 0.0;
    *(_OWORD *)(a1 + 144) = xmmword_1B2244E20;
    *(_OWORD *)(a1 + 160) = xmmword_1B2246ED0;
  }
  return result;
}

CFTypeRef *sub_1B18E44B0(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  CFTypeRef *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFArrayRef Copy;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v2 = *(void **)(a1 + 72);
  sub_1B18E43A0();
  v4 = (CFTypeRef *)v3;
  sub_1B18E4434(v3, v2, v5, v6, v7, v8, v9, v10);
  sub_1B18E4528((uint64_t)v4, *(_QWORD **)(a1 + 80), v11, v12, v13, v14, v15, v16);
  Copy = CFArrayCreateCopy(0, *(CFArrayRef *)(a1 + 88));
  sub_1B18E45B0((uint64_t)v4, Copy);
  CFRelease(Copy);
  sub_1B193EAC4(a1, v4, v18, v19, v20, v21, v22, v23);
  return v4;
}

double sub_1B18E4528(uint64_t a1, _QWORD *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  const __CFArray *v10;
  _QWORD *v11;
  CFTypeRef v12;
  double result;

  v8 = cf;
  if (!cf)
  {
    v10 = *(const __CFArray **)(a1 + 88);
    if (v10)
      v8 = sub_1B186C8F8(v10, 0, a3, a4, a5, a6, a7, a8);
    else
      v8 = 0;
  }
  v11 = *(_QWORD **)(a1 + 80);
  if (v11 != v8)
  {
    if (v11)
    {
      CFRelease(v11);
      *(_QWORD *)(a1 + 80) = 0;
    }
    if (v8)
      v12 = CFRetain(v8);
    else
      v12 = 0;
    *(_QWORD *)(a1 + 80) = v12;
  }
  *(_BYTE *)(a1 + 176) = 1;
  result = 0.0;
  *(_OWORD *)(a1 + 144) = xmmword_1B2244E20;
  *(_OWORD *)(a1 + 160) = xmmword_1B2246ED0;
  return result;
}

void sub_1B18E45B0(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;
  CFIndex Count;
  _BOOL4 v6;
  CFIndex i;
  const void *ValueAtIndex;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  _OWORD *v16;

  v3 = *(CFTypeRef *)(a1 + 88);
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    if (cf)
    {
      *(_QWORD *)(a1 + 88) = CFRetain(cf);
      Count = CFArrayGetCount((CFArrayRef)cf);
      *(_QWORD *)(a1 + 104) = Count;
      v6 = Count > 0;
      if (Count < 1)
      {
        v6 = 0;
      }
      else
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, i);
          sub_1B186CD80((uint64_t)ValueAtIndex, 1);
        }
      }
    }
    else
    {
      v6 = 0;
      Count = 0;
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    v9 = *(void **)(a1 + 112);
    if (v9)
      free(v9);
    v10 = *(void **)(a1 + 120);
    if (v10)
      free(v10);
    v11 = *(void **)(a1 + 128);
    if (v11)
      free(v11);
    if (Count)
    {
      *(_QWORD *)(a1 + 112) = sub_1B179E238(Count << 6);
      *(_QWORD *)(a1 + 120) = sub_1B179E238(48 * Count);
      v12 = sub_1B179E238(32 * Count);
    }
    else
    {
      v12 = 0;
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 128) = v12;
    if (v6)
    {
      v13 = 0;
      v14 = 0;
      do
      {
        v15 = (_OWORD *)(*(_QWORD *)(a1 + 112) + v13);
        *v15 = xmmword_1B2244DB0;
        v15[1] = xmmword_1B2244DD0;
        v15[2] = xmmword_1B2244D90;
        v15[3] = xmmword_1B2244E20;
        v16 = (_OWORD *)(*(_QWORD *)(a1 + 128) + v14);
        *v16 = xmmword_1B2244E20;
        v16[1] = xmmword_1B2246ED0;
        v14 += 32;
        v13 += 64;
        --Count;
      }
      while (Count);
    }
    *(_BYTE *)(a1 + 176) = 1;
    *(_OWORD *)(a1 + 144) = xmmword_1B2244E20;
    *(_OWORD *)(a1 + 160) = xmmword_1B2246ED0;
    free(*(void **)(a1 + 96));
    *(_QWORD *)(a1 + 96) = 0;
  }
}

void sub_1B18E4744(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"skinner");
  *(_QWORD *)(a1 + 64) = a2;
}

uint64_t sub_1B18E4790(uint64_t a1, _QWORD *a2)
{
  CFIndex Count;
  CFMutableArrayRef MutableCopy;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  int v22;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
  MutableCopy = CFArrayCreateMutableCopy(0, Count, *(CFArrayRef *)(a1 + 88));
  v22 = 0;
  v6 = 0;
  if (sub_1B18E4854(a1, MutableCopy, *(const void **)(a1 + 80), a2, &v22))
  {
    v7 = v22;
    if (CFArrayGetCount(MutableCopy) == v7)
    {
      sub_1B18E45B0(a1, MutableCopy);
      sub_1B18E4528(a1, a2, v14, v15, v16, v17, v18, v19);
      v6 = 1;
    }
    else
    {
      sub_1B17C4408(0, (uint64_t)CFSTR("Warning: CFXSkinnerTransposeSkeleton - unable to transpose every joints"), v8, v9, v10, v11, v12, v13, v21);
      v6 = 0;
    }
  }
  CFRelease(MutableCopy);
  return v6;
}

uint64_t sub_1B18E4854(uint64_t a1, __CFArray *a2, const void *a3, const void *a4, _DWORD *a5)
{
  CFIndex Count;
  _BOOL4 v11;
  _BOOL4 v12;
  BOOL v13;
  uint64_t result;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (!a3)
    return 0;
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 88)) >= 1)
  {
    Count = 0;
    do
    {
      if (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), Count) == a3)
      {
        CFArraySetValueAtIndex(a2, Count, a4);
        ++*a5;
        Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
      }
      ++Count;
    }
    while (Count < CFArrayGetCount(*(CFArrayRef *)(a1 + 88)));
  }
  free(*(void **)(a1 + 96));
  *(_QWORD *)(a1 + 96) = 0;
  v11 = sub_1B1842B54((uint64_t)a3);
  v12 = sub_1B1842B54((uint64_t)a4);
  v13 = v12;
  result = v11 ^ v12 ^ 1u;
  if (v11 && v13)
  {
    v15 = sub_1B186AF90((uint64_t)a3);
    if (v15 == sub_1B186AF90((uint64_t)a4))
    {
      v16 = v15;
      if (v15)
      {
        v17 = 0;
        v18 = v16 - 1;
        do
        {
          v19 = sub_1B186B18C((uint64_t)a3, v17);
          v20 = sub_1B186B18C((uint64_t)a4, v17);
          result = sub_1B18E4854(a1, a2, v19, v20, a5);
          if (!(_DWORD)result)
            break;
        }
        while (v18 != v17++);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFIndex sub_1B18E49C0(uint64_t a1, uint64_t a2)
{
  CFIndex result;
  const void *ValueAtIndex;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
  if (result)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), 0);
    return ValueAtIndex != (const void *)a2 && !sub_1B186C870((uint64_t)ValueAtIndex, a2, v6, v7, v8, v9, v10, v11);
  }
  return result;
}

BOOL sub_1B18E4A18(uint64_t a1, _QWORD *a2)
{
  uint64_t Count;
  CFMutableArrayRef Mutable;
  BOOL v6;
  CFIndex v7;
  const void *ValueAtIndex;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const __CFString *v31;
  uint64_t v33;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
  Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]);
  if (Count < 1)
  {
    v6 = 1;
LABEL_8:
    sub_1B18E45B0(a1, Mutable);
    sub_1B18E4528(a1, a2, v25, v26, v27, v28, v29, v30);
  }
  else
  {
    v6 = 0;
    v7 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), v7);
      v16 = sub_1B186B0BC((uint64_t)ValueAtIndex, v9, v10, v11, v12, v13, v14, v15);
      if (!v16)
      {
        v31 = CFSTR("Warning: Cannot update the joints using node names: unammed joint found");
        goto LABEL_11;
      }
      v23 = v16;
      v24 = (const void *)sub_1B186BF28((uint64_t)a2, v16, v17, v18, v19, v20, v21, v22);
      if (!v24)
        break;
      CFArrayAppendValue(Mutable, v24);
      v6 = ++v7 >= Count;
      if (Count == v7)
        goto LABEL_8;
    }
    v33 = v23;
    v31 = CFSTR("Warning: Cannot update the joints using node names: can't find node named %@");
LABEL_11:
    sub_1B17C4408(0, (uint64_t)v31, v17, v18, v19, v20, v21, v22, v33);
  }
  CFRelease(Mutable);
  return v6;
}

BOOL sub_1B18E4B20(uint64_t a1)
{
  return *(_QWORD *)(a1 + 104) == 1;
}

void sub_1B18E4B30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeRef v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const void *v26;
  const __CFArray *v27;
  CFIndex Count;
  const __CFString *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float32x4_t *v34;
  uint64_t v35;
  float32x4_t *v36;
  float32x4_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  uint64_t v82;
  BOOL v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  float *v91;
  __int16 *v92;
  unsigned __int16 v93;
  int v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  uint64_t v98;
  float32x4_t v99;
  float32x4_t *v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  uint64_t v105;
  uint64_t v106;
  float32x4_t v107;
  float32x4_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  _OWORD v112[4];
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD **)(a1 + 72);
  if (!v9)
    return;
  v11 = sub_1B1868FA0(a2, a2, a3, a4, a5, a6, a7, a8);
  if (!v11)
  {
    v29 = CFSTR("Warning: _CFXSkinnerUpdateBoundingBox - skinned node has no geometry");
    v30 = 0;
LABEL_17:
    sub_1B17C4408(v30, (uint64_t)v29, v13, v14, v15, v16, v17, v18, a9);
    return;
  }
  v19 = sub_1B17A1ACC(v11, v12, v13, v14, v15, v16, v17, v18);
  v26 = sub_1B1875E70((uint64_t)v19, 0, v20, v21, v22, v23, v24, v25);
  v27 = *(const __CFArray **)(a1 + 88);
  if (v27)
    Count = CFArrayGetCount(v27);
  else
    Count = 0;
  v31 = sub_1B18F09A0((uint64_t)v9);
  if (!Count || Count != (int)v31)
  {
    if ((byte_1EEF66168 & 1) != 0)
      return;
    byte_1EEF66168 = 1;
    v29 = CFSTR("Error: We did not succeed in locating all the joints, so do not update the geometry as it might be worse if we use the wrong bones.");
    v30 = 16;
    goto LABEL_17;
  }
  v110 = 0;
  v111 = 0;
  v109 = 0;
  v33 = MEMORY[0x1E0C80A78](v31, v32);
  v34 = (float32x4_t *)(&v105 - 2 * Count);
  MEMORY[0x1E0C80A78](v33, v35);
  v36 = v34;
  sub_1B18F091C(v9, &v111, &v110, &v109);
  if (Count >= 1)
  {
    memset_pattern16(&v105 - 2 * Count, &xmmword_1B2247E80, 16 * Count);
    memset_pattern16(&v105 - 2 * Count, &xmmword_1B2247E90, 16 * Count);
  }
  v37 = (float32x4_t *)sub_1B18F0998((uint64_t)v9);
  v45 = sub_1B181F5A8((uint64_t)v9);
  v105 = (uint64_t)&v105;
  if (Count == 1)
  {
    v108.i32[2] = 0;
    v108.i64[0] = 0;
    v107.i32[2] = 0;
    v107.i64[0] = 0;
    sub_1B1874504((uint64_t)v19, &v108, &v107, v40, v41, v42, v43, v44);
    v46 = 0;
    v47 = v108;
    v48 = v107;
    v47.i32[3] = 1.0;
    v48.i32[3] = 1.0;
    v49 = vaddq_f32(v47, v48);
    v50 = vsubq_f32(v48, v47);
    v51 = *(float32x4_t *)v45;
    v52 = *(float32x4_t *)(v45 + 16);
    v53 = *(float32x4_t *)(v45 + 32);
    v54 = *(float32x4_t *)(v45 + 48);
    v55 = v37[1];
    v56 = v37[2];
    v57 = v37[3];
    v112[0] = *v37;
    v112[1] = v55;
    v112[2] = v56;
    v112[3] = v57;
    v113 = 0u;
    v114 = 0u;
    v115 = 0u;
    v116 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v113 + v46 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v51, COERCE_FLOAT(v112[v46])), v52, *(float32x2_t *)&v112[v46], 1), v53, (float32x4_t)v112[v46], 2), v54, (float32x4_t)v112[v46], 3);
      ++v46;
    }
    while (v46 != 4);
    v58.i64[0] = 0x3F0000003F000000;
    v58.i64[1] = 0x3F0000003F000000;
    v59 = vmulq_f32(v49, v58);
    v60 = (int32x4_t)vmulq_f32(v50, v58);
    v61 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v116, v115, v59, 2), v114, *(float32x2_t *)v59.f32, 1), v113, v59.f32[0]);
    v61.i32[3] = v59.i32[3];
    v62 = (float32x4_t)v60;
    v62.i32[1] = v60.i32[0];
    v62.i32[2] = v60.i32[0];
    v63 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v60.i8, 1), v60), vabsq_f32(v114)), v62, vabsq_f32(v113)), (float32x4_t)vzip2q_s32(vtrn1q_s32(v60, v60), v60), vabsq_f32(v115));
    *v34 = vsubq_f32(v61, v63);
    *v34 = vaddq_f32(v63, v61);
  }
  else
  {
    v106 = sub_1B17ED6C4((uint64_t)v26, v38, v39, v40, v41, v42, v43, v44);
    v71 = BYTE5(v64);
    if (BYTE5(v64))
    {
      v72 = v64;
      if ((int)v64 - 1 < sub_1B17EE4F8((uint64_t)v9))
      {
        v82 = 0;
        do
        {
          *(double *)v79.i64 = sub_1B198D4F8(BYTE4(v72), (const float *)(v106 + (v71 * v82)), v73, v74, v75, v76, v77, v78, v79, v80.f32[0], v81.f32[0]);
          v80 = *v37;
          v81 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v37[3], v37[2], v79, 2), v37[1], *(float32x2_t *)v79.f32, 1), *v37, v79.f32[0]);
          if (v111)
            v83 = Count < 2;
          else
            v83 = 1;
          if (v83)
          {
            v80 = *(float32x4_t *)(v45 + 16);
            v84 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(v45 + 48), *(float32x4_t *)(v45 + 32), v81, 2), v80, *(float32x2_t *)v81.f32, 1), *(float32x4_t *)v45, v81.f32[0]);
            v85 = *v34;
            v84.i32[3] = 0;
            v85.i32[3] = 0;
            *v34 = vminnmq_f32(v84, v85);
            v86 = *v34;
            v86.i32[3] = 0;
            v79 = vmaxnmq_f32(v84, v86);
            *v34 = v79;
            ++v82;
          }
          else
          {
            v87 = *(_QWORD *)(v111 + 8 * v82++);
            v88 = *(_QWORD *)(v111 + 8 * v82);
            v83 = v88 <= v87;
            v89 = v88 - v87;
            if (!v83)
            {
              v90 = v109;
              v79 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 0);
              v80 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 1);
              v81 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 2);
              v91 = (float *)(v109 + 4 * v87);
              v92 = (__int16 *)(v110 + 2 * v87);
              do
              {
                v94 = *v92++;
                v93 = v94;
                if ((v94 & 0x80000000) == 0 && (!v90 || *v91 > 0.0) && Count > v93)
                {
                  v95 = vmlaq_f32(vmlaq_f32(vmlaq_f32(*(float32x4_t *)(v45 + ((unint64_t)v93 << 6) + 48), *(float32x4_t *)(v45 + ((unint64_t)v93 << 6) + 32), v81), *(float32x4_t *)(v45 + ((unint64_t)v93 << 6) + 16), v80), *(float32x4_t *)(v45 + ((unint64_t)v93 << 6)), v79);
                  v96 = v34[v93];
                  v95.i32[3] = 0;
                  v96.i32[3] = 0;
                  v34[v93] = vminnmq_f32(v95, v96);
                  v97 = v34[v93];
                  v97.i32[3] = 0;
                  v34[v93] = vmaxnmq_f32(v95, v97);
                }
                ++v91;
                --v89;
              }
              while (v89);
            }
          }
        }
        while (v82 != v72);
      }
    }
    else
    {
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: _CFXSkinnerUpdateBoundingBox invalid mesh source"), v65, v66, v67, v68, v69, v70, v105);
    }
  }
  if (Count >= 1)
  {
    v98 = 0;
    v99.i64[0] = 0x3F0000003F000000;
    v99.i64[1] = 0x3F0000003F000000;
    do
    {
      v100 = (float32x4_t *)(*(_QWORD *)(a1 + 128) + v98);
      v101 = *v34++;
      v102 = v101;
      v103 = *v36++;
      v104 = v103;
      v102.i32[3] = 1.0;
      v104.i32[3] = 1.0;
      *v100 = vmulq_f32(vaddq_f32(v102, v104), v99);
      v100[1] = vmulq_f32(vsubq_f32(v104, v102), v99);
      v98 += 32;
      --Count;
    }
    while (Count);
  }
  *(_BYTE *)(a1 + 176) = 0;
}

double sub_1B18E5004(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, simd_float4 a5, simd_float4 a6, simd_float4 a7, simd_float4 a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  CFIndex v39;
  _OWORD *v40;
  uint64_t *v41;
  uint64_t v42;
  int v43;
  __int128 *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  const void *ValueAtIndex;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  char v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t *v62;
  float32x4_t v63;
  float32x4_t v64;
  int32x2_t *v65;
  float32x4_t v66;
  uint64_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  char v76;
  float32x4_t v77;
  float32x4_t v78;
  double result;
  uint64_t v80;
  uint64_t v81;
  simd_float4x4 v82;
  uint64_t v83;
  simd_float4x4 v84;

  v82.columns[2] = a7;
  v82.columns[3] = a8;
  v82.columns[0] = a5;
  v82.columns[1] = a6;
  v83 = *MEMORY[0x1E0C80C00];
  v11 = sub_1B18F0604(a2);
  v84 = __invert_f4(v82);
  v82.columns[2] = v84.columns[1];
  v82.columns[3] = v84.columns[0];
  v82.columns[0] = v84.columns[3];
  v82.columns[1] = v84.columns[2];
  v19 = sub_1B17C61FC(a3, v12, v13, v14, v15, v16, v17, v18);
  if (v19)
    v27 = sub_1B187B2A8(v19, v20, v21, v22, v23, v24, v25, v26);
  else
    v27 = 0;
  v28 = *(_QWORD **)(a1 + 80);
  if (v28)
    v29 = sub_1B17C6244(v28, v20, v21, v22, v23, v24, v25, v26);
  else
    v29 = 0;
  v31 = sub_1B17C6244((_QWORD *)a1, v20, v21, v22, v23, v24, v25, v26);
  v32 = *(void **)(a1 + 96);
  if (v29 == v31)
  {
    if (!v32)
      v32 = (void *)sub_1B18E423C(a1);
  }
  else
  {
    free(v32);
    *(_QWORD *)(a1 + 96) = 0;
  }
  MEMORY[0x1E0C80A78](v32, v30);
  if (a4 < 1)
  {
    v76 = sub_1B18693D0(a3);
    v59 = (float32x4_t)v82.columns[2];
    v58 = (float32x4_t)v82.columns[3];
    v61 = (float32x4_t)v82.columns[0];
    v60 = (float32x4_t)v82.columns[1];
    if ((v76 & 1) == 0)
    {
      v64 = (float32x4_t)xmmword_1B2246ED0;
      v63 = (float32x4_t)xmmword_1B2244E20;
LABEL_28:
      v77 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v61, v60, v63, 2), v59, *(float32x2_t *)v63.f32, 1), v58, v63.f32[0]);
      v77.i32[3] = v63.i32[3];
      v78 = v64;
      v78.i32[1] = v64.i32[0];
      v78.i32[2] = v64.i32[0];
      *(float32x4_t *)(a1 + 144) = v77;
      *(float32x4_t *)(a1 + 160) = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v64.f32, 1), (int32x4_t)v64), vabsq_f32(v59)), v78, vabsq_f32(v58)), (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v64, (int32x4_t)v64), (int32x4_t)v64), vabsq_f32(v60));
    }
  }
  else
  {
    v81 = v11;
    v39 = 0;
    v40 = (_OWORD *)MEMORY[0x1E0C83FF0];
    v41 = &v80 - 8 * a4;
    do
    {
      v42 = *(_QWORD *)(a1 + 96);
      if (!v42 || (v43 = *(_DWORD *)(v42 + 4 * v39), v43 == -1))
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), v39);
        if (ValueAtIndex)
        {
          sub_1B186BE18((uint64_t)ValueAtIndex, (uint64_t)v41, v49, v50, v51, v52, v53, v54);
        }
        else
        {
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v49, v50, v51, v52, v53, v54, (uint64_t)"joint");
          v55 = v40[1];
          *(_OWORD *)v41 = *v40;
          *((_OWORD *)v41 + 1) = v55;
          v56 = v40[3];
          *((_OWORD *)v41 + 2) = v40[2];
          *((_OWORD *)v41 + 3) = v56;
        }
      }
      else
      {
        v44 = (__int128 *)sub_1B18D138C(v27, v43, v33, v34, v35, v36, v37, v38);
        v45 = v44[3];
        v47 = *v44;
        v46 = v44[1];
        *((_OWORD *)v41 + 2) = v44[2];
        *((_OWORD *)v41 + 3) = v45;
        *(_OWORD *)v41 = v47;
        *((_OWORD *)v41 + 1) = v46;
      }
      ++v39;
      v41 += 8;
    }
    while (a4 != v39);
    v57 = sub_1B18693D0(a3);
    v11 = v81;
    v59 = (float32x4_t)v82.columns[2];
    v58 = (float32x4_t)v82.columns[3];
    v61 = (float32x4_t)v82.columns[0];
    v60 = (float32x4_t)v82.columns[1];
    if ((v57 & 1) == 0)
    {
      v62 = (float32x4_t *)(&v80 - 8 * a4 + 4);
      v63 = (float32x4_t)xmmword_1B2244E20;
      v64 = (float32x4_t)xmmword_1B2246ED0;
      v65 = (int32x2_t *)(*(_QWORD *)(a1 + 128) + 16);
      v66.i64[0] = 0x3F0000003F000000;
      v66.i64[1] = 0x3F0000003F000000;
      v67 = a4;
      do
      {
        if ((vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)v65->i8)) & 0x80000000) != 0)
        {
          v68 = v62[-2];
          v69 = v62[-1];
          v70 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v62[1], *v62, *(float32x4_t *)v65[-2].i8, 2), v69, (float32x2_t)v65[-2], 1), v68, COERCE_FLOAT(*(_OWORD *)v65[-2].i8));
          v70.i32[3] = HIDWORD(*(_OWORD *)v65[-2].i8);
          v71 = vabsq_f32(v68);
          v72 = *(float32x4_t *)v65->i8;
          v72.i32[1] = *(_OWORD *)v65->i8;
          v72.i32[2] = v72.i32[1];
          v73 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*v65, 1), *(int32x4_t *)v65->i8), vabsq_f32(v69)), v72, v71), (float32x4_t)vzip2q_s32(vtrn1q_s32(*(int32x4_t *)v65->i8, *(int32x4_t *)v65->i8), *(int32x4_t *)v65->i8), vabsq_f32(*v62));
          v74 = vminnmq_f32(vsubq_f32(v63, v64), vsubq_f32(v70, v73));
          v75 = vmaxnmq_f32(vaddq_f32(v63, v64), vaddq_f32(v73, v70));
          v63 = vmulq_f32(vaddq_f32(v74, v75), v66);
          v64 = vmulq_f32(vsubq_f32(v75, v74), v66);
        }
        v62 += 4;
        v65 += 4;
        --v67;
      }
      while (v67);
      goto LABEL_28;
    }
  }
  sub_1B18407A8((float32x4_t *)&v80 - 4 * a4, (uint64_t)(&v80 - 8 * a4), a4, v58, v59, v60, v61);
  sub_1B1840714(*(float32x4_t **)(a1 + 112), (float32x4_t *)&v80 - 4 * a4, v11, a4);
  *(_QWORD *)&result = sub_1B184083C(*(_QWORD *)(a1 + 120), (int32x4_t *)*(_QWORD *)(a1 + 112), a4).u64[0];
  return result;
}

void sub_1B18E534C(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  simd_float4 *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;

  if (*(_BYTE *)(a1 + 176))
    sub_1B18E4B30(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v38);
  v11 = *(_QWORD *)(a1 + 72);
  if (!v11)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"skin");
  v12 = sub_1B18F09A0(v11);
  if (*(_QWORD *)(a1 + 88) && (v20 = *(_QWORD *)(a1 + 104)) != 0 && (v21 = v12, v20 == v12))
  {
    v22 = sub_1B1868FA0((uint64_t)a2, v13, v14, v15, v16, v17, v18, v19);
    if (v22)
      sub_1B17A1ACC(v22, v23, v24, v25, v26, v27, v28, v29);
    v30 = (simd_float4 *)sub_1B1869AC8((uint64_t)a2, v23, v24, v25, v26, v27, v28, v29);
    sub_1B18E5004(a1, v11, (uint64_t)a2, v21, *v30, v30[1], v30[2], v30[3]);
    sub_1B18690BC(a2, v31, v32, v33, v34, v35, v36, v37);
  }
  else if ((byte_1EEF66169 & 1) == 0)
  {
    byte_1EEF66169 = 1;
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: We did not succeed in locating all the joints, so do not update the geometry as it might be worse if we use the wrong bones."), v14, v15, v16, v17, v18, v19, a9);
  }
}

uint64_t sub_1B18E5458(uint64_t a1, _QWORD *a2)
{
  if (a2)
    *a2 = 3 * *(_QWORD *)(a1 + 104);
  return *(_QWORD *)(a1 + 120);
}

float32x4_t sub_1B18E5470(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFArray *v11;
  CFIndex Count;
  CFIndex v13;
  uint64_t v14;
  CFIndex v15;
  _QWORD *ValueAtIndex;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  float32x4_t result;
  CFTypeRef v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  __int128 v82;
  uint64_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;

  if (*(_BYTE *)(a1 + 176))
    sub_1B18E4B30(a1, a2, a3, a4, a5, a6, a7, a8, v83);
  if ((vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(a1 + 160))) & 0x80000000) != 0)
    goto LABEL_20;
  v11 = *(const __CFArray **)(a1 + 88);
  if (v11)
  {
    Count = CFArrayGetCount(v11);
    if (Count)
    {
      v13 = Count;
      if (Count < 1)
      {
        v85 = (float32x4_t)xmmword_1B2246ED0;
        v84 = (float32x4_t)xmmword_1B2244E20;
      }
      else
      {
        v14 = 0;
        v15 = 0;
        v84 = (float32x4_t)xmmword_1B2244E20;
        v85 = (float32x4_t)xmmword_1B2246ED0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), v15);
          v24 = sub_1B17C6244(ValueAtIndex, v17, v18, v19, v20, v21, v22, v23);
          if (v24)
          {
            v32 = v24;
            sub_1B187973C(v24, v25, v26, v27, v28, v29, v30, v31);
            v40 = sub_1B1869AC8((uint64_t)ValueAtIndex, v33, v34, v35, v36, v37, v38, v39);
            sub_1B18797B4(v32, v41, v42, v43, v44, v45, v46, v47);
          }
          else
          {
            v40 = sub_1B1869AC8((uint64_t)ValueAtIndex, v25, v26, v27, v28, v29, v30, v31);
          }
          v48 = *(_QWORD *)(a1 + 128);
          v49 = *(float32x4_t *)(v48 + v14 + 16);
          if ((vminvq_u32((uint32x4_t)vcgezq_f32(v49)) & 0x80000000) != 0)
          {
            v50 = *(float32x4_t *)(v40 + 16);
            v51 = *(float32x4_t *)(v40 + 32);
            v52 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(v40 + 48), v51, *(float32x4_t *)(v48 + v14), 2), v50, *(float32x2_t *)(v48 + v14), 1), *(float32x4_t *)v40, COERCE_FLOAT(*(_OWORD *)(v48 + v14)));
            v52.i32[3] = HIDWORD(*(_OWORD *)(v48 + v14));
            v53 = *(float32x4_t *)(v48 + v14 + 16);
            v53.i32[1] = v53.i32[0];
            v53.i32[2] = *(_OWORD *)(v48 + v14 + 16);
            v54 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v49.f32, 1), (int32x4_t)v49), vabsq_f32(v50)), v53, vabsq_f32(*(float32x4_t *)v40)), (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v49, (int32x4_t)v49), (int32x4_t)v49), vabsq_f32(v51));
            v55 = vminnmq_f32(vsubq_f32(v84, v85), vsubq_f32(v52, v54));
            v56 = vmaxnmq_f32(vaddq_f32(v84, v85), vaddq_f32(v54, v52));
            v54.i64[0] = 0x3F0000003F000000;
            v54.i64[1] = 0x3F0000003F000000;
            v84 = vmulq_f32(vaddq_f32(v55, v56), v54);
            v85 = vmulq_f32(vsubq_f32(v56, v55), v54);
          }
          ++v15;
          v14 += 32;
        }
        while (v13 != v15);
      }
      *(double *)v76.i64 = sub_1B186B90C(a2, a2, a3, a4, a5, a6, a7, a8);
      v80 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v78, v77, v84, 2), v79, *(float32x2_t *)v84.f32, 1), v76, v84.f32[0]);
      v80.i32[3] = v84.i32[3];
      v81 = v85;
      v81.i32[1] = v85.i32[0];
      v81.i32[2] = v85.i32[0];
      *(float32x4_t *)(a1 + 144) = v80;
      *(float32x4_t *)(a1 + 160) = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v85.f32, 1), (int32x4_t)v85), vabsq_f32(v79)), v81, vabsq_f32(v76)), (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v85, (int32x4_t)v85), (int32x4_t)v85), vabsq_f32(v77));
LABEL_20:
      result = *(float32x4_t *)(a1 + 144);
      v82 = *(_OWORD *)(a1 + 160);
      *(float32x4_t *)a3 = result;
      *(_OWORD *)(a3 + 16) = v82;
      return result;
    }
  }
  v57 = sub_1B1868FA0(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v57)
  {
    v66 = sub_1B17A1ACC(v57, v58, v59, v60, v61, v62, v63, v64);
    v87.i32[2] = 0;
    v87.i64[0] = 0;
    v86.i32[2] = 0;
    v86.i64[0] = 0;
    sub_1B1874504((uint64_t)v66, &v87, &v86, v67, v68, v69, v70, v71);
    v73 = v86;
    v72 = v87;
    v72.i32[3] = 1.0;
    v73.i32[3] = 1.0;
    v74.i64[0] = 0x3F0000003F000000;
    v74.i64[1] = 0x3F0000003F000000;
    v75 = vmulq_f32(vaddq_f32(v72, v73), v74);
    result = vmulq_f32(vsubq_f32(v73, v72), v74);
    *(float32x4_t *)a3 = v75;
    *(float32x4_t *)(a3 + 16) = result;
  }
  return result;
}

uint64_t sub_1B18E56FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"skinner");
  if (*(_BYTE *)(a1 + 176))
    sub_1B18E4B30(a1, a2, a3, a4, a5, a6, a7, a8, v11);
  return *(_QWORD *)(a1 + 128);
}

void sub_1B18E575C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  uint64_t v12;
  BOOL v13;
  uint64_t v14[4];
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  BOOL v19;

  if (*(_BYTE *)(a1 + 176))
    sub_1B18E4B30(a1, a3, a3, a4, a5, a6, a7, a8, v14[0]);
  v12 = *(_QWORD *)(a1 + 80);
  if (v12)
  {
    v13 = sub_1B186AF90(v12) == 0;
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 0x40000000;
    v14[2] = (uint64_t)sub_1B18E580C;
    v14[3] = (uint64_t)&unk_1E63D8B90;
    v18 = a9;
    v16 = v12;
    v17 = a2;
    v15 = xmmword_1B2244E50;
    v19 = v13;
    sub_1B186B018(v12, (uint64_t)v14);
  }
}

uint64_t sub_1B18E580C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  simd_float4 v10;
  simd_float4 v11;
  simd_float4 v12;
  simd_float4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  simd_float4x4 v24;
  uint64_t v25;
  uint64_t *v26;
  float *v27;
  simd_float4 v29;
  simd_float4 v30;
  simd_float4 v31;
  simd_float4 v32;
  float32x4_t v33;
  float32x4_t v34;
  simd_float4x4 v35;

  if (*(_QWORD *)(a1 + 48) != a2)
  {
    *(double *)v10.i64 = sub_1B18697A0(a2, a2, a3, a4, a5, a6, a7, a8);
    v31 = v11;
    v32 = v10;
    v29 = v13;
    v30 = v12;
    v21 = sub_1B1869AC8(a2, v14, v15, v16, v17, v18, v19, v20);
    v35.columns[1] = v31;
    v35.columns[0] = v32;
    v35.columns[3] = v29;
    v35.columns[2] = v30;
    v24 = __invert_f4(v35);
    v34 = 0uLL;
    v24.columns[0] = (simd_float4)vmulq_f32((float32x4_t)v24.columns[3], (float32x4_t)v24.columns[3]);
    v24.columns[1] = (simd_float4)vaddq_f32((float32x4_t)v24.columns[0], (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.columns[0].f32, 1));
    v24.columns[0] = (simd_float4)vdupq_laneq_s32((int32x4_t)v24.columns[0], 2);
    v24.columns[1].i32[0] = vaddq_f32((float32x4_t)v24.columns[0], (float32x4_t)v24.columns[1]).u32[0];
    v24.columns[0].f32[0] = sqrtf(v24.columns[1].f32[0]);
    if (v24.columns[0].f32[0] <= 0.0)
    {
      v24.columns[2] = (simd_float4)xmmword_1B2244DD0;
      v24.columns[1].i32[0] = *(_DWORD *)(a1 + 64);
      v24.columns[0].i32[0] = v24.columns[1].i32[0];
    }
    else
    {
      v24.columns[2].i32[0] = v24.columns[1].i32[0];
      *(float32x2_t *)v24.columns[1].f32 = vrsqrte_f32((float32x2_t)v24.columns[1].u32[0]);
      *(float32x2_t *)v24.columns[1].f32 = vmul_f32(*(float32x2_t *)v24.columns[1].f32, vrsqrts_f32((float32x2_t)v24.columns[2].u32[0], vmul_f32(*(float32x2_t *)v24.columns[1].f32, *(float32x2_t *)v24.columns[1].f32)));
      v24.columns[2] = (simd_float4)vmulq_n_f32((float32x4_t)v24.columns[3], vmul_f32(*(float32x2_t *)v24.columns[1].f32, vrsqrts_f32((float32x2_t)v24.columns[2].u32[0], vmul_f32(*(float32x2_t *)v24.columns[1].f32, *(float32x2_t *)v24.columns[1].f32))).f32[0]);
      v24.columns[1].i32[0] = *(_DWORD *)(a1 + 64);
    }
    v33 = (float32x4_t)v24.columns[2];
    v26 = *(uint64_t **)(a1 + 56);
    v27 = (float *)(a1 + 32);
    v25 = v21;
    goto LABEL_8;
  }
  if (*(_BYTE *)(a1 + 68))
  {
    v25 = sub_1B1869AC8(a2, a2, a3, a4, a5, a6, a7, a8);
    v34 = 0uLL;
    v24.columns[0].i32[1] = 1065353216;
    v33 = (float32x4_t)xmmword_1B2244DD0;
    v24.columns[0].i32[0] = *(_DWORD *)(a1 + 64);
    v26 = *(uint64_t **)(a1 + 56);
    v27 = (float *)(a1 + 32);
    v24.columns[1].i32[0] = v24.columns[0].i32[0];
LABEL_8:
    sub_1B17FCB54(v26, &v34, &v33, v25, v27, 1, v22, v23, *(double *)v24.columns[0].i64, v24.columns[1].f32[0]);
  }
  return 0;
}

void sub_1B18E5930(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex Count;
  CFIndex v11;
  uint64_t v12;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;

  if (*(_BYTE *)(a1 + 176))
    sub_1B18E4B30(a1, a3, a3, a4, a5, a6, a7, a8, v27);
  v27 = xmmword_1B2244E40;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
  if (Count >= 1)
  {
    v11 = Count;
    v12 = 0;
    for (i = 0; i != v11; ++i)
    {
      if ((vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 128) + v12 + 16))) & 0x80000000) != 0)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), i);
        v22 = sub_1B1869AC8((uint64_t)ValueAtIndex, v15, v16, v17, v18, v19, v20, v21);
        sub_1B17FB0F8(a2, (float32x4_t *)(*(_QWORD *)(a1 + 128) + v12), v22, (float *)&v27, v23, v24, v25, v26);
      }
      v12 += 32;
    }
  }
}

BOOL sub_1B18E59F8(int a1)
{
  return a1 == 0;
}

double sub_1B18E5A04(uint64_t a1)
{
  double result;

  *(_BYTE *)(a1 + 176) = 1;
  result = 0.0;
  *(_OWORD *)(a1 + 144) = xmmword_1B2244E20;
  *(_OWORD *)(a1 + 160) = xmmword_1B2246ED0;
  return result;
}

id sub_1B18E5A28(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  const void *v10;
  void *v11;
  void *v12;
  void *v13;
  const void *v14;

  if (a1[9])
    sub_1B18E4434((uint64_t)a1, 0, a3, a4, a5, a6, a7, a8);
  v9 = (void *)a1[15];
  if (v9)
    free(v9);
  v10 = (const void *)a1[11];
  if (v10)
    CFRelease(v10);
  v11 = (void *)a1[14];
  if (v11)
    free(v11);
  v12 = (void *)a1[16];
  if (v12)
    free(v12);
  v13 = (void *)a1[12];
  if (v13)
    free(v13);
  v14 = (const void *)a1[10];
  if (v14)
  {
    CFRelease(v14);
    a1[10] = 0;
  }
  return sub_1B193E38C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
}

__CFString *sub_1B18E5AAC(_QWORD *a1)
{
  const __CFArray *v2;
  CFIndex Count;
  __CFString *Mutable;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = (const __CFArray *)a1[11];
  if (v2)
    Count = CFArrayGetCount(v2);
  else
    Count = 0;
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFXSkinner %p skeleton:%p jointCount:%d cpuReady:%d\n"), a1, a1[10], Count);
  CFStringAppendFormat(Mutable, 0, CFSTR("  skin:%p\n"), a1[9]);
  if ((uint64_t)a1[13] >= 1)
  {
    v5 = 0;
    v6 = 0;
    do
    {
      v7 = a1[16];
      if (!v7)
        break;
      v8 = v7 + v5;
      CFStringAppendFormat(Mutable, 0, CFSTR("  JointBbox[%d] {%f,%f,%f} {%f,%f,%f}\n"), v6++, *(float *)v8, *(float *)(v8 + 4), *(float *)(v8 + 8), COERCE_FLOAT(*(_OWORD *)(v8 + 16)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v8 + 16))), COERCE_FLOAT(*(_QWORD *)(v8 + 24)));
      v5 += 32;
    }
    while (v6 < a1[13]);
  }
  CFStringAppend(Mutable, CFSTR(">"));
  return Mutable;
}

__CFArray *sub_1B18E5BE4(uint64_t a1)
{
  __CFArray *Mutable;
  const CFDictionaryKeyCallBacks *v3;
  const CFDictionaryValueCallBacks *v4;
  __CFDictionary *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  __CFDictionary *v16;
  CFNumberRef v17;
  CFNumberRef v18;
  CFNumberRef v19;
  __CFDictionary *v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  __CFDictionary *v24;
  CFNumberRef v25;
  CFNumberRef v26;
  CFNumberRef v27;
  __CFDictionary *v28;
  CFNumberRef v29;
  CFNumberRef v30;
  CFNumberRef v31;
  __CFArray *v32;
  uint64_t v33;
  const __CFArray *v34;
  CFIndex Count;
  CFIndex v36;
  uint64_t v37;
  uint64_t i;
  CFStringRef v39;
  __CFDictionary *v40;
  CFNumberRef v41;
  CFNumberRef v42;
  CFNumberRef v43;
  uint64_t v45;
  int v46;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v46 = 1;
  valuePtr = 5;
  v45 = sub_1B193E7B8(a1, v6, v7, v8, v9, v10, v11, v12);
  v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  v15 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v5, CFSTR("name"), CFSTR("attributes"));
  CFDictionarySetValue(v5, CFSTR("type"), v13);
  CFDictionarySetValue(v5, CFSTR("address"), v15);
  CFDictionarySetValue(v5, CFSTR("semantic"), v14);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v14);
  CFRelease(v5);
  CFRelease(v15);
  CFRelease(v13);
  v16 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v46 = 2;
  valuePtr = 5;
  v45 = a1 + 72;
  v17 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v18 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  v19 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v16, CFSTR("name"), CFSTR("skin"));
  CFDictionarySetValue(v16, CFSTR("type"), v17);
  CFDictionarySetValue(v16, CFSTR("address"), v19);
  CFDictionarySetValue(v16, CFSTR("semantic"), v18);
  CFArrayAppendValue(Mutable, v16);
  CFRelease(v18);
  CFRelease(v16);
  CFRelease(v19);
  CFRelease(v17);
  v20 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v46 = 2;
  valuePtr = 5;
  v45 = a1 + 80;
  v21 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v22 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  v23 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v20, CFSTR("name"), CFSTR("skeleton"));
  CFDictionarySetValue(v20, CFSTR("type"), v21);
  CFDictionarySetValue(v20, CFSTR("address"), v23);
  CFDictionarySetValue(v20, CFSTR("semantic"), v22);
  CFArrayAppendValue(Mutable, v20);
  CFRelease(v22);
  CFRelease(v20);
  CFRelease(v23);
  CFRelease(v21);
  v24 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v46 = 2;
  valuePtr = 5;
  v45 = a1 + 88;
  v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v26 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  v27 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v24, CFSTR("name"), CFSTR("joints"));
  CFDictionarySetValue(v24, CFSTR("type"), v25);
  CFDictionarySetValue(v24, CFSTR("address"), v27);
  CFDictionarySetValue(v24, CFSTR("semantic"), v26);
  CFArrayAppendValue(Mutable, v24);
  CFRelease(v26);
  CFRelease(v24);
  CFRelease(v27);
  CFRelease(v25);
  v28 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v46 = 0;
  valuePtr = 3;
  v45 = a1 + 176;
  v29 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v30 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  v31 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v28, CFSTR("name"), CFSTR("bboxDirty"));
  CFDictionarySetValue(v28, CFSTR("type"), v29);
  CFDictionarySetValue(v28, CFSTR("address"), v31);
  CFDictionarySetValue(v28, CFSTR("semantic"), v30);
  v32 = Mutable;
  CFArrayAppendValue(Mutable, v28);
  CFRelease(v30);
  CFRelease(v28);
  v33 = a1;
  CFRelease(v31);
  CFRelease(v29);
  v34 = *(const __CFArray **)(a1 + 88);
  if (v34)
  {
    Count = CFArrayGetCount(v34);
    if (Count >= 1)
    {
      v36 = Count;
      v37 = 0;
      for (i = 0; i != v36; ++i)
      {
        v39 = CFStringCreateWithFormat(0, 0, CFSTR("verticesJointsMatrices[%d]"), i);
        v40 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v46 = 0;
        valuePtr = 10;
        v45 = *(_QWORD *)(v33 + 112) + v37;
        v41 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
        v42 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
        v43 = CFNumberCreate(0, kCFNumberLongType, &v45);
        CFDictionarySetValue(v40, CFSTR("name"), v39);
        CFDictionarySetValue(v40, CFSTR("type"), v41);
        CFDictionarySetValue(v40, CFSTR("address"), v43);
        CFDictionarySetValue(v40, CFSTR("semantic"), v42);
        CFArrayAppendValue(v32, v40);
        CFRelease(v42);
        CFRelease(v40);
        CFRelease(v43);
        CFRelease(v41);
        CFRelease(v39);
        v37 += 64;
      }
    }
  }
  return v32;
}

uint64_t sub_1B18E622C(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 72);
  if (v2)
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v2);
  return result;
}

void sub_1B18E624C(uint64_t a1)
{
  free(*(void **)(a1 + 96));
  *(_QWORD *)(a1 + 96) = 0;
}

uint64_t sub_1B18E6274(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v10;

  v10 = (const void *)sub_1B193E634(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B17987F8(v10, a2))
    return a1;
  else
    return sub_1B17C62B4(*(const void **)(a1 + 72), (uint64_t)a2);
}

uint64_t sub_1B18E62BC(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5)
{
  uint64_t *v9;
  unsigned __int8 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int v19;
  uint64_t v20;

  v9 = &qword_1EEF66000;
  v10 = atomic_load((unsigned __int8 *)&qword_1EEF66178);
  if ((v10 & 1) == 0)
  {
    v20 = a5;
    v19 = __cxa_guard_acquire(&qword_1EEF66178);
    v9 = &qword_1EEF66000;
    a5 = v20;
    if (v19)
    {
      byte_1EEF66170 = 1;
      __cxa_guard_release(&qword_1EEF66178);
      v9 = &qword_1EEF66000;
      a5 = v20;
    }
  }
  if (*((_BYTE *)v9 + 368))
    v11 = 0x11A993FC41E72446;
  else
    v11 = 0;
  CFX::RG::Pass::Pass(a1, a2, a3, a5, 1, v11, 0);
  *(_QWORD *)a1 = &off_1E63CE570;
  v12 = *a4;
  v13 = a4[1];
  v14 = a4[3];
  *(_OWORD *)(a1 + 400) = a4[2];
  *(_OWORD *)(a1 + 416) = v14;
  *(_OWORD *)(a1 + 368) = v12;
  *(_OWORD *)(a1 + 384) = v13;
  v15 = a4[4];
  v16 = a4[5];
  v17 = a4[7];
  *(_OWORD *)(a1 + 464) = a4[6];
  *(_OWORD *)(a1 + 480) = v17;
  *(_OWORD *)(a1 + 432) = v15;
  *(_OWORD *)(a1 + 448) = v16;
  sub_1B1961028(a1 + 496, a2, a3, *(_QWORD *)a4, a4 + 1);
  return a1;
}

void sub_1B18E63C4(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18E63D8(uint64_t a1)
{
  return a1 + 496;
}

void sub_1B18E63E0(__n128 *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v5 = (uint64_t)&a1[31];
  sub_1B19610E0(a1 + 31, a2, a3, a4);
  sub_1B196142C(v5, v6, v7, v8, v9, v10, v11, v12);
  sub_1B1961820(v5);
  sub_1B196184C(v5, v13, v14, v15, v16, v17, v18, v19);
  if (a1[23].n128_u8[8])
    sub_1B196185C(v5, v20, v21, v22, v23, v24, v25, v26);
}

void sub_1B18E6438(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  CFX::CrossFrameResourceManager *v9;
  uint64_t v10;

  v6 = sub_1B1815BE8(*(_QWORD *)(a1 + 368), (const char *)a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Perform culling", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/CullingPass.mm", 33, v6 | 0x300000000);
  sub_1B1961A30((uint64_t *)(a1 + 496), *(const char **)a2, *(_QWORD *)(a2 + 8), v7);
  if (*(_BYTE *)(a1 + 376))
  {
    v8 = sub_1B181E7E0(a1 + 496);
    v9 = *(CFX::CrossFrameResourceManager **)(a2 + 32);
    v10 = sub_1B1960EF8();
    sub_1B18E64D4(v9, v10)[2] = v8;
  }
  prof_endFlame();
}

void sub_1B18E64C4(_Unwind_Exception *a1)
{
  prof_endFlame();
  _Unwind_Resume(a1);
}

_QWORD *sub_1B18E64D4(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v4)
  {
    v4 = (_QWORD *)operator new();
    v4[1] = 0;
    v4[2] = 0;
    *v4 = &off_1E63CE618;
    CFX::CrossFrameResourceManager::set((uint64_t)a1, a2, (uint64_t)v4);
  }
  return v4;
}

void sub_1B18E6548(__n128 *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if ((_DWORD)a3 == 1)
  {
    sub_1B18E6438((uint64_t)a1, (uint64_t)a2, a3, a4);
  }
  else if (!(_DWORD)a3)
  {
    sub_1B18E63E0(a1, a2, a3, a4);
  }
}

uint64_t sub_1B18E6560(uint64_t *a1, __int128 *a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a3;
  return sub_1B18E6584(a1, a2, &v4);
}

uint64_t sub_1B18E6584(uint64_t *a1, __int128 *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B18E666C(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

void sub_1B18E65D8(CFX::RG::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E63CE570;
  sub_1B19610A0((uint64_t)a1 + 496);
  CFX::RG::Pass::~Pass(a1);
}

void sub_1B18E660C(CFX::RG::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E63CE570;
  sub_1B19610A0((uint64_t)a1 + 496);
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

void sub_1B18E6658()
{
  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B18E666C(uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4, uint64_t *a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x2A0u, 0x10u);
  return sub_1B18E62BC(v8, *a3, a3[1], a4, *a5);
}

void sub_1B18E682C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_1B18E45B0(*(_QWORD *)(a1 + 32), 0);
  sub_1B18E4528(*(_QWORD *)(a1 + 32), 0, v2, v3, v4, v5, v6, v7);
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

void *sub_1B18E69AC(void *a1, const char *a2)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t i;
  void *v11;
  void *v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v3 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, a2, (uint64_t)&v14, (uint64_t)v18, 16);
  if (!v3)
    return 0;
  v7 = v3;
  v8 = 0;
  v9 = *(_QWORD *)v15;
  do
  {
    for (i = 0; i != v7; ++i)
    {
      if (*(_QWORD *)v15 != v9)
        objc_enumerationMutation(a1);
      v11 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * i);
      if (v8)
      {
        while (!v11)
        {
LABEL_11:
          v8 = (void *)objc_msgSend_parentNode(v8, v4, v5, v6);
          if (!v8)
            return v8;
        }
        v12 = v11;
        while (v12 != v8)
        {
          v12 = (void *)objc_msgSend_parentNode(v12, v4, v5, v6);
          if (!v12)
            goto LABEL_11;
        }
      }
      else
      {
        v8 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * i);
      }
    }
    v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v4, (uint64_t)&v14, (uint64_t)v18, 16);
  }
  while (v7);
  return v8;
}

double sub_1B18E6B80(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  void *v19;
  _QWORD *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  double result;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;

  v12 = objc_msgSend_skinnerRef(*(void **)(a1 + 32), a2, a3, a4);
  v13 = *(void **)(a1 + 40);
  if (!v13)
    goto LABEL_10;
  v14 = objc_msgSend_nodeRef(v13, v5, v6, v7);
  v18 = sub_1B18E49C0(v12, v14);
  v19 = *(void **)(a1 + 40);
  if ((v18 & 1) == 0)
  {
    if (v19)
    {
      v32 = (_QWORD *)objc_msgSend_nodeRef(v19, v15, v16, v17);
      v33 = v12;
      return sub_1B18E4528(v33, v32, v6, v7, v8, v9, v10, v11);
    }
    sub_1B18E45B0(v12, 0);
LABEL_10:
    v33 = v12;
    v32 = 0;
    return sub_1B18E4528(v33, v32, v6, v7, v8, v9, v10, v11);
  }
  v20 = (_QWORD *)objc_msgSend_nodeRef(v19, v15, v16, v17);
  if ((sub_1B18E4790(v12, v20) & 1) == 0)
  {
    v25 = (_QWORD *)objc_msgSend_nodeRef(*(void **)(a1 + 40), v21, v22, v23);
    if (!sub_1B18E4A18(v12, v25))
      sub_1B17C4408(0, (uint64_t)CFSTR("Warning: Failed to transpose skeleton\nold skeleton: %@\nnew skeleton: %@"), v26, v27, v28, v29, v30, v31, *(_QWORD *)(a1 + 48));
  }
  return result;
}

uint64_t sub_1B18E8ACC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

void sub_1B18E8AD4(void *a1, int a2)
{
  if (*((unsigned __int8 *)a1 + 64) != a2)
  {
    *((_BYTE *)a1 + 64) = a2;
    sub_1B18E8AEC(a1);
  }
}

void sub_1B18E8AEC(void *a1)
{
  const __CFDictionary *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  void *values;

  values = a1;
  v1 = CFDictionaryCreate(0, (const void **)&off_1E63D5988, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v9 = (const void *)sub_1B17C6244(values, v2, v3, v4, v5, v6, v7, v8);
  sub_1B194F874(CFSTR("kCFXNotificationEngineContextInvalidatePasses"), v9, v1, 1u);
  CFRelease(v1);
}

uint64_t sub_1B18E8B6C()
{
  if (qword_1ED4CEB10 != -1)
    dispatch_once(&qword_1ED4CEB10, &unk_1E63D1050);
  return qword_1ED4CEB18;
}

void sub_1B18E8BAC()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (!qword_1ED4CEB18)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEB18);
    qword_1ED4CEB18 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("fStop"), 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("apertureBladeCount"), 0x58u, 2, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("focalBlurSampleCount"), 0x50u, 2, 0, 0, 0, v6, v7);
    sub_1B19C3258();
  }
}

float sub_1B18E8CD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 72);
}

void sub_1B18E8D1C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 72) = a2;
}

uint64_t sub_1B18E8D70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(_QWORD *)(a1 + 80);
}

void sub_1B18E8DB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  *(_QWORD *)(a1 + 80) = a2;
}

uint64_t sub_1B18E8E04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(_QWORD *)(a1 + 88);
}

void sub_1B18E8E4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  *(_QWORD *)(a1 + 88) = a2;
}

uint64_t sub_1B18E8E98()
{
  if (qword_1ED4CEB60 != -1)
    dispatch_once(&qword_1ED4CEB60, &unk_1E63D1AD0);
  return qword_1ED4CEB68;
}

double sub_1B18E8ED8()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  double result;

  if (!qword_1ED4CEB68)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEB68);
    qword_1ED4CEB68 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("intensity"), 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B19C3258();
    *(_QWORD *)&result = 0x1B18EC2E4;
    xmmword_1ED4AE2C0 = xmmword_1E63D2EA0;
  }
  return result;
}

void sub_1B18E8FC4(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  float v11;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  v11 = a1[18];
  if (v11 != a2)
  {
    a1[18] = a2;
    if (a2 == 0.0 || v11 == 0.0)
      sub_1B18E8AEC(a1);
  }
}

uint64_t sub_1B18E904C()
{
  if (qword_1ED4CEB40 != -1)
    dispatch_once(&qword_1ED4CEB40, &unk_1E63D1B90);
  return qword_1ED4CEB48;
}

double sub_1B18E908C()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double result;

  if (!qword_1ED4CEB48)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEB48);
    qword_1ED4CEB48 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("intensity"), 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("scale"), 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("slice"), 0x50u, 1, 0, 0, 0, v6, v7);
    sub_1B19C326C(CFSTR("isColored"), 0x54u, 3, 0, 0, 0, v8, v9);
    sub_1B19C3258();
    *(_QWORD *)&result = 0x1B18EC3B4;
    xmmword_1ED4AE110 = xmmword_1E63D2E80;
  }
  return result;
}

float sub_1B18E91D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 76);
}

void sub_1B18E9220(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 76) = a2;
}

uint64_t sub_1B18E9274(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(unsigned __int8 *)(a1 + 84);
}

void sub_1B18E92BC(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  *(_BYTE *)(a1 + 84) = a2;
}

float sub_1B18E9308(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 80);
}

void sub_1B18E9350(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 80) = a2;
}

uint64_t sub_1B18E93A4()
{
  if (qword_1ED4CEB30 != -1)
    dispatch_once(&qword_1ED4CEB30, &unk_1E63D1BD0);
  return qword_1ED4CEB38;
}

double sub_1B18E93E4()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double result;

  if (!qword_1ED4CEB38)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEB38);
    qword_1ED4CEB38 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("value"), 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("offset"), 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("averageGray"), 0x50u, 1, 0, 0, 0, v6, v7);
    sub_1B19C326C(CFSTR("whitePoint"), 0x54u, 1, 0, 0, 0, v8, v9);
    sub_1B19C326C(CFSTR("adaptationBrighteningSpeedFactor"), 0x58u, 1, 0, 0, 0, v10, v11);
    sub_1B19C326C(CFSTR("adaptationDarkeningSpeedFactor"), 0x5Cu, 1, 0, 0, 0, v12, v13);
    sub_1B19C326C(CFSTR("adaptationMinimum"), 0x60u, 1, 0, 0, 0, v14, v15);
    sub_1B19C326C(CFSTR("adaptationMaximum"), 0x64u, 1, 0, 0, 0, v16, v17);
    sub_1B19C326C(CFSTR("wantsAdaptation"), 0x68u, 3, 0, 0, 0, v18, v19);
    sub_1B19C3258();
    *(_QWORD *)&result = 0x1B18EC458;
    xmmword_1ED4AE038 = xmmword_1E63D2E70;
  }
  return result;
}

float sub_1B18E95E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 84);
}

void sub_1B18E962C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 84) = a2;
}

float sub_1B18E9680(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 88);
}

void sub_1B18E96C8(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 88) = a2;
}

float sub_1B18E971C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 92);
}

void sub_1B18E9764(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 92) = a2;
}

float sub_1B18E97B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 96);
}

void sub_1B18E9800(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 96) = a2;
}

float sub_1B18E9854(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 100);
}

void sub_1B18E989C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 100) = a2;
}

uint64_t sub_1B18E98F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(unsigned __int8 *)(a1 + 104);
}

void sub_1B18E9938(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  *(_BYTE *)(a1 + 104) = a2;
}

uint64_t sub_1B18E9984()
{
  if (qword_1ED4CEB70 != -1)
    dispatch_once(&qword_1ED4CEB70, &unk_1E63D1510);
  return qword_1ED4CEB78;
}

void sub_1B18E99C4()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (!qword_1ED4CEB78)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEB78);
    qword_1ED4CEB78 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("toeStrength"), 0xB4u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("toeLength"), 0xB8u, 1, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("shoulderStrength"), 0xBCu, 1, 0, 0, 0, v6, v7);
    sub_1B19C326C(CFSTR("shoulderLength"), 0xC0u, 1, 0, 0, 0, v8, v9);
    sub_1B19C326C(CFSTR("shoulderAngle"), 0xC4u, 1, 0, 0, 0, v10, v11);
    sub_1B19C326C(CFSTR("gamma"), 0xC8u, 1, 0, 0, 0, v12, v13);
    sub_1B19C3258();
  }
}

uint64_t sub_1B18E9B68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(unsigned __int8 *)(a1 + 176);
}

void sub_1B18E9BB0(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  *(_BYTE *)(a1 + 176) = a2;
  *(_BYTE *)(a1 + 72) = 0;
}

float sub_1B18E9C00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 180);
}

void sub_1B18E9C48(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 180) = a2;
  *(_BYTE *)(a1 + 72) = 0;
}

float sub_1B18E9CA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 184);
}

void sub_1B18E9CE8(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 184) = a2;
  *(_BYTE *)(a1 + 72) = 0;
}

float sub_1B18E9D40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 188);
}

void sub_1B18E9D88(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 188) = a2;
  *(_BYTE *)(a1 + 72) = 0;
}

float sub_1B18E9DE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 192);
}

void sub_1B18E9E28(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 192) = a2;
  *(_BYTE *)(a1 + 72) = 0;
}

float sub_1B18E9E80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 196);
}

void sub_1B18E9EC8(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 196) = a2;
  *(_BYTE *)(a1 + 72) = 0;
}

float sub_1B18E9F20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 200);
}

void sub_1B18E9F68(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 200) = a2;
  *(_BYTE *)(a1 + 72) = 0;
}

void sub_1B18E9FC0(uint64_t a1, float a2)
{
  float v2;
  unsigned int v3;
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;

  if (*(_BYTE *)(a1 + 176) != 1 && !*(_BYTE *)(a1 + 176))
  {
    v2 = *(float *)(a1 + 92) * a2;
    if (v2 >= *(float *)(a1 + 76))
    {
      v3 = 2;
      if (v2 < *(float *)(a1 + 80))
        v3 = 1;
    }
    else
    {
      v3 = 0;
    }
    v4 = a1 + 24 * v3;
    v6 = *(float *)(v4 + 104);
    v5 = (float *)(v4 + 104);
    v7 = (float)(v2 - v6) * v5[2];
    if (v7 > 0.0)
    {
      v9 = v5[4];
      v8 = v5[5];
      v10 = logf(v7);
      expf(v9 + (float)(v8 * v10));
    }
  }
}

double sub_1B18EA0A0@<D0>(uint64_t a1@<X8>)
{
  double result;

  *(_QWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = xmmword_1B2247EF0;
  *(_DWORD *)(a1 + 16) = 1065353216;
  result = 0.0;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_QWORD *)(a1 + 92) = 0;
  return result;
}

__n128 sub_1B18EA0D4@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  uint64_t v43;
  float v44;
  uint64_t v45;
  __n128 result;
  __int128 v47;
  __int128 v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a2, a3, a4, a5, a6, a7, (uint64_t)"effect");
  if (!*(_BYTE *)(a1 + 72))
  {
    *(_BYTE *)(a1 + 72) = 1;
    v10 = fminf(fmaxf(*(float *)(a1 + 180), -1.0), 1.0);
    v11 = powf(fminf(fmaxf(*(float *)(a1 + 184), 0.0), 1.0), 2.2);
    v12 = fmaxf(*(float *)(a1 + 188), 0.0);
    v13 = fmaxf(*(float *)(a1 + 196), 0.0);
    v14 = fmaxf(*(float *)(a1 + 200), 0.1);
    v15 = v11 * 0.5;
    v16 = (float)(1.0 - v10) * (float)(v11 * 0.5);
    v17 = (float)(1.0 - fminf(fmaxf(*(float *)(a1 + 192), 0.0), 1.0)) * (float)(1.0 - v16);
    v58 = (float)(v11 * 0.5) + v17;
    v18 = v16 + v17;
    v19 = (float)(exp2f(v12) + (float)((float)(v11 * 0.5) + (float)(1.0 - v16))) + -1.0;
    v20 = v12 * (float)(v13 * (float)(v19 + v19));
    v54 = v12 * (float)(v13 * 0.5);
    v21 = v15 * (float)(1.0 / v19);
    v59 = v58 * (float)(1.0 / v19);
    v22 = 1.0;
    if ((float)(v59 - v21) != 0.0)
      v22 = (float)(v18 - v16) / (float)(v59 - v21);
    v56 = 1.0 / v19;
    v57 = (float)(1.0 / v19) * v20;
    v23 = logf(v22);
    *(float *)(a1 + 128) = (float)-(float)(v16 + (float)((float)-v22 * v21)) / v22;
    *(_QWORD *)(a1 + 132) = 0x3F80000000000000;
    *(_DWORD *)(a1 + 140) = 1065353216;
    *(float *)(a1 + 144) = v14 * v23;
    *(float *)(a1 + 148) = v14;
    v51 = v16 - (float)(v22 * v21);
    v49 = v14 + -1.0;
    v50 = v14 * v22;
    v24 = (float)(v14 * v22) * powf(v51 + (float)(v22 * v21), v14 + -1.0);
    v25 = fmaxf(powf(v16, v14), 0.00000011921);
    v26 = fmaxf(powf(v18, v14), 0.00000011921);
    v27 = powf(v54 + 1.0, v14) + -1.0;
    v28 = (float)(v21 * v24) / v25;
    v55 = v25;
    v29 = logf(v25);
    v30 = logf(v21);
    *(_OWORD *)(a1 + 104) = xmmword_1B2244E10;
    *(float *)(a1 + 120) = v29 - (float)(v28 * v30);
    *(float *)(a1 + 124) = v28;
    v52 = v27;
    v53 = v26;
    v31 = v27 + 1.0;
    v32 = (float)(v27 + 1.0) - v26;
    v33 = 0.0;
    v34 = 0.0;
    v35 = 0.0;
    v36 = 0.0;
    if (v32 > 0.0)
    {
      v37 = powf(v51 + (float)(v22 * v59), v49);
      v36 = v57 + 1.0;
      v38 = (float)(v57 + 1.0) - v59;
      v35 = (float)(v38 * (float)(v50 * v37)) / v32;
      v39 = logf(v32);
      v34 = v39 - (float)(v35 * logf(v38));
      v33 = -1.0;
    }
    *(float *)(a1 + 152) = v36;
    *(float *)(a1 + 156) = v31;
    *(float *)(a1 + 160) = v33;
    *(float *)(a1 + 164) = v33;
    *(float *)(a1 + 168) = v34;
    *(float *)(a1 + 172) = v35;
    v40 = (1.0 - v36) * v33;
    v41 = 0.0;
    if (v40 > 0.0)
    {
      v42 = logf(v40);
      v41 = expf(v34 + (float)(v35 * v42));
    }
    v43 = 0;
    v44 = 1.0 / (float)(v52 + (float)((float)(v41 * v33) + 1.0));
    do
    {
      v45 = a1 + v43;
      *(float *)(v45 + 108) = v44 * *(float *)(a1 + v43 + 108);
      *(float *)(v45 + 116) = v44 * *(float *)(a1 + v43 + 116);
      v43 += 24;
    }
    while (v43 != 72);
    *(float *)(a1 + 76) = v21;
    *(float *)(a1 + 80) = v59;
    *(float *)(a1 + 84) = v55;
    *(float *)(a1 + 88) = v53;
    *(float *)(a1 + 92) = v56;
    *(float *)(a1 + 96) = v57;
    *(float *)(a1 + 100) = v57;
  }
  result = *(__n128 *)(a1 + 124);
  v47 = *(_OWORD *)(a1 + 156);
  *(_OWORD *)(a8 + 64) = *(_OWORD *)(a1 + 140);
  *(_OWORD *)(a8 + 80) = v47;
  *(_DWORD *)(a8 + 96) = *(_DWORD *)(a1 + 172);
  v48 = *(_OWORD *)(a1 + 92);
  *(_OWORD *)a8 = *(_OWORD *)(a1 + 76);
  *(_OWORD *)(a8 + 16) = v48;
  *(_OWORD *)(a8 + 32) = *(_OWORD *)(a1 + 108);
  *(__n128 *)(a8 + 48) = result;
  return result;
}

uint64_t sub_1B18EA440()
{
  if (qword_1ED4CEAD0 != -1)
    dispatch_once(&qword_1ED4CEAD0, &unk_1E63D8C70);
  return qword_1ED4CEAD8;
}

double sub_1B18EA480()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double result;

  if (!qword_1ED4CEAD8)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEAD8);
    qword_1ED4CEAD8 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("intensity"), 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("threshold"), 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("thresholdSmoothness"), 0x50u, 1, 0, 0, 0, v6, v7);
    sub_1B19C326C(CFSTR("useHighQuality"), 0x54u, 3, 0, 0, 0, v8, v9);
    sub_1B19C326C(CFSTR("colorFilter"), 0x60u, 8, 0, 0, 0, v10, v11);
    sub_1B19C326C(CFSTR("contrast"), 0x70u, 1, 0, 0, 0, v12, v13);
    sub_1B19C326C(CFSTR("saturation"), 0x74u, 1, 0, 0, 0, v14, v15);
    sub_1B19C326C(CFSTR("iterationCount"), 0x78u, 2, 0, 0, 0, v16, v17);
    sub_1B19C3258();
    *(_QWORD *)&result = 0x1B18EC57CLL;
    xmmword_1ED4ADB28 = xmmword_1E63D2E30;
  }
  return result;
}

__n128 sub_1B18EA670(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return a1[6];
}

void sub_1B18EA6B8(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __n128 v10;

  if (!a1)
  {
    v10 = a2;
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
    a2 = v10;
  }
  a1[6] = a2;
}

float sub_1B18EA708(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 112);
}

void sub_1B18EA750(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 112) = a2;
}

float sub_1B18EA7A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 116);
}

void sub_1B18EA7EC(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 116) = a2;
}

uint64_t sub_1B18EA840(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(_QWORD *)(a1 + 120);
}

void sub_1B18EA888(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  if (a1[15] != a2)
  {
    a1[15] = a2;
    sub_1B18E8AEC(a1);
  }
}

uint64_t sub_1B18EA8F4()
{
  if (qword_1ED4CEB00 != -1)
    dispatch_once(&qword_1ED4CEB00, &unk_1E63D15D0);
  return qword_1ED4CEB08;
}

void sub_1B18EA934()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if (!qword_1ED4CEB08)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEB08);
    qword_1ED4CEB08 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("saturation"), 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("contrast"), 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("whiteBalanceTemperature"), 0x50u, 1, 0, 0, 0, v6, v7);
    sub_1B19C326C(CFSTR("whiteBalanceTint"), 0x54u, 1, 0, 0, 0, v8, v9);
    sub_1B19C326C(CFSTR("liftColor"), 0x60u, 8, 0, 0, 0, v10, v11);
    sub_1B19C326C(CFSTR("liftOffset"), 0x70u, 1, 0, 0, 0, v12, v13);
    sub_1B19C326C(CFSTR("gammaColor"), 0x80u, 8, 0, 0, 0, v14, v15);
    sub_1B19C326C(CFSTR("gammaOffset"), 0x90u, 1, 0, 0, 0, v16, v17);
    sub_1B19C326C(CFSTR("gainColor"), 0xA0u, 8, 0, 0, 0, v18, v19);
    sub_1B19C326C(CFSTR("gainOffset"), 0xB0u, 1, 0, 0, 0, v20, v21);
    sub_1B19C326C(CFSTR("lookupTable"), 0xB8u, 5, 1, 0, 0, v22, v23);
    sub_1B19C3258();
  }
}

__n128 sub_1B18EAB6C(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return a1[8];
}

void sub_1B18EABB4(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __n128 v10;

  if (!a1)
  {
    v10 = a2;
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
    a2 = v10;
  }
  a1[8] = a2;
}

float sub_1B18EAC04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 144);
}

void sub_1B18EAC4C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 144) = a2;
}

__n128 sub_1B18EACA0(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return a1[10];
}

void sub_1B18EACE8(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __n128 v10;

  if (!a1)
  {
    v10 = a2;
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
    a2 = v10;
  }
  a1[10] = a2;
}

float sub_1B18EAD38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(float *)(a1 + 176);
}

void sub_1B18EAD80(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 176) = a2;
}

uint64_t sub_1B18EADD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(_QWORD *)(a1 + 184);
}

void sub_1B18EAE1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  *(_QWORD *)(a1 + 184) = a2;
}

uint64_t sub_1B18EAE68()
{
  if (qword_1ED4CEB80 != -1)
    dispatch_once(&qword_1ED4CEB80, &unk_1E63D1630);
  return qword_1ED4CEB88;
}

double sub_1B18EAEA8()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double result;

  if (!qword_1ED4CEB88)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEB88);
    qword_1ED4CEB88 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("intensity"), 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("anamorphic"), 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("softness"), 0x50u, 1, 0, 0, 0, v6, v7);
    sub_1B19C326C(CFSTR("radius"), 0x54u, 1, 0, 0, 0, v8, v9);
    sub_1B19C3258();
    *(_QWORD *)&result = 0x1B18EC6A0;
    xmmword_1ED4AE548 = xmmword_1E63D2EB0;
  }
  return result;
}

uint64_t sub_1B18EAFF8()
{
  if (qword_1ED4CEAF0 != -1)
    dispatch_once(&qword_1ED4CEAF0, &unk_1E63D16D0);
  return qword_1ED4CEAF8;
}

double sub_1B18EB038()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double result;

  if (!qword_1ED4CEAF8)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEAF8);
    qword_1ED4CEAF8 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("intensity"), 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("strength"), 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B19C3258();
    *(_QWORD *)&result = 0x1B18EC744;
    xmmword_1ED4ADCD8 = xmmword_1E63D2E50;
  }
  return result;
}

void sub_1B18EB144(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  float v11;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  v11 = a1[19];
  if (v11 != a2)
  {
    a1[19] = a2;
    if (a2 == 0.0 || v11 == 0.0)
      sub_1B18E8AEC(a1);
  }
}

uint64_t sub_1B18EB1CC()
{
  if (qword_1ED4CEB50 != -1)
    dispatch_once(&qword_1ED4CEB50, &unk_1E63D1750);
  return qword_1ED4CEB58;
}

double sub_1B18EB20C()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double result;

  if (!qword_1ED4CEB58)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEB58);
    qword_1ED4CEB58 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("radius"), 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("filterQuality"), 0x4Cu, 15, 0, 0, 0, v4, v5);
    sub_1B19C3258();
    *(_QWORD *)&result = 0x1B18EC7E8;
    xmmword_1ED4AE1E8 = xmmword_1E63D2E90;
  }
  return result;
}

void sub_1B18EB31C(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  if (a1[18] != a2)
  {
    a1[18] = a2;
    sub_1B18E8AEC(a1);
  }
}

uint64_t sub_1B18EB394(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(unsigned __int8 *)(a1 + 76);
}

void sub_1B18EB3DC(_BYTE *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  if (a1[76] != a2)
  {
    a1[76] = a2;
    sub_1B18E8AEC(a1);
  }
}

uint64_t sub_1B18EB448()
{
  if (qword_1ED4CEAE0 != -1)
    dispatch_once(&qword_1ED4CEAE0, &unk_1E63D17B0);
  return qword_1ED4CEAE8;
}

double sub_1B18EB488()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double result;

  if (!qword_1ED4CEAE8)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEAE8);
    qword_1ED4CEAE8 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("sampleCount"), 0x48u, 2, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("intensity"), 0x50u, 1, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("center"), 0x58u, 7, 0, 0, 0, v6, v7);
    sub_1B19C326C(CFSTR("fromZ"), 0x60u, 1, 0, 0, 0, v8, v9);
    sub_1B19C326C(CFSTR("fromAngle"), 0x64u, 1, 0, 0, 0, v10, v11);
    sub_1B19C326C(CFSTR("fromShift"), 0x68u, 7, 0, 0, 0, v12, v13);
    sub_1B19C326C(CFSTR("toZ"), 0x70u, 1, 0, 0, 0, v14, v15);
    sub_1B19C326C(CFSTR("toAngle"), 0x74u, 1, 0, 0, 0, v16, v17);
    sub_1B19C326C(CFSTR("toShift"), 0x78u, 7, 0, 0, 0, v18, v19);
    sub_1B19C326C(CFSTR("color1"), 0x80u, 8, 0, 0, 0, v20, v21);
    sub_1B19C326C(CFSTR("color2"), 0x90u, 8, 0, 0, 0, v22, v23);
    sub_1B19C326C(CFSTR("color3"), 0xA0u, 8, 0, 0, 0, v24, v25);
    sub_1B19C326C(CFSTR("maskCenter"), 0xB0u, 7, 0, 0, 0, v26, v27);
    sub_1B19C326C(CFSTR("maskRadius"), 0xB8u, 1, 0, 0, 0, v28, v29);
    sub_1B19C326C(CFSTR("maskEnabled"), 0xBCu, 3, 0, 0, 0, v30, v31);
    sub_1B19C326C(CFSTR("unMultBlending"), 0xC0u, 1, 0, 0, 0, v32, v33);
    sub_1B19C3258();
    *(_QWORD *)&result = 0x1B18EC88CLL;
    xmmword_1ED4ADC00 = xmmword_1E63D2E40;
  }
  return result;
}

uint64_t sub_1B18EB7AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(_QWORD *)(a1 + 72);
}

void sub_1B18EB7F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  *(_QWORD *)(a1 + 72) = a2;
}

void sub_1B18EB840(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  float v11;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  v11 = a1[20];
  if (v11 != a2)
  {
    a1[20] = a2;
    if (a2 == 0.0 || v11 == 0.0)
      sub_1B18E8AEC(a1);
  }
}

double sub_1B18EB8C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(double *)(a1 + 88);
}

void sub_1B18EB910(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(double *)(a1 + 88) = a2;
}

double sub_1B18EB964(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(double *)(a1 + 104);
}

void sub_1B18EB9AC(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(double *)(a1 + 104) = a2;
}

double sub_1B18EBA00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(double *)(a1 + 120);
}

void sub_1B18EBA48(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(double *)(a1 + 120) = a2;
}

__n128 sub_1B18EBA9C(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return a1[9];
}

void sub_1B18EBAE4(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __n128 v10;

  if (!a1)
  {
    v10 = a2;
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
    a2 = v10;
  }
  a1[9] = a2;
}

double sub_1B18EBB34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(double *)(a1 + 176);
}

void sub_1B18EBB7C(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(double *)(a1 + 176) = a2;
}

void sub_1B18EBBD0(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 184) = a2;
}

uint64_t sub_1B18EBC24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(unsigned __int8 *)(a1 + 188);
}

void sub_1B18EBC6C(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  *(_BYTE *)(a1 + 188) = a2;
}

void sub_1B18EBCB8(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(float *)(a1 + 192) = a2;
}

uint64_t sub_1B18EBD0C()
{
  if (qword_1ED4CEB20 != -1)
    dispatch_once(&qword_1ED4CEB20, &unk_1E63D1830);
  return qword_1ED4CEB28;
}

double sub_1B18EBD4C()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double result;

  if (!qword_1ED4CEB28)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEB28);
    qword_1ED4CEB28 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("radius"), 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("maskCenter"), 0x50u, 7, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("maskRadius"), 0x58u, 1, 0, 0, 0, v6, v7);
    sub_1B19C326C(CFSTR("maskEnabled"), 0x5Cu, 3, 0, 0, 0, v8, v9);
    sub_1B19C3258();
    *(_QWORD *)&result = 0x1B18EC930;
    xmmword_1ED4ADF60 = xmmword_1E63D2E60;
  }
  return result;
}

double sub_1B18EBEA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(double *)(a1 + 80);
}

void sub_1B18EBEEC(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  *(double *)(a1 + 80) = a2;
}

uint64_t sub_1B18EBF40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  return *(unsigned __int8 *)(a1 + 92);
}

void sub_1B18EBF88(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  *(_BYTE *)(a1 + 92) = a2;
}

uint64_t sub_1B18EBFD4()
{
  if (qword_1EEF66188 != -1)
    dispatch_once(&qword_1EEF66188, &unk_1E63D18D0);
  return qword_1EEF66180;
}

void sub_1B18EC014()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;

  if (!qword_1EEF66180)
  {
    v0 = (void *)sub_1B179CB60(&qword_1EEF66180);
    qword_1EEF66180 = (uint64_t)v0;
    v1 = (const void *)sub_1B193E4C8();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("radius"), 0x4Cu, 1, 0, 0, 0, v2, v3);
    sub_1B19C3258();
  }
}

void sub_1B18EC0F4(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  if (a1[19] != a2)
  {
    a1[19] = a2;
    sub_1B18E8AEC(a1);
  }
}

void sub_1B18EC16C(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  if (a1[20] != a2)
  {
    a1[20] = a2;
    sub_1B18E8AEC(a1);
  }
}

CFStringRef sub_1B18EC1EC(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect depthOfField:%p"), a1);
}

CFStringRef sub_1B18EC228(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect depthOfField:%p"), a1);
}

CFStringRef sub_1B18EC26C(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect MotionBlur:%p"), a1);
}

CFStringRef sub_1B18EC2A8(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect MotionBlur:%p"), a1);
}

void sub_1B18EC2E4(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst)
    sub_1B18E8FC4(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  else
    memcpy(__dst, __src, __n);
}

id sub_1B18EC30C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;

  v9 = *(const void **)(a1 + 88);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 88) = 0;
  }
  return sub_1B193E38C(a1, a2, a3, a4, a5, a6, a7, a8);
}

CFStringRef sub_1B18EC33C(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect Grain:%p"), a1);
}

CFStringRef sub_1B18EC378(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect Grain:%p"), a1);
}

void sub_1B18EC3B4(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst)
    sub_1B18E8FC4(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  else
    memcpy(__dst, __src, __n);
}

CFStringRef sub_1B18EC3E0(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect Exposure:%p"), a1);
}

CFStringRef sub_1B18EC41C(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect Exposure:%p"), a1);
}

void sub_1B18EC458(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst)
    sub_1B18E8FC4(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  else
    memcpy(__dst, __src, __n);
}

CFStringRef sub_1B18EC484(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect ToneMapping:%p"), a1);
}

CFStringRef sub_1B18EC4C0(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect ToneMapping:%p"), a1);
}

CFStringRef sub_1B18EC504(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect Bloom:%p"), a1);
}

CFStringRef sub_1B18EC540(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect Bloom:%p"), a1);
}

void sub_1B18EC57C(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst)
    sub_1B18E8FC4(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  else
    memcpy(__dst, __src, __n);
}

CFStringRef sub_1B18EC5A8(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect ColorGrading:%p"), a1);
}

CFStringRef sub_1B18EC5E4(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect ColorGrading:%p"), a1);
}

CFStringRef sub_1B18EC628(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect Vignetting:%p"), a1);
}

CFStringRef sub_1B18EC664(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect Vignetting:%p"), a1);
}

void sub_1B18EC6A0(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst)
    sub_1B18E8FC4(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  else
    memcpy(__dst, __src, __n);
}

CFStringRef sub_1B18EC6CC(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect ColorFringe:%p"), a1);
}

CFStringRef sub_1B18EC708(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect ColorFringe:%p"), a1);
}

void sub_1B18EC744(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst)
    sub_1B18E8FC4(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  else
    memcpy(__dst, __src, __n);
}

CFStringRef sub_1B18EC770(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect LensBlur:%p"), a1);
}

CFStringRef sub_1B18EC7AC(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect LensBlur:%p"), a1);
}

void sub_1B18EC7E8(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst)
    sub_1B18EB31C(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  else
    memcpy(__dst, __src, __n);
}

CFStringRef sub_1B18EC814(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect ChromaticTransform:%p"), a1);
}

CFStringRef sub_1B18EC850(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect ChromaticTransform:%p"), a1);
}

void sub_1B18EC88C(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 20 == __dst)
    sub_1B18EB840(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  else
    memcpy(__dst, __src, __n);
}

CFStringRef sub_1B18EC8B8(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect DoughnutBokeh:%p"), a1);
}

CFStringRef sub_1B18EC8F4(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect DoughnutBokeh:%p"), a1);
}

void sub_1B18EC930(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst)
    sub_1B18E8FC4(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  else
    memcpy(__dst, __src, __n);
}

CFStringRef sub_1B18EC95C(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect SSAO:%p"), a1);
}

CFStringRef sub_1B18EC998(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXCameraEffect SSAO:%p"), a1);
}

uint64_t sub_1B18ECC28(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t result;
  const char *v10;
  uint64_t v11;

  v6 = (void *)objc_msgSend_semantic(a2, (const char *)a2, a3, a4);
  result = objc_msgSend_isEqualToString_(v6, v7, (uint64_t)CFSTR("kGeometrySourceSemanticNormal"), v8);
  if ((result & 1) == 0)
    return objc_msgSend_addObject_(*(void **)(a1 + 32), v10, (uint64_t)a2, v11);
  return result;
}

uint64_t sub_1B18ED794(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  float v5;
  float v6;
  unsigned int v7;

  v3 = a1[1];
  v4 = a1[2];
  v5 = *(float *)(*a1 + v3 + v4 * *a2);
  v6 = *(float *)(*a1 + v3 + v4 * *a3);
  if (v6 > v5)
    v7 = 1;
  else
    v7 = -1;
  if (v6 == v5)
    return 0;
  else
    return v7;
}

uint64_t sub_1B18ED9C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E63CF630;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_QWORD *)(a1 + 688) = 0;
  *(_QWORD *)(a1 + 728) = 0;
  *(_DWORD *)(a1 + 736) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_BYTE *)(a1 + 720) = 0;
  *(_QWORD *)(a1 + 16) = a2;
  v9 = sub_1B1813884(a2, a2, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)(a1 + 24) = v9;
  v17 = sub_1B187B1D0(v9, v10, v11, v12, v13, v14, v15, v16);
  *(_QWORD *)(a1 + 32) = v17;
  *(_WORD *)(a1 + 48) = 15;
  sub_1B19D7DD8(v17, 0xFu);
  return a1;
}

void sub_1B18EDA9C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;
  uint64_t v3;
  CFX::RG::Resource **v4;

  sub_1B181C064(v4, 0);
  sub_1B2227AE0(v3, v2, v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18EDAC4(uint64_t a1)
{
  uint64_t i;
  void *v3;
  void *v4;

  *(_QWORD *)a1 = &off_1E63CF630;
  sub_1B19D7E4C(*(int16x4_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 48));
  sub_1B181C064((CFX::RG::Resource **)(a1 + 728), 0);
  for (i = 712; i != 696; i -= 8)
  {
    v3 = *(void **)(a1 + i);
    if (v3)

  }
  v4 = *(void **)(a1 + 688);
  if (v4)

  return a1;
}

void sub_1B18EDB30(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B181C064((CFX::RG::Resource **)(v1 + 728), 0);
  sub_1B2227BE0(v1 + 720, v1 + 704, v1);
  _Unwind_Resume(a1);
}

void sub_1B18EDB5C(uint64_t a1)
{
  sub_1B18EDAC4(a1);
  JUMPOUT(0x1B5E22E18);
}

void sub_1B18EDB80(uint64_t a1, CFX::RG::RenderGraphContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BOOL8 v39;
  _BOOL8 v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  id v47;
  const char *v48;
  const char *v49;
  const char *v50;
  const char *v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  void *v55;
  unsigned __int16 *v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  void *v68;
  uint64_t v69;
  const char *v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  uint64_t v74;
  void *v75;
  uint64_t v76;
  void *v77;
  const char *v78;
  uint64_t v79;
  void *v80;
  uint64_t v81;
  __int16 v82;
  __int16 v83;
  CFX::RG::Resource *v84;
  _OWORD v85[5];
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  unsigned int v91;
  _BOOL4 v92;
  unsigned int v93;
  BOOL v94;
  char v95;
  const char *v96;

  v11 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 16), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v15 = (void *)objc_msgSend_resourceManager(v11, v12, v13, v14);
  v23 = sub_1B1813884(*(_QWORD *)(a1 + 16), v16, v17, v18, v19, v20, v21, v22);
  v31 = sub_1B1814768(*(uint64_t **)(a1 + 16), v24, v25, v26, v27, v28, v29, v30);
  if (v31 && sub_1B186CFA8((uint64_t)v31, v32, v33, v34, v35, v36, v37, v38))
  {
    v39 = sub_1B187B0F0(v23, 0) != 0;
    v94 = v39;
    v93 = sub_1B19DA3D0(*(_QWORD *)(a1 + 32));
    v40 = sub_1B19DA3E0(*(_QWORD *)(a1 + 32)) != 0;
    v91 = *(_DWORD *)(a3 + 172);
    v92 = v40;
    v41 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v93) ^ ((0x9DDFEA08EB382D69 * v93) >> 47));
    v42 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ v40)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ v40)));
    v43 = 0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47));
    v44 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v43 ^ ((0x9DDFEA08EB382D69 * (v43 ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * (v43 ^ v39)))) ^ ((0x9DDFEA08EB382D69 * (v43 ^ ((0x9DDFEA08EB382D69 * (v43 ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * (v43 ^ v39)))) >> 47));
    v45 = 0x9DDFEA08EB382D69
        * (v44 ^ ((0x9DDFEA08EB382D69 * (v44 ^ v91)) >> 47) ^ (0x9DDFEA08EB382D69 * (v44 ^ v91)));
    v46 = 0x9DDFEA08EB382D69 * (v45 ^ (v45 >> 47));
    if (*(_QWORD *)(a1 + 680) != v46)
    {
      *(_QWORD *)(a1 + 680) = v46;
      sub_1B19D9F28(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 16));
      v47 = objc_alloc_init(MEMORY[0x1E0CC6AA0]);
      objc_msgSend_setConstantValue_type_withName_(v47, v48, (uint64_t)&v93, 33, CFSTR("LightCount"));
      objc_msgSend_setConstantValue_type_withName_(v47, v49, (uint64_t)&v94, 53, CFSTR("has_IBL"));
      objc_msgSend_setConstantValue_type_withName_(v47, v50, (uint64_t)&v92, 33, CFSTR("raytracing_use_function_constant"));
      objc_msgSend_setConstantValue_type_withName_(v47, v51, (uint64_t)&v91, 33, CFSTR("quality_mode"));
      v52 = sub_1B19DA304(*(_QWORD *)(a1 + 32));
      v54 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_linkedFunctions_(v15, v53, (uint64_t)CFSTR("vfx_rt_clearcoat_trace"), (uint64_t)v47, v52);

      v55 = *(void **)(a1 + 688);
      if (v55 != (void *)v54)
      {
        if (v55)

        *(_QWORD *)(a1 + 688) = v54;
      }
      *(_DWORD *)(a1 + 588) = 0;
      sub_1B19DA290(*(_QWORD *)(a1 + 32));
    }
    v56 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(a2, *(const CFX::RG::Resource **)(a3 + 248));
    v60 = *v56;
    v61 = v56[1];
    v62 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v60) ^ ((0x9DDFEA08EB382D69 * v60) >> 47));
    v63 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ v61)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ v61)));
    v64 = 0x9DDFEA08EB382D69 * (v63 ^ (v63 >> 47));
    if (*(_QWORD *)(a1 + 696) != v64)
    {
      *(_QWORD *)(a1 + 696) = v64;
      v65 = v60 >> 1;
      v66 = v61 >> 1;
      v67 = (v61 >> 1) * (v60 >> 1);
      v68 = (void *)objc_msgSend_device(v11, v57, v58, v59);
      v69 = 96 * v67;
      v71 = objc_msgSend_newBufferWithLength_options_(v68, v70, v69, 32);
      v75 = *(void **)(a1 + 704);
      if (v75 != (void *)v71)
      {
        v76 = v71;
        if (v75)

        *(_QWORD *)(a1 + 704) = v76;
      }
      v77 = (void *)objc_msgSend_device(v11, v72, v73, v74);
      v79 = objc_msgSend_newBufferWithLength_options_(v77, v78, v69, 32);
      v80 = *(void **)(a1 + 712);
      if (v80 != (void *)v79)
      {
        v81 = v79;
        if (v80)

        *(_QWORD *)(a1 + 712) = v81;
      }
      *(_DWORD *)(a1 + 588) = 0;
      v89 = 0u;
      v90 = 0u;
      v87 = 0u;
      v88 = 0u;
      v86 = 0u;
      if (v65 <= 1)
        v82 = 1;
      else
        v82 = v65;
      if (v66 <= 1)
        v83 = 1;
      else
        v83 = v66;
      RGTextureDescriptorMake2D(v82, v83, 25, (uint64_t)&v86);
      CFX::RG::RenderGraphContext::currentBuilder(a2);
      v85[2] = v88;
      v85[3] = v89;
      v85[4] = v90;
      v85[0] = v86;
      v85[1] = v87;
      v96 = "distanceTex";
      v95 = 2;
      sub_1B1825D28((uint64_t *)&v96, (uint64_t)v85, &v95);
      sub_1B181C064((CFX::RG::Resource **)(a1 + 728), v84);
    }
    *(_BYTE *)(a1 + 720) ^= 1u;
  }
}

uint64_t sub_1B18EDEE4(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  CFX::CrossFrameResourceManager *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38[2];

  v8 = *(_QWORD *)a5;
  v38[0] = (uint64_t)"RTClearCoatTracePass";
  v38[1] = v8;
  LOBYTE(v8) = atomic_load((unsigned __int8 *)&qword_1EEF66198);
  if ((v8 & 1) == 0)
  {
    v37 = a3;
    v35 = a2;
    v36 = __cxa_guard_acquire(&qword_1EEF66198);
    a2 = v35;
    a3 = v37;
    if (v36)
    {
      qword_1EEF66190 = (uint64_t)sub_1B18EF9E0("RT_CLEARCOAT_TRACE", 0x12u);
      __cxa_guard_release(&qword_1EEF66198);
      a2 = v35;
      a3 = v37;
    }
  }
  sub_1B18F7354(a1, a2, a3, v38, qword_1EEF66190, 0);
  *(_QWORD *)a1 = &off_1E63CF650;
  *(_QWORD *)(a1 + 376) = a5;
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 400) = 0;
  v16 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 368), v9, v10, v11, v12, v13, v14, v15);
  *(_QWORD *)(a1 + 392) = v16;
  *(_QWORD *)(a1 + 400) = objc_msgSend_resourceManager(v16, v17, v18, v19);
  v20 = a4[4];
  v21 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v22 = CFX::CrossFrameResourceManager::get(v20, v21);
  v28 = (uint64_t *)(a1 + 384);
  *(_QWORD *)(a1 + 384) = v22;
  if (!v22)
  {
    v29 = (uint64_t)a4[4];
    v30 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
    v38[0] = *(_QWORD *)(a1 + 368);
    v31 = sub_1B18EE0AC(v29, v30, v38);
    *(_QWORD *)(a1 + 384) = v31;
    *(_DWORD *)(v31 + 588) = 0;
    v32 = sub_1B17928F4(*(void **)(a1 + 392), a4[4]);
    v22 = *v28;
    *(_QWORD *)(*v28 + 672) = v32;
  }
  sub_1B18EDB80(v22, (CFX::RG::RenderGraphContext *)a4, a5, v23, v24, v25, v26, v27);
  v33 = *(_QWORD *)(a1 + 384);
  *(_QWORD *)(*(_QWORD *)(a1 + 376) + 312) = v33 + 64;
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(v33 + 728));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(*(_QWORD *)(a1 + 384) + 728));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(_QWORD *)(a1 + 376) + 264));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a5 + 248));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a5 + 176));
  return a1;
}

void sub_1B18EE094(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18EE0AC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v6 = operator new();
  sub_1B18ED9C8(v6, *a3, v7, v8, v9, v10, v11, v12);
  CFX::CrossFrameResourceManager::set(a1, a2, v6);
  return v6;
}

void sub_1B18EE110(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E22E18](v1, 0x10A1C40D943C058);
  _Unwind_Resume(a1);
}

void sub_1B18EE138(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __int128 *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  id Texture;
  id v56;
  id v57;
  id v58;
  id v59;
  const CFX::RG::Resource *v60;
  id v61;
  id v62;
  const char *v63;
  const char *v64;
  const char *v65;
  const char *v66;
  const char *v67;
  const char *v68;
  const char *v69;
  uint64_t v70;
  const char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  const char *v75;
  _OWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int8 *v83;
  uint64_t v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  _OWORD *v88;
  float32x4_t *v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  _OWORD *v100;
  const char *v101;
  uint64_t v102;
  uint64_t v103;
  const char *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  float v115;
  uint64_t v116;
  const char *v117;
  const char *v118;
  const char *v119;
  uint64_t v120;
  const char *v121;
  uint64_t v122;
  uint64_t v123;
  const char *v124;
  uint64_t v125;
  const char *v126;
  uint64_t v127;
  const char *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  void *v137;
  void *v138;
  const char *v139;
  uint64_t v140;
  const char *v141;
  uint64_t v142;
  uint64_t v143;
  unsigned int v144;
  const char *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  const char *v155;
  uint64_t v156;
  const char *v157;
  uint64_t v158;
  uint64_t v159;
  unint64_t v160;
  const char *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  unint64_t v170;
  uint64_t v171;
  uint64_t v172;
  void *v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  uint64_t v178;
  uint64_t v179;
  float32x2_t v180;
  _QWORD v181[3];
  __n128 v182;
  unsigned __int8 v183[176];
  float32x4_t v184[4];
  _OWORD v185[5];

  if (*(_QWORD *)(*(_QWORD *)(a1 + 384) + 688))
  {
    v10 = *a3;
    v11 = sub_1B1813884(*(_QWORD *)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    v19 = sub_1B1814768(*(uint64_t **)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
    if (v19)
    {
      if (sub_1B186CFA8((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26))
      {
        v34 = sub_1B1814768(*(uint64_t **)(a1 + 368), v27, v28, v29, v30, v31, v32, v33);
        sub_1B17B33F4((uint64_t)v34, (uint64_t)v183, v35, v36, v37, v38, v39, v40);
        v41 = (__int128 *)sub_1B1815A5C(*(_QWORD *)(a1 + 368), 1);
        v176 = v41[1];
        v177 = *v41;
        v174 = v41[3];
        v175 = v41[2];
        v182 = sub_1B181537C(*(_QWORD *)(a1 + 368), 0, v42, v43, v44, v45, v46, v47);
        v179 = sub_1B187B1D0(v11, v48, v49, v50, v51, v52, v53, v54);
        sub_1B19D9F28(v179, *(_QWORD *)(a1 + 368));
        Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 376) + 256));
        v56 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 376) + 248));
        v57 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 376) + 272));
        v58 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 376) + 176));
        v59 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 376) + 264));
        v60 = *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 376) + 280);
        v178 = v11;
        if (v60)
          v61 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v60);
        else
          v61 = 0;
        v62 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 384) + 728));
        objc_msgSend_setTexture_atIndex_(v10, v63, (uint64_t)Texture, 0);
        objc_msgSend_setTexture_atIndex_(v10, v64, (uint64_t)v56, 1);
        objc_msgSend_setTexture_atIndex_(v10, v65, (uint64_t)v57, 2);
        objc_msgSend_setTexture_atIndex_(v10, v66, (uint64_t)v58, 3);
        objc_msgSend_setTexture_atIndex_(v10, v67, (uint64_t)v59, 4);
        objc_msgSend_setTexture_atIndex_(v10, v68, (uint64_t)v62, 7);
        objc_msgSend_setTexture_atIndex_(v10, v69, (uint64_t)v61, 10);
        v70 = sub_1B187B0F0(v178, 0);
        if (v70)
        {
          v74 = objc_msgSend_textureForMaterialProperty_(*(void **)(a1 + 392), v71, v70, v73);
          if (v74)
            objc_msgSend_setTexture_atIndex_(v10, v75, v74, 6);
        }
        v180 = sub_1B1816010(**(float32x2_t ***)(a1 + 376), 0, v72, v73);
        v76 = *(_OWORD **)(*(_QWORD *)(a1 + 376) + 312);
        v76[8] = v177;
        v76[9] = v176;
        v76[10] = v175;
        v76[11] = v174;
        v83 = sub_1B18667B4(v183, (uint64_t)&v182, v77, v78, v79, v80, v81, v82);
        v84 = 0;
        v85 = *((_OWORD *)v83 + 1);
        v86 = *((_OWORD *)v83 + 2);
        v87 = *((_OWORD *)v83 + 3);
        v88 = *(_OWORD **)(*(_QWORD *)(a1 + 376) + 312);
        v88[20] = *(_OWORD *)v83;
        v88[21] = v85;
        v88[22] = v86;
        v88[23] = v87;
        v89 = *(float32x4_t **)(a1 + 384);
        v90 = v89[24];
        v91 = v89[25];
        v92 = v89[26];
        v93 = v89[27];
        v94 = v89[13];
        v95 = v89[14];
        v96 = v89[15];
        v184[0] = v89[12];
        v184[1] = v94;
        v184[2] = v95;
        v184[3] = v96;
        do
        {
          v185[v84] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v90, COERCE_FLOAT(*(_OWORD *)&v184[v84])), v91, *(float32x2_t *)v184[v84].f32, 1), v92, v184[v84], 2), v93, v184[v84], 3);
          ++v84;
        }
        while (v84 != 4);
        v97 = v185[1];
        v98 = v185[2];
        v99 = v185[3];
        v100 = *(_OWORD **)(*(_QWORD *)(a1 + 376) + 312);
        *v100 = v185[0];
        v100[1] = v97;
        v100[2] = v98;
        v100[3] = v99;
        *(simd_float4x4 *)(*(_QWORD *)(*(_QWORD *)(a1 + 376) + 312) + 192) = __invert_f4(*(simd_float4x4 *)(*(_QWORD *)(a1 + 384) + 192));
        *(simd_float4x4 *)(*(_QWORD *)(*(_QWORD *)(a1 + 376) + 312) + 384) = __invert_f4(*(simd_float4x4 *)(*(_QWORD *)(a1 + 384) + 64));
        *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 376) + 312) + 512) = (float)((float)(unint64_t)objc_msgSend_width(v56, v101, v102, v103)
                                                                               * v180.f32[0])
                                                                       * 0.5;
        *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 376) + 312) + 516) = vmuls_lane_f32((float)(unint64_t)objc_msgSend_height(v56, v104, v105, v106), v180, 1)* 0.5;
        *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 376) + 312) + 528) = *(_OWORD *)(*(_QWORD *)(a1 + 376) + 208);
        *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 376) + 312) + 544) = *(_OWORD *)(*(_QWORD *)(a1 + 376) + 224);
        *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 376) + 312) + 576) = *(_OWORD *)(*(_QWORD *)(a1 + 376) + 192);
        *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 376) + 312) + 560) = (float)*(int *)(*(_QWORD *)(a1 + 376) + 184);
        v107 = sub_1B187B0F0(v178, 0);
        if (v107)
          v115 = sub_1B1841E14(v107, (uint64_t)v108, v109, v110, v111, v112, v113, v114);
        else
          v115 = 0.0;
        v116 = *(_QWORD *)(*(_QWORD *)(a1 + 376) + 312);
        *(float *)(v116 + 592) = v115;
        objc_msgSend_setBytes_length_atIndex_(v10, v108, v116, 608, 8);
        objc_msgSend_setTexture_atIndex_(v10, v117, *(_QWORD *)(*(_QWORD *)(a1 + 384) + 672), 9);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v118, *(_QWORD *)(*(_QWORD *)(a1 + 384) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 384) + 720) + 704), 0, 10);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v119, *(_QWORD *)(*(_QWORD *)(a1 + 384) + 8 * (*(_BYTE *)(*(_QWORD *)(a1 + 384) + 720) == 0) + 704), 0, 11);
        v120 = sub_1B19DA2DC(v179);
        objc_msgSend_useHeap_(v10, v121, v120, v122);
        v123 = sub_1B19DA2EC(v179);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v124, v123, 0, 0);
        v125 = sub_1B19DA2E4(v179);
        objc_msgSend_setAccelerationStructure_atBufferIndex_(v10, v126, v125, 1);
        if (sub_1B19DA3D0(v179))
        {
          v127 = sub_1B19DA2F4(v179);
          objc_msgSend_setBuffer_offset_atIndex_(v10, v128, v127, 0, 2);
        }
        if (sub_1B19DA3E0(v179))
        {
          v135 = *(_QWORD *)(a1 + 384);
          v136 = *(_QWORD *)(v135 + 688);
          if (!v136)
          {
            sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v129, v130, v131, v132, v133, v134, (uint64_t)"_ptr != NULL");
            v136 = *(_QWORD *)(v135 + 688);
          }
          v137 = (void *)sub_1B18FD774(v136);
          v138 = sub_1B19DA30C(v179, v137);
          objc_msgSend_setIntersectionFunctionTable_atBufferIndex_(v10, v139, (uint64_t)v138, 3);
        }
        else
        {
          v138 = 0;
        }
        v140 = sub_1B19DA2FC(v179);
        v144 = sub_1B19DA3F0(v179, v141, v142, v143);
        objc_msgSend_useResources_count_usage_(v10, v145, v140, v144, 1);
        v152 = *(_QWORD *)(a1 + 384);
        v153 = *(_QWORD *)(v152 + 688);
        if (!v153)
        {
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v146, v147, v148, v149, v150, v151, (uint64_t)"_ptr != NULL");
          v153 = *(_QWORD *)(v152 + 688);
        }
        v154 = sub_1B18FD774(v153);
        objc_msgSend_setComputePipelineState_(v10, v155, v154, v156);
        v160 = (unint64_t)objc_msgSend_width(v56, v157, v158, v159) >> 1;
        v170 = (unint64_t)objc_msgSend_height(v56, v161, v162, v163) >> 1;
        v171 = *(_QWORD *)(a1 + 384);
        v172 = *(_QWORD *)(v171 + 688);
        if (!v172)
        {
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v164, v165, v166, v167, v168, v169, (uint64_t)"_ptr != NULL");
          v172 = *(_QWORD *)(v171 + 688);
        }
        v173 = (void *)sub_1B18FD774(v172);
        v181[0] = v160;
        v181[1] = v170;
        v181[2] = 1;
        RGMTLComputeCommandEncoderDispatchOnGrid2D(v10, v173, (uint64_t)v181, 1);

        ++*(_DWORD *)(*(_QWORD *)(a1 + 384) + 736);
        sub_1B19DA290(v179);
      }
    }
  }
}

uint64_t sub_1B18EE734(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  id v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  void *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  const char *v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  uint64_t v55;
  void *v56;
  const char *v57;
  uint64_t v58;
  void *v59;
  uint64_t v61;
  uint64_t v62;
  int v63;
  const char *v64;
  uint64_t v65;

  v8 = *a5;
  v64 = "RTClearCoatSpatialReSTIRPass";
  v65 = v8;
  LOBYTE(v8) = atomic_load((unsigned __int8 *)&qword_1EEF661A8);
  if ((v8 & 1) == 0)
  {
    v61 = a3;
    v62 = a2;
    v63 = __cxa_guard_acquire(&qword_1EEF661A8);
    a2 = v62;
    a3 = v61;
    if (v63)
    {
      qword_1EEF661A0 = (uint64_t)sub_1B18EF9E0("RT_CLEARCOAT_SPATIAL_RESTIR", 0x1Bu);
      __cxa_guard_release(&qword_1EEF661A8);
      a2 = v62;
      a3 = v61;
    }
  }
  sub_1B18F7354(a1, a2, a3, (uint64_t *)&v64, qword_1EEF661A0, 0);
  *(_QWORD *)a1 = &off_1E63CFF68;
  *(_QWORD *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_QWORD *)(a1 + 416) = 0;
  v9 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, (const CFX::RG::Resource *)a5[31]);
  v10 = *v9;
  v11 = v9[1];
  v19 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
  *(_QWORD *)(a1 + 408) = v19;
  *(_QWORD *)(a1 + 416) = objc_msgSend_resourceManager(v19, v20, v21, v22, v64, v65);
  v23 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v24 = CFX::CrossFrameResourceManager::get(a4[4], v23);
  *(_QWORD *)(a1 + 384) = v24;
  if (!v24)
  {
    v25 = (uint64_t)a4[4];
    v26 = (_QWORD *)operator new();
    *v26 = &off_1E63CFF28;
    v26[1] = 0;
    v26[2] = 0;
    v26[3] = 0;
    CFX::CrossFrameResourceManager::set(v25, v23, (uint64_t)v26);
    *(_QWORD *)(a1 + 384) = v26;
    v27 = objc_alloc_init(MEMORY[0x1E0CC6AA0]);
    LODWORD(v64) = 0;
    objc_msgSend_setConstantValue_type_withName_(v27, v28, (uint64_t)&v64, 29, CFSTR("spatial_pass_id"));
    v29 = *(_QWORD *)(a1 + 384);
    v32 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(*(void **)(a1 + 416), v30, (uint64_t)CFSTR("vfx_rt_clearcoat_spatial_restir"), (uint64_t)v27);
    v33 = *(void **)(v29 + 16);
    if (v33 != (void *)v32)
    {
      if (v33)

      *(_QWORD *)(v29 + 16) = v32;
    }
    LODWORD(v64) = 1;
    objc_msgSend_setConstantValue_type_withName_(v27, v31, (uint64_t)&v64, 29, CFSTR("spatial_pass_id"));
    v34 = *(_QWORD *)(a1 + 384);
    v36 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(*(void **)(a1 + 416), v35, (uint64_t)CFSTR("vfx_rt_clearcoat_spatial_restir"), (uint64_t)v27);
    v37 = *(void **)(v34 + 24);
    if (v37 != (void *)v36)
    {
      if (v37)

      *(_QWORD *)(v34 + 24) = v36;
    }

  }
  v38 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v39 = 0x9DDFEA08EB382D69
      * (v38 ^ ((0x9DDFEA08EB382D69 * (v38 ^ v10)) >> 47) ^ (0x9DDFEA08EB382D69 * (v38 ^ v10)));
  v40 = 0x9DDFEA08EB382D69 * (v39 ^ (v39 >> 47));
  v41 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v40 ^ ((0x9DDFEA08EB382D69 * (v40 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v40 ^ v11)))) ^ ((0x9DDFEA08EB382D69 * (v40 ^ ((0x9DDFEA08EB382D69 * (v40 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v40 ^ v11)))) >> 47));
  v42 = CFX::CrossFrameResourceManager::get(a4[4], v41);
  *(_QWORD *)(a1 + 392) = v42;
  if (!v42)
  {
    v43 = (uint64_t)a4[4];
    v44 = (_QWORD *)operator new();
    *v44 = &off_1E63CFF48;
    v44[1] = 0;
    v44[2] = 0;
    v44[3] = 0;
    CFX::CrossFrameResourceManager::set(v43, v41, (uint64_t)v44);
    *(_QWORD *)(a1 + 392) = v44;
    v48 = (void *)objc_msgSend_device(*(void **)(a1 + 408), v45, v46, v47);
    v53 = objc_msgSend_newBufferWithLength_options_(v48, v49, 96 * (v10 >> 1) * (unint64_t)(v11 >> 1), 32);
    v54 = (void *)v44[2];
    if (v54 != (void *)v53)
    {
      if (v54)

      v44[2] = v53;
    }
    v55 = *(_QWORD *)(a1 + 392);
    v56 = (void *)objc_msgSend_device(*(void **)(a1 + 408), v50, v51, v52);
    v58 = objc_msgSend_newBufferWithLength_options_(v56, v57, 96 * (v10 >> 1) * (unint64_t)(v11 >> 1), 32);
    v59 = *(void **)(v55 + 24);
    if (v59 != (void *)v58)
    {
      if (v59)

      *(_QWORD *)(v55 + 24) = v58;
    }
  }
  return a1;
}

void sub_1B18EEA8C(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18EEAB4(uint64_t result, uint64_t a2, void **a3)
{
  uint64_t v3;
  uint64_t v5;
  void *v6;
  id Texture;
  id v8;
  id v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  const char *v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  _QWORD v65[3];
  _QWORD v66[3];

  v3 = *(_QWORD *)(result + 384);
  if (*(_QWORD *)(v3 + 16) && *(_QWORD *)(v3 + 24))
  {
    v5 = result;
    v6 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(_QWORD *)(*(_QWORD *)(result + 376) + 312), 608, 8);
    Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(v5 + 376) + 256));
    v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(v5 + 376) + 248));
    v9 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v5 + 400));
    objc_msgSend_setTexture_atIndex_(v6, v10, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v6, v11, (uint64_t)v8, 1);
    objc_msgSend_setTexture_atIndex_(v6, v12, (uint64_t)v9, 2);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v13, *(_QWORD *)(*(_QWORD *)(v5 + 376) + 296), 0, 0);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v14, *(_QWORD *)(*(_QWORD *)(v5 + 392) + 16), 0, 1);
    v21 = *(_QWORD *)(v5 + 384);
    v22 = *(_QWORD *)(v21 + 16);
    if (!v22)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v15, v16, v17, v18, v19, v20, (uint64_t)"_ptr != NULL");
      v22 = *(_QWORD *)(v21 + 16);
    }
    v23 = sub_1B18FD774(v22);
    objc_msgSend_setComputePipelineState_(v6, v24, v23, v25);
    v29 = (unint64_t)objc_msgSend_width(v8, v26, v27, v28) >> 1;
    v39 = (unint64_t)objc_msgSend_height(v8, v30, v31, v32) >> 1;
    v40 = *(_QWORD *)(v5 + 384);
    v41 = *(_QWORD *)(v40 + 16);
    if (!v41)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v33, v34, v35, v36, v37, v38, (uint64_t)"_ptr != NULL");
      v41 = *(_QWORD *)(v40 + 16);
    }
    v42 = (void *)sub_1B18FD774(v41);
    v66[0] = v29;
    v66[1] = v39;
    v66[2] = 1;
    RGMTLComputeCommandEncoderDispatchOnGrid2D(v6, v42, (uint64_t)v66, 1);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v43, *(_QWORD *)(*(_QWORD *)(v5 + 392) + 16), 0, 0);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v44, *(_QWORD *)(*(_QWORD *)(v5 + 392) + 24), 0, 1);
    v51 = *(_QWORD *)(v5 + 384);
    v52 = *(_QWORD *)(v51 + 24);
    if (!v52)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v45, v46, v47, v48, v49, v50, (uint64_t)"_ptr != NULL");
      v52 = *(_QWORD *)(v51 + 24);
    }
    v53 = sub_1B18FD774(v52);
    objc_msgSend_setComputePipelineState_(v6, v54, v53, v55);
    v62 = *(_QWORD *)(v5 + 384);
    v63 = *(_QWORD *)(v62 + 24);
    if (!v63)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v56, v57, v58, v59, v60, v61, (uint64_t)"_ptr != NULL");
      v63 = *(_QWORD *)(v62 + 24);
    }
    v64 = (void *)sub_1B18FD774(v63);
    v65[0] = v29;
    v65[1] = v39;
    v65[2] = 1;
    return RGMTLComputeCommandEncoderDispatchOnGrid2D(v6, v64, (uint64_t)v65, 1);
  }
  return result;
}

uint64_t sub_1B18EED14(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t *v39;
  CFX::RG::TextureDescriptorReference *v40;
  uint64_t *v41;
  uint64_t v43;
  int v44;
  uint64_t v45;
  _OWORD v46[10];
  _OWORD v47[10];
  uint64_t v48[2];

  v8 = *a5;
  v48[0] = (uint64_t)"RTClearCoatUpscalePass";
  v48[1] = v8;
  LOBYTE(v8) = atomic_load((unsigned __int8 *)&qword_1EEF661B8);
  if ((v8 & 1) == 0)
  {
    v45 = a3;
    v43 = a2;
    v44 = __cxa_guard_acquire(&qword_1EEF661B8);
    a2 = v43;
    a3 = v45;
    if (v44)
    {
      qword_1EEF661B0 = (uint64_t)sub_1B18EF9E0("RT_CLEARCOAT_UPSCALE", 0x14u);
      __cxa_guard_release(&qword_1EEF661B8);
      a2 = v43;
      a3 = v45;
    }
  }
  sub_1B18F7354(a1, a2, a3, v48, qword_1EEF661B0, 0);
  *(_QWORD *)a1 = &off_1E63CF978;
  *(_QWORD *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_QWORD *)(a1 + 416) = 0;
  v16 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 368), v9, v10, v11, v12, v13, v14, v15);
  *(_QWORD *)(a1 + 408) = v16;
  *(_QWORD *)(a1 + 416) = objc_msgSend_resourceManager(v16, v17, v18, v19);
  v20 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v21 = CFX::CrossFrameResourceManager::get(a4[4], v20);
  *(_QWORD *)(a1 + 384) = v21;
  if (!v21)
  {
    *(_QWORD *)(a1 + 384) = sub_1B18EEF18(a4[4], v20);
    v29 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 368), v22, v23, v24, v25, v26, v27, v28);
    v33 = (void *)objc_msgSend_resourceManager(v29, v30, v31, v32);
    v34 = *(_QWORD *)(a1 + 384);
    v37 = objc_msgSend_newComputePipelineStateWithFunctionName_(v33, v35, (uint64_t)CFSTR("vfx_rt_clearcoat_upscale"), v36);
    v38 = *(void **)(v34 + 16);
    if (v38 != (void *)v37)
    {
      if (v38)

      *(_QWORD *)(v34 + 16) = v37;
    }
  }
  v39 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
  v40 = (CFX::RG::TextureDescriptorReference *)(a5 + 1);
  CFX::RG::TextureDescriptorReference::withPixelFormat(v40, MTLPixelFormatRGBA16Float, (uint64_t)v47);
  *(_QWORD *)(a1 + 392) = sub_1B17A34D0(v39, (uint64_t)"ClearCoatUpscale", v47);
  v41 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
  CFX::RG::TextureDescriptorReference::withPixelFormat(v40, MTLPixelFormatR16Float, (uint64_t)v46);
  *(_QWORD *)(a1 + 400) = sub_1B17A34D0(v41, (uint64_t)"ClearCoatUpscaleDistance", v46);
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 392));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 400));
  return a1;
}

void sub_1B18EEEF8(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1B18EEF18(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v4)
  {
    v4 = (_QWORD *)operator new();
    v4[1] = 0;
    v4[2] = 0;
    *v4 = &off_1E63CF958;
    CFX::CrossFrameResourceManager::set((uint64_t)a1, a2, (uint64_t)v4);
  }
  return v4;
}

uint64_t sub_1B18EEF90(uint64_t result, uint64_t a2, void **a3)
{
  uint64_t v4;
  void *v5;
  id Texture;
  id v7;
  const char *v8;
  const char *v9;
  const char *v10;
  id v11;
  const char *v12;
  id v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;

  if (*(_QWORD *)(*(_QWORD *)(result + 384) + 16))
  {
    v4 = result;
    v5 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(_QWORD *)(*(_QWORD *)(result + 376) + 312), 608, 8);
    Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(v4 + 376) + 256));
    v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(v4 + 376) + 248));
    objc_msgSend_setTexture_atIndex_(v5, v8, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)v7, 1);
    objc_msgSend_setBuffer_offset_atIndex_(v5, v10, *(_QWORD *)(*(_QWORD *)(v4 + 376) + 304), 0, 0);
    v11 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 392));
    objc_msgSend_setTexture_atIndex_(v5, v12, (uint64_t)v11, 10);
    v13 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 400));
    objc_msgSend_setTexture_atIndex_(v5, v14, (uint64_t)v13, 11);
    v21 = *(_QWORD *)(v4 + 384);
    v22 = *(_QWORD *)(v21 + 16);
    if (!v22)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v15, v16, v17, v18, v19, v20, (uint64_t)"_ptr != NULL");
      v22 = *(_QWORD *)(v21 + 16);
    }
    v23 = sub_1B18FD774(v22);
    return objc_msgSend_dispatch_onTexture2D_(v5, v24, v23, (uint64_t)v11);
  }
  return result;
}

uint64_t sub_1B18EF0E0(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int16 *v21;
  unsigned int v22;
  unsigned int v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  __int16 v32;
  __int16 v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  CFX::RG::Resource *v41;
  CFX::RG::Resource *v42;
  uint64_t v44;
  int v45;
  _OWORD v46[5];
  _OWORD v47[5];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  char v53;
  const char *v54;

  v9 = *a5;
  *(_QWORD *)&v48 = "RTClearCoatTemporalDenoisePass";
  *((_QWORD *)&v48 + 1) = v9;
  LOBYTE(v9) = atomic_load((unsigned __int8 *)&qword_1EEF661C8);
  if ((v9 & 1) == 0)
  {
    v44 = a3;
    v45 = __cxa_guard_acquire(&qword_1EEF661C8);
    a3 = v44;
    if (v45)
    {
      qword_1EEF661C0 = (uint64_t)sub_1B18EF9E0("RT_CLEARCOAT_TEMPORAL_DENOISE", 0x1Du);
      __cxa_guard_release(&qword_1EEF661C8);
      a3 = v44;
    }
  }
  sub_1B18F7354(a1, a2, a3, (uint64_t *)&v48, qword_1EEF661C0, 0);
  *(_QWORD *)a1 = &off_1E63D00F8;
  *(_QWORD *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  v17 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 368), v10, v11, v12, v13, v14, v15, v16);
  *(_QWORD *)(a1 + 416) = v17;
  *(_QWORD *)(a1 + 424) = objc_msgSend_resourceManager(v17, v18, v19, v20);
  v21 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, (const CFX::RG::Resource *)a5[31]);
  v22 = *v21;
  v23 = v21[1];
  v24 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v25 = CFX::CrossFrameResourceManager::get(a4[4], v24);
  *(_QWORD *)(a1 + 384) = v25;
  if (!v25)
  {
    v26 = (uint64_t)a4[4];
    v27 = (_OWORD *)operator new();
    *v27 = 0u;
    v27[1] = 0u;
    *(_QWORD *)v27 = &off_1E63D00B8;
    CFX::CrossFrameResourceManager::set(v26, v24, (uint64_t)v27);
    *(_QWORD *)(a1 + 384) = v27;
    v30 = objc_msgSend_newComputePipelineStateWithFunctionName_(*(void **)(a1 + 424), v28, (uint64_t)CFSTR("vfx_rt_clearcoat_temporal_denoise"), v29);
    v31 = (void *)*((_QWORD *)v27 + 2);
    if (v31 != (void *)v30)
    {
      if (v31)

      *((_QWORD *)v27 + 2) = v30;
    }
  }
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v48 = 0u;
  if (v22 <= 1)
    v32 = 1;
  else
    v32 = v22;
  if (v23 <= 1)
    v33 = 1;
  else
    v33 = v23;
  RGTextureDescriptorMake2D(v32, v33, 115, (uint64_t)&v48);
  v34 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v35 = 0x9DDFEA08EB382D69
      * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ (unsigned __int16)v48)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                               * (v34 ^ (unsigned __int16)v48)));
  v36 = 0x9DDFEA08EB382D69 * (v35 ^ (v35 >> 47));
  v37 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v36 ^ ((0x9DDFEA08EB382D69 * (v36 ^ WORD1(v48))) >> 47) ^ (0x9DDFEA08EB382D69 * (v36 ^ WORD1(v48))))) ^ ((0x9DDFEA08EB382D69 * (v36 ^ ((0x9DDFEA08EB382D69 * (v36 ^ WORD1(v48))) >> 47) ^ (0x9DDFEA08EB382D69 * (v36 ^ WORD1(v48))))) >> 47));
  v38 = CFX::CrossFrameResourceManager::get(a4[4], v37);
  *(_QWORD *)(a1 + 392) = v38;
  if (!v38)
  {
    v39 = (uint64_t)a4[4];
    v40 = (_QWORD *)operator new();
    *v40 = &off_1E63D00D8;
    v40[1] = 0;
    v40[2] = 0;
    v40[3] = 0;
    CFX::CrossFrameResourceManager::set(v39, v37, (uint64_t)v40);
    *(_QWORD *)(a1 + 392) = v40;
    CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
    v47[2] = v50;
    v47[3] = v51;
    v47[4] = v52;
    v47[0] = v48;
    v47[1] = v49;
    v54 = "pingPongTex0";
    v53 = 2;
    sub_1B1825D28((uint64_t *)&v54, (uint64_t)v47, &v53);
    sub_1B181C064((CFX::RG::Resource **)(*(_QWORD *)(a1 + 392) + 16), v41);
    CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
    v46[2] = v50;
    v46[3] = v51;
    v46[4] = v52;
    v46[0] = v48;
    v46[1] = v49;
    v54 = "pingPongTex1";
    v53 = 2;
    sub_1B1825D28((uint64_t *)&v54, (uint64_t)v46, &v53);
    sub_1B181C064((CFX::RG::Resource **)(*(_QWORD *)(a1 + 392) + 24), v42);
  }
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(_QWORD *)(a1 + 376) + 264));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(_QWORD *)(a1 + 392) + 8 * (*(_BYTE *)(*(_QWORD *)(a1 + 384) + 24) == 0) + 16));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(*(_QWORD *)(a1 + 392) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 384) + 24) + 16));
  return a1;
}

void sub_1B18EF450(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1B18EF47C(uint64_t a1, uint64_t a2, void **a3)
{
  void *v5;
  id Texture;
  id v7;
  id v8;
  uint64_t v9;
  const CFX::RG::Resource *v10;
  id v11;
  id v12;
  id v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  const char *v19;
  id v20;
  id v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  _OWORD *v34;
  __int128 v35;
  __int128 v36;
  _OWORD *v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  __int128 v41;
  __n128 result;
  __int128 v43;
  uint64_t v44;

  if (*(_QWORD *)(*(_QWORD *)(a1 + 384) + 16))
  {
    v5 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(_QWORD *)(*(_QWORD *)(a1 + 376) + 312), 608, 8);
    Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 400));
    v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 408));
    v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 376) + 256));
    v9 = *(_QWORD *)(a1 + 376);
    v10 = *(const CFX::RG::Resource **)(v9 + 280);
    if (v10)
    {
      v11 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v10);
      v9 = *(_QWORD *)(a1 + 376);
    }
    else
    {
      v11 = 0;
    }
    v12 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v9 + 264));
    v13 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 376) + 248));
    objc_msgSend_setTexture_atIndex_(v5, v14, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v5, v15, (uint64_t)v8, 1);
    objc_msgSend_setTexture_atIndex_(v5, v16, (uint64_t)v11, 2);
    objc_msgSend_setTexture_atIndex_(v5, v17, (uint64_t)v12, 3);
    objc_msgSend_setTexture_atIndex_(v5, v18, (uint64_t)v13, 4);
    objc_msgSend_setTexture_atIndex_(v5, v19, (uint64_t)v7, 5);
    v20 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 392)+ 8 * (*(_BYTE *)(*(_QWORD *)(a1 + 384) + 24) == 0)+ 16));
    v21 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 392)+ 8 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 384) + 24)+ 16));
    objc_msgSend_setTexture_atIndex_(v5, v22, (uint64_t)v21, 10);
    objc_msgSend_setTexture_atIndex_(v5, v23, (uint64_t)v20, 11);
    v30 = *(_QWORD *)(a1 + 384);
    v31 = *(_QWORD *)(v30 + 16);
    if (!v31)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v24, v25, v26, v27, v28, v29, (uint64_t)"_ptr != NULL");
      v31 = *(_QWORD *)(v30 + 16);
    }
    v32 = sub_1B18FD774(v31);
    objc_msgSend_dispatch_onTexture2D_(v5, v33, v32, (uint64_t)v21);
    v34 = *(_OWORD **)(*(_QWORD *)(a1 + 376) + 312);
    v35 = v34[13];
    v34[16] = v34[12];
    v34[17] = v35;
    v36 = v34[15];
    v34[18] = v34[14];
    v34[19] = v36;
    v37 = *(_OWORD **)(*(_QWORD *)(a1 + 376) + 312);
    v38 = v37[1];
    v37[4] = *v37;
    v37[5] = v38;
    v39 = v37[3];
    v37[6] = v37[2];
    v37[7] = v39;
    v40 = *(_QWORD *)(*(_QWORD *)(a1 + 376) + 312);
    v41 = *(_OWORD *)(v40 + 400);
    *(_OWORD *)(v40 + 448) = *(_OWORD *)(v40 + 384);
    *(_OWORD *)(v40 + 464) = v41;
    result = *(__n128 *)(v40 + 416);
    v43 = *(_OWORD *)(v40 + 432);
    *(__n128 *)(v40 + 480) = result;
    *(_OWORD *)(v40 + 496) = v43;
    v44 = *(_QWORD *)(a1 + 384);
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 376) + 312) + 524);
    *(_BYTE *)(v44 + 24) ^= 1u;
  }
  return result;
}

CFX::RG::Pass *sub_1B18EF6D0(CFX::RG::RenderGraphContext *a1, uint64_t *a2)
{
  uint64_t *v4;
  CFX::RG::Pass *v5;
  uint64_t *v6;
  CFX::RG::Resource *v7;
  uint64_t *v8;
  CFX::RG::Resource *v9;
  uint64_t *v10;
  CFX::RG::Resource *v11;
  CFX::RG::Resource *v12;

  v4 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder(a1);
  v5 = (CFX::RG::Pass *)sub_1B18EF7F0(v4, (CFX::CrossFrameResourceManager **)a1, (uint64_t)a2);
  a2[37] = *(_QWORD *)(*((_QWORD *)v5 + 48) + 8 * *(unsigned __int8 *)(*((_QWORD *)v5 + 48) + 720) + 704);
  v6 = (uint64_t *)sub_1B18EF844(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  v7 = *(CFX::RG::Resource **)(*((_QWORD *)v5 + 48) + 728);
  v6[50] = (uint64_t)v7;
  CFX::RG::Pass::readFrom(v6, v7);
  CFX::RG::Pass::dependsOn(v6, v5);
  a2[38] = *(_QWORD *)(v6[49] + 24);
  v8 = (uint64_t *)sub_1B18EF898(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  v9 = *(CFX::RG::Resource **)(*((_QWORD *)v5 + 48) + 728);
  v8[50] = (uint64_t)v9;
  CFX::RG::Pass::readFrom(v8, v9);
  CFX::RG::Pass::dependsOn(v8, (CFX::RG::Pass *)v6);
  v10 = (uint64_t *)sub_1B18EF8EC(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  v11 = (CFX::RG::Resource *)v8[49];
  v10[50] = (uint64_t)v11;
  CFX::RG::Pass::readFrom(v10, v11);
  v12 = *(CFX::RG::Resource **)(*((_QWORD *)v5 + 48) + 728);
  v10[51] = (uint64_t)v12;
  CFX::RG::Pass::readFrom(v10, v12);
  CFX::RG::Pass::dependsOn(v10, (CFX::RG::Pass *)v8);
  a2[36] = *(_QWORD *)(v10[49] + 8 * *(unsigned __int8 *)(v10[48] + 24) + 16);
  return v5;
}

uint64_t sub_1B18EF7F0(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B18EFD88(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B18EF844(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B18EFDE4(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B18EF898(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B18EFE40(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B18EF8EC(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B18EFE9C(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

void sub_1B18EF944(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

void sub_1B18EF96C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

void sub_1B18EF994(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

void sub_1B18EF9BC(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

unsigned __int8 *sub_1B18EF9E0(unsigned __int8 *result, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      v3 = a2 >> 3;
      v4 = &result[8 * v3];
      v5 = 8 * v3;
      do
      {
        v6 = *(_QWORD *)result;
        result += 8;
        v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

_QWORD *sub_1B18EFAA8(_QWORD *a1)
{
  uint64_t i;
  void *v3;

  *a1 = &off_1E63CFF28;
  for (i = 3; i != 1; --i)
  {
    v3 = (void *)a1[i];
    if (v3)

  }
  return a1;
}

void sub_1B18EFAF0(_QWORD *a1)
{
  uint64_t v2;
  void *v3;

  *a1 = &off_1E63CFF28;
  v2 = 3;
  while (1)
  {
    v3 = (void *)a1[v2];
    if (v3)

    if (--v2 == 1)
      JUMPOUT(0x1B5E22E18);
  }
}

_QWORD *sub_1B18EFB48(_QWORD *a1)
{
  uint64_t i;
  void *v3;

  *a1 = &off_1E63CFF48;
  for (i = 3; i != 1; --i)
  {
    v3 = (void *)a1[i];
    if (v3)

  }
  return a1;
}

void sub_1B18EFB90(_QWORD *a1)
{
  uint64_t v2;
  void *v3;

  *a1 = &off_1E63CFF48;
  v2 = 3;
  while (1)
  {
    v3 = (void *)a1[v2];
    if (v3)

    if (--v2 == 1)
      JUMPOUT(0x1B5E22E18);
  }
}

_QWORD *sub_1B18EFBE8(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E63CF958;
  v2 = (void *)a1[2];
  if (v2)

  return a1;
}

void sub_1B18EFC20(_QWORD *a1)
{
  void *v1;

  *a1 = &off_1E63CF958;
  v1 = (void *)a1[2];
  if (v1)

  JUMPOUT(0x1B5E22E18);
}

_QWORD *sub_1B18EFC68(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E63D00B8;
  v2 = (void *)a1[2];
  if (v2)

  return a1;
}

void sub_1B18EFCA0(_QWORD *a1)
{
  void *v1;

  *a1 = &off_1E63D00B8;
  v1 = (void *)a1[2];
  if (v1)

  JUMPOUT(0x1B5E22E18);
}

_QWORD *sub_1B18EFCE8(_QWORD *a1)
{
  uint64_t i;

  *a1 = &off_1E63D00D8;
  for (i = 3; i != 1; --i)
    sub_1B181C064((CFX::RG::Resource **)&a1[i], 0);
  return a1;
}

void sub_1B18EFD30(_QWORD *a1)
{
  uint64_t i;

  *a1 = &off_1E63D00D8;
  for (i = 3; i != 1; --i)
    sub_1B181C064((CFX::RG::Resource **)&a1[i], 0);
  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B18EFD88(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x198u, 8u);
  return sub_1B18EDEE4(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B18EFDE4(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x1A8u, 8u);
  return sub_1B18EE734(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B18EFE40(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x1A8u, 8u);
  return sub_1B18EED14(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B18EFE9C(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x1B0u, 8u);
  return sub_1B18EF0E0(v8, *a3, a3[1], a4, a5);
}

void sub_1B18EFEF8(__CFString *a1, const __CFString *a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6)
{
  CFStringAppend(a1, a2);
  CFStringAppendFormat(a1, 0, CFSTR(" %f %f %f %f\n"), a3.n128_f32[0], a3.n128_f32[1], a3.n128_f32[2], a3.n128_f32[3]);
  CFStringAppendFormat(a1, 0, CFSTR(" %f %f %f %f\n"), a4.n128_f32[0], a4.n128_f32[1], a4.n128_f32[2], a4.n128_f32[3]);
  CFStringAppendFormat(a1, 0, CFSTR(" %f %f %f %f\n"), a5.n128_f32[0], a5.n128_f32[1], a5.n128_f32[2], a5.n128_f32[3]);
  CFStringAppendFormat(a1, 0, CFSTR(" %f %f %f %f\n"), a6.n128_f32[0], a6.n128_f32[1], a6.n128_f32[2], a6.n128_f32[3]);
}

uint64_t sub_1B18F0014()
{
  if (qword_1ED4CEE60 != -1)
    dispatch_once(&qword_1ED4CEE60, &unk_1E63D1070);
  return qword_1ED4CEE68;
}

double sub_1B18F0054()
{
  double result;

  if (!qword_1ED4CEE68)
  {
    qword_1ED4CEE68 = sub_1B179CB60(&qword_1ED4CEE68);
    qword_1ED4BEC40 = (uint64_t)sub_1B18F10E8;
    *(_QWORD *)&result = 0x1B18F0010;
    unk_1ED4BEC58 = xmmword_1E63D3190;
    unk_1ED4BEC68 = unk_1E63D31A0;
    qword_1ED4BEC78 = 0;
    unk_1ED4BEC80 = sub_1B18F1B88;
  }
  return result;
}

double sub_1B18F00C8()
{
  _OWORD *v0;
  double result;

  if (qword_1ED4CEE60 != -1)
    dispatch_once(&qword_1ED4CEE60, &unk_1E63D1070);
  v0 = (_OWORD *)sub_1B179CB90(qword_1ED4CEE68, 0xE0uLL);
  v0[7] = xmmword_1B2244DB0;
  v0[8] = xmmword_1B2244DD0;
  result = 0.0;
  v0[9] = xmmword_1B2244D90;
  v0[10] = xmmword_1B2244E20;
  return result;
}

uint64_t sub_1B18F0138(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFString *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  size_t v25;

  sub_1B18F00C8();
  v16 = v15;
  if (a4)
  {
    v17 = (const __CFString *)sub_1B193E568(a4, v8, v9, v10, v11, v12, v13, v14);
    sub_1B193E5B0(v16, v17, v18, v19, v20, v21, v22, v23);
  }
  *(_WORD *)(v16 + 64) = a2;
  *(_QWORD *)(v16 + 80) = a1;
  v24 = (uint64_t)a2 << 6;
  *(_QWORD *)(v16 + 88) = sub_1B179E238(v24);
  *(_QWORD *)(v16 + 96) = sub_1B179E238(v24);
  if (*(_WORD *)(v16 + 64) == 1)
  {
    *(_QWORD *)(v16 + 72) = 0;
    *(_QWORD *)(v16 + 184) = 0;
    *(_QWORD *)(v16 + 192) = 0;
    *(_QWORD *)(v16 + 176) = 0;
  }
  else
  {
    v25 = 8 * a1 + 8;
    if (a3)
    {
      *(_QWORD *)(v16 + 72) = a3;
      *(_QWORD *)(v16 + 176) = sub_1B179E238(v25);
      *(_QWORD *)(v16 + 184) = sub_1B179E238(2 * a3);
      *(_QWORD *)(v16 + 192) = sub_1B179E238(4 * a3);
    }
    else
    {
      *(_QWORD *)(v16 + 72) = 0;
      *(_QWORD *)(v16 + 176) = sub_1B179E238(v25);
      *(_QWORD *)(v16 + 184) = sub_1B179E238(0);
      *(_QWORD *)(v16 + 192) = 0;
    }
  }
  return v16;
}

uint64_t sub_1B18F0220(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int8 *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  float *v66;
  uint64_t v67;
  uint64_t v68;
  float v69;
  uint64_t v70;
  int v71;
  size_t v72;
  _DWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  double v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  _BYTE *v93;
  unsigned __int8 *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v100;

  sub_1B18F00C8();
  v5 = v4;
  v12 = sub_1B1875E70(a1, 1, v6, v7, v8, v9, v10, v11);
  v20 = sub_1B17EDAE0((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19);
  v25 = sub_1B1875540(a1, 5, 0, 1, v21, v22, v23, v24);
  if (v25)
  {
    v33 = (unsigned __int8 *)sub_1B17ED6C4((uint64_t)v25, v26, v27, v28, v29, v30, v31, v32);
    v35 = v34;
    v40 = sub_1B1875540(a1, 6, 0, 1, v36, v37, v38, v39);
    v48 = (uint64_t)v40;
    if (!v40)
    {
      *(_WORD *)(v5 + 200) = 1;
      v61 = v20;
      goto LABEL_33;
    }
    v49 = sub_1B17ED6C4((uint64_t)v40, v41, v42, v43, v44, v45, v46, v47);
    v57 = HIWORD(v50);
    if (BYTE6(v50) == 1 || BYTE6(v50) == 20)
    {
      if ((_DWORD)v35)
      {
        v58 = 0;
        v59 = 0;
        v60 = 0;
        v61 = 0;
        v62 = v50 & 0xFF000000000000;
        v63 = HIBYTE(v50);
        if (HIBYTE(v50) <= 1u)
          v64 = 1;
        else
          v64 = HIBYTE(v50);
        v65 = BYTE5(v50);
        while (1)
        {
          v66 = (float *)(v49 + v58);
          if (v62 == 0x1000000000000)
          {
            if (v63)
            {
              v67 = 0;
              v68 = v64;
              do
              {
                v69 = *v66++;
                if (v69 > 0.0)
                  ++v67;
                --v68;
              }
              while (v68);
              goto LABEL_23;
            }
          }
          else if (v63)
          {
            v67 = 0;
            v70 = v64;
            do
            {
              v71 = *(unsigned __int8 *)v66;
              v66 = (float *)((char *)v66 + 1);
              if (v71)
                ++v67;
              --v70;
            }
            while (v70);
            goto LABEL_23;
          }
          v67 = 0;
LABEL_23:
          if (v60 <= v67)
            v60 = v67;
          v61 += v67;
          ++v59;
          v58 += v65;
          if (v59 == v35)
            goto LABEL_30;
        }
      }
      v61 = 0;
      LOWORD(v60) = 0;
LABEL_30:
      *(_WORD *)(v5 + 200) = v60;
    }
    else
    {
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: Unsupported skin weight format"), v51, v52, v53, v54, v55, v56, v100);
      v61 = 0;
    }
    if (v57 == 1 || v57 == 20)
    {
LABEL_33:
      *(_QWORD *)(v5 + 176) = sub_1B179E238(8 * v20 + 8);
      *(_WORD *)(v5 + 64) = a2;
      *(_QWORD *)(v5 + 72) = v61;
      *(_QWORD *)(v5 + 80) = v20;
      v72 = (uint64_t)a2 << 6;
      *(_QWORD *)(v5 + 88) = sub_1B179E238(v72);
      *(_QWORD *)(v5 + 96) = sub_1B179E238(v72);
      *(_QWORD *)(v5 + 184) = sub_1B179E238(2 * v61);
      v73 = sub_1B179E238(4 * v61);
      *(_QWORD *)(v5 + 192) = v73;
      if (v48)
      {
        v81 = sub_1B17ED6C4(v48, v74, v75, v76, v77, v78, v79, v80);
        v84 = *(_QWORD *)(v5 + 176);
        if (v20 >= 1)
        {
          v85 = 0;
          v86 = 0;
          v87 = v82 & 0xFF000000000000;
          v88 = BYTE5(v82);
          v89 = HIBYTE(v82);
          if (HIBYTE(v82) <= 1u)
            v89 = 1;
          v90 = HIBYTE(v82);
          do
          {
            *(_QWORD *)(v84 + 8 * v85) = v86;
            if (v87 == 0x1000000000000)
            {
              if (v90)
              {
                v91 = 0;
                do
                {
                  LODWORD(v83) = *(_DWORD *)(v81 + 4 * v91);
                  if (*(float *)&v83 > 0.0)
                  {
                    v92 = *(_QWORD *)(v5 + 192);
                    *(_WORD *)(*(_QWORD *)(v5 + 184) + 2 * v86) = v33[v91];
                    *(_DWORD *)(v92 + 4 * v86++) = LODWORD(v83);
                  }
                  ++v91;
                }
                while (v89 != v91);
              }
            }
            else if (v90)
            {
              v93 = (_BYTE *)v81;
              v94 = v33;
              v95 = v89;
              do
              {
                if (*v93)
                {
                  v96 = *(_QWORD *)(v5 + 192);
                  *(_WORD *)(*(_QWORD *)(v5 + 184) + 2 * v86) = *v94;
                  LOBYTE(v83) = *v93;
                  v83 = (double)*(unint64_t *)&v83 / 255.0;
                  *(float *)&v83 = v83;
                  *(_DWORD *)(v96 + 4 * v86++) = LODWORD(v83);
                }
                ++v94;
                ++v93;
                --v95;
              }
              while (v95);
            }
            ++v85;
            v33 += BYTE5(v35);
            v81 += v88;
          }
          while (v85 != v20);
          goto LABEL_58;
        }
      }
      else
      {
        v84 = *(_QWORD *)(v5 + 176);
        if (v20 >= 1)
        {
          v97 = 0;
          v98 = *(_QWORD *)(v5 + 184);
          do
          {
            *(_QWORD *)(v84 + 8 * v97) = v97;
            *(_WORD *)(v98 + 2 * v97) = *v33;
            v73[v97] = 1065353216;
            v33 += BYTE5(v35);
            ++v97;
          }
          while (v20 != v97);
          v86 = v20;
          goto LABEL_58;
        }
      }
      v86 = 0;
LABEL_58:
      *(_QWORD *)(v84 + 8 * v20) = v86;
      return v5;
    }
  }
  return 0;
}

uint64_t sub_1B18F0560(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  float32x4_t *v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _OWORD *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _OWORD v16[4];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  if (*(_QWORD *)(result + 96) && *(__int16 *)(result + 64) >= 1)
  {
    v1 = 0;
    do
    {
      v2 = 0;
      v3 = *(_QWORD *)(result + 96);
      v4 = (float32x4_t *)(*(_QWORD *)(result + 88) + (v1 << 6));
      v5 = *v4;
      v6 = v4[1];
      v7 = v4[2];
      v8 = v4[3];
      v9 = *(_OWORD *)(result + 128);
      v10 = *(_OWORD *)(result + 144);
      v11 = *(_OWORD *)(result + 160);
      v16[0] = *(_OWORD *)(result + 112);
      v16[1] = v9;
      v16[2] = v10;
      v16[3] = v11;
      v17 = 0uLL;
      v18 = 0uLL;
      v19 = 0uLL;
      v20 = 0uLL;
      do
      {
        *(__int128 *)((char *)&v17 + v2 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5, COERCE_FLOAT(v16[v2])), v6, *(float32x2_t *)&v16[v2], 1), v7, (float32x4_t)v16[v2], 2), v8, (float32x4_t)v16[v2], 3);
        ++v2;
      }
      while (v2 != 4);
      v12 = (_OWORD *)(v3 + (v1 << 6));
      v13 = v18;
      v14 = v19;
      v15 = v20;
      *v12 = v17;
      v12[1] = v13;
      v12[2] = v14;
      v12[3] = v15;
      ++v1;
    }
    while (v1 < *(__int16 *)(result + 64));
  }
  return result;
}

uint64_t sub_1B18F0604(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

uint64_t sub_1B18F060C(uint64_t a1, void *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v10;

  v10 = *(void **)(a1 + 88);
  if (!v10)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"skin->_inverseBindMatrices");
    v10 = *(void **)(a1 + 88);
  }
  memcpy(v10, __src, (uint64_t)*(__int16 *)(a1 + 64) << 6);
  return sub_1B18F0560(a1);
}

void sub_1B18F0670(size_t *a1)
{
  size_t v1;
  uint64_t v3;
  _QWORD *v4;
  size_t v5;
  size_t v6;
  _WORD *v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  int64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  __int16 v24;
  size_t *v25;
  void *v26;
  _QWORD v27[2];
  size_t *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v1 = a1[9];
  if (v1)
  {
    v3 = a1[10];
    if (v1 != v3)
    {
      v4 = (_QWORD *)a1[22];
      v5 = a1[23];
      v6 = a1[24];
      v7 = malloc_type_calloc(2uLL, v1, 0x850BEFBFuLL);
      v8 = (float *)malloc_type_calloc(4uLL, a1[9], 0x19764A4EuLL);
      v27[1] = v27;
      v28 = a1;
      v30 = v4;
      v9 = *v4;
      MEMORY[0x1E0C80A78](v8, v10);
      v12 = (char *)v27 - v11;
      if (v3 < 1)
      {
        v14 = 0;
      }
      else
      {
        v13 = 0;
        v14 = 0;
        v15 = v30;
        v29 = v3;
        do
        {
          v16 = v15[++v13];
          if ((uint64_t)((unint64_t)(v16 - v9) << 48) >= 1)
          {
            v31 = v15[v13];
            v32 = v13;
            v17 = 0;
            if ((__int16)(v16 - v9) <= 1)
              v18 = 1;
            else
              v18 = (__int16)(v16 - v9);
            do
            {
              v19 = 0;
              if (v17)
              {
                while (*(float *)(v6 + 4 * (v17 + v9)) <= *(float *)(v6 + 4 * (*(_QWORD *)&v12[8 * v19] + v9)))
                {
                  if (v17 == ++v19)
                  {
                    v19 = v17;
                    goto LABEL_16;
                  }
                }
              }
              if (v17 != v19)
                memmove(&v12[8 * v19 + 8], &v12[8 * v19], 8 * (v17 - v19));
LABEL_16:
              *(_QWORD *)&v12[8 * v19] = v17++;
            }
            while (v17 != v18);
            v20 = (uint64_t *)v12;
            v3 = v29;
            v15 = v30;
            v16 = v31;
            v13 = v32;
            do
            {
              v21 = *v20++;
              v22 = v21 + v9;
              v23 = *(float *)(v6 + 4 * (v21 + v9));
              if (v23 <= 0.00000011921)
                break;
              v24 = *(_WORD *)(v5 + 2 * v22);
              v8[v14] = v23;
              v7[v14++] = v24;
              --v18;
            }
            while (v18);
          }
          v15[v13] = v14;
          v9 = v16;
        }
        while (v13 != v3);
      }
      v25 = v28;
      if (v14 >= (uint64_t)v28[9])
      {
        free(v7);
        free(v8);
      }
      else
      {
        free((void *)v28[23]);
        free((void *)v25[24]);
        if (v14)
        {
          v25[23] = (size_t)malloc_type_realloc(v7, 2 * v14, 0x1000040BDFB0063uLL);
          v26 = malloc_type_realloc(v8, 4 * v14, 0x100004052888210uLL);
        }
        else
        {
          free(v7);
          free(v8);
          v26 = 0;
          v25[23] = 0;
        }
        v25[24] = (size_t)v26;
        v25[9] = v14;
      }
    }
  }
}

_QWORD *sub_1B18F091C(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if (a2)
    *a2 = result[22];
  if (a3)
    *a3 = result[23];
  if (a4)
    *a4 = result[24];
  return result;
}

uint64_t sub_1B18F0944(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"skin");
  return *(_QWORD *)(a1 + 72);
}

uint64_t sub_1B18F098C(uint64_t result, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  *(__n128 *)(result + 112) = a2;
  *(__n128 *)(result + 128) = a3;
  *(__n128 *)(result + 144) = a4;
  *(__n128 *)(result + 160) = a5;
  return sub_1B18F0560(result);
}

uint64_t sub_1B18F0998(uint64_t a1)
{
  return a1 + 112;
}

uint64_t sub_1B18F09A0(uint64_t a1)
{
  return *(__int16 *)(a1 + 64);
}

void sub_1B18F09A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"skin");
  if (!*(_QWORD *)(a1 + 224))
  {
    v9 = *(_QWORD *)(a1 + 80);
    v10 = sub_1B1846AB8(0, 5, v9, 4, 15, a6, a7, a8);
    sub_1B17ED200(v10);
    if (*(__int16 *)(a1 + 200) <= 1)
    {
      v33 = (char *)sub_1B17ED6C4(v10, v11, v12, v13, v14, v15, v16, v17);
      v34 = v38;
      v18 = 0;
    }
    else
    {
      v18 = sub_1B1846AB8(0, 6, v9, 4, 20, v15, v16, v17);
      sub_1B17ED200(v18);
      v33 = (char *)sub_1B17ED6C4(v10, v19, v20, v21, v22, v23, v24, v25);
      v34 = v26;
      if (v18)
      {
        v35 = (char *)sub_1B17ED6C4(v18, v26, v27, v28, v29, v30, v31, v32);
        v37 = v36;
LABEL_9:
        sub_1B18F0AAC((_QWORD *)a1, v33, v34, v35, v37, v30, v31, v32, v39);
        *(_QWORD *)(a1 + 216) = v18;
        *(_QWORD *)(a1 + 224) = v10;
        return;
      }
    }
    v35 = 0;
    v37 = 0;
    goto LABEL_9;
  }
}

void sub_1B18F0AAC(_QWORD *a1, char *__b, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  int v22;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  float v37;
  int v38;
  int v39;
  float v40;
  uint64_t v41;
  float v42;
  uint64_t i;
  float *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  int v55;
  char v56;
  uint64_t v57;
  char *v58;
  char *v59;
  uint64_t v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  _QWORD v70[2];
  float v71[4];
  uint64_t v72;

  v12 = __b;
  v72 = *MEMORY[0x1E0C80C00];
  v13 = a1[10];
  memset(__b, 255, (4 * v13));
  v20 = BYTE5(a5);
  if (a4)
  {
    bzero(a4, v13 * BYTE5(a5));
    v21 = (_DWORD)v13 == (_DWORD)a5;
  }
  else
  {
    v21 = 1;
  }
  v22 = !v21;
  if ((_DWORD)v13 != (_DWORD)a3 || v22 != 0)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. inconsistency in %s"), v14, v15, v16, v17, v18, v19, (uint64_t)"count == dstJoints.count && (!dstWeights.ptr || (count == dstWeights.count))");
  v24 = a1;
  v25 = a1[23];
  v66 = a1[22];
  v26 = a1[24];
  v70[0] = 0;
  v70[1] = 0;
  if ((_DWORD)v13)
  {
    v69 = 0;
    v27 = 0;
    v62 = 0;
    v63 = v13;
    v64 = BYTE5(a3);
    v58 = v12;
    v59 = a4;
    v65 = v20;
    while (1)
    {
      v28 = *(_QWORD *)(v66 + 8 * v27);
      if (v28 < 0
        || ((v29 = v27 + 1, v30 = *(_QWORD *)(v66 + 8 * (v27 + 1)), v31 = v24[9], v28 <= v31)
          ? (v32 = v30 <= v31)
          : (v32 = 0),
            !v32))
      {
        if ((byte_1EEF661D0 & 1) == 0)
        {
          byte_1EEF661D0 = 1;
          sub_1B17C4408(16, (uint64_t)CFSTR("Error: invalid skin indices"), v14, v15, v16, v17, v18, v19, a9);
        }
        return;
      }
      v33 = (v64 * v27);
      v67 = v30 - v28;
      v68 = v29;
      v34 = 0;
      if (v30 <= v28)
        break;
      v35 = &a4[v69];
      v61 = v33;
      v36 = &v12[v33];
      v37 = 0.0;
      v38 = v62;
      do
      {
        v39 = *(__int16 *)(v25 + 2 * v28);
        if (v39 <= 255)
        {
          v40 = *(float *)(v26 + 4 * v28);
          if (v40 > 0.0039216)
          {
            if (v34 < 4)
            {
              v36[v34] = v39;
              v71[v34] = v40;
              v37 = v37 + v40;
              ++v34;
            }
            else
            {
              if ((v38 & 1) == 0)
                sub_1B17C4408(0, (uint64_t)CFSTR("Info: Too many influencing joints (%ld > %d) on the vertex #%u, will cap to %d and renormalize"), v14, v15, v16, v17, v18, v19, v67);
              v41 = 0;
              v42 = v71[0];
              for (i = 1; i != 4; ++i)
              {
                if (v42 > v71[i])
                {
                  v41 = i;
                  v42 = v71[i];
                }
              }
              if (v40 > v42)
              {
                v37 = v40 + (float)(v37 - v42);
                v71[v41] = v40;
                v36[v41] = v39;
              }
              v38 = 1;
            }
          }
        }
        ++v28;
      }
      while (v28 != v30);
      v62 = v38;
      if (v37 > 0.0 && v37 != 1.0 && v34 >= 1)
      {
        v46 = v71;
        v47 = v34;
        do
        {
          *v46 = *v46 / v37;
          ++v46;
          --v47;
        }
        while (v47);
      }
      v12 = v58;
      a4 = v59;
      v48 = v68;
      if (v59 && v34 >= 1)
      {
        v49 = 0;
        v50 = 0;
        do
        {
          v51 = (int)rintf(v71[v49] * 255.0);
          if (v51 >= 255)
            v51 = 255;
          v52 = v51 & ~(v51 >> 31);
          v35[v49] = v52;
          v50 += v52;
          ++v49;
        }
        while (v34 != v49);
        while (1)
        {
LABEL_61:
          if (v50 == 255)
            break;
          v53 = v34;
          v54 = v35;
          while (1)
          {
            v55 = *v54;
            if (v50 > 254)
              break;
            if (v55 != 255)
            {
              v56 = 1;
              v57 = 1;
              goto LABEL_60;
            }
LABEL_57:
            ++v54;
            if (!--v53)
              goto LABEL_61;
          }
          if (!*v54)
            goto LABEL_57;
          v57 = -1;
          v56 = -1;
LABEL_60:
          *v54 = v55 + v56;
          v50 += v57;
        }
      }
      if (v34 >= 1)
        ++*((_DWORD *)v70 + v34 - 1);
      v24 = a1;
      v33 = v61;
      if (v34 <= 3)
        goto LABEL_67;
LABEL_68:
      v69 += v65;
      v27 = v48;
      if (v48 == v63)
        return;
    }
    v48 = v29;
LABEL_67:
    bzero(&v12[v34 + v33], 4 - v34);
    bzero(&v71[v34], 16 - 4 * v34);
    goto LABEL_68;
  }
}

uint64_t sub_1B18F0EB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B18F09A8(a1, a2, a3, a4, a5, a6, a7, a8);
  return *(_QWORD *)(a1 + 224);
}

uint64_t sub_1B18F0ED4(uint64_t a1)
{
  return *(__int16 *)(a1 + 200);
}

uint64_t sub_1B18F0EDC(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 200) = a2;
  return result;
}

CFTypeRef sub_1B18F0EE4(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"skin");
  result = *(CFTypeRef *)(a1 + 208);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 208) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 208) = result;
  }
  return result;
}

id sub_1B18F0F60(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  const void *v14;
  const void *v15;

  sub_1B194F874(CFSTR("kCFXNotificationSkinWillDie"), a1, 0, 1u);
  v9 = (void *)a1[11];
  if (v9)
    free(v9);
  v10 = (void *)a1[12];
  if (v10)
    free(v10);
  v11 = (void *)a1[24];
  if (v11)
    free(v11);
  v12 = (void *)a1[22];
  if (v12)
    free(v12);
  v13 = (void *)a1[23];
  if (v13)
    free(v13);
  if (a1[26])
    sub_1B18F0EE4((uint64_t)a1, 0, v3, v4, v5, v6, v7, v8);
  v14 = (const void *)a1[28];
  if (v14)
  {
    CFRelease(v14);
    a1[28] = 0;
  }
  v15 = (const void *)a1[27];
  if (v15)
  {
    CFRelease(v15);
    a1[27] = 0;
  }
  return sub_1B193E38C((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
}

__CFString *sub_1B18F1010(__n128 *a1)
{
  __CFString *Mutable;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __n128 *v11;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v10 = sub_1B193E568((uint64_t)a1, v3, v4, v5, v6, v7, v8, v9);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFXSkin %p name:%@ joint:%d weight:%d vertexCount:%d\n"), a1, v10, a1[4].n128_i16[0], a1[4].n128_u64[1], a1[5].n128_u64[0]);
  CFStringAppendFormat(Mutable, 0, CFSTR("  maxInf:%d morpher:%p\n"), a1[12].n128_i16[4], a1[13].n128_u64[0]);
  sub_1B18EFEF8(Mutable, CFSTR("defaultShapeMatrix\n"), a1[7], a1[8], a1[9], a1[10]);
  v11 = (__n128 *)a1[5].n128_u64[1];
  if (v11)
    sub_1B18EFEF8(Mutable, CFSTR("inverseBindMatrix"), *v11, v11[1], v11[2], v11[3]);
  CFStringAppend(Mutable, CFSTR(">"));
  return Mutable;
}

__CFArray *sub_1B18F10E8(_QWORD *a1)
{
  __CFArray *Mutable;
  const CFDictionaryKeyCallBacks *v3;
  __CFDictionary *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  __CFDictionary *v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  __CFDictionary *v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  __CFArray *v16;
  __CFDictionary *v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFNumberRef v20;
  const CFDictionaryValueCallBacks *v21;
  __CFDictionary *v22;
  CFNumberRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  __CFDictionary *v26;
  CFNumberRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  __CFDictionary *v30;
  CFNumberRef v31;
  CFNumberRef v32;
  CFNumberRef v33;
  __CFDictionary *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t i;
  CFStringRef v39;
  __CFDictionary *v40;
  CFNumberRef v41;
  CFNumberRef v42;
  CFNumberRef v43;
  CFNumberRef v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  CFStringRef v49;
  __CFDictionary *v50;
  CFNumberRef v51;
  CFNumberRef v52;
  CFNumberRef v53;
  CFStringRef v54;
  __CFDictionary *v55;
  CFNumberRef v56;
  CFNumberRef v57;
  CFNumberRef v58;
  _QWORD *v60;
  uint64_t v61;
  __CFArray *theArray;
  _QWORD *v63;
  int v64;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v4 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v64 = 0;
  valuePtr = 13;
  v63 = a1 + 8;
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v6 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  v7 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v4, CFSTR("name"), CFSTR("jointsCount"));
  CFDictionarySetValue(v4, CFSTR("type"), v5);
  CFDictionarySetValue(v4, CFSTR("address"), v7);
  CFDictionarySetValue(v4, CFSTR("semantic"), v6);
  CFArrayAppendValue(Mutable, v4);
  CFRelease(v6);
  CFRelease(v4);
  CFRelease(v7);
  CFRelease(v5);
  v8 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E0C9B3A0]);
  v64 = 0;
  valuePtr = 2;
  v63 = a1 + 9;
  v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  v11 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v8, CFSTR("name"), CFSTR("weightsCount"));
  CFDictionarySetValue(v8, CFSTR("type"), v9);
  CFDictionarySetValue(v8, CFSTR("address"), v11);
  CFDictionarySetValue(v8, CFSTR("semantic"), v10);
  CFArrayAppendValue(Mutable, v8);
  CFRelease(v10);
  CFRelease(v8);
  CFRelease(v11);
  CFRelease(v9);
  v12 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v64 = 0;
  valuePtr = 2;
  v63 = a1 + 10;
  v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  v15 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v12, CFSTR("name"), CFSTR("vertexCount"));
  v16 = Mutable;
  CFDictionarySetValue(v12, CFSTR("type"), v13);
  CFDictionarySetValue(v12, CFSTR("address"), v15);
  CFDictionarySetValue(v12, CFSTR("semantic"), v14);
  CFArrayAppendValue(Mutable, v12);
  CFRelease(v14);
  CFRelease(v12);
  CFRelease(v15);
  CFRelease(v13);
  v60 = a1;
  if (a1[11])
  {
    v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v64 = 0;
    valuePtr = 10;
    v63 = (_QWORD *)a1[11];
    v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
    v20 = CFNumberCreate(0, kCFNumberLongType, &v63);
    CFDictionarySetValue(v17, CFSTR("name"), CFSTR("inverseBindMatrices"));
    CFDictionarySetValue(v17, CFSTR("type"), v18);
    CFDictionarySetValue(v17, CFSTR("address"), v20);
    CFDictionarySetValue(v17, CFSTR("semantic"), v19);
    CFArrayAppendValue(v16, v17);
    CFRelease(v19);
    CFRelease(v17);
    CFRelease(v20);
    CFRelease(v18);
  }
  v21 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v22 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v64 = 0;
  valuePtr = 10;
  v63 = a1 + 14;
  v23 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v24 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  v25 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v22, CFSTR("name"), CFSTR("defaultShapeMatrix"));
  CFDictionarySetValue(v22, CFSTR("type"), v23);
  CFDictionarySetValue(v22, CFSTR("address"), v25);
  CFDictionarySetValue(v22, CFSTR("semantic"), v24);
  CFArrayAppendValue(v16, v22);
  CFRelease(v24);
  CFRelease(v22);
  CFRelease(v25);
  CFRelease(v23);
  v26 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], v21);
  v64 = 0;
  valuePtr = 13;
  v63 = a1 + 25;
  v27 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v28 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  v29 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v26, CFSTR("name"), CFSTR("maxInfluencesPerVertex"));
  CFDictionarySetValue(v26, CFSTR("type"), v27);
  CFDictionarySetValue(v26, CFSTR("address"), v29);
  CFDictionarySetValue(v26, CFSTR("semantic"), v28);
  CFArrayAppendValue(v16, v26);
  CFRelease(v28);
  CFRelease(v26);
  CFRelease(v29);
  CFRelease(v27);
  v30 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], v21);
  v64 = 2;
  valuePtr = 5;
  v63 = a1 + 26;
  v31 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v32 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  v33 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v30, CFSTR("name"), CFSTR("influencingMorpher"));
  CFDictionarySetValue(v30, CFSTR("type"), v31);
  CFDictionarySetValue(v30, CFSTR("address"), v33);
  CFDictionarySetValue(v30, CFSTR("semantic"), v32);
  theArray = v16;
  CFArrayAppendValue(v16, v30);
  CFRelease(v32);
  v34 = v30;
  v35 = a1;
  CFRelease(v34);
  CFRelease(v33);
  CFRelease(v31);
  if (a1[22])
  {
    v36 = a1[10];
    if (v36 >= 1)
    {
      v37 = 0;
      for (i = 0; i != v36; ++i)
      {
        v39 = CFStringCreateWithFormat(0, 0, CFSTR("vertexWeightIndices[%d]"), i);
        v40 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v64 = 0;
        valuePtr = 2;
        v63 = (_QWORD *)(v35[22] + v37);
        v41 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
        v42 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
        v43 = CFNumberCreate(0, kCFNumberLongType, &v63);
        CFDictionarySetValue(v40, CFSTR("name"), v39);
        CFDictionarySetValue(v40, CFSTR("type"), v41);
        CFDictionarySetValue(v40, CFSTR("address"), v43);
        CFDictionarySetValue(v40, CFSTR("semantic"), v42);
        CFArrayAppendValue(theArray, v40);
        v44 = v42;
        v35 = v60;
        CFRelease(v44);
        CFRelease(v40);
        CFRelease(v43);
        CFRelease(v41);
        CFRelease(v39);
        v37 += 8;
      }
    }
  }
  if (v35[24])
  {
    v45 = v35;
    if (v35[23])
    {
      if ((uint64_t)v35[9] >= 1)
      {
        v46 = 0;
        v47 = 0;
        v48 = 0;
        v61 = v35[9];
        do
        {
          v49 = CFStringCreateWithFormat(0, 0, CFSTR("vertexWeights[%d]"), v48);
          v50 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v64 = 0;
          valuePtr = 1;
          v63 = (_QWORD *)(v45[24] + v46);
          v51 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
          v52 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
          v53 = CFNumberCreate(0, kCFNumberLongType, &v63);
          CFDictionarySetValue(v50, CFSTR("name"), v49);
          CFDictionarySetValue(v50, CFSTR("type"), v51);
          CFDictionarySetValue(v50, CFSTR("address"), v53);
          CFDictionarySetValue(v50, CFSTR("semantic"), v52);
          CFArrayAppendValue(theArray, v50);
          CFRelease(v52);
          CFRelease(v50);
          CFRelease(v53);
          CFRelease(v51);
          CFRelease(v49);
          v54 = CFStringCreateWithFormat(0, 0, CFSTR("jointsForVertexWeights[%d]"), v48);
          v55 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v64 = 0;
          valuePtr = 13;
          v63 = (_QWORD *)(v45[23] + v47);
          v56 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
          v57 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
          v58 = CFNumberCreate(0, kCFNumberLongType, &v63);
          CFDictionarySetValue(v55, CFSTR("name"), v54);
          CFDictionarySetValue(v55, CFSTR("type"), v56);
          CFDictionarySetValue(v55, CFSTR("address"), v58);
          CFDictionarySetValue(v55, CFSTR("semantic"), v57);
          CFArrayAppendValue(theArray, v55);
          CFRelease(v57);
          CFRelease(v55);
          CFRelease(v58);
          CFRelease(v56);
          CFRelease(v54);
          ++v48;
          v47 += 2;
          v46 += 4;
        }
        while (v61 != v48);
      }
    }
  }
  return theArray;
}

uint64_t sub_1B18F1B88(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v10;

  v10 = (const void *)sub_1B193E634(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B17987F8(v10, a2))
    return a1;
  else
    return sub_1B17C62B4(*(const void **)(a1 + 208), (uint64_t)a2);
}

uint64_t sub_1B18F1D20(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const char *v4;
  int v6;
  unsigned int v7;
  stat v9;

  memset(&v9, 0, sizeof(v9));
  v4 = (const char *)objc_msgSend_fileSystemRepresentation(a1, a2, a3, a4);
  if (!stat(v4, &v9) && (v9.st_mode & 0xF000) == 0x8000 && v9.st_size >= 1)
  {
    v6 = open(v4, 0, 511);
    if ((v6 & 0x80000000) == 0)
    {
      v7 = v6;
      if (!fstat(v6, &v9) && (v9.st_mode & 0xF000) == 0x8000 && v9.st_size >= 1)
        return v7;
      close(v7);
    }
  }
  return -1;
}

uLong sub_1B18F2F54(const Bytef *a1, uInt a2)
{
  uLong v4;

  v4 = crc32(0, 0, 0);
  return crc32(v4, a1, a2);
}

uint64_t sub_1B18F2F90(uint64_t a1, uint64_t a2)
{
  const void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  double v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  const __CFAllocator *v54;
  CFStringRef v55;
  CFStringRef v56;
  CFTypeRef v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  CFStringRef v72;
  CFStringRef v73;
  CFTypeRef v74;

  v3 = (const void *)sub_1B179FD44(CFSTR("CFXFXFloorPass.plist"));
  v10 = sub_1B18D5720(v3, a2, v4, v5, v6, v7, v8, v9);
  v11 = sub_1B18D63F0(v10, CFSTR("VFX_renderMirroredScene"));
  sub_1B19AE6CC(v11, (uint64_t)sub_1B18F31B8);
  sub_1B19AE6D4(v11, (uint64_t)sub_1B18F31C8);
  v12 = sub_1B18D63F0(v10, CFSTR("VFX_renderFloor"));
  sub_1B18DA474(v12, (uint64_t)sub_1B18F323C);
  v20 = sub_1B18695D0(a2, v13, v14, v15, v16, v17, v18, v19);
  v27 = sub_1B18D6464(v10, 0, v21, v22, v23, v24, v25, v26);
  v35 = v27;
  if (!v20)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v29, v30, v31, v32, v33, v34, (uint64_t)"floor");
    if (v35)
      goto LABEL_7;
    goto LABEL_6;
  }
  if (!v27)
  {
LABEL_6:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v29, v30, v31, v32, v33, v34, (uint64_t)"pass");
    goto LABEL_7;
  }
  v36 = sub_1B18DA2D0(v20, v28, v29, v30, v31, v32, v33, v34);
  *(double *)(v35 + 376) = v36;
  *(double *)(v35 + 384) = v36;
  v44 = sub_1B18DA398(v20, v37, v38, v39, v40, v41, v42, v43);
  if (v44)
    *(_BYTE *)(v35 + 176) = v44;
LABEL_7:
  sub_1B18F3610(a2, v45, v29, v30, v31, v32, v33, v34);
  v46 = sub_1B18D63F0(v10, CFSTR("VFX_renderFloor"));
  v53 = sub_1B19AE654(v46, CFSTR("u_floorReflectionColor"), v47, v48, v49, v50, v51, v52);
  v54 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v55 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("VFX-floor-color-%p"), a2);
  v56 = (CFStringRef)v53[9];
  if (v56 != v55)
  {
    if (v56)
    {
      CFRelease(v56);
      v53[9] = 0;
    }
    if (v55)
      v57 = CFRetain(v55);
    else
      v57 = 0;
    v53[9] = v57;
  }
  CFRelease(v55);
  if (sub_1B18DA1F0(v20, v58, v59, v60, v61, v62, v63, v64) != 0.0)
  {
    v71 = sub_1B19AE654(v46, CFSTR("u_floorReflectionDepth"), v65, v66, v67, v68, v69, v70);
    v72 = CFStringCreateWithFormat(v54, 0, CFSTR("VFX-floor-depth-%p"), a2);
    v73 = (CFStringRef)v71[9];
    if (v73 != v72)
    {
      if (v73)
      {
        CFRelease(v73);
        v71[9] = 0;
      }
      if (v72)
        v74 = CFRetain(v72);
      else
        v74 = 0;
      v71[9] = v74;
    }
    CFRelease(v72);
  }
  return v10;
}

CFTypeRef sub_1B18F31B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B19AD1A4(*(_QWORD *)a1, *(CFTypeRef *)(a1 + 16), a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B18F31C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  float v25;

  if (!a2)
    return 0;
  result = sub_1B18695D0(a2, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v16 = result;
    v24 = sub_1B18F37CC(a2, result, v10, v11, v12, v13, v14, v15);
    v25 = *(float *)(v16 + 236);
    *(float *)(v16 + 236) = v24;
    if (v25 == 1.0 && v24 != 1.0)
      sub_1B18F3610(a2, v17, v18, v19, v20, v21, v22, v23);
    return sub_1B18D9FEC(v16, v17, v18, v19, v20, v21, v22, v23) != 0.0;
  }
  return result;
}

void sub_1B18F323C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __n128 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __n128 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  float32x4_t v51;
  uint64_t v52;
  uint64_t v53;
  float v54;
  double v55;
  double v56;
  double v57;
  float32_t v58;
  int32x2_t v59;
  float v60;
  float v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int32x4_t v73;
  float32x2_t v74;
  float32x4_t v75;
  int32x4_t v76;
  int8x16_t v77;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  float v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  float v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  float32x4_t *v139;
  uint64_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  __n128 v145;
  __n128 v146;
  __n128 v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  __n128 v153;
  __n128 v154;
  float v155;
  float32x4_t v156;
  __n128 v157[4];
  __n128 v158;
  simd_float4 v159;
  simd_float4 v160;
  simd_float4 v161;
  simd_float4x4 v162;
  simd_float4x4 v163;

  v8 = a1[2];
  if (v8)
  {
    v10 = sub_1B18695D0(a1[2], a2, a3, a4, a5, a6, a7, a8);
    if (v10)
    {
      v18 = v10;
      v19 = (__n128 *)sub_1B1813884(a1[3], v11, v12, v13, v14, v15, v16, v17);
      v156.i32[2] = 0;
      v156.i64[0] = 0;
      sub_1B187AD68(v19, (__n128 *)&v156, v20, v21, v22, v23, v24, v25);
      sub_1B18D6A2C(a1[1], CFSTR("u_floorNormal"), &v156, v26, v27, v28, v29, v30);
      v36.n128_u32[0] = v156.u32[1];
      if (v156.f32[1] == 0.0 && (v36.n128_u32[0] = v156.u32[2], v156.f32[2] == 0.0))
      {
        v153.n128_u32[0] = 0;
        v153.n128_f32[1] = -v156.f32[0];
        v153.n128_u32[2] = 0;
        v153.n128_u32[3] = 1.0;
        v158 = v153;
      }
      else
      {
        v36.n128_u32[1] = 0;
        v36.n128_u32[2] = 0;
        v36.n128_u32[3] = 1.0;
        v158 = v36;
      }
      sub_1B18D6A2C(a1[1], CFSTR("u_floorTangent"), &v158, v31, v32, v33, v34, v35);
      v44 = sub_1B1814768((uint64_t *)a1[3], v37, v38, v39, v40, v41, v42, v43);
      if (v44)
      {
        v52 = (uint64_t)v44;
        if (sub_1B17B33F4((uint64_t)v44, (uint64_t)&v158, v45, v46, v47, v48, v49, v50))
        {
          v54 = v158.n128_f32[2];
          if (v158.n128_f32[2] < 10000.0)
            v54 = 10000.0;
          v55 = v54;
          if ((v158.n128_u8[0] & 1) != 0)
          {
            v57 = sqrt(v160.f32[2] * v160.f32[2] + v55 * v55);
          }
          else
          {
            v56 = cos(v160.f32[3] * 0.5 / 180.0 * 3.14159265);
            if (v56 <= 0.0)
              sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Fov is larger that 180 degrees. this can't be"), v53, v46, v47, v48, v49, v50, (uint64_t)"d > 0");
            v57 = (v55 + v55) / v56;
          }
          v157[0].n128_u32[2] = 0;
          v157[0].n128_u64[0] = 0;
          sub_1B186B5BC(v52, v157, v53, v46, v47, v48, v49, v50);
          v51 = (float32x4_t)v157[0];
          v58 = v57;
          v51.f32[3] = v58;
        }
      }
      v59 = vdup_laneq_s32((int32x4_t)v51, 3);
      v158 = (__n128)vmlsq_f32(v51, v156, v51);
      v157[0].n128_u64[0] = (unint64_t)v59;
      v60 = *(float *)(v18 + 228);
      if (v60 != 0.0)
      {
        v158.n128_u32[0] = 0;
        *(float *)v59.i32 = v60;
        v157[0].n128_u64[0] = (unint64_t)v59;
      }
      v61 = *(float *)(v18 + 232);
      if (v61 != 0.0)
      {
        v158.n128_u32[2] = 0;
        v157[0].n128_f32[1] = v61;
      }
      sub_1B18D6A2C(a1[1], CFSTR("u_floorCenter"), &v158, v46, v47, v48, v49, v50);
      sub_1B18D6A2C(a1[1], CFSTR("u_floorExtent"), v157, v62, v63, v64, v65, v66);
      v154 = sub_1B1815A98((__n128 *)a1[3]);
      v155 = sub_1B1815CC0(a1[3]);
      v67 = sub_1B179F7DC(a1[3]);
      v75 = (float32x4_t)v154;
      if (v67 >= 2)
      {
        *(float *)v73.i32 = (float)v67;
        v74.f32[0] = (float)a1[9];
        v76 = (int32x4_t)vextq_s8((int8x16_t)v154, (int8x16_t)v154, 8uLL);
        *(int32x2_t *)v76.i8 = vdup_lane_s32((int32x2_t)vmul_f32(*(float32x2_t *)v76.i8, *(float32x2_t *)v73.i8), 0);
        *(float32x2_t *)v73.i8 = vdiv_f32(v74, *(float32x2_t *)v73.i8);
        v76.i32[0] = v73.i32[0];
        v75 = (float32x4_t)vtrn2q_s32(vrev64q_s32(vzip1q_s32(v76, v73)), (int32x4_t)v154);
      }
      v77 = (int8x16_t)vmulq_n_f32(v75, v155);
      __asm { FMOV            V2.2S, #1.0 }
      v77.u64[1] = (unint64_t)vdiv_f32(_D2, (float32x2_t)*(_OWORD *)&vextq_s8(v77, v77, 8uLL));
      v158 = (__n128)v77;
      sub_1B18D6A2C(a1[1], CFSTR("u_floor_viewport"), &v158, v68, v69, v70, v71, v72);
      v158.n128_u32[0] = sub_1B18D9FEC(v18, v83, v84, v85, v86, v87, v88, v89);
      sub_1B18D6A2C(a1[1], CFSTR("u_floorReflectivity"), &v158, v90, v91, v92, v93, v94);
      v158.n128_u32[0] = sub_1B18DA110(v18, v95, v96, v97, v98, v99, v100, v101);
      sub_1B18D6A2C(a1[1], CFSTR("u_floorFalloffStart"), &v158, v102, v103, v104, v105, v106);
      v114 = sub_1B18DA1F0(v18, v107, v108, v109, v110, v111, v112, v113);
      v127 = v114 - sub_1B18DA110(v18, v115, v116, v117, v118, v119, v120, v121);
      if (v127 <= 0.0)
        v127 = 1.0;
      v158.n128_f32[0] = v127;
      sub_1B18D6A2C(a1[1], CFSTR("u_floorFalloff"), &v158, v122, v123, v124, v125, v126);
      sub_1B17B3860(v8, &v156, &v158, v128, v129, v130, v131, v132);
      sub_1B18D6A2C(a1[1], CFSTR("u_floorPlane"), &v158, v133, v134, v135, v136, v137);
      v138 = sub_1B1815A5C(a1[3], 1);
      v139 = (float32x4_t *)sub_1B1815A5C(a1[3], 0);
      v140 = 0;
      v141 = *v139;
      v142 = v139[1];
      v143 = v139[2];
      v144 = v139[3];
      v145 = *(__n128 *)(v138 + 16);
      v146 = *(__n128 *)(v138 + 32);
      v147 = *(__n128 *)(v138 + 48);
      v157[0] = *(__n128 *)v138;
      v157[1] = v145;
      v157[2] = v146;
      v157[3] = v147;
      do
      {
        *(float32x4_t *)((char *)&v158 + v140 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v141, COERCE_FLOAT(*(_OWORD *)&v157[v140])), v142, (float32x2_t)v157[v140].n128_u64[0], 1), v143, (float32x4_t)v157[v140], 2), v144, (float32x4_t)v157[v140], 3);
        ++v140;
      }
      while (v140 != 4);
      v162.columns[2] = v160;
      v162.columns[3] = v161;
      v162.columns[0] = (simd_float4)v158;
      v162.columns[1] = v159;
      v163 = __invert_f4(v162);
      v158 = (__n128)v163.columns[0];
      v159 = v163.columns[1];
      v160 = v163.columns[2];
      v161 = v163.columns[3];
      sub_1B18D6A2C(a1[1], CFSTR("u_floorMVP_i"), &v158, v148, v149, v150, v151, v152);
    }
  }
}

void sub_1B18F3610(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFTypeRef *v16;
  float v17;
  __CFArray *Mutable;
  const __CFString *v19;
  const void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  __CFDictionary *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const __CFString *v48;
  const void *v49;

  v9 = sub_1B18695D0(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v9)
  {
    v16 = (CFTypeRef *)v9;
    v17 = sub_1B18F37CC(a1, v9, v10, v11, v12, v13, v14, v15);
    Mutable = CFArrayCreateMutable(0, 4, MEMORY[0x1E0C9B378]);
    v19 = (const __CFString *)sub_1B19B83D4(CFSTR("FloorGeomImpl-metal.h"));
    v20 = (const void *)sub_1B19B9164(v19, 0, 0, 0, 0);
    CFArrayAppendValue(Mutable, v20);
    CFRelease(v20);
    if (sub_1B18D9FEC((uint64_t)v16, v21, v22, v23, v24, v25, v26, v27) > 0.0)
    {
      v33 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (sub_1B18DA1F0((uint64_t)v16, v34, v35, v36, v37, v38, v39, v40) != 0.0)
        CFDictionaryAddValue(v33, CFSTR("USE_FALLOFF"), &stru_1E63FD500);
      if (sub_1B18DA110((uint64_t)v16, v41, v42, v43, v44, v45, v46, v47) != 0.0)
        CFDictionaryAddValue(v33, CFSTR("USE_FALLOFF_START"), &stru_1E63FD500);
      if (v17 < 1.0)
        CFDictionaryAddValue(v33, CFSTR("USE_TRANSPARENCY"), &stru_1E63FD500);
      v48 = (const __CFString *)sub_1B19B83D4(CFSTR("FloorImpl-metal.h"));
      v49 = (const void *)sub_1B19B9164(v48, 2, v33, 0, 0);
      CFArrayAppendValue(Mutable, v49);
      CFRelease(v49);
      CFRelease(v33);
    }
    sub_1B193E9B8(v16, CFSTR("kShaderModifiers"), Mutable, v28, v29, v30, v31, v32);
    CFRelease(Mutable);
  }
}

float sub_1B18F37CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFArray *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"mirrorNode");
  v17 = 1.0;
  if (sub_1B18D9FEC(a2, a2, a3, a4, a5, a6, a7, a8) != 0.0)
  {
    sub_1B186C4A8(a1, v10, v11, v12, v13, v14, v15, v16);
    v17 = v18;
    v25 = sub_1B17A08FC(a2, 0, v19, v20, v21, v22, v23, v24);
    if (v25)
      sub_1B187813C((uint64_t)v25, v26, v27, v28, v29, v30, v31, v32);
  }
  return v17;
}

uint64_t sub_1B18F3854(uint64_t a1)
{
  return *(__int16 *)(a1 + 24);
}

uint64_t sub_1B18F385C(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 26);
}

void sub_1B18F3864()
{
  if (!qword_1EEF661D8)
  {
    qword_1EEF661D8 = sub_1B179CB60(&qword_1EEF661D8);
    qword_1ED4AF488 = (uint64_t)sub_1B18F3F88;
  }
}

uint64_t sub_1B18F38B4()
{
  if (qword_1EEF661E0 != -1)
    dispatch_once(&qword_1EEF661E0, &unk_1E63D1090);
  return sub_1B179CB90(qword_1EEF661D8, 0x30uLL);
}

uint64_t sub_1B18F38F8(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = sub_1B18F38B4();
  *(_WORD *)(v17 + 24) = a1;
  *(_WORD *)(v17 + 26) = a2;
  if (!a4)
    a4 = sub_1B179E250(a1, v10, v11, v12, v13, v14, v15, v16) * a2;
  *(_QWORD *)(v17 + 32) = a3;
  *(_QWORD *)(v17 + 40) = a4;
  *(_QWORD *)(v17 + 48) = a5;
  *(_QWORD *)(v17 + 56) = 0;
  return v17;
}

uint64_t sub_1B18F3960(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B179E720(*(__int16 *)(a1 + 24), *(unsigned __int16 *)(a1 + 26), a3, a4, a5, a6, a7, a8);
}

void *sub_1B18F3970(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  result = *(void **)(a1 + 16);
  if (result)
    return sub_1B18F59D8((uint64_t)result, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

uint64_t sub_1B18F39CC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

const UInt8 *sub_1B18F39D4(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFData *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;

  if (a1[4] <= a2)
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXSourceAccessorGetValuePtrAtIndex - index out of bounds : %d > %d"), a3, a4, a5, a6, a7, a8, a2);
  }
  else
  {
    v10 = (const __CFData *)sub_1B18F3970((uint64_t)a1, (const char *)a2, a3, a4, a5, a6, a7, a8);
    if (v10)
      return &CFDataGetBytePtr(v10)[a1[6] + a1[5] * a2];
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXSourceAccessorGetValuePtrAtIndex - no data"), v11, v12, v13, v14, v15, v16, v18);
  }
  return 0;
}

__CFData *sub_1B18F3A4C(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFData *result;

  if (a1[4] <= a2)
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXSourceAccessorGetMutableValuePtrAtIndex - index out of bounds : %d > %d"), a3, a4, a5, a6, a7, a8, a2);
    return 0;
  }
  else
  {
    result = (__CFData *)sub_1B18F3970((uint64_t)a1, (const char *)a2, a3, a4, a5, a6, a7, a8);
    if (result)
      return (__CFData *)&CFDataGetMutableBytePtr(result)[a1[6] + a1[5] * a2];
  }
  return result;
}

uint64_t sub_1B18F3AB8(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;

  if (a1[4] <= a2)
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXSourceAccessorGetVolatileValuePtrAtIndex - index out of bounds : %d > %d"), a3, a4, a5, a6, a7, a8, a2);
  }
  else
  {
    v8 = a1[2];
    if ((*(_BYTE *)(v8 + 88) & 4) != 0)
    {
      v10 = *(_QWORD *)(v8 + 72);
      if (v10)
        return v10 + a1[5] * a2;
    }
    else
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. cannot access volatile data on non volatile source"), a3, a4, a5, a6, a7, a8, (uint64_t)"accessor->_source->_dataIsVolatile");
    }
  }
  return 0;
}

uint64_t sub_1B18F3B34(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

uint64_t sub_1B18F3B3C(uint64_t a1)
{
  uint64_t result;

  result = sub_1B18F38F8(*(__int16 *)(a1 + 24), *(unsigned __int16 *)(a1 + 26), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
  return result;
}

uint64_t sub_1B18F3B74(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t sub_1B18F3B7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  v8 = *(unsigned __int16 *)(a1 + 26);
  return sub_1B179E250(*(__int16 *)(a1 + 24), a2, a3, a4, a5, a6, a7, a8) * v8;
}

uint64_t sub_1B18F3BA4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = a2;
  return result;
}

BOOL sub_1B18F3BAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;

  v8 = *(_QWORD *)(a1 + 40);
  v9 = *(unsigned __int16 *)(a1 + 26);
  return v8 != *(_QWORD *)(a1 + 56) + sub_1B179E250(*(__int16 *)(a1 + 24), a2, a3, a4, a5, a6, a7, a8) * v9;
}

uint64_t sub_1B18F3BF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned int v11;
  size_t v12;
  const __CFData *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFString *v21;
  __CFData *v22;
  uint64_t v23;
  __CFData *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const UInt8 *v37;
  const UInt8 *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  size_t v49;
  uint64_t result;
  uint64_t v51;

  if (*(unsigned __int16 *)(a1 + 24) != *(unsigned __int16 *)(a2 + 24))
    return 0;
  v10 = *(unsigned __int16 *)(a1 + 26);
  v11 = *(unsigned __int16 *)(a2 + 26);
  if (v10 > v11)
    return 0;
  v12 = *(_QWORD *)(a2 + 40) * *(_QWORD *)(a1 + 32);
  if (!v12)
    return 0;
  v14 = (const __CFData *)sub_1B18F3970(a2, (const char *)a2, a3, a4, a5, a6, a7, a8);
  if (v12 > CFDataGetLength(v14) - *(_QWORD *)(a2 + 40) * a3)
  {
    v21 = CFSTR("Error: The destination does not have enough room to copy this data");
LABEL_16:
    sub_1B17C4408(16, (uint64_t)v21, v15, v16, v17, v18, v19, v20, v51);
    return 0;
  }
  v22 = sub_1B18F3A4C((_QWORD *)a2, a3, v15, v16, v17, v18, v19, v20);
  if (!v22)
  {
    v21 = CFSTR("Error: error in CFXSourceAccessorCopyDataToAccessor");
    goto LABEL_16;
  }
  v24 = v22;
  v25 = *(_QWORD *)(a1 + 40);
  v26 = *(unsigned __int16 *)(a1 + 26);
  if (v25 == *(_QWORD *)(a1 + 56) + sub_1B179E250(*(__int16 *)(a1 + 24), v23, v15, v16, v17, v18, v19, v20) * v26)
  {
    v34 = *(_QWORD *)(a2 + 40);
    v35 = *(unsigned __int16 *)(a2 + 26);
    v36 = sub_1B179E250(*(__int16 *)(a2 + 24), v27, v28, v29, v30, v31, v32, v33);
    if (v11 <= v10 && v34 == *(_QWORD *)(a2 + 56) + v36 * v35)
    {
      v37 = sub_1B18F39D4((_QWORD *)a1, 0, v28, v29, v30, v31, v32, v33);
      memcpy(v24, v37, v12);
      return 1;
    }
  }
  v38 = sub_1B18F39D4((_QWORD *)a1, 0, v28, v29, v30, v31, v32, v33);
  v39 = *(unsigned __int16 *)(a1 + 26);
  v47 = sub_1B179E250(*(__int16 *)(a1 + 24), v40, v41, v42, v43, v44, v45, v46);
  if (*(uint64_t *)(a1 + 32) < 1)
    return 1;
  v48 = 0;
  v49 = v47 * v39;
  do
  {
    memcpy(v24, v38, v49);
    v38 += *(_QWORD *)(a1 + 40);
    v24 = (__CFData *)((char *)v24 + *(_QWORD *)(a2 + 40));
    ++v48;
    result = 1;
  }
  while (v48 < *(_QWORD *)(a1 + 32));
  return result;
}

uint64_t sub_1B18F3D80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  return *(_QWORD *)(a1 + 48);
}

void sub_1B18F3DC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  *(_QWORD *)(a1 + 48) = a2;
}

void sub_1B18F3E14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  *(_QWORD *)(a1 + 40) = a2;
}

uint64_t sub_1B18F3E60(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 56) = a2;
  return result;
}

uint64_t sub_1B18F3E68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  return *(_QWORD *)(a1 + 32) * *(_QWORD *)(a1 + 40);
}

uint64_t sub_1B18F3EB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  return sub_1B179E250(*(__int16 *)(a1 + 24), a2, a3, a4, a5, a6, a7, a8) * *(unsigned __int16 *)(a1 + 26);
}

CFStringRef sub_1B18F3F10(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXSourceAccessor %lx>"), a1);
}

CFStringRef sub_1B18F3F4C(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXSourceAccessor %lx>"), a1);
}

__CFArray *sub_1B18F3F88(uint64_t a1)
{
  __CFArray *Mutable;
  const CFDictionaryKeyCallBacks *v3;
  const CFDictionaryValueCallBacks *v4;
  __CFDictionary *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  __CFDictionary *v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  const CFDictionaryValueCallBacks *v13;
  __CFDictionary *v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  const CFDictionaryKeyCallBacks *v18;
  __CFDictionary *v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  __CFDictionary *v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  __CFDictionary *v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFNumberRef v30;
  __CFDictionary *v31;
  CFNumberRef v32;
  CFNumberRef v33;
  CFNumberRef v34;
  __CFDictionary *v35;
  CFNumberRef v36;
  CFNumberRef v37;
  CFNumberRef v38;
  uint64_t v40;
  int v41;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v41 = 0;
  valuePtr = 5;
  v40 = *(_QWORD *)(a1 + 16) + 64;
  v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v8 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v5, CFSTR("name"), CFSTR("accessor"));
  CFDictionarySetValue(v5, CFSTR("type"), v6);
  CFDictionarySetValue(v5, CFSTR("address"), v8);
  CFDictionarySetValue(v5, CFSTR("semantic"), v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v41 = 2;
  valuePtr = 5;
  v40 = *(_QWORD *)(a1 + 16) + 72;
  v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v12 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v9, CFSTR("name"), CFSTR("data"));
  CFDictionarySetValue(v9, CFSTR("type"), v10);
  CFDictionarySetValue(v9, CFSTR("address"), v12);
  CFDictionarySetValue(v9, CFSTR("semantic"), v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  v13 = v4;
  v14 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v41 = 0;
  valuePtr = 2;
  v40 = a1 + 24;
  v15 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v16 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v17 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v14, CFSTR("name"), CFSTR("type"));
  CFDictionarySetValue(v14, CFSTR("type"), v15);
  CFDictionarySetValue(v14, CFSTR("address"), v17);
  CFDictionarySetValue(v14, CFSTR("semantic"), v16);
  CFArrayAppendValue(Mutable, v14);
  CFRelease(v16);
  CFRelease(v14);
  CFRelease(v17);
  CFRelease(v15);
  v18 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v19 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], v13);
  v41 = 0;
  valuePtr = 2;
  v40 = a1 + 26;
  v20 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v21 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v22 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v19, CFSTR("name"), CFSTR("componentsCountPerValue"));
  CFDictionarySetValue(v19, CFSTR("type"), v20);
  CFDictionarySetValue(v19, CFSTR("address"), v22);
  CFDictionarySetValue(v19, CFSTR("semantic"), v21);
  CFArrayAppendValue(Mutable, v19);
  CFRelease(v21);
  CFRelease(v19);
  CFRelease(v22);
  CFRelease(v20);
  v23 = CFDictionaryCreateMutable(0, 4, v18, v13);
  v41 = 0;
  valuePtr = 2;
  v40 = a1 + 32;
  v24 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v25 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v26 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v23, CFSTR("name"), CFSTR("count"));
  CFDictionarySetValue(v23, CFSTR("type"), v24);
  CFDictionarySetValue(v23, CFSTR("address"), v26);
  CFDictionarySetValue(v23, CFSTR("semantic"), v25);
  CFArrayAppendValue(Mutable, v23);
  CFRelease(v25);
  CFRelease(v23);
  CFRelease(v26);
  CFRelease(v24);
  v27 = CFDictionaryCreateMutable(0, 4, v18, v13);
  v41 = 0;
  valuePtr = 2;
  v40 = a1 + 40;
  v28 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v29 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v30 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v27, CFSTR("name"), CFSTR("stride"));
  CFDictionarySetValue(v27, CFSTR("type"), v28);
  CFDictionarySetValue(v27, CFSTR("address"), v30);
  CFDictionarySetValue(v27, CFSTR("semantic"), v29);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v29);
  CFRelease(v27);
  CFRelease(v30);
  CFRelease(v28);
  v31 = CFDictionaryCreateMutable(0, 4, v18, v13);
  v41 = 0;
  valuePtr = 2;
  v40 = a1 + 48;
  v32 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v33 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v34 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v31, CFSTR("name"), CFSTR("offset"));
  CFDictionarySetValue(v31, CFSTR("type"), v32);
  CFDictionarySetValue(v31, CFSTR("address"), v34);
  CFDictionarySetValue(v31, CFSTR("semantic"), v33);
  CFArrayAppendValue(Mutable, v31);
  CFRelease(v33);
  CFRelease(v31);
  CFRelease(v34);
  CFRelease(v32);
  v35 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v41 = 0;
  valuePtr = 2;
  v40 = a1 + 56;
  v36 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v37 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v38 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v35, CFSTR("name"), CFSTR("padding"));
  CFDictionarySetValue(v35, CFSTR("type"), v36);
  CFDictionarySetValue(v35, CFSTR("address"), v38);
  CFDictionarySetValue(v35, CFSTR("semantic"), v37);
  CFArrayAppendValue(Mutable, v35);
  CFRelease(v37);
  CFRelease(v35);
  CFRelease(v38);
  CFRelease(v36);
  return Mutable;
}

uint64_t sub_1B18F4794(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  uint64_t EntityObjectWithTag;
  const char *v23;
  uint64_t v24;
  const void *v25;
  const void *v26;

  if ((_DWORD)a2)
  {
    if (!a1[12])
    {
      v10 = sub_1B17C6244(a1, a2, a3, a4, a5, a6, a7, a8);
      if (v10)
      {
        v18 = sub_1B187AA20(v10, v11, v12, v13, v14, v15, v16, v17);
        v19 = (void *)sub_1B181FEE0(v18);
        EntityObjectWithTag = objc_msgSend_fetchEntityObjectWithTag_(v19, v20, a1[8], v21);
        if (EntityObjectWithTag)
        {
          v25 = (const void *)EntityObjectWithTag;
          v26 = (const void *)a1[12];
          if (v26 != v25)
          {
            if (v26)
            {
              CFRelease(v26);
              a1[12] = 0;
            }
            a1[12] = CFRetain(v25);
          }
          objc_msgSend_addEntityObject_(v19, v23, (uint64_t)v25, v24);
        }
      }
    }
  }
  return a1[12];
}

uint64_t sub_1B18F4824()
{
  if (qword_1ED4CEC30 != -1)
    dispatch_once(&qword_1ED4CEC30, &unk_1E63D10B0);
  return qword_1ED4CEC38;
}

double sub_1B18F4864()
{
  double result;

  if (!qword_1ED4CEC38)
  {
    qword_1ED4CEC38 = sub_1B179CB60(&qword_1ED4CEC38);
    qword_1ED4BDC38 = (uint64_t)sub_1B18F4EE8;
    *(_QWORD *)&result = 0x1B18F5030;
    xmmword_1ED4BDC28 = xmmword_1E63D2ED0;
  }
  return result;
}

uint64_t sub_1B18F48C4(const void *a1)
{
  uint64_t v2;
  const void *v3;
  CFTypeRef v4;

  if (qword_1ED4CEC30 != -1)
    dispatch_once(&qword_1ED4CEC30, &unk_1E63D10B0);
  v2 = sub_1B179CB90(qword_1ED4CEC38, 0x58uLL);
  v3 = *(const void **)(v2 + 64);
  if (v3 != a1)
  {
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(v2 + 64) = 0;
    }
    if (a1)
      v4 = CFRetain(a1);
    else
      v4 = 0;
    *(_QWORD *)(v2 + 64) = v4;
  }
  return v2;
}

uint64_t sub_1B18F4950(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"handle");
  return *(_QWORD *)(a1 + 64);
}

uint64_t sub_1B18F4998(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef v10;
  CFTypeRef v11;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"handle");
  v10 = *(CFTypeRef *)(a1 + 64);
  if (v10 != cf)
  {
    if (v10)
    {
      CFRelease(v10);
      *(_QWORD *)(a1 + 64) = 0;
    }
    if (cf)
      v11 = CFRetain(cf);
    else
      v11 = 0;
    *(_QWORD *)(a1 + 64) = v11;
  }
  return objc_msgSend_setTag_(*(void **)(a1 + 96), (const char *)cf, (uint64_t)cf, a4);
}

uint64_t sub_1B18F4A18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  switch(a1)
  {
    case 1:
      result = 3;
      break;
    case 2:
    case 7:
      result = 15;
      break;
    case 3:
    case 8:
      result = 13;
      break;
    case 4:
    case 9:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      sub_1B17C4408(0, (uint64_t)CFSTR("Warning: binding type %d can't not be exposed"), a3, a4, a5, a6, a7, a8, a1);
      result = 0;
      break;
    case 5:
    case 6:
    case 10:
      result = 2;
      break;
    case 11:
      result = 6;
      break;
    case 12:
      result = 1;
      break;
    case 13:
      result = 7;
      break;
    case 14:
      result = 8;
      break;
    case 15:
      result = 9;
      break;
    case 16:
      result = 11;
      break;
    case 17:
      result = 10;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t sub_1B18F4ACC(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v10;
  void *Value;
  const char *v12;
  uint64_t v13;
  uint64_t v14;

  sub_1B18F4B14(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v10 = *(const __CFDictionary **)(a1 + 72);
  if (v10 && (Value = (void *)CFDictionaryGetValue(v10, a2)) != 0)
    return objc_msgSend_type(Value, v12, v13, v14);
  else
    return 0;
}

uint64_t sub_1B18F4B14(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  CFIndex v20;
  const char *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  VFXBindingWrapper *v39;
  const char *v40;
  uint64_t v41;
  CFIndex Count;
  const char *v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  __CFDictionary *v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;
  const void *v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  _BYTE v56[128];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(result + 88))
  {
    v8 = result;
    result = sub_1B18F4794((_QWORD *)result, 1, a3, a4, a5, a6, a7, a8);
    if (result)
    {
      *(_BYTE *)(v8 + 88) = 1;
      v12 = (void *)objc_msgSend_bindings((void *)result, v9, v10, v11);
      v16 = objc_msgSend_count(v12, v13, v14, v15);
      *(_QWORD *)(v8 + 72) = CFDictionaryCreateMutable(0, v16, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v20 = objc_msgSend_count(v12, v17, v18, v19);
      *(_QWORD *)(v8 + 80) = CFArrayCreateMutable(0, v20, MEMORY[0x1E0C9B378]);
      v52 = 0u;
      v53 = 0u;
      v54 = 0u;
      v55 = 0u;
      result = objc_msgSend_countByEnumeratingWithState_objects_count_(v12, v21, (uint64_t)&v52, (uint64_t)v56, 16);
      if (result)
      {
        v25 = result;
        v26 = *(_QWORD *)v53;
        do
        {
          v27 = 0;
          do
          {
            if (*(_QWORD *)v53 != v26)
              objc_enumerationMutation(v12);
            v28 = *(void **)(*((_QWORD *)&v52 + 1) + 8 * v27);
            v29 = objc_msgSend_type(v28, v22, v23, v24);
            v37 = sub_1B18F4A18(v29, v30, v31, v32, v33, v34, v35, v36);
            if ((_DWORD)v37)
            {
              v38 = v37;
              v39 = objc_alloc_init(VFXBindingWrapper);
              objc_msgSend_setBinding_(v39, v40, (uint64_t)v28, v41);
              Count = CFArrayGetCount(*(CFArrayRef *)(v8 + 80));
              objc_msgSend_setIndex_(v39, v43, Count, v44);
              objc_msgSend_setType_(v39, v45, v38, v46);
              CFArrayAppendValue(*(CFMutableArrayRef *)(v8 + 80), v39);
              v47 = *(__CFDictionary **)(v8 + 72);
              v51 = (const void *)objc_msgSend_bindingName(v28, v48, v49, v50);
              CFDictionaryAddValue(v47, v51, v39);

            }
            ++v27;
          }
          while (v25 != v27);
          result = objc_msgSend_countByEnumeratingWithState_objects_count_(v12, v22, (uint64_t)&v52, (uint64_t)v56, 16);
          v25 = result;
        }
        while (result);
      }
    }
  }
  return result;
}

const __CFDictionary *sub_1B18F4CE4(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  const __CFDictionary *result;
  const char *v12;
  uint64_t v13;
  uint64_t v14;

  v8 = a3;
  sub_1B18F4B14(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  result = *(const __CFDictionary **)(a1 + 72);
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, a2);
    if (result)
      return (const __CFDictionary *)(a1 + (int)(16 * objc_msgSend_index(result, v12, v13, v14)) + v8);
  }
  return result;
}

const __CFDictionary *sub_1B18F4D38(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *result;
  void *Value;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"handle");
  result = (const __CFDictionary *)sub_1B18F4B14(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (a3)
  {
    result = *(const __CFDictionary **)(a1 + 72);
    if (result)
    {
      Value = (void *)CFDictionaryGetValue(result, a2);
      v16 = (void *)objc_msgSend_binding(Value, v13, v14, v15);
      v17 = (void *)MEMORY[0x1E0C99D50];
      v25 = sub_1B191E41C(a3, v18, v19, v20, v21, v22, v23, v24);
      v33 = sub_1B191E340(a3, v26, v27, v28, v29, v30, v31, v32);
      v35 = objc_msgSend_dataWithBytesNoCopy_length_freeWhenDone_(v17, v34, v25, v33, 0);
      return (const __CFDictionary *)objc_msgSend_setRawValue_(v16, v36, v35, v37);
    }
  }
  return result;
}

uint64_t sub_1B18F4DFC(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"handle");
  v10 = sub_1B18F4794(a1, 1, a3, a4, a5, a6, a7, a8);
  return MEMORY[0x1E0DE7D20](v10, sel_setIsEnabled_, a2, v11);
}

id sub_1B18F4E58(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;
  const void *v10;
  const void *v11;

  v9 = (const void *)a1[9];
  if (v9)
  {
    CFRelease(v9);
    a1[9] = 0;
  }
  v10 = (const void *)a1[12];
  if (v10)
  {
    CFRelease(v10);
    a1[12] = 0;
  }
  v11 = (const void *)a1[10];
  if (v11)
  {
    CFRelease(v11);
    a1[10] = 0;
  }
  return sub_1B193E38C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
}

CFStringRef sub_1B18F4EA8(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXCoreEntityHandle>"));
}

CFStringRef sub_1B18F4EC8(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXCoreEntityHandle>"));
}

__CFArray *sub_1B18F4EE8(uint64_t a1)
{
  __CFArray *Mutable;
  __CFDictionary *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  uint64_t v8;
  int v9;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v9 = 1;
  valuePtr = 5;
  v8 = *(_QWORD *)(a1 + 64);
  v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v9);
  v6 = CFNumberCreate(0, kCFNumberLongType, &v8);
  CFDictionarySetValue(v3, CFSTR("name"), CFSTR("tag"));
  CFDictionarySetValue(v3, CFSTR("type"), v4);
  CFDictionarySetValue(v3, CFSTR("address"), v6);
  CFDictionarySetValue(v3, CFSTR("semantic"), v5);
  CFArrayAppendValue(Mutable, v3);
  CFRelease(v5);
  CFRelease(v3);
  CFRelease(v6);
  CFRelease(v4);
  return Mutable;
}

void sub_1B18F5030(uint64_t a1, int a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v10;
  int v11;
  const __CFString *v14;
  void *ValueAtIndex;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  signed int v34;
  void *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  void *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;

  v10 = a2 - a1;
  if (a2 - (int)a1 >= 0)
    v11 = a2 - a1;
  else
    v11 = a2 - a1 + 15;
  if (v10 < -15 || CFArrayGetCount(*(CFArrayRef *)(a1 + 80)) < (v11 >> 4))
  {
    v14 = CFSTR("Error: binding access(write) out of bounds");
LABEL_7:
    sub_1B17C4408(16, (uint64_t)v14, (uint64_t)a3, a4, a5, a6, a7, a8, a9);
    return;
  }
  ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), (v11 >> 4));
  v19 = (void *)objc_msgSend_binding(ValueAtIndex, v16, v17, v18);
  if (objc_msgSend_type(v19, v20, v21, v22) == 12)
  {
    v26 = objc_msgSend_dataWithBytesNoCopy_length_freeWhenDone_(MEMORY[0x1E0C99D50], v23, (uint64_t)a3, a4, 0);
    v30 = (void *)objc_msgSend_binding(ValueAtIndex, v27, v28, v29);
    v33 = v26;
  }
  else
  {
    v34 = v10 - (v11 & 0xFFFFFFF0);
    v35 = (void *)objc_msgSend_binding(ValueAtIndex, v23, v24, v25);
    v39 = (void *)objc_msgSend_rawValue(v35, v36, v37, v38);
    if (a4 + 4 * v34 > objc_msgSend_length(v39, v40, v41, v42))
    {
      v14 = CFSTR("Error: binding access(write) out of bounds (2)");
      goto LABEL_7;
    }
    v44 = (void *)objc_msgSend_mutableCopy(v39, v43, (uint64_t)a3, a4);
    v48 = objc_msgSend_mutableBytes(v44, v45, v46, v47);
    memcpy((void *)(v48 + 4 * v34), a3, a4);
    v30 = (void *)objc_msgSend_binding(ValueAtIndex, v49, v50, v51);
    v33 = (uint64_t)v44;
  }
  objc_msgSend_setRawValue_(v30, v31, v33, v32);
}

void sub_1B18F5160(uint64_t a1, int a2, void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v10;
  int v11;
  const __CFString *v14;
  unsigned int v15;
  void *ValueAtIndex;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  const char *v25;
  const void *v26;

  v10 = a2 - a1;
  if (a2 - (int)a1 >= 0)
    v11 = a2 - a1;
  else
    v11 = a2 - a1 + 15;
  if (v10 < -15 || CFArrayGetCount(*(CFArrayRef *)(a1 + 80)) < (v11 >> 4))
  {
    v14 = CFSTR("Error: binding access(read) out of bounds");
LABEL_7:
    sub_1B17C4408(16, (uint64_t)v14, (uint64_t)a3, a4, a5, a6, a7, a8, a9);
    return;
  }
  v15 = v10 - (v11 & 0xFFFFFFF0);
  ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), (v11 >> 4));
  v20 = (void *)objc_msgSend_binding(ValueAtIndex, v17, v18, v19);
  v24 = (void *)objc_msgSend_rawValue(v20, v21, v22, v23);
  if (v15 < 0x10)
  {
    v26 = (const void *)(objc_msgSend_bytes(v24, v25, (uint64_t)a3, a4) + 4 * v15);
    memcpy(a3, v26, a4);
  }
  else if ((byte_1EEF661E8 & 1) == 0)
  {
    byte_1EEF661E8 = 1;
    v14 = CFSTR("Error: _CFXCoreEntityHandleGetValue - reading memory out of bounds");
    goto LABEL_7;
  }
}

id sub_1B18F524C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;
  const void *v10;

  if (*(_QWORD *)(a1 + 80) || (*(_BYTE *)(a1 + 88) & 4) == 0)
  {
    v9 = *(const void **)(a1 + 72);
    if (v9)
    {
      CFRelease(v9);
      *(_QWORD *)(a1 + 72) = 0;
    }
  }
  v10 = *(const void **)(a1 + 64);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 64) = 0;
  }
  return sub_1B193E38C(a1, a2, a3, a4, a5, a6, a7, a8);
}

CFStringRef sub_1B18F52A0(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXGenericSource %lx>"), a1);
}

uint64_t sub_1B18F52DC()
{
  if (qword_1ED4CEC98 != -1)
    dispatch_once(&qword_1ED4CEC98, &unk_1E63D10D0);
  return qword_1ED4CECA0;
}

double sub_1B18F531C()
{
  double result;

  if (!qword_1ED4CECA0)
  {
    qword_1ED4CECA0 = sub_1B179CB60(&qword_1ED4CECA0);
    qword_1ED4BE0B0 = (uint64_t)sub_1B18F5DE4;
    *(_QWORD *)&result = 0x1B18F5E18;
    xmmword_1ED4BE060 = xmmword_1E63D2F60;
  }
  return result;
}

uint64_t sub_1B18F537C()
{
  if (qword_1ED4CEC98 != -1)
    dispatch_once(&qword_1ED4CEC98, &unk_1E63D10D0);
  return sub_1B179CB90(qword_1ED4CECA0, 0x50uLL);
}

uint64_t sub_1B18F53C0(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  v15 = sub_1B18F537C();
  if (!v15)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v9, v10, v11, v12, v13, v14, (uint64_t)"genericSource");
  sub_1B18F543C(v15, a1, v9, v10, v11, v12, v13, v14);
  return v15;
}

CFTypeRef sub_1B18F543C(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
    if (a1)
      goto LABEL_3;
LABEL_5:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    goto LABEL_3;
  }
  if (!a1)
    goto LABEL_5;
LABEL_3:
  *(_QWORD *)(a1 + 64) = cf;
  return CFRetain(cf);
}

uint64_t sub_1B18F54B4(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFIndex v18;
  __CFData *Mutable;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  CFIndex v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  v17 = sub_1B18F53C0(a1, a2, a3, a4, a5, a6, a7, a8);
  *(_BYTE *)(v17 + 88) |= 1u;
  if (v8)
  {
    v18 = sub_1B18F3E68((uint64_t)a1, v10, v11, v12, v13, v14, v15, v16);
    Mutable = CFDataCreateMutable(0, v18);
    v27 = sub_1B18F3E68((uint64_t)a1, v20, v21, v22, v23, v24, v25, v26);
    CFDataSetLength(Mutable, v27);
    sub_1B18F5564(v17, Mutable, v28, v29, v30, v31, v32, v33);
    CFRelease(Mutable);
  }
  return v17;
}

CFTypeRef sub_1B18F5564(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  if ((*(_BYTE *)(a1 + 88) & 4) != 0)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. cannot set data to volatile source"), a3, a4, a5, a6, a7, a8, (uint64_t)"!genericSource->_dataIsVolatile");
  if (*(_QWORD *)(a1 + 80))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. cannot set data to MTL buffer"), a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource->_mtlVertexFormat == 0");
  result = *(CFTypeRef *)(a1 + 72);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 72) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 72) = result;
  }
  return result;
}

void sub_1B18F5624(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  *(_QWORD *)(a1 + 72) = a2;
  *(_QWORD *)(a1 + 80) = a3;
}

void sub_1B18F567C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const UInt8 *v17;
  unint64_t v18;
  unsigned __int8 v19;
  uint64_t v20;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  UInt8 *v38;
  int v39;
  const void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const void *v49;
  __CFData *v50;
  UInt8 *MutableBytePtr;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const __CFData *v58;
  CFMutableDataRef MutableCopy;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  CFIndex capacity;

  if (sub_1B18F3BAC(*(_QWORD *)(a1 + 64), a2, a3, a4, a5, a6, a7, a8))
  {
    v17 = sub_1B18F5884(a1, v10, v11, v12, v13, v14, v15, v16);
    v19 = BYTE5(v18);
    v20 = v18;
    v21 = (const void *)sub_1B18F38F8(BYTE6(v18), HIBYTE(v18), v18, 0, 0);
    sub_1B185D040(a2, v21);
    sub_1B18F3B34((uint64_t)v21, a2);
    CFRelease(v21);
    if (v17)
    {
      v29 = sub_1B18F3EB4(*(_QWORD *)(a1 + 64), v22, v23, v24, v25, v26, v27, v28);
      Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v29 * v20);
      CFDataSetLength(Mutable, v29 * v20);
      BytePtr = CFDataGetBytePtr(Mutable);
      if (v20)
      {
        v38 = (UInt8 *)BytePtr;
        v39 = 0;
        do
        {
          memcpy(v38, &v17[v39], v29);
          v39 += v19;
          v38 += v29;
          --v20;
        }
        while (v20);
      }
      sub_1B18F5564(a2, Mutable, v32, v33, v34, v35, v36, v37);
      CFRelease(Mutable);
    }
  }
  else
  {
    v40 = (const void *)sub_1B18F3B3C(*(_QWORD *)(a1 + 64));
    sub_1B185D040(a2, v40);
    sub_1B18F3B34((uint64_t)v40, a2);
    CFRelease(v40);
    if (*(_QWORD *)(a1 + 80))
    {
      sub_1B17C4408(0, (uint64_t)CFSTR("Warning: Cannot duplicate a Metal Buffer source. Create an empty data instead."), v41, v42, v43, v44, v45, v46, v66);
      capacity = 0;
      v49 = (const void *)sub_1B179FDE0(*(void **)(a1 + 72), (char *)&capacity, v47, v48);
      v50 = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], capacity);
      CFDataSetLength(v50, capacity);
      MutableBytePtr = CFDataGetMutableBytePtr(v50);
      memcpy(MutableBytePtr, v49, capacity);
      sub_1B18F5564(a2, v50, v52, v53, v54, v55, v56, v57);
      CFRelease(v50);
    }
    else
    {
      v58 = *(const __CFData **)(a1 + 72);
      if (v58)
      {
        MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v58);
        sub_1B18F5564(a2, MutableCopy, v60, v61, v62, v63, v64, v65);
        CFRelease(MutableCopy);
      }
    }
  }
}

const UInt8 *sub_1B18F5884(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const UInt8 *v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v8 = *(_QWORD **)(a1 + 64);
  if (sub_1B18F3970((uint64_t)v8, a2, a3, a4, a5, a6, a7, a8))
    v15 = sub_1B18F39D4(v8, 0, v9, v10, v11, v12, v13, v14);
  else
    v15 = 0;
  sub_1B18F39CC((uint64_t)v8);
  sub_1B18F3B74((uint64_t)v8);
  v16 = sub_1B18F3854((uint64_t)v8);
  v17 = sub_1B18F385C((uint64_t)v8);
  if (v16 != sub_1B179E600(v16, v18, v19, v20, v21, v22, v23, v24))
    sub_1B179E64C(v16, v25, v26, v27, v28, v29, v30, v31);
  sub_1B179E720(v16, v17, v26, v27, v28, v29, v30, v31);
  return v15;
}

void sub_1B18F5950(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B18F567C(a1, a2, a3, a4, a5, a6, a7, a8);
  *(_BYTE *)(a2 + 88) |= 1u;
}

uint64_t sub_1B18F597C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  v9 = sub_1B18F537C();
  sub_1B18F567C(a1, v9, v10, v11, v12, v13, v14, v15);
  return v9;
}

void *sub_1B18F59D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  result = *(void **)(a1 + 72);
  if (*(_QWORD *)(a1 + 80))
    return (void *)sub_1B179FE0C(result, a2, a3, a4);
  return result;
}

void *sub_1B18F5A34(_QWORD *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  result = (void *)a1[9];
  if (a1[10])
    return (void *)sub_1B179FE0C(result, a2, a3, a4);
  if (!result)
  {
    result = (void *)a1[8];
    if (result)
      return sub_1B18F3970((uint64_t)result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t sub_1B18F5AAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  if (*(_QWORD *)(a1 + 80))
    return *(_QWORD *)(a1 + 72);
  else
    return 0;
}

void sub_1B18F5B04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  if ((*(_BYTE *)(a1 + 88) & 4) == 0)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. cannot set volatile data to non volatile source"), a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource->_dataIsVolatile");
  if (*(_QWORD *)(a1 + 80))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. cannot set volatile data to MTL buffer"), a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource->_mtlVertexFormat == 0");
  *(_QWORD *)(a1 + 72) = a2;
}

uint64_t sub_1B18F5B98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"source");
  return *(_QWORD *)(a1 + 64);
}

uint64_t sub_1B18F5BE0(uint64_t a1)
{
  return *(_BYTE *)(a1 + 88) & 1;
}

uint64_t sub_1B18F5BEC(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 88) >> 2) & 1;
}

uint64_t sub_1B18F5BF8(uint64_t result)
{
  *(_BYTE *)(result + 88) &= ~1u;
  return result;
}

uint64_t sub_1B18F5C08(uint64_t result)
{
  *(_BYTE *)(result + 88) |= 1u;
  return result;
}

BOOL sub_1B18F5C18(uint64_t *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return !a1[10] && a1[9] && sub_1B18F3970(a1[8], a2, a3, a4, a5, a6, a7, a8) == (void *)a1[9];
}

void sub_1B18F5C60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"source");
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a1 + 88) & 0xFD | (2 * (a2 != 0));
  if (a2)
  {
    v10 = (const __CFDictionary *)sub_1B191E394(5, a2, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)sub_1B191E41C((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17) = a2;
    sub_1B193E9B8((CFTypeRef *)a1, CFSTR("listener"), v10, v18, v19, v20, v21, v22);
    if (v10)
      CFRelease(v10);
  }
  else
  {
    sub_1B193E9B8((CFTypeRef *)a1, CFSTR("listener"), 0, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B18F5D34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"source");
  if ((*(_BYTE *)(a1 + 88) & 2) == 0)
    return 0;
  result = (uint64_t)sub_1B193E800(a1, CFSTR("listener"), a3, a4, a5, a6, a7, a8);
  if (result)
  {
    result = sub_1B191E41C(result, v10, v11, v12, v13, v14, v15, v16);
    if (result)
      return *(_QWORD *)result;
  }
  return result;
}

CFStringRef sub_1B18F5DA8(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXGenericSource %lx>"), a1);
}

uint64_t sub_1B18F5DE4(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v10;

  v10 = (const void *)sub_1B193E634(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B17987F8(v10, a2))
    return a1;
  else
    return 0;
}

uint64_t sub_1B18F5E18(uint64_t a1, void *__s1, void *__s2, size_t __n)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  result = memcmp(__s1, __s2, __n);
  if ((_DWORD)result)
  {
    memcpy(__s1, __s2, __n);
    result = sub_1B18F5D34(a1, v9, v10, v11, v12, v13, v14, v15);
    if (result)
      return (uint64_t)sub_1B17C5AF4((CFTypeRef)result, a1, v16, v17, v18, v19, v20, v21);
  }
  return result;
}

uint64_t sub_1B18F6628(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  const char *v6;
  uint64_t v7;
  VFXMTLLibrary *v8;
  const char *v9;
  uint64_t result;

  v5 = (void *)objc_msgSend_mainBundle(MEMORY[0x1E0CB34D0], a2, a3, a4);
  v7 = objc_msgSend_pathForResource_ofType_(v5, v6, (uint64_t)CFSTR("default"), (uint64_t)CFSTR("metallib"));
  v8 = [VFXMTLLibrary alloc];
  result = objc_msgSend_initWithPath_manager_(v8, v9, v7, *(_QWORD *)(a1 + 32));
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = result;
  return result;
}

void sub_1B18F675C(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_1B18F676C(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t sub_1B18F6778(uint64_t *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  VFXMTLLibrary *v9;
  const char *v10;
  const char *v11;
  uint64_t result;

  v8 = (void *)objc_msgSend_objectForKey_(*(void **)(a1[4] + 72), a2, a1[5], a4);
  if (!v8)
  {
    v9 = [VFXMTLLibrary alloc];
    v8 = (void *)objc_msgSend_initWithPath_manager_(v9, v10, a1[5], a1[4]);
    objc_msgSend_setObject_forKey_(*(void **)(a1[4] + 72), v11, (uint64_t)v8, a1[5]);

  }
  result = objc_msgSend_library(v8, v5, v6, v7);
  *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40) = result;
  return result;
}

dispatch_queue_t sub_1B18F6E2C()
{
  NSObject *v0;
  NSObject *v1;
  dispatch_queue_t result;

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v1 = dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_USER_INITIATED, 0);
  result = dispatch_queue_create("com.apple.vfx.shader-collection-queue", v1);
  qword_1EEF661F8 = (uint64_t)result;
  return result;
}

void sub_1B18F6E6C(uint64_t a1, const char *a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  _QWORD v10[5];
  _QWORD v11[4];
  __int128 v12;

  v3 = MEMORY[0x1E0C809B0];
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = sub_1B18F6F20;
  v11[3] = &unk_1E63D8E00;
  v12 = *(_OWORD *)(a1 + 32);
  v4 = (void *)objc_msgSend_generatorWithProfile_allowingHotReload_(VFXCommonProfileProgramGenerator, a2, 0, 0);
  v6 = *(_QWORD *)(a1 + 56);
  v5 = *(_QWORD *)(a1 + 64);
  v7 = *(_QWORD *)(a1 + 40);
  v8 = *(_QWORD *)(a1 + 48);
  v10[0] = v3;
  v10[1] = 3221225472;
  v10[2] = sub_1B18F6FB4;
  v10[3] = &unk_1E63D8E28;
  v10[4] = *(_QWORD *)(a1 + 32);
  objc_msgSend_collectShaderForProgram_hashCode_newVertexFunctionName_newFragmentFunctionName_sourceCodeBlock_additionalFileBlock_(v4, v9, v5, v7, v8, v6, v11, v10);
  CFRelease(*(CFTypeRef *)(a1 + 64));
}

void sub_1B18F6F20(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;

  v5 = *(void **)(a1 + 32);
  v22 = *(_QWORD *)(a1 + 40);
  v23 = 0;
  v6 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], a2, (uint64_t)CFSTR("commonProfile_%@.metal"), a4, v22);
  v9 = objc_msgSend_URLByAppendingPathComponent_(v5, v7, v6, v8);
  if (objc_msgSend_writeToURL_atomically_encoding_error_(a2, v10, v9, 1, 4, &v23))
    v14 = v23 == 0;
  else
    v14 = 0;
  if (!v14)
  {
    v15 = objc_msgSend_localizedDescription(v23, v11, v12, v13);
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Failed to collect shader: %@"), v16, v17, v18, v19, v20, v21, v15);
  }
}

void sub_1B18F6FB4(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t PathComponent;
  const char *v34;
  const char *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;

  v46 = 0;
  v6 = (void *)objc_msgSend_URLByAppendingPathComponent_(*(void **)(a1 + 32), a2, a3, a4);
  v10 = (void *)objc_msgSend_defaultManager(MEMORY[0x1E0CB3620], v7, v8, v9);
  v14 = objc_msgSend_path(v6, v11, v12, v13);
  if (objc_msgSend_fileExistsAtPath_(v10, v15, v14, v16))
  {
    v20 = (void *)objc_msgSend_stringWithContentsOfURL_encoding_error_(MEMORY[0x1E0CB3940], v17, (uint64_t)v6, 4, 0);
    if ((objc_msgSend_isEqualToString_(v20, v21, (uint64_t)a2, v22) & 1) == 0)
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: Failed to collect shader: additional file \"%@\" is not always the same"), v23, v24, v25, v26, v27, v28, a3);
  }
  else
  {
    v29 = (void *)objc_msgSend_defaultManager(MEMORY[0x1E0CB3620], v17, v18, v19);
    PathComponent = objc_msgSend_URLByDeletingLastPathComponent(v6, v30, v31, v32);
    objc_msgSend_createDirectoryAtURL_withIntermediateDirectories_attributes_error_(v29, v34, PathComponent, 1, 0, 0);
    if (!objc_msgSend_writeToURL_atomically_encoding_error_(a2, v35, (uint64_t)v6, 1, 4, &v46) || v46)
    {
      v45 = objc_msgSend_localizedDescription(v46, v36, v37, v38);
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: Failed to collect shader: %@"), v39, v40, v41, v42, v43, v44, v45);
    }
  }
}

void sub_1B18F70C4(uint64_t a1, const char *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v11;
  uint64_t v12;
  void (**v13)(_QWORD, void *, uint64_t);
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(_QWORD, void *, uint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  os_signpost_id_t v28;
  NSObject *v29;
  int v30;
  uint8_t buf[4];
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v11 = *(void **)(a1 + 136);
    if (v11)
      objc_msgSend_setObject_forKeyedSubscript_(v11, a2, (uint64_t)a3, *(_QWORD *)(a1 + 32));
  }
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 88));
    if (!CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 40) + 80), *(const void **)(a1 + 48)))
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 40) + 80), *(const void **)(a1 + 48), a2);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 88));
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 168);
    if (v12
      && (v13 = (void (**)(_QWORD, void *, uint64_t))sub_1B181E898(v12, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8)) != 0&& (v18 = *v13) != 0)
    {
      v19 = sub_1B181E8E0(*(_QWORD *)(a1 + 168), (uint64_t)a2, (uint64_t)a3, a4, v14, v15, v16, v17);
      v18(0, a3, v19);
    }
    else
    {
      v20 = objc_msgSend_description(a3, a2, (uint64_t)a3, a4);
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: failed compiling shader:\n%@"), v21, v22, v23, v24, v25, v26, v20);
    }
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
  v27 = sub_1B17C439C();
  v28 = *(_QWORD *)(a1 + 176);
  if (v28 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v29 = v27;
    if (os_signpost_enabled(v27))
    {
      v30 = *(_DWORD *)(a1 + 184);
      *(_DWORD *)buf = 67109120;
      v32 = v30;
      _os_signpost_emit_with_name_impl(&dword_1B178D000, v29, OS_SIGNPOST_INTERVAL_END, v28, "CompileShader", "programID=%d", buf, 8u);
    }
  }
}

void sub_1B18F7250(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3;
  NSObject *v4;
  _QWORD v5[6];
  __int128 v6;

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = sub_1B18F72B0;
  v5[3] = &unk_1E63D8EA0;
  v3 = *(_OWORD *)(a1 + 32);
  v4 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  v5[4] = a2;
  v5[5] = a3;
  v6 = v3;
  dispatch_async(v4, v5);
}

void sub_1B18F72B0(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
  dispatch_group_leave(*(dispatch_group_t *)(*(_QWORD *)(a1 + 48) + 48));
}

void sub_1B18F72E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *v4;
  _QWORD block[7];

  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_1B18F7340;
  block[3] = &unk_1E63D8EF0;
  block[5] = a3;
  block[6] = v3;
  block[4] = a2;
  dispatch_async(v4, block);
}

uint64_t sub_1B18F7340(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

__n128 sub_1B18F7354(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  __n128 result;

  v7 = CFX::RG::Pass::Pass(a1, a2, a3, *a4, 4, a5, a6);
  *(_QWORD *)v7 = &off_1E63CE520;
  result = *(__n128 *)a4;
  *(_OWORD *)(v7 + 360) = *(_OWORD *)a4;
  return result;
}

uint64_t sub_1B18F739C(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  switch(a3)
  {
    case 2:
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 56))(result, a2, a4 + 8);
    case 1:
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
    case 0:
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  }
  return result;
}

void sub_1B18F73E0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B18F740C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E63CEBD0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 424) = 0;
  *(_QWORD *)(a1 + 432) = 0;
  *(_QWORD *)(a1 + 16) = a2;
  v9 = sub_1B1813884(a2, a2, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)(a1 + 24) = v9;
  v17 = sub_1B187B1D0(v9, v10, v11, v12, v13, v14, v15, v16);
  *(_QWORD *)(a1 + 32) = v17;
  *(_WORD *)(a1 + 48) = 15;
  sub_1B19D7DD8(v17, 0xFu);
  return a1;
}

void sub_1B18F749C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  id *v2;
  void *v4;

  v4 = *(void **)(v1 + 432);
  if (v4)

  if (*v2)
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B18F74C0(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = &off_1E63CEBD0;
  sub_1B19D7E4C(*(int16x4_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 48));
  v2 = *(void **)(a1 + 432);
  if (v2)

  v3 = *(void **)(a1 + 424);
  if (v3)

  return a1;
}

void sub_1B18F7510(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;
  void *v4;

  v3 = *(void **)(v1 + 432);
  if (v3)

  v4 = *(void **)(v1 + 424);
  if (v4)

  _Unwind_Resume(exception_object);
}

void sub_1B18F7538(uint64_t a1)
{
  sub_1B18F74C0(a1);
  JUMPOUT(0x1B5E22E18);
}

void sub_1B18F755C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CFDictionary *v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  id v57;
  const char *v58;
  const char *v59;
  const char *v60;
  const char *v61;
  const char *v62;
  uint64_t v63;
  const char *v64;
  uint64_t v65;
  void *v66;
  _BOOL4 v67;
  unsigned int v68;
  char v69;
  __int16 v70;

  v9 = (void *)sub_1B1813BC4(a1[2], a2, a3, a4, a5, a6, a7, a8);
  v13 = (void *)objc_msgSend_resourceManager(v9, v10, v11, v12);
  v21 = sub_1B1813884(a1[2], v14, v15, v16, v17, v18, v19, v20);
  v29 = sub_1B1814768((uint64_t *)a1[2], v22, v23, v24, v25, v26, v27, v28);
  if (v29)
  {
    v37 = sub_1B186CFA8((uint64_t)v29, v30, v31, v32, v33, v34, v35, v36);
    if (v37)
    {
      v38 = (uint64_t)v37;
      v70 = 0;
      v39 = sub_1B187B0F0(v21, 0);
      v47 = sub_1B187B0A0(v21, 0);
      if (v47)
        HIBYTE(v70) = objc_msgSend_textureForMaterialProperty_(v9, v40, v47, v42) != 0;
      if (v39)
        LOBYTE(v70) = objc_msgSend_textureForMaterialProperty_(v9, v40, v39, v42) != 0;
      v48 = sub_1B186503C(v38, (uint64_t)v40, v41, v42, v43, v44, v45, v46);
      v69 = v48;
      v68 = sub_1B19DA3D0(a1[4]);
      v49 = sub_1B19DA3E0(a1[4]);
      v67 = v49 != 0;
      v50 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v47) ^ ((0x9DDFEA08EB382D69 * v47) >> 47));
      v51 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                            * ((0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47))) ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47))) ^ v39)));
      v52 = 0x9DDFEA08EB382D69 * (v51 ^ (v51 >> 47));
      v53 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v52 ^ ((0x9DDFEA08EB382D69 * (v52 ^ v68)) >> 47) ^ (0x9DDFEA08EB382D69 * (v52 ^ v68)))) ^ ((0x9DDFEA08EB382D69 * (v52 ^ ((0x9DDFEA08EB382D69 * (v52 ^ v68)) >> 47) ^ (0x9DDFEA08EB382D69 * (v52 ^ v68)))) >> 47));
      v54 = 0x9DDFEA08EB382D69
          * (v53 ^ ((0x9DDFEA08EB382D69 * (v53 ^ (v49 != 0))) >> 47) ^ (0x9DDFEA08EB382D69 * (v53 ^ (v49 != 0))));
      v55 = 0x9DDFEA08EB382D69 * (v54 ^ (v54 >> 47));
      v56 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v55 ^ ((0x9DDFEA08EB382D69 * (v55 ^ v48)) >> 47) ^ (0x9DDFEA08EB382D69 * (v55 ^ v48)))) ^ ((0x9DDFEA08EB382D69 * (v55 ^ ((0x9DDFEA08EB382D69 * (v55 ^ v48)) >> 47) ^ (0x9DDFEA08EB382D69 * (v55 ^ v48)))) >> 47));
      if (a1[52] != v56)
      {
        a1[52] = v56;
        sub_1B19D9F28(a1[4], a1[2]);
        v57 = objc_alloc_init(MEMORY[0x1E0CC6AA0]);
        objc_msgSend_setConstantValue_type_withName_(v57, v58, (uint64_t)&v70 + 1, 53, CFSTR("has_background"));
        objc_msgSend_setConstantValue_type_withName_(v57, v59, (uint64_t)&v70, 53, CFSTR("has_IBL"));
        objc_msgSend_setConstantValue_type_withName_(v57, v60, (uint64_t)&v69, 53, CFSTR("has_DOF"));
        objc_msgSend_setConstantValue_type_withName_(v57, v61, (uint64_t)&v68, 33, CFSTR("LightCount"));
        objc_msgSend_setConstantValue_type_withName_(v57, v62, (uint64_t)&v67, 33, CFSTR("raytracing_use_function_constant"));
        v63 = sub_1B19DA304(a1[4]);
        v65 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_linkedFunctions_(v13, v64, (uint64_t)CFSTR("vfx_path_tracer"), (uint64_t)v57, v63);

        v66 = (void *)a1[53];
        if (v66 != (void *)v65)
        {
          if (v66)

          a1[53] = v65;
        }
        sub_1B19DA290(a1[4]);
      }
    }
  }
}

uint64_t sub_1B18F77DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFX::CrossFrameResourceManager **a5, uint64_t *a6)
{
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  CFX::CrossFrameResourceManager *v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  const CFX::RG::Resource *v36;
  unsigned __int16 *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  CFX::RG::TextureDescriptorReference *v49;
  CFX::RG::Resource *v50;
  __int128 v51;
  CFX::RG::Resource *v52;
  __int128 v53;
  int v55;
  uint64_t v56;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;

  v10 = *a6;
  *(_QWORD *)&v88 = "PathTracerPass";
  *((_QWORD *)&v88 + 1) = v10;
  v11 = atomic_load((unsigned __int8 *)&qword_1EEF66210);
  if ((v11 & 1) == 0)
  {
    v56 = a2;
    v57 = a3;
    v55 = __cxa_guard_acquire(&qword_1EEF66210);
    a2 = v56;
    a3 = v57;
    if (v55)
    {
      byte_1EEF66208 = 1;
      __cxa_guard_release(&qword_1EEF66210);
      a2 = v56;
      a3 = v57;
    }
  }
  if (byte_1EEF66208)
    v12 = 0x3A712055557F5840;
  else
    v12 = 0;
  sub_1B18F7354(a1, a2, a3, (uint64_t *)&v88, v12, 0);
  *(_QWORD *)a1 = &off_1E63CEC10;
  *(_OWORD *)(a1 + 376) = *(_OWORD *)a6;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_QWORD *)(a1 + 456) = 0;
  v20 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 368), v13, v14, v15, v16, v17, v18, v19);
  *(_QWORD *)(a1 + 448) = v20;
  *(_QWORD *)(a1 + 456) = objc_msgSend_resourceManager(v20, v21, v22, v23);
  v24 = a5[4];
  v25 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v26 = (uint64_t *)CFX::CrossFrameResourceManager::get(v24, v25);
  *(_QWORD *)(a1 + 392) = v26;
  if (!v26)
  {
    v34 = (uint64_t)a5[4];
    v35 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
    *(_QWORD *)&v88 = *(_QWORD *)(a1 + 368);
    v26 = (uint64_t *)sub_1B18F7C00(v34, v35, (uint64_t *)&v88);
    *(_QWORD *)(a1 + 392) = v26;
  }
  sub_1B18F755C(v26, v27, v28, v29, v30, v31, v32, v33);
  CFX::RG::RenderGraphBuilder::findPublishedResource(a4, *(_QWORD *)(a1 + 384));
  v37 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a5, v36);
  v38 = *v37;
  v39 = v37[1];
  v40 = *((_QWORD *)v37 + 2);
  v41 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v42 = 0x9DDFEA08EB382D69
      * (v41 ^ ((0x9DDFEA08EB382D69 * (v41 ^ v38)) >> 47) ^ (0x9DDFEA08EB382D69 * (v41 ^ v38)));
  v43 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47))) ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47))) ^ v39)));
  v44 = 0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47));
  v45 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v44 ^ ((0x9DDFEA08EB382D69 * (v44 ^ v40)) >> 47) ^ (0x9DDFEA08EB382D69 * (v44 ^ v40)))) ^ ((0x9DDFEA08EB382D69 * (v44 ^ ((0x9DDFEA08EB382D69 * (v44 ^ v40)) >> 47) ^ (0x9DDFEA08EB382D69 * (v44 ^ v40)))) >> 47));
  v46 = CFX::CrossFrameResourceManager::get(a5[4], v45);
  *(_QWORD *)(a1 + 400) = v46;
  if (!v46)
  {
    v47 = (uint64_t)a5[4];
    v48 = operator new();
    *(_OWORD *)v48 = 0u;
    *(_OWORD *)(v48 + 16) = 0u;
    *(_QWORD *)(v48 + 24) = 0;
    *(_QWORD *)(v48 + 32) = 0;
    *(_QWORD *)v48 = &off_1E63CEBF0;
    *(_QWORD *)(v48 + 16) = 0;
    *(_BYTE *)(v48 + 32) = 0;
    CFX::CrossFrameResourceManager::set(v47, v45, v48);
    *(_QWORD *)(a1 + 400) = v48;
    v49 = (CFX::RG::TextureDescriptorReference *)CFX::RG::TextureDescriptorReference::TextureDescriptorReference(&v88, *(_QWORD *)(a1 + 384), 1.0);
    CFX::RG::TextureDescriptorReference::withPixelFormat(v49, MTLPixelFormatRGBA32Float, (uint64_t)&v78);
    v74 = v84;
    v75 = v85;
    v76 = v86;
    v77 = v87;
    v70 = v80;
    v71 = v81;
    v72 = v82;
    v73 = v83;
    v68 = v78;
    v69 = v79;
    v50 = (CFX::RG::Resource *)malloc_type_malloc(0xE0uLL, 0xD5346062uLL);
    *(_QWORD *)&v51 = -1;
    *((_QWORD *)&v51 + 1) = -1;
    *((_OWORD *)v50 + 12) = v51;
    *((_OWORD *)v50 + 13) = v51;
    *((_OWORD *)v50 + 10) = v51;
    *((_OWORD *)v50 + 11) = v51;
    *((_OWORD *)v50 + 8) = v51;
    *((_OWORD *)v50 + 9) = v51;
    *((_OWORD *)v50 + 6) = v51;
    *((_OWORD *)v50 + 7) = v51;
    *((_OWORD *)v50 + 4) = v51;
    *((_OWORD *)v50 + 5) = v51;
    *((_OWORD *)v50 + 2) = v51;
    *((_OWORD *)v50 + 3) = v51;
    *(_OWORD *)v50 = v51;
    *((_OWORD *)v50 + 1) = v51;
    v88 = v68;
    v89 = v69;
    v92 = v72;
    v93 = v73;
    v90 = v70;
    v91 = v71;
    v96 = v76;
    v97 = v77;
    v94 = v74;
    v95 = v75;
    CFX::RG::Resource::Resource((uint64_t)v50, (uint64_t)"pingPongTex0", (uint64_t)&v88, 2);
    sub_1B181C064((CFX::RG::Resource **)(*(_QWORD *)(a1 + 400) + 16), v50);
    v64 = v84;
    v65 = v85;
    v66 = v86;
    v67 = v87;
    v60 = v80;
    v61 = v81;
    v62 = v82;
    v63 = v83;
    v58 = v78;
    v59 = v79;
    v52 = (CFX::RG::Resource *)malloc_type_malloc(0xE0uLL, 0xD5346062uLL);
    *(_QWORD *)&v53 = -1;
    *((_QWORD *)&v53 + 1) = -1;
    *((_OWORD *)v52 + 12) = v53;
    *((_OWORD *)v52 + 13) = v53;
    *((_OWORD *)v52 + 10) = v53;
    *((_OWORD *)v52 + 11) = v53;
    *((_OWORD *)v52 + 8) = v53;
    *((_OWORD *)v52 + 9) = v53;
    *((_OWORD *)v52 + 6) = v53;
    *((_OWORD *)v52 + 7) = v53;
    *((_OWORD *)v52 + 4) = v53;
    *((_OWORD *)v52 + 5) = v53;
    *((_OWORD *)v52 + 2) = v53;
    *((_OWORD *)v52 + 3) = v53;
    *(_OWORD *)v52 = v53;
    *((_OWORD *)v52 + 1) = v53;
    v88 = v58;
    v89 = v59;
    v92 = v62;
    v93 = v63;
    v90 = v60;
    v91 = v61;
    v96 = v66;
    v97 = v67;
    v94 = v64;
    v95 = v65;
    CFX::RG::Resource::Resource((uint64_t)v52, (uint64_t)"pingPongTex1", (uint64_t)&v88, 2);
    sub_1B181C064((CFX::RG::Resource **)(*(_QWORD *)(a1 + 400) + 24), v52);
    *(_QWORD *)(*(_QWORD *)(a1 + 392) + 384) = 0;
    v46 = *(_QWORD *)(a1 + 400);
  }
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(v46 + 8 * (*(_BYTE *)(v46 + 32) == 0) + 16));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(*(_QWORD *)(a1 + 400) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 400) + 32) + 16));
  return a1;
}

void sub_1B18F7BD0(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18F7C00(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v6 = operator new();
  sub_1B18F740C(v6, *a3, v7, v8, v9, v10, v11, v12);
  CFX::CrossFrameResourceManager::set(a1, a2, v6);
  return v6;
}

void sub_1B18F7C64(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E22E18](v1, 0x10A1C40A12BA9B8);
  _Unwind_Resume(a1);
}

void sub_1B18F7C8C(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFDictionary *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  float32x4_t *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _OWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned __int8 *v65;
  uint64_t v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  _OWORD *v70;
  float32x4_t *v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  float v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  float v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  float v111;
  uint64_t v112;
  BOOL v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  float v122;
  float32x4_t *v123;
  int16x4_t v124;
  const char *v125;
  uint64_t i;
  id Texture;
  const char *v128;
  uint64_t v129;
  const char *v130;
  uint64_t v131;
  uint64_t v132;
  const char *v133;
  uint64_t v134;
  const char *v135;
  uint64_t v136;
  uint64_t v137;
  const char *v138;
  id v139;
  id v140;
  const char *v141;
  const char *v142;
  uint64_t v143;
  const char *v144;
  uint64_t v145;
  uint64_t v146;
  const char *v147;
  uint64_t v148;
  const char *v149;
  uint64_t v150;
  const char *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  void *v160;
  void *v161;
  const char *v162;
  uint64_t v163;
  const char *v164;
  uint64_t v165;
  uint64_t v166;
  unsigned int v167;
  const char *v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  const char *v178;
  _OWORD *v179;
  __int128 v180;
  __int128 v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  __int8 v189;
  uint64_t v190;
  void *v191;
  uint64_t v192;
  uint64_t v193;
  void *v194;
  const char *v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  const char *v199;
  uint64_t v200;
  uint64_t v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  __n128 v206;
  unsigned __int8 v207[176];
  _OWORD v208[4];
  simd_float4x4 v209;

  if (!*(_QWORD *)(*(_QWORD *)(a1 + 392) + 424))
    return;
  v10 = *a3;
  v11 = sub_1B1813884(*(_QWORD *)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  v19 = sub_1B1814768(*(uint64_t **)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
  if (!v19)
    return;
  v27 = sub_1B186CFA8((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26);
  if (!v27)
    return;
  v35 = (uint64_t)v27;
  v36 = sub_1B1814768(*(uint64_t **)(a1 + 368), v28, v29, v30, v31, v32, v33, v34);
  sub_1B17B33F4((uint64_t)v36, (uint64_t)v207, v37, v38, v39, v40, v41, v42);
  v43 = (float32x4_t *)sub_1B1815A5C(*(_QWORD *)(a1 + 368), 1);
  v203 = v43[1];
  v204 = *v43;
  v202 = v43[2];
  v205 = v43[3];
  v206 = 0uLL;
  v206 = sub_1B181537C(*(_QWORD *)(a1 + 368), 0, v44, v45, v46, v47, v48, v49);
  v57 = sub_1B187B1D0(v11, v50, v51, v52, v53, v54, v55, v56);
  sub_1B19D9F28(v57, *(_QWORD *)(a1 + 368));
  v58 = *(_OWORD **)(a1 + 392);
  v58[8] = v204;
  v58[9] = v203;
  v58[10] = v202;
  v58[11] = v205;
  *(simd_float4x4 *)(*(_QWORD *)(a1 + 392) + 192) = __invert_f4(*(simd_float4x4 *)(*(_QWORD *)(a1 + 392) + 128));
  v65 = sub_1B18667B4(v207, (uint64_t)&v206, v59, v60, v61, v62, v63, v64);
  v66 = 0;
  v67 = *((_OWORD *)v65 + 1);
  v68 = *((_OWORD *)v65 + 2);
  v69 = *((_OWORD *)v65 + 3);
  v70 = *(_OWORD **)(a1 + 392);
  v70[16] = *(_OWORD *)v65;
  v70[17] = v67;
  v70[18] = v68;
  v70[19] = v69;
  v71 = *(float32x4_t **)(a1 + 392);
  v72 = v71[16];
  v73 = v71[17];
  v74 = v71[18];
  v75 = v71[19];
  v76 = v71[9];
  v77 = v71[10];
  v78 = v71[11];
  v208[0] = v71[8];
  v208[1] = v76;
  v208[2] = v77;
  v208[3] = v78;
  do
  {
    v209.columns[v66] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v72, COERCE_FLOAT(v208[v66])), v73, *(float32x2_t *)&v208[v66], 1), v74, (float32x4_t)v208[v66], 2), v75, (float32x4_t)v208[v66], 3);
    ++v66;
  }
  while (v66 != 4);
  *(simd_float4x4 *)(*(_QWORD *)(a1 + 392) + 320) = __invert_f4(v209);
  v86 = sub_1B1865DD8(v35, v79, v80, v81, v82, v83, v84, v85);
  v94 = sub_1B1866048(v35, v87, v88, v89, v90, v91, v92, v93) / 1000.0;
  v102 = sub_1B186433C(v35, v95, v96, v97, v98, v99, v100, v101);
  if (v102)
    v110 = sub_1B18E8E04(v102, v103, v104, v105, v106, v107, v108, v109);
  else
    v110 = 1;
  v111 = v94 * 1.5;
  v112 = *(_QWORD *)(a1 + 392);
  v113 = v86 != *(float *)(v112 + 392) || v111 != *(float *)(v112 + 396) || v110 != *(_DWORD *)(v112 + 400);
  *(float *)(v112 + 392) = v86;
  *(float *)(v112 + 396) = v111;
  *(_DWORD *)(v112 + 400) = v110;
  v114 = sub_1B187B0F0(v11, 0);
  if (v114)
    v122 = sub_1B1841E14(v114, v115, v116, v117, v118, v119, v120, v121);
  else
    v122 = 0.0;
  v123 = *(float32x4_t **)(a1 + 392);
  v123[25].f32[1] = v122;
  if (v113
    || (v124 = vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v205, v123[7]))), v124.i8[0] & 1 | v124.i8[2] & 1))
  {
    sub_1B1814A78(*(_QWORD *)(a1 + 368), v115, v116, v117, v118, v119, v120, v121);
  }
  else
  {
    v189 = v124.i8[4];
    v190 = sub_1B1814A78(*(_QWORD *)(a1 + 368), v115, v116, v117, v118, v119, v120, v121);
    if ((v189 & 1) == 0)
    {
      v191 = (void *)v190;
      if (!sub_1B19DA288(v57))
        goto LABEL_21;
      v194 = (void *)objc_msgSend_world(v191, v125, v192, v193);
      v198 = (void *)objc_msgSend_clock(v194, v195, v196, v197);
      if ((objc_msgSend_isPaused(v198, v199, v200, v201) & 1) != 0)
        goto LABEL_21;
    }
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 392) + 384) = 0;
LABEL_21:
  objc_msgSend_setBytes_length_atIndex_(v10, v125, *(_QWORD *)(a1 + 392) + 128, 288, 8);
  for (i = 0; i != 5; ++i)
  {
    Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 408 + 8 * i));
    objc_msgSend_setTexture_atIndex_(v10, v128, (uint64_t)Texture, i);
  }
  v129 = sub_1B187B0A0(v11, 0);
  if (v129)
  {
    v132 = objc_msgSend_textureForMaterialProperty_(*(void **)(a1 + 448), v130, v129, v131);
    if (v132)
      objc_msgSend_setTexture_atIndex_(v10, v133, v132, 5);
  }
  v134 = sub_1B187B0F0(v11, 0);
  if (v134)
  {
    v137 = objc_msgSend_textureForMaterialProperty_(*(void **)(a1 + 448), v135, v134, v136);
    if (v137)
      objc_msgSend_setTexture_atIndex_(v10, v138, v137, 6);
  }
  v139 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 400)+ 8 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 400) + 32)+ 16));
  v140 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(_QWORD *)(a1 + 400)+ 8 * (*(_BYTE *)(*(_QWORD *)(a1 + 400) + 32) == 0)+ 16));
  objc_msgSend_setTexture_atIndex_(v10, v141, (uint64_t)v139, 10);
  objc_msgSend_setTexture_atIndex_(v10, v142, (uint64_t)v140, 11);
  v143 = sub_1B19DA2DC(v57);
  objc_msgSend_useHeap_(v10, v144, v143, v145);
  v146 = sub_1B19DA2EC(v57);
  objc_msgSend_setBuffer_offset_atIndex_(v10, v147, v146, 0, 0);
  v148 = sub_1B19DA2E4(v57);
  objc_msgSend_setAccelerationStructure_atBufferIndex_(v10, v149, v148, 1);
  if (sub_1B19DA3D0(v57))
  {
    v150 = sub_1B19DA2F4(v57);
    objc_msgSend_setBuffer_offset_atIndex_(v10, v151, v150, 0, 2);
  }
  if (sub_1B19DA3E0(v57))
  {
    v158 = *(_QWORD *)(a1 + 392);
    v159 = *(_QWORD *)(v158 + 424);
    if (!v159)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v152, v153, v154, v155, v156, v157, (uint64_t)"_ptr != NULL");
      v159 = *(_QWORD *)(v158 + 424);
    }
    v160 = (void *)sub_1B18FD774(v159);
    v161 = sub_1B19DA30C(v57, v160);
    objc_msgSend_setIntersectionFunctionTable_atBufferIndex_(v10, v162, (uint64_t)v161, 3);
  }
  else
  {
    v161 = 0;
  }
  v163 = sub_1B19DA2FC(v57);
  v167 = sub_1B19DA3F0(v57, v164, v165, v166);
  objc_msgSend_useResources_count_usage_(v10, v168, v163, v167, 1);
  v175 = *(_QWORD *)(a1 + 392);
  v176 = *(_QWORD *)(v175 + 424);
  if (!v176)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v169, v170, v171, v172, v173, v174, (uint64_t)"_ptr != NULL");
    v176 = *(_QWORD *)(v175 + 424);
  }
  v177 = sub_1B18FD774(v176);
  objc_msgSend_dispatch_onTexture2D_(v10, v178, v177, (uint64_t)v139);

  v179 = *(_OWORD **)(a1 + 392);
  v180 = v179[9];
  v179[4] = v179[8];
  v179[5] = v180;
  v181 = v179[11];
  v179[6] = v179[10];
  v179[7] = v181;
  *(int32x2_t *)(*(_QWORD *)(a1 + 392) + 384) = vadd_s32(*(int32x2_t *)(*(_QWORD *)(a1 + 392) + 384), (int32x2_t)0x100000001);
  sub_1B19DA290(v57);
  *(_BYTE *)(*(_QWORD *)(a1 + 400) + 32) ^= 1u;
  sub_1B1814328(*(_QWORD *)(a1 + 368), v182, v183, v184, v185, v186, v187, v188);
}

uint64_t *sub_1B18F81D0(uint64_t *this, CFX::RG::Resource *a2, unsigned int a3)
{
  this[a3 + 51] = (uint64_t)a2;
  return CFX::RG::Pass::readFrom(this, a2);
}

uint64_t sub_1B18F81DC(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 400) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 400) + 32) + 16);
}

uint64_t sub_1B18F81F0(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  return sub_1B18F8200(a1, (uint64_t)a1, a2, a3);
}

uint64_t sub_1B18F8200(uint64_t *a1, uint64_t a2, CFX::CrossFrameResourceManager **a3, uint64_t *a4)
{
  uint64_t v7;
  uint64_t v9[2];

  v7 = a1[1];
  v9[0] = *a1;
  v9[1] = v7;
  v9[0] = sub_1B18F8320(v9[0], v7, v9, a2, a3, a4);
  sub_1B179C734(a1 + 18, v9);
  return v9[0];
}

void sub_1B18F825C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

_QWORD *sub_1B18F8280(_QWORD *a1)
{
  uint64_t i;

  *a1 = &off_1E63CEBF0;
  for (i = 3; i != 1; --i)
    sub_1B181C064((CFX::RG::Resource **)&a1[i], 0);
  return a1;
}

void sub_1B18F82C8(_QWORD *a1)
{
  uint64_t i;

  *a1 = &off_1E63CEBF0;
  for (i = 3; i != 1; --i)
    sub_1B181C064((CFX::RG::Resource **)&a1[i], 0);
  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B18F8320(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, CFX::CrossFrameResourceManager **a5, uint64_t *a6)
{
  uint64_t v10;
  _QWORD v12[2];

  v12[0] = a1;
  v12[1] = a2;
  v10 = sub_1B179C1C0(v12, 0x1D0u, 8u);
  return sub_1B18F77DC(v10, *a3, a3[1], a4, a5, a6);
}

CFTypeRef sub_1B18F8384(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeRef result;
  const void *v10;
  uint64_t v11;
  char v12;
  NSObject *v13;
  os_signpost_id_t v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  double v54;
  float32x4_t v55;
  float32x4_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  NSObject *v62;
  uint8_t v63[8];
  int *v64;
  uint8_t buf[16];
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;

  sub_1B1924A68();
  result = *(CFTypeRef *)(a1 + 152);
  if (!result)
  {
    v10 = (const void *)sub_1B17A0848(a1, v2, v3, v4, v5, v6, v7, v8);
    v11 = (uint64_t)v10;
    v12 = *(_BYTE *)(a1 + 128);
    if (v12)
    {
      v13 = sub_1B17C439C();
      v14 = os_signpost_id_generate(v13);
      v15 = sub_1B17C439C();
      if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v16 = v15;
        if (os_signpost_enabled(v15))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_1B178D000, v16, OS_SIGNPOST_INTERVAL_BEGIN, v14, "Subdivision", "", buf, 2u);
        }
      }
      sub_1B1924D88(a1);
      sub_1B1925B14((_QWORD *)(a1 + 128), v11, v17, v18, v19, v20, v21, v22);
      v78 = 0u;
      v79 = 0u;
      v76 = 0u;
      v77 = 0u;
      v74 = 0u;
      v75 = 0u;
      v72 = 0u;
      v73 = 0u;
      v70 = 0u;
      v71 = 0u;
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      *(_OWORD *)buf = 0u;
      sub_1B192618C((uint64_t)buf, a1 + 128, v11, v23, v24, v25, v26, v27);
      v35 = sub_1B1926028(a1 + 128, v28, v29, v30, v31, v32, v33, v34);
      v42 = (int *)v35;
      if (*((_QWORD *)&v68 + 1) != (_QWORD)v68 || *(_BYTE *)(a1 + 133) == 2)
        v44 = 32;
      else
        v44 = 0;
      sub_1B2222E28(v35, v44 & 0xFFFFFFF0 | v12 & 0xF, v36, v37, v38, v39, v40, v41, v63[0]);
      v64 = v42;
      sub_1B192678C((uint64_t)buf, a1 + 128, (uint64_t)v42, v45, v46, v47, v48, v49);
      sub_1B1926AA0((uint64_t)buf, v54, v55, v56, a1 + 128, (uint64_t)v42, &v64, v50, v51, v52, v53);
      *(_QWORD *)(a1 + 152) = sub_1B19283B0(buf, a1 + 128, (uint64_t)v42, (uint64_t *)&v64, v11, v57, v58, v59);
      v60 = sub_1B2222B2C(v42);
      MEMORY[0x1B5E22E18](v60, 0x10A0C40D2671FEALL);
      nullsub_16(buf);
      v61 = sub_1B17C439C();
      if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v62 = v61;
        if (os_signpost_enabled(v61))
        {
          *(_WORD *)v63 = 0;
          _os_signpost_emit_with_name_impl(&dword_1B178D000, v62, OS_SIGNPOST_INTERVAL_END, v14, "Subdivision", "", v63, 2u);
        }
      }
      sub_1B18F8584((uint64_t)buf);
      return *(CFTypeRef *)(a1 + 152);
    }
    else
    {
      result = CFRetain(v10);
      *(_QWORD *)(a1 + 152) = result;
    }
  }
  return result;
}

uint64_t sub_1B18F8584(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v5;

  v5 = (void **)(a1 + 216);
  sub_1B18F864C(&v5);
  v5 = (void **)(a1 + 192);
  sub_1B18F870C(&v5);
  v5 = (void **)(a1 + 168);
  sub_1B18F870C(&v5);
  v5 = (void **)(a1 + 144);
  sub_1B18F870C(&v5);
  v5 = (void **)(a1 + 120);
  sub_1B18F870C(&v5);
  v5 = (void **)(a1 + 96);
  sub_1B18F870C(&v5);
  v5 = (void **)(a1 + 72);
  sub_1B18F870C(&v5);
  v5 = (void **)(a1 + 48);
  sub_1B18F87D0(&v5);
  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  v3 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1B18F864C(void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 9;
        sub_1B18F86BC(v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1B18F86BC(void **a1)
{
  void **v2;

  v2 = a1 + 6;
  sub_1B18F870C(&v2);
  v2 = a1 + 3;
  sub_1B18F870C(&v2);
  v2 = a1;
  sub_1B18F870C(&v2);
}

void sub_1B18F870C(void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 112;
        sub_1B18F877C(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1B18F877C(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v3;
    operator delete(v3);
  }
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
  }
}

void sub_1B18F87D0(void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    sub_1B18F8810((uint64_t *)v2);
    operator delete(**a1);
  }
}

void sub_1B18F8810(uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 32)
  {
    v4 = *(void **)(i - 24);
    if (v4)
    {
      *(_QWORD *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

unint64_t sub_1B18F885C(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t i;
  void *v15;
  const char *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t j;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _BYTE v33[128];
  _BYTE v34[128];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v5 = (void *)objc_msgSend_allKeys(a1, a2, a3, a4);
  v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v6, (uint64_t)&v29, (uint64_t)v34, 16);
  if (v7)
  {
    v11 = v7;
    v12 = 0;
    v13 = *(_QWORD *)v30;
    do
    {
      for (i = 0; i != v11; ++i)
      {
        if (*(_QWORD *)v30 != v13)
          objc_enumerationMutation(v5);
        v12 ^= (v12 << 6)
             + 2654435769u
             + (v12 >> 2)
             + objc_msgSend_hash(*(void **)(*((_QWORD *)&v29 + 1) + 8 * i), v8, v9, v10);
      }
      v11 = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v8, (uint64_t)&v29, (uint64_t)v34, 16);
    }
    while (v11);
  }
  else
  {
    v12 = 0;
  }
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v15 = (void *)objc_msgSend_allValues(a1, v8, v9, v10, 0);
  v17 = objc_msgSend_countByEnumeratingWithState_objects_count_(v15, v16, (uint64_t)&v25, (uint64_t)v33, 16);
  if (v17)
  {
    v21 = v17;
    v22 = *(_QWORD *)v26;
    do
    {
      for (j = 0; j != v21; ++j)
      {
        if (*(_QWORD *)v26 != v22)
          objc_enumerationMutation(v15);
        v12 ^= (v12 << 6)
             + 2654435769u
             + (v12 >> 2)
             + objc_msgSend_hash(*(void **)(*((_QWORD *)&v25 + 1) + 8 * j), v18, v19, v20);
      }
      v21 = objc_msgSend_countByEnumeratingWithState_objects_count_(v15, v18, (uint64_t)&v25, (uint64_t)v33, 16);
    }
    while (v21);
  }
  return v12;
}

uint64_t sub_1B18F8A08(uint64_t a1)
{
  CC_SHA256_CTX v3;
  unsigned __int8 md[32];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  CC_SHA256_Init(&v3);
  sub_1B19B9800(a1, (uint64_t)&v3);
  CC_SHA256_Final(md, &v3);
  return *(_QWORD *)md;
}

void sub_1B18F8B84(uint64_t a1)
{
  sub_1B195809C(*(_QWORD *)(a1 + 32));
}

uint64_t sub_1B18F8B8C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  void *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  BOOL v64;
  unsigned __int8 v65;
  unsigned __int8 v66;
  uint64_t v67;
  const char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;

  v9 = sub_1B18A796C(a1, 0, a3, a4, a5, a6, a7, a8);
  v10 = HIDWORD(v9);
  v14 = (void *)objc_msgSend_colorAttachments(a2, v11, v12, v13);
  v17 = (void *)objc_msgSend_objectAtIndexedSubscript_(v14, v15, 0, v16);
  v21 = objc_msgSend_pixelFormat(v17, v18, v19, v20);
  if ((_BYTE)v9)
    v24 = v21 == 0;
  else
    v24 = 1;
  if (v24)
    objc_msgSend_setBlendingEnabled_(v17, v22, 0, v23);
  else
    objc_msgSend_setBlendingEnabled_(v17, v22, 1, v23);
  v32 = sub_1B189D060(BYTE2(v9), v25, v26, v27, v28, v29, v30, v31);
  objc_msgSend_setSourceRGBBlendFactor_(v17, v33, v32, v34);
  v42 = sub_1B189D060(BYTE3(v9), v35, v36, v37, v38, v39, v40, v41);
  objc_msgSend_setDestinationRGBBlendFactor_(v17, v43, v42, v44);
  v52 = sub_1B189D0B4(BYTE4(v9), v45, v46, v47, v48, v49, v50, v51);
  objc_msgSend_setRgbBlendOperation_(v17, v53, v52, v54);
  v62 = HIBYTE(v9);
  v63 = v9 >> 40;
  v64 = (v9 & 0xFF00) == 0;
  if ((v9 & 0xFF00) != 0)
  {
    v65 = BYTE6(v9);
  }
  else
  {
    LOBYTE(v63) = BYTE2(v9);
    v65 = BYTE3(v9);
  }
  if (v64)
    v66 = v10;
  else
    v66 = v62;
  v67 = sub_1B189D060(v63, v55, v56, v57, v58, v59, v60, v61);
  objc_msgSend_setSourceAlphaBlendFactor_(v17, v68, v67, v69);
  v77 = sub_1B189D060(v65, v70, v71, v72, v73, v74, v75, v76);
  objc_msgSend_setDestinationAlphaBlendFactor_(v17, v78, v77, v79);
  v87 = sub_1B189D0B4(v66, v80, v81, v82, v83, v84, v85, v86);
  return MEMORY[0x1E0DE7D20](v17, sel_setAlphaBlendOperation_, v87, v88);
}

void *sub_1B18F8C8C(uint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  void *v5;
  VFXMTLResourceManager *v6;
  const char *v7;
  uint64_t v8;
  const char *v9;

  objc_opt_self();
  if (qword_1ED4CF738 != -1)
    dispatch_once(&qword_1ED4CF738, &unk_1E63D1110);
  os_unfair_lock_lock((os_unfair_lock_t)&dword_1EEF66218);
  v5 = (void *)objc_msgSend_objectForKey_((void *)qword_1ED4CEEE0, v3, a2, v4);
  if (!v5)
  {
    v6 = [VFXMTLResourceManager alloc];
    v5 = (void *)objc_msgSend_initWithDevice_(v6, v7, a2, v8);
    objc_msgSend_setObject_forKey_((void *)qword_1ED4CEEE0, v9, (uint64_t)v5, a2);

  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_1EEF66218);
  return v5;
}

uint64_t sub_1B18F8D3C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  dword_1EEF66218 = 0;
  qword_1ED4CEEE0 = (uint64_t)(id)objc_msgSend_weakToStrongObjectsMapTable(MEMORY[0x1E0CB3748], a2, a3, a4);
  objc_msgSend_allocateRegistry(VFXMTLShaderBindingsGenerator, v4, v5, v6);
  return MEMORY[0x1E0DE7D20](VFXMTLRenderContext, sel_registerBindings, v7, v8);
}

uint64_t sub_1B18F8DC0(uint64_t *a1, int a2)
{
  uint64_t v3;
  id v4;
  const char *v5;
  uint64_t result;

  if (a2)
    v3 = 0;
  else
    v3 = 258;
  v4 = objc_alloc(MEMORY[0x1E0CB3748]);
  result = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v4, v5, v3, 0, 100);
  *a1 = result;
  return result;
}

uint64_t sub_1B18F9260(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](a2, sel__rasterizerStateDidDie_, a4, a4);
}

uint64_t sub_1B18F9694(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  const char *v6;
  uint64_t v7;

  objc_msgSend_removeObjectForKey_(a3, a2, *(_QWORD *)(a1 + 32), a4);
  return objc_msgSend_removeObjectForKey_(a3, v6, *(_QWORD *)(a1 + 32) | 1, v7);
}

uint64_t sub_1B18F96CC(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  const char *v6;
  uint64_t v7;

  objc_msgSend_removeObjectForKey_(a3, a2, *(_QWORD *)(a1 + 32), a4);
  return objc_msgSend_removeObjectForKey_(a3, v6, *(_QWORD *)(a1 + 32) | 1, v7);
}

void sub_1B18F9B9C(void *value, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  __CFArray *Mutable;

  if (!*a3 || *(_QWORD *)(a2 + 16) == *a3)
  {
    v5 = a3[1];
    if (!v5 || *(_QWORD *)(a2 + 24) == v5)
    {
      Mutable = (__CFArray *)a3[2];
      if (!Mutable)
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
        a3[2] = Mutable;
      }
      CFArrayAppendValue(Mutable, value);
    }
  }
}

void sub_1B18FA3D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    objc_msgSend_clearCompiledLibraries(*(void **)(a1 + 32), a2, a3, a4);
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 48));
  }
}

void *sub_1B18FA408(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  const char *v5;
  uint64_t v6;
  void *v7;
  id v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  id v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const char *v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  const char *v80;
  uint64_t v81;
  uint64_t v82;
  void *v83;
  const char *v84;
  uint64_t v85;
  uint64_t v86;
  const char *v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  const char *v91;
  uint64_t v92;
  uint64_t v93;
  const char *v94;
  uint64_t v95;
  uint64_t v96;
  void *v97;
  const char *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  void *v111;
  const char *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  const char *v122;
  uint64_t v123;
  uint64_t v124;
  void *v125;
  const char *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  const char *v136;
  uint64_t v137;
  uint64_t v138;
  void *v139;
  const char *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  const char *v150;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  const char *v154;
  uint64_t v155;
  uint64_t v156;
  const char *v157;
  uint64_t v158;
  uint64_t v159;
  void *v160;
  const char *v161;
  uint64_t v162;
  uint64_t v163;
  const char *v164;
  uint64_t v165;
  uint64_t v166;
  void *v167;
  const char *v168;
  uint64_t v169;
  const char *v170;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  int v175;

  if (!a1)
    return 0;
  v4 = (os_unfair_lock_s *)(a1 + 256);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 256));
  v7 = *(void **)(a1 + 248);
  if (!v7)
  {
    v8 = objc_alloc(MEMORY[0x1E0CB3748]);
    v7 = (void *)objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v8, v9, 258, 0, 100);
    *(_QWORD *)(a1 + 248) = v7;
  }
  v16 = (void *)objc_msgSend_objectForKey_(v7, v5, a2, v6);
  if (!v16)
  {
    v172 = 0;
    v173 = 0;
    v175 = 0;
    v174 = 0;
    sub_1B181EE68(a2, v10, v11, v12, v13, v14, v15, (uint64_t)&v172);
    v24 = objc_alloc_init(MEMORY[0x1E0CC6A88]);
    if ((_BYTE)v173)
    {
      v25 = sub_1B189D15C(BYTE2(v173), (uint64_t)v17, v18, v19, v20, v21, v22, v23);
      objc_msgSend_setDepthCompareFunction_(v24, v26, v25, v27);
    }
    else
    {
      objc_msgSend_setDepthCompareFunction_(v24, v17, 7, v19);
    }
    objc_msgSend_setDepthWriteEnabled_(v24, v28, BYTE1(v173), v29);
    if (BYTE3(v173))
    {
      v37 = sub_1B189D108(BYTE5(v173), (uint64_t)v30, v31, v32, v33, v34, v35, v36);
      v41 = (void *)objc_msgSend_frontFaceStencil(v24, v38, v39, v40);
      objc_msgSend_setStencilCompareFunction_(v41, v42, v37, v43);
      v51 = sub_1B189D1B0(BYTE3(v174), v44, v45, v46, v47, v48, v49, v50);
      v55 = (void *)objc_msgSend_frontFaceStencil(v24, v52, v53, v54);
      objc_msgSend_setStencilFailureOperation_(v55, v56, v51, v57);
      v65 = sub_1B189D1B0(BYTE2(v174), v58, v59, v60, v61, v62, v63, v64);
      v69 = (void *)objc_msgSend_frontFaceStencil(v24, v66, v67, v68);
      objc_msgSend_setDepthFailureOperation_(v69, v70, v65, v71);
      v79 = sub_1B189D1B0(BYTE1(v174), v72, v73, v74, v75, v76, v77, v78);
      v83 = (void *)objc_msgSend_frontFaceStencil(v24, v80, v81, v82);
      objc_msgSend_setDepthStencilPassOperation_(v83, v84, v79, v85);
      v86 = BYTE6(v173);
      v90 = (void *)objc_msgSend_frontFaceStencil(v24, v87, v88, v89);
      objc_msgSend_setReadMask_(v90, v91, v86, v92);
      v93 = HIBYTE(v173);
      v97 = (void *)objc_msgSend_frontFaceStencil(v24, v94, v95, v96);
      objc_msgSend_setWriteMask_(v97, v98, v93, v99);
      v107 = sub_1B189D108(BYTE4(v174), v100, v101, v102, v103, v104, v105, v106);
      v111 = (void *)objc_msgSend_backFaceStencil(v24, v108, v109, v110);
      objc_msgSend_setStencilCompareFunction_(v111, v112, v107, v113);
      v121 = sub_1B189D1B0(BYTE2(v175), v114, v115, v116, v117, v118, v119, v120);
      v125 = (void *)objc_msgSend_backFaceStencil(v24, v122, v123, v124);
      objc_msgSend_setStencilFailureOperation_(v125, v126, v121, v127);
      v135 = sub_1B189D1B0(BYTE1(v175), v128, v129, v130, v131, v132, v133, v134);
      v139 = (void *)objc_msgSend_backFaceStencil(v24, v136, v137, v138);
      objc_msgSend_setDepthFailureOperation_(v139, v140, v135, v141);
      v149 = sub_1B189D1B0(v175, v142, v143, v144, v145, v146, v147, v148);
      v153 = (void *)objc_msgSend_backFaceStencil(v24, v150, v151, v152);
      objc_msgSend_setDepthStencilPassOperation_(v153, v154, v149, v155);
      v156 = BYTE5(v174);
      v160 = (void *)objc_msgSend_backFaceStencil(v24, v157, v158, v159);
      objc_msgSend_setReadMask_(v160, v161, v156, v162);
      v163 = BYTE6(v174);
      v167 = (void *)objc_msgSend_backFaceStencil(v24, v164, v165, v166);
      objc_msgSend_setWriteMask_(v167, v168, v163, v169);
    }
    v16 = (void *)objc_msgSend_newDepthStencilStateWithDescriptor_(*(void **)(a1 + 8), v30, (uint64_t)v24, v32);

    objc_msgSend_setObject_forKey_(*(void **)(a1 + 248), v170, (uint64_t)v16, a2);
  }
  os_unfair_lock_unlock(v4);
  return v16;
}

void *sub_1B18FA92C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const __CFData *v11;
  const __CFData *v12;
  CFIndex Length;
  uint64_t v14;
  const UInt8 *BytePtr;
  const char *v16;
  uint64_t v17;
  void *v18;
  id v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;

  if (!a1)
    return 0;
  if (sub_1B18472D8(a2))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. cannot use volatile meshSource"), v4, v5, v6, v7, v8, v9, (uint64_t)"CFXMeshSourceIsVolatile(meshSource) != true");
  v10 = (void *)sub_1B17EE4F4(a2);
  if (!v10)
  {
    v11 = (const __CFData *)sub_1B17EDADC(a2);
    if (v11)
    {
      v12 = v11;
      Length = CFDataGetLength(v11);
      if (Length)
      {
        v14 = Length;
        BytePtr = CFDataGetBytePtr(v12);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 224));
        v18 = *(void **)(a1 + 216);
        if (!v18)
        {
          v19 = objc_alloc(MEMORY[0x1E0CB3748]);
          v18 = (void *)objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v19, v20, 258, 0, 100);
          *(_QWORD *)(a1 + 216) = v18;
        }
        v10 = (void *)objc_msgSend_objectForKey_(v18, v16, (uint64_t)v12, v17);
        if (!v10)
        {
          v10 = (void *)objc_msgSend_newBufferWithBytes_length_options_(*(void **)(a1 + 8), v21, (uint64_t)BytePtr, v14, 0);
          v22 = *(_QWORD *)(a1 + 24);
          ++*(_DWORD *)(v22 + 228);
          *(_DWORD *)(v22 + 256) += v14;
          objc_msgSend_setObject_forKey_(*(void **)(a1 + 216), v23, (uint64_t)v10, (uint64_t)v12);

        }
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 224));
        return v10;
      }
    }
    return 0;
  }
  return v10;
}

VFXMTLMeshElement *sub_1B18FAA70(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  void *v8;
  id v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  VFXMTLMeshElement *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  unsigned int v51;

  if (!a1)
    return 0;
  v4 = sub_1B17A4FB0(a2);
  if (v4 == a2)
    v5 = 0;
  else
    v5 = sub_1B18FAA70(a1, v4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 240));
  v8 = *(void **)(a1 + 232);
  if (!v8)
  {
    v9 = objc_alloc(MEMORY[0x1E0CB3748]);
    v8 = (void *)objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v9, v10, 258, 0, 100);
    *(_QWORD *)(a1 + 232) = v8;
  }
  v11 = objc_msgSend_objectForKey_(v8, v6, v4, v7);
  if (!v11)
  {
    v19 = objc_alloc_init(VFXMTLMeshElement);
    sub_1B1955F00(v19, a2, v28, v29, v30, v31, v32, v33);
    if (v4 == a2)
    {
      if (sub_1B17A4568(a2))
      {
        v45 = sub_1B17A4568(a2);
        v34 = (char *)objc_msgSend__bufferForMTLBuffer_((void *)a1, v46, v45, v47);
      }
      else
      {
        v51 = 0;
        v48 = sub_1B17A4570(a2, &v51);
        if (!v48)
        {
LABEL_20:
          objc_msgSend_setObject_forKey_(*(void **)(a1 + 232), v49, (uint64_t)v19, a2);

          goto LABEL_21;
        }
        v34 = (char *)objc_msgSend__bufferForData_bytesPerIndex_((void *)a1, v49, v48, v51);
      }
    }
    else
    {
      v34 = (char *)sub_1B1956188(v5);
    }
    sub_1B1955E70(v19, v34);
    goto LABEL_20;
  }
  v19 = (VFXMTLMeshElement *)v11;
  if (v4 != a2)
  {
    v20 = (char *)sub_1B1956188(v5);
    sub_1B1955E70(v19, v20);
LABEL_13:
    v35 = sub_1B17A4304(a2, v21, v22, v23, v24, v25, v26, v27);
    sub_1B1956164((uint64_t)v19, v35);
    v43 = sub_1B17A4FC0(a2, v36, v37, v38, v39, v40, v41, v42);
    sub_1B195617C((uint64_t)v19, v43);
    goto LABEL_14;
  }
  if (sub_1B17A506C(a2, v12, v13, v14, v15, v16, v17, v18))
    goto LABEL_13;
LABEL_14:
  v44 = sub_1B17A5008(a2, v21, v22, v23, v24, v25, v26, v27);
  sub_1B1956170((uint64_t)v19, v44);
LABEL_21:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 240));
  return v19;
}

uint64_t sub_1B18FAC48(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  const char *v32;
  uint64_t v33;
  void *v34;
  const char *v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  const char *v41;
  uint64_t v42;
  void *v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const __CFString *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  const char *v66;
  uint64_t v67;
  void *v68;
  const char *v69;
  uint64_t v70;
  const char *v71;
  uint64_t v72;
  uint64_t v73;
  void *v74;
  const char *v75;
  uint64_t v76;
  void *v77;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  const char *v81;
  uint64_t v82;
  uint64_t v83;
  void *v84;
  const char *v85;
  uint64_t v86;
  void *v87;
  const char *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int v97;
  const char *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  void *v102;
  const char *v103;
  uint64_t v104;
  void *v105;
  const char *v106;
  uint64_t v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  void *v111;
  const char *v112;
  uint64_t v113;
  uint64_t v114;
  void *v115;
  const char *v116;
  uint64_t v117;
  void *v118;
  const char *v119;
  uint64_t v120;
  uint64_t v121;

  v11 = 0;
  switch((int)a3)
  {
    case 0:
      break;
    case 1:
      v11 = 1;
      break;
    case 2:
      v11 = 3;
      break;
    case 3:
      if (a4 == -1)
      {
        v11 = 6;
      }
      else
      {
        v11 = a4 + 6;
        if ((a4 + 6) == 14)
          goto LABEL_6;
      }
      break;
    case 4:
      v11 = 2;
      break;
    case 5:
      v11 = 4;
      break;
    case 6:
      v11 = 5;
      break;
    default:
LABEL_6:
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Semantic %d is not meant to be passed to shaders"), a3, a4, a5, a6, a7, a8, (uint64_t)"attribute != kCFXVertexAttrib_None");
      v11 = 14;
      break;
  }
  v12 = sub_1B17EE3B4(a2, a2, a3, a4, a5, a6, a7, a8);
  v13 = sub_1B18F3854(v12);
  v14 = sub_1B18F385C(v12);
  v21 = sub_1B179E720(v13, v14, v15, v16, v17, v18, v19, v20);
  v29 = sub_1B17EE4F8(a2);
  v30 = a5 + 18;
  if (!v29)
    v29 = sub_1B189D65C(v21, (uint64_t)v22, v23, v24, v25, v26, v27, v28);
  v31 = (void *)objc_msgSend_attributes(a1, v22, v23, v24);
  v34 = (void *)objc_msgSend_objectAtIndexedSubscript_(v31, v32, v11, v33);
  objc_msgSend_setFormat_(v34, v35, v29, v36);
  v40 = (void *)objc_msgSend_attributes(a1, v37, v38, v39);
  v43 = (void *)objc_msgSend_objectAtIndexedSubscript_(v40, v41, v11, v42);
  if (!objc_msgSend_format(v43, v44, v45, v46))
  {
    v54 = sub_1B179E5A0(v21, v47, v48, v49, v50, v51, v52, v53);
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: format %@ not convertible to MTLVertexFormat"), v55, v56, v57, v58, v59, v60, (uint64_t)v54);
  }
  v61 = sub_1B18F3D80(v12, v47, v48, v49, v50, v51, v52, v53);
  v65 = (void *)objc_msgSend_attributes(a1, v62, v63, v64);
  v68 = (void *)objc_msgSend_objectAtIndexedSubscript_(v65, v66, v11, v67);
  objc_msgSend_setOffset_(v68, v69, v61, v70);
  v74 = (void *)objc_msgSend_attributes(a1, v71, v72, v73);
  v77 = (void *)objc_msgSend_objectAtIndexedSubscript_(v74, v75, v11, v76);
  objc_msgSend_setBufferIndex_(v77, v78, v30, v79);
  v80 = sub_1B18F3B74(v12);
  v84 = (void *)objc_msgSend_layouts(a1, v81, v82, v83);
  v87 = (void *)objc_msgSend_objectAtIndexedSubscript_(v84, v85, v30, v86);
  objc_msgSend_setStride_(v87, v88, v80, v89);
  v97 = sub_1B18472F8(a2, v90, v91, v92, v93, v94, v95, v96);
  if (v97)
  {
    v101 = v97;
    v102 = (void *)objc_msgSend_layouts(a1, v98, v99, v100);
    v105 = (void *)objc_msgSend_objectAtIndexedSubscript_(v102, v103, v30, v104);
    objc_msgSend_setStepFunction_(v105, v106, 2, v107);
    v111 = (void *)objc_msgSend_layouts(a1, v108, v109, v110);
    v114 = objc_msgSend_objectAtIndexedSubscript_(v111, v112, v30, v113);
    return MEMORY[0x1E0DE7D20](v114, sel_setStepRate_, v101, v121);
  }
  else
  {
    v115 = (void *)objc_msgSend_layouts(a1, v98, v99, v100);
    v118 = (void *)objc_msgSend_objectAtIndexedSubscript_(v115, v116, v30, v117);
    return objc_msgSend_setStepFunction_(v118, v119, 1, v120);
  }
}

void *sub_1B18FB0AC(uint64_t a1, uint64_t a2)
{
  void *result;
  const __CFData *v5;
  const char *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const UInt8 *BytePtr;
  CFIndex Length;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;

  result = (void *)sub_1B17ED1FC(a2);
  if ((_DWORD)result)
  {
    result = (void *)sub_1B17EE4F4(a2);
    if (!result)
    {
      v5 = (const __CFData *)sub_1B17EDADC(a2);
      v8 = (void *)objc_msgSend_objectForKey_(*(void **)(*(_QWORD *)(a1 + 32) + 216), v6, (uint64_t)v5, v7);
      v9 = (void *)sub_1B1955CE0(*(_QWORD *)(a1 + 40));
      if (objc_msgSend_indexOfObject_(v9, v10, (uint64_t)v8, v11) == 0x7FFFFFFFFFFFFFFFLL)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. source should be present"), v12, v13, v14, v15, v16, v17, (uint64_t)"[metalMesh.buffers indexOfObject:buf] != NSNotFound");
      BytePtr = CFDataGetBytePtr(v5);
      Length = CFDataGetLength(v5);
      if (Length != objc_msgSend_length(v8, v20, v21, v22))
      {
        objc_msgSend_length(v8, v23, v24, v25);
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. size mismatch in mutable buffers %u!=%u"), v26, v27, v28, v29, v30, v31, (uint64_t)"dataSize == buf.length");
      }
      v32 = (void *)objc_msgSend_contents(v8, v23, v24, v25);
      return memcpy(v32, BytePtr, Length);
    }
  }
  return result;
}

VFXMTLMesh *sub_1B18FB1C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  void *v9;
  id v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  VFXMTLMesh *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  id v34;
  const char *v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  id v57;
  const char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  CFIndex i;
  const void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  uint64_t v72;
  VFXMTLMeshElement *v73;
  const char *v74;
  uint64_t v75;
  const char *v76;
  VFXMTLMesh *v77;
  uint64_t v79;
  os_unfair_lock_s *lock;
  _QWORD v81[7];
  _QWORD v82[9];
  char v83;
  BOOL v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;

  if (!a1)
    return 0;
  v6 = ((_DWORD)a3 == 0) | (unint64_t)a2;
  lock = (os_unfair_lock_s *)(a1 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 208));
  v9 = *(void **)(a1 + 200);
  if (!v9)
  {
    v10 = objc_alloc(MEMORY[0x1E0CB3748]);
    v9 = (void *)objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v10, v11, 258, 0, 100);
    *(_QWORD *)(a1 + 200) = v9;
  }
  v12 = objc_msgSend_objectForKey_(v9, v7, v6, v8);
  if (v12)
  {
    v20 = (VFXMTLMesh *)v12;
    if (sub_1B1876730(a2, v13, v14, v15, v16, v17, v18, v19))
      objc_msgSend___updateMutableMesh_withMetalMesh_((void *)a1, v21, a2, (uint64_t)v20);
  }
  else
  {
    v79 = v6;
    v20 = objc_alloc_init(VFXMTLMesh);
    sub_1B193E568(a2, v22, v23, v24, v25, v26, v27, v28);
    v32 = (void *)objc_msgSend_vertexDescriptor(MEMORY[0x1E0CC6BD8], v29, v30, v31);
    v33 = sub_1B1876058(a2);
    v34 = objc_alloc(MEMORY[0x1E0C99DE8]);
    v37 = (char *)objc_msgSend_initWithCapacity_(v34, v35, v33, v36);
    v85 = 0;
    v86 = &v85;
    v87 = 0x2020000000;
    v38 = MEMORY[0x1E0C809B0];
    v88 = 0;
    v82[0] = MEMORY[0x1E0C809B0];
    v82[1] = 3221225472;
    v82[2] = sub_1B18FB4C8;
    v82[3] = &unk_1E63D8F80;
    v83 = a3;
    v82[7] = v32;
    v82[8] = &v85;
    v84 = (_DWORD)a3 == 0;
    v82[4] = v20;
    v82[5] = a1;
    v82[6] = v37;
    sub_1B1873EE0(a2, a3, (uint64_t)v82, v39, v40, v41, v42, v43);
    if ((_DWORD)a3 == 1)
    {
      v81[0] = v38;
      v81[1] = 3221225472;
      v81[2] = sub_1B18FB618;
      v81[3] = &unk_1E63D8FA8;
      v81[5] = v37;
      v81[6] = &v85;
      v81[4] = v32;
      sub_1B1873EE0(a2, 1, (uint64_t)v81, v44, v45, v46, v47, v48);
    }
    sub_1B19558B8((uint64_t)v20, v32);
    sub_1B1955CEC(v20, v37);
    sub_1B1955D64((uint64_t)v20, v86[3]);

    v56 = (uint64_t)sub_1B1874BE0(a2, v49, v50, v51, v52, v53, v54, v55);
    v57 = objc_alloc(MEMORY[0x1E0C99DE8]);
    v65 = (void *)objc_msgSend_initWithCapacity_(v57, v58, v56, v59);
    if (v56 >= 1)
    {
      for (i = 0; i != v56; ++i)
      {
        v67 = sub_1B1874C3C(a2, i, a3, v60, v61, v62, v63, v64);
        v70 = (uint64_t)v67;
        if (v67)
        {
          v71 = sub_1B17A426C((uint64_t)v67, v68, v69, v60, v61, v62, v63, v64);
          if ((sub_1B189D25C(v71) & 1) != 0)
          {
            v73 = sub_1B18FAA70(a1, v70);
            objc_msgSend_addObject_(v65, v74, (uint64_t)v73, v75);
          }
          else if ((_DWORD)a3)
          {
            sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Only original data kind can have non 'GPU' primitive type"), v72, v60, v61, v62, v63, v64, (uint64_t)"dataKind == kCFXMeshDataKindOriginal");
          }
        }
      }
    }
    sub_1B1955D0C(v20, (char *)v65);

    objc_msgSend_setObject_forKey_(*(void **)(a1 + 200), v76, (uint64_t)v20, v79);
    _Block_object_dispose(&v85, 8);
  }
  v77 = v20;
  os_unfair_lock_unlock(lock);
  return v20;
}

void sub_1B18FB4A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18FB4C8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;

  if ((_DWORD)a3 != 7)
  {
    v7 = result;
    result = sub_1B186FCC4(*(_QWORD *)(result + 32));
    if (!result)
    {
      v15 = sub_1B17EDAE0(a2, v8, v9, v10, v11, v12, v13, v14);
      result = sub_1B1955D88(*(_QWORD *)(v7 + 32), v15);
    }
    if (((_DWORD)a3 == 3 || a4 <= 0) && ((_DWORD)a3 != 3 || a4 <= 7))
    {
      if (*(_BYTE *)(v7 + 72) == 1 && (result = sub_1B18472D8(a2), (_DWORD)result))
      {
        v23 = sub_1B17EE3B4(a2, v16, v17, v18, v19, v20, v21, v22);
        sub_1B18F3DC8(v23, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 64) + 8) + 24), v24, v25, v26, v27, v28, v29);
        result = sub_1B18F3B74(v23);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 64) + 8) + 24) += result;
      }
      else if (!(_DWORD)a3 || !*(_BYTE *)(v7 + 73))
      {
        result = (uint64_t)sub_1B18FA92C(*(_QWORD *)(v7 + 40), a2);
        if (result)
        {
          v32 = result;
          v39 = objc_msgSend_indexOfObject_(*(void **)(v7 + 48), v30, result, v31);
          if (v39 == 0x7FFFFFFFFFFFFFFFLL)
          {
            v39 = objc_msgSend_count(*(void **)(v7 + 48), v33, v34, v35);
            objc_msgSend_addObject_(*(void **)(v7 + 48), v40, v32, v41);
          }
          return sub_1B18FAC48(*(void **)(v7 + 56), a2, a3, a4, v39, v36, v37, v38);
        }
      }
    }
  }
  return result;
}

uint64_t sub_1B18FB618(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  result = sub_1B18472D8(a2);
  if ((_DWORD)result)
  {
    v16 = sub_1B17EE3B4(a2, v9, v10, v11, v12, v13, v14, v15);
    sub_1B18F3E14(v16, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), v17, v18, v19, v20, v21, v22);
    v23 = *(void **)(a1 + 32);
    v27 = objc_msgSend_count(*(void **)(a1 + 40), v24, v25, v26);
    return sub_1B18FAC48(v23, a2, a3, a4, v27, v28, v29, v30);
  }
  return result;
}

void sub_1B18FB930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B18FB948(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_1B18FB958(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t sub_1B18FB964(uint64_t result, _QWORD *a2, void *a3, _BYTE *a4)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;

  if (*(void **)(result + 32) != a3)
  {
    v6 = result;
    result = sub_1B198EEC4((uint64_t)VFXMTLSkinDeformer, *(_QWORD **)(result + 56), a2);
    if ((_DWORD)result)
    {
      result = objc_msgSend_objectForKey_(a3, v7, *(_QWORD *)(v6 + 40), v8);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 48) + 8) + 40) = result;
      if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 48) + 8) + 40))
        *a4 = 1;
    }
  }
  return result;
}

void sub_1B18FBB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18FBBB4(uint64_t result, uint64_t a2, void *a3, _BYTE *a4)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;

  if (*(void **)(result + 32) != a3)
  {
    v6 = result;
    result = sub_1B194E41C();
    if ((_DWORD)result)
    {
      result = objc_msgSend_objectForKey_(a3, v7, *(_QWORD *)(v6 + 40), v8);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 48) + 8) + 40) = result;
      if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 48) + 8) + 40))
        *a4 = 1;
    }
  }
  return result;
}

void *sub_1B18FBC34(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  const char *v5;
  uint64_t v6;
  void *v7;
  id v8;
  const char *v9;
  void *v10;
  VFXMTLTessellator *v11;
  const char *v12;
  const char *v13;

  if (!a1)
    return 0;
  v4 = (os_unfair_lock_s *)(a1 + 368);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 368));
  v7 = *(void **)(a1 + 360);
  if (!v7)
  {
    v8 = objc_alloc(MEMORY[0x1E0CB3748]);
    v7 = (void *)objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v8, v9, 258, 0, 100);
    *(_QWORD *)(a1 + 360) = v7;
  }
  v10 = (void *)objc_msgSend_objectForKey_(v7, v5, a2, v6);
  if (!v10)
  {
    v11 = [VFXMTLTessellator alloc];
    v10 = (void *)objc_msgSend_initWithGeometry_resourceManager_(v11, v12, a2, a1);
    objc_msgSend_setObject_forKey_(*(void **)(a1 + 360), v13, (uint64_t)v10, a2);

  }
  os_unfair_lock_unlock(v4);
  return v10;
}

VFXMetalWireframeResource *sub_1B18FBCE8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  void *v18;
  id v19;
  const char *v20;
  VFXMetalWireframeResource *v21;
  _QWORD *v22;
  __n128 *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const void *v27;
  unsigned int v28;
  uint64_t v29;
  const char *v30;
  const void *v31;
  const char *v32;
  void *material;
  void *v34;
  void *program;
  void *v36;
  uint64_t programHashCode;
  void *v38;
  __n128 *v40;
  const void *v41;

  if (a1)
  {
    v13 = sub_1B18143C8(a3, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
    v14 = sub_1B17C7D94(v13, (char *)a2, 0, a5);
    if (v14)
    {
      v15 = v14;
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 384));
      v18 = *(void **)(a1 + 376);
      if (!v18)
      {
        v19 = objc_alloc(MEMORY[0x1E0CB3748]);
        v18 = (void *)objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v19, v20, 258, 0, 100);
        *(_QWORD *)(a1 + 376) = v18;
      }
      v21 = (VFXMetalWireframeResource *)objc_msgSend_objectForKey_(v18, v16, v15, v17);
      if (v21)
        goto LABEL_28;
      v22 = (_QWORD *)sub_1B17C2DEC(a2);
      v23 = (__n128 *)sub_1B17C2E5C(a2);
      v24 = sub_1B17C2EA0(a2);
      if (v24)
      {
        v25 = v24;
        v41 = sub_1B17C2EC0(a2);
        v26 = sub_1B17C2E80(a2);
        v40 = v23;
        v27 = (const void *)sub_1B1877DA8(v26);
        v28 = sub_1B1815C04(a3);
        v30 = (const char *)sub_1B1957258(v22, v23, v25, (uint64_t)v41, 0, (uint64_t)v27, ((unint64_t)a4[24] << 16) | ((unint64_t)((8 * (a4[27] & 3)) & 0x9F | (*(unsigned __int16 *)(a2 + 80) >> 11) & 7 | (32 * (a4[28] & 3u))) << 24) | v28, v29);
        v31 = (const void *)sub_1B1815734(a3, v30);
        v21 = objc_alloc_init(VFXMetalWireframeResource);
        material = v21->material;
        if (material != v27)
        {
          if (material)
          {
            CFRelease(material);
            v21->material = 0;
          }
          if (v27)
            v34 = (void *)CFRetain(v27);
          else
            v34 = 0;
          v21->material = v34;
        }
        program = v21->program;
        if (program != v31)
        {
          if (program)
          {
            CFRelease(program);
            v21->program = 0;
          }
          if (v31)
            v36 = (void *)CFRetain(v31);
          else
            v36 = 0;
          v21->program = v36;
        }
        programHashCode = (uint64_t)v21->programHashCode;
        if ((const char *)programHashCode != v30)
        {
          sub_1B195809C(programHashCode);
          if (v30)
            v38 = (void *)CFRetain(v30);
          else
            v38 = 0;
          v21->programHashCode = v38;
        }
        objc_msgSend_setObject_forKey_(*(void **)(a1 + 376), v32, (uint64_t)v21, v15, v40);

        CFRelease(v27);
        sub_1B195809C((uint64_t)v30);
LABEL_28:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 384));
        return v21;
      }
    }
  }
  return 0;
}

uint64_t sub_1B18FBF28(uint64_t result, const char *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;

  if (result)
  {
    v3 = (int)a2;
    v4 = result;
    result = objc_msgSend_newBufferWithLength_options_(*(void **)(result + 8), a2, (uint64_t)a2, a3);
    v5 = *(_QWORD *)(v4 + 24);
    ++*(_DWORD *)(v5 + 240);
    *(_DWORD *)(v5 + 264) += v3;
  }
  return result;
}

uint64_t sub_1B18FBF78(uint64_t result, const char *a2, uint64_t a3, uint64_t a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v4 = a3;
    v5 = result;
    result = objc_msgSend_newBufferWithBytes_length_options_(*(void **)(result + 8), a2, (uint64_t)a2, a3, a4);
    v6 = *(_QWORD *)(v5 + 24);
    ++*(_DWORD *)(v6 + 228);
    *(_DWORD *)(v6 + 256) += v4;
  }
  return result;
}

uint64_t sub_1B18FBFCC(uint64_t a1, const char *a2, uint64_t a3, void *a4)
{
  uint64_t v8;
  const char *v9;
  void *v10;
  const char *v11;
  uint64_t v12;

  if (!a1)
    return 0;
  v8 = objc_msgSend_newBufferWithLength_options_(*(void **)(a1 + 8), a2, a3, 32);
  v10 = (void *)objc_msgSend_newBufferWithBytes_length_options_(*(void **)(a1 + 8), v9, (uint64_t)a2, a3, 0);
  objc_msgSend_copyFromBuffer_sourceOffset_toBuffer_destinationOffset_size_(a4, v11, (uint64_t)v10, 0, v8, 0, a3);

  v12 = *(_QWORD *)(a1 + 24);
  ++*(_DWORD *)(v12 + 228);
  *(_DWORD *)(v12 + 256) += a3;
  return v8;
}

uint64_t sub_1B18FC078(uint64_t result, const char *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;

  if (result)
  {
    v3 = (int)a2;
    v4 = result;
    result = objc_msgSend_newBufferWithLength_options_(*(void **)(result + 8), a2, (uint64_t)a2, a3);
    v5 = *(_QWORD *)(v4 + 24);
    ++*(_DWORD *)(v5 + 228);
    *(_DWORD *)(v5 + 256) += v3;
  }
  return result;
}

VFXMTLShadable *sub_1B18FC0C8(uint64_t a1, _QWORD *a2, _QWORD *a3, VFXMTLRenderPipeline *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v12;
  unsigned int v13;
  const char *v14;
  uint64_t v15;
  id v16;
  const char *v17;
  void *v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  VFXMTLShadable *v30;
  const char *v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float *v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t i;
  uint64_t v51;
  void *v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const char *v61;
  uint64_t v62;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  float v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  float v291;
  uint64_t v292;
  __int128 v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  const char *v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  VFXMTLBuffer *v308;
  uint64_t v309;
  int v310;
  const char *v311;
  void *v312;
  uint64_t v313;
  const char *v314;
  uint64_t v315;
  uint64_t v316;
  _OWORD *v317;
  const char *v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t *v325;
  uint64_t v326;
  _OWORD *v327;
  __int128 *v328;
  __int128 v329;
  __int128 v330;
  __int128 v331;
  const char *v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  const void *v339;
  BOOL v340;
  CFTypeID v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  const char *v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  void *v357;
  BOOL v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  void *v366;
  const char *v367;
  uint64_t v368;
  uint64_t v369;
  unint64_t v370;
  const char *v371;
  uint64_t v372;
  const char *v373;
  uint64_t v374;
  uint64_t v375;
  const char *v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  void *v386;
  const char *v387;
  uint64_t v388;
  const char *v389;
  uint64_t v390;
  const char *v391;
  uint64_t v392;
  uint64_t v393;
  void *v394;
  const char *v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  const char *v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  void *v408;
  const char *v409;
  uint64_t v410;
  uint64_t v411;
  void *v412;
  uint64_t v413;
  const char *v414;
  uint64_t v415;
  const char *v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  void *v424;
  const char *v425;
  const char *v426;
  uint64_t v427;
  uint64_t v428;
  char isKindOfClass;
  unint64_t v430;
  void *v431;
  const char *v432;
  uint64_t v433;
  uint64_t v434;
  const char *v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  const char *v439;
  uint64_t v440;
  const char *v441;
  uint64_t v442;
  uint64_t v443;
  void *v444;
  uint64_t v445;
  uint64_t v446;
  const char *v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  const char *v451;
  void *v452;
  const char *v453;
  uint64_t v454;
  const char *v455;
  uint64_t v456;
  const char *v457;
  uint64_t v458;
  uint64_t v459;
  void *v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  const char *v468;
  uint64_t v469;
  uint64_t v470;
  void *v471;
  const char *v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  const char *v476;
  void *v477;
  const char *v478;
  uint64_t v479;
  const char *v480;
  uint64_t v481;
  uint64_t v482;
  void *v483;
  const char *v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  const char *v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  const char *v492;
  const char *v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  char v500;
  char v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t isDynamic;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  void *v514;
  const char *v515;
  const char *v516;
  uint64_t v517;
  uint64_t v518;
  void *v519;
  const char *v520;
  uint64_t v521;
  void *v522;
  const char *v523;
  uint64_t v524;
  uint64_t v525;
  void *v526;
  const char *v527;
  void *v528;
  const char *v529;
  uint64_t v530;
  void *v531;
  uint64_t v532;
  const char *v533;
  uint64_t v534;
  uint64_t v535;
  const char *v536;
  VFXMTLShadableKey *v537;
  const char *v538;
  uint64_t v540;
  VFXMTLRenderPipeline *v541;
  os_unfair_lock_s *lock;
  void *v543;
  uint64_t v544;
  unint64_t v545;
  void *v546;
  char v547;
  unint64_t v548;
  unint64_t v549;
  unint64_t v550;
  VFXMTLShadable *v552;
  uint64_t v553;
  uint64_t v554;
  uint64_t v555;
  id obj;
  uint64_t v557;
  uint64_t v558;
  _QWORD v559[6];
  uint64_t v560;
  uint64_t *v561;
  uint64_t v562;
  uint64_t v563;
  _OWORD __src[19];
  __int128 v565;
  __int128 v566;
  __int128 v567;
  __int128 v568;
  _QWORD v569[33];
  _BYTE v570[128];
  uint64_t v571;

  v571 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  if (a2)
  {
    if (a4)
      goto LABEL_4;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"material");
    if (a4)
      goto LABEL_4;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"pipeline");
LABEL_4:
  v12 = sub_1B193FE9C(a2);
  if (a3)
    v13 = sub_1B193FE9C(a3);
  else
    v13 = 0;
  lock = (os_unfair_lock_s *)(a1 + 416);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 416));
  if (!*(_QWORD *)(a1 + 408))
  {
    v16 = objc_alloc(MEMORY[0x1E0CB3748]);
    *(_QWORD *)(a1 + 408) = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v16, v17, 0, 0, 100);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 424) + 8) = a2;
  *(_QWORD *)(*(_QWORD *)(a1 + 424) + 16) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 424) + 24) = a4;
  v18 = (void *)objc_msgSend_objectForKey_(*(void **)(a1 + 408), v14, *(_QWORD *)(a1 + 424), v15);
  v26 = v18;
  if (!v18
    || v12 != objc_msgSend_materialModificationCount(v18, v19, v20, v21)
    || v13 != objc_msgSend_geometryModificationCount(v26, v19, v20, v21))
  {
    v546 = v26;
    v554 = a1;
    v555 = (uint64_t)a3;
    v543 = (void *)sub_1B1813BC4(a5, (uint64_t)v19, v20, v21, v22, v23, v24, v25);
    v544 = objc_msgSend_frameConstantBufferPool(v543, v27, v28, v29);
    v30 = objc_alloc_init(VFXMTLShadable);
    objc_msgSend_setMaterialModificationCount_(v30, v31, v12, v32);
    v552 = v30;
    objc_msgSend_setGeometryModificationCount_(v30, v33, v13, v34);
    v553 = (uint64_t)a2;
    v42 = (float *)sub_1B1878184((uint64_t)a2, v35, v36, v37, v38, v39, v40, v41);
    v565 = 0u;
    v566 = 0u;
    v567 = 0u;
    v568 = 0u;
    v541 = a4;
    obj = (id)objc_msgSend_shadableBufferBindings(a4, v43, v44, v45);
    v558 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v46, (uint64_t)&v565, (uint64_t)v570, 16);
    if (!v558)
      goto LABEL_100;
    v557 = *(_QWORD *)v566;
    while (1)
    {
      for (i = 0; i != v558; ++i)
      {
        if (*(_QWORD *)v566 != v557)
          objc_enumerationMutation(obj);
        v51 = *(_QWORD *)(*((_QWORD *)&v565 + 1) + 8 * i);
        if (objc_msgSend_needsRenderResource((void *)v51, v47, v48, v49))
        {
          v52 = (void *)objc_msgSend_name((void *)v51, v47, v48, v49);
          v56 = objc_msgSend_type((void *)v51, v53, v54, v55);
          switch(v56)
          {
            case 0:
              v550 = v550 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)(v51 + 9);
              v63 = (void *)objc_msgSend_bufferAtIndices_(v546, v47, v550, v49);
              if (v42
                && objc_msgSend_isEqualToString_(v52, v61, (uint64_t)CFSTR("vfx_commonprofile"), v62))
              {
                DWORD2(__src[12]) = sub_1B1841B14((uint64_t)v42, 1, v64, v65, v66, v67, v68, v69);
                HIDWORD(__src[12]) = sub_1B1841B14((uint64_t)v42, 2, v70, v71, v72, v73, v74, v75);
                DWORD1(__src[15]) = sub_1B1841B14((uint64_t)v42, 11, v76, v77, v78, v79, v80, v81);
                DWORD2(__src[15]) = sub_1B1841B14((uint64_t)v42, 12, v82, v83, v84, v85, v86, v87);
                HIDWORD(__src[15]) = sub_1B1841B14((uint64_t)v42, 13, v88, v89, v90, v91, v92, v93);
                LODWORD(__src[16]) = sub_1B1841B14((uint64_t)v42, 14, v94, v95, v96, v97, v98, v99);
                DWORD1(__src[16]) = sub_1B1841B14((uint64_t)v42, 15, v100, v101, v102, v103, v104, v105);
                LODWORD(__src[13]) = sub_1B1841B14((uint64_t)v42, 6, v106, v107, v108, v109, v110, v111);
                LODWORD(__src[14]) = sub_1B1841B14((uint64_t)v42, 3, v112, v113, v114, v115, v116, v117);
                DWORD1(__src[14]) = sub_1B1841B14((uint64_t)v42, 5, v118, v119, v120, v121, v122, v123);
                DWORD2(__src[14]) = sub_1B1841B14((uint64_t)v42, 4, v124, v125, v126, v127, v128, v129);
                HIDWORD(__src[14]) = sub_1B1841B14((uint64_t)v42, 9, v130, v131, v132, v133, v134, v135);
                LODWORD(__src[15]) = sub_1B1841B14((uint64_t)v42, 10, v136, v137, v138, v139, v140, v141);
                DWORD2(__src[16]) = sub_1B1841B14((uint64_t)v42, 16, v142, v143, v144, v145, v146, v147);
                *(_QWORD *)&__src[0] = sub_1B1841964((uint64_t)v42, 1, v148, v149, v150, v151, v152, v153);
                *((_QWORD *)&__src[0] + 1) = v154;
                *(_QWORD *)&__src[1] = sub_1B1841964((uint64_t)v42, 2, v155, v156, v157, v158, v159, v160);
                *((_QWORD *)&__src[1] + 1) = v161;
                LODWORD(__src[8]) = sub_1B1841B7C((uint64_t)v42, 11, v162, v163, v164, v165, v166, v167);
                DWORD1(__src[8]) = sub_1B1841B7C((uint64_t)v42, 12, v168, v169, v170, v171, v172, v173);
                LODWORD(__src[10]) = sub_1B1841B7C((uint64_t)v42, 14, v174, v175, v176, v177, v178, v179);
                *(_QWORD *)&__src[11] = sub_1B1841964((uint64_t)v42, 15, v180, v181, v182, v183, v184, v185);
                *((_QWORD *)&__src[11] + 1) = v186;
                *(_QWORD *)&__src[5] = sub_1B1841964((uint64_t)v42, 3, v187, v188, v189, v190, v191, v192);
                *((_QWORD *)&__src[5] + 1) = v193;
                *(_QWORD *)&__src[6] = sub_1B1841964((uint64_t)v42, 5, v194, v195, v196, v197, v198, v199);
                *((_QWORD *)&__src[6] + 1) = v200;
                *(_QWORD *)&__src[7] = sub_1B1841964((uint64_t)v42, 4, v201, v202, v203, v204, v205, v206);
                *((_QWORD *)&__src[7] + 1) = v207;
                LODWORD(__src[12]) = sub_1B1841B7C((uint64_t)v42, 9, v208, v209, v210, v211, v212, v213);
                DWORD1(__src[12]) = sub_1B1841B7C((uint64_t)v42, 10, v214, v215, v216, v217, v218, v219);
                if (sub_1B1842620((uint64_t)v42, v220, v221, v222, v223, v224, v225, v226))
                {
                  *(_QWORD *)&__src[2] = sub_1B1841964((uint64_t)v42, 7, v227, v228, v229, v230, v231, v232);
                  *((_QWORD *)&__src[2] + 1) = v233;
                  DWORD1(__src[13]) = sub_1B1841B14((uint64_t)v42, 7, v234, v235, v236, v237, v238, v239);
                }
                *(_QWORD *)&__src[4] = sub_1B1841964((uint64_t)v42, 8, v227, v228, v229, v230, v231, v232);
                *((_QWORD *)&__src[4] + 1) = v240;
                HIDWORD(__src[13]) = sub_1B1841B14((uint64_t)v42, 8, v241, v242, v243, v244, v245, v246);
                *(_QWORD *)&__src[3] = sub_1B1841964((uint64_t)v42, 0, v247, v248, v249, v250, v251, v252);
                *((_QWORD *)&__src[3] + 1) = v253;
                DWORD2(__src[13]) = sub_1B1841B14((uint64_t)v42, 0, v254, v255, v256, v257, v258, v259);
                *((float *)&__src[16] + 3) = sub_1B1841434(v42, 17, v260, v261, v262, v263, v264, v265) * 128.0;
                LODWORD(__src[17]) = sub_1B1842628((uint64_t)v42);
                DWORD1(__src[17]) = sub_1B1878320(v553, v266, v267, v268, v269, v270, v271, v272);
                v279 = sub_1B1841434(v42, 18, v273, v274, v275, v276, v277, v278);
                v291 = sub_1B1841434(v42, 19, v280, v281, v282, v283, v284, v285);
                v292 = 0;
                *(float *)&v293 = (float)((float)(1.0 - v279) * (float)(1.0 - v279))
                                / (float)((float)(v279 + 1.0) * (float)(v279 + 1.0));
                *((float *)&v293 + 1) = 1.0 - *(float *)&v293;
                *((float *)&v293 + 2) = v291;
                __src[18] = v293;
                memset(v569, 0, 256);
                v560 = 0;
                v561 = &v560;
                v562 = 0x2020000000;
                v563 = 0;
                do
                {
                  v294 = sub_1B1840E70((uint64_t)v42, (char)v292, 0, v286, v287, v288, v289, v290);
                  v297 = v294;
                  if (v294 && sub_1B1841A40(v294, v295, v296, v286, v287, v288, v289, v290) && sub_1B1842B54(v297))
                  {
                    v299 = sub_1B1842B0C(v297, v298, v296, v286, v287, v288, v289, v290);
                    v300 = v561[3];
                    v561[3] = v300 + 1;
                    v569[v300] = v299;
                  }
                  ++v292;
                }
                while (v292 != 17);
                v559[0] = MEMORY[0x1E0C809B0];
                v559[1] = 3221225472;
                v559[2] = sub_1B18FCFCC;
                v559[3] = &unk_1E63D8FF8;
                v559[5] = v569;
                v559[4] = &v560;
                sub_1B193FD50(v553, (const char *)v559, v296, v286, v287, v288, v289, v290);
                if (v555)
                  sub_1B193FD50(v555, (const char *)v559, v302, v303, v304, v305, v306, v307);
                if (v561[3] < 1)
                {
                  if (objc_msgSend_argumentEncoder((void *)v51, v301, v302, v303))
                  {
                    v308 = objc_alloc_init(VFXMTLBuffer);
                    v471 = (void *)objc_msgSend_argumentEncoder((void *)v51, v468, v469, v470);
                    v475 = objc_msgSend_encodedLength(v471, v472, v473, v474);
                    v477 = (void *)objc_msgSend_newBufferWithLength_options_(*(void **)(v554 + 8), v476, v475, 0);
                    objc_msgSend_setBuffer_(v308, v478, (uint64_t)v477, v479);

                    v483 = (void *)objc_msgSend_argumentEncoder((void *)v51, v480, v481, v482);
                    v487 = objc_msgSend_buffer(v308, v484, v485, v486);
                    v491 = objc_msgSend_offset(v308, v488, v489, v490);
                    objc_msgSend_setArgumentBuffer_offset_(v483, v492, v487, v491);
                    v500 = sub_1B18545A0();
                    if (v500)
                    {
                      v501 = 0;
                      v502 = 27;
                      do
                      {
                        v503 = sub_1B1840E70((uint64_t)v42, v501, 0, v495, v496, v497, v498, v499);
                        if (v503)
                        {
                          isDynamic = objc_msgSend_renderResourceForMaterialProperty_withEngineContext_didFallbackToDefaultTexture_isDynamic_((void *)v554, v493, v503, a5, 0, 0);
                          v512 = sub_1B1842028(v503, v505, v506, v507, v508, v509, v510, v511);
                          if (isDynamic)
                          {
                            v513 = v512;
                            v514 = (void *)objc_msgSend_argumentEncoder((void *)v51, v493, v494, v495);
                            objc_msgSend_setTexture_atIndex_(v514, v515, isDynamic, v502 - 1);
                            v519 = (void *)objc_msgSend_usedResources((void *)v51, v516, v517, v518);
                            objc_msgSend_addObject_(v519, v520, isDynamic, v521);
                            if (!v513)
                              v513 = sub_1B180CF10();
                            v522 = sub_1B18FD03C(v554, v513);
                            v526 = (void *)objc_msgSend_argumentEncoder((void *)v51, v523, v524, v525);
                            objc_msgSend_setSamplerState_atIndex_(v526, v527, (uint64_t)v522, v502);
                          }
                        }
                        v502 += 2;
                        ++v501;
                      }
                      while (v501 != v500);
                    }
                    v528 = (void *)objc_msgSend_argumentEncoder((void *)v51, v493, v494, v495);
                    v531 = (void *)objc_msgSend_constantDataAtIndex_(v528, v529, 0, v530);
                    memcpy(v531, __src, 0x130uLL);
                  }
                  else
                  {
                    v532 = sub_1B1813BC4(a5, v461, v462, v463, v464, v465, v466, v467);
                    v308 = (VFXMTLBuffer *)objc_msgSend_newSubBufferWithBytes_length_renderContext_(*(void **)(v554 + 64), v533, (uint64_t)__src, 304, v532);
                  }
                  v534 = *(_QWORD *)(v554 + 24);
                  ++*(_DWORD *)(v534 + 240);
                  *(_DWORD *)(v534 + 264) += 304;
                }
                else
                {
                  v308 = objc_alloc_init(VFXMTLBuffer);
                  v309 = v561[3] << 6;
                  v310 = v309 + 304;
                  v312 = (void *)objc_msgSend_newBufferWithLength_options_(*(void **)(v554 + 8), v311, v309 + 304, 0);
                  v313 = *(_QWORD *)(v554 + 24);
                  ++*(_DWORD *)(v313 + 240);
                  *(_DWORD *)(v313 + 264) += v310;
                  v317 = (_OWORD *)objc_msgSend_contents(v312, v314, v315, v316);
                  memcpy(v317, __src, 0x130uLL);
                  v325 = v561;
                  if (v561[3] >= 1)
                  {
                    v326 = 0;
                    v327 = v317 + 19;
                    do
                    {
                      v328 = (__int128 *)v569[v326];
                      if (!v328)
                      {
                        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v319, v320, v321, v322, v323, v324, (uint64_t)"textureMatrix");
                        v325 = v561;
                      }
                      v329 = *v328;
                      v330 = v328[1];
                      v331 = v328[3];
                      v327[2] = v328[2];
                      v327[3] = v331;
                      *v327 = v329;
                      v327[1] = v330;
                      v327 += 4;
                      ++v326;
                    }
                    while (v326 < v325[3]);
                  }
                  objc_msgSend_setBuffer_(v308, v318, (uint64_t)v312, v320);

                }
                _Block_object_dispose(&v560, 8);
              }
              else
              {
                v308 = objc_alloc_init(VFXMTLBuffer);
                v357 = (void *)sub_1B193FCB0(v553, v52, v344, v345, v346, v347, v348, v349);
                v358 = v555 == 0;
                if (v357)
                  v358 = 1;
                if (!v358)
                  v357 = (void *)sub_1B193FCB0(v555, v52, v351, v352, v353, v354, v355, v356);
                if (!v357 && (byte_1EEF66220 & 1) == 0)
                {
                  byte_1EEF66220 = 1;
                  v359 = objc_msgSend_name((void *)v51, v350, v351, v352);
                  sub_1B17C4408(16, (uint64_t)CFSTR("Error: missing value for attachment \"%@\" [vertex: %d fragment: %d]"), v360, v361, v362, v363, v364, v365, v359);
                }
                v366 = (void *)objc_msgSend_binding((void *)v51, v350, v351, v352);
                v370 = objc_msgSend_bufferDataSize(v366, v367, v368, v369);
                if (objc_msgSend_conformsToProtocol_(v357, v371, (uint64_t)&unk_1EF024118, v372))
                {
                  if (objc_msgSend_length(v357, v373, v374, v375) >= v370)
                  {
                    objc_msgSend_setBuffer_(v308, v376, (uint64_t)v357, v378);
                  }
                  else
                  {
                    if ((byte_1EEF66221 & 1) == 0)
                    {
                      byte_1EEF66221 = 1;
                      v379 = *(char *)(v51 + 9);
                      objc_msgSend_length(v357, v376, v377, v378);
                      sub_1B17C4408(16, (uint64_t)CFSTR("Error: incorrect buffer size  for attachments vertex [%d] fragments [%d]. Expected:%d Provided:%d"), v380, v381, v382, v383, v384, v385, v379);
                    }
                    v386 = (void *)objc_msgSend_newBufferWithLength_options_(*(void **)(v554 + 8), v376, v370, 0);
                    objc_msgSend_setBuffer_(v308, v387, (uint64_t)v386, v388);

                    objc_msgSend_setOffset_(v308, v389, 0, v390);
                  }
                }
                else
                {
                  objc_opt_class();
                  isKindOfClass = objc_opt_isKindOfClass();
                  if ((isKindOfClass & 1) != 0)
                  {
                    v430 = objc_msgSend_length(v357, v426, v427, v428);
                    if (v430 > v370)
                      v370 = v430;
                  }
                  v431 = (void *)objc_msgSend_buffer(v63, v426, v427, v428);
                  if (objc_msgSend_length(v431, v432, v433, v434) == v370)
                  {
                    v438 = objc_msgSend_buffer(v63, v435, v436, v437);
                    objc_msgSend_setBuffer_(v308, v439, v438, v440);
                    memset(__src, 0, 24);
                    sub_1B1868B34(v544, v370, __src);
                    sub_1B18FD1E0((void *)v51, (uint64_t)v52, *(void **)&__src[0], v555, v370, v553, v357, isKindOfClass & 1);
                    v444 = *(void **)objc_msgSend_resourceBlitEncoder(v543, v441, v442, v443);
                    v445 = *((_QWORD *)&__src[0] + 1);
                    v446 = *(_QWORD *)&__src[1];
                    v450 = objc_msgSend_buffer(v308, v447, v448, v449);
                    objc_msgSend_copyFromBuffer_sourceOffset_toBuffer_destinationOffset_size_(v444, v451, v445, v446, v450, 0, v370);
                  }
                  else
                  {
                    v452 = (void *)objc_msgSend_newBufferWithLength_options_(*(void **)(v554 + 8), v435, v370, 0);
                    objc_msgSend_setBuffer_(v308, v453, (uint64_t)v452, v454);

                    objc_msgSend_setOffset_(v308, v455, 0, v456);
                    v460 = (void *)objc_msgSend_contents(v308, v457, v458, v459);
                    sub_1B18FD1E0((void *)v51, (uint64_t)v52, v460, v555, v370, v553, v357, isKindOfClass & 1);
                  }
                }
              }
              v535 = objc_msgSend_type((void *)v51, v391, v392, v393);
              v548 = v548 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)(v51 + 9);
              objc_msgSend_setResource_ofType_atIndices_(v552, v536, (uint64_t)v308, v535);

              continue;
            case 1:
              continue;
            case 2:
              v339 = sub_1B193FCB0(v553, v52, v48, v49, v57, v58, v59, v60);
              v340 = v555 == 0;
              if (v339)
                v340 = 1;
              if (!v340)
                v339 = sub_1B193FCB0(v555, v52, v333, v334, v335, v336, v337, v338);
              LOBYTE(__src[0]) = 0;
              LOBYTE(v569[0]) = 0;
              if (v339 && (v341 = CFGetTypeID(v339), v341 == sub_1B1843480()))
              {
                v342 = objc_msgSend_renderResourceForMaterialProperty_withEngineContext_didFallbackToDefaultTexture_isDynamic_((void *)v554, v332, (uint64_t)v339, a5, __src, v569);
                v547 = 0;
                v343 = (uint64_t)v339;
                if (v342)
                {
                  v343 = (uint64_t)v339;
LABEL_69:
                  v415 = objc_msgSend_type((void *)v51, v332, v333, v334);
                  v549 = v549 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)(v51 + 9);
                  objc_msgSend_setResource_ofType_atIndices_(v552, v416, v342, v415);
                  if (LOBYTE(__src[0]) | LOBYTE(v569[0]))
                    objc_msgSend_setMaterialModificationCount_(v552, v47, -1, v49);
                  v421 = *(unsigned __int8 *)(v51 + 11);
                  v422 = *(unsigned __int8 *)(v51 + 12);
                  if (v422 != 255 || (_DWORD)v421 != 255)
                  {
                    if ((v547 & 1) != 0
                      || (v423 = sub_1B1842028(v343, (uint64_t)v47, v48, v49, v417, v418, v419, v420)) == 0)
                    {
                      v423 = sub_1B180CF10();
                    }
                    v424 = sub_1B18FD03C(v554, v423);
                    v545 = v545 & 0xFFFFFFFFFFFF0000 | v421 | (v422 << 8);
                    objc_msgSend_setResource_ofType_atIndices_(v552, v425, (uint64_t)v424, 3);
                  }
                  continue;
                }
              }
              else
              {
                if ((byte_1EEF66222 & 1) == 0)
                {
                  byte_1EEF66222 = 1;
                  sub_1B17C4408(16, (uint64_t)CFSTR("Warning: Missing texture value for %@"), v333, v334, v335, v336, v337, v338, (uint64_t)v52);
                }
                v343 = 0;
                v547 = 1;
              }
              LOBYTE(__src[0]) = 1;
              v394 = (void *)objc_msgSend_binding((void *)v51, v332, v333, v334);
              v398 = objc_msgSend_textureType(v394, v395, v396, v397);
              v342 = objc_msgSend_defaultTextureForTextureType_((void *)v554, v399, v398, v400);
              v408 = (void *)sub_1B1813BC4(a5, v401, v402, v403, v404, v405, v406, v407);
              v412 = (void *)objc_msgSend_resourceManagerMonitor(v408, v409, v410, v411);
              if (v412)
              {
                v540 = v51;
                v413 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v332, (uint64_t)CFSTR("Unable to find texture for binding %@ (\"%@\") and effect materialProperty %@ derived from value %@ (geometry=%@, material=%@)"), v334);
                objc_msgSend_renderContext_didFallbackToDefaultTextureForSource_message_(v412, v414, (uint64_t)v408, v51, v413);
              }
              goto LABEL_69;
            case 3:
              sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Sampler are not yet implemented as separate bindings"), v48, v49, v57, v58, v59, v60, v540);
              continue;
            default:
              if ((unint64_t)(v56 - 16) >= 2)
                sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: binding type not supported"), v48, v49, v57, v58, v59, v60, v540);
              continue;
          }
        }
      }
      v558 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v47, (uint64_t)&v565, (uint64_t)v570, 16);
      if (!v558)
      {
LABEL_100:
        v537 = objc_alloc_init(VFXMTLShadableKey);
        v537->_material = (__CFXMaterial *)v553;
        v537->_geometry = (__CFXGeometry *)v555;
        v537->_pipeline = v541;
        objc_msgSend_setObject_forKey_(*(void **)(v554 + 408), v538, (uint64_t)v552, (uint64_t)v537);

        os_unfair_lock_unlock(lock);
        return v552;
      }
    }
  }
  os_unfair_lock_unlock(lock);
  return (VFXMTLShadable *)v26;
}

void sub_1B18FCF74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  _Block_object_dispose(&a41, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18FCFCC(uint64_t a1, int a2, CFTypeRef cf)
{
  CFTypeID v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v5 = CFGetTypeID(cf);
  result = sub_1B1843480();
  if (cf && v5 == result)
  {
    result = sub_1B1842B54((uint64_t)cf);
    if ((_DWORD)result)
    {
      result = sub_1B1842B0C((uint64_t)cf, v7, v8, v9, v10, v11, v12, v13);
      v14 = *(_QWORD *)(a1 + 40);
      v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v16 = *(_QWORD *)(v15 + 24);
      *(_QWORD *)(v15 + 24) = v16 + 1;
      *(_QWORD *)(v14 + 8 * v16) = result;
    }
  }
  return result;
}

void *sub_1B18FD03C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  os_unfair_lock_s *v4;
  void *v5;
  id v6;
  const char *v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  void *v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  const char *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  const char *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  const char *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  const char *v128;
  uint64_t v129;
  float v130;
  const char *v131;
  uint64_t v132;
  void *v133;
  uint64_t v134;
  const char *v135;

  if (!a1)
    return 0;
  v2 = a2;
  if (!a2)
    v2 = sub_1B180CF10();
  v4 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v5 = *(void **)(a1 + 152);
  if (!v5)
  {
    v6 = objc_alloc(MEMORY[0x1E0CB3748]);
    v5 = (void *)objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v6, v7, 258, 0, 100);
    *(_QWORD *)(a1 + 152) = v5;
  }
  v8 = sub_1B180C828(v2);
  v11 = (void *)objc_msgSend_objectForKey_(v5, v9, v8, v10);
  if (!v11)
  {
    v12 = objc_alloc_init(MEMORY[0x1E0CC6B80]);
    v20 = sub_1B180CDF0(v2, v13, v14, v15, v16, v17, v18, v19);
    v28 = sub_1B189CEBC(v20, v21, v22, v23, v24, v25, v26, v27);
    objc_msgSend_setMinFilter_(v12, v29, v28, v30);
    v38 = sub_1B180CE38(v2, v31, v32, v33, v34, v35, v36, v37);
    v46 = sub_1B189CEBC(v38, v39, v40, v41, v42, v43, v44, v45);
    objc_msgSend_setMagFilter_(v12, v47, v46, v48);
    v56 = sub_1B180CE80(v2, v49, v50, v51, v52, v53, v54, v55);
    v64 = sub_1B189CF10(v56, v57, v58, v59, v60, v61, v62, v63);
    objc_msgSend_setMipFilter_(v12, v65, v64, v66);
    v74 = sub_1B180CD18(v2, v67, v68, v69, v70, v71, v72, v73);
    v82 = sub_1B189CE68(v74, v75, v76, v77, v78, v79, v80, v81);
    objc_msgSend_setSAddressMode_(v12, v83, v82, v84);
    v92 = sub_1B180CD60(v2, v85, v86, v87, v88, v89, v90, v91);
    v100 = sub_1B189CE68(v92, v93, v94, v95, v96, v97, v98, v99);
    objc_msgSend_setTAddressMode_(v12, v101, v100, v102);
    v110 = sub_1B180CDA8(v2, v103, v104, v105, v106, v107, v108, v109);
    v118 = sub_1B189CE68(v110, v111, v112, v113, v114, v115, v116, v117);
    objc_msgSend_setRAddressMode_(v12, v119, v118, v120);
    v130 = sub_1B180CEC8(v2, v121, v122, v123, v124, v125, v126, v127);
    if (v130 < 1.0)
      v130 = 1.0;
    objc_msgSend_setMaxAnisotropy_(v12, v128, (unint64_t)fminf(v130, 16.0), v129);
    v11 = (void *)objc_msgSend_newSamplerStateWithDescriptor_(*(void **)(a1 + 8), v131, (uint64_t)v12, v132);

    v133 = *(void **)(a1 + 152);
    v134 = sub_1B180C828(v2);
    objc_msgSend_setObject_forKey_(v133, v135, (uint64_t)v11, v134);

  }
  os_unfair_lock_unlock(v4);
  return v11;
}

uint64_t sub_1B18FD1E0(void *a1, uint64_t a2, void *a3, uint64_t a4, size_t a5, uint64_t a6, void *cf, int a8)
{
  CFTypeID v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const void *v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  CFTypeID v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t result;
  const char *v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  const char *v66;
  uint64_t v67;
  void *v68;
  const char *v69;
  uint64_t v70;
  uint64_t v71;
  void *v72;
  const char *v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  const char *v77;
  uint64_t v78;
  uint64_t v79;
  void *v80;
  const char *v81;
  const char *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  BOOL v87;
  int v88;
  uint64_t v89;
  void *v90;
  uint64_t v91;
  const char *v92;
  uint64_t v93;
  const void *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  const void *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  CFTypeID v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  CFStringRef v114;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  _BYTE v121[128];
  uint64_t v122;

  v122 = *MEMORY[0x1E0C80C00];
  if (cf)
  {
    v15 = CFGetTypeID(cf);
    if (v15 == sub_1B191E200())
    {
      v19 = (void *)objc_msgSend_binding(a1, v16, v17, v18);
      v23 = objc_msgSend_bufferDataType(v19, v20, v21, v22);
      if ((sub_1B189DBA4((uint64_t)cf, v23, (uint64_t)a3, v24, v25, v26, v27, v28) & 1) == 0)
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: Argument '%@' : failed to write value to Metal buffer (%@)"), v30, v31, v32, v33, v34, v35, a2);
    }
    else if (a8)
    {
      v36 = (const void *)objc_msgSend_bytes(cf, v16, v17, v18);
      if (objc_msgSend_length(cf, v37, v38, v39) == a5)
        memcpy(a3, v36, a5);
      else
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: Argument '%@' : mismatch between the NSData and the buffer size %ld != %ld"), v40, v41, v42, v43, v44, v45, a2);
    }
    else
    {
      v46 = CFGetTypeID(cf);
      v114 = CFCopyTypeIDDescription(v46);
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: Argument '%@' : only NSData and NSValue are supported for shadable value storage (found '%@'). Please make sure that your custom shader modifier uniform types match the custom properties of the shadable object"), v47, v48, v49, v50, v51, v52, a2);
      CFRelease(v114);
    }
  }
  else
  {
    bzero(a3, a5);
  }
  v53 = (void *)objc_msgSend_binding(a1, v29, v30, v31);
  result = objc_msgSend_bufferDataType(v53, v54, v55, v56);
  if (result == 1)
  {
    v61 = (void *)objc_msgSend_binding(a1, v58, v59, v60);
    v65 = (void *)objc_msgSend_name(v61, v62, v63, v64);
    v68 = (void *)objc_msgSend_stringByAppendingString_(v65, v66, (uint64_t)CFSTR("."), v67);
    v72 = (void *)objc_msgSend_binding(a1, v69, v70, v71);
    v76 = (void *)objc_msgSend_bufferStructType(v72, v73, v74, v75);
    v80 = (void *)objc_msgSend_members(v76, v77, v78, v79);
    v117 = 0u;
    v118 = 0u;
    v119 = 0u;
    v120 = 0u;
    result = objc_msgSend_countByEnumeratingWithState_objects_count_(v80, v81, (uint64_t)&v117, (uint64_t)v121, 16);
    if (result)
    {
      v85 = result;
      v86 = *(_QWORD *)v118;
      if (a4)
        v87 = cf == 0;
      else
        v87 = 0;
      v88 = v87;
      do
      {
        v89 = 0;
        do
        {
          if (*(_QWORD *)v118 != v86)
            objc_enumerationMutation(v80);
          v90 = *(void **)(*((_QWORD *)&v117 + 1) + 8 * v89);
          v91 = objc_msgSend_name(v90, v82, v83, v84);
          v94 = (const void *)objc_msgSend_stringByAppendingString_(v68, v92, v91, v93);
          v101 = sub_1B193FCB0(a6, v94, v95, v96, v97, v98, v99, v100);
          if (v88)
            v101 = sub_1B193FCB0(a4, v94, v83, v84, v102, v103, v104, v105);
          v106 = (uint64_t)v101;
          if (v101)
          {
            v107 = CFGetTypeID(v101);
            if (v107 == sub_1B191E200())
              sub_1B189E450(v106, v90, (uint64_t)a3, v109);
            else
              sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. only CFXValue are supported for partial struct storage"), v108, v109, v110, v111, v112, v113, (uint64_t)"0");
          }
          ++v89;
        }
        while (v85 != v89);
        result = objc_msgSend_countByEnumeratingWithState_objects_count_(v80, v82, (uint64_t)&v117, (uint64_t)v121, 16);
        v85 = result;
      }
      while (result);
    }
  }
  return result;
}

uint64_t sub_1B18FD494(uint64_t result, char *a2, void *a3, void *a4)
{
  unint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  _QWORD v30[3];
  _QWORD v31[3];

  if (result)
  {
    v7 = objc_msgSend_threadExecutionWidth(a4, a2, (uint64_t)a3, (uint64_t)a4);
    v11 = objc_msgSend_width(a2, v8, v9, v10);
    if (v7 >= v11)
      v15 = v11;
    else
      v15 = v7;
    v16 = objc_msgSend_height(a2, v12, v13, v14);
    if (v7 >= v16)
      v7 = v16;
    v20 = objc_msgSend_maxTotalThreadsPerThreadgroup(a4, v17, v18, v19);
    do
    {
      v24 = v7;
      v25 = v7 * v15;
      v7 >>= 1;
    }
    while (v25 > v20);
    v31[0] = (v15 + objc_msgSend_width(a2, v21, v22, v23) - 1) / v15;
    v31[1] = (v24 + objc_msgSend_height(a2, v26, v27, v28) - 1) / v24;
    v31[2] = 1;
    v30[0] = v15;
    v30[1] = v24;
    v30[2] = 1;
    return objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(a3, v29, (uint64_t)v31, (uint64_t)v30);
  }
  return result;
}

uint64_t sub_1B18FD568(uint64_t result, char *a2, void *a3, void *a4)
{
  unint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  _QWORD v26[3];
  _QWORD v27[3];

  if (result)
  {
    v7 = objc_msgSend_threadExecutionWidth(a4, a2, (uint64_t)a3, (uint64_t)a4);
    v11 = objc_msgSend_width(a2, v8, v9, v10);
    if (v7 >= v11)
      v7 = v11;
    v15 = objc_msgSend_maxTotalThreadsPerThreadgroup(a4, v12, v13, v14);
    v19 = v7;
    do
    {
      v20 = v19;
      v21 = v19 * v7;
      v19 >>= 1;
    }
    while (v21 > v15);
    v27[0] = (v7 + objc_msgSend_width(a2, v16, v17, v18) - 1) / v7;
    v27[1] = (v20 + objc_msgSend_height(a2, v22, v23, v24) - 1) / v20;
    v27[2] = 6;
    v26[0] = v7;
    v26[1] = v20;
    v26[2] = 1;
    return objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(a3, v25, (uint64_t)v27, (uint64_t)v26);
  }
  return result;
}

uint64_t sub_1B18FD634(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

uint64_t sub_1B18FD640(uint64_t result)
{
  uint64_t v1;
  _QWORD block[5];

  if (result)
  {
    v1 = result;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_1B18FD6C0;
    block[3] = &unk_1E63D6D80;
    block[4] = result;
    if (qword_1EEF66228 != -1)
      dispatch_once(&qword_1EEF66228, block);
    return *(_QWORD *)(v1 + 488);
  }
  return result;
}

void sub_1B18FD6C0(uint64_t a1)
{
  const char *v2;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  id v8;

  v8 = objc_alloc_init(MEMORY[0x1E0CC6A88]);
  objc_msgSend_setDepthCompareFunction_(v8, v2, 7, v3);
  objc_msgSend_setDepthWriteEnabled_(v8, v4, 0, v5);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 488) = objc_msgSend_newDepthStencilStateWithDescriptor_(*(void **)(*(_QWORD *)(a1 + 32) + 8), v6, (uint64_t)v8, v7);

}

uint64_t sub_1B18FD760(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1B1872064(a3);
}

uint64_t sub_1B18FD768(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 32);
  return result;
}

uint64_t sub_1B18FD774(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 8);
  return result;
}

uint64_t sub_1B18FD780(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t sub_1B18FD8D4(uint64_t result)
{
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 40) = 0;
  return result;
}

uint64_t sub_1B18FDC58(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = objc_msgSend_didFinishPlayback(*(void **)(a1 + 32), a2, a3, a4);
  if (result)
  {
    v9 = objc_msgSend_didFinishPlayback(*(void **)(a1 + 32), v6, v7, v8);
    return (*(uint64_t (**)(void))(v9 + 16))();
  }
  return result;
}

uint64_t sub_1B18FDC98(uint64_t a1)
{
  const char *v2;
  uint64_t v3;
  int8x16_t v4;
  const char *v5;
  _QWORD v7[4];
  int8x16_t v8;
  uint64_t v9;

  dispatch_async(MEMORY[0x1E0C80D38], *(dispatch_block_t *)(a1 + 48));
  objc_msgSend_setCompleted_(*(void **)(a1 + 32), v2, 1, v3);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = sub_1B18FDD30;
  v7[3] = &unk_1E63D7EA8;
  v9 = *(_QWORD *)(a1 + 56);
  v4 = *(int8x16_t *)(a1 + 32);
  v8 = vextq_s8(v4, v4, 8uLL);
  return objc_msgSend_postCommandWithContext_object_applyBlock_(VFXTransaction, v5, 0, v4.i64[0], v7);
}

uint64_t sub_1B18FDD30(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  const void *v10;
  _BYTE *v11;

  v9 = *(_QWORD *)(a1 + 48);
  if (v9)
  {
    sub_1B186D644(v9, *(const void **)(a1 + 32), 1, a4, a5, a6, a7, a8);
    v10 = *(const void **)(a1 + 48);
    if (v10)
      CFRelease(v10);
  }
  v11 = *(_BYTE **)(a1 + 40);
  if (v11[50])
    return MEMORY[0x1E0DE7D20](v11, sel_recycle, a3, a4);
  else
    return objc_msgSend_reset(v11, a2, a3, a4);
}

uint64_t sub_1B18FDD84(int8x16_t *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const char *v5;
  uint64_t v6;
  int8x16_t v7;
  _QWORD v9[4];
  int8x16_t v10;
  uint64_t v11;

  if (!objc_msgSend_loops(*(void **)(a1[2].i64[0] + 24), a2, a3, a4))
    return (*(uint64_t (**)(void))(a1[3].i64[0] + 16))();
  v6 = a1[3].i64[1];
  if (!v6)
    return (*(uint64_t (**)(void))(a1[3].i64[0] + 16))();
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = sub_1B18FDE2C;
  v9[3] = &unk_1E63D7EA8;
  v11 = v6;
  v7 = a1[2];
  v10 = vextq_s8(v7, v7, 8uLL);
  return objc_msgSend_postCommandWithContext_object_applyBlock_(VFXTransaction, v5, 0, v7.i64[0], v9);
}

void sub_1B18FDE2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  const void *v10;
  _QWORD block[5];

  v9 = *(_QWORD *)(a1 + 48);
  if (v9)
  {
    sub_1B186D644(v9, *(const void **)(a1 + 32), 1, a4, a5, a6, a7, a8);
    v10 = *(const void **)(a1 + 48);
    if (v10)
      CFRelease(v10);
  }
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_1B18FDEB4;
  block[3] = &unk_1E63D6D80;
  block[4] = *(_QWORD *)(a1 + 40);
  dispatch_async(MEMORY[0x1E0C80D38], block);
}

uint64_t sub_1B18FDEB4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_play(*(void **)(a1 + 32), a2, a3, a4);
}

uint64_t sub_1B18FDEBC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t started;

  result = objc_msgSend_willStartPlayback(*(void **)(a1 + 32), a2, a3, a4);
  if (result)
  {
    started = objc_msgSend_willStartPlayback(*(void **)(a1 + 32), v6, v7, v8);
    return (*(uint64_t (**)(void))(started + 16))();
  }
  return result;
}

void sub_1B18FDF54(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1B18FE310(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  qword_1EEF66238 = objc_msgSend_dictionary(MEMORY[0x1E0C99E08], a2, a3, a4);
  return (id)qword_1EEF66238;
}

uint64_t sub_1B18FE964(uint64_t *a1)
{
  uint64_t result;

  result = sub_1B179CB60(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B18FE990()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const CFDictionaryKeyCallBacks *v7;
  const CFDictionaryValueCallBacks *v8;
  __CFNotificationCenter *LocalCenter;
  __CFNotificationCenter *v10;

  if (qword_1EEF66250 != -1)
    dispatch_once_f(&qword_1EEF66250, &qword_1EEF66248, (dispatch_function_t)sub_1B18FE964);
  v6 = sub_1B179CB90(qword_1EEF66248, 0x20uLL);
  if (!v6)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v0, v1, v2, v3, v4, v5, (uint64_t)"resourceCache");
  v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  *(_QWORD *)(v6 + 16) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v6 + 24) = CFDictionaryCreateMutable(0, 0, 0, 0);
  *(_QWORD *)(v6 + 32) = CFDictionaryCreateMutable(0, 0, v7, v8);
  *(_DWORD *)(v6 + 40) = 0;
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(LocalCenter, (const void *)v6, (CFNotificationCallback)sub_1B18FEACC, CFSTR("kCFXNotificationImageWillDie"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  v10 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(v10, (const void *)v6, (CFNotificationCallback)sub_1B18FEACC, CFSTR("kCFXNotificationImageProxyWillDie"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  return v6;
}

void sub_1B18FEACC(int a1, uint64_t a2, int a3, CFNumberRef number)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *valuePtr;

  valuePtr = 0;
  CFNumberGetValue(number, kCFNumberLongType, &valuePtr);
  sub_1B18FF164(a2, valuePtr, v5, v6, v7, v8, v9, v10);
}

uint64_t sub_1B18FEB10()
{
  if (qword_1EEF66258 != -1)
    dispatch_once(&qword_1EEF66258, &unk_1E63D1150);
  return qword_1EEF66260;
}

uint64_t sub_1B18FEB50()
{
  uint64_t result;

  result = sub_1B18FE990();
  qword_1EEF66260 = result;
  return result;
}

const void *sub_1B18FEB6C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v10;
  void *Value;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  CFTypeID v16;
  CFTypeID v17;
  _BOOL4 v18;
  double v19;
  uint64_t isKindOfClass;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  const char *v30;
  uint64_t v31;
  void *v32;
  const __CFNumber *v33;
  double v34;
  double valuePtr;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"cache");
    if (a2)
      goto LABEL_3;
LABEL_15:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    goto LABEL_3;
  }
  if (!a2)
    goto LABEL_15;
LABEL_3:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  v10 = (void *)sub_1B18FED3C(a2);
  Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v10);
  v15 = (const void *)objc_msgSend_copyWeakRef(Value, v12, v13, v14);
  if (v15)
  {
    v16 = CFGetTypeID(v10);
    if (v16 == CFURLGetTypeID() || (v17 = CFGetTypeID(v10), v17 == CFStringGetTypeID()))
    {
      v18 = VFXHasSpecialResourceBundle();
      v19 = sub_1B1883210(v10);
      if (v19 == 0.0 && VFXHasSpecialResourceBundle())
      {
        objc_opt_class();
        isKindOfClass = objc_opt_isKindOfClass();
        v24 = (uint64_t)v10;
        if ((isKindOfClass & 1) != 0)
        {
          isKindOfClass = objc_msgSend_path(v10, v21, v22, v23);
          v24 = isKindOfClass;
        }
        v25 = (void *)VFXGetResourceBundle(isKindOfClass, v21, v22, v23);
        v29 = (void *)objc_msgSend_bundlePath(v25, v26, v27, v28);
        v32 = (void *)objc_msgSend_stringByAppendingPathComponent_(v29, v30, v24, v31);
        v19 = sub_1B1883210(v32);
      }
      if (v19 == 0.0)
      {
        if (!v18)
          goto LABEL_21;
        goto LABEL_20;
      }
      valuePtr = 0.0;
      v33 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v10);
      if (v33)
      {
        CFNumberGetValue(v33, kCFNumberDoubleType, &valuePtr);
        v34 = valuePtr;
      }
      else
      {
        v34 = 0.0;
      }
      if (v34 != v19)
      {
LABEL_20:
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), v10);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), v15);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v10);
        CFRelease(v15);
        v15 = 0;
      }
    }
  }
LABEL_21:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
  return v15;
}

uint64_t sub_1B18FED3C(void *a1)
{
  CFTypeID v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;

  v2 = CFGetTypeID(a1);
  v6 = (uint64_t)a1;
  if (v2 == CFURLGetTypeID())
  {
    v6 = (uint64_t)a1;
    if (objc_msgSend_isFileURL(a1, v3, v4, v5))
    {
      v6 = (uint64_t)a1;
      if (!objc_msgSend_query(a1, v7, v8, v9))
        v6 = objc_msgSend_relativePath(a1, v10, v11, v12);
    }
  }
  if (v2 == CFStringGetTypeID())
    return objc_msgSend_stringByStandardizingPath(a1, v13, v14, v15);
  else
    return v6;
}

CFTypeRef sub_1B18FEDC8(uint64_t a1, void *a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeRef result;

  v3 = (void *)sub_1B18FED3C(a2);
  result = sub_1B18FEB6C(a1, v3, v4, v5, v6, v7, v8, v9);
  if (result)
    return CFAutorelease(result);
  return result;
}

const void *sub_1B18FEE08(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *Value;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"cache");
    if (a2)
      goto LABEL_3;
LABEL_5:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"resource");
    goto LABEL_3;
  }
  if (!a2)
    goto LABEL_5;
LABEL_3:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
  return Value;
}

void sub_1B18FEEA8(uint64_t a1, void *cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeID v11;
  CFTypeID v12;
  double v13;
  void *v14;
  CFTypeID v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *Value;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  const __CFDictionary *v25;
  VFXWeakPointer *v26;
  const char *v27;
  uint64_t v28;
  CFNumberRef v29;
  _QWORD v30[6];
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  double valuePtr;

  if (a1)
  {
    if (cf)
      goto LABEL_3;
LABEL_14:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    if (a3)
      goto LABEL_4;
LABEL_15:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"resource");
    goto LABEL_4;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"cache");
  if (!cf)
    goto LABEL_14;
LABEL_3:
  if (!a3)
    goto LABEL_15;
LABEL_4:
  valuePtr = 0.0;
  v11 = CFGetTypeID(cf);
  if (v11 == CFURLGetTypeID() || (v12 = CFGetTypeID(cf), v13 = 0.0, v12 == CFStringGetTypeID()))
  {
    v13 = sub_1B1883210(cf);
    valuePtr = v13;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  v14 = (void *)sub_1B18FED3C(cf);
  v15 = CFGetTypeID(v14);
  if (v15 == CFStringGetTypeID())
    v14 = (void *)objc_msgSend_copy(v14, v16, v17, v18);
  else
    CFRetain(v14);
  Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v14);
  if (Value)
  {
    v23 = objc_msgSend_copyWeakRef(Value, v20, v21, v22);
    if (v23)
    {
      v24 = (const void *)v23;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), v14);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), v24);
      CFRelease(v24);
    }
    else
    {
      v31 = 0;
      v32 = &v31;
      v33 = 0x2020000000;
      v34 = 0;
      v25 = *(const __CFDictionary **)(a1 + 24);
      v30[0] = MEMORY[0x1E0C809B0];
      v30[1] = 3221225472;
      v30[2] = sub_1B18FF144;
      v30[3] = &unk_1E63D9090;
      v30[4] = &v31;
      v30[5] = v14;
      sub_1B17A04DC(v25, (uint64_t)v30);
      if (v32[3])
      {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), v14);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), (const void *)v32[3]);
      }
      _Block_object_dispose(&v31, 8);
    }
  }
  v26 = objc_alloc_init(VFXWeakPointer);
  objc_msgSend_setWeakRef_(v26, v27, (uint64_t)a3, v28);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v14, v26);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a3, v14);

  CFRelease(v14);
  if (v13 != 0.0)
  {
    v29 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v14, v29);
    CFRelease(v29);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
}

void sub_1B18FF12C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B18FF144(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)(result + 40) == a3)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  return result;
}

void sub_1B18FF164(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *Value;

  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"cache");
    if (a2)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"resource");
LABEL_3:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), Value);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), a2);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
}

void sub_1B18FF218(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  __CFNotificationCenter *LocalCenter;
  __CFNotificationCenter *v6;

  if ((_QWORD *)qword_1EEF66260 == a1)
    qword_1EEF66260 = 0;
  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(LocalCenter, a1, CFSTR("kCFXNotificationImageProxyWillDie"), 0);
  v6 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(v6, a1, CFSTR("kCFXNotificationImageWillDie"), 0);
}

CFStringRef sub_1B18FF2AC(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXResourceCache 0x%lx>"), a1);
}

CFStringRef sub_1B18FF2E8(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXResourceCache 0x%lx>"), a1);
}

uint64_t sub_1B18FF324()
{
  if (qword_1ED4CEAA8 != -1)
    dispatch_once(&qword_1ED4CEAA8, &unk_1E63D1170);
  return qword_1ED4CEAB0;
}

void sub_1B18FF364()
{
  if (!qword_1ED4CEAB0)
    qword_1ED4CEAB0 = sub_1B179CB60(&qword_1ED4CEAB0);
}

uint64_t sub_1B18FF3A4()
{
  uint64_t v0;

  if (qword_1ED4CEAA8 != -1)
    dispatch_once(&qword_1ED4CEAA8, &unk_1E63D1170);
  v0 = sub_1B179CB90(qword_1ED4CEAB0, 0xA0uLL);
  sub_1B185CF98(v0);
  *(_QWORD *)(v0 + 168) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  return v0;
}

void sub_1B18FF420(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"AnimationGroup");
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 168), value);
}

void sub_1B18FF470(uint64_t a1, CFArrayRef theArray, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFArray *v10;
  CFRange v11;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"group");
    if (theArray)
      goto LABEL_3;
LABEL_5:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"animations");
    goto LABEL_3;
  }
  if (!theArray)
    goto LABEL_5;
LABEL_3:
  v10 = *(__CFArray **)(a1 + 168);
  v11.length = CFArrayGetCount(theArray);
  v11.location = 0;
  CFArrayAppendArray(v10, theArray, v11);
}

CFIndex sub_1B18FF4FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"AnimationGroup");
  return CFArrayGetCount(*(CFArrayRef *)(a1 + 168));
}

const void *sub_1B18FF544(uint64_t a1, CFIndex idx, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"AnimationGroup");
  return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 168), idx);
}

uint64_t sub_1B18FF594(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"AnimationGroup");
  return *(_QWORD *)(a1 + 168);
}

void sub_1B18FF5DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"AnimationGroup");
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 168));
}

void sub_1B18FF624(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFArray *v16;
  uint64_t Count;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int16 v34;

  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    if (a2)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"dest");
LABEL_3:
  sub_1B18FF5DC(a2, a2, a3, a4, a5, a6, a7, a8);
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v10, v11, v12, v13, v14, v15, (uint64_t)"AnimationGroup");
  v16 = *(const __CFArray **)(a1 + 168);
  Count = CFArrayGetCount(v16);
  Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]);
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v16, i);
      v27 = (const void *)sub_1B185E2E8(ValueAtIndex);
      CFArrayAppendValue(Mutable, v27);
      CFRelease(v27);
    }
  }
  sub_1B18FF470(a2, Mutable, v18, v19, v20, v21, v22, v23);
  CFRelease(Mutable);
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v28, v29, v30, v31, v32, v33, (uint64_t)"group");
  v34 = *(_WORD *)(a1 + 84);
  if (!a2)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v28, v29, v30, v31, v32, v33, (uint64_t)"group");
  *(_WORD *)(a2 + 84) = *(_WORD *)(a2 + 84) & 0xFF7F | v34 & 0x80;
}

id sub_1B18FF7AC(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;

  v9 = (const void *)a1[21];
  if (v9)
  {
    CFRelease(v9);
    a1[21] = 0;
  }
  return sub_1B185CF48(a1, a2, a3, a4, a5, a6, a7, a8);
}

CFStringRef sub_1B18FF7DC(_QWORD *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXAnimationGroup %p animations:%@>"), a1, a1[21]);
}

CFStringRef sub_1B18FF81C(_QWORD *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXAnimationGroup %p animations:%@>"), a1, a1[21]);
}

float32x4_t sub_1B18FFCB0(uint64_t a1, uint64_t a2, uint64_t a3, simd_float4x4 a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8)
{
  float32x4_t v11;
  float32x4_t v12;
  int32x4_t v13;
  uint64_t v14;
  float32x4_t result;
  uint64_t v16;
  float32x4_t v21;
  simd_float3x3 v22;
  simd_float4x4 v23;

  v23 = __invert_f4(a4);
  v11 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v23.columns[3], (float32x4_t)v23.columns[2], a6, 2), (float32x4_t)v23.columns[1], *(float32x2_t *)a6.f32, 1), (float32x4_t)v23.columns[0], a6.f32[0]);
  v12 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v23.columns[3], (float32x4_t)v23.columns[2], a8, 2), (float32x4_t)v23.columns[1], *(float32x2_t *)a8.f32, 1), (float32x4_t)v23.columns[0], a8.f32[0]);
  v21 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v23.columns[3], (float32x4_t)v23.columns[2], a5, 2), (float32x4_t)v23.columns[1], *(float32x2_t *)a5.f32, 1), (float32x4_t)v23.columns[0], a5.f32[0]);
  v23.columns[0] = (simd_float4)vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v23.columns[3], (float32x4_t)v23.columns[2], a7, 2), (float32x4_t)v23.columns[1], *(float32x2_t *)a7.f32, 1), (float32x4_t)v23.columns[0], a7.f32[0]), v11);
  v23.columns[2] = (simd_float4)vsubq_f32(v12, v11);
  v23.columns[3] = (simd_float4)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23.columns[0], (int32x4_t)v23.columns[0]), (int8x16_t)v23.columns[0], 0xCuLL), vnegq_f32((float32x4_t)v23.columns[2])), (float32x4_t)v23.columns[0], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23.columns[2], (int32x4_t)v23.columns[2]), (int8x16_t)v23.columns[2], 0xCuLL));
  v23.columns[1] = (simd_float4)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23.columns[3], (int32x4_t)v23.columns[3]), (int8x16_t)v23.columns[3], 0xCuLL);
  v13 = (int32x4_t)vmulq_f32((float32x4_t)v23.columns[0], (float32x4_t)v23.columns[0]);
  v13.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1))).u32[0];
  *(float32x2_t *)v12.f32 = vrsqrte_f32((float32x2_t)v13.u32[0]);
  *(float32x2_t *)v12.f32 = vmul_f32(*(float32x2_t *)v12.f32, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)v12.f32)));
  v23.columns[0] = (simd_float4)vmulq_n_f32((float32x4_t)v23.columns[0], vmul_f32(*(float32x2_t *)v12.f32, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)v12.f32))).f32[0]);
  v23.columns[3] = (simd_float4)vmulq_f32((float32x4_t)v23.columns[3], (float32x4_t)v23.columns[3]);
  v23.columns[3].i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.columns[3].f32, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v23.columns[3], 2), *(float32x2_t *)v23.columns[3].f32)).u32[0];
  *(float32x2_t *)v13.i8 = vrsqrte_f32((float32x2_t)v23.columns[3].u32[0]);
  *(float32x2_t *)v13.i8 = vmul_f32(*(float32x2_t *)v13.i8, vrsqrts_f32((float32x2_t)v23.columns[3].u32[0], vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8)));
  v23.columns[1] = (simd_float4)vmulq_n_f32((float32x4_t)v23.columns[1], vmul_f32(*(float32x2_t *)v13.i8, vrsqrts_f32((float32x2_t)v23.columns[3].u32[0], vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8))).f32[0]);
  v23.columns[3] = (simd_float4)vmulq_f32((float32x4_t)v23.columns[2], (float32x4_t)v23.columns[2]);
  v23.columns[3].i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v23.columns[3], 2), vadd_f32(*(float32x2_t *)v23.columns[3].f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.columns[3].f32, 1))).u32[0];
  *(float32x2_t *)v13.i8 = vrsqrte_f32((float32x2_t)v23.columns[3].u32[0]);
  *(float32x2_t *)v13.i8 = vmul_f32(*(float32x2_t *)v13.i8, vrsqrts_f32((float32x2_t)v23.columns[3].u32[0], vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8)));
  v23.columns[2] = (simd_float4)vmulq_n_f32((float32x4_t)v23.columns[2], vmul_f32(*(float32x2_t *)v13.i8, vrsqrts_f32((float32x2_t)v23.columns[3].u32[0], vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8))).f32[0]);
  v14 = a2 + 36 * a1;
  v23.columns[3] = v23.columns[0];
  v23.columns[3].i32[3] = v23.columns[1].i32[0];
  *(simd_float4 *)v14 = v23.columns[3];
  *(int8x16_t *)(v14 + 16) = vextq_s8(vextq_s8((int8x16_t)v23.columns[1], (int8x16_t)v23.columns[1], 0xCuLL), (int8x16_t)v23.columns[2], 8uLL);
  *(_DWORD *)(v14 + 32) = v23.columns[2].i32[2];
  v22 = __invert_f3(*(simd_float3x3 *)v23.columns[0].f32);
  result = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v22.columns[0], v21.f32[0]), (float32x4_t)v22.columns[1], *(float32x2_t *)v21.f32, 1), (float32x4_t)v22.columns[2], v21, 2);
  v16 = a3 + 12 * a1;
  *(_QWORD *)v16 = result.i64[0];
  *(_DWORD *)(v16 + 8) = result.i32[2];
  return result;
}

void sub_1B18FFE58(uint64_t a1, size_t count, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10, float32x4_t a11, float32x4_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,_QWORD *a23,size_t *a24)
{
  int v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const __CFArray *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  CFIndex v42;
  const void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  size_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  _DWORD *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned __int16 *v75;
  uint32x2_t v76;
  float32x2_t v77;
  float32x4_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  float32x4_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int32x4_t v96;
  float32x4_t v97;
  float32x2_t v98;
  float32x2_t v99;
  float32x4_t v100;
  int32x4_t v101;
  int32x4_t v102;
  float32x4_t v103;
  __int32 v104;
  int v105;
  unint64_t v109;
  int8x16_t v110;
  int8x16_t v111;
  int v112;
  int8x16_t v113;
  __int128 v114;
  size_t v116;
  uint64_t v121;
  float32x4_t v124;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v129;
  simd_float3 v130;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  _QWORD v135[18];
  int v136;
  _QWORD block[16];
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  int8x16_t v142[3];
  __int128 v143;
  uint64_t v144;
  simd_float3x3 v145;
  simd_float3x3 v146;
  simd_float4x4 v147;
  simd_float4x4 v148;

  v25 = count;
  v144 = *MEMORY[0x1E0C80C00];
  v121 = count;
  if (a13 == a14)
  {
    v26 = a1;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_1B19004C4;
    block[3] = &unk_1E63D90D0;
    block[4] = a7;
    block[5] = a4;
    block[6] = a6;
    block[7] = a8;
    block[8] = a15;
    block[9] = a16;
    block[10] = a17;
    block[11] = a22;
    block[12] = a21;
    block[13] = a18;
    block[14] = a19;
    block[15] = a20;
    dispatch_apply(count, 0, block);
  }
  else
  {
    v138.i64[0] = 0;
    v138.i64[1] = (uint64_t)&v138;
    v139.i64[0] = 0x2020000000;
    v139.i32[2] = 0;
    v27 = malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
    v35 = sub_1B1874BE0(a3, v28, v29, v30, v31, v32, v33, v34);
    v41 = (char *)v35 - 1;
    if ((uint64_t)v35 >= 1)
    {
      v42 = 0;
      do
      {
        v43 = sub_1B1874C3C(a3, v42, 0, v36, v37, v38, v39, v40);
        sub_1B17A4804((uint64_t)v43, a13, v44, v45, v46, v47, v48, v49, (uint64_t)v142);
        sub_1B17A4804((uint64_t)v43, a14, v50, v51, v52, v53, v54, v55, (uint64_t)&v143 + 8);
        v135[0] = MEMORY[0x1E0C809B0];
        v135[1] = 3221225472;
        v135[2] = sub_1B19008C4;
        v135[3] = &unk_1E63D90F8;
        v135[6] = a7;
        v135[7] = a4;
        v135[8] = a6;
        v135[9] = a8;
        v135[10] = a15;
        v135[11] = a16;
        v135[12] = a17;
        v135[13] = a22;
        v135[14] = a21;
        v135[15] = a18;
        v135[16] = a19;
        v135[17] = a20;
        v135[4] = &v138;
        v135[5] = v27;
        v136 = v25;
        sub_1B17A51EC(v142[0].i64, 2, (uint64_t)v135, v56, v57, v58, v59, v60);
        if (*(_DWORD *)(v138.i64[1] + 24) == v25)
          break;
      }
      while (v41 != (char *)v42++);
    }
    free(v27);
    _Block_object_dispose(&v138, 8);
    v26 = a1;
  }
  if (v26 == 1)
  {
    v62 = 16 * (3 * v25);
  }
  else if (v26)
  {
    v62 = 0;
  }
  else
  {
    v62 = 4 * (3 * v25);
  }
  v116 = v62;
  v69 = malloc_type_malloc(v62, 0xA21770E6uLL);
  if (v25)
  {
    v70 = 0;
    while (1)
    {
      if (a18)
      {
        v71 = *(unsigned __int8 *)(a18 + (3 * v70));
        v72 = *(unsigned __int8 *)(a18 + (3 * v70 + 1));
        v73 = *(unsigned __int8 *)(a18 + (3 * v70 + 2));
      }
      else if (a19)
      {
        v71 = *(unsigned __int16 *)(a19 + 2 * (3 * v70));
        v72 = *(unsigned __int16 *)(a19 + 2 * (3 * v70 + 1));
        v73 = *(unsigned __int16 *)(a19 + 2 * (3 * v70 + 2));
      }
      else if (a20)
      {
        v71 = *(unsigned int *)(a20 + 4 * (3 * v70));
        v72 = *(unsigned int *)(a20 + 4 * (3 * v70 + 1));
        v73 = *(unsigned int *)(a20 + 4 * (3 * v70 + 2));
      }
      else
      {
        v73 = 0;
        v72 = 0;
        v71 = 0;
      }
      v74 = (2 * v70);
      if (a22)
      {
        v75 = (unsigned __int16 *)(a22 + 2 * v74);
        v76.i32[0] = *v75;
        v76.i32[1] = v75[1];
        v77 = vdiv_f32(vcvt_f32_u32(v76), (float32x2_t)vdup_n_s32(0x477FFF00u));
      }
      else
      {
        v77 = *(float32x2_t *)(a21 + 4 * v74);
      }
      *(float32x2_t *)v132.f32 = v77;
      *(double *)v78.i64 = sub_1B17EE400(a6, v71, v63, v64, v65, v66, v67, v68);
      v129 = v78;
      *(double *)v85.i64 = sub_1B17EE400(a6, v72, v79, v80, v81, v82, v83, v84);
      v126 = v85;
      *(double *)v92.i64 = sub_1B17EE400(a6, v73, v86, v87, v88, v89, v90, v91);
      v133 = vmlaq_n_f32(vmlaq_n_f32(vmulq_lane_f32(v126, *(float32x2_t *)v132.f32, 1), v129, v132.f32[0]), v92, (float)(1.0 - v132.f32[0]) - v132.f32[1]);
      v93 = vsubq_f32(v126, v129);
      v94 = vsubq_f32(v92, v129);
      v95 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v93, (int32x4_t)v93), (int8x16_t)v93, 0xCuLL), vnegq_f32(v94)), v93, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v94, (int32x4_t)v94), (int8x16_t)v94, 0xCuLL));
      v96 = (int32x4_t)vmulq_f32(v93, v93);
      v97 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v95, (int32x4_t)v95), (int8x16_t)v95, 0xCuLL);
      v96.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v96, 2), vadd_f32(*(float32x2_t *)v96.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v96.i8, 1))).u32[0];
      v98 = vrsqrte_f32((float32x2_t)v96.u32[0]);
      v99 = vmul_f32(v98, vrsqrts_f32((float32x2_t)v96.u32[0], vmul_f32(v98, v98)));
      v100 = vmulq_n_f32(v93, vmul_f32(v99, vrsqrts_f32((float32x2_t)v96.u32[0], vmul_f32(v99, v99))).f32[0]);
      v101 = (int32x4_t)vmulq_f32(v95, v95);
      v101.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v101.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v101, 2), *(float32x2_t *)v101.i8)).u32[0];
      *(float32x2_t *)v95.f32 = vrsqrte_f32((float32x2_t)v101.u32[0]);
      *(float32x2_t *)v95.f32 = vmul_f32(*(float32x2_t *)v95.f32, vrsqrts_f32((float32x2_t)v101.u32[0], vmul_f32(*(float32x2_t *)v95.f32, *(float32x2_t *)v95.f32)));
      v127 = vmulq_n_f32(v97, vmul_f32(*(float32x2_t *)v95.f32, vrsqrts_f32((float32x2_t)v101.u32[0], vmul_f32(*(float32x2_t *)v95.f32, *(float32x2_t *)v95.f32))).f32[0]);
      v130 = (simd_float3)v100;
      v102 = (int32x4_t)vmulq_f32(v94, v94);
      v102.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v102, 2), vadd_f32(*(float32x2_t *)v102.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v102.i8, 1))).u32[0];
      *(float32x2_t *)v97.f32 = vrsqrte_f32((float32x2_t)v102.u32[0]);
      *(float32x2_t *)v97.f32 = vmul_f32(*(float32x2_t *)v97.f32, vrsqrts_f32((float32x2_t)v102.u32[0], vmul_f32(*(float32x2_t *)v97.f32, *(float32x2_t *)v97.f32)));
      v124 = vmulq_n_f32(v94, vmul_f32(*(float32x2_t *)v97.f32, vrsqrts_f32((float32x2_t)v102.u32[0], vmul_f32(*(float32x2_t *)v97.f32, *(float32x2_t *)v97.f32))).f32[0]);
      if (a1 == 1)
        break;
      if (!a1)
      {
        *(double *)v103.i64 = sub_1B17EE400(a5, v70, v63, v64, v65, v66, v67, v68);
        v134 = vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a12, a11, v103, 2), a10, *(float32x2_t *)v103.f32, 1), a9, v103.f32[0]), v133);
        v145.columns[1] = (simd_float3)v127;
        v145.columns[0] = v130;
        v145.columns[2] = (simd_float3)v124;
        v146 = __invert_f3(v145);
        v146.columns[0] = (simd_float3)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v146.columns[0], v134.f32[0]), (float32x4_t)v146.columns[1], *(float32x2_t *)v134.f32, 1), (float32x4_t)v146.columns[2], v134, 2);
        v69[(3 * v70)] = v146.columns[0].i32[0];
        v69[(3 * v70 + 1)] = v146.columns[0].i32[1];
        v104 = v146.columns[0].i32[2];
        v105 = 3 * v70 + 2;
LABEL_32:
        v69[v105] = v104;
      }
      if (++v70 == v121)
        goto LABEL_34;
    }
    v147.columns[1] = (simd_float4)v127;
    v147.columns[0] = (simd_float4)v100;
    v147.columns[0].i32[3] = 0;
    v147.columns[1].i32[3] = 0;
    v147.columns[2] = (simd_float4)v124;
    v147.columns[2].i32[3] = 0;
    __asm { FMOV            V3.4S, #1.0 }
    v147.columns[3].i64[0] = v133.i64[0];
    v147.columns[3].i32[2] = v133.i32[2];
    v148 = __invert_f4(v147);
    v109 = 0;
    v138 = a9;
    v139 = a10;
    v140 = a11;
    v141 = a12;
    do
    {
      v142[v109 / 4] = (int8x16_t)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v148.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v138 + v109 * 4))), (float32x4_t)v148.columns[1], *(float32x2_t *)&v138.f32[v109], 1), (float32x4_t)v148.columns[2], *(float32x4_t *)((char *)&v138 + v109 * 4), 2), (float32x4_t)v148.columns[3], *(float32x4_t *)((char *)&v138 + v109 * 4), 3);
      v109 += 4;
    }
    while (v109 != 16);
    v110 = v142[0];
    v111 = v142[1];
    v112 = 12 * v70;
    v113 = v142[2];
    v114 = v143;
    v69[v112] = v142[0].i32[0];
    v69[(12 * (_DWORD)v70) | 1] = v111.i32[0];
    v69[(12 * (_DWORD)v70) | 2] = v113.i32[0];
    v69[(12 * (_DWORD)v70) | 3] = v114;
    *(int32x2_t *)&v69[v112 + 4] = vzip2_s32(*(int32x2_t *)v110.i8, *(int32x2_t *)v111.i8);
    *(int32x2_t *)&v69[v112 + 6] = vzip2_s32(*(int32x2_t *)v113.i8, *(int32x2_t *)&v114);
    *(int32x2_t *)&v69[v112 + 8] = vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v110, v110, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v111, v111, 8uLL));
    v69[v112 + 10] = v113.i32[2];
    v104 = DWORD2(v114);
    v105 = 12 * v70 + 11;
    goto LABEL_32;
  }
LABEL_34:
  *a23 = v69;
  *a24 = v116;
}

void sub_1B1900498(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x200], 8);
  _Unwind_Resume(a1);
}

void sub_1B19004C4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v10;
  uint64_t v11;
  uint64_t v12;
  __int128 *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _WORD *v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  DWORD2(v22) = 0;
  *(_QWORD *)&v22 = 0;
  DWORD2(v21) = 0;
  *(_QWORD *)&v21 = 0;
  DWORD2(v20) = 0;
  *(_QWORD *)&v20 = 0;
  v10 = sub_1B17EE478(a1[4], a2, a3, a4, a5, a6, a7, a8);
  sub_1B190061C(a1[5], a1[7], a1[8], a1[9], &v21, &v20, &v22, v11, v10);
  v12 = a1[11];
  if (a1[10])
    v13 = &v21;
  else
    v13 = &v20;
  v14 = *v13;
  if (v12)
  {
    *(_WORD *)(v12 + 4 * a2) = (int)(float)(65535.0 * *(float *)&v14);
    *(_WORD *)(v12 + ((4 * a2) | 2)) = (int)vmuls_lane_f32(65535.0, *(float32x2_t *)&v14, 1);
  }
  else
  {
    *(_QWORD *)(a1[12] + 8 * a2) = v14;
  }
  v15 = a1[13];
  if (v15)
  {
    *(_BYTE *)(v15 + 3 * a2) = v22;
    *(_BYTE *)(3 * a2 + a1[13] + 1) = BYTE4(v22);
    *(_BYTE *)(3 * a2 + a1[13] + 2) = BYTE8(v22);
  }
  else
  {
    v16 = a1[14];
    if (v16)
    {
      v17 = (_WORD *)(v16 + 6 * a2);
      *v17 = v22;
      v17[1] = WORD2(v22);
      v17[2] = WORD4(v22);
    }
    else
    {
      v18 = a1[15];
      if (v18)
      {
        v19 = v18 + 12 * a2;
        *(_QWORD *)v19 = v22;
        *(_DWORD *)(v19 + 8) = DWORD2(v22);
      }
    }
  }
}

void sub_1B190061C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5, _OWORD *a6, _OWORD *a7, uint64_t a8, double a9)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFArray *v21;
  CFIndex v22;
  const void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  _QWORD v43[14];
  _QWORD v44[3];
  int v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  char v49;
  uint64_t v50[7];
  uint64_t v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v46 = 0;
  v47 = &v46;
  v48 = 0x2020000000;
  v49 = 0;
  v44[0] = 0;
  v44[1] = v44;
  v44[2] = 0x2020000000;
  v45 = 2139095039;
  v62 = 0;
  v63 = &v62;
  v66 = 0;
  v64 = 0x3020000000;
  v65 = 0;
  v57 = 0;
  v58 = &v57;
  v61 = 0;
  v59 = 0x3020000000;
  v60 = 0;
  v52 = 0;
  v53 = &v52;
  v54 = 0x3020000000;
  v56 = 0;
  v55 = 0;
  v21 = sub_1B1874BE0(a1, a2, a3, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  if ((uint64_t)v21 >= 1)
  {
    v22 = 0;
    do
    {
      if (*((_BYTE *)v47 + 24))
        break;
      v23 = sub_1B1874C3C(a1, v22, 0, v16, v17, v18, v19, v20);
      sub_1B17A4804((uint64_t)v23, a3, v24, v25, v26, v27, v28, v29, (uint64_t)v50);
      sub_1B17A4804((uint64_t)v23, a4, v30, v31, v32, v33, v34, v35, (uint64_t)&v51);
      v43[0] = MEMORY[0x1E0C809B0];
      v43[1] = 3221225472;
      v43[2] = sub_1B1901754;
      v43[3] = &unk_1E63D9168;
      *(double *)&v43[10] = a9;
      v43[11] = a5;
      v43[12] = a6;
      v43[13] = a7;
      v43[4] = &v46;
      v43[5] = v44;
      v43[6] = &v57;
      v43[7] = &v62;
      v43[8] = &v52;
      v43[9] = a2;
      sub_1B17A51EC(v50, 2, (uint64_t)v43, v36, v37, v38, v39, v40);
      ++v22;
    }
    while (v21 != (const __CFArray *)v22);
  }
  v41 = v47;
  if (!*((_BYTE *)v47 + 24))
  {
    *a5 = *((_OWORD *)v58 + 2);
    *a6 = *((_OWORD *)v63 + 2);
    *a7 = *((_OWORD *)v53 + 2);
    *((_BYTE *)v41 + 24) = 1;
  }
  _Block_object_dispose(&v52, 8);
  _Block_object_dispose(&v57, 8);
  _Block_object_dispose(&v62, 8);
  _Block_object_dispose(v44, 8);
  _Block_object_dispose(&v46, 8);
}

void sub_1B1900874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  _Block_object_dispose((const void *)(v29 - 256), 8);
  _Block_object_dispose((const void *)(v29 - 208), 8);
  _Block_object_dispose((const void *)(v29 - 160), 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_1B19008C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  __int128 *v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  if ((_DWORD)a4)
  {
    v11 = 0;
    v12 = 2 * a4;
    while (1)
    {
      v13 = *(unsigned int *)(a3 + 4 * v11);
      v14 = *(_QWORD *)(a1 + 40);
      if (!*(_DWORD *)(v14 + 4 * v13))
      {
        v15 = *(unsigned int *)(a3 + 4 * (v11 + 1));
        *(_DWORD *)(v14 + 4 * v13) = 1;
        DWORD2(v27) = 0;
        *(_QWORD *)&v27 = 0;
        DWORD2(v26) = 0;
        *(_QWORD *)&v26 = 0;
        DWORD2(v25) = 0;
        *(_QWORD *)&v25 = 0;
        v16 = sub_1B17EE478(*(_QWORD *)(a1 + 48), v15, a3, a4, (uint64_t)a5, a6, a7, a8);
        sub_1B190061C(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), &v26, &v25, &v27, v17, v16);
        v18 = *(_QWORD *)(a1 + 104);
        v19 = *(_QWORD *)(a1 + 96) ? &v26 : &v25;
        v20 = *v19;
        if (v18)
        {
          *(_WORD *)(v18 + 2 * (2 * v13)) = (int)(float)(65535.0 * *(float *)&v20);
          *(_WORD *)(v18 + 2 * ((2 * (_DWORD)v13) | 1u)) = (int)vmuls_lane_f32(65535.0, *(float32x2_t *)&v20, 1);
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 112) + 4 * (2 * v13)) = v20;
        }
        v21 = *(_QWORD *)(a1 + 120);
        if (v21)
        {
          v22 = (3 * v13);
          *(_BYTE *)(v21 + v22) = v27;
          *(_BYTE *)(*(_QWORD *)(a1 + 120) + (v22 + 1)) = BYTE4(v27);
          *(_BYTE *)(*(_QWORD *)(a1 + 120) + (v22 + 2)) = BYTE8(v27);
        }
        else
        {
          v23 = *(_QWORD *)(a1 + 128);
          if (v23)
          {
            *(_WORD *)(v23 + 2 * (3 * v13)) = v27;
            *(_WORD *)(v23 + 2 * (3 * v13 + 1)) = WORD2(v27);
            *(_WORD *)(v23 + 2 * (3 * v13 + 2)) = WORD4(v27);
          }
          else
          {
            v24 = *(_QWORD *)(a1 + 136);
            if (v24)
            {
              *(_DWORD *)(v24 + 4 * (3 * v13)) = v27;
              *(_DWORD *)(v24 + 4 * (3 * v13 + 1)) = DWORD1(v27);
              *(_DWORD *)(v24 + 4 * (3 * v13 + 2)) = DWORD2(v27);
            }
          }
        }
        if (++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == *(_DWORD *)(a1 + 144))
          break;
      }
      v11 += 2;
      if (v12 == v11)
        return;
    }
    *a5 = 1;
  }
}

void sub_1B1900ABC(uint64_t a1, size_t iterations, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9, __n128 a10, __n128 a11, __n128 a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void **a22,void **a23,size_t *a24,void **a25,_QWORD *a26,size_t *a27)
{
  unsigned int v27;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  size_t v36;
  size_t v37;
  __n128 v38;
  __n128 v39;
  __n128 v40;
  __n128 v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD block[4];
  __n128 v47;
  __n128 v48;
  __n128 v49;
  __n128 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void **v64;
  void **v65;
  void **v66;
  _QWORD *v67;

  v27 = iterations;
  v30 = a20;
  v29 = a21;
  v31 = a18;
  v32 = a19;
  v34 = a16;
  v33 = a17;
  if (a1 == 1)
  {
    v36 = 4 * (9 * iterations);
    *a24 = v36;
    v44 = a7;
    v45 = a8;
    v42 = a4;
    v43 = a6;
    v40 = a11;
    v41 = a12;
    v38 = a9;
    v39 = a10;
    *a22 = malloc_type_malloc(v36, 0x5A49ABFAuLL);
    *a23 = malloc_type_malloc(*a24, 0x90028C1uLL);
    v37 = 12 * v27;
    *a27 = v37;
    *a25 = malloc_type_malloc(v37, 0x5933B5D5uLL);
    v35 = malloc_type_malloc(*a27, 0xE4F664EAuLL);
    v34 = a16;
    v33 = a17;
    v32 = a19;
    v30 = a20;
    v29 = a21;
    v31 = a18;
    a9 = v38;
    a10 = v39;
    a11 = v40;
    a12 = v41;
    a4 = v42;
    a6 = v43;
    a7 = v44;
    a8 = v45;
    goto LABEL_5;
  }
  if (!a1)
  {
    v35 = 0;
    *a24 = 0;
    *a22 = 0;
    *a23 = 0;
    *a27 = 0;
    *a25 = 0;
LABEL_5:
    *a26 = v35;
  }
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_1B1900C4C;
  block[3] = &unk_1E63D9140;
  v47 = a9;
  v48 = a10;
  v49 = a11;
  v50 = a12;
  v51 = a6;
  v52 = a4;
  v53 = a13;
  v54 = a7;
  v55 = a8;
  v56 = a15;
  v57 = v29;
  v58 = v30;
  v59 = v32;
  v60 = v34;
  v61 = v33;
  v62 = v31;
  v63 = a1;
  v64 = a22;
  v65 = a25;
  v66 = a23;
  v67 = a26;
  dispatch_apply(v27, 0, block);
}

void sub_1B1900C4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float32x4_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFArray *v23;
  CFIndex i;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  _QWORD *v39;
  __n128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __n128 v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  __n128 v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  __n128 v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  __n128 v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  float32x4_t v75;
  float v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float v81;
  float32x4_t v82;
  float32x4_t v83;
  float v84;
  float v85;
  float v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  _WORD *v90;
  uint64_t v91;
  _DWORD *v92;
  __n128 v93;
  __n128 v95;
  __n128 v96;
  float32x4_t v97;
  __n128 v98;
  float32x4_t v99;
  __n128 v100;
  float32x4_t v101;
  __n128 v102;
  float32x4_t v103;
  __int128 v104;
  float32x4_t v105;
  float32x4_t v106;
  _QWORD v107[4];
  float32x4_t v108;
  uint64_t *v109;
  uint64_t *v110;
  uint64_t *v111;
  uint64_t *v112;
  _QWORD *v113;
  uint64_t *v114;
  uint64_t *v115;
  uint64_t *v116;
  __int128 v117;
  _OWORD v118[3];
  uint64_t v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  uint64_t v123;
  _QWORD v124[3];
  int v125;
  uint64_t v126;
  uint64_t *v127;
  uint64_t v128;
  char v129;
  uint64_t v130;
  uint64_t *v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  uint64_t v135;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  uint64_t v140;
  uint64_t *v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  uint64_t v145;
  _QWORD v146[4];
  int v147;
  uint64_t v148;
  _QWORD v149[4];
  int v150;
  uint64_t v151;
  uint64_t *v152;
  uint64_t v153;
  uint64_t v154;
  int v155;
  uint64_t v156;

  v156 = *MEMORY[0x1E0C80C00];
  *(double *)v9.i64 = sub_1B17EE400(*(_QWORD *)(a1 + 96), a2, a3, a4, a5, a6, a7, a8);
  v103 = v9;
  v99 = *(float32x4_t *)(a1 + 48);
  v101 = *(float32x4_t *)(a1 + 32);
  v97 = *(float32x4_t *)(a1 + 64);
  v105 = *(float32x4_t *)(a1 + 80);
  v126 = 0;
  v127 = &v126;
  v128 = 0x2020000000;
  v129 = 0;
  v151 = 0;
  v152 = &v151;
  v153 = 0x3020000000;
  v155 = 0;
  v154 = 0;
  v148 = 0;
  v149[0] = &v148;
  v150 = 0;
  v149[1] = 0x3020000000;
  v149[3] = 0;
  v145 = 0;
  v146[0] = &v145;
  v147 = 0;
  v146[1] = 0x3020000000;
  v146[3] = 0;
  v124[0] = 0;
  v124[1] = v124;
  v124[2] = 0x2020000000;
  v125 = 2139095039;
  v140 = 0;
  v141 = &v140;
  v144 = 0;
  v142 = 0x3020000000;
  v143 = 0;
  v135 = 0;
  v136 = &v135;
  v139 = 0;
  v137 = 0x3020000000;
  v138 = 0;
  v130 = 0;
  v131 = &v130;
  v132 = 0x3020000000;
  v134 = 0;
  v133 = 0;
  v23 = sub_1B1874BE0(*(_QWORD *)(a1 + 104), v10, v11, v12, v13, v14, v15, v16);
  v106 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v105, v97, v103, 2), v99, *(float32x2_t *)v103.f32, 1), v101, v103.f32[0]);
  if ((uint64_t)v23 >= 1)
  {
    for (i = 0; (const __CFArray *)i != v23; ++i)
    {
      if (*((_BYTE *)v127 + 24))
        break;
      v25 = sub_1B1874C3C(*(_QWORD *)(a1 + 104), i, 0, v18, v19, v20, v21, v22);
      v123 = 0;
      v121 = 0u;
      v122 = 0u;
      v120 = 0u;
      sub_1B17A4804((uint64_t)v25, *(_QWORD *)(a1 + 112), v26, v27, v28, v29, v30, v31, (uint64_t)&v120);
      v118[0] = v120;
      v118[1] = v121;
      v118[2] = v122;
      v119 = v123;
      v107[0] = MEMORY[0x1E0C809B0];
      v107[1] = 3221225472;
      v107[2] = sub_1B19012E0;
      v107[3] = &unk_1E63D9120;
      v117 = *(_OWORD *)(a1 + 120);
      v108 = v106;
      v109 = &v126;
      v110 = &v148;
      v111 = &v145;
      v112 = &v151;
      v113 = v124;
      v114 = &v140;
      v115 = &v135;
      v116 = &v130;
      sub_1B17A5198((uint64_t *)v118, (uint64_t)v107, v32, v33, v34, v35, v36, v37);
    }
  }
  v38 = v127;
  if (!*((_BYTE *)v127 + 24))
  {
    *(_OWORD *)(v149[0] + 32) = *((_OWORD *)v136 + 2);
    *(_OWORD *)(v146[0] + 32) = *((_OWORD *)v141 + 2);
    *((_OWORD *)v152 + 2) = *((_OWORD *)v131 + 2);
    *((_BYTE *)v38 + 24) = 1;
  }
  if (*(_QWORD *)(a1 + 136))
    v39 = v149;
  else
    v39 = v146;
  v104 = *(_OWORD *)(*v39 + 32);
  v40.n128_f64[0] = sub_1B17EE400(*(_QWORD *)(a1 + 120), *((unsigned int *)v152 + 8), v17, v18, v19, v20, v21, v22);
  v102 = v40;
  v47.n128_f64[0] = sub_1B17EE400(*(_QWORD *)(a1 + 120), *((unsigned int *)v152 + 9), v41, v42, v43, v44, v45, v46);
  v100 = v47;
  v54.n128_f64[0] = sub_1B17EE400(*(_QWORD *)(a1 + 120), *((unsigned int *)v152 + 10), v48, v49, v50, v51, v52, v53);
  v98 = v54;
  v61.n128_f64[0] = sub_1B17EE400(*(_QWORD *)(a1 + 128), *((unsigned int *)v152 + 8), v55, v56, v57, v58, v59, v60);
  v96 = v61;
  v68.n128_f64[0] = sub_1B17EE400(*(_QWORD *)(a1 + 128), *((unsigned int *)v152 + 9), v62, v63, v64, v65, v66, v67);
  v95 = v68;
  *(double *)v75.i64 = sub_1B17EE400(*(_QWORD *)(a1 + 128), *((unsigned int *)v152 + 10), v69, v70, v71, v72, v73, v74);
  v76 = (float)(1.0 - *(float *)&v104) - *((float *)&v104 + 1);
  v93 = (__n128)v75;
  v77 = v106;
  v78 = vsubq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v100, *(float32x2_t *)&v104, 1), (float32x4_t)v102, *(float *)&v104), (float32x4_t)v98, v76), v106);
  v79 = vsubq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v95, *(float32x2_t *)&v104, 1), (float32x4_t)v96, *(float *)&v104), v75, v76), v106);
  v80 = vmulq_f32(v78, v78);
  v81 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 2), vaddq_f32(v80, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v80.f32, 1))).f32[0]);
  v82 = vmulq_f32(v79, v79);
  v83 = vmulq_f32(v78, v79);
  v84 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v82, 2), vaddq_f32(v82, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v82.f32, 1))).f32[0]);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 2), vaddq_f32(v83, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.f32, 1))).f32[0] >= 0.0)
  {
    if (v81 >= v84)
    {
      v85 = v84 / (float)(v84 + sub_1B19016A0(v106, v102, v100, v98, v79));
    }
    else
    {
      v86 = sub_1B19016A0(v106, v96, v95, v93, v78);
      v85 = v86 / (float)(v81 + v86);
    }
    v77 = v106;
  }
  else
  {
    v85 = v84 / (float)(v81 + v84);
  }
  *(float *)(*(_QWORD *)(a1 + 144) + 4 * a2) = v85;
  v87 = *(_QWORD *)(a1 + 152);
  if (v87)
  {
    *(_WORD *)(v87 + 4 * a2) = (int)(float)(*(float *)&v104 * 65535.0);
    *(_WORD *)(v87 + ((4 * a2) | 2)) = (int)(float)(*((float *)&v104 + 1) * 65535.0);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * a2) = v104;
  }
  v88 = *(_QWORD *)(a1 + 168);
  if (v88)
  {
    *(_BYTE *)(v88 + 3 * a2) = *((_OWORD *)v152 + 2);
    *(_BYTE *)(3 * a2 + *(_QWORD *)(a1 + 168) + 1) = *((_BYTE *)v152 + 36);
    *(_BYTE *)(3 * a2 + *(_QWORD *)(a1 + 168) + 2) = *((_BYTE *)v152 + 40);
  }
  else
  {
    v89 = *(_QWORD *)(a1 + 176);
    if (v89)
    {
      v90 = (_WORD *)(v89 + 6 * a2);
      *v90 = *((_OWORD *)v152 + 2);
      v90[1] = *((_WORD *)v152 + 18);
      v90[2] = *((_WORD *)v152 + 20);
    }
    else
    {
      v91 = *(_QWORD *)(a1 + 184);
      if (v91)
      {
        v92 = (_DWORD *)(v91 + 12 * a2);
        *v92 = *((_DWORD *)v152 + 8);
        v92[1] = *((_DWORD *)v152 + 9);
        v92[2] = *((_DWORD *)v152 + 10);
      }
    }
  }
  if (*(_QWORD *)(a1 + 192) == 1)
  {
    sub_1B18FFCB0(a2, **(_QWORD **)(a1 + 200), **(_QWORD **)(a1 + 208), *(simd_float4x4 *)(a1 + 32), v77, (float32x4_t)v102, (float32x4_t)v100, (float32x4_t)v98);
    sub_1B18FFCB0(a2, **(_QWORD **)(a1 + 216), **(_QWORD **)(a1 + 224), *(simd_float4x4 *)(a1 + 32), v106, (float32x4_t)v96, (float32x4_t)v95, (float32x4_t)v93);
  }
  _Block_object_dispose(&v130, 8);
  _Block_object_dispose(&v135, 8);
  _Block_object_dispose(&v140, 8);
  _Block_object_dispose(v124, 8);
  _Block_object_dispose(&v145, 8);
  _Block_object_dispose(&v148, 8);
  _Block_object_dispose(&v151, 8);
  _Block_object_dispose(&v126, 8);
}

void sub_1B1901250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  char a65;
  char a69;
  uint64_t v69;

  _Block_object_dispose(&a69, 8);
  _Block_object_dispose(&STACK[0x210], 8);
  _Block_object_dispose(&STACK[0x240], 8);
  _Block_object_dispose(&a61, 8);
  _Block_object_dispose(&STACK[0x270], 8);
  _Block_object_dispose((const void *)(v69 - 224), 8);
  _Block_object_dispose((const void *)(v69 - 176), 8);
  _Block_object_dispose(&a65, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1B19012E0(float32x4_t *a1, uint64_t a2, unsigned int *a3, uint64_t a4, _BYTE *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float32x4_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float32x4_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float32x4_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  float32x4_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  float32x4_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  float32x4_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float32x4_t v62;
  unint64_t v63;
  float32x4_t v64;
  uint64_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float v68;
  float32x4_t v69;
  float32x4_t *v70;
  float32x4_t *v71;
  float32x4_t *v72;
  uint64_t v73;
  float32x4_t *v74;
  float32x4_t *v75;
  float32x4_t *v76;
  char v77;
  _BOOL8 result;
  unsigned int v79;
  unsigned int v80;
  float32x4_t *v81;
  float32x4_t *v82;
  float32x4_t *v83;
  float32x4_t v84;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  unsigned int v89;
  float32x4_t v90;
  float32x4_t v91;
  unsigned int v92;
  uint64_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float v111[3];

  v10 = *a3;
  v9 = a3[1];
  v11 = a3[2];
  v12 = a3[3];
  *(double *)v13.i64 = sub_1B17EE400(a1[7].i64[0], v10, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8);
  v99 = v13;
  *(double *)v20.i64 = sub_1B17EE400(a1[7].i64[0], v9, v14, v15, v16, v17, v18, v19);
  v98 = v20;
  *(double *)v27.i64 = sub_1B17EE400(a1[7].i64[0], v11, v21, v22, v23, v24, v25, v26);
  v97 = v27;
  *(double *)v34.i64 = sub_1B17EE400(a1[7].i64[0], v12, v28, v29, v30, v31, v32, v33);
  v91 = v34;
  *(double *)v41.i64 = sub_1B17EE400(a1[7].i64[1], v10, v35, v36, v37, v38, v39, v40);
  v107 = v41;
  *(double *)v48.i64 = sub_1B17EE400(a1[7].i64[1], v9, v42, v43, v44, v45, v46, v47);
  v105 = v48;
  *(double *)v55.i64 = sub_1B17EE400(a1[7].i64[1], v11, v49, v50, v51, v52, v53, v54);
  v103 = v55;
  *(double *)v62.i64 = sub_1B17EE400(a1[7].i64[1], v12, v56, v57, v58, v59, v60, v61);
  v63 = 0;
  v96 = vsubq_f32(v107, v99);
  v64 = vsubq_f32(v105, v98);
  v95 = v64;
  v65 = v10;
  v64.i32[0] = v10;
  v66 = v64;
  v93 = v9;
  v66.i32[1] = v9;
  v94 = vsubq_f32(v103, v97);
  v67 = v66;
  v67.i32[2] = v11;
  v66.i32[2] = v12;
  v87 = v66;
  v88 = v67;
  v90 = vsubq_f32(v62, v91);
  v92 = v11;
  v64.i32[1] = v11;
  v89 = v12;
  v64.i32[2] = v12;
  v86 = v64;
  while (1)
  {
    v68 = (double)v63 * 0.025;
    v69 = a1[2];
    v101 = v68;
    v70 = (float32x4_t *)(*(_QWORD *)(a1[3].i64[1] + 8) + 32);
    v71 = (float32x4_t *)(*(_QWORD *)(a1[4].i64[0] + 8) + 32);
    v72 = (float32x4_t *)(*(_QWORD *)(a1[4].i64[1] + 8) + 32);
    v73 = *(_QWORD *)(a1[5].i64[0] + 8);
    v74 = *(float32x4_t **)(a1[5].i64[1] + 8);
    v75 = *(float32x4_t **)(a1[6].i64[0] + 8);
    v76 = *(float32x4_t **)(a1[6].i64[1] + 8);
    v111[0] = 0.0;
    v110.i32[2] = 0;
    v110.i64[0] = 0;
    v109.i32[2] = 0;
    v109.i64[0] = 0;
    v104 = vmlaq_n_f32(v98, v95, v68);
    v106 = vmlaq_n_f32(v99, v96, v68);
    v100 = vmlaq_n_f32(v97, v94, v68);
    v108 = v69;
    if (sub_1B1901CD4(v111, &v109, &v110, v106, v104, v100, v69))
    {
      v77 = 1;
      result = v65;
      v80 = v92;
      v79 = v93;
      goto LABEL_18;
    }
    v81 = v74 + 2;
    v82 = v75 + 2;
    v83 = v76 + 2;
    if (v111[0] < *(float *)(v73 + 24))
    {
      *(float *)(v73 + 24) = v111[0];
      *v82 = v109;
      *v81 = v110;
      *v83 = v88;
    }
    v102 = vmlaq_n_f32(v91, v90, v101);
    if (sub_1B1901CD4(v111, &v109, &v110, v106, v104, v102, v108))
    {
      v77 = 1;
      result = v65;
      v79 = v93;
      goto LABEL_17;
    }
    if (v111[0] < *(float *)(v73 + 24))
    {
      *(float *)(v73 + 24) = v111[0];
      *v82 = v109;
      *v81 = v110;
      *v83 = v87;
    }
    if (sub_1B1901CD4(v111, &v109, &v110, v106, v100, v102, v108))
    {
      v77 = 1;
      result = v65;
LABEL_16:
      v79 = v92;
LABEL_17:
      v80 = v89;
LABEL_18:
      *v70 = v109;
      v84.i32[3] = v110.i32[3];
      *v71 = v110;
      v84.i64[0] = __PAIR64__(v79, result);
      v84.i32[2] = v80;
      *v72 = v84;
      goto LABEL_19;
    }
    if (v111[0] < *(float *)(v73 + 24))
    {
      *(float *)(v73 + 24) = v111[0];
      *v82 = v109;
      *v81 = v110;
      *v83 = v86;
    }
    result = sub_1B1901CD4(v111, &v109, &v110, v104, v100, v102, v108);
    if (result)
    {
      v77 = 1;
      result = v93;
      goto LABEL_16;
    }
    v77 = 0;
    if (v111[0] < *(float *)(v73 + 24))
    {
      v70 = v82;
      *(float *)(v73 + 24) = v111[0];
      v71 = v81;
      result = v93;
      v79 = v92;
      v80 = v89;
      v72 = v83;
      goto LABEL_18;
    }
LABEL_19:
    *(_BYTE *)(*(_QWORD *)(a1[3].i64[0] + 8) + 24) = v77;
    if (*(_BYTE *)(*(_QWORD *)(a1[3].i64[0] + 8) + 24))
      break;
    if (++v63 == 41)
      return result;
  }
  *a5 = 1;
  return result;
}

float sub_1B19016A0(float32x4_t a1, __n128 a2, __n128 a3, __n128 a4, float32x4_t a5)
{
  int32x4_t v5;
  float32x2_t v6;
  float32x2_t v7;
  int v8;
  float result;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v14;
  _OWORD v15[2];
  float v16[4];
  _OWORD v17[3];

  v17[0] = a2;
  v17[1] = a3;
  v17[2] = a4;
  sub_1B17C4B84((uint64_t)v16, (uint64_t)v17);
  v5 = (int32x4_t)vmulq_f32(a5, a5);
  v5.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v5, 2), vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 1))).u32[0];
  v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)));
  v15[0] = a1;
  v15[1] = vmulq_n_f32(a5, vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).f32[0]);
  v14.i32[2] = 0;
  v14.i64[0] = 0;
  v8 = sub_1B17C2FB4((uint64_t)v15, v16, &v14);
  result = 0.0;
  if (v8)
  {
    v10 = vsubq_f32(v14, a1);
    v11 = vmulq_f32(v10, v10);
    return sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
  }
  return result;
}

uint64_t sub_1B1901754(_QWORD *a1, uint64_t a2, unsigned int *a3, uint64_t a4, _BYTE *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  __int32 v14;
  uint64_t v15;
  __int32 v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  float32x2_t v39;
  double v40;
  double v41;
  double v42;
  int8x16_t v43;
  uint64_t result;
  double v45;
  double v46;
  double v47;
  int8x16_t v48;
  __int128 v49;
  float32x4_t v50;
  float32x2_t v51;
  float v52;
  uint64_t v53;
  double v54;
  double v55;
  double v56;
  int8x16_t v57;
  float32x4_t v58;
  float32x2_t v59;
  float v60;
  uint64_t v61;
  double v62;
  double v63;
  double v64;
  int8x16_t v65;
  float32x4_t v66;
  float32x2_t v67;
  float v68;
  uint64_t v69;
  float32x4_t v70;
  float32x2_t v71;
  float v72;
  uint64_t v73;
  __int128 v74;
  float32x4_t v75;
  float32x4_t v76;

  v10 = *a3;
  v12 = a3[2];
  v11 = a3[3];
  v14 = a3[4];
  v13 = a3[5];
  v16 = a3[6];
  v15 = a3[7];
  v17 = sub_1B17EE478(a1[9], a3[1], (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8);
  v24 = sub_1B17EE478(a1[9], v11, v18, v19, v20, v21, v22, v23);
  v31 = sub_1B17EE478(a1[9], v13, v25, v26, v27, v28, v29, v30);
  v38 = sub_1B17EE478(a1[9], v15, v32, v33, v34, v35, v36, v37);
  v76.i32[2] = 0;
  v76.i64[0] = 0;
  v75.i32[2] = 0;
  v75.i64[0] = 0;
  v39 = (float32x2_t)a1[10];
  result = sub_1B1901AF4(&v75, &v76, *(float32x2_t *)&v17, *(float32x2_t *)&v24, *(float32x2_t *)&v31, v39, v40, v41, v42, v43);
  if ((_DWORD)result)
  {
    *(float32x4_t *)a1[11] = v75;
    HIDWORD(v49) = v76.i32[3];
    *(float32x4_t *)a1[12] = v76;
    *(_QWORD *)&v49 = __PAIR64__(v12, v10);
    DWORD2(v49) = v14;
LABEL_17:
    *(_OWORD *)a1[13] = v49;
    *a5 = 1;
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
    return result;
  }
  v50 = v76;
  v51 = vsub_f32(vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v24, *(float32x2_t *)v76.f32, 1), *(float32x2_t *)&v17, v76.f32[0]), *(float32x2_t *)&v31, v76, 2), v39);
  v52 = vaddv_f32(vmul_f32(v51, v51));
  v53 = *(_QWORD *)(a1[5] + 8);
  if (v52 < *(float *)(v53 + 24))
  {
    *(float *)(v53 + 24) = v52;
    *(float32x4_t *)(*(_QWORD *)(a1[6] + 8) + 32) = v75;
    *(float32x4_t *)(*(_QWORD *)(a1[7] + 8) + 32) = v50;
    v50.i64[0] = __PAIR64__(v12, v10);
    v50.i32[2] = v14;
    *(float32x4_t *)(*(_QWORD *)(a1[8] + 8) + 32) = v50;
    v39 = (float32x2_t)a1[10];
  }
  result = sub_1B1901AF4(&v75, &v76, *(float32x2_t *)&v17, *(float32x2_t *)&v24, *(float32x2_t *)&v38, v39, v45, v46, v47, v48);
  if ((_DWORD)result)
  {
    *(float32x4_t *)a1[11] = v75;
    HIDWORD(v49) = v76.i32[3];
    *(float32x4_t *)a1[12] = v76;
    *(_QWORD *)&v49 = __PAIR64__(v12, v10);
LABEL_16:
    DWORD2(v49) = v16;
    goto LABEL_17;
  }
  v58 = v76;
  v59 = vsub_f32(vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v24, *(float32x2_t *)v76.f32, 1), *(float32x2_t *)&v17, v76.f32[0]), *(float32x2_t *)&v38, v76, 2), v39);
  v60 = vaddv_f32(vmul_f32(v59, v59));
  v61 = *(_QWORD *)(a1[5] + 8);
  if (v60 < *(float *)(v61 + 24))
  {
    *(float *)(v61 + 24) = v60;
    *(float32x4_t *)(*(_QWORD *)(a1[6] + 8) + 32) = v75;
    *(float32x4_t *)(*(_QWORD *)(a1[7] + 8) + 32) = v58;
    v58.i64[0] = __PAIR64__(v12, v10);
    v58.i32[2] = v16;
    *(float32x4_t *)(*(_QWORD *)(a1[8] + 8) + 32) = v58;
    v39 = (float32x2_t)a1[10];
  }
  result = sub_1B1901AF4(&v75, &v76, *(float32x2_t *)&v17, *(float32x2_t *)&v31, *(float32x2_t *)&v38, v39, v54, v55, v56, v57);
  if ((_DWORD)result)
  {
    *(float32x4_t *)a1[11] = v75;
    HIDWORD(v49) = v76.i32[3];
    *(float32x4_t *)a1[12] = v76;
    LODWORD(v49) = v10;
LABEL_15:
    DWORD1(v49) = v14;
    goto LABEL_16;
  }
  v66 = v76;
  v67 = vsub_f32(vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v31, *(float32x2_t *)v76.f32, 1), *(float32x2_t *)&v17, v76.f32[0]), *(float32x2_t *)&v38, v76, 2), v39);
  v68 = vaddv_f32(vmul_f32(v67, v67));
  v69 = *(_QWORD *)(a1[5] + 8);
  if (v68 < *(float *)(v69 + 24))
  {
    *(float *)(v69 + 24) = v68;
    *(float32x4_t *)(*(_QWORD *)(a1[6] + 8) + 32) = v75;
    *(float32x4_t *)(*(_QWORD *)(a1[7] + 8) + 32) = v66;
    v66.i64[0] = __PAIR64__(v14, v10);
    v66.i32[2] = v16;
    *(float32x4_t *)(*(_QWORD *)(a1[8] + 8) + 32) = v66;
    v39 = (float32x2_t)a1[10];
  }
  result = sub_1B1901AF4(&v75, &v76, *(float32x2_t *)&v24, *(float32x2_t *)&v31, *(float32x2_t *)&v38, v39, v62, v63, v64, v65);
  if ((_DWORD)result)
  {
    *(float32x4_t *)a1[11] = v75;
    HIDWORD(v49) = v76.i32[3];
    *(float32x4_t *)a1[12] = v76;
    LODWORD(v49) = v12;
    goto LABEL_15;
  }
  v70 = v76;
  v71 = vsub_f32(vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v31, *(float32x2_t *)v76.f32, 1), *(float32x2_t *)&v24, v76.f32[0]), *(float32x2_t *)&v38, v76, 2), v39);
  v72 = vaddv_f32(vmul_f32(v71, v71));
  v73 = *(_QWORD *)(a1[5] + 8);
  if (v72 < *(float *)(v73 + 24))
  {
    *(float *)(v73 + 24) = v72;
    HIDWORD(v74) = v75.i32[3];
    *(float32x4_t *)(*(_QWORD *)(a1[6] + 8) + 32) = v75;
    *(_QWORD *)&v74 = __PAIR64__(v14, v12);
    *(float32x4_t *)(*(_QWORD *)(a1[7] + 8) + 32) = v70;
    DWORD2(v74) = v16;
    *(_OWORD *)(*(_QWORD *)(a1[8] + 8) + 32) = v74;
  }
  return result;
}

uint64_t sub_1B1901AF4(float32x4_t *a1, float32x4_t *a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, float32x2_t a6, double a7, double a8, double a9, int8x16_t _Q7)
{
  int8x16_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  int32x2_t v21;
  float32x2_t v22;
  float32x4_t v27;
  float32x4_t v28;
  uint32x4_t v30;
  unsigned int v31;
  float v32;
  float v33;
  float32x2_t v34;
  int32x2_t v35;
  int32x2_t v36;
  float32x2_t v37;

  v11 = vsub_f32(a4, a3);
  v12 = vsub_f32(a5, a3);
  v13 = vsub_f32(a6, a3);
  v14 = vmul_f32(v11, v11);
  v15 = vadd_f32(v14, (float32x2_t)vdup_lane_s32((int32x2_t)v14, 1));
  *(float32x2_t *)_Q7.i8 = vmul_f32(v11, v12);
  v16 = (int32x2_t)vmul_f32(v12, v12);
  v17 = (int32x2_t)vmul_f32(v11, v13);
  v18 = (int32x2_t)vmul_f32(v12, v13);
  _D6 = vadd_f32((float32x2_t)vzip1_s32(v17, *(int32x2_t *)_Q7.i8), (float32x2_t)vzip2_s32(v17, *(int32x2_t *)_Q7.i8));
  _D5 = vadd_f32((float32x2_t)vzip1_s32(v18, v16), (float32x2_t)vzip2_s32(v18, v16));
  v21 = (int32x2_t)vmla_n_f32(vmul_n_f32(_D6, -_D6.f32[1]), _D5, v15.f32[0]);
  v22 = (float32x2_t)vdup_lane_s32(v21, 0);
  __asm { FMLA            S7, S6, V5.S[1] }
  v22.i32[0] = _Q7.i32[0];
  *(float32x2_t *)_Q7.i8 = vdiv_f32(v22, (float32x2_t)vdup_lane_s32(v21, 1));
  *(float *)v10.i32 = (float)(1.0 - *(float *)_Q7.i32) - *(float *)&_Q7.i32[1];
  v27 = (float32x4_t)vextq_s8(vextq_s8(v10, v10, 4uLL), _Q7, 0xCuLL);
  v28 = v27;
  v28.i32[3] = v27.i32[2];
  __asm { FMOV            V20.4S, #1.0 }
  v30 = (uint32x4_t)vceqq_f32(vminq_f32(vmaxq_f32(v28, (float32x4_t)0), _Q20), v27);
  v30.i32[3] = v30.i32[2];
  v31 = vminvq_u32(v30);
  if ((v31 & 0x80000000) != 0)
  {
    *a1 = v28;
    goto LABEL_29;
  }
  if (*(float *)v10.i32 < 0.0)
  {
    if (*(float *)_Q7.i32 < 0.0)
    {
      *a1 = v28;
      v28 = (float32x4_t)xmmword_1B2244D90;
LABEL_29:
      *a2 = v28;
      return v31 >> 31;
    }
    if (*(float *)&_Q7.i32[1] < 0.0)
    {
      *a1 = v28;
      v28 = (float32x4_t)xmmword_1B2244DD0;
      goto LABEL_29;
    }
    v34 = vsub_f32(a5, a4);
    v35 = (int32x2_t)vmul_f32(v34, vsub_f32(a6, a4));
    v36 = (int32x2_t)vmul_f32(v34, v34);
    v37 = vadd_f32((float32x2_t)vzip1_s32(v35, v36), (float32x2_t)vzip2_s32(v35, v36));
    v33 = vdiv_f32(v37, (float32x2_t)vdup_lane_s32((int32x2_t)v37, 1)).f32[0];
    if (v33 >= 1.0)
      v33 = 1.0;
    if (v33 <= 0.0)
      v33 = 0.0;
    *a1 = v28;
    v28.i32[0] = 0;
    v28.i32[3] = 0;
    v28.f32[1] = 1.0 - v33;
LABEL_28:
    v28.f32[2] = v33;
    goto LABEL_29;
  }
  if (*(float *)_Q7.i32 < 0.0 && *(float *)&_Q7.i32[1] < 0.0)
  {
    *a1 = v28;
    v28 = (float32x4_t)xmmword_1B2244DB0;
    goto LABEL_29;
  }
  if (*(float *)&_Q7.i32[1] < 0.0)
  {
    v32 = vdiv_f32(_D6, v15).f32[0];
    if (v32 >= 1.0)
      v32 = 1.0;
    if (v32 <= 0.0)
      v32 = 0.0;
    *a1 = v28;
    v28.i64[1] = 0;
    v28.f32[0] = 1.0 - v32;
    v28.f32[1] = v32;
    goto LABEL_29;
  }
  if (*(float *)_Q7.i32 < 0.0)
  {
    v33 = _D5.f32[0] / _D5.f32[1];
    if ((float)(_D5.f32[0] / _D5.f32[1]) >= 1.0)
      v33 = 1.0;
    if (v33 <= 0.0)
      v33 = 0.0;
    *a1 = v28;
    v28.i32[1] = 0;
    v28.i32[3] = 0;
    v28.f32[0] = 1.0 - v33;
    goto LABEL_28;
  }
  return v31 >> 31;
}

BOOL sub_1B1901CD4(_DWORD *a1, float32x4_t *a2, float32x4_t *a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7)
{
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v13;
  int32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int32x4_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x4_t v21;
  int32x4_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  int32x4_t v31;
  int32x4_t v32;
  float32x4_t v33;
  int32x4_t v34;
  int8x16_t v35;
  int32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v45;
  float32x4_t v46;

  v10 = vsubq_f32(a5, a4);
  v11 = vsubq_f32(a6, a4);
  v13 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), (int8x16_t)v10, 0xCuLL);
  v14 = (int32x4_t)vmlaq_f32(vmulq_f32(v13, vnegq_f32(v11)), v10, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL));
  v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v14, v14), (int8x16_t)v14, 0xCuLL);
  v16 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), (int8x16_t)v15, 0xCuLL), vnegq_f32(v10)), v15, v13);
  v17 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v16, (int32x4_t)v16), (int8x16_t)v16, 0xCuLL);
  v18 = (int32x4_t)vmulq_f32(v10, v10);
  v18.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v18, 2), vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v18.i8, 1))).u32[0];
  v19 = vrsqrte_f32((float32x2_t)v18.u32[0]);
  v20 = vmul_f32(v19, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v19, v19)));
  v21 = vmulq_n_f32(v10, vmul_f32(v20, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v20, v20))).f32[0]);
  v22 = (int32x4_t)vmulq_f32(v16, v16);
  v22.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v22.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v22, 2), *(float32x2_t *)v22.i8)).u32[0];
  v23 = vrsqrte_f32((float32x2_t)v22.u32[0]);
  v24 = vmul_f32(v23, vrsqrts_f32((float32x2_t)v22.u32[0], vmul_f32(v23, v23)));
  v25 = vmulq_n_f32(v17, vmul_f32(v24, vrsqrts_f32((float32x2_t)v22.u32[0], vmul_f32(v24, v24))).f32[0]);
  v26 = vmulq_f32(a7, v21);
  v27 = vmulq_f32(a7, v25);
  v28 = vmlaq_n_f32(vmulq_n_f32(v25, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]), v21, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]);
  v29 = (int32x4_t)vmulq_f32(v10, v21);
  v30 = (int32x4_t)vmulq_f32(v10, v25);
  *(int32x2_t *)v30.i8 = vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v29, 2), vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v29.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v30, 2), vadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v30.i8, 1))));
  v31 = (int32x4_t)vmulq_f32(v11, v21);
  v32 = (int32x4_t)vmulq_f32(v11, v25);
  v33 = vsubq_f32(v28, a4);
  v34 = (int32x4_t)vmulq_f32(v21, v33);
  v35 = (int8x16_t)vdupq_laneq_s32(v34, 2);
  *(int32x2_t *)v21.f32 = vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v31, 2), vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v31.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v32, 2), vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v32.i8, 1))));
  v36 = (int32x4_t)vmulq_f32(v25, v33);
  v46.i32[2] = 0;
  v46.i64[0] = 0;
  v45.i32[2] = 0;
  v45.i64[0] = 0;
  sub_1B1901AF4(&v46, &v45, 0, *(float32x2_t *)v30.i8, *(float32x2_t *)v21.f32, (float32x2_t)vzip1_s32((int32x2_t)vadd_f32(*(float32x2_t *)v35.i8, vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v34.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v36, 2), vadd_f32(*(float32x2_t *)v36.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v36.i8, 1)))), 0.0, *(double *)v33.i64, *(double *)v34.i64, v35);
  v37 = v45;
  v38 = vsubq_f32(a7, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a5, *(float32x2_t *)v45.f32, 1), a4, v45.f32[0]), a6, v45, 2));
  v39 = vmulq_f32(v38, v38);
  v39.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0];
  *a1 = v39.i32[0];
  *a2 = v46;
  *a3 = v37;
  return v39.f32[0] == 0.0;
}

void sub_1B1901F5C(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1EEF66270);
  _Unwind_Resume(a1);
}

uint64_t sub_1B19023B4(uint64_t result, uint64_t a2, float a3)
{
  *(_QWORD *)result = off_1E63CC498;
  *(float *)(result + 64) = a3;
  *(_QWORD *)(result + 72) = a2;
  return result;
}

__n128 *sub_1B19023CC(__n128 *result, __n128 a2)
{
  result[3] = a2;
  return result;
}

float32x4_t sub_1B19023D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v17;
  float32x2_t v18;
  int8x16_t v19;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t result;

  v10 = sub_1B1869AC8(*(_QWORD *)(a1 + 72), a2, a3, a4, a5, a6, a7, a8);
  v11.i32[3] = 0;
  v11.i32[0] = HIDWORD(*(_QWORD *)v10);
  v12.i32[0] = *(_QWORD *)(v10 + 8);
  v13 = *(float32x4_t *)(v10 + 48);
  v14.i32[0] = *(_OWORD *)v10;
  v14.i32[1] = *(_OWORD *)(v10 + 16);
  v14.i64[1] = *(_OWORD *)(v10 + 32);
  v11.i32[1] = HIDWORD(*(_QWORD *)(v10 + 16));
  v11.i32[2] = HIDWORD(*(_QWORD *)(v10 + 32));
  v12.i32[1] = *(_QWORD *)(v10 + 24);
  v12.i64[1] = *(_QWORD *)(v10 + 40);
  v13.i32[3] = 0;
  v15 = (int8x16_t)vmulq_f32(*(float32x4_t *)v10, *(float32x4_t *)v10);
  _Q2 = vmulq_f32(*(float32x4_t *)(v10 + 16), *(float32x4_t *)(v10 + 16));
  v17 = vmulq_f32(*(float32x4_t *)(v10 + 32), *(float32x4_t *)(v10 + 32));
  v18 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v15.i8, *(int32x2_t *)_Q2.f32), (float32x2_t)vzip2_s32(*(int32x2_t *)v15.i8, *(int32x2_t *)_Q2.f32));
  v19 = vextq_s8(v15, v15, 8uLL);
  *(float32x2_t *)v19.i8 = vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v19.i8, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)_Q2, (int8x16_t)_Q2, 8uLL)), v18));
  __asm { FMOV            V2.2S, #1.0 }
  *(float32x2_t *)_Q2.f32 = vdiv_f32(*(float32x2_t *)_Q2.f32, *(float32x2_t *)v19.i8);
  v19.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0]);
  *(int8x16_t *)(a1 + 16) = v19;
  _Q2.f32[2] = 1.0 / *(float *)&v19.i32[2];
  _Q2.i32[3] = 0;
  v24 = vmulq_f32(v12, _Q2);
  v25 = vmulq_f32(v11, _Q2);
  v26 = vmulq_f32(v14, _Q2);
  v27 = *(float32x4_t *)(a1 + 48);
  v28 = (int8x16_t)vmulq_f32(v27, v24);
  v27.i32[3] = 0;
  v29 = (int8x16_t)vmulq_f32(v27, v26);
  v30 = vmulq_f32(v27, v25);
  v28.i32[3] = 0;
  *(float32x2_t *)v30.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v29.i8, *(float32x2_t *)v30.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL)));
  *(float32x2_t *)&v30.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)), 0);
  v31 = vaddq_f32(v13, v30);
  v30.i32[0] = *(_DWORD *)(a1 + 64);
  *(float32x4_t *)a2 = v26;
  *(float32x4_t *)(a2 + 16) = v25;
  result = vmulq_n_f32(v31, v30.f32[0]);
  *(float32x4_t *)(a2 + 32) = v24;
  *(float32x4_t *)(a2 + 48) = result;
  return result;
}

uint64_t sub_1B19024F8(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  int8x16_t v12;
  int8x16_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  uint64_t v40;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  _OWORD v50[4];
  _OWORD v51[4];

  v9 = *(float32x4_t *)(a2 + 16);
  v10 = *(float32x4_t *)(a2 + 32);
  v11 = a1[3];
  v12 = (int8x16_t)vmulq_f32(v10, v11);
  v11.i32[3] = 0;
  v13 = (int8x16_t)vmulq_f32(*(float32x4_t *)a2, v11);
  v14 = vmulq_f32(v9, v11);
  v12.i32[3] = 0;
  *(float32x2_t *)v14.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v14.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL)));
  *(float32x2_t *)&v14.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL)), 0);
  v15 = (float32x4_t)vtrn1q_s32(*(int32x4_t *)a2, (int32x4_t)v9);
  v16.i64[0] = vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL).u64[0];
  v15.i64[1] = v10.u32[0];
  *(int32x2_t *)v17.f32 = vzip2_s32(*(int32x2_t *)a2, *(int32x2_t *)v9.f32);
  *(int32x2_t *)&v17.u32[2] = vzip2_s32(*(int32x2_t *)v10.f32, 0);
  v16.i64[1] = vextq_s8((int8x16_t)v10, (int8x16_t)v10, 8uLL).u32[0];
  v18 = vsubq_f32(vmulq_n_f32(*(float32x4_t *)(a2 + 48), 1.0 / a1[4].f32[0]), v14);
  v18.i32[3] = 1.0;
  v19 = a1[1];
  v42 = vmulq_lane_f32(v17, *(float32x2_t *)v19.f32, 1);
  v43 = vmulq_n_f32(v15, v19.f32[0]);
  v46 = v43;
  v47 = v42;
  v44 = vmulq_laneq_f32(v16, v19, 2);
  v45 = v18;
  v48 = v44;
  v49 = v18;
  v20 = sub_1B186B574(a1[4].i64[1], a2, a3, a4, a5, a6, a7, a8);
  if (v20)
  {
    v28 = v20;
    if (sub_1B186B574(v20, v21, v22, v23, v24, v25, v26, v27))
    {
      *(double *)v36.i64 = sub_1B186B90C(v28, v29, v30, v31, v32, v33, v34, v35);
      v40 = 0;
      v50[0] = v43;
      v50[1] = v42;
      v50[2] = v44;
      v50[3] = v45;
      do
      {
        v51[v40] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v36, COERCE_FLOAT(v50[v40])), v37, *(float32x2_t *)&v50[v40], 1), v38, (float32x4_t)v50[v40], 2), v39, (float32x4_t)v50[v40], 3);
        ++v40;
      }
      while (v40 != 4);
      v46 = (float32x4_t)v51[0];
      v47 = (float32x4_t)v51[1];
      v48 = (float32x4_t)v51[2];
      v49 = (float32x4_t)v51[3];
    }
  }
  return sub_1B186BC48(a1[4].i64[1], (uint64_t)&v46);
}

uint64_t sub_1B1902894(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  int v6;
  int v7;

  v2 = result;
  v3 = *(_DWORD *)(result + 232) & 0xFFFFFFFC;
  if (a2 == 2)
  {
    v4 = v3 | 2;
    result = sub_1B21D0364(result, 4);
  }
  else if (a2)
  {
    v4 = *(_DWORD *)(result + 232) & 0xFFFFFFFC;
  }
  else
  {
    v4 = v3 | 1;
  }
  v5 = *(_QWORD *)(v2 + 208);
  if (v5)
  {
    v6 = *(_DWORD *)(v5 + 8);
    if (v6 == 21)
      v7 = v4 | 8;
    else
      v7 = v4;
    if (v6 == 22)
      v4 |= 8u;
    else
      v4 = v7;
  }
  *(_DWORD *)(v2 + 232) = v4;
  return result;
}

uint64_t sub_1B1902904(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v4;

  if (*(float *)(result + 288) > 0.0)
  {
    v1 = result;
    result = *(_QWORD *)(result + 208);
    v4 = 0;
    if (result)
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t *, int *))(*(_QWORD *)result + 24))(result, &v3, &v4);
      v2 = v4;
    }
    else
    {
      v2 = 0;
    }
    *(_DWORD *)(v1 + 284) = v2;
  }
  return result;
}

uint64_t sub_1B1902964(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  __int128 *v5;
  int8x16_t v6;
  int8x16_t v8;
  __n128 v9[4];

  v2 = a1;
  if (a1)
  {
    if (*(float *)a2 != 0.0 || *(float *)(a2 + 4) != 0.0 || *(float *)(a2 + 8) != 0.0)
    {
      v5 = sub_1B1902AA4();
      v6.i64[0] = 0x8000000080000000;
      v6.i64[1] = 0x8000000080000000;
      v8 = veorq_s8(*(int8x16_t *)a2, v6);
      sub_1B19064B8((uint64_t)v9, (float32x4_t *)v5);
      v9[3] = (__n128)v8;
      if (*(_DWORD *)(v2 + 8) == 31 && *(_QWORD *)(v2 + 16) == 2880154539)
      {
        sub_1B21DFA10(v2, 0, v9, 1);
        return v2;
      }
      v4 = sub_1B21FF5F0(128, 16);
      sub_1B21DF788(v4, 1);
      *(_QWORD *)(v4 + 16) = 2880154539;
      sub_1B21DF7EC(v4, v9, (_DWORD *)v2, 0);
      return v4;
    }
    if (*(_DWORD *)(a1 + 8) == 31 && *(_QWORD *)(a1 + 16) == 2880154539)
    {
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 64);
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
      return v4;
    }
  }
  return v2;
}

void sub_1B1902A90(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B21FF5FC(v1);
  _Unwind_Resume(a1);
}

__int128 *sub_1B1902AA4()
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1EEF55A90);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1EEF55A90))
  {
    xmmword_1EEF55A80 = xmmword_1B2244E20;
    __cxa_guard_release(&qword_1EEF55A90);
  }
  return &xmmword_1EEF55A80;
}

void sub_1B1902AFC(float32x4_t *a1, uint64_t a2, __int128 *a3, __int128 *a4, float a5)
{
  _DWORD *v8;
  __n128 v9;
  __int128 v10;

  v10 = *a4;
  v8 = (_DWORD *)sub_1B1902964(a2, (uint64_t)&v10);
  (*(void (**)(float32x4_t *, _DWORD *))(a1->i64[0] + 24))(a1, v8);
  sub_1B1902904((uint64_t)a1);
  v9.n128_f32[0] = a5;
  sub_1B1902BA4(a1, v8, a3, v9);
  if (v8)
  {
    if ((v8[2] - 21) <= 1)
      a1[14].i32[2] |= 8u;
  }
}

void sub_1B1902BA4(float32x4_t *a1, _DWORD *a2, __int128 *a3, __n128 a4)
{
  float v4;
  __int128 v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  __int128 v11;

  v4 = a4.n128_f32[0];
  v11 = 0uLL;
  if (a3)
  {
    v6 = *a3;
    HIDWORD(v6) = 0;
    v11 = v6;
  }
  else if (a2 && (a1[14].i8[8] & 1) == 0)
  {
    v7 = a2[2];
    v8 = v7 > 0x1C;
    v9 = (1 << v7) & 0x10608000;
    if (v8 || v9 == 0)
      (*(void (**)(_DWORD *, __int128 *, __n128))(*(_QWORD *)a2 + 64))(a2, &v11, a4);
  }
  sub_1B21FEA84((uint64_t)a1, (float32x2_t *)&v11, v4);
  sub_1B21FEB10(a1);
}

uint64_t sub_1B1902D20(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  int v4;

  result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (result)
  {
    sub_1B21D037C(result, 1);
    sub_1B1902894(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 240), *(_QWORD *)(a1 + 40));
    v3 = *(_QWORD *)(a1 + 32);
    if (*(_BYTE *)(v3 + 232))
      v4 = 1;
    else
      v4 = 4;
    sub_1B21D0364(*(_QWORD *)(v3 + 240), v4);
    return sub_1B21D0384(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 240), 0);
  }
  return result;
}

void sub_1B1902E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B1902E98(uint64_t a1, __n128 a2)
{
  uint64_t v3;
  uint64_t v4;
  __int128 *v5;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(v3 + 240);
  if (v4)
  {
    if (*(_BYTE *)(v3 + 172))
      v5 = (__int128 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 32);
    else
      v5 = 0;
    a2.n128_u32[0] = *(_DWORD *)(a1 + 48);
    sub_1B1902BA4((float32x4_t *)v4, *(_DWORD **)(v4 + 208), v5, a2);
  }
}

void sub_1B1902FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B1902FC8(uint64_t a1, __n128 a2)
{
  uint64_t v3;
  uint64_t v4;
  __int128 *v5;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(v3 + 240);
  if (v4)
  {
    if (*(_BYTE *)(v3 + 172))
      v5 = (__int128 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 32);
    else
      v5 = 0;
    a2.n128_u32[0] = *(_DWORD *)(v3 + 16);
    sub_1B1902BA4((float32x4_t *)v4, *(_DWORD **)(v4 + 208), v5, a2);
  }
}

void sub_1B19030C0(uint64_t a1)
{
  uint64_t v1;
  _OWORD *v3;
  uint64_t v4;
  float32x4_t *v5;
  uint64_t v6;
  float v7;
  __int128 *v8;
  unsigned int v9;
  __int128 v10;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 240);
  if (v1)
  {
    v3 = *(_OWORD **)(v1 + 536);
    if (v3)
    {
      v3[3] = *(_OWORD *)(a1 + 32);
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 240);
      *(_QWORD *)(v4 + 536) = v3;
      (*(void (**)(_OWORD *, uint64_t))(*(_QWORD *)v3 + 16))(v3, v4 + 16);
      v5 = *(float32x4_t **)(*(_QWORD *)(a1 + 64) + 240);
      v6 = v5[13].i64[0];
      v7 = *(float *)(a1 + 72);
      if (*(_BYTE *)(a1 + 76))
        v8 = (__int128 *)(a1 + 48);
      else
        v8 = 0;
      v9 = *(_DWORD *)(a1 + 40);
      *(_QWORD *)&v10 = *(_QWORD *)(a1 + 32);
      *((_QWORD *)&v10 + 1) = v9;
      sub_1B1902AFC(v5, v6, v8, &v10, v7);
    }
  }
}

void sub_1B190323C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B1903254(uint64_t a1, __n128 a2)
{
  uint64_t v3;
  uint64_t v4;
  __int128 *v5;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(v3 + 240);
  if (v4)
  {
    if (*(_BYTE *)(v3 + 172))
      v5 = (__int128 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 32);
    else
      v5 = 0;
    a2.n128_u32[0] = *(_DWORD *)(v3 + 16);
    sub_1B1902BA4((float32x4_t *)v4, *(_DWORD **)(v4 + 208), v5, a2);
  }
}

float sub_1B190332C(uint64_t a1)
{
  uint64_t v1;
  float result;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v1)
  {
    result = *(float *)(a1 + 40);
    *(float *)(v1 + 532) = result;
  }
  return result;
}

uint64_t sub_1B1903388(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = (void *)objc_msgSend_nodeWithNodeRef_(VFXNode, a2, a1, a4);
  v8 = objc_msgSend_physicsBody(v4, v5, v6, v7);
  return MEMORY[0x1E0DE7D20](v8, sel_isResting, v9, v10);
}

BOOL sub_1B19033AC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;

  v4 = (void *)objc_msgSend_nodeWithNodeRef_(VFXNode, a2, a1, a4);
  v8 = (void *)objc_msgSend_physicsBody(v4, v5, v6, v7);
  return objc_msgSend_type(v8, v9, v10, v11) == 1;
}

uint64_t sub_1B1903470(uint64_t a1)
{
  uint64_t result;
  int v3;

  result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (result)
  {
    sub_1B21D0384(result, 0);
    if (*(_BYTE *)(a1 + 40))
      v3 = 1;
    else
      v3 = 4;
    return sub_1B21D0364(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 240), v3);
  }
  return result;
}

float sub_1B1903550(uint64_t a1)
{
  uint64_t v1;
  float result;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v1)
  {
    result = *(float *)(a1 + 40);
    *(float *)(v1 + 252) = result;
  }
  return result;
}

float sub_1B19035FC(uint64_t a1)
{
  uint64_t v1;
  float result;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v1)
  {
    result = *(float *)(a1 + 40);
    *(float *)(v1 + 256) = result;
  }
  return result;
}

float sub_1B19036A8(uint64_t a1)
{
  uint64_t v1;
  float result;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v1)
  {
    result = *(float *)(a1 + 40);
    *(float *)(v1 + 260) = result;
  }
  return result;
}

float32x2_t sub_1B1903754(uint64_t a1, float32x2_t result)
{
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 240))
  {
    result.i32[0] = *(_DWORD *)(a1 + 40);
    return (float32x2_t)sub_1B21FEA64(*(int8x8_t **)(*(_QWORD *)(a1 + 32) + 240), result, result.f32[0]);
  }
  return result;
}

float32x2_t sub_1B1903808(uint64_t a1, float32x2_t result)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v2 + 240))
  {
    result.i32[0] = *(_DWORD *)(v2 + 64);
    return (float32x2_t)sub_1B21FEA64(*(int8x8_t **)(v2 + 240), result, *(float32_t *)(a1 + 40));
  }
  return result;
}

double sub_1B19038C0(uint64_t a1)
{
  uint64_t v1;
  double result;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v1)
  {
    result = *(double *)(a1 + 40);
    *(double *)(v1 + 524) = result;
  }
  return result;
}

double sub_1B1903974(uint64_t a1)
{
  uint64_t v1;
  double result;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v1)
  {
    result = *(double *)(a1 + 40);
    *(double *)(v1 + 524) = result;
  }
  return result;
}

void sub_1B1903BC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B1903BDC(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  void *v15;
  float32x4_t *v16;
  uint64_t v17;
  float v18;
  __int128 *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;

  if (*(_QWORD *)(*(_QWORD *)(result + 64) + 240))
  {
    v8 = result;
    v9 = *(void **)(result + 72);
    if (v9)
    {
      v10 = objc_msgSend__shapeHandle_(v9, a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 80) + 8) + 24), a4);
      objc_msgSend__setBtShape_(*(void **)(v8 + 64), v11, v10, v12);
    }
    v13 = *(const void **)(*(_QWORD *)(*(_QWORD *)(v8 + 80) + 8) + 24);
    if (v13)
    {
      CFRelease(v13);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 80) + 8) + 24) = 0;
    }
    v14 = *(_QWORD *)(v8 + 64);
    v15 = *(void **)(v14 + 248);
    if (v15)
    {
      v16 = *(float32x4_t **)(v14 + 240);
      v17 = objc_msgSend_btShape(v15, a2, a3, a4);
      v18 = *(float *)(v8 + 88);
      if (*(_BYTE *)(v8 + 92))
        v19 = (__int128 *)(v8 + 32);
      else
        v19 = 0;
      v31 = *(_OWORD *)(v8 + 48);
      sub_1B1902AFC(v16, v17, v19, &v31, v18);
    }
    else
    {
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: unable to update the physics shape of %@"), a3, a4, a5, a6, a7, a8, *(_QWORD *)(v8 + 64));
    }
    v23 = *(void **)(v8 + 72);
    objc_msgSend_worldTransform(*(void **)(*(_QWORD *)(v8 + 64) + 8), v20, v21, v22);
    v25 = vmulq_f32(v24, v24);
    v25.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0]);
    v27 = vmulq_f32(v26, v26);
    v25.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]);
    return objc_msgSend__setNodeScale_(v23, v28, v29, v30, *(double *)v25.i64);
  }
  return result;
}

__n128 sub_1B1903D18(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

void sub_1B1903DE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 184))(a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 176))(a1, a2, a4, a3, a5);
    sub_1B21D0384(a2, 0);
  }
  else
  {
    sub_1B17C4408(0, (uint64_t)CFSTR("Warning: cannot change collision bit masks without physics world"), a3, a4, a5, a6, a7, a8, a9);
  }
}

void sub_1B1903F18(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v9)
  {
    v10 = *(_QWORD *)(v9 + 200);
    if (v10)
    {
      if (*(_QWORD *)(v10 + 8) != *(_QWORD *)(a1 + 48))
      {
        v12 = objc_msgSend__handle(*(void **)(a1 + 40), a2, a3, a4);
        sub_1B1903DE4(v12, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 64), v13, v14, v15, a9);
      }
    }
  }
}

void sub_1B190403C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v9)
  {
    v10 = *(_QWORD *)(v9 + 200);
    if (v10)
    {
      if (*(_QWORD *)(v10 + 16) != *(_QWORD *)(a1 + 48))
      {
        v12 = objc_msgSend__handle(*(void **)(a1 + 40), a2, a3, a4);
        sub_1B1903DE4(v12, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), v13, v14, v15, a9);
      }
    }
  }
}

void sub_1B190415C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v9)
  {
    v10 = *(_QWORD *)(v9 + 200);
    if (v10)
    {
      if (*(_QWORD *)(v10 + 24) != *(_QWORD *)(a1 + 48))
      {
        v12 = objc_msgSend__handle(*(void **)(a1 + 40), a2, a3, a4);
        sub_1B1903DE4(v12, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 48), v13, v14, v15, a9);
      }
    }
  }
}

uint64_t sub_1B190424C(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(result + 32) + 240);
  if (v1)
  {
    *(_DWORD *)(v1 + 288) = *(_DWORD *)(result + 40);
    return sub_1B1902904(*(_QWORD *)(*(_QWORD *)(result + 32) + 240));
  }
  return result;
}

__n128 sub_1B1904300(__n128 *a1)
{
  uint64_t v2;
  __n128 result;

  v2 = *(_QWORD *)(a1[3].n128_u64[0] + 240);
  if (v2)
  {
    sub_1B21D0384(v2, 0);
    result = a1[2];
    result.n128_u32[3] = 0;
    *(__n128 *)(*(_QWORD *)(a1[3].n128_u64[0] + 240) + 352) = result;
  }
  return result;
}

double sub_1B190443C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  int v6;
  float32x4_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  float v12;
  float32x4_t v13;
  double result;
  float32x4_t v15;
  float32x4_t v16;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v4)
  {
    v6 = *(unsigned __int8 *)(a1 + 48);
    *(_DWORD *)(v4 + 576) = *(_BYTE *)(a1 + 48) == 0;
    if (v6)
    {
      objc_msgSend_gravity(*(void **)(a1 + 40), a2, a3, a4);
      v15 = v7;
      objc_msgSend_scale(*(void **)(a1 + 40), v8, v9, v10);
      v11 = *(float32x4_t **)(*(_QWORD *)(a1 + 32) + 240);
      v13 = vmulq_n_f32(v15, 1.0 / v12);
      v13.i32[3] = 0;
      v16 = v13;
    }
    else
    {
      v11 = *(float32x4_t **)(*(_QWORD *)(a1 + 32) + 240);
      v16 = 0uLL;
    }
    *(_QWORD *)&result = sub_1B21FEC54(v11, &v16).n128_u64[0];
  }
  return result;
}

float32x4_t sub_1B1904564(float32x4_t *a1)
{
  __n128 *v1;
  float32x4_t result;

  v1 = *(__n128 **)(a1[3].i64[0] + 240);
  if (v1)
  {
    result = vmulq_laneq_f32(a1[2], a1[2], 3);
    result.i32[3] = 0;
    v1[23] = (__n128)result;
  }
  return result;
}

float32x4_t sub_1B190467C(__n128 *a1)
{
  float32x4_t *v1;
  float32x4_t v2;
  float32x4_t result;

  v1 = *(float32x4_t **)(a1[3].n128_u64[0] + 240);
  if (v1)
  {
    result = (float32x4_t)a1[2];
    v2 = vmulq_n_f32(result, v1[24].f32[0]);
    result.i32[3] = 0;
    v1[25] = result;
    v2.i32[3] = 0;
    v1[40] = v2;
  }
  return result;
}

__n128 sub_1B1904738(__n128 *a1)
{
  __n128 *v1;
  __n128 result;

  v1 = *(__n128 **)(a1[3].n128_u64[0] + 240);
  if (v1)
  {
    result = a1[2];
    result.n128_u32[3] = 0;
    v1[39] = result;
  }
  return result;
}

float32x4_t sub_1B19047F0(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t result;

  v10 = *(_QWORD *)(a1[3].i64[0] + 240);
  if (v10)
  {
    sub_1B21D0384(v10, 0);
    v11 = *(float32x4_t **)(a1[3].i64[0] + 240);
    v12 = a1[2];
    v12.i32[3] = 0;
    v13 = vmulq_f32(v11[25], v12);
    if (a1[3].i8[8])
    {
      v14 = vmulq_n_f32(v13, v11[24].f32[0]);
      v14.i32[3] = 0;
      result = vaddq_f32(v11[22], v14);
      v11[22] = result;
    }
    else
    {
      result = vaddq_f32(v11[29], v13);
      v11[29] = result;
    }
  }
  else
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: cannot apply force on a body that is not attached to a VFXNode"), a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

float32x4_t sub_1B1904918(int8x8_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;
  float32x4_t *v11;
  unsigned __int32 v12;
  __int32 v13;
  float32x4_t result;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x8_t v22;
  __int32 v23;
  int v24;
  float32x4_t v25;

  v10 = *(_QWORD *)(*(_QWORD *)&a1[8] + 240);
  if (v10)
  {
    sub_1B21D0384(v10, 0);
    v11 = *(float32x4_t **)(*(_QWORD *)&a1[8] + 240);
    if (a1[9].i8[0])
    {
      v12 = a1[5].u32[0];
      *(int8x8_t *)v25.f32 = a1[4];
      v25.i64[1] = v12;
      v13 = a1[7].i32[0];
      v22 = a1[6];
      v23 = v13;
      v24 = 0;
      result.i64[0] = sub_1B1904A0C(v11, &v25, &v22).u64[0];
    }
    else
    {
      v15 = *(float32x4_t *)a1[4].i8;
      v16 = *(float32x4_t *)a1[6].i8;
      v15.i32[3] = 0;
      *(int8x8_t *)v17.f32 = vext_s8(*(int8x8_t *)v16.f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v16, (int8x16_t)v16, 8uLL), 4uLL);
      *(int8x8_t *)&v17.u32[2] = a1[6];
      v16.i32[3] = 0;
      v18 = vmulq_f32(v15, v11[25]);
      v19.i64[0] = vextq_s8((int8x16_t)v18, (int8x16_t)v18, 4uLL).u64[0];
      v19.i64[1] = v18.i64[0];
      v20 = (int8x16_t)vsubq_f32(vmulq_f32(v16, v19), vmulq_f32(v18, v17));
      v17.i64[0] = vextq_s8(v20, v20, 4uLL).u64[0];
      v17.i64[1] = v20.u32[0];
      result = vaddq_f32(v11[29], v18);
      v21 = vaddq_f32(v11[30], vmulq_f32(v11[39], v17));
      v11[29] = result;
      v11[30] = v21;
    }
  }
  else
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: cannot apply force on a body that is not attached to a VFXNode"), a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

float32x4_t sub_1B1904A0C(float32x4_t *a1, float32x4_t *a2, int8x8_t *a3)
{
  float32x4_t result;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int8x16_t v10;
  float32x4_t v11;
  int8x16_t v12;
  int8x16_t v13;
  float32x4_t v14;

  result.i32[0] = a1[24].i32[0];
  if (result.f32[0] != 0.0)
  {
    v4 = a1[25];
    v5 = vmulq_n_f32(vmulq_f32(*a2, v4), result.f32[0]);
    v5.i32[3] = 0;
    v6 = a1[21];
    a1[22] = vaddq_f32(a1[22], v5);
    v7 = vmulq_f32(v4, *a2);
    *(int8x8_t *)v8.f32 = vext_s8(*a3, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a3->i8, *(int8x16_t *)a3->i8, 8uLL), 4uLL);
    *(int8x8_t *)&v8.u32[2] = *a3;
    v9.i64[0] = vextq_s8((int8x16_t)v7, (int8x16_t)v7, 4uLL).u64[0];
    v9.i64[1] = v7.i64[0];
    v10 = (int8x16_t)vsubq_f32(vmulq_f32(*(float32x4_t *)a3->i8, v9), vmulq_f32(v7, v8));
    v4.i64[0] = vextq_s8(v10, v10, 4uLL).u64[0];
    v4.i64[1] = v10.i64[0];
    v11 = v4;
    v11.i32[3] = 0;
    v12 = (int8x16_t)vmulq_f32(v6, v4);
    v13 = (int8x16_t)vmulq_f32(a1[19], v11);
    v14 = vmulq_f32(a1[20], v11);
    v12.i32[3] = 0;
    *(float32x2_t *)v14.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v14.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL)));
    *(float32x2_t *)&v14.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL)), 0);
    result = vaddq_f32(a1[23], vmulq_f32(a1[39], v14));
    a1[23] = result;
  }
  return result;
}

float32x4_t sub_1B1904B60(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;
  float32x4_t v11;
  float32x4_t *v12;
  float32x4_t v13;
  int8x16_t v14;
  int8x16_t v15;
  float32x4_t result;

  v10 = *(_QWORD *)(a1[3].i64[0] + 240);
  if (v10)
  {
    sub_1B21D0384(v10, 0);
    v11 = vmulq_laneq_f32(a1[2], a1[2], 3);
    v11.i32[3] = 0;
    v12 = *(float32x4_t **)(a1[3].i64[0] + 240);
    if (a1[3].i8[8])
    {
      v13 = vmulq_f32(v12[19], v11);
      v14 = (int8x16_t)vmulq_f32(v12[20], v11);
      v15 = (int8x16_t)vmulq_f32(v12[21], v11);
      v15.i32[3] = 0;
      *(float32x2_t *)v13.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v13.f32, *(float32x2_t *)v14.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL)));
      *(float32x2_t *)&v13.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v15.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL)), 0);
      result = vaddq_f32(v12[23], vmulq_f32(v13, v12[39]));
      v12[23] = result;
    }
    else
    {
      result = vaddq_f32(v12[30], vmulq_f32(v12[39], v11));
      v12[30] = result;
    }
  }
  else
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: cannot apply force on a body that is not attached to a VFXNode"), a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

void sub_1B1904CBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (v9)
  {
    *(_OWORD *)(v9 + 464) = 0u;
    *(_OWORD *)(v9 + 480) = 0u;
    *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 240) + 352) = 0u;
    *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 240) + 368) = 0u;
  }
  else
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: cannot clear forces on a body that is not attached to a VFXNode"), a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1B1904D84(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 240);
  if (result)
  {
    if (*(_BYTE *)(a1 + 40))
      return sub_1B21D0364(result, 3);
    else
      return sub_1B21D0384(result, 0);
  }
  return result;
}

uint64_t sub_1B1904E48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 96), sel_moveToTransform_, a3, a4);
}

uint64_t sub_1B1904F00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 96), sel_moveToTransform_, a3, a4);
}

void sub_1B1905740(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B21FF5FC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B19057FC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B186DAA0(v5, 0, v6, v7, v8, v9, v10, v11);
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 40), sel_removePhysicsBody_handle_, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
}

uint64_t sub_1B19059B0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float32x4_t *v26;
  float v27;
  __int128 *v28;
  void *v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v41;

  v5 = (void *)objc_msgSend_world(*(void **)(a1 + 64), a2, a3, a4);
  v9 = (void *)objc_msgSend_physicsWorld(v5, v6, v7, v8);
  sub_1B186DAA0(*(_QWORD *)(a1 + 80), *(const __CFDictionary **)(a1 + 72), v10, v11, v12, v13, v14, v15);
  v18 = *(_QWORD *)(a1 + 88);
  if (v18 && !*(_QWORD *)(v18 + 208))
  {
    v19 = (void *)objc_msgSend__shapeHandle_(*(void **)(*(_QWORD *)(a1 + 72) + 48), v16, *(_QWORD *)(a1 + 80), v17);
    objc_msgSend__setBtShape_(*(void **)(a1 + 72), v20, (uint64_t)v19, v21);
    v25 = objc_msgSend_btShape(v19, v22, v23, v24);
    v26 = *(float32x4_t **)(a1 + 88);
    v27 = *(float *)(a1 + 120);
    if (*(_BYTE *)(a1 + 124))
      v28 = (__int128 *)(a1 + 32);
    else
      v28 = 0;
    v41 = *(_OWORD *)(a1 + 48);
    sub_1B1902AFC(v26, v25, v28, &v41, v27);
    v29 = *(void **)(*(_QWORD *)(a1 + 72) + 48);
    objc_msgSend_worldTransform(*(void **)(a1 + 64), v30, v31, v32);
    v34 = vmulq_f32(v33, v33);
    v36 = vmulq_f32(v35, v35);
    v34.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0]);
    v34.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0]);
    objc_msgSend__setNodeScale_(v29, v37, v38, v39, *(double *)v34.i64);
  }
  return objc_msgSend_addPhysicsBody_nodeRef_colGroup_colMask_colTest_(v9, v16, *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112));
}

float sub_1B19064B8(uint64_t a1, float32x4_t *a2)
{
  float32x4_t v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float result;

  v2 = vmulq_f32(*a2, *a2);
  v2.i64[0] = vpaddq_f32(v2, v2).u64[0];
  v2.f32[0] = 2.0 / vpadd_f32(*(float32x2_t *)v2.f32, *(float32x2_t *)v2.f32).f32[0];
  v3 = v2.f32[0] * COERCE_FLOAT(*a2);
  v4 = vmuls_lane_f32(v2.f32[0], *(float32x2_t *)a2->f32, 1);
  v2.f32[0] = vmuls_lane_f32(v2.f32[0], *a2, 2);
  v5 = vmuls_lane_f32(v3, *a2, 3);
  v6 = vmuls_lane_f32(v4, *a2, 3);
  v7 = vmuls_lane_f32(v2.f32[0], *a2, 3);
  v8 = v3 * COERCE_FLOAT(*a2);
  v9 = v4 * COERCE_FLOAT(*a2);
  v10 = v2.f32[0] * COERCE_FLOAT(*a2);
  v11 = vmuls_lane_f32(v4, *(float32x2_t *)a2->f32, 1);
  v12 = vmuls_lane_f32(v2.f32[0], *(float32x2_t *)a2->f32, 1);
  v13 = vmuls_lane_f32(v2.f32[0], *a2, 2);
  *(float *)a1 = 1.0 - (float)(v11 + v13);
  *(float *)(a1 + 4) = v9 - v7;
  *(float *)(a1 + 8) = v10 + v6;
  *(_DWORD *)(a1 + 12) = 0;
  *(float *)(a1 + 16) = v9 + v7;
  *(float *)(a1 + 20) = 1.0 - (float)(v8 + v13);
  *(float *)(a1 + 24) = v12 - v5;
  *(_DWORD *)(a1 + 28) = 0;
  *(float *)(a1 + 32) = v10 - v6;
  *(float *)(a1 + 36) = v12 + v5;
  result = 1.0 - (float)(v8 + v11);
  *(float *)(a1 + 40) = result;
  *(_DWORD *)(a1 + 44) = 0;
  return result;
}

uint64_t sub_1B190655C(int a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, float a7, float a8, float a9)
{
  double v14;
  double v15;
  double v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  char v45;
  CFIndex v46;
  UInt8 *v47;
  UInt8 *v48;
  __int16 v49;
  uint64_t v50;
  UInt8 *v51;
  uint64_t v52;
  __int16 v53;
  __int16 v54;
  __int16 v55;
  uint64_t v56;
  __int16 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char v66;
  UInt8 *v67;
  char v68;
  uint64_t i;
  uint64_t v70;
  char v71;
  UInt8 *v72;
  int v73;
  uint64_t v74;
  UInt8 *v75;
  uint64_t v76;
  __int16 v77;
  uint64_t v78;
  __int16 v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t j;
  UInt8 *v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  int v89;
  int v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  UInt8 *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  int v101;
  uint64_t *v102;
  _DWORD *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  const __CFAllocator *v111;
  CFDataRef v112;
  const CFArrayCallBacks *v113;
  const __CFArray *v114;
  const __CFArray *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v123;
  char v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  _QWORD v135[2];
  uint64_t (*v136)(uint64_t, int, int, uint64_t, int);
  void *v137;
  uint64_t *v138;
  uint64_t v139;
  _QWORD v140[2];
  uint64_t (*v141)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v142;
  uint64_t *v143;
  uint64_t v144;
  _QWORD v145[2];
  uint64_t (*v146)(uint64_t, int, int, uint64_t, int);
  void *v147;
  uint64_t *v148;
  uint64_t v149;
  _QWORD v150[2];
  uint64_t (*v151)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v152;
  uint64_t *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t *v156;
  uint64_t v157;
  UInt8 *v158;
  void *v159;
  void *values;
  CFTypeRef v161;
  CFTypeRef v162;
  uint64_t v163;

  v163 = *MEMORY[0x1E0C80C00];
  v14 = a7;
  v15 = fabsf(a5) * 0.5;
  v16 = fabsf(a6);
  if (v15 >= v16 * 0.5)
  {
    if (v16 * 0.5 <= v14)
      v14 = v16 * 0.5;
  }
  else if (v15 <= v14)
  {
    v14 = v15;
  }
  v17 = v14;
  if (a4 <= 1)
    v18 = 1;
  else
    v18 = a4;
  if (a2 <= 1)
    v19 = 1;
  else
    v19 = a2;
  if (a3 <= 1)
    v20 = 1;
  else
    v20 = a3;
  v21 = (void *)sub_1B1906FBC(0, v19, v20, v18, a5, a6, v17, a8, a9);
  values = v21;
  v161 = (CFTypeRef)sub_1B1906FBC(1, v19, v20, v18, a5, a6, v17, a8, a9);
  v162 = (CFTypeRef)sub_1B1906FBC(3, v19, v20, v18, a5, a6, v17, a8, a9);
  v22 = (void *)sub_1B17A39B4();
  v159 = v22;
  sub_1B17A3B60((uint64_t)v22, a1, v23, v24, v25, v26, v27, v28);
  if (a1 == 3)
  {
    v65 = sub_1B17EDAE0((uint64_t)v21, v29, v30, v31, v32, v33, v34, v35);
    v42 = v65;
    v66 = 1;
    if (v65 >= 0x10000)
      v66 = 2;
    v46 = v65 << v66;
    v67 = (UInt8 *)malloc_type_malloc(v65 << v66, 0x95274BC2uLL);
    v48 = v67;
    if (v42 >= 0x10000)
      v68 = 4;
    else
      v68 = 2;
    if (v42 < 0x10000)
    {
      if (v42 < 1)
      {
        v68 = 2;
      }
      else
      {
        for (i = 0; i != v42; ++i)
          *(_WORD *)&v67[2 * i] = i;
      }
    }
    else
    {
      for (j = 0; j != v42; ++j)
        *(_DWORD *)&v67[4 * j] = j;
    }
  }
  else
  {
    v36 = v19 + 1;
    v37 = (v20 + 1) * (v19 + 1);
    v38 = v18 + v19 + v37;
    v39 = v18 + v20 + v38;
    v40 = v20 * (v19 + 1);
    if (a1 == 2)
    {
      v126 = v18 + v19 + v37;
      v128 = v40 + v19;
      v130 = v18 + v20 + v38;
      v132 = v18 + v19 + v39;
      v134 = v20 * (v19 + 1);
      if (v17 > 0.0)
        v42 = 8 * v18 + 4 * (v20 + 1 + v36) + v20 + v19 + 2 * v20 * v19 - 8;
      else
        v42 = v20 + v19 + 2 * v20 * v19;
      v70 = 2 * v42;
      v71 = 1;
      if (v42 >= 0x8000)
        v71 = 2;
      v46 = v70 << v71;
      v72 = (UInt8 *)malloc_type_malloc(v70 << v71, 0x62DAF02uLL);
      v48 = v72;
      if (v42 >= 0x8000)
        v68 = 4;
      else
        v68 = 2;
      v73 = 0;
      v74 = 0;
      if (v42 < 0x8000)
      {
        v155 = 0;
        v156 = &v155;
        v157 = 0x2000000000;
        v158 = v72;
        v75 = v72;
        do
        {
          v76 = 0;
          ++v74;
          do
          {
            *(_WORD *)v75 = v73 + v76;
            v77 = v19 + v73 + v76;
            v78 = v76 + 1;
            v79 = v73 + v76 + 1;
            *(_WORD *)(v156[3] + 2) = v79;
            *(_WORD *)(v156[3] + 4) = v79;
            *(_WORD *)(v156[3] + 6) = v77 + 2;
            v75 = (UInt8 *)(v156[3] + 8);
            v156[3] = (uint64_t)v75;
            v76 = v78;
          }
          while (v19 != v78);
          LOWORD(v73) = v73 + v36;
        }
        while (v74 != v20);
        v80 = 0;
        v81 = v20;
        do
        {
          *(_WORD *)v75 = v80;
          v80 += v36;
          *(_WORD *)(v156[3] + 2) = v80;
          v75 = (UInt8 *)(v156[3] + 4);
          v156[3] = (uint64_t)v75;
          --v81;
        }
        while (v81);
        v82 = v20 * (v19 + 1);
        v83 = v19;
        do
        {
          *(_WORD *)v75 = v82;
          *(_WORD *)(v156[3] + 2) = v82 + 1;
          v75 = (UInt8 *)(v156[3] + 4);
          v156[3] = (uint64_t)v75;
          ++v82;
          --v83;
        }
        while (v83);
        if (v17 > 0.0)
        {
          v140[0] = MEMORY[0x1E0C809B0];
          v140[1] = 0x40000000;
          v141 = sub_1B19075E8;
          v142 = &unk_1E63D92D0;
          v143 = &v155;
          v144 = v18;
          sub_1B19075E8((uint64_t)v140, 0, (v20 + 1) * (v19 + 1), v19, 1);
          sub_1B19075E8((uint64_t)v140, v19, v126, v20, v19 + 1);
          v141((uint64_t)v140, v128, v130, v19, -1);
          v141((uint64_t)v140, v134, v132, v20, ~v19);
          *(_WORD *)(v156[3] - 2) = v37;
        }
      }
      else
      {
        v155 = 0;
        v156 = &v155;
        v157 = 0x2000000000;
        v158 = v72;
        v85 = v72;
        do
        {
          v86 = 0;
          ++v74;
          do
          {
            *(_DWORD *)v85 = v73 + v86;
            v87 = v19 + v73 + v86;
            v88 = v86 + 1;
            v89 = v73 + v86 + 1;
            *(_DWORD *)(v156[3] + 4) = v89;
            *(_DWORD *)(v156[3] + 8) = v89;
            *(_DWORD *)(v156[3] + 12) = v87 + 2;
            v85 = (UInt8 *)(v156[3] + 16);
            v156[3] = (uint64_t)v85;
            v86 = v88;
          }
          while (v19 != v88);
          v73 += v19 + 1;
        }
        while (v74 != v20);
        v90 = 0;
        v91 = v20;
        do
        {
          *(_DWORD *)v85 = v90;
          v90 += v19 + 1;
          *(_DWORD *)(v156[3] + 4) = v90;
          v85 = (UInt8 *)(v156[3] + 8);
          v156[3] = (uint64_t)v85;
          --v91;
        }
        while (v91);
        v92 = v20 + v20 * v19;
        v93 = v19;
        do
        {
          *(_DWORD *)v85 = v92++;
          *(_DWORD *)(v156[3] + 4) = v92;
          v85 = (UInt8 *)(v156[3] + 8);
          v156[3] = (uint64_t)v85;
          --v93;
        }
        while (v93);
        if (v17 > 0.0)
        {
          v135[0] = MEMORY[0x1E0C809B0];
          v135[1] = 0x40000000;
          v136 = sub_1B19076DC;
          v137 = &unk_1E63D92F8;
          v138 = &v155;
          v139 = v18;
          sub_1B19076DC((uint64_t)v135, 0, (v20 + 1) * (v19 + 1), v19, 1);
          sub_1B19076DC((uint64_t)v135, v19, v126, v20, v19 + 1);
          v136((uint64_t)v135, v128, v130, v19, -1);
          v136((uint64_t)v135, v134, v132, v20, ~v19);
          *(_DWORD *)(v156[3] - 4) = v37;
        }
      }
      _Block_object_dispose(&v155, 8);
    }
    else if (a1)
    {
      v48 = 0;
      LODWORD(v42) = 0;
      v46 = 0;
      v68 = 0;
    }
    else
    {
      v125 = v18 + v19 + v37;
      v127 = v40 + v19;
      v129 = v18 + v20 + v38;
      v131 = v18 + v19 + v39;
      v133 = v20 * (v19 + 1);
      v41 = 4 * (v18 + v19 + v20);
      if (v17 <= 0.0)
        v41 = 0;
      v123 = v20 * v19;
      v42 = v41 + 2 * v20 * v19;
      v43 = 3 * v42;
      if (v42 >= 21846)
        v44 = 4;
      else
        v44 = 2;
      v124 = v44;
      v45 = 1;
      if (v42 >= 21846)
        v45 = 2;
      v46 = v43 << v45;
      v47 = (UInt8 *)malloc_type_malloc(v43 << v45, 0xDD91F8A0uLL);
      v48 = v47;
      if (v42 > 21845)
      {
        v94 = 0;
        v95 = 0;
        v155 = 0;
        v156 = &v155;
        v157 = 0x2000000000;
        v158 = v47;
        v96 = v47;
        do
        {
          v97 = 0;
          ++v95;
          v98 = v94;
          do
          {
            *(_DWORD *)v96 = v98;
            ++v97;
            v99 = v98 + 1;
            *(_DWORD *)(v156[3] + 4) = v98 + 1;
            v100 = v19 + v98;
            v101 = v19 + v98 + 2;
            *(_DWORD *)(v156[3] + 8) = v101;
            *(_DWORD *)(v156[3] + 12) = v98;
            v102 = v156;
            v103 = (_DWORD *)v156[3];
            v103[4] = v101;
            v103[5] = v100 + 1;
            v96 = (UInt8 *)(v103 + 6);
            v102[3] = (uint64_t)(v103 + 6);
            v98 = v99;
          }
          while (v19 != v97);
          v94 += (v19 + 1);
        }
        while (v95 != v20);
        if (v17 > 0.0)
        {
          v145[0] = MEMORY[0x1E0C809B0];
          v145[1] = 0x40000000;
          v146 = sub_1B19074D8;
          v147 = &unk_1E63D92A8;
          v148 = &v155;
          v149 = v18;
          sub_1B19074D8((uint64_t)v145, 0, (v20 + 1) * (v19 + 1), v19, 1);
          *(_DWORD *)&v48[24 * v123 + 4] = sub_1B17EDAE0((uint64_t)v21, v104, v105, v106, v107, v108, v109, v110) - 1;
          sub_1B19074D8((uint64_t)v145, v19, v125, v20, v19 + 1);
          v146((uint64_t)v145, v127, v129, v19, -1);
          v146((uint64_t)v145, v133, v131, v20, ~v19);
        }
      }
      else
      {
        v49 = 0;
        v50 = 0;
        v155 = 0;
        v156 = &v155;
        v157 = 0x2000000000;
        v158 = v47;
        v51 = v47;
        do
        {
          v52 = 0;
          ++v50;
          v53 = v19 + v49;
          do
          {
            v54 = v49 + v52;
            *(_WORD *)v51 = v49 + v52;
            *(_WORD *)(v156[3] + 2) = v49 + v52 + 1;
            v55 = v53 + v52;
            v56 = v52 + 1;
            v57 = v53 + v52 + 2;
            *(_WORD *)(v156[3] + 4) = v57;
            *(_WORD *)(v156[3] + 6) = v54;
            *(_WORD *)(v156[3] + 8) = v57;
            *(_WORD *)(v156[3] + 10) = v55 + 1;
            v51 = (UInt8 *)(v156[3] + 12);
            v156[3] = (uint64_t)v51;
            v52 = v56;
          }
          while (v19 != v56);
          v49 += v36;
        }
        while (v50 != v20);
        if (v17 > 0.0)
        {
          v150[0] = MEMORY[0x1E0C809B0];
          v150[1] = 0x40000000;
          v151 = sub_1B19073D8;
          v152 = &unk_1E63D9280;
          v153 = &v155;
          v154 = v18;
          sub_1B19073D8((uint64_t)v150, 0, (v20 + 1) * (v19 + 1), v19, 1);
          *(_WORD *)&v48[12 * v123 + 2] = sub_1B17EDAE0((uint64_t)v21, v58, v59, v60, v61, v62, v63, v64) - 1;
          sub_1B19073D8((uint64_t)v150, v19, v125, v20, v19 + 1);
          v151((uint64_t)v150, v127, v129, v19, -1);
          v151((uint64_t)v150, v133, v131, v20, ~v19);
        }
      }
      _Block_object_dispose(&v155, 8);
      v68 = v124;
    }
  }
  v111 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v112 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v48, v46);
  sub_1B17A4464((uint64_t)v22, v42, v112, v68);
  CFRelease(v112);
  free(v48);
  BYTE2(v155) = 0;
  LOWORD(v155) = 0;
  v113 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  v114 = CFArrayCreate(v111, (const void **)&values, 3, MEMORY[0x1E0C9B378]);
  v115 = CFArrayCreate(v111, (const void **)&v159, 1, v113);
  v121 = sub_1B17AF674(v114, v115, (uint64_t)&v155, v116, v117, v118, v119, v120);
  CFRelease(v115);
  CFRelease(v114);
  if (values)
  {
    CFRelease(values);
    values = 0;
  }
  if (v161)
  {
    CFRelease(v161);
    v161 = 0;
  }
  if (v162)
  {
    CFRelease(v162);
    v162 = 0;
  }
  if (v159)
    CFRelease(v159);
  return v121;
}

uint64_t sub_1B1906FBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, float a7, float a8, float a9)
{
  const __CFAllocator *v16;
  __CFData *Mutable;
  uint64_t v18;
  float v19;
  uint64_t v20;
  float v21;
  uint64_t v22;
  float v23;
  unsigned int v24;
  unsigned int v25;
  float v26;
  uint64_t v27;
  float v28;
  CFDataRef Copy;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD v40[2];
  void (*v41)(uint64_t, float, float, float, float, float);
  void *v42;
  uint64_t *v43;
  __CFData *v44;
  float v45;
  float v46;
  float v47;
  float v48;
  int v49;
  char v50;
  _QWORD v51[2];
  void (*v52)(uint64_t, double, float, float);
  void *v53;
  uint64_t *v54;
  uint64_t v55;
  __CFData *v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  int v63;
  char v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  int v68;
  UInt8 bytes[4];
  uint64_t v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v65 = 0;
  v66 = &v65;
  v67 = 0x2000000000;
  v68 = 0;
  v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if ((_DWORD)a1 == 3)
    v18 = 2;
  else
    v18 = 3;
  v19 = a5 + (float)(a7 * -2.0);
  v37 = a6 + (float)(a7 * -2.0);
  if ((a3 & 0x8000000000000000) == 0)
  {
    v20 = 0;
    v21 = (float)a2;
    while (a2 < 0)
    {
LABEL_16:
      if (++v20 > a3)
        goto LABEL_17;
    }
    v22 = 0;
    v23 = (float)(v37 * (float)(int)v20) / (float)a3;
    *(float *)&v24 = 1.0 - (float)((float)(v23 + a7) / a6);
    *(float *)&v25 = a9 + v37 * -0.5 + v23;
    v38 = v25;
    v39 = v24;
    while (1)
    {
      if ((_DWORD)a1 == 3)
      {
        *(float *)bytes = (float)((float)((float)(v19 * (float)(int)v22) / v21) + a7) / a5;
        v27 = v39;
        goto LABEL_14;
      }
      if ((_DWORD)a1 == 1)
        break;
      if (!(_DWORD)a1)
      {
        v26 = a8 + v19 * -0.5 + (float)((float)(v19 * (float)(int)v22) / v21);
        *(float *)bytes = v26;
        v27 = v38;
LABEL_14:
        v70 = v27;
      }
      ++*((_DWORD *)v66 + 6);
      CFDataAppendBytes(Mutable, bytes, (4 * v18));
      if (++v22 > a2)
        goto LABEL_16;
    }
    *(float *)bytes = 0.0;
    v27 = 0x3F80000000000000;
    goto LABEL_14;
  }
LABEL_17:
  if (a7 > 0.0)
  {
    v51[0] = MEMORY[0x1E0C809B0];
    v51[1] = 0x40000000;
    v52 = sub_1B19077D8;
    v53 = &unk_1E63D9320;
    v64 = a1;
    v57 = a8;
    v58 = a7;
    v28 = 1.57079633 / (double)a4;
    v59 = v28;
    v60 = a9;
    v61 = a5;
    v62 = a6;
    v54 = &v65;
    v55 = a4;
    v56 = Mutable;
    v63 = v18;
    v40[0] = MEMORY[0x1E0C809B0];
    v40[1] = 0x40000000;
    v41 = sub_1B1907980;
    v42 = &unk_1E63D9348;
    v50 = a1;
    v45 = a8;
    v46 = a9;
    v47 = a5;
    v48 = a6;
    v43 = &v65;
    v44 = Mutable;
    v49 = v18;
    sub_1B19077D8((uint64_t)v51, -3.14159265, v19 * -0.5, v37 * -0.5);
    sub_1B1907980((uint64_t)v40, v19 * -0.5, a6 * -0.5, v19, 0.0, (float)a2);
    sub_1B19077D8((uint64_t)v51, -1.57079633, v19 * 0.5, v37 * -0.5);
    ((void (*)(_QWORD *, float, float, float, float))v41)(v40, a5 * 0.5, v37 * -0.5, 0.0, v37);
    v52((uint64_t)v51, 0.0, v19 * 0.5, v37 * 0.5);
    v41((uint64_t)v40, v19 * 0.5, a6 * 0.5, -v19, 0.0, (float)a2);
    v52((uint64_t)v51, 1.57079633, v19 * -0.5, v37 * 0.5);
    v41((uint64_t)v40, a5 * -0.5, v37 * 0.5, 0.0, -v37, (float)a3);
  }
  Copy = CFDataCreateCopy(v16, Mutable);
  v33 = sub_1B17ED204(Copy, a1, *((int *)v66 + 6), v18, 1, v30, v31, v32);
  CFRelease(Mutable);
  CFRelease(Copy);
  _Block_object_dispose(&v65, 8);
  return v33;
}

uint64_t sub_1B19073D8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = *(_QWORD *)(result + 40);
  if (v5 >= 1)
  {
    v6 = a3;
    v7 = *(_QWORD *)(result + 40);
    do
    {
      **(_WORD **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 2) = v6 - 1;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 4) = v6;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) += 6;
      ++v6;
      --v7;
    }
    while (v7);
  }
  if (a4 >= 1)
  {
    v8 = v5 + a3;
    do
    {
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 10) = a2;
      **(_WORD **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 2) = v8 - 1;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 6) = v8;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 4) = v8;
      a2 += a5;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 8) = a2;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) += 12;
      ++v8;
      --a4;
    }
    while (a4);
  }
  return result;
}

uint64_t sub_1B19074D8(uint64_t result, int a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;

  v5 = *(_QWORD *)(result + 40);
  if (v5 >= 1)
  {
    v6 = a3;
    v7 = *(_QWORD *)(result + 40);
    do
    {
      **(_DWORD **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 4) = v6 - 1;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 8) = v6;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) += 12;
      ++v6;
      --v7;
    }
    while (v7);
  }
  if (a4 >= 1)
  {
    v8 = 0;
    v9 = v5 + a3;
    do
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 20) = a2 + v8;
      **(_DWORD **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 + v8;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 4) = v9 - 1;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 12) = v9;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 8) = v9;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 16) = a5 + a2 + v8;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) += 24;
      v8 += a5;
      ++v9;
      --a4;
    }
    while (a4);
  }
  return result;
}

uint64_t sub_1B19075E8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;

  v5 = *(_QWORD *)(result + 40);
  if (v5 >= 2)
  {
    v6 = v5 - 1;
    v7 = a3;
    do
    {
      **(_WORD **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 4) = v7;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 2) = v7;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 6) = v7 + 1;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) += 8;
      ++v7;
      --v6;
    }
    while (v6);
  }
  if ((a4 & 0x8000000000000000) == 0)
  {
    v8 = v5 + a3;
    v9 = -1;
    do
    {
      **(_WORD **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 4) = v8 + v9;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 2) = v8 + v9;
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 6) = v8 + v9 + 1;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) += 8;
      ++v9;
      a2 += a5;
    }
    while (a4 != v9);
  }
  return result;
}

uint64_t sub_1B19076DC(uint64_t result, int a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;

  v5 = *(_QWORD *)(result + 40);
  if (v5 >= 2)
  {
    v6 = v5 - 1;
    v7 = a3;
    do
    {
      **(_DWORD **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 8) = v7;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 4) = v7++;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 12) = v7;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) += 16;
      --v6;
    }
    while (v6);
  }
  if ((a4 & 0x8000000000000000) == 0)
  {
    v8 = v5 + a3;
    v9 = a4 + 1;
    v10 = v8 - 1;
    do
    {
      **(_DWORD **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 8) = v10;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 4) = v10;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) + 12) = v8;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) += 16;
      ++v10;
      a2 += a5;
      ++v8;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t sub_1B19077CC(int a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, float a7)
{
  return sub_1B190655C(a1, a2, a3, a4, a5, a6, a7, 0.0, 0.0);
}

void sub_1B19077D8(uint64_t a1, double a2, float a3, float a4)
{
  double v8;
  double v9;
  uint64_t v10;
  int v11;
  double v12;
  double v13;
  __double2 v14;
  float v15;
  double v16;
  uint64_t v17;
  double v18;
  __double2 v19;
  float v20;
  float v21;
  unsigned int v22;
  UInt8 bytes[4];
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (*(uint64_t *)(a1 + 40) >= 2)
  {
    v8 = a3;
    v9 = a4;
    v10 = 1;
    while (1)
    {
      v11 = *(char *)(a1 + 84);
      if (v11 == 3)
        break;
      if (v11 == 1)
      {
        *(_DWORD *)bytes = 0;
        v17 = 0x3F80000000000000;
        goto LABEL_10;
      }
      if (!*(_BYTE *)(a1 + 84))
      {
        v12 = (float)(*(float *)(a1 + 56) + a3);
        v13 = *(float *)(a1 + 60);
        v14 = __sincos_stret((float)(*(float *)(a1 + 64) * (float)(int)v10) + a2);
        v15 = v12 + v13 * v14.__cosval;
        *(float *)bytes = v15;
        v16 = (float)(*(float *)(a1 + 68) + a4) + v13 * v14.__sinval;
        goto LABEL_9;
      }
LABEL_11:
      ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 48), bytes, 4 * *(int *)(a1 + 80));
      if (*(_QWORD *)(a1 + 40) <= ++v10)
        return;
    }
    v18 = *(float *)(a1 + 60);
    v19 = __sincos_stret((float)(*(float *)(a1 + 64) * (float)(int)v10) + a2);
    v20 = *(float *)(a1 + 76);
    v21 = (v8 + v18 * v19.__cosval) / *(float *)(a1 + 72) + 0.5;
    *(float *)bytes = v21;
    v16 = 1.0 - (v9 + v18 * v19.__sinval) / v20 + -0.5;
LABEL_9:
    *(float *)&v22 = v16;
    v17 = v22;
LABEL_10:
    v24 = v17;
    goto LABEL_11;
  }
}

void sub_1B1907980(uint64_t a1, float a2, float a3, float a4, float a5, float a6)
{
  float v6;
  float v13;
  int v14;
  int v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  float v20;
  UInt8 bytes[4];
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v6 = a6 + 1.0;
  if ((float)(a6 + 1.0) > 0.0)
  {
    v13 = 0.0;
    v14 = 1;
    while (1)
    {
      v15 = *(char *)(a1 + 68);
      if (v15 == 3)
        break;
      if (v15 == 1)
      {
        *(float *)bytes = 0.0;
        v19 = 0x3F80000000000000;
        goto LABEL_10;
      }
      if (!*(_BYTE *)(a1 + 68))
      {
        v16 = *(float *)(a1 + 52);
        *(float *)bytes = (float)((float)(v13 * a4) / a6) + (float)(*(float *)(a1 + 48) + a2);
        v17 = v16 + a3;
        v18 = (float)(v13 * a5) / a6;
        goto LABEL_9;
      }
LABEL_11:
      ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 40), bytes, 4 * *(int *)(a1 + 64));
      v13 = (float)v14++;
      if (v6 <= v13)
        return;
    }
    v20 = *(float *)(a1 + 60);
    *(float *)bytes = (float)((float)((float)((float)(v13 * a4) / a6) + a2) / *(float *)(a1 + 56)) + 0.5;
    v18 = 1.0 - (float)((float)((float)((float)(v13 * a5) / a6) + a3) / v20);
    v17 = -0.5;
LABEL_9:
    HIDWORD(v19) = 0;
    *(float *)&v19 = v18 + v17;
LABEL_10:
    v22 = v19;
    goto LABEL_11;
  }
}

void sub_1B1908A50(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 40);
  if (v4 > 8)
    v5 = 0;
  else
    v5 = dword_1B2248044[v4];
  v6 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1915480(v6, v5, v7, v8, v9, v10, v11, v12);
}

void sub_1B1908C4C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919738(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B1908DA0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B191942C(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B1908EF4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919558(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B1909048(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919B08(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B19091A4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919300(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B19092F8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B19199D0(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B190944C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919D60(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B19095A0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919C34(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B19096E8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919BC8(v5, *(unsigned int *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B1909830(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B19197F8(v5, *(unsigned int *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B1909978(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B19194EC(v5, *(unsigned int *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B1909AC0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919618(v5, *(unsigned int *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B1909C08(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B19193C0(v5, *(unsigned int *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B1909D50(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B19193C0(v5, *(unsigned int *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B1909E98(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919CF4(v5, *(unsigned int *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B1909FE0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B19198AC(v5, *(unsigned int *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B190A128(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919964(v5, *(unsigned int *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B190A27C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B1919A90(v5, v6, v7, v8, v9, v10, v11, v12, *(float *)(a1 + 40));
}

void sub_1B190A3BC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B19196CC(v5, *(char *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B190A60C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v4 = *(_DWORD *)(a1 + 40);
  if (v4 == 2)
  {
    v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
    v12 = 1;
LABEL_6:
    sub_1B1919204(v5, v12, v6, v7, v8, v9, v10, v11);
    return;
  }
  if (v4 != 1)
  {
    if (v4)
      return;
    v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
    v12 = 0;
    goto LABEL_6;
  }
  v13 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B19192B0(v13, 1, v14, v15, v16, v17, v18, v19);
}

void sub_1B190B080()
{
  if (!qword_1EEF66278)
    qword_1EEF66278 = sub_1B179CB60(&qword_1EEF66278);
}

uint64_t sub_1B190B0C0()
{
  if (qword_1EEF66280 != -1)
    dispatch_once(&qword_1EEF66280, &unk_1E63D1190);
  return sub_1B179CB90(qword_1EEF66278, 0x40uLL);
}

uint64_t sub_1B190B104()
{
  if (qword_1ED4CEA98 != -1)
    dispatch_once(&qword_1ED4CEA98, &unk_1E63D1710);
  return qword_1ED4CEAA0;
}

void sub_1B190B144()
{
  if (!qword_1ED4CEAA0)
    qword_1ED4CEAA0 = sub_1B179CB60(&qword_1ED4CEAA0);
}

uint64_t sub_1B190B184()
{
  if (qword_1ED4CEA98 != -1)
    dispatch_once(&qword_1ED4CEA98, &unk_1E63D1710);
  return sub_1B179CB90(qword_1ED4CEAA0, 0xA0uLL);
}

uint64_t sub_1B190B1C8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  char v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v4 = sub_1B18071BC();
  v5 = *(_DWORD *)(a1 + 16);
  v6 = *(__int16 *)(*(_QWORD *)(a1 + 32) + 2 * a2);
  v7 = sub_1B1801F94(*(double (**)(float32x4_t *, float32x4_t *, double, uint64_t, uint64_t, uint64_t, int, float32x4_t *))(*(_QWORD *)(a1 + 48) + 8 * a2));
  v11 = (const void *)sub_1B17F4EEC(v5, v6, v7, 0, 0);
  v12 = *(char **)(a1 + 64);
  if (a2 >= 1)
  {
    v13 = *(char **)(a1 + 40);
    v14 = a2;
    do
    {
      v15 = *v13++;
      v12 += (v15 + 15) & 0xF0;
      --v14;
    }
    while (v14);
  }
  if (*(_DWORD *)(a1 + 16))
  {
    v16 = 0;
    do
    {
      sub_1B17F5020((uint64_t)v11, v16, v12, 0, 0, v8, v9, v10, *(float *)(*(_QWORD *)(a1 + 56) + 4 * v16), 0.0, 0.0, 0.0);
      v12 += *(unsigned int *)(a1 + 24);
      ++v16;
    }
    while (v16 < *(unsigned int *)(a1 + 16));
  }
  sub_1B185D040(v4, *(CFTypeRef *)(*(_QWORD *)(a1 + 72) + 8 * a2));
  sub_1B1807218(v4, (uint64_t)v11, v17, v18, v19, v20, v21, v22);
  CFRelease(v11);
  return v4;
}

uint64_t sub_1B190B2DC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  uint64_t v31;
  float v32;
  uint64_t i;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;

  v2 = sub_1B18FF3A4();
  sub_1B185E154(a1, v2, v3, v4, v5, v6, v7, v8);
  v16 = sub_1B193E67C(a1, v9, v10, v11, v12, v13, v14, v15);
  sub_1B193E6E0(v2, v16, v17, v18, v19, v20, v21, v22);
  v30 = sub_1B185D118(a1, v23, v24, v25, v26, v27, v28, v29);
  v31 = *(unsigned int *)(*(_QWORD *)(a1 + 168) + 20);
  if ((_DWORD)v31)
  {
    v32 = v30;
    for (i = 0; i != v31; ++i)
    {
      v34 = (void *)sub_1B190B1C8(*(_QWORD *)(a1 + 168), i);
      sub_1B185D0C4((uint64_t)v34, v32, v35, v36, v37, v38, v39, v40, v41);
      sub_1B18FF420(v2, v34, v42, v43, v44, v45, v46, v47);
      CFRelease(v34);
    }
  }
  return v2;
}

uint64_t sub_1B190B390(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  id v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t i;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _BYTE *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  float v66;
  double v67;
  unsigned int v68;
  double v69;
  double v70;
  uint64_t v71;
  uint64_t *v72;
  double v73;
  char v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  double v84;
  double v85;
  uint64_t v86;
  uint64_t *v87;
  double v88;
  float v89;
  uint64_t v90;
  char *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  uint64_t v100;
  uint64_t v101;
  double v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  char v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  char v114;

  v114 = 0;
  if (!sub_1B190B90C(a1, &v114, a3, a4, a5, a6, a7, a8))
    return 0;
  v16 = sub_1B190BA74(a1, v9, v10, v11, v12, v13, v14, v15);
  if (!v114 && v16 < 3)
    return 0;
  v18 = v16;
  if (qword_1ED4CEA98 != -1)
    dispatch_once(&qword_1ED4CEA98, &unk_1E63D1710);
  v19 = sub_1B179CB90(qword_1ED4CEAA0, 0xA0uLL);
  v27 = sub_1B193E67C(a1, v20, v21, v22, v23, v24, v25, v26);
  sub_1B193E6E0(v19, v27, v28, v29, v30, v31, v32, v33);
  *(_QWORD *)(v19 + 168) = sub_1B190B0C0();
  sub_1B185CF98(v19);
  v111 = v19;
  v34 = *(_QWORD *)(v19 + 168);
  *(_DWORD *)(v34 + 20) = v18;
  *(_QWORD *)(v34 + 32) = malloc_type_malloc(2 * v18, 0x1000040BDFB0063uLL);
  *(_QWORD *)(v34 + 40) = malloc_type_malloc(v18, 0x100004077774924uLL);
  *(_QWORD *)(v34 + 48) = malloc_type_malloc(8 * v18, 0x80040B8603338uLL);
  *(_QWORD *)(v34 + 72) = malloc_type_malloc(8 * v18, 0x6004044C4A2DFuLL);
  v35 = (uint64_t *)malloc_type_malloc(8 * *(unsigned int *)(v34 + 20), 0x2004093837F09uLL);
  v113 = 0;
  sub_1B190BAFC(a1, (uint64_t)v35, &v113, v36, v37, v38, v39, v40);
  if (v18)
  {
    v41 = 0;
    for (i = 0; i != v18; v41 += (*(_BYTE *)(*(_QWORD *)(v34 + 40) + i++) + 15) & 0xF0)
    {
      v43 = v35[i];
      *(_QWORD *)(*(_QWORD *)(v34 + 72) + 8 * i) = sub_1B185D090(v43);
      CFRetain(*(CFTypeRef *)(*(_QWORD *)(v34 + 72) + 8 * i));
      v44 = *(_QWORD *)(v43 + 168);
      v45 = *(_QWORD *)(v34 + 40);
      *(_WORD *)(*(_QWORD *)(v34 + 32) + 2 * i) = *(_WORD *)(v44 + 28);
      *(_BYTE *)(v45 + i) = *(_BYTE *)(v44 + 30);
      *(_QWORD *)(*(_QWORD *)(v34 + 48) + 8 * i) = sub_1B17FFEC0(*(__int16 *)(*(_QWORD *)(v43 + 168) + 28), *(char *)(*(_QWORD *)(v43 + 168) + 99), 1, 0);
    }
    *(_DWORD *)(v34 + 24) = v41;
    v53 = malloc_type_malloc(v18, 0x100004077774924uLL);
    v54 = 0;
    while (1)
    {
      v55 = sub_1B18072BC(v35[v54], v46, v47, v48, v49, v50, v51, v52);
      if (!v55)
        break;
      v56 = v55;
      if (sub_1B17F5F34(v55))
      {
        v57 = 1;
      }
      else
      {
        if (!sub_1B17F5F78(v56))
          break;
        v57 = sub_1B17F58D8(v56, v46, v47, v48, v49, v50, v51, v52) != 0;
      }
LABEL_19:
      v53[v54++] = v57;
      if (v18 == v54)
        goto LABEL_23;
    }
    v57 = 0;
    goto LABEL_19;
  }
  *(_DWORD *)(v34 + 24) = 0;
  v53 = malloc_type_malloc(0, 0x100004077774924uLL);
  v41 = 0;
LABEL_23:
  v112 = a1;
  v66 = sub_1B185D118(a1, v46, v47, v48, v49, v50, v51, v52);
  v67 = v66;
  if (v66 < 0.0)
    goto LABEL_38;
  v68 = 0;
  v69 = 0.0;
  do
  {
    v70 = v66;
    if (v18)
    {
      v71 = v18;
      v72 = v35;
      v70 = v66;
      do
      {
        v73 = v69 + 0.0416666667;
        if (!v53)
          sub_1B190BBDC(*v72, v69, v67, v59, v60, v61, v62, v63, v64, v65);
        if (v73 < v70)
          v70 = v73;
        ++v72;
        --v71;
      }
      while (v71);
    }
    if (v70 >= v69 + 0.00833333333)
      v69 = v70;
    else
      v69 = v69 + 0.00833333333;
    ++v68;
  }
  while (v69 <= v67);
  if (v68)
  {
    v74 = 0;
  }
  else
  {
LABEL_38:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v60, v61, v62, v63, v64, v65, (uint64_t)"keyCount");
    v68 = 0;
    v74 = 1;
  }
  *(_DWORD *)(v34 + 16) = v68;
  v75 = v68;
  *(_QWORD *)(v34 + 56) = malloc_type_malloc(4 * v68, 0x100004052888210uLL);
  if (v66 >= 0.0)
  {
    v110 = v74;
    v83 = 0;
    v84 = 0.0;
    do
    {
      v85 = v66;
      if (v18)
      {
        v86 = v18;
        v87 = v35;
        v85 = v66;
        do
        {
          v88 = v84 + 0.0416666667;
          if (!v53)
            sub_1B190BBDC(*v87, v84, v67, v76, v77, v78, v79, v80, v81, v82);
          if (v88 < v85)
            v85 = v88;
          ++v87;
          --v86;
        }
        while (v86);
      }
      if (v85 < v84 + 0.00833333333)
        v85 = v84 + 0.00833333333;
      v89 = v84;
      *(float *)(*(_QWORD *)(v34 + 56) + 4 * v83++) = v89;
      v84 = v85;
    }
    while (v85 <= v67);
    v74 = v110;
  }
  else
  {
    LODWORD(v83) = 0;
  }
  if ((_DWORD)v83 != (_DWORD)v75)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. bad count"), v77, v78, v79, v80, v81, v82, (uint64_t)"keyIndex == (int)keyCount");
  v90 = v41 * v75;
  v91 = (char *)malloc_type_malloc(v41 * v75, 0x5B32AAF7uLL);
  v98 = (uint64_t)v91;
  *(_QWORD *)(v34 + 64) = v91;
  if ((v74 & 1) != 0)
  {
    v99 = v91;
  }
  else
  {
    v100 = 0;
    do
    {
      if (v18)
      {
        v101 = 0;
        v102 = *(float *)(*(_QWORD *)(v34 + 56) + 4 * v100);
        do
        {
          sub_1B17F51E4(*(_QWORD *)(v35[v101] + 168), 0, 0, v98, v94, v95, v96, v97, v102);
          v98 += (*(_BYTE *)(*(_QWORD *)(v34 + 40) + v101++) + 15) & 0xF0;
        }
        while (v18 != v101);
      }
      ++v100;
    }
    while (v100 != v75);
    v99 = *(char **)(v34 + 64);
  }
  if ((char *)v98 != &v99[v90])
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. CFXAnimationClusterCreateWithAnimationGroup out of bounds"), v92, v93, v94, v95, v96, v97, (uint64_t)"valueWrt == kf->_values + (totalValueSize * keyCount)");
  free(v35);
  v58 = v111;
  *(float *)(v111 + 72) = v66;
  sub_1B185E154(v112, v111, v103, v104, v105, v106, v107, v108);
  return v58;
}

BOOL sub_1B190B90C(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  _WORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _WORD *v34;
  CFIndex v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  CFTypeID v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;

  if ((*(_WORD *)(a1 + 84) & 6) != 0)
    return 0;
  v10 = sub_1B18FF4FC(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B185D118(a1, v11, v12, v13, v14, v15, v16, v17) == 0.0)
    return 0;
  if (v10 < 1)
    return 1;
  v26 = sub_1B18FF544(a1, 0, v18, v19, v20, v21, v22, v23);
  if ((v26[42] & 6) != 0)
  {
    return 0;
  }
  else
  {
    v34 = v26;
    v24 = 0;
    v35 = 1;
    while (sub_1B18089AC((uint64_t)v34, v27, v28, v29, v30, v31, v32, v33) == 0.0
         && sub_1B185D6F0((uint64_t)v34, v36, v37, v38, v39, v40, v41, v42) == 0.0
         && sub_1B185D118((uint64_t)v34, v43, v44, v45, v46, v47, v48, v49) != 0.0)
    {
      if (sub_1B185D098(v34))
      {
        if ((sub_1B190B90C(v34, a2) & 1) == 0)
          return v24;
      }
      else
      {
        v56 = CFGetTypeID(v34);
        if (v56 != sub_1B180713C())
          return v24;
        v64 = sub_1B18072BC((uint64_t)v34, v57, v58, v59, v60, v61, v62, v63);
        if (sub_1B17F582C(v64, v65, v66, v67, v68, v69, v70, v71))
          return v24;
        if (sub_1B17F5F78(v64) && sub_1B17F58D8(v64, v72, v50, v51, v52, v53, v54, v55))
          *a2 = 1;
      }
      v24 = v35 >= v10;
      if (v10 != v35)
      {
        v34 = sub_1B18FF544(a1, v35++, v50, v51, v52, v53, v54, v55);
        if ((v34[42] & 6) == 0)
          continue;
      }
      return v24;
    }
  }
  return v24;
}

uint64_t sub_1B190BA74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  CFIndex v17;
  uint64_t v18;
  const void *v19;
  int v20;

  v9 = sub_1B18FF4FC(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v9 < 1)
    return 0;
  v16 = v9;
  v17 = 0;
  LODWORD(v18) = 0;
  do
  {
    v19 = sub_1B18FF544(a1, v17, v10, v11, v12, v13, v14, v15);
    if (sub_1B185D098(v19))
      v20 = sub_1B190BA74(v19);
    else
      v20 = 1;
    v18 = (v20 + v18);
    ++v17;
  }
  while (v16 != v17);
  return v18;
}

void sub_1B190BAFC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFIndex v18;
  CFIndex i;
  const void *v20;
  CFTypeID v21;
  uint64_t v22;

  v11 = sub_1B18FF4FC(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (v11 >= 1)
  {
    v18 = v11;
    for (i = 0; i != v18; ++i)
    {
      v20 = sub_1B18FF544(a1, i, v12, v13, v14, v15, v16, v17);
      if (sub_1B185D098(v20))
      {
        sub_1B190BAFC(v20, a2, a3);
      }
      else
      {
        v21 = CFGetTypeID(v20);
        if (v21 != sub_1B180713C())
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. unexpected animation class"), v12, v13, v14, v15, v16, v17, (uint64_t)"CFGetTypeID(animation) == CFXKeyframedAnimationGetTypeID()");
        v22 = *a3;
        *(_QWORD *)(a2 + 8 * *a3) = v20;
        *a3 = v22 + 1;
      }
    }
  }
}

void sub_1B190BBDC(uint64_t a1, double a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  double v11;
  float v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  float v21;

  v10 = *(_QWORD *)(a1 + 168);
  v11 = a2 / a3 * *(double *)(v10 + 16);
  v12 = v11 + 0.00001;
  v21 = v12;
  v13 = sub_1B17F4DC4(*(float **)(v10 + 40), *(_DWORD *)(v10 + 24), &v21, 0, a7, a8, a9, a10);
  if (v13 < *(_DWORD *)(v10 + 24) - 1)
  {
    v20 = v11;
    if (*(float *)(*(_QWORD *)(v10 + 40) + 4 * (v13 + 1)) < v20)
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. _getNextKeyTime twice the same keytime?"), v14, v15, v16, v17, v18, v19, (uint64_t)"kf->_keytimes[index+1] >= (float)time");
  }
}

CFTypeRef sub_1B190BCA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result;

  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    if (a2)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"dest");
LABEL_3:
  result = *(CFTypeRef *)(a1 + 168);
  if (result)
    result = CFRetain(result);
  *(_QWORD *)(a2 + 168) = result;
  return result;
}

__CFArray *sub_1B190BD28(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  __CFArray *Mutable;
  uint64_t v5;
  uint64_t v6;
  const __CFArray *v7;
  const __CFArray *v8;

  v1 = *(_QWORD *)(a1 + 168);
  if (!v1)
    return 0;
  v2 = *(unsigned int *)(v1 + 20);
  if (!(_DWORD)v2)
    return 0;
  Mutable = CFArrayCreateMutable(0, *(unsigned int *)(v1 + 20), MEMORY[0x1E0C9B378]);
  v5 = 0;
  v6 = 8 * v2;
  do
  {
    v7 = sub_1B17A02D0(*(const __CFArray **)(*(_QWORD *)(*(_QWORD *)(a1 + 168) + 72) + v5));
    if (v7)
    {
      v8 = v7;
      CFArrayAppendValue(Mutable, v7);
      CFRelease(v8);
    }
    v5 += 8;
  }
  while (v6 != v5);
  return Mutable;
}

void sub_1B190BDCC(uint64_t a1)
{
  unint64_t v2;
  unint64_t i;
  const void *v4;

  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 56));
  free(*(void **)(a1 + 64));
  v2 = *(unsigned int *)(a1 + 20);
  if ((_DWORD)v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(const void **)(*(_QWORD *)(a1 + 72) + 8 * i);
      if (v4)
      {
        CFRelease(v4);
        *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * i) = 0;
        v2 = *(unsigned int *)(a1 + 20);
      }
    }
  }
  free(*(void **)(a1 + 72));
}

CFStringRef sub_1B190BE48(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXAnimationClusterKeyframes %p>"), a1);
}

CFStringRef sub_1B190BE84(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXAnimationClusterKeyframes %p>"), a1);
}

void sub_1B190BEC4(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;

  sub_1B185CF48(a1, a2, a3, a4, a5, a6, a7, a8);
  v9 = (const void *)a1[21];
  if (v9)
  {
    CFRelease(v9);
    a1[21] = 0;
  }
}

CFStringRef sub_1B190BEF4(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXAnimationCluster %p>"), a1);
}

CFStringRef sub_1B190BF30(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXAnimationCluster %p>"), a1);
}

void sub_1B190C128(uint64_t a1)
{
  id Weak;
  const char *v2;
  uint64_t v3;
  uint64_t v4;

  Weak = objc_loadWeak((id *)(a1 + 32));
  sub_1B190C140((uint64_t)Weak, v2, v3, v4);
}

void sub_1B190C140(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  int v9;
  unsigned int v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  unsigned int v16;

  if (a1
    && (objc_msgSend_isPaused((void *)a1, a2, a3, a4) & 1) == 0
    && (objc_msgSend__isInvalidated((void *)a1, v5, v6, v7) & 1) == 0)
  {
    v8 = (unsigned int *)(a1 + 88);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
    if (v9 < 4)
    {
      v11 = (void *)MEMORY[0x1B5E23520]();
      if ((objc_msgSend_isPaused((void *)a1, v12, v13, v14) & 1) == 0 && !*(_BYTE *)(a1 + 57))
      {
        v15 = COERCE_DOUBLE(atomic_load((unint64_t *)(a1 + 16)));
        (*(void (**)(double))(*(_QWORD *)(a1 + 32) + 16))(v15);
      }
      do
        v16 = __ldaxr(v8);
      while (__stlxr(v16 - 1, v8));
      objc_autoreleasePoolPop(v11);
    }
    else
    {
      do
        v10 = __ldaxr(v8);
      while (__stlxr(v10 - 1, v8));
    }
  }
}

void sub_1B190C318(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B190C42C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  const char *v6;
  uint64_t v7;

  result = objc_msgSend__isInvalidated(*(void **)(a1 + 32), a2, a3, a4);
  if ((result & 1) == 0)
    return objc_msgSend_setPaused_(*(void **)(a1 + 32), v6, 0, v7);
  return result;
}

void sub_1B190C598(uint64_t a1, double a2)
{
  id v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  int v16;
  unsigned int v17;
  void *v18;
  NSObject *v19;
  _QWORD v20[6];
  uint8_t buf[16];

  if (a1)
  {
    v4 = (id)a1;
    objc_msgSend_lock(*(void **)(a1 + 80), v5, v6, v7);
    v8 = sub_1B17C439C();
    if (os_signpost_enabled(v8))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1B178D000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "DisplayLink", "", buf, 2u);
    }
    if ((objc_msgSend_isPaused((void *)a1, v9, v10, v11) & 1) == 0
      && (objc_msgSend__isInvalidated((void *)a1, v12, v13, v14) & 1) == 0)
    {
      v15 = (unsigned int *)(a1 + 88);
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 + 1, v15));
      if (v16 < 4)
      {
        v18 = (void *)MEMORY[0x1B5E23520]();
        v19 = *(NSObject **)(a1 + 48);
        v20[0] = MEMORY[0x1E0C809B0];
        v20[1] = 3221225472;
        v20[2] = sub_1B190C6C8;
        v20[3] = &unk_1E63D83E0;
        v20[4] = a1;
        *(double *)&v20[5] = a2;
        dispatch_sync(v19, v20);
        objc_autoreleasePoolPop(v18);
      }
      else
      {
        do
          v17 = __ldaxr(v15);
        while (__stlxr(v17 - 1, v15));
      }
    }
    objc_msgSend_unlock(*(void **)(a1 + 80), v12, v13, v14);

  }
}

uint64_t sub_1B190C6C8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;

  result = objc_msgSend_isPaused(*(void **)(a1 + 32), a2, a3, a4);
  v6 = *(_QWORD *)(a1 + 32);
  if ((result & 1) == 0 && !*(_BYTE *)(v6 + 57))
  {
    result = (*(uint64_t (**)(double))(*(_QWORD *)(v6 + 32) + 16))(*(double *)(a1 + 40));
    v6 = *(_QWORD *)(a1 + 32);
  }
  v7 = (unsigned int *)(v6 + 88);
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  return result;
}

void *sub_1B190C7B4(int *a1, uint64_t a2, uint64_t a3)
{
  double v5;
  double v6;
  double v7;
  uint64_t i;
  double v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  __int128 v17;
  __int128 v18;
  double v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  void *result;
  unsigned int v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  float64x2_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  unsigned int v53;
  _BYTE __dst[536];
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;
  __int128 v63;
  __int128 v64;
  int v65;

  v5 = 0.0;
  v6 = 1.17549435e-38;
  v7 = 3.40282347e38;
  for (i = 88; i != 208; i += 2)
  {
    v9 = *(double *)&a1[i];
    if (v7 >= v9)
      v7 = *(double *)&a1[i];
    if (v6 < v9)
      v6 = *(double *)&a1[i];
    v5 = v5 + v9;
  }
  *((double *)a1 + 42) = v7;
  *((double *)a1 + 43) = v6;
  *((double *)a1 + 41) = v5 / 60.0;
  v50 = a1[2];
  v51 = a1[1];
  v10 = a1[4];
  v52 = a1[3];
  v53 = *a1;
  v11 = a1[6];
  v12 = a1[7];
  v13 = a1[9];
  v14 = a1[10];
  v15 = a1[11];
  v16 = a1[12];
  v46 = a1[5];
  v47 = a1[13];
  v48 = a1[14];
  v49 = a1[8];
  v17 = *(_OWORD *)(a1 + 15);
  v18 = *(_OWORD *)(a1 + 19);
  v65 = a1[23];
  v63 = v17;
  v64 = v18;
  v43 = *((float64x2_t *)a1 + 7);
  v44 = *((float64x2_t *)a1 + 6);
  v45 = *((float64x2_t *)a1 + 9);
  v40 = *((float64x2_t *)a1 + 10);
  v41 = *((float64x2_t *)a1 + 11);
  v42 = *((float64x2_t *)a1 + 8);
  v19 = *((double *)a1 + 24);
  v20 = *(_OWORD *)(a1 + 50);
  v21 = *(_OWORD *)(a1 + 54);
  v22 = *(_OWORD *)(a1 + 62);
  v57 = *(_OWORD *)(a1 + 58);
  v58 = v22;
  v55 = v20;
  v56 = v21;
  v23 = *(_OWORD *)(a1 + 66);
  v24 = *(_OWORD *)(a1 + 70);
  v25 = *(_OWORD *)(a1 + 74);
  v62 = *((_QWORD *)a1 + 39);
  v60 = v24;
  v61 = v25;
  v59 = v23;
  result = memcpy(__dst, a1 + 80, sizeof(__dst));
  if (v10 <= 1)
    v27 = 1;
  else
    v27 = v10;
  if (a2)
  {
    v62 = *(_QWORD *)(a2 + 312);
    v28 = *(_OWORD *)(a2 + 232);
    v56 = *(_OWORD *)(a2 + 216);
    v57 = v28;
    v29 = *(_OWORD *)(a2 + 264);
    v30 = *(_OWORD *)(a2 + 280);
    v58 = *(_OWORD *)(a2 + 248);
    v59 = v29;
    v31 = *(_OWORD *)(a2 + 296);
    v60 = v30;
    v61 = v31;
  }
  if (a3)
  {
    v32 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v27), 0);
    v33 = v63;
    *(_OWORD *)(a3 + 76) = v64;
    *(_DWORD *)a3 = v53 / v27;
    *(_DWORD *)(a3 + 4) = v51 / v27;
    *(_DWORD *)(a3 + 8) = v50 / v27;
    *(_DWORD *)(a3 + 12) = v52;
    *(_DWORD *)(a3 + 16) = v10;
    *(_DWORD *)(a3 + 20) = v46 / v27;
    *(_DWORD *)(a3 + 24) = v11 / v27;
    *(_DWORD *)(a3 + 28) = v12 / v27;
    *(_DWORD *)(a3 + 32) = v49;
    *(_DWORD *)(a3 + 36) = v13 / v27;
    *(_DWORD *)(a3 + 40) = v14 / v27;
    *(_DWORD *)(a3 + 44) = v15 / v27;
    *(_DWORD *)(a3 + 48) = v16 / v27;
    *(_DWORD *)(a3 + 52) = v47 / v27;
    *(_DWORD *)(a3 + 56) = v48 / v27;
    *(_DWORD *)(a3 + 92) = v65;
    *(_OWORD *)(a3 + 60) = v33;
    *(float64x2_t *)(a3 + 96) = vdivq_f64(v44, v32);
    *(float64x2_t *)(a3 + 112) = vdivq_f64(v43, v32);
    *(float64x2_t *)(a3 + 128) = vdivq_f64(v42, v32);
    *(float64x2_t *)(a3 + 144) = vdivq_f64(v45, v32);
    *(float64x2_t *)(a3 + 160) = vdivq_f64(v40, v32);
    *(float64x2_t *)(a3 + 176) = vdivq_f64(v41, v32);
    *(double *)(a3 + 192) = v19 / (double)v27;
    v34 = v55;
    v35 = v56;
    v36 = v57;
    *(_OWORD *)(a3 + 248) = v58;
    *(_OWORD *)(a3 + 232) = v36;
    *(_OWORD *)(a3 + 216) = v35;
    *(_OWORD *)(a3 + 200) = v34;
    v37 = v59;
    v38 = v60;
    v39 = v61;
    *(_QWORD *)(a3 + 312) = v62;
    *(_OWORD *)(a3 + 280) = v38;
    *(_OWORD *)(a3 + 296) = v39;
    *(_OWORD *)(a3 + 264) = v37;
    return memcpy((void *)(a3 + 320), __dst, 0x218uLL);
  }
  return result;
}

void sub_1B190CA58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"stats");
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(CFTimeInterval *)(a1 + 840) = CACurrentMediaTime();
}

CFTimeInterval sub_1B190CAC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTimeInterval result;
  CFTimeInterval v10;
  uint64_t v11;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"stats");
  result = CACurrentMediaTime();
  v10 = result - *(double *)(a1 + 848);
  *(CFTimeInterval *)(a1 + 96) = result - *(double *)(a1 + 840);
  *(CFTimeInterval *)(a1 + 848) = result;
  v11 = *(unsigned int *)(a1 + 832);
  *(CFTimeInterval *)(a1 + 8 * v11 + 352) = v10;
  *(_DWORD *)(a1 + 832) = ((int)v11 + 1) % 0x3Cu;
  ++*(_DWORD *)(a1 + 16);
  return result;
}

uint64_t sub_1B190CB5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  unsigned __int8 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  const void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const __CFDictionary *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  float32x2_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  uint64_t v59;
  __int128 v60;
  uint64_t v61;
  __int128 v62;
  unsigned __int8 v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  CFX::RG::Resource *v68;
  __int128 v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t *v74;
  double v75;
  _OWORD v76[5];
  uint64_t v77;
  uint64_t v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  char v86;
  char v87;
  uint64_t v88;
  int v89;
  __int16 v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v79 = a2;
  *((_QWORD *)&v79 + 1) = a3;
  v12 = atomic_load((unsigned __int8 *)&qword_1EEF664A0);
  if ((v12 & 1) == 0 && __cxa_guard_acquire(&qword_1EEF664A0))
  {
    byte_1EEF66498 = 1;
    __cxa_guard_release(&qword_1EEF664A0);
  }
  if (byte_1EEF66498)
    v13 = 0x39077B4FC07D180;
  else
    v13 = 0;
  sub_1B182AAEC(a1, a2, a3, a5, v13, a6);
  *(_QWORD *)a1 = &off_1E63CF358;
  v74 = (uint64_t *)(a1 + 384);
  *(_OWORD *)(a1 + 384) = v79;
  *(_QWORD *)(a1 + 400) = 0;
  *(_QWORD *)(a1 + 408) = a1 + 416;
  *(_QWORD *)(a1 + 424) = 0;
  v78 = *(_QWORD *)(a1 + 368);
  v21 = sub_1B1813884(v78, v14, v15, v16, v17, v18, v19, v20);
  v29 = sub_1B187B188(v21, v22, v23, v24, v25, v26, v27, v28);
  v73 = sub_1B179865C(v29);
  v30 = sub_1B1798668(v29);
  v31 = sub_1B1797B08(v29);
  v75 = sub_1B1797AF8(v29);
  v32 = *(_DWORD *)(a1 + 404);
  if (v31 > v32)
    sub_1B179C78C((uint64_t)v74, v31 - v32, 1);
  if (v30)
  {
    v33 = 0;
    v71 = v30;
    v72 = v29;
    do
    {
      v34 = *(const void **)(v73 + 8 * v33);
      if (sub_1B17985A4(v29, v34))
      {
        v42 = sub_1B1868FE8((uint64_t)v34, v35, v36, v37, v38, v39, v40, v41);
        v50 = (float32x2_t *)sub_1B18626CC((uint64_t)v42, v43, v44, v45, v46, v47, v48, v49);
        v58 = sub_1B1862714((uint64_t)v42, v51, v52, v53, v54, v55, v56, v57);
        if (v58)
        {
          v59 = v58;
          do
          {
            *(float32x2_t *)&v60 = vmul_f32(*(float32x2_t *)&v75, *v50);
            *((float32x2_t *)&v60 + 1) = vmul_f32(*(float32x2_t *)&v75, (float32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v50->f32, *(int8x16_t *)v50->f32, 8uLL));
            v81 = (unint64_t)v34;
            *(_QWORD *)&v82 = 0;
            v83 = v60;
            LOBYTE(v84) = 1;
            v85 = xmmword_1B2245710;
            v86 = *(_BYTE *)(a1 + 376);
            v87 = 2;
            v88 = 3;
            v89 = 1;
            v90 = 1;
            v61 = sub_1B17CA2A0(v79, *((uint64_t *)&v79 + 1), (uint64_t *)&v79, &v78, &v81);
            v77 = 0;
            v62 = v79;
            *(_QWORD *)&v81 = 0;
            WORD4(v81) = 0;
            BYTE10(v81) = *(_BYTE *)(a1 + 377);
            *(_QWORD *)&v82 = 8;
            WORD4(v82) = 0;
            v63 = atomic_load((unsigned __int8 *)&qword_1EEF664A0);
            if ((v63 & 1) == 0)
            {
              v70 = v79;
              v67 = __cxa_guard_acquire(&qword_1EEF664A0);
              v62 = v70;
              if (v67)
              {
                byte_1EEF66498 = 1;
                __cxa_guard_release(&qword_1EEF664A0);
                v62 = v70;
              }
            }
            v64 = 0x39077B4FC07D180;
            if (!byte_1EEF66498)
              v64 = 0;
            *(_QWORD *)&v83 = v64;
            v80 = v62;
            v65 = sub_1B179C1C0(&v80, 0x40u, 8u);
            sub_1B182CDF0(v65, v78, (uint64_t)&v81, v61);
            v77 = v66;
            sub_1B179C734(v74, &v77);
            v50 += 2;
            --v59;
          }
          while (v59);
        }
      }
      ++v33;
      v29 = v72;
    }
    while (v33 != v71);
  }
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  v81 = 0u;
  RGTextureDescriptorMakeDefault((uint64_t)&v81);
  LOWORD(v81) = (int)*(float *)&v75;
  WORD1(v81) = (int)*((float *)&v75 + 1);
  v82 = xmmword_1B22480C0;
  v76[2] = v83;
  v76[3] = v84;
  v76[4] = v85;
  v76[0] = v81;
  v76[1] = xmmword_1B22480C0;
  v68 = sub_1B179BD38(a4, (uint64_t)"SHADOW_MAP_ATLAS", (uint64_t)v76);
  *(_QWORD *)(a1 + 424) = v68;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v68, 0x200000002, -1);
  return a1;
}

void sub_1B190CF0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  CFX::RG::Pass *v18;

  sub_1B190D7C4(a18);
  CFX::RG::Pass::~Pass(v18);
  _Unwind_Resume(a1);
}

void sub_1B190CF5C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  __n128 *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  const __CFDictionary *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  _OWORD *v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int8 v83;
  unsigned __int8 v84;
  unsigned __int8 v85;
  unsigned __int8 v86;
  unsigned __int8 v87;
  uint64_t v88;
  _OWORD *v89;
  uint64_t v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 *v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 *v101;
  uint64_t v102;
  uint64_t v103;
  _OWORD *v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  uint64_t v111;
  uint64_t *v112;
  uint64_t v113;
  uint64_t *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  __int128 v123;
  const char *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unsigned int v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  _OWORD v133[4];
  _OWORD v134[5];

  v6 = sub_1B1815BE8(*(_QWORD *)(a1 + 368), a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Shadow", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/ShadowMapAtlasPass.mm", 93, v6 | 0x300000000);
  v14 = sub_1B1813884(*(_QWORD *)(a1 + 368), v7, v8, v9, v10, v11, v12, v13);
  v22 = sub_1B187B188(v14, v15, v16, v17, v18, v19, v20, v21);
  sub_1B1798594(v22, *(_QWORD *)(a1 + 424));
  v127 = sub_1B179865C(v22);
  v124 = a2;
  v30 = sub_1B1798668(v22);
  v31 = *(unsigned int *)(a1 + 400);
  if ((_DWORD)v31)
  {
    v32 = *(uint64_t **)(a1 + 408);
    v33 = 8 * v31;
    do
    {
      v34 = (__n128 *)sub_1B180C828(*v32);
      sub_1B19610E0(v34, v35, v36, v37);
      sub_1B196142C((uint64_t)v34, v38, v39, v40, v41, v42, v43, v44);
      ++v32;
      v33 -= 8;
    }
    while (v33);
  }
  v125 = v14;
  if (v30)
  {
    v45 = 0;
    v46 = 0;
    v126 = v30;
    v123 = xmmword_1B2244E20;
    do
    {
      v47 = sub_1B1868FE8(*(_QWORD *)(v127 + 8 * v45), v23, v24, v25, v26, v27, v28, v29);
      v128 = sub_1B1862714((uint64_t)v47, v48, v49, v50, v51, v52, v53, v54);
      v55 = sub_1B180C828(*(_QWORD *)(*(_QWORD *)(a1 + 408) + 8 * v46));
      v63 = sub_1B186064C((uint64_t)v47, v56, v57, v58, v59, v60, v61, v62);
      v64 = (_OWORD *)sub_1B181E7E0(v55);
      v65 = (_QWORD *)sub_1B181DE6C(v55);
      if (v63 == 1)
        v67 = 0;
      else
        v67 = (uint64_t)(v64 + 449);
      sub_1B17981CC(v22, v65, v67, (uint64_t)(v64 + 577), 0, 0, 0, v66, v123);
      if (sub_1B186064C((uint64_t)v47, v68, v69, v70, v71, v72, v73, v74) == 2)
        sub_1B18D2C40(v125, v47, (uint64_t)(v64 + 449), (uint64_t)(v64 + 577), v78, v79, v80, v81);
      if (v63 == 1 && v128)
      {
        v82 = 0;
        v131 = *((float32x4_t *)v64 + 450);
        v132 = *((float32x4_t *)v64 + 449);
        v129 = *((float32x4_t *)v64 + 452);
        v130 = *((float32x4_t *)v64 + 451);
        do
        {
          v83 = atomic_load((unsigned __int8 *)qword_1EEF662A0);
          if ((v83 & 1) == 0 && __cxa_guard_acquire(qword_1EEF662A0))
          {
            xmmword_1EEF66290 = xmmword_1B2244DB0;
            __cxa_guard_release(qword_1EEF662A0);
          }
          v84 = atomic_load((unsigned __int8 *)qword_1EEF662C0);
          if ((v84 & 1) == 0 && __cxa_guard_acquire(qword_1EEF662C0))
          {
            xmmword_1EEF662B0 = xmmword_1B2244DD0;
            __cxa_guard_release(qword_1EEF662C0);
          }
          v85 = atomic_load((unsigned __int8 *)qword_1EEF662E0);
          if ((v85 & 1) == 0 && __cxa_guard_acquire(qword_1EEF662E0))
          {
            xmmword_1EEF662D0 = xmmword_1B2244D90;
            __cxa_guard_release(qword_1EEF662E0);
          }
          v86 = atomic_load((unsigned __int8 *)qword_1EEF66300);
          if ((v86 & 1) == 0 && __cxa_guard_acquire(qword_1EEF66300))
          {
            xmmword_1EEF662F0 = v123;
            __cxa_guard_release(qword_1EEF66300);
          }
          v87 = atomic_load((unsigned __int8 *)&qword_1EEF66490);
          if ((v87 & 1) == 0 && __cxa_guard_acquire(&qword_1EEF66490))
          {
            xmmword_1EEF66310[0] = xmmword_1EEF662D0;
            unk_1EEF66320 = xmmword_1EEF662B0;
            xmmword_1EEF66330 = (__int128)vnegq_f32((float32x4_t)xmmword_1EEF66290);
            unk_1EEF66340 = xmmword_1EEF662F0;
            xmmword_1EEF66350 = (__int128)vnegq_f32((float32x4_t)xmmword_1EEF662D0);
            unk_1EEF66360 = xmmword_1EEF662B0;
            xmmword_1EEF66370 = xmmword_1EEF66290;
            unk_1EEF66380 = xmmword_1EEF662F0;
            xmmword_1EEF66390 = xmmword_1EEF66290;
            unk_1EEF663A0 = xmmword_1EEF662D0;
            xmmword_1EEF663B0 = (__int128)vnegq_f32((float32x4_t)xmmword_1EEF662B0);
            unk_1EEF663C0 = xmmword_1EEF662F0;
            xmmword_1EEF663D0 = xmmword_1EEF66290;
            unk_1EEF663E0 = xmmword_1EEF66350;
            xmmword_1EEF663F0 = xmmword_1EEF662B0;
            unk_1EEF66400 = xmmword_1EEF662F0;
            xmmword_1EEF66410 = xmmword_1EEF66330;
            unk_1EEF66420 = xmmword_1EEF662B0;
            xmmword_1EEF66430 = xmmword_1EEF66350;
            unk_1EEF66440 = xmmword_1EEF662F0;
            xmmword_1EEF66450 = xmmword_1EEF66290;
            unk_1EEF66460 = xmmword_1EEF662B0;
            xmmword_1EEF66470 = xmmword_1EEF662D0;
            unk_1EEF66480 = xmmword_1EEF662F0;
            __cxa_guard_release(&qword_1EEF66490);
          }
          v88 = sub_1B180C828(*(_QWORD *)(*(_QWORD *)(a1 + 408) + 8 * v46));
          v89 = (_OWORD *)sub_1B181E7E0(v88);
          v90 = 0;
          v91 = v64[577];
          v92 = v64[578];
          v93 = v64[579];
          v89[580] = v64[580];
          v89[579] = v93;
          v89[578] = v92;
          v89[577] = v91;
          v94 = &xmmword_1EEF66310[4 * v82];
          v95 = v94[1];
          v96 = v94[2];
          v97 = v94[3];
          v133[0] = *v94;
          v133[1] = v95;
          v133[2] = v96;
          v133[3] = v97;
          do
          {
            v134[v90] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v132, COERCE_FLOAT(v133[v90])), v131, *(float32x2_t *)&v133[v90], 1), v130, (float32x4_t)v133[v90], 2), v129, (float32x4_t)v133[v90], 3);
            ++v90;
          }
          while (v90 != 4);
          v98 = v134[1];
          v99 = v134[2];
          v100 = v134[3];
          v89[449] = v134[0];
          v89[450] = v98;
          v89[451] = v99;
          v89[452] = v100;
          ++v82;
          ++v46;
        }
        while (v82 != v128);
      }
      if (sub_1B186064C((uint64_t)v47, v75, v76, v77, v78, v79, v80, v81) == 2)
      {
        ++v46;
        if (v128 >= 2)
        {
          v101 = v64 + 453;
          v102 = v128 - 1;
          do
          {
            v103 = sub_1B180C828(*(_QWORD *)(*(_QWORD *)(a1 + 408) + 8 * v46));
            v104 = (_OWORD *)sub_1B181E7E0(v103);
            v105 = v101[128];
            v106 = v101[129];
            v107 = v101[130];
            v104[580] = v101[131];
            v104[579] = v107;
            v104[578] = v106;
            v104[577] = v105;
            v108 = *v101;
            v109 = v101[1];
            v110 = v101[2];
            v104[452] = v101[3];
            v104[451] = v110;
            v104[450] = v109;
            v104[449] = v108;
            ++v46;
            v101 += 4;
            --v102;
          }
          while (v102);
        }
      }
      ++v45;
    }
    while (v45 != v126);
  }
  v111 = *(unsigned int *)(a1 + 400);
  if ((_DWORD)v111)
  {
    v112 = *(uint64_t **)(a1 + 408);
    v113 = 8 * v111;
    do
    {
      v114 = (uint64_t *)sub_1B180C828(*v112);
      sub_1B1961820((uint64_t)v114);
      sub_1B196184C((uint64_t)v114, v115, v116, v117, v118, v119, v120, v121);
      sub_1B1961A30(v114, *(const char **)v124, *((_QWORD *)v124 + 1), v122);
      ++v112;
      v113 -= 8;
    }
    while (v113);
  }
  prof_endFlame();
}

void sub_1B190D45C(_Unwind_Exception *a1)
{
  prof_endFlame();
  _Unwind_Resume(a1);
}

void sub_1B190D49C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;

  v6 = sub_1B1815BE8(*(_QWORD *)(a1 + 368), a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Shadow", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/ShadowMapAtlasPass.mm", 185, v6 | 0x300000000);
  v9 = *(unsigned int *)(a1 + 400);
  if ((_DWORD)v9)
  {
    v10 = *(uint64_t **)(a1 + 408);
    v11 = 8 * v9;
    do
    {
      sub_1B182CE18(*v10++, a2, v7, v8);
      v11 -= 8;
    }
    while (v11);
  }
  prof_endFlame();
}

void sub_1B190D514(_Unwind_Exception *a1)
{
  prof_endFlame();
  _Unwind_Resume(a1);
}

void sub_1B190D524(unint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFDictionary *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  float v36;
  const char *v37;
  uint64_t v38;
  double v39;
  double v40;
  double v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  __int128 v47;
  uint64_t v48;

  v6 = a1;
  v7 = sub_1B1815BE8(*(_QWORD *)(a1 + 368), a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Shadow", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/ShadowMapAtlasPass.mm", 193, v7 | 0x300000000);
  v8 = *(unsigned int *)(v6 + 400);
  if ((_DWORD)v8)
  {
    v9 = *(uint64_t **)(v6 + 408);
    v10 = 8 * v8;
    do
    {
      v11 = *v9;
      v12 = sub_1B182CE10(*v9);
      v20 = sub_1B1868FE8(v12, v13, v14, v15, v16, v17, v18, v19);
      v35 = sub_1B18627C0((uint64_t)v20, v21, v22, v23, v24, v25, v26, v27);
      v36 = 2.0;
      if (v35)
      {
        objc_msgSend_setCullMode_(*(void **)a3, v28, 1, v30);
        v36 = 0.0;
        objc_msgSend_setLockCullMode_(*(void **)a3, v37, 1, v38);
      }
      v39 = sub_1B1860068((uint64_t)v20, (uint64_t)v28, v29, v30, v31, v32, v33, v34);
      *(float *)&v39 = v39;
      *(float *)&v39 = *(float *)&v39 * -10.0;
      *(float *)&v40 = -v36;
      LODWORD(v41) = 0;
      objc_msgSend_setDepthBias_slopeScale_clamp_(*(void **)a3, v42, v43, v44, v39, v40, v41);
      v48 = *(_QWORD *)(a3 + 16);
      v47 = *(_OWORD *)a3;
      v6 = v6 & 0xFFFFFFFFFFFF0000 | BYTE1(v48) | ((unint64_t)BYTE1(v48) << 8);
      sub_1B182D4E8(v11, a2, (uint64_t)&v47, v6);
      if (v35)
        objc_msgSend_setLockCullMode_(*(void **)a3, v45, 0, v46);
      ++v9;
      v10 -= 8;
    }
    while (v10);
  }
  prof_endFlame();
}

void sub_1B190D660(_Unwind_Exception *a1)
{
  prof_endFlame();
  _Unwind_Resume(a1);
}

uint64_t sub_1B190D680(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v20;
  uint64_t v21[2];
  __int16 v22;
  uint64_t *v23;

  v23 = a1;
  v10 = sub_1B1813884(a3, a2, a3, a4, a5, a6, a7, a8);
  v18 = sub_1B187B188(v10, v11, v12, v13, v14, v15, v16, v17);
  if (!sub_1B1798668(v18))
    return 0;
  v21[0] = (uint64_t)"Shadow map atlas";
  v21[1] = a3;
  v22 = 0;
  v20 = 0;
  return sub_1B190D6F0(a1, &v23, v21, &v20);
}

uint64_t sub_1B190D6F0(uint64_t *a1, uint64_t **a2, uint64_t *a3, int *a4)
{
  uint64_t v7;
  uint64_t v9[2];

  v7 = a1[1];
  v9[0] = *a1;
  v9[1] = v7;
  v9[0] = sub_1B190D80C(v9[0], v7, v9, a2, a3, a4);
  sub_1B179C734(a1 + 18, v9);
  return v9[0];
}

void sub_1B190D748(CFX::RG::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E63CF358;
  sub_1B190D7C4((uint64_t)a1 + 384);
  CFX::RG::Pass::~Pass(a1);
}

void sub_1B190D77C(CFX::RG::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E63CF358;
  sub_1B190D7C4((uint64_t)a1 + 384);
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B190D7C4(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v4;

  if (*(_DWORD *)(a1 + 20))
  {
    v4 = *(_QWORD *)(a1 + 24);
    v2 = *(_QWORD **)(a1 + 8);
    if (v2)
      sub_1B179C834(v2, &v4);
  }
  return a1;
}

uint64_t sub_1B190D80C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t **a4, uint64_t *a5, int *a6)
{
  uint64_t v10;
  _QWORD v12[2];

  v12[0] = a1;
  v12[1] = a2;
  v10 = sub_1B179C1C0(v12, 0x1B0u, 8u);
  return sub_1B190CB5C(v10, *a3, a3[1], *a4, a5, *a6);
}

uint64_t sub_1B190D870(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *v8;
  unsigned __int8 v9;
  CFX::RG::Resource *v10;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE v15[160];
  float v16[40];

  v8 = &qword_1EEF66000;
  v9 = atomic_load((unsigned __int8 *)&qword_1EEF664B0);
  if ((v9 & 1) == 0)
  {
    v13 = a2;
    v14 = a3;
    v12 = __cxa_guard_acquire(&qword_1EEF664B0);
    v8 = &qword_1EEF66000;
    a2 = v13;
    a3 = v14;
    if (v12)
    {
      qword_1EEF664A8 = (uint64_t)sub_1B190F014("DOF_DOWNSAMPLE_COLOR_COC_PASS", 0x1Du);
      __cxa_guard_release(&qword_1EEF664B0);
      v8 = &qword_1EEF66000;
      a2 = v13;
      a3 = v14;
    }
  }
  sub_1B18F7354(a1, a2, a3, a5, v8[149], 0);
  *(_QWORD *)a1 = &off_1E63CFAC8;
  memcpy((void *)(a1 + 376), a5 + 2, 0x150uLL);
  *(_QWORD *)(a1 + 720) = 0;
  *(_QWORD *)(a1 + 736) = 0;
  *(_QWORD *)(a1 + 728) = 0;
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 384), MTLPixelFormatRGBA16Float, (uint64_t)v15);
  CFX::RG::TextureDescriptorReference::applyingSizeFactor((CFX::RG::TextureDescriptorReference *)v15, 1.0 / (float)*(unsigned int *)(a1 + 704), v16);
  v10 = sub_1B17A34D0(a4, (uint64_t)"DOF_DOWNSAMPLE_COLOR_COC", v16);
  *(_QWORD *)(a1 + 736) = v10;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v10);
  return a1;
}

void sub_1B190D994(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B190D9AC(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  id v26;

  v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ *(unsigned int *)(a1 + 704));
  v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  v7 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
  *(_QWORD *)(a1 + 712) = v7;
  if (!v7)
  {
    *(_QWORD *)(a1 + 712) = sub_1B190DAB8(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
    v15 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 368), v8, v9, v10, v11, v12, v13, v14);
    v19 = (void *)objc_msgSend_resourceManager(v15, v16, v17, v18);
    v26 = objc_alloc_init(MEMORY[0x1E0CC6AA0]);
    objc_msgSend_setConstantValue_type_withName_(v26, v20, a1 + 704, 29, CFSTR("dof_downsample_rate"));
    v21 = *(_QWORD *)(a1 + 712);
    v23 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(v19, v22, (uint64_t)CFSTR("dof_downsample_color_coc"), (uint64_t)v26);
    v24 = *(void **)(v21 + 16);
    if (v24 != (void *)v23)
    {
      v25 = v23;
      if (v24)

      *(_QWORD *)(v21 + 16) = v25;
    }

  }
}

_QWORD *sub_1B190DAB8(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v4)
  {
    v4 = (_QWORD *)operator new();
    v4[1] = 0;
    v4[2] = 0;
    *v4 = &off_1E63CFAA8;
    CFX::CrossFrameResourceManager::set((uint64_t)a1, a2, (uint64_t)v4);
  }
  return v4;
}

void *sub_1B190DB2C(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v10;
  void *result;
  uint64_t v12;
  id Texture;
  id v14;
  id v15;
  const char *v16;
  const char *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  float v43;
  float v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  float v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  const char *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  const char *v80;
  float v81;
  float v82;
  uint64_t v83;
  float v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  const char *v94;
  uint64_t v95;
  __int128 v96;

  v10 = *a3;
  result = *(void **)(a1 + 376);
  if (result || (result = (void *)sub_1B1814768(*(uint64_t **)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8)) != 0)
  {
    result = sub_1B186CFA8((uint64_t)result, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    if (result)
    {
      v12 = (uint64_t)result;
      Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 720));
      v14 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 728));
      v15 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 736));
      objc_msgSend_setTexture_atIndex_(v10, v16, (uint64_t)Texture, 0);
      objc_msgSend_setTexture_atIndex_(v10, v17, (uint64_t)v14, 1);
      objc_msgSend_setTexture_atIndex_(v10, v18, (uint64_t)v15, 2);
      v96 = xmmword_1B2244EC0;
      v26 = sub_1B1865B64(v12, v19, v20, v21, v22, v23, v24, v25) / 1000.0;
      v27 = v26 + 0.01;
      v42 = sub_1B1865DD8(v12, v28, v29, v30, v31, v32, v33, v34);
      if (v27 >= v42)
        v43 = v27;
      else
        v43 = v42;
      v44 = sub_1B1866048(v12, v35, v36, v37, v38, v39, v40, v41) / 1000.0;
      v52 = sub_1B18660E0(v12, v45, v46, v47, v48, v49, v50, v51) / 1000.0;
      v60 = sub_1B1866E38(v12, v53, v54, v55, v56, v57, v58, v59);
      v64 = objc_msgSend_width(v15, v61, v62, v63);
      v68 = objc_msgSend_height(v15, v65, v66, v67);
      if (sub_1B18662A8((unsigned __int8 *)v60, (float)(v64 / v68), v69, v70, v71, v72, v73, v74, v75))
        v79 = objc_msgSend_width(v15, v76, v77, v78);
      else
        v79 = objc_msgSend_height(v15, v76, v77, v78);
      v81 = (float)(v26 * (float)(v44 * (float)((float)(unint64_t)v79 / v52))) / (float)(v43 - v26);
      v82 = *(float *)(v60 + 8);
      *(float *)&v83 = (float)((float)(v82 - *(float *)(v60 + 4)) * (float)-(float)(v81 * v43))
                     / (float)(v82 * *(float *)(v60 + 4));
      v84 = (1.0 - (float)(v43 / v82)) * v81;
      *((float *)&v83 + 1) = v84;
      v95 = v83;
      objc_msgSend_setBytes_length_atIndex_(v10, v80, (uint64_t)&v95, 32, 0);
      v91 = *(_QWORD *)(a1 + 712);
      v92 = *(_QWORD *)(v91 + 16);
      if (!v92)
      {
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v85, v86, v87, v88, v89, v90, (uint64_t)"_ptr != NULL");
        v92 = *(_QWORD *)(v91 + 16);
      }
      v93 = sub_1B18FD774(v92);
      return (void *)objc_msgSend_dispatch_onTexture2D_(v10, v94, v93, (uint64_t)v15);
    }
  }
  return result;
}

uint64_t sub_1B190DD48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *v8;
  unsigned __int8 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  CFX::RG::Resource *v18;
  int v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE v23[160];
  float v24[40];

  v8 = &qword_1EEF66000;
  v9 = atomic_load((unsigned __int8 *)&qword_1EEF664C0);
  if ((v9 & 1) == 0)
  {
    v21 = a2;
    v22 = a3;
    v20 = __cxa_guard_acquire(&qword_1EEF664C0);
    v8 = &qword_1EEF66000;
    a2 = v21;
    a3 = v22;
    if (v20)
    {
      qword_1EEF664B8 = (uint64_t)sub_1B190F014("DOF_DOWNSAMPLE_SORT_COC_PASS", 0x1Cu);
      __cxa_guard_release(&qword_1EEF664C0);
      v8 = &qword_1EEF66000;
      a2 = v21;
      a3 = v22;
    }
  }
  sub_1B18F7354(a1, a2, a3, (uint64_t *)a5, v8[151], 0);
  *(_QWORD *)a1 = &off_1E63CFA58;
  v10 = *(_OWORD *)(a5 + 16);
  v11 = *(_OWORD *)(a5 + 48);
  *(_OWORD *)(a1 + 392) = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 408) = v11;
  *(_OWORD *)(a1 + 376) = v10;
  v12 = *(_OWORD *)(a5 + 64);
  v13 = *(_OWORD *)(a5 + 80);
  v14 = *(_OWORD *)(a5 + 112);
  *(_OWORD *)(a1 + 456) = *(_OWORD *)(a5 + 96);
  *(_OWORD *)(a1 + 472) = v14;
  *(_OWORD *)(a1 + 424) = v12;
  *(_OWORD *)(a1 + 440) = v13;
  v15 = *(_OWORD *)(a5 + 128);
  v16 = *(_OWORD *)(a5 + 144);
  v17 = *(_OWORD *)(a5 + 160);
  *(_QWORD *)(a1 + 536) = *(_QWORD *)(a5 + 176);
  *(_OWORD *)(a1 + 504) = v16;
  *(_OWORD *)(a1 + 520) = v17;
  *(_OWORD *)(a1 + 488) = v15;
  *(_OWORD *)(a1 + 552) = 0u;
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 376), MTLPixelFormatRG16Float, (uint64_t)v23);
  CFX::RG::TextureDescriptorReference::applyingSizeFactor((CFX::RG::TextureDescriptorReference *)v23, 1.0 / (float)(4 * *(_DWORD *)(a1 + 536)), v24);
  v18 = sub_1B17A34D0(a4, (uint64_t)"DOF_COC_DOWNSAMPLE", v24);
  *(_QWORD *)(a1 + 560) = v18;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v18);
  return a1;
}

void sub_1B190DE98(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B190DEB0(uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;

  v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v5 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
  a1[68] = v5;
  if (!v5)
  {
    a1[68] = (uint64_t)sub_1B190DF3C(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
    v13 = (void *)sub_1B1813BC4(a1[46], v6, v7, v8, v9, v10, v11, v12);
    v17 = (void *)objc_msgSend_resourceManager(v13, v14, v15, v16);
    v18 = a1[68];
    v21 = objc_msgSend_newComputePipelineStateWithFunctionName_(v17, v19, (uint64_t)CFSTR("dof_coc_downsample_sort"), v20);
    v22 = *(void **)(v18 + 16);
    if (v22 != (void *)v21)
    {
      v23 = v21;
      if (v22)

      *(_QWORD *)(v18 + 16) = v23;
    }
  }
}

_QWORD *sub_1B190DF3C(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v4)
  {
    v4 = (_QWORD *)operator new();
    v4[1] = 0;
    v4[2] = 0;
    *v4 = &off_1E63CFA38;
    CFX::CrossFrameResourceManager::set((uint64_t)a1, a2, (uint64_t)v4);
  }
  return v4;
}

uint64_t sub_1B190DFB0(uint64_t a1, uint64_t a2, void **a3)
{
  void *v5;
  id Texture;
  id v7;
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;

  v5 = *a3;
  Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 552));
  v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 560));
  objc_msgSend_setTexture_atIndex_(v5, v8, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)v7, 1);
  v16 = *(_QWORD *)(a1 + 544);
  v17 = *(_QWORD *)(v16 + 16);
  if (!v17)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v10, v11, v12, v13, v14, v15, (uint64_t)"_ptr != NULL");
    v17 = *(_QWORD *)(v16 + 16);
  }
  v18 = sub_1B18FD774(v17);
  return objc_msgSend_dispatch_onTexture2D_(v5, v19, v18, (uint64_t)v7);
}

uint64_t sub_1B190E060(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *v9;
  unsigned __int8 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  char *v20;
  char v21;
  CFX::RG::Resource *v22;
  int v24;
  uint64_t v25;
  _OWORD v26[10];
  float v27[40];

  v9 = &qword_1EEF66000;
  v10 = atomic_load((unsigned __int8 *)&qword_1EEF664D0);
  if ((v10 & 1) == 0)
  {
    v25 = a2;
    v24 = __cxa_guard_acquire(&qword_1EEF664D0);
    v9 = &qword_1EEF66000;
    a2 = v25;
    if (v24)
    {
      byte_1EEF664C8 = 1;
      __cxa_guard_release(&qword_1EEF664D0);
      v9 = &qword_1EEF66000;
      a2 = v25;
    }
  }
  if (*((_BYTE *)v9 + 1224))
    v11 = 0xD94882481E2E3EC6;
  else
    v11 = 0;
  sub_1B18F7354(a1, a2, a3, (uint64_t *)a5, v11, 0);
  *(_QWORD *)a1 = &off_1E63CEB80;
  v12 = *(_OWORD *)(a5 + 16);
  v13 = *(_OWORD *)(a5 + 48);
  *(_OWORD *)(a1 + 392) = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 408) = v13;
  *(_OWORD *)(a1 + 376) = v12;
  v14 = *(_OWORD *)(a5 + 64);
  v15 = *(_OWORD *)(a5 + 80);
  v16 = *(_OWORD *)(a5 + 112);
  *(_OWORD *)(a1 + 456) = *(_OWORD *)(a5 + 96);
  *(_OWORD *)(a1 + 472) = v16;
  *(_OWORD *)(a1 + 424) = v14;
  *(_OWORD *)(a1 + 440) = v15;
  v17 = *(_OWORD *)(a5 + 128);
  v18 = *(_OWORD *)(a5 + 144);
  v19 = *(_OWORD *)(a5 + 160);
  *(_QWORD *)(a1 + 536) = *(_QWORD *)(a5 + 176);
  *(_OWORD *)(a1 + 504) = v18;
  *(_OWORD *)(a1 + 520) = v19;
  *(_OWORD *)(a1 + 488) = v17;
  *(_OWORD *)(a1 + 552) = 0u;
  v26[0] = *(_OWORD *)(a1 + 8);
  v20 = (char *)sub_1B179C1C0(v26, 0x16u, 1u);
  strlcpy(v20, "DOF_COC_BLUR_OUTPUT_", 0x15uLL);
  if (*(_BYTE *)(a1 + 540))
    v21 = 89;
  else
    v21 = 88;
  v20[20] = v21;
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 376), MTLPixelFormatRG16Float, (uint64_t)v26);
  CFX::RG::TextureDescriptorReference::applyingSizeFactor((CFX::RG::TextureDescriptorReference *)v26, 1.0 / (float)(4 * *(_DWORD *)(a1 + 536)), v27);
  v22 = sub_1B17A34D0(a4, (uint64_t)v20, v27);
  *(_QWORD *)(a1 + 560) = v22;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v22);
  return a1;
}

void sub_1B190E20C(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B190E228(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  id v26;

  v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ *(unsigned __int8 *)(a1 + 540));
  v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  v7 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
  *(_QWORD *)(a1 + 544) = v7;
  if (!v7)
  {
    *(_QWORD *)(a1 + 544) = sub_1B190E334(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
    v15 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 368), v8, v9, v10, v11, v12, v13, v14);
    v19 = (void *)objc_msgSend_resourceManager(v15, v16, v17, v18);
    v26 = objc_alloc_init(MEMORY[0x1E0CC6AA0]);
    objc_msgSend_setConstantValue_type_withName_(v26, v20, a1 + 540, 53, CFSTR("dof_blur_vertical"));
    v21 = *(_QWORD *)(a1 + 544);
    v23 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(v19, v22, (uint64_t)CFSTR("dof_coc_blur"), (uint64_t)v26);
    v24 = *(void **)(v21 + 16);
    if (v24 != (void *)v23)
    {
      v25 = v23;
      if (v24)

      *(_QWORD *)(v21 + 16) = v25;
    }

  }
}

_QWORD *sub_1B190E334(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v4)
  {
    v4 = (_QWORD *)operator new();
    v4[1] = 0;
    v4[2] = 0;
    *v4 = &off_1E63CEB60;
    CFX::CrossFrameResourceManager::set((uint64_t)a1, a2, (uint64_t)v4);
  }
  return v4;
}

uint64_t sub_1B190E3A8(uint64_t a1, uint64_t a2, void **a3)
{
  void *v5;
  id Texture;
  id v7;
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;

  v5 = *a3;
  Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 552));
  v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 560));
  objc_msgSend_setTexture_atIndex_(v5, v8, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)v7, 1);
  v16 = *(_QWORD *)(a1 + 544);
  v17 = *(_QWORD *)(v16 + 16);
  if (!v17)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v10, v11, v12, v13, v14, v15, (uint64_t)"_ptr != NULL");
    v17 = *(_QWORD *)(v16 + 16);
  }
  v18 = sub_1B18FD774(v17);
  return objc_msgSend_dispatch_onTexture2D_(v5, v19, v18, (uint64_t)v7);
}

uint64_t sub_1B190E458(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *v8;
  unsigned __int8 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  CFX::RG::Resource *v18;
  int v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE v23[160];
  float v24[40];

  v8 = &qword_1EEF66000;
  v9 = atomic_load((unsigned __int8 *)&qword_1EEF664E0);
  if ((v9 & 1) == 0)
  {
    v21 = a2;
    v22 = a3;
    v20 = __cxa_guard_acquire(&qword_1EEF664E0);
    v8 = &qword_1EEF66000;
    a2 = v21;
    a3 = v22;
    if (v20)
    {
      qword_1EEF664D8 = (uint64_t)sub_1B190F014("DOF_FINAL_PASS", 0xEu);
      __cxa_guard_release(&qword_1EEF664E0);
      v8 = &qword_1EEF66000;
      a2 = v21;
      a3 = v22;
    }
  }
  sub_1B18F7354(a1, a2, a3, (uint64_t *)a5, v8[155], 0);
  *(_QWORD *)a1 = &off_1E63CE788;
  v10 = *(_OWORD *)(a5 + 16);
  v11 = *(_OWORD *)(a5 + 48);
  *(_OWORD *)(a1 + 392) = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 408) = v11;
  *(_OWORD *)(a1 + 376) = v10;
  v12 = *(_OWORD *)(a5 + 64);
  v13 = *(_OWORD *)(a5 + 80);
  v14 = *(_OWORD *)(a5 + 112);
  *(_OWORD *)(a1 + 456) = *(_OWORD *)(a5 + 96);
  *(_OWORD *)(a1 + 472) = v14;
  *(_OWORD *)(a1 + 424) = v12;
  *(_OWORD *)(a1 + 440) = v13;
  v15 = *(_OWORD *)(a5 + 128);
  v16 = *(_OWORD *)(a5 + 144);
  v17 = *(_OWORD *)(a5 + 176);
  *(_OWORD *)(a1 + 520) = *(_OWORD *)(a5 + 160);
  *(_OWORD *)(a1 + 536) = v17;
  *(_OWORD *)(a1 + 488) = v15;
  *(_OWORD *)(a1 + 504) = v16;
  *(_QWORD *)(a1 + 576) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 376), MTLPixelFormatRGBA16Float, (uint64_t)v23);
  CFX::RG::TextureDescriptorReference::applyingSizeFactor((CFX::RG::TextureDescriptorReference *)v23, 1.0 / (float)*(unsigned int *)(a1 + 536), v24);
  v18 = sub_1B17A34D0(a4, (uint64_t)"DOF_FINAL", v24);
  *(_QWORD *)(a1 + 576) = v18;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v18);
  return a1;
}

void sub_1B190E59C(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B190E5B4(uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  const char *v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  float v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  const char *v62;
  uint64_t v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  const char *v73;
  const char *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  void *v81;
  uint64_t v82;
  _QWORD v83[3];
  int64x2_t v84;
  uint64_t v85;
  _DWORD v86[6];
  uint64_t v87;

  v87 = *MEMORY[0x1E0C80C00];
  v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v12 = sub_1B18E8D70(a1[68], v5, v6, v7, v8, v9, v10, v11);
  v20 = sub_1B18E8D70(a1[68], v13, v14, v15, v16, v17, v18, v19);
  v21 = v20;
  v22 = 0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v12 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v12 ^ v4)));
  v23 = 0x9DDFEA08EB382D69 * (v22 ^ (v22 >> 47));
  v24 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v23 ^ ((0x9DDFEA08EB382D69 * (v23 ^ v20)) >> 47) ^ (0x9DDFEA08EB382D69 * (v23 ^ v20)))) ^ ((0x9DDFEA08EB382D69 * (v23 ^ ((0x9DDFEA08EB382D69 * (v23 ^ v20)) >> 47) ^ (0x9DDFEA08EB382D69 * (v23 ^ v20)))) >> 47));
  v25 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v24);
  a1[69] = v25;
  if (!v25)
  {
    a1[69] = sub_1B190E808(*(CFX::CrossFrameResourceManager **)(a2 + 32), v24);
    v33 = (void *)sub_1B1813BC4(a1[46], v26, v27, v28, v29, v30, v31, v32);
    v37 = (void *)objc_msgSend_resourceManager(v33, v34, v35, v36);
    v38 = a1[69];
    v42 = (void *)objc_msgSend_device(v33, v39, v40, v41);
    v44 = objc_msgSend_newBufferWithLength_options_(v42, v43, 512, 32);
    v47 = *(void **)(v38 + 24);
    if (v47 != (void *)v44)
    {
      v48 = v44;
      if (v47)

      *(_QWORD *)(v38 + 24) = v48;
    }
    v49 = fmin((double)(unint64_t)v12, 64.0);
    v50 = sqrtf(v49);
    v51 = (void *)objc_msgSend_newComputePipelineStateWithFunctionName_(v37, v45, (uint64_t)CFSTR("dof_compute_kernel_parallel"), v46);
    v52 = a1[69];
    *(_DWORD *)(v52 + 32) = v50;
    *(_DWORD *)(v52 + 36) = v21;
    v86[0] = v21;
    v86[1] = v50;
    v56 = (void *)objc_msgSend_currentCommandBuffer(v33, v53, v54, v55);
    v60 = (void *)objc_msgSend_computeCommandEncoder(v56, v57, v58, v59);
    v61 = sub_1B18FD774((uint64_t)v51);
    objc_msgSend_setComputePipelineState_(v60, v62, v61, v63);
    v70 = a1[69];
    v71 = *(_QWORD *)(v70 + 24);
    if (!v71)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), 0, v65, v66, v67, v68, v69, (uint64_t)"_ptr != NULL");
      v71 = *(_QWORD *)(v70 + 24);
    }
    objc_msgSend_setBuffer_offset_atIndex_(v60, v64, v71, 0, 0);
    objc_msgSend_setBytes_length_atIndex_(v60, v72, (uint64_t)v86, 16, 1);
    v84 = vdupq_n_s64(1uLL);
    v85 = 1;
    v83[0] = v50;
    v83[1] = v50;
    v83[2] = 1;
    objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(v60, v73, (uint64_t)&v84, (uint64_t)v83);
    objc_msgSend_endEncoding(v60, v74, v75, v76);

    v77 = a1[69];
    v80 = objc_msgSend_newComputePipelineStateWithFunctionName_(v37, v78, (uint64_t)CFSTR("dof_blur2"), v79);
    v81 = *(void **)(v77 + 16);
    if (v81 != (void *)v80)
    {
      v82 = v80;
      if (v81)

      *(_QWORD *)(v77 + 16) = v82;
    }
  }
}

uint64_t sub_1B190E808(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v4)
  {
    v4 = operator new();
    *(_OWORD *)v4 = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    *(_QWORD *)(v4 + 24) = 0;
    *(_QWORD *)(v4 + 32) = 0;
    *(_QWORD *)v4 = &off_1E63CE768;
    *(_QWORD *)(v4 + 16) = 0;
    CFX::CrossFrameResourceManager::set((uint64_t)a1, a2, v4);
  }
  return v4;
}

uint64_t sub_1B190E888(uint64_t a1, uint64_t a2, void **a3)
{
  void *v5;
  id Texture;
  id v7;
  id v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  int v32[6];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 560));
  v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 568));
  v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 576));
  objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v5, v10, (uint64_t)v7, 1);
  objc_msgSend_setTexture_atIndex_(v5, v11, (uint64_t)v8, 2);
  v32[0] = *(_DWORD *)(*(_QWORD *)(a1 + 552) + 32) * *(_DWORD *)(*(_QWORD *)(a1 + 552) + 32);
  objc_msgSend_setBytes_length_atIndex_(v5, v12, (uint64_t)v32, 16, 0);
  v19 = *(_QWORD *)(a1 + 552);
  v20 = *(_QWORD *)(v19 + 24);
  if (!v20)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), 0, v14, v15, v16, v17, v18, (uint64_t)"_ptr != NULL");
    v20 = *(_QWORD *)(v19 + 24);
  }
  objc_msgSend_setBuffer_offset_atIndex_(v5, v13, v20, 0, 1);
  v27 = *(_QWORD *)(a1 + 552);
  v28 = *(_QWORD *)(v27 + 16);
  if (!v28)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v21, v22, v23, v24, v25, v26, (uint64_t)"_ptr != NULL");
    v28 = *(_QWORD *)(v27 + 16);
  }
  v29 = sub_1B18FD774(v28);
  return objc_msgSend_dispatch_onTexture2D_(v5, v30, v29, (uint64_t)v8);
}

uint64_t *sub_1B190E9F0(uint64_t *a1, uint64_t a2, CFX::RG::Resource *a3, CFX::RG::Resource *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _OWORD *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t *v29;
  const char *v30;
  CFX::RG::Resource *v31;
  const char *v32;
  CFX::RG::Resource *v33;
  uint64_t v34;
  uint64_t *v35;
  CFX::RG::Resource *v36;
  uint64_t v37;
  uint64_t *v38;
  CFX::RG::Resource *v39;
  uint64_t v40;
  uint64_t *v41;
  CFX::RG::Resource *v42;
  uint64_t v43;
  uint64_t *v44;
  CFX::RG::Resource *v45;
  CFX::RG::Resource *v46;
  _QWORD v48[2];
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  int v59;
  uint64_t v60;
  _QWORD v61[2];
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  int v72;
  char v73;
  _QWORD v74[2];
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  int v85;
  char v86;
  _QWORD v87[2];
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  int v98;
  uint64_t v99[3];
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  int v120;
  _OWORD v121[10];
  _OWORD v122[10];
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  _OWORD v133[10];

  if (!*(_QWORD *)(a2 + 32))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"scopeParameters.dofEffect");
  v12 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*(CFX::RG::Resource **)(a2 + 8));
  v13 = v12[1];
  v133[0] = *v12;
  v133[1] = v13;
  v14 = v12[5];
  v16 = v12[2];
  v15 = v12[3];
  v133[4] = v12[4];
  v133[5] = v14;
  v133[2] = v16;
  v133[3] = v15;
  v17 = v12[9];
  v19 = v12[6];
  v18 = v12[7];
  v133[8] = v12[8];
  v133[9] = v17;
  v133[6] = v19;
  v133[7] = v18;
  CFX::RG::TextureDescriptorReference::withSampleCount(v133, 1, (uint64_t)&v123);
  v20 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*(CFX::RG::Resource **)(a2 + 16));
  v21 = v20[1];
  v122[0] = *v20;
  v122[1] = v21;
  v22 = v20[5];
  v24 = v20[2];
  v23 = v20[3];
  v122[4] = v20[4];
  v122[5] = v22;
  v122[2] = v24;
  v122[3] = v23;
  v25 = v20[9];
  v27 = v20[6];
  v26 = v20[7];
  v122[8] = v20[8];
  v122[9] = v25;
  v122[6] = v27;
  v122[7] = v26;
  CFX::RG::TextureDescriptorReference::withSampleCount(v122, 1, (uint64_t)v121);
  v106 = v129;
  v107 = v130;
  v108 = v131;
  v109 = v132;
  v102 = v125;
  v103 = v126;
  v104 = v127;
  v105 = v128;
  v100 = v123;
  v101 = v124;
  v116 = v121[6];
  v117 = v121[7];
  v118 = v121[8];
  v119 = v121[9];
  v115 = v121[5];
  v112 = v121[2];
  v113 = v121[3];
  v114 = v121[4];
  v110 = v121[0];
  v28 = *(_QWORD *)a2;
  v99[0] = (uint64_t)"DOF downsample color CoC";
  v99[1] = v28;
  v99[2] = *(_QWORD *)(a2 + 24);
  v111 = v121[1];
  v120 = 4;
  v29 = (uint64_t *)sub_1B190EE24(a1, a1, v99);
  v31 = (CFX::RG::Resource *)CFX::RG::copyIfNeeded((CFX::RG *)a1, *(CFX::RG::RenderGraphBuilder **)(a2 + 8), a3, (CFX::RG::Pass *)&v123, 0, v30);
  v29[90] = (uint64_t)v31;
  CFX::RG::Pass::readFrom(v29, v31);
  if (a3)
    CFX::RG::Pass::dependsOn(v29, a3);
  v33 = (CFX::RG::Resource *)CFX::RG::copyIfNeeded((CFX::RG *)a1, *(CFX::RG::RenderGraphBuilder **)(a2 + 16), a4, (CFX::RG::Pass *)v121, 0, v32);
  v29[91] = (uint64_t)v33;
  CFX::RG::Pass::readFrom(v29, v33);
  if (a4)
    CFX::RG::Pass::dependsOn(v29, a4);
  v34 = *(_QWORD *)a2;
  v87[0] = "DOF downsample CoC";
  v87[1] = v34;
  v94 = v129;
  v95 = v130;
  v96 = v131;
  v97 = v132;
  v90 = v125;
  v91 = v126;
  v92 = v127;
  v93 = v128;
  v88 = v123;
  v89 = v124;
  v98 = 4;
  v35 = (uint64_t *)sub_1B190EE78(a1, a1, (uint64_t)v87);
  v36 = (CFX::RG::Resource *)v29[92];
  v35[69] = (uint64_t)v36;
  CFX::RG::Pass::readFrom(v35, v36);
  v37 = *(_QWORD *)a2;
  v74[0] = "DOF blur CoC X";
  v74[1] = v37;
  v81 = v129;
  v82 = v130;
  v83 = v131;
  v84 = v132;
  v77 = v125;
  v78 = v126;
  v79 = v127;
  v80 = v128;
  v75 = v123;
  v76 = v124;
  v85 = 4;
  v86 = 0;
  v38 = (uint64_t *)sub_1B190EECC(a1, a1, (uint64_t)v74);
  v39 = (CFX::RG::Resource *)v35[70];
  v38[69] = (uint64_t)v39;
  CFX::RG::Pass::readFrom(v38, v39);
  v40 = *(_QWORD *)a2;
  v61[0] = "DOF blur CoC Y";
  v61[1] = v40;
  v68 = v129;
  v69 = v130;
  v70 = v131;
  v71 = v132;
  v64 = v125;
  v65 = v126;
  v66 = v127;
  v67 = v128;
  v62 = v123;
  v63 = v124;
  v72 = 4;
  v73 = 1;
  v41 = (uint64_t *)sub_1B190EECC(a1, a1, (uint64_t)v61);
  v42 = (CFX::RG::Resource *)v38[70];
  v41[69] = (uint64_t)v42;
  CFX::RG::Pass::readFrom(v41, v42);
  v43 = *(_QWORD *)a2;
  v48[0] = "DOF final";
  v48[1] = v43;
  v55 = v129;
  v56 = v130;
  v57 = v131;
  v58 = v132;
  v51 = v125;
  v52 = v126;
  v53 = v127;
  v54 = v128;
  v49 = v123;
  v50 = v124;
  v59 = 4;
  v60 = *(_QWORD *)(a2 + 32);
  v44 = (uint64_t *)sub_1B190EF20(a1, a1, (uint64_t)v48);
  v45 = (CFX::RG::Resource *)v29[92];
  v44[70] = (uint64_t)v45;
  CFX::RG::Pass::readFrom(v44, v45);
  v46 = (CFX::RG::Resource *)v41[70];
  v44[71] = (uint64_t)v46;
  CFX::RG::Pass::readFrom(v44, v46);
  return v44;
}

uint64_t sub_1B190EE24(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B190F2F4(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B190EE78(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B190F350(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B190EECC(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B190F3AC(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B190EF20(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B190F408(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

void sub_1B190EF78(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

void sub_1B190EFA0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

void sub_1B190EFC8(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

void sub_1B190EFF0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

unsigned __int8 *sub_1B190F014(unsigned __int8 *result, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      v3 = a2 >> 3;
      v4 = &result[8 * v3];
      v5 = 8 * v3;
      do
      {
        v6 = *(_QWORD *)result;
        result += 8;
        v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

_QWORD *sub_1B190F0DC(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E63CFAA8;
  v2 = (void *)a1[2];
  if (v2)

  return a1;
}

void sub_1B190F114(_QWORD *a1)
{
  void *v1;

  *a1 = &off_1E63CFAA8;
  v1 = (void *)a1[2];
  if (v1)

  JUMPOUT(0x1B5E22E18);
}

_QWORD *sub_1B190F15C(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E63CFA38;
  v2 = (void *)a1[2];
  if (v2)

  return a1;
}

void sub_1B190F194(_QWORD *a1)
{
  void *v1;

  *a1 = &off_1E63CFA38;
  v1 = (void *)a1[2];
  if (v1)

  JUMPOUT(0x1B5E22E18);
}

_QWORD *sub_1B190F1DC(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E63CEB60;
  v2 = (void *)a1[2];
  if (v2)

  return a1;
}

void sub_1B190F214(_QWORD *a1)
{
  void *v1;

  *a1 = &off_1E63CEB60;
  v1 = (void *)a1[2];
  if (v1)

  JUMPOUT(0x1B5E22E18);
}

_QWORD *sub_1B190F25C(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_1E63CE768;
  v2 = (void *)a1[3];
  if (v2)

  v3 = (void *)a1[2];
  if (v3)

  return a1;
}

void sub_1B190F2A0(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_1E63CE768;
  v2 = (void *)a1[3];
  if (v2)

  v3 = (void *)a1[2];
  if (v3)

  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B190F2F4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x2E8u, 8u);
  return sub_1B190D870(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B190F350(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x238u, 8u);
  return sub_1B190DD48(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B190F3AC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x238u, 8u);
  return sub_1B190E060(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B190F408(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x248u, 8u);
  return sub_1B190E458(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B190F464(uint64_t result)
{
  _QWORD *v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (result)
  {
    v1 = (_QWORD *)result;
    v2 = *(_DWORD *)(result + 8);
    if (v2 == 21)
    {
      v7 = *(_QWORD *)(result + 80);
      if (!v7)
        return (*(uint64_t (**)(_QWORD *))(*v1 + 8))(v1);
    }
    else
    {
      if (v2 != 22)
      {
        if (v2 == 31)
        {
          v3 = *(unsigned int *)(result + 28);
          if ((int)v3 >= 1)
          {
            v4 = 0;
            v5 = 96 * v3;
            do
            {
              v6 = v1[5] + v4;
              if ((*(_BYTE *)(v6 + 88) & 1) != 0)
                sub_1B190F464(*(_QWORD *)(v6 + 64));
              v4 += 96;
            }
            while (v5 != v4);
          }
        }
        return (*(uint64_t (**)(_QWORD *))(*v1 + 8))(v1);
      }
      v7 = *(_QWORD *)(*(_QWORD *)(result + 48) + 80);
      if (!v7)
        return (*(uint64_t (**)(_QWORD *))(*v1 + 8))(v1);
    }
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    return (*(uint64_t (**)(_QWORD *))(*v1 + 8))(v1);
  }
  return result;
}

uint64_t sub_1B190F7F0(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  return objc_msgSend_cleanCollisionCache(a3, a2, (uint64_t)a3, a4);
}

id sub_1B190FA20(_QWORD *a1, uint64_t a2)
{
  VFXBtShapeWrapper *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;

  v4 = [VFXBtShapeWrapper alloc];
  v5 = sub_1B1910D80(a1, a2);
  return (id)objc_msgSend_initWithShape_(v4, v6, v5, v7);
}

id sub_1B190FA70(void *a1, uint64_t a2, int a3)
{
  uint64_t v5;
  int v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  VFXBtShapeWrapper *v19;
  const char *v20;
  uint64_t v21;
  void *v22;
  VFXBtShapeWrapper *v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34[4];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  _DWORD *v40;
  _QWORD v41[5];
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  int v45;

  if (!a3)
    goto LABEL_5;
  v42 = 0;
  v43 = &v42;
  v44 = 0x2020000000;
  v5 = MEMORY[0x1E0C809B0];
  v45 = 0;
  v41[0] = MEMORY[0x1E0C809B0];
  v41[1] = 3221225472;
  v41[2] = sub_1B1910C04;
  v41[3] = &unk_1E63D9420;
  v41[4] = &v42;
  sub_1B186B018((uint64_t)a1, (uint64_t)v41);
  v6 = *((_DWORD *)v43 + 6);
  _Block_object_dispose(&v42, 8);
  if (v6 < 2)
  {
LABEL_5:
    v23 = [VFXBtShapeWrapper alloc];
    v24 = sub_1B19109F8(a1, a2);
    v22 = (void *)objc_msgSend_initWithShape_(v23, v25, v24, v26);
    return v22;
  }
  v7 = (_DWORD *)sub_1B21FF5F0(128, 16);
  sub_1B21DF788(v7, 1);
  *(double *)&v15 = sub_1B186B90C((uint64_t)a1, v8, v9, v10, v11, v12, v13, v14);
  v34[0] = v5;
  v34[1] = 3221225472;
  v34[2] = (uint64_t)sub_1B1910C58;
  v34[3] = (uint64_t)&unk_1E63D9440;
  v35 = v15;
  v36 = v16;
  v37 = v17;
  v38 = v18;
  v39 = a2;
  v40 = v7;
  sub_1B186B018((uint64_t)a1, (uint64_t)v34);
  if (v7[7])
  {
    sub_1B21E0074((uint64_t)v7);
    v19 = [VFXBtShapeWrapper alloc];
    v22 = (void *)objc_msgSend_initWithShape_(v19, v20, (uint64_t)v7, v21);
    return v22;
  }
  (*(void (**)(_DWORD *))(*(_QWORD *)v7 + 8))(v7);
  sub_1B17C4408(16, (uint64_t)CFSTR("Error: Compound shapes cannot be created without shapes"), v28, v29, v30, v31, v32, v33, v34[0]);
  return 0;
}

void sub_1B190FBF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B21FF5FC(v1);
  _Unwind_Resume(a1);
}

id sub_1B190FC18(void *a1, uint64_t a2)
{
  _DWORD *v4;
  const char *v5;
  uint64_t v6;
  VFXBtShapeWrapper *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17[6];

  v4 = (_DWORD *)sub_1B21FF5F0(128, 16);
  sub_1B21DF788(v4, 0);
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3221225472;
  v17[2] = (uint64_t)sub_1B1910908;
  v17[3] = (uint64_t)&unk_1E63D93F8;
  v17[4] = a2;
  v17[5] = (uint64_t)v4;
  objc_msgSend_enumerateObjectsUsingBlock_(a1, v5, (uint64_t)v17, v6);
  if (v4[7])
  {
    sub_1B21E0074((uint64_t)v4);
    v7 = [VFXBtShapeWrapper alloc];
    return (id)objc_msgSend_initWithShape_(v7, v8, (uint64_t)v4, v9);
  }
  else
  {
    (*(void (**)(_DWORD *))(*(_QWORD *)v4 + 8))(v4);
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Compound shapes cannot be created without shapes"), v11, v12, v13, v14, v15, v16, v17[0]);
    return 0;
  }
}

void sub_1B190FCF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B21FF5FC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B1910128(uint64_t a1, const UInt8 **a2, _DWORD *a3, int *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const __CFData *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;

  if (sub_1B17A426C(a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8))
  {
    sub_1B17C4408(0, (uint64_t)CFSTR("Info: Non triangle list element type not yet supported in physics shape generation"), v13, v14, v15, v16, v17, v18, v38);
  }
  else
  {
    v39 = 0;
    v20 = sub_1B17A4570(a1, &v39);
    if (v20)
    {
      v28 = (const __CFData *)v20;
      v29 = sub_1B17A4304(a1, v21, v22, v23, v24, v25, v26, v27);
      *a2 = CFDataGetBytePtr(v28);
      v36 = v39;
      *a3 = 3 * v39;
      *a4 = v29 / 3;
      switch(v36)
      {
        case 1:
          v37 = 5;
          break;
        case 4:
          v37 = 2;
          break;
        case 2:
          v37 = 3;
          break;
        default:
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Unsupported indices stride"), v30, v31, v32, v33, v34, v35, (uint64_t)"0");
          return 0;
      }
      *a5 = v37;
      return 1;
    }
  }
  return 0;
}

uint64_t sub_1B1910234(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  const __CFData *v26;
  const UInt8 *BytePtr;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const __CFArray *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const __CFArray *v41;
  CFIndex i;
  const void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v48;
  int v49;
  int v50;
  const UInt8 *v51;
  _DWORD v52[2];
  const UInt8 *v53;
  int v54;
  int v55;
  int v56;

  v2 = sub_1B21FF5F0(112, 16);
  *(_OWORD *)(v2 + 16) = xmmword_1B2244F70;
  *(_QWORD *)v2 = off_1E63CD8F8;
  v3 = 1;
  *(_BYTE *)(v2 + 56) = 1;
  *(_QWORD *)(v2 + 48) = 0;
  *(_DWORD *)(v2 + 36) = 0;
  *(_DWORD *)(v2 + 40) = 0;
  v48 = v2;
  *(_DWORD *)(v2 + 72) = 0;
  v8 = sub_1B1875540(a1, 0, 0, 1, v4, v5, v6, v7);
  v16 = sub_1B17EE3B4((uint64_t)v8, v9, v10, v11, v12, v13, v14, v15);
  v17 = sub_1B18F3B74(v16);
  v25 = sub_1B17EDAE0((uint64_t)v8, v18, v19, v20, v21, v22, v23, v24);
  v26 = (const __CFData *)sub_1B17EDADC(v8);
  BytePtr = CFDataGetBytePtr(v26);
  if (sub_1B18F3854(v16) != 6)
  {
    sub_1B18F3854(v16);
    v3 = 0;
  }
  v35 = sub_1B1874BE0(a1, v28, v29, v30, v31, v32, v33, v34);
  if ((uint64_t)v35 >= 1)
  {
    v41 = v35;
    for (i = 0; (const __CFArray *)i != v41; ++i)
    {
      v43 = sub_1B1874C3C(a1, i, 1, v36, v37, v38, v39, v40);
      v53 = BytePtr;
      v54 = v17;
      v55 = 2;
      v56 = v3;
      v52[1] = v25;
      v49 = 0;
      if (sub_1B1910128((uint64_t)v43, &v51, v52, &v50, &v49, v44, v45, v46))
        sub_1B191039C(v48, (uint64_t)&v50, v49);
    }
  }
  return v48;
}

__n128 sub_1B191039C(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __n128 result;
  __int128 v18;

  v6 = *(_DWORD *)(a1 + 36);
  if (v6 == *(_DWORD *)(a1 + 40))
  {
    v7 = v6 ? 2 * v6 : 1;
    if (v6 < v7)
    {
      if (v7)
      {
        v8 = sub_1B21FF5F0(48 * v7, 16);
        v6 = *(_DWORD *)(a1 + 36);
      }
      else
      {
        v8 = 0;
      }
      if (v6 >= 1)
      {
        v9 = 0;
        v10 = 48 * v6;
        do
        {
          v11 = (_OWORD *)(v8 + v9);
          v12 = (__int128 *)(*(_QWORD *)(a1 + 48) + v9);
          v13 = *v12;
          v14 = v12[2];
          v11[1] = v12[1];
          v11[2] = v14;
          *v11 = v13;
          v9 += 48;
        }
        while (v10 != v9);
      }
      v15 = *(_QWORD *)(a1 + 48);
      if (v15 && *(_BYTE *)(a1 + 56))
        sub_1B21FF5FC(v15);
      *(_BYTE *)(a1 + 56) = 1;
      *(_QWORD *)(a1 + 48) = v8;
      *(_DWORD *)(a1 + 40) = v7;
      v6 = *(_DWORD *)(a1 + 36);
    }
  }
  v16 = *(_QWORD *)(a1 + 48) + 48 * v6;
  result = *(__n128 *)a2;
  v18 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v16 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v16 + 32) = v18;
  *(__n128 *)v16 = result;
  LODWORD(v16) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = v16 + 1;
  *(_DWORD *)(*(_QWORD *)(a1 + 48) + 48 * (int)v16 + 36) = a3;
  return result;
}

uint64_t sub_1B19104AC(const void *a1)
{
  CFTypeID v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = CFGetTypeID(a1);
  if (v2 == sub_1B1874018())
    return sub_1B1910234((uint64_t)a1);
  if (v2 != sub_1B1869F5C())
    return 0;
  v4 = sub_1B21FF5F0(96, 16);
  sub_1B19119AC(v4, (uint64_t)a1, v5, v6, v7, v8, v9, v10);
  return v4;
}

void sub_1B191051C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B21FF5FC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B1910530(void *a1)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  int i;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  __int128 *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD *v21;
  _DWORD *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  double v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  id *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  id *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;

  v2 = sub_1B19104AC(a1);
  if (!v2)
    return v2;
  v41 = (id *)a1;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  for (i = 0; ; ++i)
  {
    v7 = v5;
    v8 = v4;
    if (i >= (*(int (**)(uint64_t))(*(_QWORD *)v2 + 56))(v2))
      break;
    v46 = 0;
    v47 = 0;
    v45 = 0;
    v43 = 0;
    v44 = 0;
    v42 = 0;
    (*(void (**)(uint64_t, uint64_t *, char *, uint64_t *, int *, uint64_t *, char *, uint64_t *, int *, int))(*(_QWORD *)v2 + 32))(v2, &v47, (char *)&v46 + 4, &v46, &v45, &v44, (char *)&v43 + 4, &v43, &v42, i);
    v4 += HIDWORD(v46);
    if ((v46 & 0x8000000000000000) == 0 && HIDWORD(v46) && v3 < v4)
    {
      if (v4)
        v5 = sub_1B21FF5F0(16 * v4, 16);
      else
        v5 = 0;
      if (v8 >= 1)
      {
        v15 = v8;
        v16 = (_OWORD *)v5;
        v17 = (__int128 *)v7;
        do
        {
          v18 = *v17++;
          *v16++ = v18;
          --v15;
        }
        while (v15);
LABEL_16:
        sub_1B21FF5FC(v7);
        v3 = v4;
        goto LABEL_17;
      }
      if (v7)
        goto LABEL_16;
      v3 = v4;
    }
LABEL_17:
    if ((_DWORD)v46)
    {
      if ((byte_1EEF664E8 & 1) == 0)
      {
        byte_1EEF664E8 = 1;
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: vertex format not supported for physics shape creation (%d)"), v9, v10, v11, v12, v13, v14, v46);
      }
    }
    else
    {
      v19 = HIDWORD(v46);
      if (SHIDWORD(v46) >= 1)
      {
        v20 = v45;
        v21 = (_OWORD *)(v5 + 16 * v8);
        v22 = (_DWORD *)(v47 + 8);
        do
        {
          *(_QWORD *)&v23 = *((_QWORD *)v22 - 1);
          DWORD2(v23) = *v22;
          v22 = (_DWORD *)((char *)v22 + v20);
          *((_QWORD *)&v23 + 1) = DWORD2(v23);
          *v21++ = v23;
          --v19;
        }
        while (v19);
      }
    }
  }
  v24 = sub_1B21FF5F0(128, 16);
  sub_1B21E2B24(v24, v2, 1);
  v25 = sub_1B21FF5F0(80, 16);
  v26 = sub_1B21E6900(v25, v24);
  (*(void (**)(uint64_t, double))(*(_QWORD *)v24 + 96))(v24, v26);
  sub_1B21E699C(v25);
  (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v27 = *(_QWORD *)(v25 + 16);
  v28 = sub_1B21E6F78(v25);
  v29 = *(_QWORD *)(v25 + 48);
  v30 = sub_1B21E6F60(v25);
  if ((_DWORD)v28 && v27)
  {
    v31 = v30;
    v2 = sub_1B21FF5F0(192, 16);
    sub_1B21E0994(v2, v27, v28, 16, v29, v31);
  }
  else
  {
    v32 = sub_1B193E758(v41);
    sub_1B17C4408(0, (uint64_t)CFSTR("Warning: Cannot create convex hull for entity %@"), v33, v34, v35, v36, v37, v38, (uint64_t)v32);
    v2 = 0;
  }
  v39 = sub_1B21E6998(v25);
  sub_1B21FF5FC(v39);
  if (v7)
    sub_1B21FF5FC(v7);
  return v2;
}

void sub_1B19107E8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  sub_1B21FF5FC(v2);
  if (v1)
    sub_1B21FF5FC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B1910854(const void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = sub_1B19104AC(a1);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = sub_1B21FF5F0(112, 16);
  sub_1B21DE1F8(v3, v2, 1, 1);
  v4 = operator new();
  sub_1B1911F68(v4);
  sub_1B21D93A0(v3, v4);
  return v3;
}

void sub_1B19108D0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  v2 = v1;
  MEMORY[0x1B5E22E18](v2, 0x10B1C403C62072ELL);
  _Unwind_Resume(a1);
}

double sub_1B1910908(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  double result;
  _DWORD *v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  __int128 v18;
  unsigned int v19;
  unsigned int v20;
  __int128 v21;
  int v22;
  __int128 v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;

  v6 = objc_msgSend__shapeHandle_(a2, (const char *)a2, 0, a4);
  if (v6)
  {
    v10 = (_DWORD *)v6;
    v11 = objc_msgSend_objectAtIndex_(*(void **)(a1 + 32), v7, a3, v8);
    if (v11 && (v12 = (void *)v11, objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      objc_msgSend_VFXMatrix4Value(v12, v13, v14, v15);
      *(_QWORD *)&v18 = __PAIR64__(v17, v16);
      *(_QWORD *)&v21 = __PAIR64__(v20, v19);
      DWORD1(v23) = v22;
      *((_QWORD *)&v23 + 1) = v24;
      *((_QWORD *)&v18 + 1) = v25;
      *((_QWORD *)&v21 + 1) = v26;
      HIDWORD(v27) = 0;
      v28 = v23;
      v29 = v18;
      v30 = v21;
      v31 = v27;
    }
    else
    {
      v28 = xmmword_1B2244DB0;
      v29 = xmmword_1B2244DD0;
      v30 = xmmword_1B2244D90;
      v31 = 0uLL;
    }
    *(_QWORD *)&result = sub_1B21DF7EC(*(_QWORD *)(a1 + 40), (__n128 *)&v28, v10, 0).n128_u64[0];
  }
  return result;
}

uint64_t sub_1B19109F8(void *cf, uint64_t a2)
{
  CFTypeID v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int32x4_t v11;
  int8x16_t v12;
  int8x16_t v13;
  __int128 v14;
  int32x4_t v15;
  int8x16_t v16;
  int32x4_t v17;
  int8x16_t v18;
  int32x4_t v19;
  _OWORD v20[9];
  _OWORD v21[3];
  __int32 v22;
  int8x16_t v23;
  __int32 v24;
  __int128 v25;
  int8x8_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a2 == 3)
    return 0;
  if (a2 == 2)
    return sub_1B1910854(cf);
  if (a2 != 1)
    return sub_1B1910530(cf);
  v19.i32[2] = 0;
  v19.i64[0] = 0;
  v18.i32[2] = 0;
  v18.i64[0] = 0;
  v3 = CFGetTypeID(cf);
  if (v3 == sub_1B1874018())
    sub_1B1874504((uint64_t)cf, &v19, &v18, v4, v5, v6, v7, v8);
  else
    sub_1B17C5C88(cf, 1, (uint64_t)&v19, (uint64_t)&v18, v5, v6, v7, v8);
  v11 = vrev64q_s32(v19);
  v12 = vextq_s8(v18, (int8x16_t)v19, 4uLL);
  v13 = vextq_s8(v12, v12, 8uLL);
  v13.i32[0] = v19.i32[2];
  *(_QWORD *)&v14 = v18.i64[0];
  *((_QWORD *)&v14 + 1) = __PAIR64__(v18.u32[0], v19.u32[2]);
  v15 = v19;
  v15.i32[3] = v19.i32[0];
  v16 = vextq_s8((int8x16_t)v19, (int8x16_t)v11, 4uLL);
  v17 = vzip1q_s32(v11, (int32x4_t)v18);
  v17.i32[1] = v18.i32[2];
  v21[0] = v15;
  v21[1] = v17;
  v21[2] = v13;
  v22 = v18.i32[0];
  v16.i32[2] = v18.i32[0];
  v23 = v16;
  v24 = v18.i32[2];
  v25 = v14;
  v26 = vext_s8(*(int8x8_t *)v18.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), 4uLL);
  v20[6] = xmmword_1B2248160;
  v20[7] = unk_1B2248170;
  v20[8] = xmmword_1B2248180;
  v20[2] = xmmword_1B2248120;
  v20[3] = unk_1B2248130;
  v20[4] = xmmword_1B2248140;
  v20[5] = unk_1B2248150;
  v20[0] = xmmword_1B2248100;
  v20[1] = unk_1B2248110;
  v9 = sub_1B21FF5F0(192, 16);
  sub_1B21E0994(v9, v21, 8, 12, v20, 12);
  return v9;
}

void sub_1B1910BE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B21FF5FC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B1910C04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  int v11;

  v9 = sub_1B1868FA0(a2, a2, a3, a4, a5, a6, a7, a8);
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v11 = *(_DWORD *)(v10 + 24);
  if (v9)
    ++v11;
  *(_DWORD *)(v10 + 24) = v11;
  return 2 * (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) > 1);
}

uint64_t sub_1B1910C58(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  _OWORD *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  _OWORD v32[4];
  int8x16_t v33;
  int8x16_t v34;
  int32x2_t v35;
  uint64_t v36;
  __int128 v37;

  v10 = (_QWORD *)sub_1B1868FA0(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    v11 = sub_1B1910D80(v10, a1[6].i64[0]);
    if (v11)
    {
      v19 = (_DWORD *)v11;
      v30 = a1[2];
      v31 = a1[3];
      v28 = a1[5];
      v29 = a1[4];
      v20 = (_OWORD *)sub_1B1869AC8(a2, v12, v13, v14, v15, v16, v17, v18);
      v21 = 0;
      v22 = v20[1];
      v23 = v20[2];
      v24 = v20[3];
      v32[0] = *v20;
      v32[1] = v22;
      v32[2] = v23;
      v32[3] = v24;
      do
      {
        *(float32x4_t *)((char *)&v33 + v21 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v30, COERCE_FLOAT(v32[v21])), v31, *(float32x2_t *)&v32[v21], 1), v29, (float32x4_t)v32[v21], 2), v28, (float32x4_t)v32[v21], 3);
        ++v21;
      }
      while (v21 != 4);
      v25 = v33;
      v26 = v34;
      *(int32x2_t *)v33.i8 = vzip1_s32(*(int32x2_t *)v33.i8, *(int32x2_t *)v34.i8);
      v33.i64[1] = v35.u32[0];
      *(int32x2_t *)v34.i8 = vzip2_s32(*(int32x2_t *)v25.i8, *(int32x2_t *)v34.i8);
      v34.i64[1] = v35.u32[1];
      v35 = vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
      v36 = v36;
      HIDWORD(v37) = 0;
      sub_1B21DF7EC(a1[6].i64[1], (__n128 *)&v33, v19, 1);
    }
  }
  return 0;
}

uint64_t sub_1B1910D80(_QWORD *a1, uint64_t a2)
{
  CFTypeID v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __n128 *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float v44;
  float v45;
  float v46;
  float v47;
  int32x2_t v48;
  uint64_t v49;
  int32x2_t v50;
  int32x2_t v51;
  float *v52;
  uint64_t v53;
  float64x2_t v54;
  __float2 v55;
  __float2 v56;
  float32x2_t v57;
  float32x2_t v58;
  uint64_t v59;
  float v60;
  uint64_t v61;
  float64x2_t v62;
  float v63;
  float v64;
  float32x4_t __s1;
  _BYTE v66[32];
  __int128 v67;
  float v68;
  int v69;
  float v70;
  int v71;
  float v72;
  int v73;
  float v74;
  int v75;
  float v76;
  int v77;
  float v78;
  int v79;
  float v80;
  int v81;
  float v82;
  int v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v4 = CFGetTypeID(a1);
  if (a2 == 1 || v4 != sub_1B19156CC())
  {
    if (v4 == sub_1B18D9D1C())
    {
      v21 = (__n128 *)sub_1B17C6244(a1, v14, v15, v16, v17, v18, v19, v20);
      DWORD2(v67) = 0;
      *(_QWORD *)&v67 = 0;
      if (v21)
        sub_1B187AD68(v21, (__n128 *)&v67, v22, v23, v24, v25, v26, v27);
      else
        v67 = xmmword_1B2244DD0;
      v13 = sub_1B21FF5F0(112, 16);
      __s1.i64[0] = v67;
      __s1.i64[1] = DWORD2(v67);
      sub_1B21E71B0(v13, &__s1, 0.0);
      return v13;
    }
    v28 = (void *)sub_1B17A0848((uint64_t)a1, v14, v15, v16, v17, v18, v19, v20);
    if (v28)
      return sub_1B19109F8(v28, a2);
    return 0;
  }
  memset(&__s1, 0, 48);
  sub_1B1915674((uint64_t)a1, v5, v6, v7, v8, v9, v10, (uint64_t)&__s1);
  if (!memcmp(&__s1, &xmmword_1E63D2D98, 0x30uLL))
  {
    v30 = sub_1B1915A70((uint64_t)a1, 0);
    v31 = sub_1B1915A70((uint64_t)a1, 1);
    v32 = sub_1B1915A70((uint64_t)a1, 2);
    v13 = sub_1B21FF5F0(80, 16);
    *(float *)&v67 = v30 * 0.5;
    *((float *)&v67 + 1) = v31 * 0.5;
    *((float *)&v67 + 2) = v32 * 0.5;
    HIDWORD(v67) = 0;
    sub_1B21DD98C(v13, &v67);
    return v13;
  }
  if (!memcmp(&__s1, &xmmword_1E63D3B00, 0x30uLL))
  {
    v33 = sub_1B1915A70((uint64_t)a1, 0);
    v34 = sub_1B1915A70((uint64_t)a1, 1);
    v35 = sub_1B1915A70((uint64_t)a1, 2);
    LODWORD(v67) = 0;
    *((float *)&v67 + 1) = v34;
    *((_QWORD *)&v67 + 1) = 0;
    v68 = v33 * -0.5;
    v69 = 0;
    v70 = v35 * -0.5;
    v71 = 0;
    v72 = v33 * -0.5;
    v73 = 0;
    v74 = v35 * 0.5;
    v75 = 0;
    v76 = v33 * 0.5;
    v77 = 0;
    v78 = v35 * -0.5;
    v79 = 0;
    v80 = v33 * 0.5;
    v81 = 0;
    v82 = v35 * 0.5;
    v83 = 0;
    v13 = sub_1B21FF5F0(192, 16);
    sub_1B21E0994(v13, &v67, 5, 16, 0, 0);
    return v13;
  }
  if (!memcmp(&__s1, &xmmword_1E63D3440, 0x30uLL))
    goto LABEL_24;
  if (!memcmp(&__s1, &xmmword_1E63D3290, 0x30uLL))
  {
    if (sub_1B1915A70((uint64_t)a1, 5) != 0.0 && (byte_1EEF664E9 & 1) == 0)
    {
      byte_1EEF664E9 = 1;
      sub_1B17C4408(16, (uint64_t)CFSTR("Warning: VFXPhysicsShape does not support a VFXCone with TopRadius != 0.0"), v38, v39, v40, v41, v42, v43, v61);
    }
    v44 = sub_1B1915A70((uint64_t)a1, 4);
    v45 = sub_1B1915A70((uint64_t)a1, 1);
    v13 = sub_1B21FF5F0(96, 16);
    sub_1B21E039C(v13, v44, v45);
    return v13;
  }
  if (!memcmp(&__s1, &xmmword_1E63D4010, 0x30uLL))
  {
LABEL_24:
    v36 = sub_1B1915A70((uint64_t)a1, 4);
    v37 = sub_1B1915A70((uint64_t)a1, 1);
    v13 = sub_1B21FF5F0(80, 16);
    *(float *)&v67 = v36;
    *((float *)&v67 + 1) = v37 * 0.5;
    *((_QWORD *)&v67 + 1) = LODWORD(v36);
    sub_1B21E2FA0(v13, &v67);
    return v13;
  }
  if (!memcmp(&__s1, &xmmword_1E63D3260, 0x30uLL))
  {
    v46 = sub_1B1915A70((uint64_t)a1, 4);
    v47 = sub_1B1915A70((uint64_t)a1, 1);
    v13 = sub_1B21FF5F0(80, 16);
    sub_1B21DEB8C(v13, v46, v47 + (float)(v46 * -2.0));
    return v13;
  }
  if (!memcmp(&__s1, &xmmword_1E63D3F20, 0x30uLL))
  {
    v63 = sub_1B1915A70((uint64_t)a1, 4);
    *(float *)v48.i32 = sub_1B1915A70((uint64_t)a1, 7);
    v49 = 0;
    v50 = vdup_lane_s32(v48, 0);
    v51 = (int32x2_t)0x100000000;
    v52 = (float *)&v67;
    v62 = (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL);
    v53 = 0;
    do
    {
      v54 = vmulq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_s32(v51), (float32x2_t)0x3E0000003E000000)), v62);
      *(float32x2_t *)&v54.f64[0] = vcvt_f32_f64(vaddq_f64(v54, v54));
      v64 = *(float *)v54.f64;
      v55 = __sincosf_stret(*((float *)v54.f64 + 1));
      v56 = __sincosf_stret(v64);
      v57 = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v55.__sinval), LODWORD(v56.__sinval)), v63);
      v58 = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v55.__cosval), LODWORD(v56.__cosval)), v63);
      v59 = 0;
      vst4_f32(v52, *(float32x2x4_t *)(&v53 - 1));
      v52 += 8;
      *(int32x2_t *)&v66[v49] = v50;
      v51 = vadd_s32(v51, (int32x2_t)0x200000002);
      v49 += 8;
    }
    while (v49 != 32);
    v13 = sub_1B21FF5F0(192, 16);
    sub_1B21E37D4(v13, &v67, v66, 8);
    return v13;
  }
  if (!memcmp(&__s1, &xmmword_1E63D3DD0, 0x30uLL))
  {
    v60 = sub_1B1915A70((uint64_t)a1, 4);
    v13 = sub_1B21FF5F0(80, 16);
    sub_1B21E0FCC(v13);
    *(_QWORD *)v13 = &unk_1E63CBCC8;
    *(_DWORD *)(v13 + 8) = 8;
    *(float *)(v13 + 48) = v60;
    *(float *)(v13 + 64) = v60;
    return v13;
  }
  if (memcmp(&__s1, &xmmword_1E63D3A70, 0x30uLL))
    return 0;
  v11 = sub_1B1915A70((uint64_t)a1, 0);
  v12 = sub_1B1915A70((uint64_t)a1, 1);
  v13 = sub_1B21FF5F0(224, 16);
  *(float *)&v67 = v11 * 0.5;
  *((float *)&v67 + 1) = v12 * 0.5;
  *((_QWORD *)&v67 + 1) = 0;
  sub_1B19122E0(v13, (float32x2_t *)&v67);
  return v13;
}

void sub_1B19113CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B21FF5FC(v1);
  _Unwind_Resume(a1);
}

void sub_1B191152C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B1911544(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  __n128 v16;

  v5 = (void *)MEMORY[0x1E0CB3940];
  v6 = *(void **)(a1 + 32);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v8 = *(unsigned int *)(v7 + 24);
  *(_DWORD *)(v7 + 24) = v8 + 1;
  v9 = (const char *)objc_msgSend_stringWithFormat_(v5, a2, (uint64_t)CFSTR("transform%d"), a4, v8);
  objc_msgSend_VFXMatrix4Value(a2, v10, v11, v12);
  return sub_1B18BD294(v6, v9, v13, v14, v15, v16);
}

uint64_t sub_1B19119AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _QWORD v15[4];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  *(_OWORD *)(a1 + 16) = xmmword_1B2244F70;
  *(_QWORD *)a1 = off_1E63CD118;
  *(_BYTE *)(a1 + 56) = 1;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 88) = 1;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 68) = 0;
  *(double *)&v10 = sub_1B186B90C(a2, a2, a3, a4, a5, a6, a7, a8);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v15[2] = sub_1B1911A8C;
  v15[3] = &unk_1E63D9460;
  v20 = a1;
  v16 = v10;
  v17 = v11;
  v18 = v12;
  v19 = v13;
  sub_1B186B018(a2, (uint64_t)v15);
  return a1;
}

void sub_1B1911A64(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B1810570(v1 + 64);
  sub_1B1810570(v1 + 32);
  nullsub_16(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B1911A8C(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const void *v27;
  _OWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  const void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  const __CFData *v56;
  const UInt8 *BytePtr;
  int v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  float32x4_t v72;
  int v73;
  uint64_t v74;
  float32_t v75;
  float32x4_t v76;
  const __CFArray *v77;
  const __CFArray *v78;
  const __CFArray *i;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _OWORD *v85;
  _OWORD *v86;
  __int128 v87;
  uint64_t v88;
  uint64_t v89;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  _OWORD v99[4];
  _OWORD v100[4];

  v10 = a1[6].i64[0];
  v11 = sub_1B1868FA0(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v11)
  {
    v19 = sub_1B17A0848(v11, v12, v13, v14, v15, v16, v17, v18);
    if (v19)
    {
      v27 = (const void *)v19;
      v95 = a1[2];
      v97 = a1[3];
      v91 = a1[5];
      v93 = a1[4];
      v28 = (_OWORD *)sub_1B1869AC8(a2, v20, v21, v22, v23, v24, v25, v26);
      v33 = 0;
      v34 = v28[1];
      v35 = v28[2];
      v36 = v28[3];
      v99[0] = *v28;
      v99[1] = v34;
      v99[2] = v35;
      v99[3] = v36;
      do
      {
        v100[v33] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v95, COERCE_FLOAT(v99[v33])), v97, *(float32x2_t *)&v99[v33], 1), v93, (float32x4_t)v99[v33], 2), v91, (float32x4_t)v99[v33], 3);
        ++v33;
      }
      while (v33 != 4);
      v96 = (float32x4_t)v100[1];
      v98 = (float32x4_t)v100[0];
      v92 = (float32x4_t)v100[3];
      v94 = (float32x4_t)v100[2];
      v37 = sub_1B1875540((uint64_t)v27, 0, 0, 1, v29, v30, v31, v32);
      if (v37)
      {
        v45 = (uint64_t)v37;
        v46 = sub_1B17EE3B4((uint64_t)v37, v38, v39, v40, v41, v42, v43, v44);
        v47 = sub_1B18F3B74(v46);
        v55 = sub_1B17EDAE0(v45, v48, v49, v50, v51, v52, v53, v54);
        v56 = (const __CFData *)sub_1B17EDADC(v45);
        BytePtr = CFDataGetBytePtr(v56);
        v58 = *(_DWORD *)(v10 + 68);
        v59 = v58 + v55;
        if ((int)v55 >= 1 && *(_DWORD *)(v10 + 72) < v59)
        {
          if (v59)
            v60 = sub_1B21FF5F0(16 * v59, 16);
          else
            v60 = 0;
          if (*(int *)(v10 + 68) >= 1)
          {
            v61 = 0;
            v62 = 16 * *(unsigned int *)(v10 + 68);
            do
            {
              *(_OWORD *)(v60 + v61) = *(_OWORD *)(*(_QWORD *)(v10 + 80) + v61);
              v61 += 16;
            }
            while (v62 != v61);
          }
          v63 = *(_QWORD *)(v10 + 80);
          if (v63 && *(_BYTE *)(v10 + 88))
            sub_1B21FF5FC(v63);
          *(_BYTE *)(v10 + 88) = 1;
          *(_QWORD *)(v10 + 80) = v60;
          *(_DWORD *)(v10 + 72) = v59;
        }
        *(_DWORD *)(v10 + 68) = v59;
        v64 = sub_1B18F3854(v46);
        if (v64 == 6 || (unsigned __int16)v64 == 1)
        {
          if (v55 >= 1)
          {
            v73 = v58;
            v74 = v55;
            do
            {
              if (v64 == 1)
              {
                v72.i64[0] = *(_QWORD *)BytePtr;
                v72.i32[2] = *((_DWORD *)BytePtr + 2);
              }
              else
              {
                v72 = *(float32x4_t *)BytePtr;
                *(float32x2_t *)v72.f32 = vcvt_f32_f64(*(float64x2_t *)BytePtr);
                v75 = *((double *)BytePtr + 2);
                v72.f32[2] = v75;
              }
              v76 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v92, v94, v72, 2), v96, *(float32x2_t *)v72.f32, 1), v98, v72.f32[0]);
              v76.i32[3] = 0;
              *(float32x4_t *)(*(_QWORD *)(v10 + 80) + 16 * v73++) = v76;
              BytePtr += v47;
              --v74;
            }
            while (v74);
          }
        }
        else
        {
          sub_1B17C4408(0, (uint64_t)CFSTR("Warning: Physics shape construction does not support meshes with positions value type different from double or float. (%d)"), v66, v67, v68, v69, v70, v71, v64);
        }
        v77 = sub_1B1874BE0((uint64_t)v27, v65, v66, v67, v68, v69, v70, v71);
        if ((uint64_t)v77 >= 1)
        {
          v78 = v77;
          for (i = 0; i != v78; i = (const __CFArray *)((char *)i + 1))
          {
            CFRetain(v27);
            v80 = *(_DWORD *)(v10 + 36);
            if (v80 == *(_DWORD *)(v10 + 40))
            {
              v81 = v80 ? 2 * v80 : 1;
              if (v80 < v81)
              {
                if (v81)
                {
                  v82 = sub_1B21FF5F0(32 * v81, 16);
                  v80 = *(_DWORD *)(v10 + 36);
                }
                else
                {
                  v82 = 0;
                }
                if (v80 >= 1)
                {
                  v83 = 0;
                  v84 = 32 * v80;
                  do
                  {
                    v85 = (_OWORD *)(v82 + v83);
                    v86 = (_OWORD *)(*(_QWORD *)(v10 + 48) + v83);
                    v87 = v86[1];
                    *v85 = *v86;
                    v85[1] = v87;
                    v83 += 32;
                  }
                  while (v84 != v83);
                }
                v88 = *(_QWORD *)(v10 + 48);
                if (v88 && *(_BYTE *)(v10 + 56))
                  sub_1B21FF5FC(v88);
                *(_BYTE *)(v10 + 56) = 1;
                *(_QWORD *)(v10 + 48) = v82;
                *(_DWORD *)(v10 + 40) = v81;
                v80 = *(_DWORD *)(v10 + 36);
              }
            }
            v89 = *(_QWORD *)(v10 + 48) + 32 * v80;
            *(_QWORD *)v89 = v27;
            *(_QWORD *)(v89 + 8) = i;
            *(_DWORD *)(v89 + 16) = v58;
            *(_DWORD *)(v89 + 20) = v55;
            ++*(_DWORD *)(v10 + 36);
          }
        }
      }
    }
  }
  return 0;
}

void sub_1B1911DDC(uint64_t a1)
{
  uint64_t v1;

  sub_1B1911EC0(a1);
  sub_1B21FF5FC(v1);
}

void sub_1B1911DF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: This is not yet implemented"), a3, a4, a5, a6, a7, a8, a9);
}

const void *sub_1B1911E00(uint64_t a1, _QWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, const UInt8 **a6, _DWORD *a7, int *a8, int *a9, int a10)
{
  uint64_t v13;
  const void *result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v13 = *(_QWORD *)(a1 + 48) + 32 * a10;
  *a3 = *(_DWORD *)(v13 + 20);
  *a2 = *(_QWORD *)(a1 + 80) + 16 * *(int *)(v13 + 16);
  *a4 = 0;
  *a5 = 16;
  result = sub_1B1874C3C(*(_QWORD *)v13, *(_QWORD *)(v13 + 8), 1, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8);
  if (result)
    return (const void *)sub_1B1910128((uint64_t)result, a6, a7, a8, a9, v15, v16, v17);
  return result;
}

uint64_t sub_1B1911E98(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_1B1911EA8()
{
  return 0;
}

uint64_t sub_1B1911EB8()
{
  return 32;
}

double sub_1B1911EC0(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t i;
  const void *v5;

  *(_QWORD *)a1 = off_1E63CD118;
  v2 = *(_DWORD *)(a1 + 36);
  if (v2 >= 1)
  {
    v3 = 0;
    for (i = 0; i < v2; ++i)
    {
      v5 = *(const void **)(*(_QWORD *)(a1 + 48) + v3);
      if (v5)
      {
        CFRelease(v5);
        v2 = *(_DWORD *)(a1 + 36);
      }
      v3 += 32;
    }
  }
  sub_1B1810570(a1 + 64);
  sub_1B1810570(a1 + 32);
  return nullsub_16(a1);
}

void sub_1B1911F40(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B1810570(v1 + 64);
  sub_1B1810570(v1 + 32);
  nullsub_16(v1);
  _Unwind_Resume(a1);
}

double sub_1B1911F68(uint64_t a1)
{
  double result;

  *(_BYTE *)(a1 + 32) = 1;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 64) = 1;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 96) = 1;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 76) = 0;
  *(_BYTE *)(a1 + 128) = 1;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 108) = 0;
  *(_QWORD *)a1 = &off_1E63CC8B0;
  *(_OWORD *)(a1 + 136) = xmmword_1B22480E0;
  result = 5.15555163e-67;
  *(_QWORD *)(a1 + 152) = 0x322BCC7640C90FDBLL;
  return result;
}

void sub_1B1911FCC(uint64_t a1)
{
  sub_1B191229C(a1);
  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B1911FF0()
{
  return 72;
}

const char *sub_1B1911FF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  int *v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int *v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  int *v36;
  int v37;

  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 136);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 156);
  v6 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 56) = v6;
  if (v6)
  {
    v7 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 56))(a3, *(_QWORD *)(a1 + 24));
    *(_QWORD *)a2 = v7;
    if (v7)
    {
      v8 = *(unsigned int *)(a2 + 56);
      v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 32))(a3, 4, v8);
      v10 = *(_QWORD *)(a1 + 24);
      if ((int)v8 >= 1)
      {
        v11 = *(_DWORD **)(v9 + 8);
        v12 = *(int **)(a1 + 24);
        do
        {
          v13 = *v12++;
          *v11++ = v13;
          --v8;
        }
        while (v8);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(_QWORD *)a3 + 40))(a3, v9, "int", 1497453121, v10);
    }
  }
  else
  {
    *(_QWORD *)a2 = 0;
  }
  v14 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a2 + 52) = v14;
  if (v14)
  {
    v15 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 56))(a3, *(_QWORD *)(a1 + 56));
    *(_QWORD *)(a2 + 8) = v15;
    if (v15)
    {
      v16 = *(unsigned int *)(a2 + 52);
      v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 32))(a3, 4, v16);
      v18 = *(_QWORD *)(a1 + 56);
      if ((int)v16 >= 1)
      {
        v19 = *(_DWORD **)(v17 + 8);
        v20 = *(int **)(a1 + 56);
        do
        {
          v21 = *v20++;
          *v19++ = v21;
          --v16;
        }
        while (v16);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(_QWORD *)a3 + 40))(a3, v17, "int", 1497453121, v18);
    }
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
  }
  v22 = *(_DWORD *)(a1 + 76);
  *(_DWORD *)(a2 + 60) = v22;
  if (v22)
  {
    v23 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 56))(a3, *(_QWORD *)(a1 + 88));
    *(_QWORD *)(a2 + 16) = v23;
    if (v23)
    {
      v24 = *(unsigned int *)(a2 + 60);
      v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 32))(a3, 16, v24);
      v26 = *(_QWORD *)(a1 + 88);
      if ((int)v24 >= 1)
      {
        v27 = *(_QWORD *)(v25 + 8);
        v28 = *(int **)(a1 + 88);
        do
        {
          *(_QWORD *)(v27 + 4) = *(_QWORD *)(v28 + 1);
          *(_DWORD *)(v27 + 12) = v28[3];
          v29 = *v28;
          v28 += 4;
          *(_DWORD *)v27 = v29;
          v27 += 16;
          --v24;
        }
        while (v24);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(_QWORD *)a3 + 40))(a3, v25, "btTriangleInfoData", 1497453121, v26);
    }
  }
  else
  {
    *(_QWORD *)(a2 + 16) = 0;
  }
  v30 = *(_DWORD *)(a1 + 108);
  *(_DWORD *)(a2 + 64) = v30;
  if (v30)
  {
    v31 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 56))(a3, *(_QWORD *)(a1 + 120));
    *(_QWORD *)(a2 + 24) = v31;
    if (v31)
    {
      v32 = *(unsigned int *)(a2 + 60);
      v33 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 32))(a3, 4, v32);
      v34 = *(_QWORD *)(a1 + 120);
      if ((int)v32 >= 1)
      {
        v35 = *(_DWORD **)(v33 + 8);
        v36 = *(int **)(a1 + 120);
        do
        {
          v37 = *v36++;
          *v35++ = v37;
          --v32;
        }
        while (v32);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(_QWORD *)a3 + 40))(a3, v33, "int", 1497453121, v34);
    }
  }
  else
  {
    *(_QWORD *)(a2 + 24) = 0;
  }
  return "btTriangleInfoMapData";
}

uint64_t sub_1B191229C(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 8;
  sub_1B1810570(a1 + 104);
  sub_1B1810570(a1 + 72);
  sub_1B1810570(a1 + 40);
  sub_1B1810570(v2);
  return a1;
}

uint64_t sub_1B19122E0(uint64_t a1, float32x2_t *a2)
{
  uint64_t v4;
  float v5;
  float v6;
  float v7;
  __n128 v8;
  float v9;
  float32x4_t v10;
  float32x4_t v11;
  __int32 v13;
  float32x4_t v14;

  sub_1B21E464C(a1);
  *(_QWORD *)v4 = &unk_1E63CBAE8;
  *(_QWORD *)(v4 + 80) = 0;
  *(_QWORD *)(v4 + 88) = 0;
  *(float32x2_t *)(v4 + 96) = vneg_f32(*a2);
  *(_QWORD *)(v4 + 104) = 0;
  v5 = -a2->f32[1];
  *(_DWORD *)(v4 + 112) = a2->i32[0];
  *(float *)(v4 + 116) = v5;
  *(_QWORD *)(v4 + 120) = 0;
  *(_DWORD *)(v4 + 128) = a2->i32[0];
  *(_DWORD *)(v4 + 132) = a2->i32[1];
  *(_QWORD *)(v4 + 136) = 0;
  *(float *)(v4 + 144) = -a2->f32[0];
  *(_DWORD *)(v4 + 148) = a2->i32[1];
  *(_OWORD *)(v4 + 152) = xmmword_1B22463E0;
  *(_QWORD *)(v4 + 168) = 0;
  *(_DWORD *)(v4 + 176) = 1065353216;
  *(_QWORD *)(v4 + 188) = 0;
  *(_QWORD *)(v4 + 180) = 0;
  *(_OWORD *)(v4 + 196) = xmmword_1B22480F0;
  *(_QWORD *)(v4 + 212) = 0;
  *(_DWORD *)(v4 + 220) = 0;
  if (a2->f32[0] <= a2->f32[1])
    v6 = a2->f32[0];
  else
    v6 = a2->f32[1];
  v7 = sub_1B21D60F0(v4);
  v8.n128_f32[0] = v6 * 0.1;
  if ((float)(v6 * 0.1) < v7)
    (*(void (**)(uint64_t, float))(*(_QWORD *)a1 + 88))(a1, v8.n128_f32[0]);
  *(_DWORD *)(a1 + 8) = 17;
  v14.i64[0] = (*(double (**)(uint64_t, __n128))(*(_QWORD *)a1 + 96))(a1, v8);
  v13 = COERCE_UNSIGNED_INT64((*(double (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1));
  v9 = (*(float (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  v10 = v14;
  v10.i32[1] = v13;
  v10.f32[2] = v9;
  v11 = vsubq_f32(vmulq_f32(*(float32x4_t *)a2->f32, *(float32x4_t *)(a1 + 32)), v10);
  v11.i32[3] = 0;
  *(float32x4_t *)(a1 + 48) = v11;
  return a1;
}

void sub_1B1912448(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1B21E4670(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B1912468(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  unsigned __int8 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t v29;
  uint64_t v30;
  __n128 v31;
  uint64_t v32;
  uint64_t v33;
  CFX::RG::Resource *v34;
  CFX::RG::Resource *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v44;
  uint64_t v45;
  float v46[40];
  uint64_t v47[20];
  float v48[40];
  uint64_t v49;
  __int16 v50;
  char v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  char v58;
  char v59;
  uint64_t v60;
  uint64_t v61;
  char v62;
  char v63;
  uint64_t v64;
  int v65;
  __int16 v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v55 = a2;
  *((_QWORD *)&v55 + 1) = a3;
  v11 = atomic_load((unsigned __int8 *)&qword_1EEF66518);
  if ((v11 & 1) == 0)
  {
    v45 = a2;
    v44 = __cxa_guard_acquire(&qword_1EEF66518);
    a2 = v45;
    if (v44)
    {
      qword_1EEF66510 = (uint64_t)sub_1B19129A0("MIRROR_PASS", 0xBu);
      __cxa_guard_release(&qword_1EEF66518);
      a2 = v45;
    }
  }
  sub_1B182AAEC(a1, a2, a3, (uint64_t *)a5, qword_1EEF66510, a6);
  *(_QWORD *)a1 = &off_1E63CE480;
  *(_QWORD *)(a1 + 392) = 0;
  v12 = *(_OWORD *)(a5 + 24);
  v13 = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(a1 + 416) = *(_OWORD *)(a5 + 40);
  *(_OWORD *)(a1 + 432) = v13;
  *(_OWORD *)(a1 + 400) = v12;
  v14 = *(_OWORD *)(a5 + 72);
  v15 = *(_OWORD *)(a5 + 88);
  v16 = *(_OWORD *)(a5 + 120);
  *(_OWORD *)(a1 + 480) = *(_OWORD *)(a5 + 104);
  *(_OWORD *)(a1 + 496) = v16;
  *(_OWORD *)(a1 + 448) = v14;
  *(_OWORD *)(a1 + 464) = v15;
  v17 = *(_OWORD *)(a5 + 136);
  v18 = *(_OWORD *)(a5 + 152);
  v19 = *(_OWORD *)(a5 + 168);
  *(_QWORD *)(a1 + 560) = *(_QWORD *)(a5 + 184);
  *(_OWORD *)(a1 + 528) = v18;
  *(_OWORD *)(a1 + 544) = v19;
  *(_OWORD *)(a1 + 512) = v17;
  *(_OWORD *)(a1 + 568) = 0u;
  v27 = sub_1B18695D0(*(_QWORD *)(a1 + 400), v20, v21, v22, v23, v24, v25, v26);
  v47[0] = *(_QWORD *)(a1 + 368);
  v58 = 0;
  v59 = 0;
  v57 = 0;
  v56 = 0uLL;
  v60 = sub_1B18DA46C(v27);
  v61 = 0;
  v62 = *(_BYTE *)(a1 + 376);
  v63 = sub_1B1815C80(*(_QWORD *)(a1 + 368));
  v64 = 2;
  v65 = 1;
  v66 = 1;
  *(_QWORD *)(a1 + 384) = sub_1B17CA2A0(v55, *((uint64_t *)&v55 + 1), (uint64_t *)&v55, v47, &v56);
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 3;
  v53 = 0;
  v28 = atomic_load((unsigned __int8 *)&qword_1EEF66518);
  if ((v28 & 1) == 0 && __cxa_guard_acquire(&qword_1EEF66518))
  {
    qword_1EEF66510 = (uint64_t)sub_1B19129A0("MIRROR_PASS", 0xBu);
    __cxa_guard_release(&qword_1EEF66518);
  }
  v54 = qword_1EEF66510;
  v29 = *(_QWORD *)(a1 + 368);
  v56 = v55;
  v30 = sub_1B179C1C0(&v56, 0x40u, 8u);
  v31 = sub_1B182CDF0(v30, v29, (uint64_t)&v49, *(_QWORD *)(a1 + 384));
  *(_QWORD *)(a1 + 392) = v32;
  v33 = (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)a1 + 32))(a1, v31);
  *(_OWORD *)v33 = 0u;
  *(_OWORD *)(v33 + 16) = 0u;
  *(_BYTE *)(v33 + 269) = 1;
  CFX::RG::TextureDescriptorReference::withSampleCount((_OWORD *)(a1 + 408), *(unsigned __int8 *)(v27 + 224), (uint64_t)v47);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v47, MTLPixelFormatRGBA16Float, (uint64_t)&v56);
  CFX::RG::TextureDescriptorReference::withSizeFactor(&v56, *(float *)(v27 + 220), v48);
  v34 = sub_1B17A34D0(a4, (uint64_t)"COLOR_MIRROR_MAP", v48);
  *(_QWORD *)(a1 + 568) = v34;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v34, 0x100000002, 0);
  CFX::RG::TextureDescriptorReference::withSampleCount((_OWORD *)(a1 + 408), *(unsigned __int8 *)(v27 + 224), (uint64_t)v47);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v47, MTLPixelFormatDepth32Float, (uint64_t)&v56);
  CFX::RG::TextureDescriptorReference::withSizeFactor(&v56, *(float *)(v27 + 220), v46);
  v35 = sub_1B17A34D0(a4, (uint64_t)"DEPTH_MIRROR_MAP", v46);
  CFX::RG::Pass::renderTo(a1, (uint64_t)v35, 0x200000002, -1);
  if (sub_1B18DA1F0(v27, v36, v37, v38, v39, v40, v41, v42) != 0.0)
    *(_QWORD *)(a1 + 576) = v35;
  return a1;
}

void sub_1B19127B4(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B19127E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v10;
  unsigned __int8 v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  __n128 *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const CFX::RG::Resource *v55;

  v10 = atomic_load((unsigned __int8 *)&qword_1EEF664F8);
  if ((v10 & 1) == 0 && __cxa_guard_acquire(&qword_1EEF664F8))
  {
    qword_1EEF664F0 = (uint64_t)sub_1B19129A0("VFX-Floor-color", 0xFu);
    __cxa_guard_release(&qword_1EEF664F8);
  }
  v11 = atomic_load((unsigned __int8 *)&qword_1EEF66508);
  if ((v11 & 1) == 0 && __cxa_guard_acquire(&qword_1EEF66508))
  {
    qword_1EEF66500 = (uint64_t)sub_1B19129A0("VFX-Floor-depth", 0xFu);
    __cxa_guard_release(&qword_1EEF66508);
  }
  v12 = *(_QWORD *)(a1 + 400);
  v13 = 0x9DDFEA08EB382D69
      * (qword_1EEF664F0 ^ ((0x9DDFEA08EB382D69 * (qword_1EEF664F0 ^ v12)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                                     * (qword_1EEF664F0 ^ v12)));
  v14 = v13 ^ (v13 >> 47);
  v15 = qword_1EEF66500;
  v16 = sub_1B18695D0(v12, a2, a3, a4, a5, a6, a7, a8);
  v26 = sub_1B181537C(*(_QWORD *)(a1 + 368), 0, v17, v18, v19, v20, v21, v22);
  *(float32x2_t *)&v26.n128_i8[8] = vmul_n_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL), *(float *)(v16 + 220));
  v27 = *(__n128 **)(a1 + 384);
  if (!v27[5].n128_u8[0])
    v27[5].n128_u8[0] = 1;
  v27[4] = v26;
  sub_1B19610E0(*(__n128 **)(a1 + 384), v23, v24, v25);
  sub_1B196142C(*(_QWORD *)(a1 + 384), v28, v29, v30, v31, v32, v33, v34);
  sub_1B196183C(*(_QWORD *)(a1 + 384), *(_QWORD *)(a1 + 400), v35, v36, v37, v38, v39, v40);
  sub_1B1961820(*(_QWORD *)(a1 + 384));
  sub_1B1961844(*(_QWORD *)(a1 + 384), *(_QWORD *)(a1 + 400), v41, v42, v43, v44, v45, v46);
  sub_1B196184C(*(_QWORD *)(a1 + 384), v47, v48, v49, v50, v51, v52, v53);
  CFX::GPUResourceManager::registerNamedFrameResource(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 568), -348639895 * v14);
  v55 = *(const CFX::RG::Resource **)(a1 + 576);
  if (v55)
    CFX::GPUResourceManager::registerNamedFrameResource(*(CFX::GPUResourceManager **)(a2 + 24), v55, -348639895* ((-348639895* (v15 ^ (((0x9DDFEA08EB382D69 * (v15 ^ v12)) >> 32) >> 15) ^ (-348639895 * (v15 ^ v12)))) ^ (((0x9DDFEA08EB382D69 * (v15 ^ ((0x9DDFEA08EB382D69 * (v15 ^ v12)) >> 47) ^ (0x9DDFEA08EB382D69 * (v15 ^ v12)))) >> 32) >> 15)));
  sub_1B1961A30(*(uint64_t **)(a1 + 384), *(const char **)a2, *(_QWORD *)(a2 + 8), v54);
}

unsigned __int8 *sub_1B19129A0(unsigned __int8 *result, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      v3 = a2 >> 3;
      v4 = &result[8 * v3];
      v5 = 8 * v3;
      do
      {
        v6 = *(_QWORD *)result;
        result += 8;
        v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void sub_1B1912A68(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B182CE18(*(_QWORD *)(a1 + 392), a2, a3, a4);
}

void sub_1B1912A70(uint64_t a1, const char *a2, uint64_t a3)
{
  sub_1B182D4E8(*(_QWORD *)(a1 + 392), a2, a3, 0);
}

uint64_t sub_1B1912A7C(uint64_t *a1, uint64_t **a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7;
  uint64_t v9[2];

  v7 = a1[1];
  v9[0] = *a1;
  v9[1] = v7;
  v9[0] = sub_1B1912C48(v9[0], v7, v9, a2, a3, a4);
  sub_1B179C734(a1 + 18, v9);
  return v9[0];
}

uint64_t sub_1B1912AD4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t *a9@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD v21[8];
  uint64_t v22;
  uint64_t v23;

  v22 = a3;
  v23 = a1;
  *a9 = a2;
  a9[1] = 0;
  a9[2] = (uint64_t)(a9 + 3);
  v11 = sub_1B1813884(a3, a2, a3, a4, a5, a6, a7, a8);
  v19 = sub_1B187A934(v11, v12, v13, v14, v15, v16, v17, v18);
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3321888768;
  v21[2] = sub_1B1912B58;
  v21[3] = &unk_1E63D08B8;
  v21[4] = &v23;
  v21[5] = &v22;
  v21[6] = a4;
  v21[7] = a9;
  return sub_1B186B104(v19, (uint64_t)v21);
}

uint64_t sub_1B1912B58(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t *v4;
  unint64_t v5;
  _QWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;

  if ((*(_BYTE *)(a2 + 221) & 0x10) != 0)
  {
    v3 = *(_QWORD **)(a1 + 40);
    v4 = **(uint64_t ***)(a1 + 32);
    v7[0] = "Mirror map";
    v7[1] = *v3;
    v8 = 0;
    v9 = a2;
    CFX::RG::TextureDescriptorReference::withSampleCount(*(_OWORD **)(a1 + 48), 1, (uint64_t)&v10);
    v5 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v9) ^ ((0x9DDFEA08EB382D69 * v9) >> 47));
    v11 = 0x9DDFEA08EB382D69 * (v5 ^ (v5 >> 47));
    v12 = v4;
    v7[0] = sub_1B1912A7C(v4, &v12, (uint64_t)v7, (uint64_t *)&v11);
    sub_1B18AE3A0(*(_DWORD **)(a1 + 56), v7);
  }
  return 0;
}

__n128 sub_1B1912C10(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 32);
  v3 = *(_OWORD *)(a2 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

void sub_1B1912C24(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B1912C48(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t **a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v10;
  _QWORD v12[2];

  v12[0] = a1;
  v12[1] = a2;
  v10 = sub_1B179C1C0(v12, 0x248u, 8u);
  return sub_1B1912468(v10, *a3, a3[1], *a4, a5, *a6);
}

void sub_1B1912DFC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B1912F60(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_1B1913528(void **a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t result;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  result = objc_msgSend_mipmapLevelCount(a2, (const char *)a2, a3, a4);
  if (result >= 2)
  {
    if ((unint64_t)objc_msgSend_width(a2, v7, v8, v9) > 1)
      return objc_msgSend_generateMipmapsForTexture_(*a1, v10, (uint64_t)a2, v12);
    if ((unint64_t)objc_msgSend_height(a2, v10, v11, v12) > 1)
      return objc_msgSend_generateMipmapsForTexture_(*a1, v10, (uint64_t)a2, v12);
    result = objc_msgSend_depth(a2, v10, v13, v12);
    if (result >= 2)
      return objc_msgSend_generateMipmapsForTexture_(*a1, v10, (uint64_t)a2, v12);
  }
  return result;
}

uint64_t sub_1B19137C4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
}

void sub_1B1913D0C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B1913E94(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B1914128(uint64_t a1)
{

}

uint64_t sub_1B1914A08(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_setNeedsDisplay(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B1914B8C(uint64_t a1)
{
  id v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD block[5];

  v2 = *(id *)(a1 + 32);
  objc_msgSend__drawAtTime_(*(void **)(a1 + 32), v3, v4, v5, *(double *)(a1 + 40));
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_1B1914C08;
  block[3] = &unk_1E63D6D80;
  block[4] = *(_QWORD *)(a1 + 32);
  dispatch_async(MEMORY[0x1E0C80D38], block);
}

void sub_1B1914C08(uint64_t a1)
{

}

void sub_1B1915154(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void (*v9)(void);

  v9 = *(void (**)(void))(a1 + 328);
  if (v9)
    v9();
  else
    sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: NOT IMPLEMENTED YET"), a3, a4, a5, a6, 0, a8, a9);
}

void sub_1B1915170(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t (*v9)(uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  const __CFArray *v20;
  const __CFArray *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CFIndex v25;
  CFDataRef v26;
  const void *Value;
  const void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  CFDataRef v43;
  CFTypeRef v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD v52[12];

  v52[11] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 64))
  {
    v9 = *(uint64_t (**)(uint64_t))(a1 + 288);
    if (v9)
    {
      if (v9 == sub_1B19153D4)
      {
        v10 = (uint64_t)sub_1B17A08A0(a1, a2, a3, a4, a5, a6, a7, a8);
        v17 = 0;
        if (v10 <= 8)
        {
          v18 = v10;
          if (v10)
          {
            if (v10 >= 1)
            {
              v19 = 0;
              do
              {
                v20 = sub_1B17A08FC(a1, v19, v11, v12, v13, v14, v15, v16);
                if (v19)
                {
                  v21 = v20;
                  v22 = 0;
                  while (sub_1B17A08FC(a1, v22, v11, v12, v13, v14, v15, v16) != v21)
                  {
                    if (v19 == ++v22)
                    {
                      v22 = v19;
                      break;
                    }
                  }
                }
                else
                {
                  v22 = 0;
                }
                v52[v19++] = v22 + 1;
              }
              while (v19 != v18);
            }
            v23 = 0;
            v24 = 0;
            v17 = 0;
            do
            {
              v17 |= v52[v24 % v18] << v23;
              ++v24;
              v23 += 4;
            }
            while (v24 != 8);
          }
        }
        *(_DWORD *)(a1 + 284) = v17;
      }
      os_unfair_lock_lock((os_unfair_lock_t)&unk_1EEF66520);
      sub_1B1919DD8();
      if (*(_QWORD *)(a1 + 336))
        sub_1B1919E50(a1);
      v25 = (*(uint64_t (**)(uint64_t, _QWORD *))(a1 + 320))(a1, v52);
      v26 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v52, v25);
      Value = CFDictionaryGetValue((CFDictionaryRef)qword_1EEF66528, v26);
      if (Value)
      {
        v28 = Value;
        sub_1B1919004(v26);
      }
      else
      {
        v36 = (*(uint64_t (**)(uint64_t))(a1 + 288))(a1 + 208);
        if (!v36)
        {
          sub_1B17A14D4(a1, 0, v37, v38, v39, v40, v41, v42);
LABEL_34:
          CFRelease(v26);
          os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EEF66520);
          return;
        }
        v28 = (const void *)v36;
        CFDictionarySetValue((CFMutableDictionaryRef)qword_1EEF66530, v26, (const void *)1);
        CFDictionarySetValue((CFMutableDictionaryRef)qword_1EEF66528, v26, v28);
        CFRelease(v28);
      }
      v43 = *(CFDataRef *)(a1 + 336);
      if (v43 != v26)
      {
        if (v43)
        {
          CFRelease(v43);
          *(_QWORD *)(a1 + 336) = 0;
        }
        if (v26)
          v44 = CFRetain(v26);
        else
          v44 = 0;
        *(_QWORD *)(a1 + 336) = v44;
      }
      v45 = (const void *)sub_1B18741B0((uint64_t)v28, v29, v30, v31, v32, v33, v34, v35);
      sub_1B17A14D4(a1, (uint64_t)v45, v46, v47, v48, v49, v50, v51);
      if (v45)
        CFRelease(v45);
      goto LABEL_34;
    }
  }
}

uint64_t sub_1B19153D4(uint64_t a1)
{
  return sub_1B18E3BCC(*(char *)(a1 + 68), *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 48), *(int *)(a1 + 52), *(_DWORD *)(a1 + 76), *(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 8), *(float *)(a1 + 16));
}

void sub_1B19153F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(uint64_t (**)(uint64_t))(a1 + 288) == sub_1B19153D4)
  {
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
    *(_DWORD *)(a1 + 284) = -1;
  }
}

void sub_1B1915434(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_QWORD *)(a1 + 64))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1EEF66520);
    sub_1B1919E50(a1);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EEF66520);
  }
  sub_1B17A14D4(a1, 0, a3, a4, a5, a6, a7, a8);
}

void sub_1B1915480(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 *v8;
  __int128 v9;

  switch((int)a2)
  {
    case 0:
      v8 = &xmmword_1E63D3A70;
      goto LABEL_11;
    case 1:
      v8 = &xmmword_1E63D2D98;
      goto LABEL_11;
    case 2:
      v8 = &xmmword_1E63D3B00;
      goto LABEL_11;
    case 3:
      v8 = &xmmword_1E63D3DD0;
      goto LABEL_11;
    case 4:
      v8 = &xmmword_1E63D3440;
      goto LABEL_11;
    case 5:
      v8 = &xmmword_1E63D3290;
      goto LABEL_11;
    case 6:
      v8 = &xmmword_1E63D4010;
      goto LABEL_11;
    case 7:
      v8 = &xmmword_1E63D3260;
      goto LABEL_11;
    case 8:
      v8 = &xmmword_1E63D3F20;
LABEL_11:
      v9 = v8[1];
      *(_OWORD *)(a1 + 288) = *v8;
      *(_OWORD *)(a1 + 304) = v9;
      *(_OWORD *)(a1 + 320) = v8[2];
      break;
    default:
      break;
  }
  sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B1915520(_OWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v9;
  _OWORD __s1[3];

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  v9 = a1[19];
  __s1[0] = a1[18];
  __s1[1] = v9;
  __s1[2] = a1[20];
  if (!memcmp(__s1, &xmmword_1E63D2D98, 0x30uLL))
    return 1;
  if (!memcmp(__s1, &xmmword_1E63D3B00, 0x30uLL))
    return 2;
  if (!memcmp(__s1, &xmmword_1E63D3440, 0x30uLL))
    return 4;
  if (!memcmp(__s1, &xmmword_1E63D3290, 0x30uLL))
    return 5;
  if (!memcmp(__s1, &xmmword_1E63D4010, 0x30uLL))
    return 6;
  if (!memcmp(__s1, &xmmword_1E63D3260, 0x30uLL))
    return 7;
  if (!memcmp(__s1, &xmmword_1E63D3F20, 0x30uLL))
    return 8;
  if (!memcmp(__s1, &xmmword_1E63D3DD0, 0x30uLL))
    return 3;
  return 0;
}

__n128 sub_1B1915674@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  __int128 v10;
  __n128 result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a2, a3, a4, a5, a6, a7, (uint64_t)"geometry");
  v10 = *(_OWORD *)(a1 + 304);
  *(_OWORD *)a8 = *(_OWORD *)(a1 + 288);
  *(_OWORD *)(a8 + 16) = v10;
  result = *(__n128 *)(a1 + 320);
  *(__n128 *)(a8 + 32) = result;
  return result;
}

uint64_t sub_1B19156CC()
{
  if (qword_1ED4CEDA0 != -1)
    dispatch_once(&qword_1ED4CEDA0, &unk_1E63D11D0);
  return qword_1ED4CEDA8;
}

double sub_1B191570C()
{
  void *v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double result;

  if (!qword_1ED4CEDA8)
  {
    v0 = (void *)sub_1B179CB60(&qword_1ED4CEDA8);
    qword_1ED4CEDA8 = (uint64_t)v0;
    v1 = (const void *)sub_1B17A12B4();
    sub_1B19C3200(v0, v1);
    sub_1B19C326C(CFSTR("width"), 0xD0u, 1, 0, 0, 0, v2, v3);
    sub_1B19C326C(CFSTR("height"), 0xD4u, 1, 0, 0, 0, v4, v5);
    sub_1B19C326C(CFSTR("length"), 0xD8u, 1, 0, 0, 0, v6, v7);
    sub_1B19C326C(CFSTR("chamferRadius"), 0xE0u, 1, 0, 0, 0, v8, v9);
    sub_1B19C326C(CFSTR("topRadius"), 0xE4u, 1, 0, 0, 0, v10, v11);
    sub_1B19C326C(CFSTR("radius"), 0xDCu, 1, 0, 0, 0, v12, v13);
    sub_1B19C326C(CFSTR("innerRadius"), 0xE8u, 1, 0, 0, 0, v14, v15);
    sub_1B19C326C(CFSTR("pipeRadius"), 0xECu, 1, 0, 0, 0, v16, v17);
    sub_1B19C326C(CFSTR("chamferSegmentCount"), 0x104u, 2, 0, 0, 0, v18, v19);
    sub_1B19C326C(CFSTR("heightSegmentCount"), 0xFCu, 2, 0, 0, 0, v20, v21);
    sub_1B19C326C(CFSTR("lengthSegmentCount"), 0x100u, 2, 0, 0, 0, v22, v23);
    sub_1B19C326C(CFSTR("widthSegmentCount"), 0xF8u, 2, 0, 0, 0, v24, v25);
    sub_1B19C326C(CFSTR("capSegmentCount"), 0x110u, 1, 0, 0, 0, v26, v27);
    sub_1B19C326C(CFSTR("radialSegmentCount"), 0x108u, 2, 0, 0, 0, v28, v29);
    sub_1B19C326C(CFSTR("cornerSegmentCount"), 0x104u, 2, 0, 0, 0, v30, v31);
    sub_1B19C326C(CFSTR("segmentCount"), 0xF4u, 2, 0, 0, 0, v32, v33);
    sub_1B19C326C(CFSTR("radialSpan"), 0xF0u, 1, 0, 0, 0, v34, v35);
    sub_1B19C326C(CFSTR("pipeSegmentCount"), 0x10Cu, 2, 0, 0, 0, v36, v37);
    sub_1B19C3258();
    unk_1ED4BEB70 = xmmword_1E63D3110;
    xmmword_1ED4BEB58 = xmmword_1E63D3100;
    *(_QWORD *)&result = 0x1B191A268;
    unk_1ED4BEB80 = xmmword_1E63D3120;
    unk_1ED4BEB90 = *(_OWORD *)algn_1E63D3130;
    qword_1ED4BEBA0 = 0;
    qword_1ED4BEBB0 = (uint64_t)sub_1B191A26C;
  }
  return result;
}

float32x2_t sub_1B19159F8(float32x2_t *a1, float32x2_t *a2, float32x2_t result, float32_t a4)
{
  BOOL v4;

  if (a1)
    v4 = a2 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    result.f32[1] = a4;
    a1[1].i32[0] = 0;
    *a1 = vmul_f32(result, (float32x2_t)0xBF000000BF000000);
    result = vmul_f32(result, (float32x2_t)0x3F0000003F000000);
    a2[1].i32[0] = 0;
    *a2 = result;
  }
  return result;
}

float32x2_t sub_1B1915A34(float32x2_t *a1, float32x2_t *a2, float32x2_t *a3)
{
  BOOL v3;
  float32x2_t v4;
  float32x2_t result;

  if (a2)
    v3 = a3 == 0;
  else
    v3 = 1;
  if (!v3)
  {
    v4 = a1[26];
    a2[1].i32[0] = 0;
    *a2 = vmul_f32(v4, (float32x2_t)0xBF000000BF000000);
    result = vmul_f32(v4, (float32x2_t)0x3F0000003F000000);
    a3[1].i32[0] = 0;
    *a3 = result;
  }
  return result;
}

float sub_1B1915A70(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = sub_1B1919070(a1, a2);
  if (v2)
    return *(float *)v2;
  else
    return 0.0;
}

BOOL sub_1B1915A94(_OWORD *a1, float a2, float a3)
{
  float v3;
  __int128 v4;

  if (a1)
  {
    v3 = sqrtf((float)(a3 * a3) + (float)(a2 * a2)) * 0.5;
    *(_QWORD *)&v4 = 0;
    DWORD2(v4) = 0;
    *((float *)&v4 + 3) = v3;
    *a1 = v4;
  }
  return a1 != 0;
}

BOOL sub_1B1915AC4(uint64_t a1, _OWORD *a2)
{
  __int128 v2;

  if (a2)
  {
    *(_QWORD *)&v2 = 0;
    DWORD2(v2) = 0;
    *((float *)&v2 + 3) = sqrtf((float)(*(float *)(a1 + 212) * *(float *)(a1 + 212))+ (float)(*(float *)(a1 + 208) * *(float *)(a1 + 208)))* 0.5;
    *a2 = v2;
  }
  return a2 != 0;
}

uint64_t sub_1B1915AF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 296))(a1, a2, a3);
}

uint64_t sub_1B1915B5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 304))(a1, a2);
}

void sub_1B1915BB0(float32x2_t *a1, uint64_t a2, unsigned int *a3, __n128 *a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, __n128 a14, uint64_t a15)
{
  float32x2_t v15;
  float v16;
  float32x2_t v17;
  float v18;
  float v19;
  uint64_t v20;
  float v21;
  unsigned int v22;
  unsigned int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float32x2_t v32;
  float64x2_t v33;
  _OWORD *v34;
  int v35;
  uint32x2_t v36;
  uint32x2_t v37;
  uint64x2_t v38;

  if (a6 >= 2)
  {
    if (a6 == 2)
      sub_1B17A2264(a1, a2, a3, (uint64_t)a4, a5, 2, a7, a8, a15);
  }
  else
  {
    v15 = a1[26];
    v16 = a1[28].f32[0];
    v17 = vmul_f32(v15, (float32x2_t)0x3F0000003F000000);
    if (v16 <= 0.0)
    {
      if (a2 >= 1)
      {
        v32 = vneg_f32(v17);
        v33 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
        v34 = (_OWORD *)a5;
        do
        {
          v35 = 214013 * *a3 + 2531011;
          *a3 = 214013 * v35 + 2531011;
          v36.i32[0] = v35;
          v36.i32[1] = 214013 * v35 + 2531011;
          v37 = vshr_n_u32(v36, 0x10uLL);
          v38.i64[0] = v37.u32[0];
          v38.i64[1] = v37.u32[1];
          a14.n128_u64[0] = (unint64_t)vmla_f32(v32, v15, vcvt_f32_f64(vmulq_f64(vcvtq_f64_u64(v38), v33)));
          a14.n128_u32[2] = 0;
          *a4 = a14;
          if (a5)
            *v34 = xmmword_1B2244D90;
          ++v34;
          ++a4;
          --a2;
        }
        while (a2);
      }
    }
    else
    {
      if (v17.f32[0] >= v17.f32[1])
        v18 = v17.f32[1];
      else
        v18 = v17.f32[0];
      if (v16 >= v18)
        v19 = v18;
      else
        v19 = a1[28].f32[0];
      if (a2 >= 1)
      {
        v20 = 0;
        v21 = -v17.f32[0];
        v17.f32[0] = v19 - v17.f32[0];
        do
        {
          v22 = *a3;
          do
          {
            v23 = 214013 * v22 + 2531011;
            v24 = (double)HIWORD(v23) * 0.0000152590219;
            v25 = v21 + (float)(v24 * v15.f32[0]);
            v22 = 214013 * v23 + 2531011;
            v26 = (double)HIWORD(v22) * 0.0000152590219;
            v27 = (float)(v26 * v15.f32[1]) - v17.f32[1];
            v28 = v17.f32[0] + fabsf(v25);
            if (v28 <= 0.0)
              break;
            v29 = (float)(v19 - v17.f32[1]) + fabsf(v27);
            v30 = (float)(v29 * v29) + (float)(v28 * v28);
          }
          while (v29 > 0.0 && v30 > (float)(v19 * v19));
          *a3 = v22;
          a4[v20] = (__n128)__PAIR64__(LODWORD(v27), LODWORD(v25));
          if (a5)
            *(_OWORD *)(a5 + 16 * v20) = xmmword_1B2244D90;
          ++v20;
        }
        while (v20 != a2);
      }
    }
  }
}

float sub_1B1915D4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(float *)(a1 + 224);
}

uint64_t sub_1B1915D94(uint64_t a1)
{
  return sub_1B19077CC(*(char *)(a1 + 68), *(int *)(a1 + 40), *(int *)(a1 + 44), *(int *)(a1 + 52), *(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 16));
}

void sub_1B1915DB0(_DWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  sub_1B19190E4((uint64_t)a1, 0, 1.0);
  sub_1B19190E4((uint64_t)a1, 1, 1.0);
  sub_1B19190E4((uint64_t)a1, 3, 0.0);
  if (a1[62] != 1)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[62] = 1;
  }
  if (a1[63] != 1)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[63] = 1;
  }
  if (a1[65] != 10)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[65] = 10;
  }
}

uint64_t sub_1B1915E4C(_DWORD *a1, _DWORD *a2)
{
  *a2 = 0;
  a2[1] = a1[69];
  a2[2] = a1[52];
  a2[3] = a1[53];
  a2[4] = a1[56];
  a2[5] = a1[62];
  a2[6] = a1[63];
  a2[7] = a1[65];
  a2[8] = a1[71];
  return 36;
}

float32x2_t sub_1B1915E98(float32x2_t *a1, float32x2_t *a2, float32x2_t result, float32_t a4, float a5)
{
  BOOL v5;

  if (a1)
    v5 = a2 == 0;
  else
    v5 = 1;
  if (!v5)
  {
    result.f32[1] = a4;
    a1[1].f32[0] = a5 * -0.5;
    *a1 = vmul_f32(result, (float32x2_t)0xBF000000BF000000);
    result = vmul_f32(result, (float32x2_t)0x3F0000003F000000);
    a2[1].f32[0] = a5 * 0.5;
    *a2 = result;
  }
  return result;
}

float32_t sub_1B1915EE4(float32x2_t *a1, float32x2_t *a2, float32x2_t *a3)
{
  BOOL v3;
  float v4;
  float32x2_t v5;
  float32_t result;

  if (a2)
    v3 = a3 == 0;
  else
    v3 = 1;
  if (!v3)
  {
    v4 = a1[27].f32[0];
    v5 = a1[26];
    a2[1].f32[0] = v4 * -0.5;
    *a2 = vmul_f32(v5, (float32x2_t)0xBF000000BF000000);
    result = v4 * 0.5;
    a3[1].f32[0] = result;
    *a3 = vmul_f32(v5, (float32x2_t)0x3F0000003F000000);
  }
  return result;
}

BOOL sub_1B1915F34(_OWORD *a1, float a2, float a3, float a4)
{
  float v4;
  __int128 v5;

  if (a1)
  {
    v4 = sqrtf((float)((float)(a3 * a3) + (float)(a2 * a2)) + (float)(a4 * a4)) * 0.5;
    *(_QWORD *)&v5 = 0;
    DWORD2(v5) = 0;
    *((float *)&v5 + 3) = v4;
    *a1 = v5;
  }
  return a1 != 0;
}

BOOL sub_1B1915F68(float *a1, _OWORD *a2)
{
  __int128 v2;

  if (a2)
  {
    *(_QWORD *)&v2 = 0;
    DWORD2(v2) = 0;
    *((float *)&v2 + 3) = sqrtf((float)((float)(a1[53] * a1[53]) + (float)(a1[52] * a1[52])) + (float)(a1[54] * a1[54]))
                        * 0.5;
    *a2 = v2;
  }
  return a2 != 0;
}

void sub_1B1915FA4(float *cf, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, float32x4_t a13, double a14, float32x4_t a15, uint64_t a16)
{
  __int128 v16;
  int v17;
  _OWORD *v19;
  float v23;
  float32x2_t v24;
  float v25;
  float v26;
  float32x4_t v27;
  float v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float v32;
  float v33;
  int8x16_t v34;
  float32x4_t *v35;
  unsigned int v36;
  float v37;
  float v38;
  unsigned int v39;
  float v40;
  float v41;
  unsigned int v42;
  float v43;
  float v44;
  _BOOL4 v45;
  _BOOL4 v46;
  char v47;
  unsigned int v48;
  _BOOL4 v49;
  uint64_t v50;
  char v51;
  char v52;
  float v53;
  float v54;
  float v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  char v63;
  float32x4_t v64;
  float32x4_t v65;
  int v66;
  __int32 *v67;
  float v68;
  int8x16_t v69;
  __int32 *v70;
  float32x4_t v71;
  float v72;
  float32x4_t v73;
  int32x4_t v74;
  float32x2_t v75;
  float32x2_t v76;
  uint64_t v77;
  float32x2_t v78;
  float64x2_t v79;
  unsigned int v80;
  int v81;
  uint32x2_t v82;
  uint32x2_t v83;
  uint64x2_t v84;
  float v85;
  float32x4_t v86;
  float32x4_t v87;
  float v88;
  int v89;
  float v90;
  int32x4_t v91;
  float32x2_t v92;
  float32x2_t v93;
  float32x2_t v94;
  float v95;
  float64x2_t v96;
  float32x4_t *v97;
  int v98;
  uint32x2_t v99;
  uint32x2_t v100;
  uint64x2_t v101;
  unsigned int v102;
  float v103;
  float32x4_t v104;
  int32x4_t v105;
  float32x2_t v106;
  float32x2_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  int8x16_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  int8x16_t v116;

  v17 = a6;
  v19 = (_OWORD *)a4;
  if (!cf)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  v23 = cf[54];
  v24 = *(float32x2_t *)(cf + 52);
  *(float32x2_t *)a15.f32 = vmul_f32(v24, (float32x2_t)0x3F0000003F000000);
  v25 = v23 * 0.5;
  if (a15.f32[0] >= a15.f32[1])
    v26 = a15.f32[1];
  else
    v26 = a15.f32[0];
  if (v26 >= v25)
    v26 = v23 * 0.5;
  if (cf[56] >= v26)
    *(float *)&a11 = v26;
  else
    *(float *)&a11 = cf[56];
  if (v17 == 2)
  {
    sub_1B17A2264(cf, a2, a3, (uint64_t)v19, a5, 2, a7, a8, a16);
  }
  else
  {
    v27 = a15;
    v27.f32[2] = v23 * 0.5;
    v28 = *(float *)&a11 * *(float *)&a11;
    v29 = vsubq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a11, 0));
    if (v17 == 1)
    {
      if (*(float *)&a11 <= 0.0)
      {
        if (a2 >= 1)
        {
          v94 = vneg_f32(*(float32x2_t *)a15.f32);
          v95 = -v25;
          v96 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
          v97 = (float32x4_t *)a5;
          do
          {
            v98 = 214013 * *a3 + 2531011;
            v99.i32[0] = v98;
            v99.i32[1] = 214013 * v98 + 2531011;
            v100 = vshr_n_u32(v99, 0x10uLL);
            v101.i64[0] = v100.u32[0];
            v101.i64[1] = v100.u32[1];
            v104 = (float32x4_t)vmulq_f64(vcvtq_f64_u64(v101), v96);
            *(float32x2_t *)v104.f32 = vmla_f32(v94, v24, vcvt_f32_f64((float64x2_t)v104));
            v102 = 214013 * (214013 * v98 + 2531011) + 2531011;
            *a3 = v102;
            v103 = (double)HIWORD(v102) * 0.0000152590219;
            v104.f32[2] = v95 + (float)(v103 * v23);
            *v19 = v104;
            if (a5)
            {
              v105 = (int32x4_t)vmulq_f32(v104, v104);
              v105.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v105, 2), vadd_f32(*(float32x2_t *)v105.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v105.i8, 1))).u32[0];
              v106 = vrsqrte_f32((float32x2_t)v105.u32[0]);
              v107 = vmul_f32(v106, vrsqrts_f32((float32x2_t)v105.u32[0], vmul_f32(v106, v106)));
              *v97 = vmulq_n_f32(v104, vmul_f32(v107, vrsqrts_f32((float32x2_t)v105.u32[0], vmul_f32(v107, v107))).f32[0]);
            }
            ++v97;
            ++v19;
            --a2;
          }
          while (a2);
        }
      }
      else if (a2 >= 1)
      {
        v77 = 0;
        v78 = vneg_f32(*(float32x2_t *)a15.f32);
        v79 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
        do
        {
          v80 = *a3;
          do
          {
            v81 = 214013 * v80 + 2531011;
            v82.i32[0] = v81;
            v82.i32[1] = 214013 * v81 + 2531011;
            v83 = vshr_n_u32(v82, 0x10uLL);
            v84.i64[0] = v83.u32[0];
            v84.i64[1] = v83.u32[1];
            v86 = (float32x4_t)vmulq_f64(vcvtq_f64_u64(v84), v79);
            v80 = 214013 * (214013 * v81 + 2531011) + 2531011;
            *(float32x2_t *)v86.f32 = vmla_f32(v78, v24, vcvt_f32_f64((float64x2_t)v86));
            v85 = (double)HIWORD(v80) * 0.0000152590219;
            v86.f32[2] = (float)(v85 * v23) - v25;
            v87 = vsubq_f32(vabsq_f32(v86), v29);
            v88 = v87.f32[1];
            v89 = v87.f32[1] > 0.0;
            if (v87.f32[0] > 0.0)
              ++v89;
            if (v87.f32[2] > 0.0)
              ++v89;
            if (v89 == 2)
            {
              if (v87.f32[0] <= v87.f32[1])
                v87.f32[0] = v87.f32[1];
              if (v87.f32[1] <= v87.f32[2])
                v88 = v87.f32[2];
              v90 = (float)(v88 * v88) + (float)(v87.f32[0] * v87.f32[0]);
            }
            else
            {
              if (v89 != 3)
                break;
              v90 = (float)((float)(v87.f32[1] * v87.f32[1]) + (float)(v87.f32[0] * v87.f32[0]))
                  + (float)(v87.f32[2] * v87.f32[2]);
            }
          }
          while (v90 > v28);
          *a3 = v80;
          v19[v77] = v86;
          if (a5)
          {
            v91 = (int32x4_t)vmulq_f32(v86, v86);
            v91.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v91, 2), vadd_f32(*(float32x2_t *)v91.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v91.i8, 1))).u32[0];
            v92 = vrsqrte_f32((float32x2_t)v91.u32[0]);
            v93 = vmul_f32(v92, vrsqrts_f32((float32x2_t)v91.u32[0], vmul_f32(v92, v92)));
            *(float32x4_t *)(a5 + 16 * v77) = vmulq_n_f32(v86, vmul_f32(v93, vrsqrts_f32((float32x2_t)v91.u32[0], vmul_f32(v93, v93))).f32[0]);
          }
          ++v77;
        }
        while (v77 != a2);
      }
    }
    else if (!v17 && a2 >= 1)
    {
      a13.f32[0] = a15.f32[1] * v25;
      v30 = a13;
      v30.f32[1] = a15.f32[0] * v25;
      v30.f32[2] = a15.f32[0] * a15.f32[1];
      v31 = vmulq_n_f32(v30, 1.0/ (float)((float)(a15.f32[0] * a15.f32[1]) + (float)((float)(a15.f32[1] * v25) + (float)(a15.f32[0] * v25))));
      v32 = v31.f32[0] + v31.f32[0];
      v33 = (float)(v31.f32[0] + v31.f32[0]) + v31.f32[1] * 2.0;
      v34.i64[0] = 0x8000000080000000;
      v34.i64[1] = 0x8000000080000000;
      v35 = (float32x4_t *)a5;
      do
      {
        v36 = 214013 * *a3 + 2531011;
        v37 = (double)HIWORD(v36) * 0.0000152590219;
        v38 = v37 * 2.0 + -1.0;
        v39 = 214013 * v36 + 2531011;
        v40 = (double)HIWORD(v39) * 0.0000152590219;
        v41 = v40 * 2.0 + -1.0;
        v42 = 214013 * v39 + 2531011;
        *a3 = v42;
        v43 = (double)HIWORD(v42) * 0.0000152590219;
        v44 = v43 + v43;
        v45 = v31.f32[2] == 1.0;
        if ((float)(v44 - v33) < v31.f32[2])
          v45 = 1;
        v46 = v31.f32[1] == 1.0;
        if ((float)(v44 - v32) < v31.f32[1])
          v46 = 1;
        if (v44 < v33)
          v45 = v46;
        v47 = -1;
        if (v44 < v33)
          v48 = 1;
        else
          v48 = 2;
        v49 = v31.f32[0] == 1.0;
        if (v44 < v31.f32[0])
          v49 = 1;
        if (v44 < v32)
          v47 = 2;
        else
          v49 = v45;
        if (v44 < v32)
          v50 = 0;
        else
          v50 = v48;
        if ((_DWORD)v50 == 2)
          v51 = 0;
        else
          v51 = v50 + 1;
        v52 = v50 + v47;
        v113 = v27;
        v53 = *(float *)((unint64_t)&v113 | (4 * v50));
        if (!v49)
          v53 = -v53;
        v114 = 0uLL;
        *(float *)((unint64_t)&v114 & 0xFFFFFFFFFFFFFFF3 | (4 * (v50 & 3))) = v53;
        v54 = *(float *)((unint64_t)&v113 & 0xFFFFFFFFFFFFFFF3 | (4 * (v51 & 3))) * v38;
        v115 = v114;
        *(float *)((unint64_t)&v115 & 0xFFFFFFFFFFFFFFF3 | (4 * (v51 & 3))) = v54;
        v55 = *(float *)((unint64_t)&v113 & 0xFFFFFFFFFFFFFFF3 | (4 * (v52 & 3))) * v41;
        v116 = (int8x16_t)v115;
        *(float *)((unint64_t)&v116 & 0xFFFFFFFFFFFFFFF3 | (4 * (v52 & 3))) = v55;
        v56 = v116;
        v57 = (float32x4_t)v116;
        v57.i32[3] = HIDWORD(v16);
        if (*(float *)&a11 <= 0.0)
          goto LABEL_62;
        v58 = vsubq_f32(vabsq_f32((float32x4_t)v116), v29);
        v59 = v58.f32[1] > 0.0;
        if (v58.f32[0] > 0.0)
          ++v59;
        if (v58.f32[2] > 0.0)
          ++v59;
        if (v59 == 3)
        {
          v71 = vmulq_f32(v58, v58);
          v72 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 2), vaddq_f32(v71, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 1))).f32[0];
          if (v72 > v28)
          {
            v73 = vmlaq_n_f32(v29, v58, *(float *)&a11 / sqrtf(v72));
            *(int8x8_t *)v57.f32 = vbsl_s8((int8x8_t)0x8000000080000000, *(int8x8_t *)v73.f32, *(int8x8_t *)v116.i8);
            v58.i32[0] = v73.i32[2];
            v56.i32[0] = v116.i32[2];
            v57.i32[2] = vbslq_s8(v34, (int8x16_t)v58, v56).u32[0];
LABEL_61:
            v57.i32[3] = HIDWORD(v16);
          }
        }
        else if (v59 == 2)
        {
          v60 = 2 * (v58.f32[0] > 0.0);
          if (v58.f32[1] <= 0.0)
            v61 = 1;
          else
            v61 = 2;
          if ((_DWORD)v50)
            v61 = 0;
          if ((_DWORD)v50 != 1)
            v60 = v61;
          if ((_DWORD)v50 == 2)
            v62 = v58.f32[1] <= 0.0;
          else
            v62 = v60;
          if ((_DWORD)v62 == 2)
            v63 = 0;
          else
            v63 = v62 + 1;
          v108 = v58;
          *(_DWORD *)((unint64_t)&v108 | (4 * v62)) = 0;
          v64 = v108;
          v65 = vmulq_f32(v64, v64);
          v66 = v62 + 2 + ((int)v62 + 2) / 3u;
          v65.f32[0] = *(float *)&a11
                     / sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 2), vaddq_f32(v65, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v65.f32, 1))).f32[0]);
          v67 = (__int32 *)((unint64_t)&v111 & 0xFFFFFFFFFFFFFFF3 | (4 * (v63 & 3)));
          v109 = v29;
          v68 = *(float *)((unint64_t)&v109 & 0xFFFFFFFFFFFFFFF3 | (4 * (v63 & 3)));
          v110 = v108;
          v64.f32[0] = v68
                     + (float)(*(float *)((unint64_t)&v110 & 0xFFFFFFFFFFFFFFF3 | (4 * (v63 & 3)))
                             * v65.f32[0]);
          v111 = v56;
          v56.i32[0] = *v67;
          *v67 = vbslq_s8(v34, (int8x16_t)v64, v56).u32[0];
          v69 = v111;
          v70 = (__int32 *)((unint64_t)&v112 & 0xFFFFFFFFFFFFFFF3 | (4 * (v66 & 3)));
          v64.f32[0] = *(float *)((unint64_t)&v109 & 0xFFFFFFFFFFFFFFF3 | (4 * (v66 & 3)))
                     + (float)(*(float *)((unint64_t)&v110 & 0xFFFFFFFFFFFFFFF3 | (4 * (v66 & 3)))
                             * v65.f32[0]);
          v112 = (float32x4_t)v111;
          v69.i32[0] = *v70;
          *v70 = vbslq_s8(v34, (int8x16_t)v64, v69).u32[0];
          v57 = v112;
          goto LABEL_61;
        }
LABEL_62:
        *v19 = v57;
        if (a5)
        {
          v74 = (int32x4_t)vmulq_f32(v57, v57);
          v74.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v74, 2), vadd_f32(*(float32x2_t *)v74.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v74.i8, 1))).u32[0];
          v75 = vrsqrte_f32((float32x2_t)v74.u32[0]);
          v76 = vmul_f32(v75, vrsqrts_f32((float32x2_t)v74.u32[0], vmul_f32(v75, v75)));
          *v35 = vmulq_n_f32(v57, vmul_f32(v76, vrsqrts_f32((float32x2_t)v74.u32[0], vmul_f32(v76, v76))).f32[0]);
        }
        ++v35;
        ++v19;
        HIDWORD(v16) = v57.i32[3];
        --a2;
      }
      while (a2);
    }
  }
}

float sub_1B1916680(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(float *)(a1 + 208);
}

float sub_1B19166C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(float *)(a1 + 212);
}

float sub_1B1916710(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(float *)(a1 + 216);
}

void sub_1B1916758(_DWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  sub_1B19190E4((uint64_t)a1, 0, 1.0);
  sub_1B19190E4((uint64_t)a1, 1, 1.0);
  sub_1B19190E4((uint64_t)a1, 2, 1.0);
  sub_1B19190E4((uint64_t)a1, 3, 0.0);
  if (a1[62] != 1)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[62] = 1;
  }
  if (a1[63] != 1)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[63] = 1;
  }
  if (a1[64] != 1)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[64] = 1;
  }
  if (a1[65] != 10)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[65] = 10;
  }
}

uint64_t sub_1B1916820(_DWORD *a1, _DWORD *a2)
{
  *a2 = 1;
  a2[1] = a1[69];
  a2[2] = a1[52];
  a2[3] = a1[53];
  a2[4] = a1[54];
  a2[5] = a1[56];
  a2[6] = a1[62];
  a2[7] = a1[63];
  a2[8] = a1[64];
  a2[9] = a1[65];
  a2[10] = a1[71];
  return 44;
}

double sub_1B1916880(uint64_t a1, uint64_t a2, int32x4_t a3, float a4, float a5)
{
  BOOL v5;
  int32x4_t v6;

  if (a1)
    v5 = a2 == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = a3;
    *(float *)&v6.i32[1] = a5;
    *(float32x2_t *)v6.i8 = vmul_f32(*(float32x2_t *)v6.i8, (float32x2_t)0xBF000000BF000000);
    *(_DWORD *)(a1 + 8) = v6.i32[1];
    *(_QWORD *)a1 = vzip1q_s32(v6, a3).u32[0];
    *(float *)a3.i32 = *(float *)a3.i32 * 0.5;
    *(float *)&a3.i32[1] = a4;
    *(float *)(a2 + 8) = a5 * 0.5;
    *(_QWORD *)a2 = a3.i64[0];
  }
  return *(double *)a3.i64;
}

float sub_1B19168D4(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x4_t a9, int32x4_t a10)
{
  BOOL v13;
  uint64_t v14;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (a2)
    v13 = a3 == 0;
  else
    v13 = 1;
  if (!v13)
  {
    a9.i32[0] = a1[54];
    a10.i32[0] = a1[52];
    *(float *)&v14 = *(float *)a10.i32 * 0.5;
    a10.i32[1] = a9.i32[0];
    *(float32x2_t *)a10.i8 = vmul_f32(*(float32x2_t *)a10.i8, (float32x2_t)0xBF000000BF000000);
    HIDWORD(v14) = a1[53];
    *(_DWORD *)(a2 + 8) = a10.i32[1];
    *(_QWORD *)a2 = vzip1q_s32(a10, a9).u32[0];
    *(float *)a9.i32 = *(float *)a9.i32 * 0.5;
    *(_DWORD *)(a3 + 8) = a9.i32[0];
    *(_QWORD *)a3 = v14;
  }
  return *(float *)a9.i32;
}

BOOL sub_1B191697C(int32x4_t *a1, int32x4_t a2, double a3, float a4)
{
  if (a1)
  {
    HIDWORD(a3) = sqrtf((float)((float)(*(float *)&a3 * *(float *)&a3) + (float)(*(float *)a2.i32 * *(float *)a2.i32))+ (float)(a4 * a4));
    *(float32x2_t *)a2.i8 = vmul_f32(*(float32x2_t *)&a3, (float32x2_t)0x3F0000003F000000);
    *a1 = vtrn1q_s32((int32x4_t)0, vzip1q_s32(a2, a2));
  }
  return a1 != 0;
}

BOOL sub_1B19169B8(uint64_t a1, int32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x4_t a9)
{
  float32x2_t v11;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
    if (!a2)
      return a2 != 0;
    goto LABEL_3;
  }
  if (a2)
  {
LABEL_3:
    v11.i32[0] = *(_DWORD *)(a1 + 212);
    v11.i32[1] = sqrtf((float)((float)(v11.f32[0] * v11.f32[0]) + (float)(*(float *)(a1 + 208) * *(float *)(a1 + 208)))+ (float)(*(float *)(a1 + 216) * *(float *)(a1 + 216)));
    *(float32x2_t *)a9.i8 = vmul_f32(v11, (float32x2_t)0x3F0000003F000000);
    *a2 = vtrn1q_s32((int32x4_t)0, vzip1q_s32(a9, a9));
  }
  return a2 != 0;
}

void sub_1B1916A48(float *cf, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, float32x4_t a15, uint64_t a16)
{
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int v20;
  __n128 *v22;
  float v26;
  float v27;
  float v28;
  float32x4_t v29;
  float v30;
  __n128 *v31;
  unsigned int v32;
  float32_t v33;
  float v34;
  float v35;
  unsigned int v36;
  unsigned int v37;
  float v38;
  float32_t v39;
  int32x4_t v40;
  float32x2_t v41;
  float32x2_t v42;
  uint64_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int32x4_t v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int32x4_t v60;
  int8x16_t v61;
  int32x4_t v62;
  int8x16_t v63;
  int32x4_t v64;
  int8x16_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  __int32 v69;
  uint64_t v70;
  float v71;
  unsigned int v72;
  float v73;
  unsigned int v74;
  float v75;
  unsigned int v76;
  float v77;
  float32x4_t v78;
  unsigned int v79;
  float v80;
  int32x4_t v81;
  float32x2_t v82;
  float32x2_t v83;
  __int128 v84;
  float v85;
  uint64_t v86;

  v20 = a6;
  v22 = (__n128 *)a4;
  v86 = *MEMORY[0x1E0C80C00];
  if (!cf)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  v27 = cf[52];
  v26 = cf[53];
  v28 = cf[54];
  v29.f32[0] = v27 * 0.5;
  v30 = v28 * 0.5;
  if (v20)
  {
    if (v20 == 2)
    {
      sub_1B17A2264(cf, a2, a3, (uint64_t)v22, a5, 2, a7, a8, a16);
    }
    else if (v20 == 1 && a2 >= 1)
    {
      v31 = (__n128 *)a5;
      do
      {
        v32 = 214013 * *a3 + 2531011;
        a15.f32[0] = (double)HIWORD(v32) * 0.0000152590219;
        v33 = v26 * a15.f32[0];
        a15.f32[0] = v26 - (float)(v26 * a15.f32[0]);
        v34 = (float)(v29.f32[0] * a15.f32[0]) / v26;
        v35 = (float)(v30 * a15.f32[0]) / v26;
        v36 = 214013 * v32 + 2531011;
        a15.f32[0] = (double)HIWORD(v36) * 0.0000152590219;
        a15.f32[0] = (a15.f32[0] * 2.0 + -1.0) * v34;
        v37 = 214013 * v36 + 2531011;
        *a3 = v37;
        v38 = (double)HIWORD(v37) * 0.0000152590219;
        v39 = (v38 * 2.0 + -1.0) * v35;
        a15.f32[1] = v33;
        a15.f32[2] = v39;
        *v22 = (__n128)a15;
        if (a5)
        {
          v40 = (int32x4_t)vmulq_f32(a15, a15);
          v40.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v40, 2), vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.i8, 1))).u32[0];
          v41 = vrsqrte_f32((float32x2_t)v40.u32[0]);
          v42 = vmul_f32(v41, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(v41, v41)));
          a15 = vmulq_n_f32(a15, vmul_f32(v42, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(v42, v42))).f32[0]);
          *v31 = (__n128)a15;
        }
        ++v31;
        ++v22;
        --a2;
      }
      while (a2);
    }
  }
  else if (a2 >= 1)
  {
    v43 = 0;
    v46.i32[1] = 0;
    v46.i32[3] = 0;
    v47.i32[1] = 0;
    v47.i32[3] = 0;
    v47.f32[0] = v27 * 0.5;
    v29 = (float32x4_t)v29.u32[0];
    v29.f32[2] = v28 * 0.5;
    v44.i32[0] = 0;
    v44.i32[3] = 0;
    *(uint64_t *)((char *)v44.i64 + 4) = *((unsigned int *)cf + 53);
    v46.f32[0] = -(float)(v27 * 0.5);
    v45 = (float32x4_t)v46.u32[0];
    v45.f32[2] = v28 * 0.5;
    v46.f32[2] = -(float)(v28 * 0.5);
    v47.f32[2] = v46.f32[2];
    v48 = vsubq_f32(v29, v45);
    v49 = vsubq_f32(v47, v29);
    v50 = vsubq_f32(v46, v47);
    v51 = vsubq_f32(v45, v46);
    v52 = vsubq_f32((float32x4_t)v44.u64[0], v45);
    v53 = vsubq_f32((float32x4_t)v44.u64[0], v47);
    v54 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL);
    v55 = (int32x4_t)vmlaq_f32(vmulq_f32(v54, vnegq_f32(v49)), v53, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v49, (int32x4_t)v49), (int8x16_t)v49, 0xCuLL));
    v56 = vextq_s8((int8x16_t)vuzp1q_s32(v55, v55), (int8x16_t)v55, 0xCuLL);
    v57 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v51, (int32x4_t)v51), (int8x16_t)v51, 0xCuLL);
    v58 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v52, (int32x4_t)v52), (int8x16_t)v52, 0xCuLL);
    v59 = vnegq_f32(v51);
    v60 = (int32x4_t)vmlaq_f32(vmulq_f32(v58, v59), v52, v57);
    v61 = vextq_s8((int8x16_t)vuzp1q_s32(v60, v60), (int8x16_t)v60, 0xCuLL);
    v62 = (int32x4_t)vmlaq_f32(vmulq_f32(v54, vnegq_f32(v50)), v53, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v50, (int32x4_t)v50), (int8x16_t)v50, 0xCuLL));
    v63 = vextq_s8((int8x16_t)vuzp1q_s32(v62, v62), (int8x16_t)v62, 0xCuLL);
    v64 = (int32x4_t)vmlaq_f32(vmulq_f32(v58, vnegq_f32(v48)), v52, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v48, (int32x4_t)v48), (int8x16_t)v48, 0xCuLL));
    v65 = vextq_s8((int8x16_t)vuzp1q_s32(v64, v64), (int8x16_t)v64, 0xCuLL);
    do
    {
      v66 = v16;
      v67 = v17;
      v68 = v19;
      v69 = v18.i32[3];
      v85 = 0.16667;
      v84 = xmmword_1B22681F8;
      v70 = 4;
      v71 = 0.33333;
      do
      {
        v71 = v71 + *(float *)((char *)&v84 + v70);
        *(float *)((char *)&v84 + v70) = v71;
        v70 += 4;
      }
      while (v70 != 20);
      v72 = 214013 * *a3 + 2531011;
      v73 = (double)HIWORD(v72) * 0.0000152590219;
      v16 = v45;
      v17 = v59;
      v19 = v48;
      v18 = (float32x4_t)xmmword_1B2244DE0;
      if (v73 >= 0.33333)
      {
        v16 = v44;
        v17 = v29;
        v19 = v45;
        v18 = (float32x4_t)v65;
        if (*((float *)&v84 + 1) <= v73)
        {
          v16 = v44;
          v17 = v46;
          v19 = v47;
          v18 = (float32x4_t)v63;
          if (*((float *)&v84 + 2) <= v73)
          {
            v16 = v46;
            v17 = v44;
            v19 = v45;
            v18 = (float32x4_t)v61;
            if (*((float *)&v84 + 3) <= v73)
            {
              if (v85 <= v73)
              {
                v18.i16[0] = 0;
                v18.i8[2] = 0;
                v18.i8[3] = 0;
                v18.i8[4] = 0;
                v18.i8[5] = 0;
                v18.i8[6] = 0;
                v18.i8[7] = 0;
                v18.i8[8] = 0;
                v18.i8[9] = 0;
                v18.i8[10] = 0;
                v18.i8[11] = 0;
                v18.i32[3] = v69;
                v16 = v66;
                v17 = v67;
                v19 = v68;
              }
              else
              {
                v16 = v47;
                v17 = v29;
                v19 = v44;
                v18 = (float32x4_t)v56;
              }
            }
          }
        }
      }
      v74 = 214013 * v72 + 2531011;
      v75 = (double)HIWORD(v74) * 0.0000152590219;
      v76 = 214013 * v74 + 2531011;
      *a3 = v76;
      v77 = (double)HIWORD(v76) * 0.0000152590219;
      if (v73 >= 0.33333)
      {
        v79 = 214013 * v76 + 2531011;
        *a3 = v79;
        v80 = (double)HIWORD(v79) * 0.0000152590219;
        v78 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v17, (float)(1.0 / (float)((float)(v75 + v77) + v80)) * v77), v19, (float)(1.0 / (float)((float)(v75 + v77) + v80)) * v75), v16, (float)(1.0 / (float)((float)(v75 + v77) + v80)) * v80);
      }
      else
      {
        v78 = vaddq_f32(v16, vmlaq_n_f32(vmulq_n_f32(v17, v77), v19, v75));
      }
      v22[v43] = (__n128)v78;
      if (a5)
      {
        v81 = (int32x4_t)vmulq_f32(v18, v18);
        v81.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v81, 2), vadd_f32(*(float32x2_t *)v81.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v81.i8, 1))).u32[0];
        v82 = vrsqrte_f32((float32x2_t)v81.u32[0]);
        v83 = vmul_f32(v82, vrsqrts_f32((float32x2_t)v81.u32[0], vmul_f32(v82, v82)));
        *(float32x4_t *)(a5 + 16 * v43) = vmulq_n_f32(v18, vmul_f32(v83, vrsqrts_f32((float32x2_t)v81.u32[0], vmul_f32(v83, v83))).f32[0]);
      }
      ++v43;
    }
    while (v43 != a2);
  }
}

uint64_t sub_1B1916F48(uint64_t a1)
{
  return sub_1B18E4054(*(char *)(a1 + 68), *(int *)(a1 + 40), *(_DWORD *)(a1 + 44), *(int *)(a1 + 48), *(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 8));
}

void sub_1B1916F64(_DWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  sub_1B19190E4((uint64_t)a1, 0, 1.0);
  sub_1B19190E4((uint64_t)a1, 1, 1.0);
  sub_1B19190E4((uint64_t)a1, 2, 1.0);
  if (a1[62] != 1)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[62] = 1;
  }
  if (a1[63] != 1)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[63] = 1;
  }
  if (a1[64] != 1)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[64] = 1;
  }
}

uint64_t sub_1B1917000(_DWORD *a1, _DWORD *a2)
{
  *a2 = 2;
  a2[1] = a1[69];
  a2[2] = a1[52];
  a2[3] = a1[53];
  a2[4] = a1[54];
  a2[5] = a1[62];
  a2[6] = a1[63];
  a2[7] = a1[64];
  a2[8] = a1[71];
  return 36;
}

uint64_t sub_1B1917050(uint64_t a1)
{
  return sub_1B18E2808(*(char *)(a1 + 68), *(int *)(a1 + 36), *(_DWORD *)(a1 + 72), *(float *)(a1 + 12), *(float *)(a1 + 32));
}

float sub_1B191706C(uint64_t a1, uint64_t a2, double a3, double a4)
{
  BOOL v4;

  if (a1)
    v4 = a2 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    *(float *)&a4 = -*(float *)&a3;
    *(float *)(a1 + 8) = -*(float *)&a3;
    *(_QWORD *)a1 = vdupq_lane_s32(*(int32x2_t *)&a4, 0).u64[0];
    *(_DWORD *)(a2 + 8) = LODWORD(a3);
    *(_QWORD *)a2 = vdupq_lane_s32(*(int32x2_t *)&a3, 0).u64[0];
  }
  return *(float *)&a3;
}

float sub_1B19170A0(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5)
{
  BOOL v5;

  if (a2)
    v5 = a3 == 0;
  else
    v5 = 1;
  if (!v5)
  {
    LODWORD(a4) = *(_DWORD *)(a1 + 220);
    *(float *)&a5 = -*(float *)&a4;
    *(float *)(a2 + 8) = -*(float *)&a4;
    *(_QWORD *)a2 = vdupq_lane_s32(*(int32x2_t *)&a5, 0).u64[0];
    *(_DWORD *)(a3 + 8) = LODWORD(a4);
    *(_QWORD *)a3 = vdupq_lane_s32(*(int32x2_t *)&a4, 0).u64[0];
  }
  return *(float *)&a4;
}

BOOL sub_1B19170D8(_OWORD *a1, float a2)
{
  __int128 v2;

  if (a1)
  {
    *(_QWORD *)&v2 = 0;
    DWORD2(v2) = 0;
    *((float *)&v2 + 3) = a2;
    *a1 = v2;
  }
  return a1 != 0;
}

BOOL sub_1B19170F4(uint64_t a1, _OWORD *a2)
{
  __int128 v2;

  if (a2)
  {
    *(_QWORD *)&v2 = 0;
    DWORD2(v2) = 0;
    HIDWORD(v2) = *(_DWORD *)(a1 + 220);
    *a2 = v2;
  }
  return a2 != 0;
}

void sub_1B1917114(_DWORD *a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, uint64_t a10)
{
  float32x4_t v10;
  float32x4_t *v12;
  uint64_t v14;
  uint64_t v15;
  float32x2_t v16;
  unsigned int v22;
  int v23;
  float32x4_t v24;
  int32x2_t v25;
  _OWORD *v26;
  unsigned int v27;
  unsigned int v28;
  float v29;
  __float2 v30;
  float32x4_t v31;
  float32x4_t v32;
  float32_t v33;

  v12 = (float32x4_t *)a4;
  v14 = a2;
  LODWORD(a9) = a1[55];
  if ((_DWORD)a6)
  {
    if ((_DWORD)a6 == 2)
    {
      sub_1B17A2264(a1, a2, a3, a4, a5, a6, a7, a8, a10);
    }
    else if ((_DWORD)a6 == 1 && a2 >= 1)
    {
      v15 = 0;
      v16 = (float32x2_t)vdup_n_s32(0x37800080u);
      __asm { FMOV            V3.2S, #-1.0 }
      do
      {
        v22 = *a3;
        do
        {
          v23 = 214013 * v22 + 2531011;
          v10.i32[0] = v23;
          v10.i32[1] = 214013 * v23 + 2531011;
          *(float32x2_t *)v10.f32 = vmla_f32(_D3, (float32x2_t)0x4000000040000000, vmul_f32(vcvt_f32_u32(vshr_n_u32(*(uint32x2_t *)v10.f32, 0x10uLL)), v16));
          v22 = 214013 * (214013 * v23 + 2531011) + 2531011;
          v10.f32[2] = (float)((float)((float)HIWORD(v22) * 0.000015259) * 2.0) + -1.0;
          v24 = vmulq_f32(v10, v10);
          v25 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).u64[0];
          *(float *)v25.i32 = sqrtf(*(float *)v25.i32);
        }
        while (*(float *)v25.i32 > 1.0);
        *a3 = v22;
        if (a5)
          *(float32x4_t *)(a5 + 16 * v15) = vdivq_f32(v10, (float32x4_t)vdupq_lane_s32(v25, 0));
        v10 = vaddq_f32(vmulq_n_f32(v10, *(float *)&a9), (float32x4_t)0);
        *(float32x4_t *)(a4 + 16 * v15++) = v10;
      }
      while (v15 != a2);
    }
  }
  else if (a2 >= 1)
  {
    v32 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    v26 = (_OWORD *)a5;
    do
    {
      v27 = 214013 * *a3 + 2531011;
      v33 = (float)((float)((float)HIWORD(v27) * 0.000015259) * 2.0) + -1.0;
      v28 = 214013 * v27 + 2531011;
      *a3 = v28;
      v29 = (float)((float)((float)HIWORD(v28) * 0.000015259) + (float)((float)HIWORD(v28) * 0.000015259)) * 3.14159265;
      v30 = __sincosf_stret(v29);
      *(float32x2_t *)v31.f32 = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v30.__sinval), LODWORD(v30.__cosval)), sqrtf(1.0 - (float)(v33 * v33)));
      v31.f32[2] = v33;
      *v12 = vmlaq_f32((float32x4_t)0, v32, v31);
      if (a5)
        *v26 = v31;
      ++v26;
      ++v12;
      --v14;
    }
    while (v14);
  }
}

uint64_t sub_1B1917360(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_DWORD *)(a1 + 280) != 3)
  {
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
    *(_DWORD *)(a1 + 280) = 3;
  }
  sub_1B19190E4(a1, 4, 0.5);
  if (*(_DWORD *)(a1 + 244) != 48)
  {
    sub_1B1915434(a1, v9, v10, v11, v12, v13, v14, v15);
    *(_DWORD *)(a1 + 244) = 48;
  }
  return sub_1B19190E4(a1, 18, 1.0);
}

uint64_t sub_1B19173D0(_DWORD *a1, _DWORD *a2)
{
  *a2 = 3;
  a2[1] = a1[69];
  a2[2] = a1[70];
  a2[3] = a1[55];
  a2[4] = a1[61];
  a2[5] = a1[60];
  a2[6] = a1[71];
  return 28;
}

uint64_t sub_1B1917410(uint64_t a1)
{
  return sub_1B18E2C84(*(char *)(a1 + 68), *(_DWORD *)(a1 + 56), *(int *)(a1 + 44), *(float *)(a1 + 12), *(float *)(a1 + 4), *(float *)(a1 + 32));
}

float sub_1B1917430(uint64_t a1, uint64_t a2, float result, float a4)
{
  BOOL v4;
  uint64_t v5;

  if (a1)
    v4 = a2 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    *(float *)&v5 = -result;
    *(float *)(a1 + 8) = -result;
    *((float *)&v5 + 1) = a4 * -0.5;
    *(_QWORD *)a1 = v5;
    *(float *)&v5 = result;
    *((float *)&v5 + 1) = a4 * 0.5;
    *(float *)(a2 + 8) = result;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

float sub_1B1917478(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float result;
  BOOL v12;
  float v13;
  uint64_t v14;
  uint64_t v15;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (a2)
    v12 = a3 == 0;
  else
    v12 = 1;
  if (!v12)
  {
    v13 = *(float *)(a1 + 212);
    LODWORD(v14) = *(_DWORD *)(a1 + 220);
    *(float *)&v15 = -*(float *)&v14;
    *(float *)(a2 + 8) = -*(float *)&v14;
    *((float *)&v15 + 1) = v13 * -0.5;
    *(_QWORD *)a2 = v15;
    result = v13 * 0.5;
    *(_DWORD *)(a3 + 8) = v14;
    *((float *)&v14 + 1) = result;
    *(_QWORD *)a3 = v14;
  }
  return result;
}

float sub_1B1917510(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(float *)(a1 + 220);
}

BOOL sub_1B1917558(_OWORD *a1, float a2, float a3)
{
  float v3;
  __int128 v4;

  if (a1)
  {
    v3 = sqrt((float)(a2 * a2) + a3 * 0.25 * a3);
    *(_QWORD *)&v4 = 0;
    DWORD2(v4) = 0;
    *((float *)&v4 + 3) = v3;
    *a1 = v4;
  }
  return a1 != 0;
}

BOOL sub_1B1917594(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v10;
  __int128 v11;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
    if (!a2)
      return a2 != 0;
    goto LABEL_3;
  }
  if (a2)
  {
LABEL_3:
    v10 = sqrt((float)(*(float *)(a1 + 220) * *(float *)(a1 + 220)) + *(float *)(a1 + 212) * 0.25 * *(float *)(a1 + 212));
    *(_QWORD *)&v11 = 0;
    DWORD2(v11) = 0;
    *((float *)&v11 + 3) = v10;
    *a2 = v11;
  }
  return a2 != 0;
}

void sub_1B1917624(float *cf, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9;
  _OWORD *v11;
  float v15;
  float v16;
  _OWORD *v17;
  unsigned int v18;
  float v19;
  __double2 v20;
  float sinval;
  float cosval;
  unsigned int v23;
  float v24;
  float v25;
  __int128 v26;
  unsigned int v27;
  float v28;
  float v29;
  __int128 v30;
  _OWORD *v31;
  unsigned int v32;
  float v33;
  __double2 v34;
  unsigned int v35;
  float v36;
  float v37;
  __int128 v38;
  float v39;
  float v40;
  __int128 v41;

  v9 = a6;
  v11 = (_OWORD *)a4;
  if (!cf)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  v15 = cf[55];
  v16 = cf[53];
  if (v9)
  {
    if (v9 == 2)
    {
      sub_1B17A2264(cf, a2, a3, (uint64_t)v11, a5, 2, a7, a8, a9);
    }
    else if (v9 == 1 && a2 >= 1)
    {
      v17 = (_OWORD *)a5;
      do
      {
        v18 = 214013 * *a3 + 2531011;
        v19 = (double)HIWORD(v18) * 0.0000152590219;
        v20 = __sincos_stret((float)(v19 + v19) * 3.14159265);
        sinval = v20.__sinval;
        cosval = v20.__cosval;
        v23 = 214013 * v18 + 2531011;
        v24 = (double)HIWORD(v23) * 0.0000152590219;
        v25 = v15 * v24;
        *(float *)&v26 = v25 * cosval;
        v27 = 214013 * v23 + 2531011;
        *a3 = v27;
        v28 = (double)HIWORD(v27) * 0.0000152590219;
        v29 = (float)(v16 * v28) + -v16 * 0.5;
        *((float *)&v26 + 1) = v29;
        *((float *)&v26 + 2) = v25 * sinval;
        *v11 = v26;
        if (a5)
        {
          *(_QWORD *)&v30 = LODWORD(cosval);
          *((_QWORD *)&v30 + 1) = LODWORD(sinval);
          *v17 = v30;
        }
        ++v17;
        ++v11;
        --a2;
      }
      while (a2);
    }
  }
  else if (a2 >= 1)
  {
    v31 = (_OWORD *)a5;
    do
    {
      v32 = 214013 * *a3 + 2531011;
      v33 = (double)HIWORD(v32) * 0.0000152590219;
      v34 = __sincos_stret((float)(v33 + v33) * 3.14159265);
      v35 = 214013 * v32 + 2531011;
      v36 = v34.__sinval;
      v37 = v34.__cosval;
      *(float *)&v38 = v15 * v37;
      *a3 = v35;
      v39 = (double)HIWORD(v35) * 0.0000152590219;
      v40 = (float)(v16 * v39) + -v16 * 0.5;
      *((float *)&v38 + 1) = v40;
      *((float *)&v38 + 2) = v15 * v36;
      *v11 = v38;
      if (a5)
      {
        *(_QWORD *)&v41 = LODWORD(v37);
        *((_QWORD *)&v41 + 1) = LODWORD(v36);
        *v31 = v41;
      }
      ++v31;
      ++v11;
      --a2;
    }
    while (a2);
  }
}

uint64_t sub_1B19178B4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  sub_1B19190E4(a1, 4, 0.5);
  sub_1B19190E4(a1, 1, 1.0);
  if (*(_DWORD *)(a1 + 264) != 48)
  {
    sub_1B1915434(a1, v2, v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(a1 + 264) = 48;
  }
  if (*(_DWORD *)(a1 + 252) != 1)
  {
    sub_1B1915434(a1, v2, v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(a1 + 252) = 1;
  }
  return sub_1B19190E4(a1, 18, 1.0);
}

uint64_t sub_1B1917930(_DWORD *a1, _DWORD *a2)
{
  *a2 = 4;
  a2[1] = a1[69];
  a2[2] = a1[55];
  a2[3] = a1[53];
  a2[4] = a1[66];
  a2[5] = a1[63];
  a2[6] = a1[60];
  a2[7] = a1[71];
  return 32;
}

uint64_t sub_1B1917978(uint64_t a1)
{
  return sub_1B18E30F4(*(char *)(a1 + 68), *(_DWORD *)(a1 + 56), *(_DWORD *)(a1 + 44), *(float *)(a1 + 20), *(float *)(a1 + 12), *(float *)(a1 + 4));
}

__n64 sub_1B1917998(uint64_t a1, __n64 *a2, __n64 result, float a4, float a5)
{
  BOOL v5;
  uint64_t v6;

  if (a1)
    v5 = a2 == 0;
  else
    v5 = 1;
  if (!v5)
  {
    if (result.n64_f32[0] <= a4)
      result.n64_f32[0] = a4;
    *(float *)&v6 = -result.n64_f32[0];
    *(float *)(a1 + 8) = -result.n64_f32[0];
    *((float *)&v6 + 1) = a5 * -0.5;
    *(_QWORD *)a1 = v6;
    a2[1].n64_u32[0] = result.n64_u32[0];
    result.n64_f32[1] = a5 * 0.5;
    a2->n64_u64[0] = result.n64_u64[0];
  }
  return result;
}

float sub_1B19179E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float result)
{
  BOOL v12;
  float v13;
  uint64_t v14;
  uint64_t v15;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (a2)
    v12 = a3 == 0;
  else
    v12 = 1;
  if (!v12)
  {
    v13 = *(float *)(a1 + 212);
    LODWORD(v14) = *(_DWORD *)(a1 + 220);
    if (*(float *)(a1 + 228) > *(float *)&v14)
      LODWORD(v14) = *(_DWORD *)(a1 + 228);
    *(float *)&v15 = -*(float *)&v14;
    *(float *)(a2 + 8) = -*(float *)&v14;
    *((float *)&v15 + 1) = v13 * -0.5;
    *(_QWORD *)a2 = v15;
    result = v13 * 0.5;
    *(_DWORD *)(a3 + 8) = v14;
    *((float *)&v14 + 1) = result;
    *(_QWORD *)a3 = v14;
  }
  return result;
}

float sub_1B1917A88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(float *)(a1 + 228);
}

BOOL sub_1B1917AD0(_OWORD *a1, float a2, float a3, float a4)
{
  float v4;
  __int128 v5;

  if (a1)
  {
    if (a2 <= a3)
      a2 = a3;
    v4 = sqrt((float)(a2 * a2) + a4 * 0.25 * a4);
    *(_QWORD *)&v5 = 0;
    DWORD2(v5) = 0;
    *((float *)&v5 + 3) = v4;
    *a1 = v5;
  }
  return a1 != 0;
}

BOOL sub_1B1917B14(float *a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v10;
  float v11;
  __int128 v12;

  if (a1)
  {
    if (!a2)
      return a2 != 0;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
    if (!a2)
      return a2 != 0;
  }
  v10 = a1[55];
  if (a1[57] > v10)
    v10 = a1[57];
  v11 = sqrt((float)(v10 * v10) + a1[53] * 0.25 * a1[53]);
  *(_QWORD *)&v12 = 0;
  DWORD2(v12) = 0;
  *((float *)&v12 + 3) = v11;
  *a2 = v12;
  return a2 != 0;
}

void sub_1B1917BB0(float *cf, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9;
  _OWORD *v11;
  float v15;
  float v16;
  float v17;
  float v18;
  _OWORD *v19;
  unsigned int v20;
  float v21;
  __double2 v22;
  float sinval;
  float cosval;
  unsigned int v25;
  float v26;
  unsigned int v27;
  float v28;
  float v29;
  __int128 v30;
  float v31;
  __int128 v32;
  float v33;
  _OWORD *v34;
  unsigned int v35;
  float v36;
  __double2 v37;
  float v38;
  float v39;
  unsigned int v40;
  float v41;
  float v42;
  __int128 v43;
  float v44;
  __int128 v45;

  v9 = a6;
  v11 = (_OWORD *)a4;
  if (!cf)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  v15 = cf[57];
  v16 = cf[55];
  v17 = cf[53];
  if (v9)
  {
    if (v9 == 2)
    {
      sub_1B17A2264(cf, a2, a3, (uint64_t)v11, a5, 2, a7, a8, a9);
    }
    else if (v9 == 1 && a2 >= 1)
    {
      v18 = v15 - v16;
      v19 = (_OWORD *)a5;
      do
      {
        v20 = 214013 * *a3 + 2531011;
        v21 = (double)HIWORD(v20) * 0.0000152590219;
        v22 = __sincos_stret((float)(v21 + v21) * 3.14159265);
        sinval = v22.__sinval;
        cosval = v22.__cosval;
        v25 = 214013 * v20 + 2531011;
        v26 = (double)HIWORD(v25) * 0.0000152590219;
        v27 = 214013 * v25 + 2531011;
        *a3 = v27;
        v28 = (double)HIWORD(v27) * 0.0000152590219;
        v29 = (float)(v16 + (float)(v26 * v18)) * v28;
        *(float *)&v30 = v29 * cosval;
        v31 = (float)(v17 * v26) + -v17 * 0.5;
        *((float *)&v30 + 1) = v31;
        *((float *)&v30 + 2) = v29 * sinval;
        *v11 = v30;
        if (a5)
        {
          *(_QWORD *)&v32 = LODWORD(cosval);
          *((_QWORD *)&v32 + 1) = LODWORD(sinval);
          *v19 = v32;
        }
        ++v19;
        ++v11;
        --a2;
      }
      while (a2);
    }
  }
  else if (a2 >= 1)
  {
    v33 = v15 - v16;
    v34 = (_OWORD *)a5;
    do
    {
      v35 = 214013 * *a3 + 2531011;
      v36 = (double)HIWORD(v35) * 0.0000152590219;
      v37 = __sincos_stret((float)(v36 + v36) * 3.14159265);
      v38 = v37.__sinval;
      v39 = v37.__cosval;
      v40 = 214013 * v35 + 2531011;
      *a3 = v40;
      v41 = (double)HIWORD(v40) * 0.0000152590219;
      v42 = v16 + (float)(v41 * v33);
      *(float *)&v43 = v42 * v39;
      v44 = (float)(v17 * v41) + -v17 * 0.5;
      *((float *)&v43 + 1) = v44;
      *((float *)&v43 + 2) = v42 * v38;
      *v11 = v43;
      if (a5)
      {
        *(_QWORD *)&v45 = LODWORD(v39);
        *((_QWORD *)&v45 + 1) = LODWORD(v38);
        *v34 = v45;
      }
      ++v34;
      ++v11;
      --a2;
    }
    while (a2);
  }
}

void sub_1B1917E60(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  sub_1B19190E4(a1, 5, 0.0);
  sub_1B19190E4(a1, 4, 0.5);
  sub_1B19190E4(a1, 1, 1.0);
  if (*(_DWORD *)(a1 + 264) != 48)
  {
    sub_1B1915434(a1, v2, v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(a1 + 264) = 48;
  }
  if (*(_DWORD *)(a1 + 252) != 1)
  {
    sub_1B1915434(a1, v2, v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(a1 + 252) = 1;
  }
}

uint64_t sub_1B1917EE0(_DWORD *a1, _DWORD *a2)
{
  *a2 = 5;
  a2[1] = a1[69];
  a2[2] = a1[57];
  a2[3] = a1[55];
  a2[4] = a1[53];
  a2[5] = a1[66];
  a2[6] = a1[63];
  a2[7] = a1[71];
  return 32;
}

uint64_t sub_1B1917F28(uint64_t a1)
{
  return sub_1B18E3318(*(char *)(a1 + 68), *(_DWORD *)(a1 + 56), *(int *)(a1 + 44), *(float *)(a1 + 24), *(float *)(a1 + 12), *(float *)(a1 + 4), *(float *)(a1 + 32));
}

float sub_1B1917F4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v3;
  float v4;
  uint64_t v5;
  uint64_t v6;
  float result;

  if (a2)
    v3 = a3 == 0;
  else
    v3 = 1;
  if (!v3)
  {
    v4 = *(float *)(a1 + 212);
    LODWORD(v5) = *(_DWORD *)(a1 + 220);
    *(float *)&v6 = -*(float *)&v5;
    *(float *)(a2 + 8) = -*(float *)&v5;
    *((float *)&v6 + 1) = v4 * -0.5;
    *(_QWORD *)a2 = v6;
    result = v4 * 0.5;
    *(_DWORD *)(a3 + 8) = v5;
    *((float *)&v5 + 1) = result;
    *(_QWORD *)a3 = v5;
  }
  return result;
}

BOOL sub_1B1917F98(uint64_t a1, _OWORD *a2)
{
  float v2;
  __int128 v3;

  if (a2)
  {
    v2 = sqrt((float)(*(float *)(a1 + 220) * *(float *)(a1 + 220)) + *(float *)(a1 + 212) * 0.25 * *(float *)(a1 + 212));
    *(_QWORD *)&v3 = 0;
    DWORD2(v3) = 0;
    *((float *)&v3 + 3) = v2;
    *a2 = v3;
  }
  return a2 != 0;
}

void sub_1B1917FDC(float *cf, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9;
  _OWORD *v11;
  float v15;
  float v16;
  float v17;
  float v18;
  _OWORD *v19;
  unsigned int v20;
  float v21;
  __double2 v22;
  float sinval;
  float cosval;
  unsigned int v25;
  float v26;
  float v27;
  __int128 v28;
  unsigned int v29;
  float v30;
  float v31;
  __int128 v32;
  _OWORD *v33;
  unsigned int v34;
  float v35;
  __double2 v36;
  __double2 v37;
  float v38;
  float v39;
  unsigned int v40;
  float v41;
  float v42;
  unsigned int v43;
  float v44;
  float v45;
  __int128 v46;

  v9 = a6;
  v11 = (_OWORD *)a4;
  if (!cf)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  v15 = cf[55];
  v16 = cf[58];
  v17 = cf[53];
  if (v9)
  {
    if (v9 == 2)
    {
      sub_1B17A2264(cf, a2, a3, (uint64_t)v11, a5, 2, a7, a8, a9);
    }
    else if (v9 == 1 && a2 >= 1)
    {
      v18 = v15 - v16;
      v19 = (_OWORD *)a5;
      do
      {
        v20 = 214013 * *a3 + 2531011;
        v21 = (double)HIWORD(v20) * 0.0000152590219;
        v22 = __sincos_stret((float)(v21 + v21) * 3.14159265);
        sinval = v22.__sinval;
        cosval = v22.__cosval;
        v25 = 214013 * v20 + 2531011;
        v26 = (double)HIWORD(v25) * 0.0000152590219;
        v27 = v16 + (float)(v18 * v26);
        *(float *)&v28 = v27 * cosval;
        v29 = 214013 * v25 + 2531011;
        *a3 = v29;
        v30 = (double)HIWORD(v29) * 0.0000152590219;
        v31 = (float)(v17 * v30) + -v17 * 0.5;
        *((float *)&v28 + 1) = v31;
        *((float *)&v28 + 2) = v27 * sinval;
        *v11 = v28;
        if (a5)
        {
          if (v26 > 0.5)
          {
            cosval = -cosval;
            sinval = -sinval;
          }
          *(_QWORD *)&v32 = LODWORD(cosval);
          *((_QWORD *)&v32 + 1) = LODWORD(sinval);
          *v19 = v32;
        }
        ++v19;
        ++v11;
        --a2;
      }
      while (a2);
    }
  }
  else if (a2 >= 1)
  {
    v33 = (_OWORD *)a5;
    do
    {
      v34 = 214013 * *a3 + 2531011;
      v35 = (double)HIWORD(v34) * 0.0000152590219;
      v37 = __sincos_stret((float)(v35 + v35) * 3.14159265);
      v38 = v37.__sinval;
      v39 = v37.__cosval;
      v40 = 214013 * v34 + 2531011;
      v41 = (double)HIWORD(v40) * 0.0000152590219;
      if (v41 <= 0.5)
        v42 = v15;
      else
        v42 = v16;
      *(float *)&v36.__sinval = v42 * v39;
      v43 = 214013 * v40 + 2531011;
      *a3 = v43;
      v44 = (double)HIWORD(v43) * 0.0000152590219;
      v45 = (float)(v17 * v44) + -v17 * 0.5;
      *((float *)&v36.__sinval + 1) = v45;
      *(float *)&v36.__cosval = v42 * v38;
      *v11 = v36;
      if (a5)
      {
        if (v41 > 0.5)
        {
          v39 = -v39;
          v38 = -v38;
        }
        *(_QWORD *)&v46 = LODWORD(v39);
        *((_QWORD *)&v46 + 1) = LODWORD(v38);
        *v33 = v46;
      }
      ++v33;
      ++v11;
      --a2;
    }
    while (a2);
  }
}

uint64_t sub_1B19182CC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  sub_1B19190E4(a1, 6, 0.25);
  sub_1B19190E4(a1, 4, 0.5);
  sub_1B19190E4(a1, 1, 1.0);
  if (*(_DWORD *)(a1 + 264) != 48)
  {
    sub_1B1915434(a1, v2, v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(a1 + 264) = 48;
  }
  if (*(_DWORD *)(a1 + 252) != 1)
  {
    sub_1B1915434(a1, v2, v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(a1 + 252) = 1;
  }
  return sub_1B19190E4(a1, 18, 1.0);
}

uint64_t sub_1B1918358(_DWORD *a1, _DWORD *a2)
{
  *a2 = 6;
  a2[1] = a1[69];
  a2[2] = a1[58];
  a2[3] = a1[55];
  a2[4] = a1[53];
  a2[5] = a1[66];
  a2[6] = a1[63];
  a2[7] = a1[60];
  a2[8] = a1[71];
  return 36;
}

uint64_t sub_1B19183A8(uint64_t a1)
{
  return sub_1B18E37D8(*(char *)(a1 + 68), *(_DWORD *)(a1 + 56), *(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 64), *(float *)(a1 + 12), *(float *)(a1 + 4));
}

float sub_1B19183C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float result;
  BOOL v12;
  float v13;
  uint64_t v14;
  uint64_t v15;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (a2)
    v12 = a3 == 0;
  else
    v12 = 1;
  if (!v12)
  {
    v13 = *(float *)(a1 + 212);
    LODWORD(v14) = *(_DWORD *)(a1 + 220);
    *(float *)&v15 = -*(float *)&v14;
    *(float *)(a2 + 8) = -*(float *)&v14;
    *((float *)&v15 + 1) = v13 * -0.5;
    *(_QWORD *)a2 = v15;
    result = v13 * 0.5;
    *(_DWORD *)(a3 + 8) = v14;
    *((float *)&v14 + 1) = result;
    *(_QWORD *)a3 = v14;
  }
  return result;
}

BOOL sub_1B1918460(_OWORD *a1, double a2, float a3)
{
  float v3;
  __int128 v4;

  if (a1)
  {
    v3 = a3 * 0.5;
    *(_QWORD *)&v4 = 0;
    DWORD2(v4) = 0;
    *((float *)&v4 + 3) = v3;
    *a1 = v4;
  }
  return a1 != 0;
}

BOOL sub_1B1918484(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v12, v13, v14, v15, v16, v17, (uint64_t)"parametricGeometry");
    if (!a2)
      return a2 != 0;
    goto LABEL_3;
  }
  if (a2)
  {
LABEL_3:
    *(_QWORD *)&v10 = 0;
    DWORD2(v10) = 0;
    *((float *)&v10 + 3) = *(float *)(a1 + 212) * 0.5;
    *a2 = v10;
  }
  return a2 != 0;
}

void sub_1B1918514(float *cf, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, int8x16_t a10, uint64_t a11)
{
  int v11;
  _OWORD *v13;
  float v17;
  float v18;
  float v19;
  float v20;
  _OWORD *v21;
  unsigned int v22;
  float v23;
  __double2 v24;
  __double2 v25;
  float sinval;
  __int128 v27;
  unsigned int v28;
  float v29;
  int8x16_t v30;
  unsigned int v31;
  float v32;
  float v33;
  int8x16_t v34;
  int8x16_t v35;
  float v36;
  float v37;
  __double2 v38;
  float v39;
  _OWORD *v40;
  unsigned int v41;
  float v42;
  __double2 v43;
  __double2 v44;
  float v45;
  __int128 v46;
  unsigned int v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  float v51;
  float v52;
  __double2 v53;
  int8x16_t v54;

  v11 = a6;
  v13 = (_OWORD *)a4;
  if (!cf)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  v17 = cf[55];
  v18 = cf[53];
  v19 = v18 * 0.5;
  *(float *)a10.i32 = (float)(v18 * 0.5) - v17;
  v54 = a10;
  if (v11)
  {
    if (v11 == 2)
    {
      sub_1B17A2264(cf, a2, a3, (uint64_t)v13, a5, 2, a7, a8, a11);
    }
    else if (v11 == 1 && a2 >= 1)
    {
      v20 = -v19;
      v21 = (_OWORD *)a5;
      do
      {
        v22 = 214013 * *a3 + 2531011;
        v23 = (double)HIWORD(v22) * 0.0000152590219;
        v25 = __sincos_stret((float)(v23 + v23) * 3.14159265);
        sinval = v25.__sinval;
        *(float *)&v27 = v25.__cosval;
        v28 = 214013 * v22 + 2531011;
        v29 = (double)HIWORD(v28) * 0.0000152590219;
        *(float *)v30.i32 = v20 + (float)(v29 * v18);
        v31 = 214013 * v28 + 2531011;
        *a3 = v31;
        v32 = (double)HIWORD(v31) * 0.0000152590219;
        v33 = v17 * v32;
        *(float *)v34.i32 = fabsf(*(float *)v30.i32) - *(float *)v54.i32;
        if (*(float *)v34.i32 <= 0.0)
        {
          *(_QWORD *)&v38.__sinval = v27;
          *(_QWORD *)&v38.__cosval = LODWORD(sinval);
          *(float *)&v27 = v33 * *(float *)&v27;
        }
        else
        {
          *(float *)v34.i32 = *(float *)v34.i32 / v17;
          v35.i64[0] = 0x8000000080000000;
          v35.i64[1] = 0x8000000080000000;
          v36 = *(float *)vbslq_s8(v35, v34, v30).i32;
          v37 = sqrtf(1.0 - (float)(v36 * v36));
          *(float *)&v24.__sinval = v37 * *(float *)&v27;
          sinval = v37 * sinval;
          *(float *)&v27 = v33 * (float)(v37 * *(float *)&v27);
          v38 = v24;
          *((float *)&v38.__sinval + 1) = v36;
          *(float *)&v38.__cosval = sinval;
          *(float *)v30.i32 = *(float *)vbslq_s8(v35, v54, v30).i32 + (float)(v36 * v33);
        }
        DWORD1(v27) = v30.i32[0];
        *((float *)&v27 + 2) = v33 * sinval;
        *v13 = v27;
        if (a5)
          *v21 = v38;
        ++v21;
        ++v13;
        --a2;
      }
      while (a2);
    }
  }
  else if (a2 >= 1)
  {
    v39 = -v19;
    v40 = (_OWORD *)a5;
    do
    {
      v41 = 214013 * *a3 + 2531011;
      v42 = (double)HIWORD(v41) * 0.0000152590219;
      v44 = __sincos_stret((float)(v42 + v42) * 3.14159265);
      v45 = v44.__sinval;
      *(float *)&v46 = v44.__cosval;
      v47 = 214013 * v41 + 2531011;
      *a3 = v47;
      *(double *)v48.i64 = (double)HIWORD(v47) * 0.0000152590219;
      *(float *)v48.i32 = *(double *)v48.i64;
      *(float *)v48.i32 = v39 + (float)(*(float *)v48.i32 * v18);
      *(float *)v49.i32 = fabsf(*(float *)v48.i32) - *(float *)v54.i32;
      if (*(float *)v49.i32 <= 0.0)
      {
        *(_QWORD *)&v53.__sinval = v46;
        *(_QWORD *)&v53.__cosval = LODWORD(v45);
        *(float *)&v46 = v17 * *(float *)&v46;
      }
      else
      {
        *(float *)v49.i32 = *(float *)v49.i32 / v17;
        v50.i64[0] = 0x8000000080000000;
        v50.i64[1] = 0x8000000080000000;
        v51 = *(float *)vbslq_s8(v50, v49, v48).i32;
        v52 = sqrtf(1.0 - (float)(v51 * v51));
        *(float *)&v43.__sinval = v52 * *(float *)&v46;
        v45 = v52 * v45;
        *(float *)&v46 = v17 * (float)(v52 * *(float *)&v46);
        v53 = v43;
        *((float *)&v53.__sinval + 1) = v51;
        *(float *)&v53.__cosval = v45;
        *(float *)v48.i32 = *(float *)vbslq_s8(v50, v54, v48).i32 + (float)(v51 * v17);
      }
      DWORD1(v46) = v48.i32[0];
      *((float *)&v46 + 2) = v17 * v45;
      *v13 = v46;
      if (a5)
        *v40 = v53;
      ++v40;
      ++v13;
      --a2;
    }
    while (a2);
  }
}

void sub_1B1918834(_DWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  sub_1B19190E4((uint64_t)a1, 4, 0.5);
  sub_1B19190E4((uint64_t)a1, 1, 2.0);
  if (a1[66] != 48)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[66] = 48;
  }
  if (a1[61] != 24)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[61] = 24;
  }
  if (a1[63] != 1)
  {
    sub_1B1915434((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[63] = 1;
  }
}

uint64_t sub_1B19188C0(_DWORD *a1, _DWORD *a2)
{
  *a2 = 7;
  a2[1] = a1[69];
  a2[2] = a1[55];
  a2[3] = a1[53];
  a2[4] = a1[66];
  a2[5] = a1[68];
  a2[6] = a1[63];
  a2[7] = a1[71];
  return 32;
}

uint64_t sub_1B1918908(uint64_t a1)
{
  return sub_1B18E38DC(*(char *)(a1 + 68), *(_DWORD *)(a1 + 56), *(_DWORD *)(a1 + 60), *(float *)(a1 + 12), *(float *)(a1 + 28), *(float *)(a1 + 32));
}

__n64 sub_1B1918920(uint64_t a1, __n64 *a2, __n64 result, float a4)
{
  BOOL v4;
  float32x4_t v5;
  float32x4_t v6;

  if (a1)
    v4 = a2 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    result.n64_f32[0] = result.n64_f32[0] + a4;
    v5.i64[0] = __PAIR64__(LODWORD(a4), result.n64_u32[0]);
    *(__n64 *)&v5.u32[2] = result;
    v6 = vnegq_f32(v5);
    *(_DWORD *)(a1 + 8) = v6.i32[2];
    *(_QWORD *)a1 = v6.i64[0];
    a2[1].n64_u32[0] = result.n64_u32[0];
    result.n64_f32[1] = a4;
    a2->n64_u64[0] = result.n64_u64[0];
  }
  return result;
}

float sub_1B1918964(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5)
{
  BOOL v5;
  float result;
  float32x4_t v7;
  float32x4_t v8;

  if (a2)
    v5 = a3 == 0;
  else
    v5 = 1;
  if (!v5)
  {
    result = *(float *)(a1 + 236);
    *(float *)&a5 = result + *(float *)(a1 + 220);
    v7.f32[0] = *(float *)&a5;
    v7.f32[1] = result;
    *(double *)&v7.i64[1] = a5;
    v8 = vnegq_f32(v7);
    *(_DWORD *)(a2 + 8) = v8.i32[2];
    *(_QWORD *)a2 = v8.i64[0];
    *(_DWORD *)(a3 + 8) = LODWORD(a5);
    *((float *)&a5 + 1) = result;
    *(double *)a3 = a5;
  }
  return result;
}

BOOL sub_1B19189B0(_OWORD *a1, float a2, float a3)
{
  float v3;
  __int128 v4;

  if (a1)
  {
    v3 = a2 + a3;
    *(_QWORD *)&v4 = 0;
    DWORD2(v4) = 0;
    *((float *)&v4 + 3) = v3;
    *a1 = v4;
  }
  return a1 != 0;
}

BOOL sub_1B19189D0(uint64_t a1, _OWORD *a2)
{
  __int128 v2;

  if (a2)
  {
    *(_QWORD *)&v2 = 0;
    DWORD2(v2) = 0;
    *((float *)&v2 + 3) = *(float *)(a1 + 236) + *(float *)(a1 + 220);
    *a2 = v2;
  }
  return a2 != 0;
}

void sub_1B19189F8(float *cf, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9, uint64_t a10)
{
  int v10;
  _OWORD *v12;
  float v16;
  _OWORD *v17;
  unsigned int v18;
  float v19;
  __double2 v20;
  float cosval;
  unsigned int v22;
  __int128 v23;
  unsigned int v24;
  double v25;
  __double2 v26;
  float sinval;
  float64x2_t v28;
  __int128 v29;
  _OWORD *v30;
  unsigned int v31;
  float v32;
  __double2 v33;
  float v34;
  __n128 v35;
  unsigned int v36;
  double v37;
  __double2 v38;
  float v39;
  __n128 v40;
  float64x2_t v41;
  unsigned int v42;
  __int128 v43;
  __n128 v44;
  __n128 v45;

  v10 = a6;
  v12 = (_OWORD *)a4;
  if (!cf)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  v16 = cf[55];
  a9.n128_f32[0] = cf[59];
  v45 = a9;
  if (v10)
  {
    if (v10 == 2)
    {
      sub_1B17A2264(cf, a2, a3, (uint64_t)v12, a5, 2, a7, a8, a10);
    }
    else if (v10 == 1 && a2 >= 1)
    {
      v17 = (_OWORD *)a5;
      do
      {
        v18 = 214013 * *a3 + 2531011;
        v19 = (double)HIWORD(v18) * 0.0000152590219;
        v20 = __sincos_stret((float)(v19 + v19) * 3.14159265);
        cosval = v20.__cosval;
        v22 = 214013 * v18 + 2531011;
        *(double *)&v23 = (double)HIWORD(v22) * 0.0000152590219;
        *(float *)&v23 = *(double *)&v23;
        *(float *)&v23 = v45.n128_f32[0] * sqrtf(*(float *)&v23);
        v43 = v23;
        *(float *)&v42 = v16 + (float)(cosval * *(float *)&v23);
        v24 = 214013 * v22 + 2531011;
        *a3 = v24;
        *(float *)&v23 = (double)HIWORD(v24) * 0.0000152590219;
        v26 = __sincos_stret((float)(*(float *)&v23 + *(float *)&v23) * 3.14159265);
        v25 = v26.__cosval;
        sinval = v26.__sinval;
        v28.f64[1] = v20.__sinval;
        *(float32x2_t *)&v28.f64[0] = vcvt_f32_f64(v28);
        HIDWORD(v29) = HIDWORD(v43);
        *(float32x2_t *)&v29 = vmul_f32((float32x2_t)__PAIR64__(v43, v42), *(float32x2_t *)&v28.f64[0]);
        *((float *)&v29 + 2) = *(float *)&v42 * sinval;
        *v12 = v29;
        if (a5)
        {
          *(float *)v28.f64 = cosval * *(float *)v28.f64;
          *(float *)&v28.f64[1] = cosval * sinval;
          *v17 = v28;
        }
        ++v17;
        ++v12;
        --a2;
      }
      while (a2);
    }
  }
  else if (a2 >= 1)
  {
    v30 = (_OWORD *)a5;
    do
    {
      v31 = 214013 * *a3 + 2531011;
      v32 = (double)HIWORD(v31) * 0.0000152590219;
      v33 = __sincos_stret((float)(v32 + v32) * 3.14159265);
      v34 = v33.__cosval;
      v35 = v45;
      v35.n128_f32[0] = v16 + (float)(v34 * v45.n128_f32[0]);
      v44 = v35;
      v36 = 214013 * v31 + 2531011;
      *a3 = v36;
      v35.n128_f32[0] = (double)HIWORD(v36) * 0.0000152590219;
      v38 = __sincos_stret((float)(v35.n128_f32[0] + v35.n128_f32[0]) * 3.14159265);
      v37 = v38.__cosval;
      v39 = v38.__sinval;
      v40 = v44;
      v41.f64[1] = v33.__sinval;
      *(float32x2_t *)&v41.f64[0] = vcvt_f32_f64(v41);
      v40.n128_u32[1] = v45.n128_u32[0];
      v40.n128_u64[0] = (unint64_t)vmul_f32((float32x2_t)v40.n128_u64[0], *(float32x2_t *)&v41.f64[0]);
      v40.n128_f32[2] = v44.n128_f32[0] * v39;
      *v12 = v40;
      if (a5)
      {
        *(float *)v41.f64 = v34 * *(float *)v41.f64;
        *(float *)&v41.f64[1] = v34 * v39;
        *v30 = v41;
      }
      ++v30;
      ++v12;
      --a2;
    }
    while (a2);
  }
}

float sub_1B1918CBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(float *)(a1 + 236);
}

uint64_t sub_1B1918D04(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  sub_1B19190E4(a1, 4, 0.5);
  sub_1B19190E4(a1, 7, 0.25);
  if (*(_DWORD *)(a1 + 264) != 48)
  {
    sub_1B1915434(a1, v2, v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(a1 + 264) = 48;
  }
  if (*(_DWORD *)(a1 + 268) != 24)
  {
    sub_1B1915434(a1, v2, v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(a1 + 268) = 24;
  }
  return sub_1B19190E4(a1, 18, 1.0);
}

uint64_t sub_1B1918D80(_DWORD *a1, _DWORD *a2)
{
  *a2 = 8;
  a2[1] = a1[69];
  a2[2] = a1[55];
  a2[3] = a1[59];
  a2[4] = a1[66];
  a2[5] = a1[67];
  a2[6] = a1[60];
  a2[7] = a1[71];
  return 32;
}

uint64_t sub_1B1918DDC(_OWORD *a1, __int128 *a2, int a3)
{
  uint64_t v6;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  if (qword_1ED4CEDA0 != -1)
    dispatch_once(&qword_1ED4CEDA0, &unk_1E63D11D0);
  v6 = sub_1B179CB90(qword_1ED4CEDA8, 0x148uLL);
  sub_1B17A13B4(v6);
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v6 + 208) = _Q0;
  *(_OWORD *)(v6 + 224) = xmmword_1B2268210;
  *(_OWORD *)(v6 + 244) = xmmword_1B2268220;
  *(_OWORD *)(v6 + 260) = xmmword_1B2268230;
  *(_DWORD *)(v6 + 240) = 1065353216;
  *(_DWORD *)(v6 + 280) = 3;
  if (a3)
  {
    v12 = (void *)sub_1B1878138();
    sub_1B17A1B04(v6, v12, v13, v14, v15, v16, v17, v18);
    CFRelease(v12);
  }
  sub_1B17A1BF4(v6, (uint64_t)sub_1B1915170);
  if (a2)
  {
    v26 = *a2;
    v27 = a2[2];
    *(_OWORD *)(v6 + 304) = a2[1];
    *(_OWORD *)(v6 + 320) = v27;
  }
  else
  {
    v26 = 0uLL;
    *(_OWORD *)(v6 + 304) = 0u;
    *(_OWORD *)(v6 + 320) = 0u;
  }
  *(_OWORD *)(v6 + 288) = v26;
  if (*(_DWORD *)(v6 + 276))
  {
    sub_1B1915434(v6, v19, v20, v21, v22, v23, v24, v25);
    *(_DWORD *)(v6 + 276) = 0;
  }
  if (a1)
  {
    *(_OWORD *)(v6 + 208) = *a1;
    v28 = a1[1];
    v29 = a1[2];
    v30 = a1[4];
    *(_OWORD *)(v6 + 256) = a1[3];
    *(_OWORD *)(v6 + 272) = v30;
    *(_OWORD *)(v6 + 224) = v28;
    *(_OWORD *)(v6 + 240) = v29;
  }
  else if (a2)
  {
    (*(void (**)(uint64_t))(v6 + 312))(v6);
  }
  return v6;
}

void sub_1B1918F2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  void *v23;

  sub_1B17A15D0(a1, a2, a3, a4, a5, a6, a7, a8);
  if (*(_QWORD *)(a1 + 288))
  {
    v10 = *(_OWORD *)(a1 + 288);
    v11 = *(_OWORD *)(a1 + 320);
    *(_OWORD *)(a2 + 304) = *(_OWORD *)(a1 + 304);
    *(_OWORD *)(a2 + 320) = v11;
    *(_OWORD *)(a2 + 288) = v10;
  }
  *(_OWORD *)(a2 + 208) = *(_OWORD *)(a1 + 208);
  v12 = *(_OWORD *)(a1 + 224);
  v13 = *(_OWORD *)(a1 + 240);
  v14 = *(_OWORD *)(a1 + 272);
  *(_OWORD *)(a2 + 256) = *(_OWORD *)(a1 + 256);
  *(_OWORD *)(a2 + 272) = v14;
  *(_OWORD *)(a2 + 224) = v12;
  *(_OWORD *)(a2 + 240) = v13;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EEF66520);
  v21 = *(_QWORD *)(a1 + 64);
  v22 = *(const void **)(a1 + 336);
  if ((v21 != 0) == (v22 == 0))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. A parametric geometry with a mesh must also have a hash"), v15, v16, v17, v18, v19, v20, (uint64_t)"hasMesh == (hash != NULL)");
  if (v21)
  {
    sub_1B17A14D4(a2, v21, v15, v16, v17, v18, v19, v20);
    v23 = (void *)CFRetain(v22);
    *(_QWORD *)(a2 + 336) = v23;
    sub_1B1919004(v23);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EEF66520);
}

void sub_1B1919004(void *key)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *Value;

  Value = (char *)CFDictionaryGetValue((CFDictionaryRef)qword_1EEF66530, key);
  if (!Value)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. inconsistency in _CFXParametricGeometryCacheIncrRetainCount"), v2, v3, v4, v5, v6, v7, (uint64_t)"retainCount != 0");
  CFDictionarySetValue((CFMutableDictionaryRef)qword_1EEF66530, key, Value + 1);
}

uint64_t sub_1B1919070(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  switch(a2)
  {
    case 0:
      result = a1 + 208;
      break;
    case 1:
      result = a1 + 212;
      break;
    case 2:
      result = a1 + 216;
      break;
    case 3:
      result = a1 + 224;
      break;
    case 4:
      result = a1 + 220;
      break;
    case 5:
      result = a1 + 228;
      break;
    case 6:
      result = a1 + 232;
      break;
    case 7:
      result = a1 + 236;
      break;
    case 18:
      result = a1 + 240;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_1B19190E4(uint64_t a1, int a2, float a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;

  result = sub_1B1919070(a1, a2);
  if (result)
  {
    v13 = (float *)result;
    if (*(float *)result == a3)
    {
      return 0;
    }
    else
    {
      sub_1B1915434(a1, v6, v7, v8, v9, v10, v11, v12);
      *v13 = a3;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1B191913C(int *a1, int a2)
{
  uint64_t v2;
  int *v3;

  v2 = 0;
  switch(a2)
  {
    case 8:
      v3 = a1 + 61;
      goto LABEL_11;
    case 9:
      v3 = a1 + 62;
      goto LABEL_11;
    case 10:
      v3 = a1 + 63;
      goto LABEL_11;
    case 11:
      v3 = a1 + 64;
      goto LABEL_11;
    case 12:
      v3 = a1 + 65;
      goto LABEL_11;
    case 13:
      v3 = a1 + 66;
      goto LABEL_11;
    case 15:
      v3 = a1 + 67;
      goto LABEL_11;
    case 17:
      v3 = a1 + 69;
      goto LABEL_11;
    case 19:
      v3 = a1 + 70;
LABEL_11:
      v2 = *v3;
      break;
    default:
      return v2;
  }
  return v2;
}

BOOL sub_1B19191B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricgeometry");
  return *(_DWORD *)(a1 + 280) == 2;
}

void sub_1B1919204(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v10;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricgeometry");
  if (v8)
    v10 = 2;
  else
    v10 = 0;
  *(_DWORD *)(a1 + 280) = v10;
  sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
}

BOOL sub_1B1919260(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricgeometry");
  return *(_DWORD *)(a1 + 280) == 1;
}

void sub_1B19192B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricgeometry");
  *(_DWORD *)(a1 + 280) = v8;
  sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B1919300(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(float *)(a1 + 224) != a9)
  {
    *(float *)(a1 + 224) = a9;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B1919378(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(unsigned int *)(a1 + 260);
}

void sub_1B19193C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(_DWORD *)(a1 + 260) != v8)
  {
    *(_DWORD *)(a1 + 260) = v8;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B191942C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(float *)(a1 + 212) != a9)
  {
    *(float *)(a1 + 212) = a9;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B19194A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(unsigned int *)(a1 + 252);
}

void sub_1B19194EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(_DWORD *)(a1 + 252) != v8)
  {
    *(_DWORD *)(a1 + 252) = v8;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B1919558(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(float *)(a1 + 216) != a9)
  {
    *(float *)(a1 + 216) = a9;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B19195D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(unsigned int *)(a1 + 256);
}

void sub_1B1919618(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(_DWORD *)(a1 + 256) != v8)
  {
    *(_DWORD *)(a1 + 256) = v8;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B1919684(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(char *)(a1 + 276);
}

void sub_1B19196CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(_DWORD *)(a1 + 276) != v8)
  {
    *(_DWORD *)(a1 + 276) = v8;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B1919738(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(float *)(a1 + 208) != a9)
  {
    *(float *)(a1 + 208) = a9;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B19197B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(unsigned int *)(a1 + 248);
}

void sub_1B19197F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(_DWORD *)(a1 + 248) != v8)
  {
    *(_DWORD *)(a1 + 248) = v8;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B1919864(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(unsigned int *)(a1 + 272);
}

void sub_1B19198AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v10;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  v10 = v8 & ~(v8 >> 31);
  if (v10 != *(_DWORD *)(a1 + 272))
  {
    *(_DWORD *)(a1 + 272) = v10;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B191991C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(unsigned int *)(a1 + 264);
}

void sub_1B1919964(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(_DWORD *)(a1 + 264) != v8)
  {
    *(_DWORD *)(a1 + 264) = v8;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B19199D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(float *)(a1 + 228) != a9)
  {
    *(float *)(a1 + 228) = a9;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

float sub_1B1919A48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(float *)(a1 + 240);
}

void sub_1B1919A90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(float *)(a1 + 240) != a9)
  {
    *(float *)(a1 + 240) = a9;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B1919B08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(float *)(a1 + 220) != a9)
  {
    *(float *)(a1 + 220) = a9;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B1919B80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(unsigned int *)(a1 + 244);
}

void sub_1B1919BC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(_DWORD *)(a1 + 244) != v8)
  {
    *(_DWORD *)(a1 + 244) = v8;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B1919C34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(float *)(a1 + 236) != a9)
  {
    *(float *)(a1 + 236) = a9;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B1919CAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  return *(unsigned int *)(a1 + 268);
}

void sub_1B1919CF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(_DWORD *)(a1 + 268) != v8)
  {
    *(_DWORD *)(a1 + 268) = v8;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B1919D60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  if (*(float *)(a1 + 232) != a9)
  {
    *(float *)(a1 + 232) = a9;
    sub_1B1915434(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B1919DD8()
{
  const __CFAllocator *v0;
  const CFDictionaryKeyCallBacks *v1;

  if (!qword_1EEF66528)
  {
    v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    qword_1EEF66528 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    qword_1EEF66530 = (uint64_t)CFDictionaryCreateMutable(v0, 0, v1, 0);
  }
}

void sub_1B1919E50(uint64_t a1)
{
  const void *v2;
  char *Value;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;

  sub_1B1919DD8();
  v2 = *(const void **)(a1 + 336);
  if (v2)
  {
    Value = (char *)CFDictionaryGetValue((CFDictionaryRef)qword_1EEF66530, *(const void **)(a1 + 336));
    v10 = Value;
    if (Value)
    {
      if (Value == (char *)1)
      {
        CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_1EEF66528, v2);
        CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_1EEF66530, v2);
LABEL_7:
        CFRelease(*(CFTypeRef *)(a1 + 336));
        *(_QWORD *)(a1 + 336) = 0;
        return;
      }
    }
    else
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. inconsistency in _CFXParametricGeometryReleaseCachedMesh"), v4, v5, v6, v7, v8, v9, (uint64_t)"retainCount>0");
    }
    CFDictionarySetValue((CFMutableDictionaryRef)qword_1EEF66530, v2, v10 - 1);
    goto LABEL_7;
  }
}

id sub_1B1919F04(_QWORD *a1)
{
  if (a1[42])
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1EEF66520);
    sub_1B1919E50((uint64_t)a1);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EEF66520);
  }
  return sub_1B17A0620(a1);
}

__CFString *sub_1B1919F50(_OWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v9;
  const __CFString *v10;
  CFTypeID v11;
  CFStringRef v12;
  __CFString *Mutable;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const __CFArray *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _OWORD __s1[3];

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  v9 = a1[19];
  __s1[0] = a1[18];
  __s1[1] = v9;
  __s1[2] = a1[20];
  if (!memcmp(__s1, &xmmword_1E63D2D98, 0x30uLL))
  {
    v10 = CFSTR("Box");
  }
  else if (!memcmp(__s1, &xmmword_1E63D3B00, 0x30uLL))
  {
    v10 = CFSTR("Pyramid");
  }
  else if (!memcmp(__s1, &xmmword_1E63D3440, 0x30uLL))
  {
    v10 = CFSTR("Cylinder");
  }
  else if (!memcmp(__s1, &xmmword_1E63D3290, 0x30uLL))
  {
    v10 = CFSTR("Cone");
  }
  else if (!memcmp(__s1, &xmmword_1E63D4010, 0x30uLL))
  {
    v10 = CFSTR("Tube");
  }
  else if (!memcmp(__s1, &xmmword_1E63D3260, 0x30uLL))
  {
    v10 = CFSTR("Capsule");
  }
  else if (!memcmp(__s1, &xmmword_1E63D3F20, 0x30uLL))
  {
    v10 = CFSTR("Torus");
  }
  else if (!memcmp(__s1, &xmmword_1E63D3DD0, 0x30uLL))
  {
    v10 = CFSTR("Sphere");
  }
  else if (!memcmp(__s1, &xmmword_1E63D3A70, 0x30uLL))
  {
    v10 = CFSTR("Plane");
  }
  else
  {
    v10 = CFSTR("Unknown");
  }
  v11 = CFGetTypeID(a1);
  v12 = CFCopyTypeIDDescription(v11);
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v21 = sub_1B17A0800((uint64_t)a1, v14, v15, v16, v17, v18, v19, v20);
  CFStringAppendFormat(Mutable, 0, CFSTR("<%@<%@>:%p \"%@\"\n"), v12, v10, a1, v21);
  v29 = sub_1B17A0848((uint64_t)a1, v22, v23, v24, v25, v26, v27, v28);
  CFStringAppendFormat(Mutable, 0, CFSTR("  mesh: %@\n"), v29);
  if ((uint64_t)sub_1B17A08A0((uint64_t)a1, v30, v31, v32, v33, v34, v35, v36) >= 1)
  {
    v43 = 0;
    do
    {
      v44 = sub_1B17A08FC((uint64_t)a1, v43, v37, v38, v39, v40, v41, v42);
      CFStringAppendFormat(Mutable, 0, CFSTR("  mat%d: %@\n"), v43++, v44);
    }
    while (v43 < (uint64_t)sub_1B17A08A0((uint64_t)a1, v45, v46, v47, v48, v49, v50, v51));
  }
  CFStringAppend(Mutable, CFSTR(">"));
  CFRelease(v12);
  return Mutable;
}

uint64_t sub_1B191A1D8(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4)
{
  float32x4_t *v4;
  uint64_t (*v6)(void);

  v4 = *(float32x4_t **)(a1 + 104);
  if (v4)
  {
    *a3 = vsubq_f32(*v4, v4[1]);
    *a4 = vaddq_f32(*(float32x4_t *)*(_QWORD *)(a1 + 104), *(float32x4_t *)(*(_QWORD *)(a1 + 104) + 16));
    return 1;
  }
  else
  {
    v6 = *(uint64_t (**)(void))(a1 + 296);
    if (v6)
      return v6();
    else
      return 0;
  }
}

uint64_t sub_1B191A220(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(a1 + 304);
  if (v1)
    return v1();
  else
    return 0;
}

void sub_1B191A238(uint64_t a1, void *__dst, void *__src, size_t __n)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  memcpy(__dst, __src, __n);
  sub_1B1915434(a1, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B191A26C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"src");
  v9 = sub_1B1918DDC((_OWORD *)(a1 + 208), 0, 0);
  sub_1B1918F2C(a1, v9, v10, v11, v12, v13, v14, v15);
  return v9;
}

void sub_1B191BBEC(uint64_t *a1, uint64_t a2, _QWORD *a3, int __e, int a5)
{
  double v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const float *v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  float32x4_t v41;
  int32x2_t v42;
  int32x2_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  float v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  float v53;
  float v54;
  float32x2_t *v55;
  _QWORD *v56;
  float v57;

  v9 = ldexp(1.0, __e);
  v17 = (const float *)sub_1B17ED6C4(a2, v10, v11, v12, v13, v14, v15, v16);
  v19 = WORD2(v18);
  v32 = sub_1B17EDAE0(a2, v18, v20, v21, v22, v23, v24, v25);
  v56 = a3;
  if (v32 != 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 2))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Morph target has a vertex count different from the base geometry"), v26, v27, v28, v29, v30, v31, (uint64_t)"vertexCount == CFIndex(baseMesh.pointCount())");
  v33 = 3 * v32;
  v34 = a1[1] - *a1;
  sub_1B17F8190((uint64_t)a1, 3 * v32 + (v34 >> 2));
  if (v32 >= 1)
  {
    v44 = 0;
    v45 = 0;
    v46 = v34 >> 2;
    v47 = v19;
    v48 = v9;
    v49 = HIBYTE(v19);
    v50 = 4 * (v34 >> 2);
    v57 = v48;
    do
    {
      *(double *)v41.i64 = sub_1B198D4F8(v47, v17, v35, v36, v37, v38, v39, v40, v41, *(float *)v42.i32, *(float *)v43.i32);
      if (a5)
      {
        v51 = v45 + v46;
        v52 = *a1;
        v53 = v57;
        v42 = vcvt_s32_f32(vrnda_f32(vmul_n_f32(*(float32x2_t *)v41.f32, v57)));
        *(int32x2_t *)(*a1 + v50 + v44) = v42;
        v54 = v41.f32[2];
      }
      else
      {
        v55 = (float32x2_t *)(*v56 + v44);
        v42.i32[0] = v55[1].i32[0];
        v51 = v46 + v45;
        v52 = *a1;
        v53 = v57;
        v43 = vcvt_s32_f32(vrnda_f32(vmul_n_f32(vsub_f32(*(float32x2_t *)v41.f32, *v55), v57)));
        *(int32x2_t *)(*a1 + v50 + v44) = v43;
        v54 = v41.f32[2] - *(float *)v42.i32;
      }
      v41.f32[0] = v54 * v53;
      *(_DWORD *)(v52 + 4 * v51 + 8) = llroundf(v41.f32[0]);
      v17 = (const float *)((char *)v17 + v49);
      v45 += 3;
      v44 += 12;
    }
    while (v45 < v33);
  }
}

uint64_t sub_1B191BD8C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 v27;
  unsigned __int8 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float32x4_t v35;
  float v36;
  float v37;
  const float *v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  const __CFArray *v56;
  _QWORD *v57;
  CFIndex i;
  const void *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  CFIndex v78;
  uint64_t v79;
  const void *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  _QWORD v94[7];
  _OWORD v95[3];
  uint64_t v96;
  _QWORD v97[6];
  _OWORD v98[3];
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t v110;
  uint64_t v111;

  v10 = sub_1B1875E70(a2, 0, a3, a4, a5, a6, a7, a8);
  v18 = sub_1B17EDAE0((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17);
  sub_1B191CA98(a1, v18);
  v26 = sub_1B17ED6C4((uint64_t)v10, v19, v20, v21, v22, v23, v24, v25);
  if (v18 >= 1)
  {
    v38 = (const float *)v26;
    v39 = 0;
    v40 = v27;
    v41 = v28;
    do
    {
      *(double *)v35.i64 = sub_1B198D4F8(v40, v38, v29, v30, v31, v32, v33, v34, v35, v36, v37);
      v42 = *a1 + v39;
      *(_QWORD *)v42 = v35.i64[0];
      *(_DWORD *)(v42 + 8) = v35.i32[2];
      v38 = (const float *)((char *)v38 + v41);
      v39 += 12;
      --v18;
    }
    while (v18);
  }
  v43 = sub_1B1875D94(a2, 0, 0, v30, v31, v32, v33, v34);
  v56 = sub_1B1874BE0(a2, v44, v45, v46, v47, v48, v49, v50);
  v108 = 0;
  v109 = &v108;
  v110 = 0x2020000000;
  v111 = 0;
  v104 = 0;
  v105 = &v104;
  v106 = 0x2020000000;
  v107 = 0;
  v57 = &unk_1B2244000;
  if ((uint64_t)v56 < 1)
  {
    v72 = 0;
  }
  else
  {
    for (i = 0; (const __CFArray *)i != v56; ++i)
    {
      v59 = sub_1B1874C3C(a2, i, 0, v51, v52, v53, v54, v55);
      v103 = 0;
      v101 = 0u;
      v102 = 0u;
      v100 = 0u;
      sub_1B17A4804((uint64_t)v59, v43, v60, v61, v62, v63, v64, v65, (uint64_t)&v100);
      v98[0] = v100;
      v98[1] = v101;
      v98[2] = v102;
      v99 = v103;
      v97[0] = MEMORY[0x1E0C809B0];
      v97[1] = 3221225472;
      v97[2] = sub_1B191C05C;
      v97[3] = &unk_1E63D94D0;
      v97[4] = &v108;
      v97[5] = &v104;
      sub_1B17A5198((uint64_t *)v98, (uint64_t)v97, v66, v67, v68, v69, v70, v71);
    }
    v72 = v109[3];
    v57 = (_QWORD *)&unk_1B2244000;
  }
  sub_1B17F8190((uint64_t)(a1 + 3), v72);
  sub_1B17F8190((uint64_t)(a1 + 6), v105[3]);
  v109[3] = 0;
  v105[3] = 0;
  if ((uint64_t)v56 >= 1)
  {
    v78 = 0;
    v79 = v57[402];
    do
    {
      v80 = sub_1B1874C3C(a2, v78, 0, v73, v74, v75, v76, v77);
      v103 = 0;
      v101 = 0u;
      v102 = 0u;
      v100 = 0u;
      sub_1B17A4804((uint64_t)v80, v43, v81, v82, v83, v84, v85, v86, (uint64_t)&v100);
      v95[0] = v100;
      v95[1] = v101;
      v95[2] = v102;
      v96 = v103;
      v94[0] = MEMORY[0x1E0C809B0];
      v94[1] = v79;
      v94[2] = sub_1B191C090;
      v94[3] = &unk_1E63D94F8;
      v94[5] = &v104;
      v94[6] = a1;
      v94[4] = &v108;
      sub_1B17A5198((uint64_t *)v95, (uint64_t)v94, v87, v88, v89, v90, v91, v92);
      ++v78;
    }
    while (v56 != (const __CFArray *)v78);
  }
  _Block_object_dispose(&v104, 8);
  _Block_object_dispose(&v108, 8);
  return 1;
}

void sub_1B191C028(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B191C05C(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (a4 >= 2)
  {
    ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) += a4;
  }
  return result;
}

_QWORD *sub_1B191C090(_QWORD *result, uint64_t a2, int *a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if (a4 >= 2)
  {
    v4 = result[6];
    v5 = *(_QWORD *)(result[4] + 8);
    v6 = *(_QWORD *)(v5 + 24);
    *(_QWORD *)(v5 + 24) = v6 + 1;
    *(_DWORD *)(*(_QWORD *)(v4 + 24) + 4 * v6) = a4;
    v7 = *(_QWORD *)(v4 + 48);
    v8 = a4;
    do
    {
      v9 = *(_QWORD *)(result[5] + 8);
      v10 = *(_QWORD *)(v9 + 24);
      *(_QWORD *)(v9 + 24) = v10 + 1;
      v11 = *a3++;
      *(_DWORD *)(v7 + 4 * v10) = v11;
      --v8;
    }
    while (v8);
  }
  return result;
}

BOOL sub_1B191C0E8(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const __CFArray *v58;
  CFIndex Count;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  const void *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  char *v93;
  const char *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  const void *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  const void *v113;
  void *v114;
  uint64_t v115;
  int *v116;
  _BYTE *v117;
  id v118;
  const char *v119;
  uint64_t v120;
  void *v121;
  const char *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  const char *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  const char *v134;
  id v135;
  const char *v136;
  uint64_t v137;
  void *v138;
  const char *v139;
  const char *v140;
  const char *v141;
  CFIndex j;
  const void *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  const __CFString *v151;
  size_t v152;
  const char *v153;
  uint64_t v155;
  int64_t v157;
  uint64_t v158;
  uint64_t v159;
  char v160;
  void *__p;
  _BYTE *v162;
  uint64_t v163;
  BOOL v164;
  char v165;
  void *v166[2];
  void *v167[2];
  __int128 v168;
  void *v169[2];
  uint64_t v170;
  char buffer[512];
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v5 = objc_msgSend_nodeRef(a2, (const char *)a2, a3, a4);
  v13 = sub_1B186ACAC(v5, v6, v7, v8, v9, v10, v11, v12);
  v21 = sub_1B1943990(v13, v14, v15, v16, v17, v18, v19, v20);
  v29 = sub_1B17A0848(v21, v22, v23, v24, v25, v26, v27, v28);
  v35 = sub_1B1875D94(v29, 0, 0, v30, v31, v32, v33, v34);
  v42 = sub_1B1875E70(v29, 0, v36, v37, v38, v39, v40, v41);
  v50 = sub_1B17EDAE0((uint64_t)v42, v43, v44, v45, v46, v47, v48, v49);
  v170 = 0;
  v168 = 0u;
  *(_OWORD *)v169 = 0u;
  *(_OWORD *)v166 = 0u;
  *(_OWORD *)v167 = 0u;
  sub_1B191BD8C((uint64_t *)v166, v29, v51, v52, v53, v54, v55, v56);
  v57 = sub_1B17A0A4C(v13);
  v58 = (const __CFArray *)sub_1B17A0A4C(v57);
  Count = CFArrayGetCount(v58);
  v165 = 5;
  v157 = (char *)v166[1] - (char *)v166[0];
  v164 = sub_1B1942070(v57) == 1;
  __p = 0;
  v162 = 0;
  v163 = 0;
  sub_1B17F7530(&__p, 3 * Count * 0xAAAAAAAAAAAAAAABLL * (v157 >> 2));
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v58, i);
      v69 = sub_1B17A0848((uint64_t)ValueAtIndex, v62, v63, v64, v65, v66, v67, v68);
      v76 = sub_1B1875E70(v69, 0, v70, v71, v72, v73, v74, v75);
      v84 = (uint64_t)v76;
      if (v76)
      {
        if (sub_1B17EDAE0((uint64_t)v76, v77, v78, v79, v80, v81, v82, v83) == v50)
        {
          sub_1B191BBEC((uint64_t *)&__p, v84, v166, 5, v164);
        }
        else
        {
          if ((sub_1B1942C9C(v57, v85, v86, v87, v88, v89, v90, v91) & 1) == 0)
          {
            v101 = objc_msgSend_name(a2, v94, v95, v96);
            sub_1B17C4408(16, (uint64_t)CFSTR("Error: Internal consistency error, %@'s (%p) morph %p is not sparse"), v102, v103, v104, v105, v106, v107, v101);
          }
          v108 = sub_1B1874C3C(v69, 0, 0, v96, v97, v98, v99, v100);
          v113 = (const void *)sub_1B17EDF54(v84, (uint64_t)v108, v50, v35, v109, v110, v111, v112);
          sub_1B191BBEC((uint64_t *)&__p, (uint64_t)v113, v166, 5, v164);
          if (v113)
            CFRelease(v113);
        }
      }
      else
      {
        v92 = v162 - (_BYTE *)__p;
        sub_1B17F8190((uint64_t)&__p, (v157 >> 2) + ((v162 - (_BYTE *)__p) >> 2));
        v93 = (char *)__p + 4 * (v92 >> 2);
        if (v162 - v93 >= 1)
          bzero(v93, 4 * (((unint64_t)(v162 - v93) >> 2) - ((unint64_t)(v162 - v93) > 3)) + 4);
      }
    }
  }
  v114 = v167[1];
  v115 = v168;
  v116 = (int *)v169[0];
  v117 = v169[1];
  v118 = objc_alloc(MEMORY[0x1E0C99DF0]);
  v121 = (void *)objc_msgSend_initWithLength_(v118, v119, v157 * Count + 1024, v120);
  v125 = objc_msgSend_mutableBytes(v121, v122, v123, v124);
  v158 = 0;
  v159 = 0;
  v133 = sub_1B2226F30((uint64_t)&v160, (uint64_t)v114, v116, (uint64_t)__p, 3, 0xAAAAAAAAAAAAAAABLL * (v157 >> 2), (v115 - (uint64_t)v114) >> 2, (v117 - (_BYTE *)v116) >> 2, Count, v125, v157 * Count + 1024, &v159, &v158);
  if (v133)
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: AnimCodec - Failed to compress mesh"), v127, v128, v129, v130, v131, v132, v155);

  }
  else
  {
    objc_msgSend_setLength_(v121, v126, v159, v128);
    objc_msgSend_encodeObject_forKey_(a1, v134, (uint64_t)v121, (uint64_t)CFSTR("morpherCompressedData"));

    v135 = objc_alloc(MEMORY[0x1E0C99DF0]);
    v138 = (void *)objc_msgSend_initWithCapacity_(v135, v136, 32 * Count, v137);
    objc_msgSend_appendBytes_length_(v138, v139, (uint64_t)&v165, 1);
    objc_msgSend_appendBytes_length_(v138, v140, (uint64_t)&v164, 1);
    if (Count >= 1)
    {
      for (j = 0; j != Count; ++j)
      {
        v143 = CFArrayGetValueAtIndex(v58, j);
        v151 = (const __CFString *)sub_1B193E568((uint64_t)v143, v144, v145, v146, v147, v148, v149, v150);
        CFStringGetCString(v151, buffer, 512, 0x600u);
        v152 = strlen(buffer);
        objc_msgSend_appendBytes_length_(v138, v153, (uint64_t)buffer, v152 + 1);
      }
    }
    objc_msgSend_encodeObject_forKey_(a1, v141, (uint64_t)v138, (uint64_t)CFSTR("morpherMetaData"));

  }
  if (__p)
  {
    v162 = __p;
    operator delete(__p);
  }
  if (v169[0])
  {
    v169[1] = v169[0];
    operator delete(v169[0]);
  }
  if (v167[1])
  {
    *(void **)&v168 = v167[1];
    operator delete(v167[1]);
  }
  if (v166[0])
  {
    v166[1] = v166[0];
    operator delete(v166[0]);
  }
  return v133 == 0;
}

void sub_1B191C508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  if (__p)
    operator delete(__p);
  sub_1B17DA70C((uint64_t)&a25);
  _Unwind_Resume(a1);
}

uint64_t sub_1B191C578(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  long double v15;
  char *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  float32x2_t *v21;
  uint64_t v22;
  uint64_t v23;
  float32x2_t v24;
  uint64_t v25;
  float *v26;
  float v27;
  float32x2_t *v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v32;
  const char *v33;
  int32x2_t v35;
  _QWORD v36[2];

  v36[1] = *MEMORY[0x1E0C80C00];
  v12 = *a2;
  v11 = a2[1];
  v13 = (v11 - *a2) / 12;
  v14 = v13 * a4;
  v15 = ldexp(1.0, -a5);
  *(float *)&v15 = v15;
  v35 = *(int32x2_t *)&v15;
  v16 = (char *)malloc_type_malloc(4 * v14, 0xB81148E8uLL);
  if (a6)
  {
    if (v11 != v12)
    {
      v18 = 0;
      if (v13 <= 1)
        v19 = 1;
      else
        v19 = v13;
      v20 = *a1 + 4 * v14 * a3;
      do
      {
        v21 = (float32x2_t *)&v16[v18];
        *v21 = vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)(v20 + v18)), *(float *)v35.i32);
        v21[1].f32[0] = *(float *)v35.i32 * (float)*(int *)(v20 + v18 + 8);
        v18 += 4 * a4;
        --v19;
      }
      while (v19);
    }
  }
  else if (v11 != v12)
  {
    v22 = 0;
    if (v13 <= 1)
      v23 = 1;
    else
      v23 = v13;
    v24 = (float32x2_t)vdup_lane_s32(v35, 0);
    v25 = *a1 + 4 * v14 * a3;
    v26 = (float *)(*a2 + 8);
    do
    {
      v27 = *v26;
      v28 = (float32x2_t *)&v16[v22];
      *v28 = vmla_f32(*(float32x2_t *)(v26 - 2), v24, vcvt_f32_s32(*(int32x2_t *)(v25 + v22)));
      v28[1].f32[0] = v27 + (float)((float)*(int *)(v25 + v22 + 8) * *(float *)v35.i32);
      v22 += 4 * a4;
      v26 += 3;
      --v23;
    }
    while (v23);
  }
  v29 = objc_msgSend_dataWithBytesNoCopy_length_freeWhenDone_(MEMORY[0x1E0C99D50], v17, (uint64_t)v16, 4 * v14, 1);
  v36[0] = objc_msgSend_meshSourceWithData_semantic_vectorCount_floatComponents_componentsPerVector_bytesPerComponent_dataOffset_dataStride_(VFXMeshSource, v30, v29, (uint64_t)CFSTR("kGeometrySourceSemanticPosition"), v13, 1, a4, 4, 0, 0);
  v32 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E0C99D20], v31, (uint64_t)v36, 1);
  return objc_msgSend_meshWithSources_elements_(VFXMesh, v33, v32, MEMORY[0x1E0C9AA60]);
}

void *sub_1B191C794(void *a1, void *a2)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  int *v48;
  _BYTE *v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v66;
  const char *v67;
  void *v68;
  const char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _BYTE *v76;
  char v77;
  char v78;
  const char *v79;
  uint64_t v80;
  uint64_t v81;
  const char *v82;
  const __CFAllocator *v83;
  void *v84;
  const char *v85;
  uint64_t v86;
  CFStringRef v87;
  const char *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  void *__p;
  void *v93;
  uint64_t v94;
  _BYTE v95[4];
  unsigned int v96;
  char v97;
  void *v98[2];
  void *v99[2];
  __int128 v100;
  void *v101[2];
  uint64_t v102;

  v4 = objc_opt_class();
  v6 = objc_msgSend_decodeObjectOfClass_forKey_(a1, v5, v4, (uint64_t)CFSTR("morpherCompressedData"));
  if (!v6)
    return 0;
  v10 = (void *)v6;
  v11 = (void *)objc_msgSend_model(a2, v7, v8, v9);
  v15 = objc_msgSend_geometryRef(v11, v12, v13, v14);
  v102 = 0;
  v100 = 0u;
  *(_OWORD *)v101 = 0u;
  *(_OWORD *)v98 = 0u;
  *(_OWORD *)v99 = 0u;
  v23 = sub_1B17A0848(v15, v16, v17, v18, v19, v20, v21, v22);
  sub_1B191BD8C((uint64_t *)v98, v23, v24, v25, v26, v27, v28, v29);
  v33 = objc_msgSend_bytes(v10, v30, v31, v32);
  v37 = objc_msgSend_length(v10, v34, v35, v36);
  if (!sub_1B22246E8(v33, v37, (uint64_t)v95))
  {
    v45 = 0xAAAAAAAAAAAAAAABLL * (((char *)v98[1] - (char *)v98[0]) >> 2);
    v46 = v99[1];
    v47 = v100;
    v48 = (int *)v101[0];
    v49 = v101[1];
    v50 = v96;
    __p = 0;
    v93 = 0;
    v94 = 0;
    sub_1B17F8190((uint64_t)&__p, 3 * v45 * v96);
    v54 = objc_msgSend_bytes(v10, v51, v52, v53);
    v58 = objc_msgSend_length(v10, v55, v56, v57);
    if (sub_1B2224894((uint64_t)&v97, v54, v58, (uint64_t)v46, v48, 3, v45, (v47 - (uint64_t)v46) >> 2, (v49 - (_BYTE *)v48) >> 2, (uint64_t)__p))
    {
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: AnimCodec - Failed to decompress animation"), v59, v60, v61, v62, v63, v64, v91);
    }
    else
    {
      v66 = objc_opt_class();
      v68 = (void *)objc_msgSend_decodeObjectOfClass_forKey_(a1, v67, v66, (uint64_t)CFSTR("morpherMetaData"));
      if (v68)
      {
        v76 = (_BYTE *)objc_msgSend_bytes(v68, v69, v70, v71);
        v77 = *v76;
        v78 = v76[1];
        v44 = (void *)objc_msgSend_arrayWithCapacity_(MEMORY[0x1E0C99DE8], v79, v50, v80);
        if ((_DWORD)v50)
        {
          v81 = 0;
          v82 = v76 + 2;
          v83 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          do
          {
            v84 = (void *)sub_1B191C578(&__p, v98, v81, 3, v77, v78);
            objc_msgSend_addObject_(v44, v85, (uint64_t)v84, v86);
            v87 = CFStringCreateWithCString(v83, v82, 0x8000100u);
            objc_msgSend_setName_(v84, v88, (uint64_t)v87, v89);
            if (v87)
              CFRelease(v87);
            v82 += strlen(v82) + 1;
            ++v81;
          }
          while (v50 != v81);
        }
        goto LABEL_8;
      }
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: AnimCodec - Can't decode metadata"), v70, v71, v72, v73, v74, v75, v91);
    }
    v44 = 0;
LABEL_8:
    if (__p)
    {
      v93 = __p;
      operator delete(__p);
    }
    goto LABEL_10;
  }
  sub_1B17C4408(16, (uint64_t)CFSTR("Error: AnimCodec - Failed to parse header"), v38, v39, v40, v41, v42, v43, v90);
  v44 = 0;
LABEL_10:
  if (v101[0])
  {
    v101[1] = v101[0];
    operator delete(v101[0]);
  }
  if (v99[1])
  {
    *(void **)&v100 = v99[1];
    operator delete(v99[1]);
  }
  if (v98[0])
  {
    v98[1] = v98[0];
    operator delete(v98[0]);
  }
  return v44;
}

void sub_1B191CA50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (__p)
    operator delete(__p);
  sub_1B17DA70C((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void sub_1B191CA98(uint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 2);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    sub_1B191CAD4(a1, v4);
  }
  else if (!v3)
  {
    a1[1] = *a1 + 12 * a2;
  }
}

void sub_1B191CAD4(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  void *__p;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      v13 = 12 * ((12 * a2 - 12) / 0xC) + 12;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 2);
    v9 = v8 + a2;
    if (v8 + a2 > 0x1555555555555555)
      abort();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 2);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0xAAAAAAAAAAAAAAALL)
      v11 = 0x1555555555555555;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)sub_1B191CD0C(v4, v11);
    else
      v12 = 0;
    __p = v12;
    v16 = &v12[12 * v8];
    v18 = &v12[12 * v11];
    v14 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v16, v14);
    v17 = &v16[v14];
    sub_1B191CCA4(a1, &__p);
    if (v17 != v16)
      v17 = &v16[(v17 - v16 - 12) % 0xCuLL];
    if (__p)
      operator delete(__p);
  }
}

void sub_1B191CC58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1B191CCA4(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    v5 = *(_DWORD *)(v2 - 12);
    v2 -= 12;
    *(_DWORD *)(v4 - 12) = v5;
    v4 -= 12;
    *(_DWORD *)(v4 + 4) = *(_DWORD *)(v2 + 4);
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(v2 + 8);
  }
  a2[1] = v4;
  v6 = *result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1B191CD0C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556)
    sub_1B179C4A8();
  return operator new(12 * a2);
}

uint64_t sub_1B191CD50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, CFX::CrossFrameResourceManager *a5, uint64_t *a6)
{
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  id v57;
  const char *v58;
  const char *v59;
  const char *v60;
  const char *v61;
  const char *v62;
  const char *v63;
  uint64_t v64;
  const char *v65;
  const char *v66;
  uint64_t v67;
  void *v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  uint64_t v73;
  uint64_t v74;
  int v75;
  _OWORD v76[10];
  _OWORD v77[10];
  _OWORD v78[10];
  BOOL v79;
  BOOL v80;
  BOOL v81;
  BOOL v82;
  BOOL v83;
  uint64_t v84[2];

  v10 = *a6;
  v84[0] = (uint64_t)"HybridCompositePass";
  v84[1] = v10;
  v11 = atomic_load((unsigned __int8 *)&qword_1EEF66540);
  if ((v11 & 1) == 0)
  {
    v73 = a3;
    v74 = a2;
    v75 = __cxa_guard_acquire(&qword_1EEF66540);
    a2 = v74;
    a3 = v73;
    if (v75)
    {
      byte_1EEF66538 = 1;
      __cxa_guard_release(&qword_1EEF66540);
      a2 = v74;
      a3 = v73;
    }
  }
  if (byte_1EEF66538)
    v12 = 0x2E8422031D6ACA49;
  else
    v12 = 0;
  sub_1B18F7354(a1, a2, a3, v84, v12, 0);
  *(_QWORD *)a1 = &off_1E63CF4A8;
  memcpy((void *)(a1 + 376), a6, 0x108uLL);
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  v20 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 368), v13, v14, v15, v16, v17, v18, v19);
  *(_QWORD *)(a1 + 672) = v20;
  *(_QWORD *)(a1 + 680) = objc_msgSend_resourceManager(v20, v21, v22, v23);
  v31 = sub_1B1813884(*(_QWORD *)(a1 + 368), v24, v25, v26, v27, v28, v29, v30);
  LOBYTE(v84[0]) = 0;
  v34 = sub_1B187B0A0(v31, 0);
  if (v34)
    LOBYTE(v84[0]) = objc_msgSend_textureForMaterialProperty_(*(void **)(a1 + 672), v32, v34, v33) != 0;
  v83 = *(_QWORD *)(a1 + 560) != 0;
  v82 = *(_QWORD *)(a1 + 568) != 0;
  v81 = *(_QWORD *)(a1 + 576) != 0;
  v80 = *(_QWORD *)(a1 + 584) != 0;
  v79 = *(_QWORD *)(a1 + 624) != 0;
  v35 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  v36 = 0x9DDFEA08EB382D69
      * (v35 ^ ((0x9DDFEA08EB382D69 * (v35 ^ v34)) >> 47) ^ (0x9DDFEA08EB382D69 * (v35 ^ v34)));
  v37 = 0x9DDFEA08EB382D69 * (v36 ^ (v36 >> 47));
  v38 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v37 ^ ((0x9DDFEA08EB382D69 * (v37 ^ v83)) >> 47) ^ (0x9DDFEA08EB382D69 * (v37 ^ v83)))) ^ ((0x9DDFEA08EB382D69 * (v37 ^ ((0x9DDFEA08EB382D69 * (v37 ^ v83)) >> 47) ^ (0x9DDFEA08EB382D69 * (v37 ^ v83)))) >> 47));
  v39 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v38 ^ ((0x9DDFEA08EB382D69 * (v38 ^ v82)) >> 47) ^ (0x9DDFEA08EB382D69 * (v38 ^ v82)))) ^ ((0x9DDFEA08EB382D69 * (v38 ^ ((0x9DDFEA08EB382D69 * (v38 ^ v82)) >> 47) ^ (0x9DDFEA08EB382D69 * (v38 ^ v82)))) >> 47));
  v40 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v39 ^ ((0x9DDFEA08EB382D69 * (v39 ^ v81)) >> 47) ^ (0x9DDFEA08EB382D69 * (v39 ^ v81)))) ^ ((0x9DDFEA08EB382D69 * (v39 ^ ((0x9DDFEA08EB382D69 * (v39 ^ v81)) >> 47) ^ (0x9DDFEA08EB382D69 * (v39 ^ v81)))) >> 47));
  v41 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v40 ^ ((0x9DDFEA08EB382D69 * (v40 ^ v80)) >> 47) ^ (0x9DDFEA08EB382D69 * (v40 ^ v80)))) ^ ((0x9DDFEA08EB382D69 * (v40 ^ ((0x9DDFEA08EB382D69 * (v40 ^ v80)) >> 47) ^ (0x9DDFEA08EB382D69 * (v40 ^ v80)))) >> 47));
  v42 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v41 ^ ((0x9DDFEA08EB382D69 * (v41 ^ v79)) >> 47) ^ (0x9DDFEA08EB382D69 * (v41 ^ v79)))) ^ ((0x9DDFEA08EB382D69 * (v41 ^ ((0x9DDFEA08EB382D69 * (v41 ^ v79)) >> 47) ^ (0x9DDFEA08EB382D69 * (v41 ^ v79)))) >> 47));
  v43 = CFX::CrossFrameResourceManager::get(a5, v42);
  v44 = (uint64_t *)(a1 + 640);
  *(_QWORD *)(a1 + 640) = v43;
  if (!v43)
  {
    *(_QWORD *)(a1 + 640) = sub_1B191D250(a5, v42);
    v52 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 368), v45, v46, v47, v48, v49, v50, v51);
    v56 = (void *)objc_msgSend_resourceManager(v52, v53, v54, v55);
    v57 = objc_alloc_init(MEMORY[0x1E0CC6AA0]);
    objc_msgSend_setConstantValue_type_withName_(v57, v58, (uint64_t)v84, 53, CFSTR("has_background"));
    objc_msgSend_setConstantValue_type_withName_(v57, v59, (uint64_t)&v83, 53, CFSTR("has_directLightings"));
    objc_msgSend_setConstantValue_type_withName_(v57, v60, (uint64_t)&v82, 53, CFSTR("has_indirectDiffuse"));
    objc_msgSend_setConstantValue_type_withName_(v57, v61, (uint64_t)&v81, 53, CFSTR("has_specular"));
    objc_msgSend_setConstantValue_type_withName_(v57, v62, (uint64_t)&v80, 53, CFSTR("has_clearcoat"));
    objc_msgSend_setConstantValue_type_withName_(v57, v63, (uint64_t)&v79, 53, CFSTR("has_subsurface"));
    v64 = *v44;
    v67 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(v56, v65, (uint64_t)CFSTR("vfx_hybrid_composite"), (uint64_t)v57);
    v68 = *(void **)(v64 + 16);
    if (v68 != (void *)v67)
    {
      if (v68)

      *(_QWORD *)(v64 + 16) = v67;
    }
    v69 = *v44;
    v70 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(v56, v66, (uint64_t)CFSTR("vfx_hybrid_opacity_filter"), (uint64_t)v57);
    v71 = *(void **)(v69 + 24);
    if (v71 != (void *)v70)
    {
      if (v71)

      *(_QWORD *)(v69 + 24) = v70;
    }

  }
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 384), MTLPixelFormatRGBA16Float, (uint64_t)v78);
  *(_QWORD *)(a1 + 648) = sub_1B17A34D0(a4, (uint64_t)"HybridCompositeTmp", v78);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 384), MTLPixelFormatRGBA16Float, (uint64_t)v77);
  *(_QWORD *)(a1 + 656) = sub_1B17A34D0(a4, (uint64_t)"HybridCompositePassOutput", v77);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 384), MTLPixelFormatRGBA16Float, (uint64_t)v76);
  *(_QWORD *)(a1 + 664) = sub_1B17A34D0(a4, (uint64_t)"HybridCompositePassOutput", v76);
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 544));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 552));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 560));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 568));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 576));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 584));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 608));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 632));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 624));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 616));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 648));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 648));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 664));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 656));
  return a1;
}

void sub_1B191D224(_Unwind_Exception *a1)
{
  CFX::RG::Pass *v1;

  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1B191D250(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v4)
  {
    v4 = (_QWORD *)operator new();
    *v4 = &off_1E63CF488;
    v4[1] = 0;
    v4[2] = 0;
    v4[3] = 0;
    CFX::CrossFrameResourceManager::set((uint64_t)a1, a2, (uint64_t)v4);
  }
  return v4;
}

_QWORD *sub_1B191D2C8(_QWORD *result, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  id Texture;
  id v13;
  id v14;
  id v15;
  id v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  const char *v26;
  const char *v27;
  const char *v28;
  const char *v29;
  const CFX::RG::Resource *v30;
  id v31;
  const char *v32;
  const CFX::RG::Resource *v33;
  id v34;
  const char *v35;
  const CFX::RG::Resource *v36;
  id v37;
  const char *v38;
  const CFX::RG::Resource *v39;
  id v40;
  id v41;
  const char *v42;
  const char *v43;
  const CFX::RG::Resource *v44;
  id v45;
  id v46;
  const char *v47;
  const char *v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  const void *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  simd_float4 *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unsigned __int8 *v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  const char *v96;
  id v97;
  const char *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  const char *v108;
  id v109;
  const char *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  const char *v120;
  id v121;
  const char *v122;
  const char *v123;
  const char *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  const char *v134;
  simd_float4 v135;
  simd_float4 v136;
  simd_float4 v137;
  simd_float4 v138;
  __n128 v139;
  unsigned __int8 v140[176];
  _OWORD v141[4];
  simd_float4x4 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  _OWORD v147[4];
  uint64_t v148;
  simd_float4x4 v149;

  v148 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(result[80] + 16))
  {
    v9 = result;
    v10 = *a3;
    v11 = sub_1B1813884(result[46], a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), (const CFX::RG::Resource *)v9[68]);
    v13 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), (const CFX::RG::Resource *)v9[75]);
    v14 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), (const CFX::RG::Resource *)v9[69]);
    v15 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), (const CFX::RG::Resource *)v9[74]);
    v16 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), (const CFX::RG::Resource *)v9[79]);
    v20 = (void *)objc_msgSend_resourceManager((void *)v9[84], v17, v18, v19);
    v23 = objc_msgSend_specularDFGDiffuseHammonTextureWithRenderContext_(v20, v21, v9[84], v22);
    objc_msgSend_setTexture_atIndex_(v10, v24, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v10, v25, (uint64_t)v14, 1);
    objc_msgSend_setTexture_atIndex_(v10, v26, (uint64_t)v13, 7);
    objc_msgSend_setTexture_atIndex_(v10, v27, (uint64_t)v16, 9);
    objc_msgSend_setTexture_atIndex_(v10, v28, (uint64_t)v15, 6);
    objc_msgSend_setTexture_atIndex_(v10, v29, v23, 10);
    v30 = (const CFX::RG::Resource *)v9[70];
    if (v30)
    {
      v31 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v30);
      objc_msgSend_setTexture_atIndex_(v10, v32, (uint64_t)v31, 2);
    }
    v33 = (const CFX::RG::Resource *)v9[71];
    if (v33)
    {
      v34 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v33);
      objc_msgSend_setTexture_atIndex_(v10, v35, (uint64_t)v34, 3);
    }
    v36 = (const CFX::RG::Resource *)v9[72];
    if (v36)
    {
      v37 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v36);
      objc_msgSend_setTexture_atIndex_(v10, v38, (uint64_t)v37, 4);
    }
    v39 = (const CFX::RG::Resource *)v9[73];
    if (v39)
    {
      v40 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v39);
      v41 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), (const CFX::RG::Resource *)v9[76]);
      objc_msgSend_setTexture_atIndex_(v10, v42, (uint64_t)v40, 5);
      objc_msgSend_setTexture_atIndex_(v10, v43, (uint64_t)v41, 8);
    }
    v44 = (const CFX::RG::Resource *)v9[78];
    if (v44)
    {
      v45 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v44);
      v46 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), (const CFX::RG::Resource *)v9[77]);
      objc_msgSend_setTexture_atIndex_(v10, v47, (uint64_t)v45, 12);
      objc_msgSend_setTexture_atIndex_(v10, v48, (uint64_t)v46, 13);
    }
    v49 = sub_1B187B0A0(v11, 0);
    if (v49)
    {
      v57 = objc_msgSend_textureForMaterialProperty_((void *)v9[84], v50, v49, v52);
      if (v57)
        objc_msgSend_setTexture_atIndex_(v10, v50, v57, 11);
    }
    result = sub_1B1814768((uint64_t *)v9[46], (uint64_t)v50, v51, v52, v53, v54, v55, v56);
    if (result)
    {
      result = sub_1B186CFA8((uint64_t)result, v58, v59, v60, v61, v62, v63, v64);
      if (result)
      {
        v72 = sub_1B1814768((uint64_t *)v9[46], v65, v66, v67, v68, v69, v70, v71);
        sub_1B17B33F4((uint64_t)v72, (uint64_t)v140, v73, v74, v75, v76, v77, v78);
        v79 = (simd_float4 *)sub_1B1815A5C(v9[46], 1);
        v137 = v79[1];
        v138 = *v79;
        v135 = v79[3];
        v136 = v79[2];
        v139 = sub_1B181537C(v9[46], 0, v80, v81, v82, v83, v84, v85);
        memset(v147, 0, sizeof(v147));
        v149.columns[1] = v137;
        v149.columns[0] = v138;
        v141[0] = v138;
        v141[1] = v137;
        v149.columns[3] = v135;
        v149.columns[2] = v136;
        v141[2] = v136;
        v141[3] = v135;
        v142 = __invert_f4(v149);
        v92 = sub_1B18667B4(v140, (uint64_t)&v139, v86, v87, v88, v89, v90, v91);
        v93 = *((_OWORD *)v92 + 1);
        v94 = *((_OWORD *)v92 + 2);
        v95 = *((_OWORD *)v92 + 3);
        v143 = *(_OWORD *)v92;
        v144 = v93;
        v145 = v94;
        v146 = v95;
        objc_msgSend_setBytes_length_atIndex_(v10, v96, (uint64_t)v141, 272, 8);
        v97 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), (const CFX::RG::Resource *)v9[81]);
        objc_msgSend_setTexture_atIndex_(v10, v98, (uint64_t)v97, 16);
        v105 = v9[80];
        v106 = *(_QWORD *)(v105 + 16);
        if (!v106)
        {
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v99, v100, v101, v102, v103, v104, (uint64_t)"_ptr != NULL");
          v106 = *(_QWORD *)(v105 + 16);
        }
        v107 = sub_1B18FD774(v106);
        objc_msgSend_dispatch_onTexture2D_(v10, v108, v107, (uint64_t)v97);
        v109 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), (const CFX::RG::Resource *)v9[82]);
        objc_msgSend_setTexture_atIndex_(v10, v110, (uint64_t)v109, 17);
        v117 = v9[80];
        v118 = *(_QWORD *)(v117 + 16);
        if (!v118)
        {
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v111, v112, v113, v114, v115, v116, (uint64_t)"_ptr != NULL");
          v118 = *(_QWORD *)(v117 + 16);
        }
        v119 = sub_1B18FD774(v118);
        objc_msgSend_dispatch_onTexture2D_(v10, v120, v119, (uint64_t)v109);
        v121 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), (const CFX::RG::Resource *)v9[83]);
        objc_msgSend_setTexture_atIndex_(v10, v122, (uint64_t)v16, 0);
        objc_msgSend_setTexture_atIndex_(v10, v123, (uint64_t)v97, 1);
        objc_msgSend_setTexture_atIndex_(v10, v124, (uint64_t)v121, 2);
        v131 = v9[80];
        v132 = *(_QWORD *)(v131 + 24);
        if (!v132)
        {
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Dereferencing null pointer"), v125, v126, v127, v128, v129, v130, (uint64_t)"_ptr != NULL");
          v132 = *(_QWORD *)(v131 + 24);
        }
        v133 = sub_1B18FD774(v132);
        return (_QWORD *)objc_msgSend_dispatch_onTexture2D_(v10, v134, v133, (uint64_t)v121);
      }
    }
  }
  return result;
}

uint64_t sub_1B191D724(uint64_t a1)
{
  return *(_QWORD *)(a1 + 664);
}

uint64_t sub_1B191D72C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 656);
}

uint64_t sub_1B191D734(uint64_t *a1, CFX::CrossFrameResourceManager *a2, uint64_t *a3)
{
  return sub_1B191D744(a1, a1, a2, a3);
}

uint64_t sub_1B191D744(uint64_t *a1, uint64_t *a2, CFX::CrossFrameResourceManager *a3, uint64_t *a4)
{
  uint64_t v7;
  uint64_t v9[2];

  v7 = a1[1];
  v9[0] = *a1;
  v9[1] = v7;
  v9[0] = sub_1B191D85C(v9[0], v7, v9, a2, a3, a4);
  sub_1B179C734(a1 + 18, v9);
  return v9[0];
}

void sub_1B191D7A0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);
  JUMPOUT(0x1B5E22E18);
}

_QWORD *sub_1B191D7C4(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_1E63CF488;
  v2 = (void *)a1[3];
  if (v2)

  v3 = (void *)a1[2];
  if (v3)

  return a1;
}

void sub_1B191D808(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_1E63CF488;
  v2 = (void *)a1[3];
  if (v2)

  v3 = (void *)a1[2];
  if (v3)

  JUMPOUT(0x1B5E22E18);
}

uint64_t sub_1B191D85C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, CFX::CrossFrameResourceManager *a5, uint64_t *a6)
{
  uint64_t v10;
  _QWORD v12[2];

  v12[0] = a1;
  v12[1] = a2;
  v10 = sub_1B179C1C0(v12, 0x2B0u, 8u);
  return sub_1B191CD50(v10, *a3, a3[1], a4, a5, a6);
}

uint64_t sub_1B191D8C0(uint64_t *a1)
{
  uint64_t result;

  result = sub_1B179CB60(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B191D8EC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (qword_1EEF66550 != -1)
    dispatch_once_f(&qword_1EEF66550, &qword_1EEF66548, (dispatch_function_t)sub_1B191D8C0);
  v0 = sub_1B179CB90(qword_1EEF66548, 0x20uLL);
  *(_QWORD *)(v0 + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  v1 = sub_1B17C4468(2);
  if (v1)
    v8 = v1;
  else
    v8 = 1000;
  sub_1B191D98C(v0, v8, v2, v3, v4, v5, v6, v7);
  return v0;
}

void *sub_1B191D98C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *result;

  if (*(_QWORD *)(a1 + 32))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Can't change max batch size while in batch"), a3, a4, a5, a6, a7, a8, (uint64_t)"dynamicBatchingSystem->_currentBatchInstancesCount == 0");
  if (a2 <= 1)
    a2 = 1;
  free(*(void **)(a1 + 24));
  result = malloc_type_malloc(8 * a2, 0x2004093837F09uLL);
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = a2;
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

uint64_t sub_1B191DA08(uint64_t result)
{
  *(_QWORD *)(result + 32) = 0;
  return result;
}

BOOL sub_1B191DA10(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t vars0;

  v8 = a1[4];
  v9 = a1[5];
  if (v8 >= v9)
  {
    sub_1B17C4408(0, (uint64_t)CFSTR("Warning: overflow the max batch size boundary"), a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }
  else
  {
    v10 = a1[3];
    a1[4] = v8 + 1;
    *(_QWORD *)(v10 + 8 * v8) = a2;
    return v8 + 1 < v9;
  }
}

uint64_t sub_1B191DA5C(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v3;

  v3 = a1 + 24;
  result = *(_QWORD *)(a1 + 24);
  *a2 = *(_QWORD *)(v3 + 8);
  return result;
}

void sub_1B191DA6C(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 16));
  free(*(void **)(a1 + 24));
}

CFStringRef sub_1B191DA94(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXDynamicBatchingSystem %p>"), a1);
}

CFStringRef sub_1B191DAD0(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXDynamicBatchingSystem %p>"), a1);
}

double sub_1B191DB0C@<D0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, _OWORD *a7@<X7>, uint64_t a8@<X8>)
{
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double result;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  uint64_t *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  unsigned __int8 v31[24];
  __int128 v32;
  _BYTE v33[16];
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v32 = a5;
  *((_QWORD *)&v32 + 1) = a6;
  v14 = *(_QWORD *)(a4 + 40);
  if (!v14)
  {
    v14 = -1;
    *(_QWORD *)(a4 + 40) = -1;
  }
  v33[0] = *(_BYTE *)(a4 + 1) ^ 1;
  v33[1] = 0;
  v34 = *(_OWORD *)(a4 + 16);
  v35 = *(_QWORD *)(a4 + 32);
  v36 = v14;
  v37 = *(_QWORD *)(a4 + 48);
  sub_1B18A8498(v31, a3, v35);
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v15 = sub_1B17A2DF4(a1, a2, a3, (uint64_t)v33, v31, (uint64_t)&v27, &v32, a7);
  v19 = *((_QWORD *)&v27 + 1);
  v18 = v27;
  if (*(_BYTE *)(a4 + 2))
  {
    v22 = v27;
    v23 = v28;
    v24 = v29;
    v25 = *((_QWORD *)&v28 + 1);
    v26 = v15;
    v21 = 0;
    v15 = sub_1B17DDBA8((CFX::RG *)a1, (CFX::RG::RenderGraphContext *)a2, (CFX::RG::Resource *)a3, (uint64_t)v31, (uint64_t)&v22, (uint64_t)&v21, v16, v17);
    if (v21)
      v18 = v21;
  }
  result = 0.0;
  *(_OWORD *)(a8 + 120) = 0u;
  *(_OWORD *)(a8 + 104) = 0u;
  *(_OWORD *)(a8 + 88) = 0u;
  *(_OWORD *)(a8 + 72) = 0u;
  *(_OWORD *)(a8 + 56) = 0u;
  *(_OWORD *)(a8 + 40) = 0u;
  *(_OWORD *)(a8 + 24) = 0u;
  *(_QWORD *)a8 = v15;
  *(_QWORD *)(a8 + 8) = v18;
  *(_QWORD *)(a8 + 16) = v19;
  return result;
}

double sub_1B191DC78@<D0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>, float a6@<S0>)
{
  uint64_t *v7;
  double result;
  uint64_t v9;
  _QWORD v10[2];

  v10[0] = a2;
  v10[1] = a4;
  v7 = sub_1B19C5898(a1, a3, (uint64_t)v10, a6);
  *(_QWORD *)(a5 + 128) = 0;
  result = 0.0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  v9 = v7[50];
  *(_QWORD *)a5 = v7;
  *(_QWORD *)(a5 + 8) = v9;
  return result;
}

double sub_1B191DCD0@<D0>(uint64_t *a1@<X0>, CFX::RG::RenderGraphContext *a2@<X1>, uint64_t a3@<X2>, const CFX::RG::Resource *a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  __int128 *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  double result;
  uint64_t v20;
  _QWORD v21[3];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;

  v21[0] = a3;
  v21[1] = 0;
  v21[2] = a4;
  v10 = (__int128 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(a2, a4);
  v22 = *v10;
  v11 = v10[3];
  v12 = v10[4];
  v13 = v10[2];
  v23 = v10[1];
  v24 = v13;
  v25 = v11;
  v26 = v12;
  v18 = sub_1B179B930(a1, (uint64_t)a2, (uint64_t)v21, a5, v14, v15, v16, v17);
  result = 0.0;
  *(_OWORD *)(a6 + 16) = 0u;
  *(_OWORD *)(a6 + 32) = 0u;
  *(_OWORD *)(a6 + 48) = 0u;
  *(_OWORD *)(a6 + 64) = 0u;
  *(_OWORD *)(a6 + 80) = 0u;
  *(_OWORD *)(a6 + 96) = 0u;
  *(_OWORD *)(a6 + 112) = 0u;
  *(_QWORD *)(a6 + 128) = 0;
  v20 = v18[93];
  *(_QWORD *)a6 = v18;
  *(_QWORD *)(a6 + 8) = v20;
  return result;
}

double sub_1B191DD68@<D0>(CFX::RG::Resource *this@<X2>, uint64_t *a2@<X0>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  _OWORD *v10;
  CFX::RG::Resource *v11;
  uint64_t CopyPass;
  uint64_t *v13;
  unint64_t v14;
  CFX::RG::Resource *v15;
  uint64_t v16;
  uint64_t v17;
  double result;
  __int128 v19;
  CFX::RG::Resource *v20;
  uint64_t v21;
  _OWORD v22[10];
  CFX::RG::Resource *v23;
  uint64_t v24;

  v24 = a4;
  v10 = (_OWORD *)CFX::RG::Resource::constTextureDesc(this);
  CFX::RG::TextureDescriptorReference::withSampleCount(v10, 1, (uint64_t)v22);
  v11 = sub_1B17A34D0(a2, (uint64_t)"Custom subgraph published texture", v22);
  v23 = v11;
  *(_QWORD *)&v19 = this;
  DWORD2(v19) = 0;
  v20 = v11;
  v21 = 0x100000000;
  CopyPass = CFX::RG::makeCopyPass(a2, (uint64_t)"Copy to final", &v19);
  CFX::RG::ResourceIdentifier::ResourceIdentifier(&v19, a3);
  if (a4)
  {
    v13 = (uint64_t *)sub_1B191DE94(a2, &v23, &v24);
    CFX::RG::Pass::readFrom(v13, v23);
    v14 = v19;
    v15 = v23;
    v16 = (uint64_t)a2;
    v17 = (uint64_t)v13;
  }
  else
  {
    v14 = v19;
    v16 = (uint64_t)a2;
    v15 = v11;
    v17 = CopyPass;
  }
  CFX::RG::RenderGraphBuilder::publishResourceReference(v16, v14, (unint64_t)v15, v17);
  result = 0.0;
  *(_OWORD *)(a5 + 120) = 0u;
  *(_OWORD *)(a5 + 104) = 0u;
  *(_OWORD *)(a5 + 88) = 0u;
  *(_OWORD *)(a5 + 72) = 0u;
  *(_OWORD *)(a5 + 56) = 0u;
  *(_OWORD *)(a5 + 40) = 0u;
  *(_OWORD *)(a5 + 24) = 0u;
  *(_OWORD *)(a5 + 8) = 0u;
  *(_QWORD *)a5 = CopyPass;
  return result;
}

uint64_t sub_1B191DE94(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v7[2];

  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B191E1A4(v7[0], v5, v7, a2, a3);
  sub_1B179C734(a1 + 18, v7);
  return v7[0];
}

CFX::RG::Resource *sub_1B191DEE8(uint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  char FinalTexture;
  CFX::RG::Resource *v16;
  id v18[24];
  _QWORD v19[5];
  _BYTE v20[32];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[160];
  id v25[24];

  v11 = (void *)sub_1B1813BC4(a3, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v22 = 0u;
  v23 = 0u;
  v21 = 0u;
  memset(v20, 0, sizeof(v20));
  RGTextureDescriptorMake2D(COERCE_FLOAT(a2[2]), COERCE_FLOAT(HIDWORD(a2[2])), a2[3], (uint64_t)v20);
  *((_QWORD *)&v21 + 1) = a2[4];
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference(v24, v20);
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 3221225472;
  v19[2] = sub_1B191E148;
  v19[3] = &unk_1E63D9540;
  v19[4] = a3;
  CFX::RG::ExternalResourceDesc::ExternalResourceDesc(v25, v24, v19, 0);
  FinalTexture = objc_msgSend_requireLoadFinalTexture(v11, v12, v13, v14);
  CFX::RG::ExternalResourceDesc::setRequireLoad((uint64_t)v25, FinalTexture);
  CFX::RG::ExternalResourceDesc::ExternalResourceDesc((uint64_t)v18, (__int128 *)v25);
  v16 = sub_1B17CC3F8(a1, (uint64_t)"DRAWABLE", (__int128 *)v18);
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(v18);
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(v25);
  return v16;
}

void sub_1B191E004(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc((id *)va);
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc((id *)(v2 - 240));
  _Unwind_Resume(a1);
}

double sub_1B191E028@<D0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X3>, uint64_t a4@<X8>)
{
  CFX::RG::Resource *v8;
  uint64_t CopyPass;
  double result;
  _QWORD v11[5];
  __int128 v12;
  CFX::RG::Resource *v13;
  uint64_t v14;
  _BYTE v15[160];
  id v16[24];

  RGTextureDescriptorFromMTLTexture(a3, (uint64_t)&v12);
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference(v15, &v12);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = sub_1B191E140;
  v11[3] = &unk_1E63D9520;
  v11[4] = a3;
  CFX::RG::ExternalResourceDesc::ExternalResourceDesc(v16, v15, v11, 0);
  v8 = sub_1B17CC3F8(a1, (uint64_t)"Copy to External", (__int128 *)v16);
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(v16);
  *(_QWORD *)&v12 = a2;
  DWORD2(v12) = 0;
  v13 = v8;
  v14 = 0x100000000;
  CopyPass = CFX::RG::makeCopyPass(a1, (uint64_t)"Copy", &v12);
  *(_QWORD *)(a4 + 128) = 0;
  result = 0.0;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_QWORD *)a4 = CopyPass;
  *(_QWORD *)(a4 + 8) = v8;
  return result;
}

void sub_1B191E12C(_Unwind_Exception *a1)
{
  uint64_t v1;

  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc((id *)(v1 - 240));
  _Unwind_Resume(a1);
}

uint64_t sub_1B191E140(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t sub_1B191E148(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  prof_beginFlame((uint64_t)"Get drawable", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/RenderGraphLibrary.mm", 276);
  v9 = (void *)sub_1B1813BC4(*(_QWORD *)(a1 + 32), v2, v3, v4, v5, v6, v7, v8);
  v13 = objc_msgSend__finalRenderTexture(v9, v10, v11, v12);
  prof_endFlame();
  return v13;
}

void sub_1B191E194(_Unwind_Exception *a1)
{
  prof_endFlame();
  _Unwind_Resume(a1);
}

uint64_t sub_1B191E1A4(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v8;
  _QWORD v10[2];

  v10[0] = a1;
  v10[1] = a2;
  v8 = sub_1B179C1C0(v10, 0x178u, 8u);
  return CFX::RG::RegisterResourcePass::RegisterResourcePass(v8, *a3, a3[1], *a4, *a5);
}

uint64_t sub_1B191E200()
{
  if (qword_1EEF66560 != -1)
    dispatch_once(&qword_1EEF66560, &unk_1E63D11F0);
  return qword_1EEF66558;
}

void sub_1B191E240()
{
  if (!qword_1EEF66558)
  {
    qword_1EEF66558 = sub_1B179CB60(&qword_1EEF66558);
    qword_1ED4AF8C0 = (uint64_t)sub_1B191EBDC;
  }
}

uint64_t sub_1B191E290(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;

  if (!a2 || a1 && !sub_1B179E250(a1, a2, a3, a4, a5, a6, a7, a8))
    return 0;
  if (qword_1EEF66560 != -1)
    dispatch_once(&qword_1EEF66560, &unk_1E63D11F0);
  v10 = sub_1B179CB90(qword_1EEF66558, 0x18uLL);
  v18 = v10;
  *(_BYTE *)(v10 + 18) = 0;
  *(_WORD *)(v10 + 16) = a1;
  *(_QWORD *)(v10 + 32) = a2;
  if (a1)
  {
    v19 = sub_1B191E340(v10, v11, v12, v13, v14, v15, v16, v17);
    *(_QWORD *)(v18 + 24) = malloc_type_calloc(v19, 1uLL, 0x10AF9C92uLL);
  }
  return v18;
}

uint64_t sub_1B191E340(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"value");
  return *(_QWORD *)(a1 + 32) * sub_1B179E250(*(__int16 *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B191E394(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;

  v9 = sub_1B191E290(a1, 1, a3, a4, a5, a6, a7, a8);
  v16 = v9;
  if (a1 == 10)
  {
    if (!v9)
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v10, v11, v12, v13, v14, v15, (uint64_t)"value");
    v17 = *(_OWORD **)(v16 + 24);
    *v17 = xmmword_1B2244DB0;
    v17[1] = xmmword_1B2244DD0;
    v17[2] = xmmword_1B2244D90;
    v17[3] = xmmword_1B2244E20;
  }
  return v16;
}

uint64_t sub_1B191E41C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"value");
  return *(_QWORD *)(a1 + 24);
}

uint64_t sub_1B191E464(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"value");
  return *(__int16 *)(a1 + 16);
}

uint64_t sub_1B191E4AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"value");
  return *(char *)(a1 + 18);
}

CFTypeRef sub_1B191E4F4(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef *v10;
  CFTypeRef result;
  size_t v12;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"value");
  if (*(_BYTE *)(a1 + 18) == 1)
  {
    v10 = *(CFTypeRef **)(a1 + 24);
    if (*v10)
    {
      CFRelease(*v10);
      *v10 = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *v10 = result;
  }
  else
  {
    v12 = sub_1B191E340(a1, (uint64_t)cf, a3, a4, a5, a6, a7, a8);
    return memcpy(*(void **)(a1 + 24), cf, v12);
  }
  return result;
}

size_t sub_1B191E598(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;

  v16 = sub_1B191E340(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v10, v11, v12, v13, v14, v15, (uint64_t)"value");
  memcpy(a2, *(const void **)(a1 + 24), v16);
  return v16;
}

void sub_1B191E604(const char *a1, int *a2, int a3)
{
  const char *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char *v10;
  unsigned int v11;
  int v12;
  _DWORD *v13;
  int v14;
  int v15;
  uint64_t v16;
  char *v17;

  if (a3)
  {
    v5 = sub_1B179F0AC(a1);
    if (a3 >= 1)
    {
      v6 = v5;
      v7 = 0;
      v8 = MEMORY[0x1E0C80978];
      while (1)
      {
        v17 = 0;
        *(float *)&v9 = strtod(v6, &v17);
        a2[v7] = v9;
        if (v6 == v17)
          break;
        v10 = v17 - 1;
        do
        {
          v11 = v10[1];
          if ((v11 & 0x80000000) != 0)
            v12 = __maskrune(v10[1], 0x4000uLL);
          else
            v12 = *(_DWORD *)(v8 + 4 * v11 + 60) & 0x4000;
          ++v10;
        }
        while (v12);
        if (v11 == 44)
          v6 = v10 + 1;
        else
          v6 = v10;
        if (++v7 == a3)
          return;
      }
      if ((_DWORD)v7 == 1 && a3 >= 2)
      {
        v14 = *a2;
        v13 = a2 + 1;
        v15 = v14;
        v16 = a3 - 1;
        do
        {
          *v13++ = v15;
          --v16;
        }
        while (v16);
      }
    }
  }
}

char *sub_1B191E6F8(char *result, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *i;
  unsigned int v9;
  char *v10;

  if (!a3)
    return result;
  result = (char *)sub_1B179F0AC(result);
  v10 = result;
  if (a3 < 1)
    return result;
  v5 = 0;
  v6 = a3;
  v7 = MEMORY[0x1E0C80978];
  do
  {
    *(double *)(a2 + 8 * v5) = strtod(v10, &v10);
    for (i = v10 + 1; ; ++i)
    {
      v9 = *(i - 1);
      if ((v9 & 0x80000000) != 0)
        break;
      result = (char *)(*(_DWORD *)(v7 + 4 * v9 + 60) & 0x4000);
      if (!(_DWORD)result)
        goto LABEL_10;
LABEL_9:
      v10 = i;
    }
    result = (char *)__maskrune(*(i - 1), 0x4000uLL);
    if ((_DWORD)result)
      goto LABEL_9;
LABEL_10:
    if (v9 == 44)
      v10 = i;
    ++v5;
  }
  while (v5 != v6);
  return result;
}

CFStringRef sub_1B191E7BC(const __CFString *a1, const __CFString *a2)
{
  CFRange v3;
  CFRange v4;

  v3 = CFStringFind(a1, a2, 0);
  if (v3.location == -1)
    return 0;
  v4.length = CFStringGetLength(a1) - (v3.location + v3.length);
  if (v4.length < 1)
    return 0;
  v4.location = v3.location + v3.length;
  return CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v4);
}

uint64_t sub_1B191E834(uint64_t a1, CFStringRef str, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v11;
  float DoubleValue;
  BOOL v13;
  uint64_t result;
  uint64_t v15;
  const char *v16;
  const char *v17;
  const char *v18;
  const char *v19;
  const char *v20;
  const char *v21;
  __int128 v22;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"value");
  v10 = *(__int16 *)(a1 + 16) - 1;
  v11 = *(_QWORD *)(a1 + 24);
  switch(v10)
  {
    case 0:
      DoubleValue = CFStringGetDoubleValue(str);
      *(float *)v11 = DoubleValue;
      goto LABEL_22;
    case 1:
      *(_DWORD *)v11 = CFStringGetIntValue(str);
      goto LABEL_22;
    case 2:
      if (CFStringCompare(str, CFSTR("true"), 0))
      {
        v13 = 1;
      }
      else if (CFStringCompare(str, CFSTR("false"), 0))
      {
        v13 = 0;
      }
      else
      {
        v13 = CFStringGetIntValue(str) != 0;
      }
      *(_BYTE *)v11 = v13;
      goto LABEL_22;
    case 6:
      v15 = 0;
      *(_QWORD *)&v22 = 0;
      v16 = (const char *)sub_1B191E7BC(str, CFSTR("vec2("));
      if (v16)
      {
        v17 = v16;
        sub_1B191E604(v16, (int *)&v22, 2);
        CFRelease(v17);
        v15 = v22;
      }
      *(_QWORD *)v11 = v15;
      goto LABEL_22;
    case 7:
      v22 = 0uLL;
      v18 = (const char *)sub_1B191E7BC(str, CFSTR("vec3("));
      if (v18)
      {
        v19 = v18;
        sub_1B191E604(v18, (int *)&v22, 3);
        CFRelease(v19);
      }
      *(_QWORD *)v11 = v22;
      *(_DWORD *)(v11 + 8) = DWORD2(v22);
      goto LABEL_22;
    case 8:
      v22 = 0uLL;
      v20 = (const char *)sub_1B191E7BC(str, CFSTR("vec4("));
      if (v20)
      {
        v21 = v20;
        sub_1B191E604(v20, (int *)&v22, 4);
        CFRelease(v21);
      }
      *(_OWORD *)v11 = v22;
LABEL_22:
      result = 1;
      break;
    default:
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. string to type conversion not supported"), a3, a4, a5, a6, a7, a8, (uint64_t)"0");
      result = 0;
      break;
  }
  return result;
}

void sub_1B191EA10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v12;

  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"a");
    if (a2)
    {
LABEL_3:
      if (a3)
        goto LABEL_4;
LABEL_16:
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"output");
      if (a1)
        goto LABEL_5;
      goto LABEL_17;
    }
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"b");
  if (!a3)
    goto LABEL_16;
LABEL_4:
  if (a1)
    goto LABEL_5;
LABEL_17:
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"value");
LABEL_5:
  v12 = *(unsigned __int16 *)(a1 + 16);
  if (!a2)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"value");
  if (v12 != *(unsigned __int16 *)(a2 + 16))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. CFXValueAdd - invalid arguments"), a3, a4, a5, a6, a7, a8, (uint64_t)"type == CFXValueGetType(b)");
  if (!a3)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"value");
  if (v12 != *(unsigned __int16 *)(a3 + 16))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. CFXValueAdd - invalid arguments"), a3, a4, a5, a6, a7, a8, (uint64_t)"type == CFXValueGetType(output)");
  sub_1B179ED9C((__int16)v12, *(_OWORD **)(a1 + 24), *(float32x4_t **)(a2 + 24), *(_OWORD **)(a3 + 24), a5, a6, a7, a8, a9);
}

void sub_1B191EB7C(uint64_t a1)
{
  free(*(void **)(a1 + 24));
}

CFStringRef sub_1B191EB88(uint64_t a1)
{
  const __CFAllocator *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFString *v10;

  v2 = CFGetAllocator((CFTypeRef)a1);
  v10 = sub_1B179E5A0(*(__int16 *)(a1 + 16), v3, v4, v5, v6, v7, v8, v9);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXValue %p - %@ ptr:%p >"), a1, v10, *(_QWORD *)(a1 + 24));
}

__CFArray *sub_1B191EBDC(uint64_t a1)
{
  __CFArray *Mutable;
  __CFDictionary *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  __CFDictionary *v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  __CFDictionary *v11;
  int v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  uint64_t v17;
  int v18;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v18 = 0;
  valuePtr = 2;
  v17 = a1 + 16;
  v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v18);
  v6 = CFNumberCreate(0, kCFNumberLongType, &v17);
  CFDictionarySetValue(v3, CFSTR("name"), CFSTR("baseType"));
  CFDictionarySetValue(v3, CFSTR("type"), v4);
  CFDictionarySetValue(v3, CFSTR("address"), v6);
  CFDictionarySetValue(v3, CFSTR("semantic"), v5);
  CFArrayAppendValue(Mutable, v3);
  CFRelease(v5);
  CFRelease(v3);
  CFRelease(v6);
  CFRelease(v4);
  v7 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v18 = 0;
  valuePtr = 2;
  v17 = a1 + 32;
  v8 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v9 = CFNumberCreate(0, kCFNumberSInt32Type, &v18);
  v10 = CFNumberCreate(0, kCFNumberLongType, &v17);
  CFDictionarySetValue(v7, CFSTR("name"), CFSTR("count"));
  CFDictionarySetValue(v7, CFSTR("type"), v8);
  CFDictionarySetValue(v7, CFSTR("address"), v10);
  CFDictionarySetValue(v7, CFSTR("semantic"), v9);
  CFArrayAppendValue(Mutable, v7);
  CFRelease(v9);
  CFRelease(v7);
  CFRelease(v10);
  CFRelease(v8);
  v11 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v12 = *(__int16 *)(a1 + 16);
  v18 = 0;
  valuePtr = v12;
  v17 = *(_QWORD *)(a1 + 24);
  v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v18);
  v15 = CFNumberCreate(0, kCFNumberLongType, &v17);
  CFDictionarySetValue(v11, CFSTR("name"), CFSTR("value"));
  CFDictionarySetValue(v11, CFSTR("type"), v13);
  CFDictionarySetValue(v11, CFSTR("address"), v15);
  CFDictionarySetValue(v11, CFSTR("semantic"), v14);
  CFArrayAppendValue(Mutable, v11);
  CFRelease(v14);
  CFRelease(v11);
  CFRelease(v15);
  CFRelease(v13);
  return Mutable;
}

CFStringRef sub_1B191F448(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  return sub_1B193E5B0(v5, *(CFStringRef *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B191F7A0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;

  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40), a4);
  if ((sub_1B18C2F24(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 40));
    objc_msgSend_removeObjectForKey_(*(void **)(*(_QWORD *)(a1 + 40) + 48), v10, *(_QWORD *)(a1 + 48), v11);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 40));
  }
}

void sub_1B191F970(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C30E4(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B191FA1C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C3148(*(void **)(a1 + 32), a2, a3, a4, *(float *)(a1 + 40));
}

void sub_1B191FAD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C2FF4(*(void **)(a1 + 32), *(char **)(a1 + 40), a3, a4);
}

void sub_1B191FB9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C3064(*(void **)(a1 + 32), *(char **)(a1 + 40), a3, a4, *(float *)(a1 + 48));
}

void sub_1B192007C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFXBinding *v24;

  v5 = (_QWORD *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  v24 = objc_alloc_init(CFXBinding);
  v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(_QWORD *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(_QWORD *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(_QWORD *)(a1 + 64), v17);
  sub_1B193F4C8(v5, v24, v18, v19, v20, v21, v22, v23);

}

void sub_1B19201A8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B193F704(v5, *(const __CFString **)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B1920254(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B193F68C(v4, v5, v6, v7, v8, v9, v10, v11);
}

void *sub_1B19206C4(void *a1, const char *a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  void *v8;
  id v9;
  void *v10;
  id v11;
  id v13;

  v13 = 0;
  v8 = (void *)objc_msgSend_newLibraryWithSource_options_error_(a1, a2, a3, a4, &v13);
  v9 = v13;
  v10 = v9;
  if (v8)
  {
    if (*a5)
      *a5 = objc_retainAutorelease(v9);
    v11 = v8;
  }
  else if (a6)
  {
    *a6 = objc_retainAutorelease(v9);
  }

  return v8;
}

void sub_1B19208E0(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  v3 = (const void *)a1[2];
  if (v3)
  {
    CFRelease(v3);
    a1[2] = 0;
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
}

void sub_1B192092C()
{
  if (!qword_1EEF66568)
  {
    qword_1EEF66568 = sub_1B179CB60(&qword_1EEF66568);
    qword_1ED4AF050 = (uint64_t)sub_1B1920B54;
  }
}

uint64_t sub_1B192097C()
{
  if (qword_1EEF66570 != -1)
    dispatch_once(&qword_1EEF66570, &unk_1E63D1210);
  return sub_1B179CB90(qword_1EEF66568, 0x18uLL);
}

uint64_t sub_1B19209C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"sampler");
  return *(_QWORD *)(a1 + 16);
}

CFTypeRef sub_1B1920A08(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"sampler");
  result = *(CFTypeRef *)(a1 + 24);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 24) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 24) = result;
  }
  return result;
}

uint64_t sub_1B1920A80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"sampler");
  return *(_QWORD *)(a1 + 24);
}

uint64_t sub_1B1920AC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"sampler");
  return *(_QWORD *)(a1 + 32);
}

CFStringRef sub_1B1920B14(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXFXSampler>"));
}

CFStringRef sub_1B1920B34(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFXFXSampler>"));
}

__CFArray *sub_1B1920B54(uint64_t a1)
{
  __CFArray *Mutable;
  __CFDictionary *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  __CFDictionary *v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  uint64_t v12;
  int v13;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v13 = 2;
  valuePtr = 5;
  v12 = a1 + 16;
  v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v13);
  v6 = CFNumberCreate(0, kCFNumberLongType, &v12);
  CFDictionarySetValue(v3, CFSTR("name"), CFSTR("sampler"));
  CFDictionarySetValue(v3, CFSTR("type"), v4);
  CFDictionarySetValue(v3, CFSTR("address"), v6);
  CFDictionarySetValue(v3, CFSTR("semantic"), v5);
  CFArrayAppendValue(Mutable, v3);
  CFRelease(v5);
  CFRelease(v3);
  CFRelease(v6);
  CFRelease(v4);
  v7 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v13 = 2;
  valuePtr = 5;
  v12 = a1 + 24;
  v8 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v9 = CFNumberCreate(0, kCFNumberSInt32Type, &v13);
  v10 = CFNumberCreate(0, kCFNumberLongType, &v12);
  CFDictionarySetValue(v7, CFSTR("name"), CFSTR("image"));
  CFDictionarySetValue(v7, CFSTR("type"), v8);
  CFDictionarySetValue(v7, CFSTR("address"), v10);
  CFDictionarySetValue(v7, CFSTR("semantic"), v9);
  CFArrayAppendValue(Mutable, v7);
  CFRelease(v9);
  CFRelease(v7);
  CFRelease(v10);
  CFRelease(v8);
  return Mutable;
}

uint64_t sub_1B1920E9C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = objc_msgSend_nodeRef(*(void **)(a1 + 40), a2, a3, a4);
  v10 = objc_msgSend_nodeRef(*(void **)(a1 + 48), v7, v8, v9);
  return MEMORY[0x1E0DE7D20](v5, sel_initParametersIfNeededWithDrivingNodeRef_deformedNodeRef_, v6, v10);
}

uint64_t sub_1B1920FD0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = objc_msgSend_nodeRef(*(void **)(a1 + 40), a2, a3, a4);
  v10 = objc_msgSend_nodeRef(*(void **)(a1 + 48), v7, v8, v9);
  objc_msgSend_nodeRef(*(void **)(a1 + 56), v11, v12, v13);
  return MEMORY[0x1E0DE7D20](v5, sel_initParametersIfNeededWithInnerLayerNodeRef_outerLayerNodeRef_deformedNodeRef_, v6, v10);
}

_BYTE *sub_1B1922334(void *a1, void *a2, void *a3, _QWORD *a4, uint64_t a5, int a6, void *a7)
{
  const char *v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const __CFString *v32;
  const __CFString *v33;
  id v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  const char *v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  const char *v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  size_t v50;
  char *v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  void *v57;
  const char *v58;
  void *v59;
  const char *v60;
  uint64_t v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  size_t v65;
  char *v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  void *v72;
  const char *v73;
  void *v74;
  const char *v75;
  _QWORD v77[9];
  __int128 v78;
  objc_super v79;

  if (!a1)
    return 0;
  v79.receiver = a1;
  v79.super_class = (Class)VFXModelWrapDeformerInstance;
  v14 = objc_msgSendSuper2(&v79, sel_init);
  if (v14)
  {
    objc_msgSend_initParametersIfNeededForDeformedNode_(a4, v12, (uint64_t)a2, v13);
    v15 = a4[3];
    v14[256] = 1;
    *((_QWORD *)v14 + 1) = *(_QWORD *)(v15 + 16);
    *((_QWORD *)v14 + 44) = objc_msgSend_nodeRef(a3, v16, v17, v18);
    *((_QWORD *)v14 + 22) = objc_msgSend_nodeRef(a2, v19, v20, v21);
    *((_DWORD *)v14 + 68) = a6;
    v22 = *(_QWORD *)(v15 + 32);
    v23 = *(_QWORD *)(v15 + 56);
    v27 = (void *)objc_msgSend_device(a7, v24, v25, v26);
    if (sub_1B189EAD8(v27, v28, v29, v30))
    {
      v22 = (*(_QWORD *)(v15 + 32) + 3) & 0xFFFFFFFFFFFFFFFCLL;
      v23 = (*(_QWORD *)(v15 + 56) + 3) & 0xFFFFFFFFFFFFFFFCLL;
    }
    v77[0] = MEMORY[0x1E0C809B0];
    v77[1] = 3221225472;
    v77[2] = sub_1B19229D0;
    v77[3] = &unk_1E63D95F8;
    v77[4] = a7;
    v77[5] = v15;
    v77[7] = v22;
    v77[8] = v23;
    v77[6] = v14;
    v31 = *((_QWORD *)v14 + 1);
    v32 = CFSTR("deformer_wrap_legacy_relative");
    if (v31 != 1)
      v32 = 0;
    v78 = xmmword_1B2268280;
    if (v31)
      v33 = v32;
    else
      v33 = CFSTR("deformer_wrap_legacy_absolute");
    v34 = objc_alloc_init(MEMORY[0x1E0CC6B90]);
    v38 = (void *)objc_msgSend__currentResourceManager(a7, v35, v36, v37);
    *((_QWORD *)v14 + 24) = (id)objc_msgSend_computePipelineStateForKernel_withStageDescriptor_stageDescriptorUpdateBlock_constants_constantsHash_(v38, v39, (uint64_t)v33, (uint64_t)v34, v77, 0, 0);

    if (v22 == *(_QWORD *)(v15 + 32))
    {
      v43 = (void *)objc_msgSend_device(a7, v40, v41, v42);
      v45 = objc_msgSend_newBufferWithBytes_length_options_(v43, v44, *(_QWORD *)(v15 + 24), *(_QWORD *)(v15 + 32) * *(unsigned int *)(v15 + 8), 0);
      v49 = 0;
    }
    else
    {
      v50 = v22 * *(unsigned int *)(v15 + 8);
      v51 = (char *)malloc_type_realloc(0, v50, 0xB79CB148uLL);
      v49 = v51;
      if (*(_DWORD *)(v15 + 8))
      {
        v55 = 0;
        v56 = v51;
        do
        {
          memcpy(v56, (const void *)(*(_QWORD *)(v15 + 24) + *(_QWORD *)(v15 + 32) * v55++), *(_QWORD *)(v15 + 32));
          v56 += v22;
        }
        while (v55 < *(unsigned int *)(v15 + 8));
      }
      v57 = (void *)objc_msgSend_device(a7, v52, v53, v54);
      v45 = objc_msgSend_newBufferWithBytes_length_options_(v57, v58, (uint64_t)v49, v50, 0);
    }
    *((_QWORD *)v14 + 25) = v45;
    if (v23 == *(_QWORD *)(v15 + 56))
    {
      v59 = (void *)objc_msgSend_device(a7, v46, v47, v48);
      v61 = objc_msgSend_newBufferWithBytes_length_options_(v59, v60, *(_QWORD *)(v15 + 48), *(_QWORD *)(v15 + 56) * *(unsigned int *)(v15 + 8), 0);
    }
    else
    {
      v65 = v23 * *(unsigned int *)(v15 + 8);
      v66 = (char *)malloc_type_realloc(v49, v65, 0x768E44ABuLL);
      v49 = v66;
      if (*(_DWORD *)(v15 + 8))
      {
        v70 = 0;
        v71 = v66;
        do
        {
          memcpy(v71, (const void *)(*(_QWORD *)(v15 + 48) + *(_QWORD *)(v15 + 56) * v70++), *(_QWORD *)(v15 + 56));
          v71 += v23;
        }
        while (v70 < *(unsigned int *)(v15 + 8));
      }
      v72 = (void *)objc_msgSend_device(a7, v67, v68, v69);
      v61 = objc_msgSend_newBufferWithBytes_length_options_(v72, v73, (uint64_t)v49, v65, 0);
    }
    *((_QWORD *)v14 + 26) = v61;
    v74 = (void *)objc_msgSend_device(a7, v62, v63, v64);
    *((_QWORD *)v14 + 45) = objc_msgSend_newBufferWithBytes_length_options_(v74, v75, *(_QWORD *)(v15 + 136), *(_QWORD *)(v15 + 144), 0);
    free(v49);
  }
  return v14;
}

_QWORD *sub_1B1922640(void *a1, void *a2, void *a3, void *a4, _QWORD *a5, uint64_t a6, int a7, void *a8)
{
  const char *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CFString *v37;
  const __CFString *v38;
  id v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  const char *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  const char *v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  size_t v55;
  char *v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  void *v62;
  const char *v63;
  void *v64;
  const char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  size_t v70;
  char *v71;
  const char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  void *v77;
  const char *v78;
  void *v79;
  const char *v80;
  const char *v81;
  uint64_t v82;
  uint64_t v83;
  void *v84;
  const char *v85;
  const char *v86;
  uint64_t v87;
  uint64_t v88;
  void *v89;
  const char *v90;
  const char *v91;
  uint64_t v92;
  uint64_t v93;
  void *v94;
  const char *v95;
  const char *v96;
  uint64_t v97;
  uint64_t v98;
  void *v99;
  const char *v100;
  uint64_t v102;
  uint64_t v103;
  uint64_t (*v104)(uint64_t, const char *, void *);
  void *v105;
  void *v106;
  uint64_t v107;
  _QWORD *v108;
  unint64_t v109;
  unint64_t v110;
  __int128 v111;
  uint64_t v112;
  objc_super v113;

  if (!a1)
    return 0;
  v113.receiver = a1;
  v113.super_class = (Class)VFXModelWrapDeformerInstance;
  v16 = objc_msgSendSuper2(&v113, sel_init);
  if (v16)
  {
    objc_msgSend_initParametersIfNeededForDeformedNode_(a5, v14, (uint64_t)a2, v15);
    v17 = a5[3];
    v16[1] = *(_QWORD *)(v17 + 16);
    v16[20] = objc_msgSend_nodeRef(a3, v18, v19, v20);
    v16[21] = objc_msgSend_nodeRef(a4, v21, v22, v23);
    v16[22] = objc_msgSend_nodeRef(a2, v24, v25, v26);
    *((_DWORD *)v16 + 4) = a7;
    v27 = *(_QWORD *)(v17 + 32);
    v28 = *(_QWORD *)(v17 + 56);
    v32 = (void *)objc_msgSend_device(a8, v29, v30, v31);
    if (sub_1B189EAD8(v32, v33, v34, v35))
    {
      v27 = (*(_QWORD *)(v17 + 32) + 3) & 0xFFFFFFFFFFFFFFFCLL;
      v28 = (*(_QWORD *)(v17 + 56) + 3) & 0xFFFFFFFFFFFFFFFCLL;
    }
    v102 = MEMORY[0x1E0C809B0];
    v103 = 3221225472;
    v104 = sub_1B1922BE4;
    v105 = &unk_1E63D9620;
    v106 = a8;
    v107 = v17;
    v109 = v27;
    v110 = v28;
    v36 = v16[1];
    v37 = CFSTR("deformer_wrap_relative");
    v108 = v16;
    v112 = 36;
    if (v36 != 1)
      v37 = 0;
    v111 = xmmword_1B2268290;
    if (v36)
      v38 = v37;
    else
      v38 = CFSTR("deformer_wrap_absolute");
    v39 = objc_alloc_init(MEMORY[0x1E0CC6B90]);
    v43 = (void *)objc_msgSend__currentResourceManager(a8, v40, v41, v42, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112);
    v16[24] = (id)objc_msgSend_computePipelineStateForKernel_withStageDescriptor_stageDescriptorUpdateBlock_constants_constantsHash_(v43, v44, (uint64_t)v38, (uint64_t)v39, &v102, 0, 0);

    if (v27 == *(_QWORD *)(v17 + 32))
    {
      v48 = (void *)objc_msgSend_device(a8, v45, v46, v47);
      v50 = objc_msgSend_newBufferWithBytes_length_options_(v48, v49, *(_QWORD *)(v17 + 24), *(_QWORD *)(v17 + 32) * *(unsigned int *)(v17 + 8), 0);
      v54 = 0;
    }
    else
    {
      v55 = v27 * *(unsigned int *)(v17 + 8);
      v56 = (char *)malloc_type_realloc(0, v55, 0x2EFE224FuLL);
      v54 = v56;
      if (*(_DWORD *)(v17 + 8))
      {
        v60 = 0;
        v61 = v56;
        do
        {
          memcpy(v61, (const void *)(*(_QWORD *)(v17 + 24) + *(_QWORD *)(v17 + 32) * v60++), *(_QWORD *)(v17 + 32));
          v61 += v27;
        }
        while (v60 < *(unsigned int *)(v17 + 8));
      }
      v62 = (void *)objc_msgSend_device(a8, v57, v58, v59);
      v50 = objc_msgSend_newBufferWithBytes_length_options_(v62, v63, (uint64_t)v54, v55, 0);
    }
    v16[25] = v50;
    if (v28 == *(_QWORD *)(v17 + 56))
    {
      v64 = (void *)objc_msgSend_device(a8, v51, v52, v53);
      v66 = objc_msgSend_newBufferWithBytes_length_options_(v64, v65, *(_QWORD *)(v17 + 48), *(_QWORD *)(v17 + 56) * *(unsigned int *)(v17 + 8), 0);
    }
    else
    {
      v70 = v28 * *(unsigned int *)(v17 + 8);
      v71 = (char *)malloc_type_realloc(v54, v70, 0x2CECB42AuLL);
      v54 = v71;
      if (*(_DWORD *)(v17 + 8))
      {
        v75 = 0;
        v76 = v71;
        do
        {
          memcpy(v76, (const void *)(*(_QWORD *)(v17 + 48) + *(_QWORD *)(v17 + 56) * v75++), *(_QWORD *)(v17 + 56));
          v76 += v28;
        }
        while (v75 < *(unsigned int *)(v17 + 8));
      }
      v77 = (void *)objc_msgSend_device(a8, v72, v73, v74);
      v66 = objc_msgSend_newBufferWithBytes_length_options_(v77, v78, (uint64_t)v54, v70, 0);
    }
    v16[26] = v66;
    v79 = (void *)objc_msgSend_device(a8, v67, v68, v69);
    v16[27] = objc_msgSend_newBufferWithBytes_length_options_(v79, v80, *(_QWORD *)(v17 + 72), *(_QWORD *)(v17 + 80), 0);
    if (v16[1] == 1)
    {
      v84 = (void *)objc_msgSend_device(a8, v81, v82, v83);
      v16[28] = objc_msgSend_newBufferWithBytes_length_options_(v84, v85, *(_QWORD *)(v17 + 88), *(_QWORD *)(v17 + 104), 0);
      v89 = (void *)objc_msgSend_device(a8, v86, v87, v88);
      v16[29] = objc_msgSend_newBufferWithBytes_length_options_(v89, v90, *(_QWORD *)(v17 + 96), *(_QWORD *)(v17 + 104), 0);
      v94 = (void *)objc_msgSend_device(a8, v91, v92, v93);
      v16[30] = objc_msgSend_newBufferWithBytes_length_options_(v94, v95, *(_QWORD *)(v17 + 112), *(_QWORD *)(v17 + 128), 0);
      v99 = (void *)objc_msgSend_device(a8, v96, v97, v98);
      v16[31] = objc_msgSend_newBufferWithBytes_length_options_(v99, v100, *(_QWORD *)(v17 + 120), *(_QWORD *)(v17 + 128), 0);
    }
    free(v54);
  }
  return v16;
}

uint64_t sub_1B19229D0(uint64_t a1, const char *a2, void *a3)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  const char *v22;
  uint64_t v23;
  void *v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  void *v35;
  const char *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  const char *v46;
  uint64_t v47;
  void *v48;
  const char *v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  const char *v58;
  uint64_t v59;
  void *v60;
  const char *v61;
  uint64_t v62;
  const char *v63;
  uint64_t v64;
  const char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  const char *v71;
  uint64_t v72;
  void *v73;
  const char *v74;
  uint64_t v75;
  const char *v76;
  uint64_t v77;
  const char *v78;
  uint64_t v79;
  const char *v80;
  uint64_t v81;
  uint64_t v82;
  void *v83;
  const char *v84;
  uint64_t v85;
  void *v86;
  const char *v87;
  uint64_t v88;
  const char *v89;
  uint64_t v90;
  const char *v91;
  uint64_t v92;
  const char *v93;
  uint64_t v94;
  uint64_t v95;
  void *v96;
  const char *v97;
  uint64_t v98;
  void *v99;
  const char *v100;
  uint64_t v101;
  const char *v102;
  uint64_t v103;
  uint64_t *v104;
  void *v105;
  const char *v106;
  uint64_t v107;
  const char *v108;
  uint64_t v109;
  const char *v110;
  uint64_t v111;
  const char *v112;
  uint64_t v113;
  uint64_t v114;
  void *v115;
  const char *v116;
  uint64_t v117;
  const char *v118;
  uint64_t v119;

  objc_msgSend_configureStageInputOutputDescriptor_withDeformerFunction_(*(void **)(a1 + 32), a2, (uint64_t)a3, (uint64_t)a2);
  v8 = (void *)objc_msgSend_attributes(a3, v5, v6, v7);
  v11 = (void *)objc_msgSend_objectAtIndexedSubscript_(v8, v9, 6, v10);
  objc_msgSend_setFormat_(v11, v12, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 40), v13);
  objc_msgSend_setOffset_(v11, v14, 0, v15);
  objc_msgSend_setBufferIndex_(v11, v16, 3, v17);
  v21 = (void *)objc_msgSend_layouts(a3, v18, v19, v20);
  v24 = (void *)objc_msgSend_objectAtIndexedSubscript_(v21, v22, 3, v23);
  objc_msgSend_setStepFunction_(v24, v25, 5, v26);
  objc_msgSend_setStride_(v24, v27, *(_QWORD *)(a1 + 56), v28);
  v32 = (void *)objc_msgSend_attributes(a3, v29, v30, v31);
  v35 = (void *)objc_msgSend_objectAtIndexedSubscript_(v32, v33, 7, v34);
  objc_msgSend_setFormat_(v35, v36, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 64), v37);
  objc_msgSend_setOffset_(v35, v38, 0, v39);
  objc_msgSend_setBufferIndex_(v35, v40, 4, v41);
  v45 = (void *)objc_msgSend_layouts(a3, v42, v43, v44);
  v48 = (void *)objc_msgSend_objectAtIndexedSubscript_(v45, v46, 4, v47);
  objc_msgSend_setStepFunction_(v48, v49, 5, v50);
  objc_msgSend_setStride_(v48, v51, *(_QWORD *)(a1 + 64), v52);
  v53 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v57 = (void *)objc_msgSend_attributes(a3, v54, v55, v56);
  if (v53)
  {
    v60 = (void *)objc_msgSend_objectAtIndexedSubscript_(v57, v58, 11, v59);
    objc_msgSend_setFormat_(v60, v61, 31, v62);
    objc_msgSend_setOffset_(v60, v63, 0, v64);
    objc_msgSend_setBufferIndex_(v60, v65, 6, v66);
    v70 = (void *)objc_msgSend_attributes(a3, v67, v68, v69);
    v73 = (void *)objc_msgSend_objectAtIndexedSubscript_(v70, v71, 12, v72);
    objc_msgSend_setFormat_(v73, v74, 31, v75);
    objc_msgSend_setOffset_(v73, v76, 16, v77);
    objc_msgSend_setBufferIndex_(v73, v78, 6, v79);
    v83 = (void *)objc_msgSend_attributes(a3, v80, v81, v82);
    v86 = (void *)objc_msgSend_objectAtIndexedSubscript_(v83, v84, 13, v85);
    objc_msgSend_setFormat_(v86, v87, 31, v88);
    objc_msgSend_setOffset_(v86, v89, 32, v90);
    objc_msgSend_setBufferIndex_(v86, v91, 6, v92);
    v96 = (void *)objc_msgSend_layouts(a3, v93, v94, v95);
    v99 = (void *)objc_msgSend_objectAtIndexedSubscript_(v96, v97, 6, v98);
    objc_msgSend_setStepFunction_(v99, v100, 5, v101);
    v104 = (uint64_t *)(a1 + 80);
  }
  else
  {
    v105 = (void *)objc_msgSend_objectAtIndexedSubscript_(v57, v58, 9, v59);
    objc_msgSend_setFormat_(v105, v106, 30, v107);
    objc_msgSend_setOffset_(v105, v108, 0, v109);
    objc_msgSend_setBufferIndex_(v105, v110, 6, v111);
    v115 = (void *)objc_msgSend_layouts(a3, v112, v113, v114);
    v99 = (void *)objc_msgSend_objectAtIndexedSubscript_(v115, v116, 6, v117);
    objc_msgSend_setStepFunction_(v99, v118, 5, v119);
    v104 = (uint64_t *)(a1 + 72);
  }
  return objc_msgSend_setStride_(v99, v102, *v104, v103);
}

uint64_t sub_1B1922BE4(uint64_t a1, const char *a2, void *a3)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  const char *v22;
  uint64_t v23;
  void *v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  void *v35;
  const char *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  const char *v46;
  uint64_t v47;
  void *v48;
  const char *v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  const char *v57;
  uint64_t v58;
  void *v59;
  const char *v60;
  uint64_t v61;
  const char *v62;
  uint64_t v63;
  const char *v64;
  uint64_t v65;
  const char *v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  const char *v70;
  uint64_t v71;
  void *v72;
  const char *v73;
  uint64_t v74;
  const char *v75;
  uint64_t v76;
  uint64_t result;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  void *v81;
  const char *v82;
  uint64_t v83;
  void *v84;
  const char *v85;
  uint64_t v86;
  const char *v87;
  uint64_t v88;
  const char *v89;
  uint64_t v90;
  const char *v91;
  uint64_t v92;
  uint64_t v93;
  void *v94;
  const char *v95;
  uint64_t v96;
  void *v97;
  const char *v98;
  uint64_t v99;
  const char *v100;
  uint64_t v101;
  const char *v102;
  uint64_t v103;
  uint64_t v104;
  void *v105;
  const char *v106;
  uint64_t v107;
  void *v108;
  const char *v109;
  uint64_t v110;
  const char *v111;
  uint64_t v112;
  const char *v113;
  uint64_t v114;
  const char *v115;
  uint64_t v116;
  uint64_t v117;
  void *v118;
  const char *v119;
  uint64_t v120;
  void *v121;
  const char *v122;
  uint64_t v123;
  const char *v124;
  uint64_t v125;
  const char *v126;
  uint64_t v127;
  uint64_t v128;
  void *v129;
  const char *v130;
  uint64_t v131;
  void *v132;
  const char *v133;
  uint64_t v134;
  const char *v135;
  uint64_t v136;
  const char *v137;
  uint64_t v138;
  const char *v139;
  uint64_t v140;
  uint64_t v141;
  void *v142;
  const char *v143;
  uint64_t v144;
  void *v145;
  const char *v146;
  uint64_t v147;
  const char *v148;
  uint64_t v149;
  const char *v150;
  uint64_t v151;
  const char *v152;
  uint64_t v153;
  uint64_t v154;
  void *v155;
  const char *v156;
  uint64_t v157;
  void *v158;
  const char *v159;
  uint64_t v160;
  const char *v161;
  uint64_t v162;
  const char *v163;
  uint64_t v164;
  const char *v165;
  uint64_t v166;
  uint64_t v167;
  void *v168;
  const char *v169;
  uint64_t v170;
  void *v171;
  const char *v172;
  uint64_t v173;
  const char *v174;
  uint64_t v175;
  const char *v176;
  uint64_t v177;
  uint64_t v178;
  void *v179;
  const char *v180;
  uint64_t v181;
  void *v182;
  const char *v183;
  uint64_t v184;
  const char *v185;
  uint64_t v186;
  const char *v187;
  uint64_t v188;
  const char *v189;
  uint64_t v190;
  uint64_t v191;
  void *v192;
  const char *v193;
  uint64_t v194;
  void *v195;
  const char *v196;
  uint64_t v197;
  const char *v198;
  uint64_t v199;
  const char *v200;
  uint64_t v201;
  const char *v202;
  uint64_t v203;
  uint64_t v204;
  void *v205;
  const char *v206;
  uint64_t v207;
  void *v208;
  const char *v209;
  uint64_t v210;
  const char *v211;
  uint64_t v212;
  const char *v213;
  uint64_t v214;
  const char *v215;
  uint64_t v216;
  uint64_t v217;
  void *v218;
  const char *v219;
  uint64_t v220;
  void *v221;
  const char *v222;
  uint64_t v223;
  const char *v224;
  uint64_t v225;

  objc_msgSend_configureStageInputOutputDescriptor_withDeformerFunction_(*(void **)(a1 + 32), a2, (uint64_t)a3, (uint64_t)a2);
  v8 = (void *)objc_msgSend_attributes(a3, v5, v6, v7);
  v11 = (void *)objc_msgSend_objectAtIndexedSubscript_(v8, v9, 6, v10);
  objc_msgSend_setFormat_(v11, v12, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 40), v13);
  objc_msgSend_setOffset_(v11, v14, 0, v15);
  objc_msgSend_setBufferIndex_(v11, v16, 3, v17);
  v21 = (void *)objc_msgSend_layouts(a3, v18, v19, v20);
  v24 = (void *)objc_msgSend_objectAtIndexedSubscript_(v21, v22, 3, v23);
  objc_msgSend_setStepFunction_(v24, v25, 5, v26);
  objc_msgSend_setStride_(v24, v27, *(_QWORD *)(a1 + 56), v28);
  v32 = (void *)objc_msgSend_attributes(a3, v29, v30, v31);
  v35 = (void *)objc_msgSend_objectAtIndexedSubscript_(v32, v33, 7, v34);
  objc_msgSend_setFormat_(v35, v36, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 64), v37);
  objc_msgSend_setOffset_(v35, v38, 0, v39);
  objc_msgSend_setBufferIndex_(v35, v40, 4, v41);
  v45 = (void *)objc_msgSend_layouts(a3, v42, v43, v44);
  v48 = (void *)objc_msgSend_objectAtIndexedSubscript_(v45, v46, 4, v47);
  objc_msgSend_setStepFunction_(v48, v49, 5, v50);
  objc_msgSend_setStride_(v48, v51, *(_QWORD *)(a1 + 64), v52);
  v56 = (void *)objc_msgSend_attributes(a3, v53, v54, v55);
  v59 = (void *)objc_msgSend_objectAtIndexedSubscript_(v56, v57, 8, v58);
  objc_msgSend_setFormat_(v59, v60, 28, v61);
  objc_msgSend_setOffset_(v59, v62, 0, v63);
  objc_msgSend_setBufferIndex_(v59, v64, 5, v65);
  v69 = (void *)objc_msgSend_layouts(a3, v66, v67, v68);
  v72 = (void *)objc_msgSend_objectAtIndexedSubscript_(v69, v70, 5, v71);
  objc_msgSend_setStepFunction_(v72, v73, 5, v74);
  result = objc_msgSend_setStride_(v72, v75, *(_QWORD *)(a1 + 72), v76);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) == 1)
  {
    v81 = (void *)objc_msgSend_attributes(a3, v78, v79, v80);
    v84 = (void *)objc_msgSend_objectAtIndexedSubscript_(v81, v82, 9, v83);
    objc_msgSend_setFormat_(v84, v85, 30, v86);
    objc_msgSend_setOffset_(v84, v87, 0, v88);
    objc_msgSend_setBufferIndex_(v84, v89, 6, v90);
    v94 = (void *)objc_msgSend_layouts(a3, v91, v92, v93);
    v97 = (void *)objc_msgSend_objectAtIndexedSubscript_(v94, v95, 6, v96);
    objc_msgSend_setStepFunction_(v97, v98, 5, v99);
    objc_msgSend_setStride_(v97, v100, *(_QWORD *)(a1 + 80), v101);
    v105 = (void *)objc_msgSend_attributes(a3, v102, v103, v104);
    v108 = (void *)objc_msgSend_objectAtIndexedSubscript_(v105, v106, 10, v107);
    objc_msgSend_setFormat_(v108, v109, 30, v110);
    objc_msgSend_setOffset_(v108, v111, 0, v112);
    objc_msgSend_setBufferIndex_(v108, v113, 7, v114);
    v118 = (void *)objc_msgSend_layouts(a3, v115, v116, v117);
    v121 = (void *)objc_msgSend_objectAtIndexedSubscript_(v118, v119, 7, v120);
    objc_msgSend_setStepFunction_(v121, v122, 5, v123);
    objc_msgSend_setStride_(v121, v124, *(_QWORD *)(a1 + 80), v125);
    v129 = (void *)objc_msgSend_attributes(a3, v126, v127, v128);
    v132 = (void *)objc_msgSend_objectAtIndexedSubscript_(v129, v130, 11, v131);
    objc_msgSend_setFormat_(v132, v133, 30, v134);
    objc_msgSend_setOffset_(v132, v135, 0, v136);
    objc_msgSend_setBufferIndex_(v132, v137, 8, v138);
    v142 = (void *)objc_msgSend_attributes(a3, v139, v140, v141);
    v145 = (void *)objc_msgSend_objectAtIndexedSubscript_(v142, v143, 12, v144);
    objc_msgSend_setFormat_(v145, v146, 30, v147);
    objc_msgSend_setOffset_(v145, v148, 12, v149);
    objc_msgSend_setBufferIndex_(v145, v150, 8, v151);
    v155 = (void *)objc_msgSend_attributes(a3, v152, v153, v154);
    v158 = (void *)objc_msgSend_objectAtIndexedSubscript_(v155, v156, 13, v157);
    objc_msgSend_setFormat_(v158, v159, 30, v160);
    objc_msgSend_setOffset_(v158, v161, 24, v162);
    objc_msgSend_setBufferIndex_(v158, v163, 8, v164);
    v168 = (void *)objc_msgSend_layouts(a3, v165, v166, v167);
    v171 = (void *)objc_msgSend_objectAtIndexedSubscript_(v168, v169, 8, v170);
    objc_msgSend_setStepFunction_(v171, v172, 5, v173);
    objc_msgSend_setStride_(v171, v174, *(_QWORD *)(a1 + 88), v175);
    v179 = (void *)objc_msgSend_attributes(a3, v176, v177, v178);
    v182 = (void *)objc_msgSend_objectAtIndexedSubscript_(v179, v180, 14, v181);
    objc_msgSend_setFormat_(v182, v183, 30, v184);
    objc_msgSend_setOffset_(v182, v185, 0, v186);
    objc_msgSend_setBufferIndex_(v182, v187, 9, v188);
    v192 = (void *)objc_msgSend_attributes(a3, v189, v190, v191);
    v195 = (void *)objc_msgSend_objectAtIndexedSubscript_(v192, v193, 15, v194);
    objc_msgSend_setFormat_(v195, v196, 30, v197);
    objc_msgSend_setOffset_(v195, v198, 12, v199);
    objc_msgSend_setBufferIndex_(v195, v200, 9, v201);
    v205 = (void *)objc_msgSend_attributes(a3, v202, v203, v204);
    v208 = (void *)objc_msgSend_objectAtIndexedSubscript_(v205, v206, 16, v207);
    objc_msgSend_setFormat_(v208, v209, 30, v210);
    objc_msgSend_setOffset_(v208, v211, 24, v212);
    objc_msgSend_setBufferIndex_(v208, v213, 9, v214);
    v218 = (void *)objc_msgSend_layouts(a3, v215, v216, v217);
    v221 = (void *)objc_msgSend_objectAtIndexedSubscript_(v218, v219, 9, v220);
    objc_msgSend_setStepFunction_(v221, v222, 5, v223);
    return objc_msgSend_setStride_(v221, v224, *(_QWORD *)(a1 + 88), v225);
  }
  return result;
}

void sub_1B1923434(uint64_t a1, __CFSet *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;

  if (a3 != -1)
  {
    v9 = sub_1B1875540(a1, 3, a3, 1, a5, a6, a7, a8);
    if (v9)
      CFSetSetValue(a2, v9);
  }
}

uint64_t sub_1B192347C(__n128 *a1, CFDictionaryRef theDict, int *a3, float *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFBoolean *Value;
  _BOOL4 v14;
  uint64_t v15;
  int v16;
  const __CFNumber *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  double v27;
  __n128 v29;

  if (!theDict
    || (Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("kWorldSourceConvertToYUpIfNeeded"))) == 0)
  {
    v14 = 0;
    if (!a3)
      goto LABEL_7;
    goto LABEL_6;
  }
  v14 = CFBooleanGetValue(Value) != 0;
  if (a3)
LABEL_6:
    *a3 = 0;
LABEL_7:
  if (a4)
    *a4 = 1.0;
  if (a5)
    *a5 = 0;
  if (v14)
  {
    v29.n128_u32[2] = 0;
    v29.n128_u64[0] = 0;
    sub_1B187AD68(a1, &v29, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
    v15 = v29.n128_f32[1] <= 0.0001;
    if (a3 && v29.n128_f32[1] <= 0.0001)
    {
      if (v29.n128_f32[0] <= 0.0001)
        v16 = 1;
      else
        v16 = 2;
      *a3 = v16;
    }
  }
  else
  {
    v15 = 0;
  }
  v29.n128_u32[0] = 0;
  if (theDict)
  {
    v17 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("kWorldSourceConvertToUnit"));
    if (v17)
    {
      CFNumberGetValue(v17, kCFNumberFloatType, &v29);
      if (v29.n128_f32[0] != 0.0)
      {
        if (a5)
          *a5 = v29.n128_u32[0];
        v25 = sub_1B187AD20((uint64_t)a1, v18, v19, v20, v21, v22, v23, v24);
        if (v25 != 0.0 && v29.n128_f32[0] != 0.0)
        {
          v26 = v25 / v29.n128_f32[0];
          v27 = fabs(v26 + -1.0);
          if (v27 > 0.0001)
            v15 = 1;
          else
            v15 = v15;
          if (a4 && v27 > 0.0001)
          {
            *a4 = v26;
            return 1;
          }
        }
      }
    }
  }
  return v15;
}

void sub_1B19235FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v8;
  __n128 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFTypeRef *v14;
  const void *Value;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFArray *v29;
  const __CFArray *v30;
  CFIndex Count;
  CFIndex v32;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  const __CFArray *v71;
  const __CFArray *v72;
  CFIndex v73;
  CFIndex v74;
  CFIndex j;
  _QWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  const void *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  const __CFArray *v98;
  const __CFArray *v99;
  CFIndex v100;
  const void *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  const __CFDictionary *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  void *v133;
  const CFSetCallBacks *v134;
  __CFSet *Mutable;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  const __CFNumber *v143;
  unsigned __int32 v144;
  unsigned __int32 v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  unsigned __int32 v152;
  const void *v153;
  const __CFArray *v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  const __CFArray *v161;
  uint64_t k;
  const __CFArray *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t m;
  const void *v366;
  const void *v367;
  __CFSet *v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  const void *v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  const __CFArray *v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  void *v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  CFIndex v406;
  CFIndex v407;
  BOOL v408;
  CFIndex ii;
  const void *v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  _QWORD *v419;
  int v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  const UInt8 *v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  const UInt8 *v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  CFIndex v451;
  const void *v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  _QWORD *v465;
  int v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  size_t v481;
  CFIndex v482;
  UInt8 *v483;
  uint64_t *v484;
  UInt8 *v485;
  uint64_t v486;
  uint64_t v487;
  const UInt8 *v488;
  CFDataRef v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  __int16 v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  const void *v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  const __CFArray *v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  CFIndex v521;
  const void *v522;
  const __CFData *v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  UInt8 *v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  UInt8 *v547;
  UInt8 *BytePtr;
  const void *v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  uint64_t v554;
  uint64_t v555;
  uint64_t v556;
  uint64_t v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  const __CFArray *v563;
  uint64_t v564;
  uint64_t v565;
  uint64_t v566;
  uint64_t v567;
  uint64_t v568;
  uint64_t v569;
  const __CFArray *v570;
  CFIndex v571;
  uint64_t v572;
  uint64_t v573;
  uint64_t v574;
  uint64_t v575;
  uint64_t v576;
  uint64_t v577;
  uint64_t v578;
  uint64_t v579;
  const void *v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  uint64_t v584;
  uint64_t v585;
  uint64_t v586;
  uint64_t v587;
  const __CFBoolean *v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t v593;
  uint64_t v594;
  uint64_t v595;
  uint64_t v596;
  uint64_t v597;
  uint64_t v598;
  uint64_t v599;
  uint64_t v600;
  uint64_t v601;
  const __CFArray *v602;
  const __CFArray *v603;
  CFIndex v604;
  CFIndex v605;
  uint64_t v606;
  const void *v607;
  uint64_t v608;
  uint64_t v609;
  uint64_t v610;
  uint64_t v611;
  uint64_t v612;
  uint64_t v613;
  uint64_t v614;
  const __CFDictionary *v615;
  uint64_t v616;
  uint64_t v617;
  uint64_t v618;
  uint64_t v619;
  uint64_t v620;
  uint64_t v621;
  uint64_t v622;
  int v623;
  CFIndex jj;
  const void *v625;
  uint64_t v626;
  uint64_t v627;
  uint64_t v628;
  uint64_t v629;
  uint64_t v630;
  uint64_t v631;
  uint64_t v632;
  float32x4_t *v633;
  uint64_t v634;
  uint64_t v635;
  uint64_t v636;
  uint64_t v637;
  uint64_t v638;
  uint64_t v639;
  uint64_t v640;
  float *v641;
  uint64_t v642;
  uint64_t v643;
  uint64_t v644;
  uint64_t v645;
  uint64_t v646;
  uint64_t v647;
  const void *v648;
  uint64_t v649;
  uint64_t v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  uint64_t v654;
  uint64_t v655;
  uint64_t v656;
  const void *v657;
  uint64_t v658;
  uint64_t v659;
  uint64_t v660;
  uint64_t v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  uint64_t v669;
  uint64_t v670;
  const void *v671;
  const __CFArray *v672;
  const __CFArray *v673;
  CFIndex v674;
  CFIndex v675;
  const __CFDictionary *v676;
  CFIndex v677;
  char v678;
  const void *v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  uint64_t v683;
  uint64_t v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  uint64_t v688;
  uint64_t v689;
  uint64_t v690;
  uint64_t v691;
  uint64_t v692;
  uint64_t v693;
  float v694;
  uint64_t v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  uint64_t v707;
  uint64_t v708;
  float32x4_t v709;
  float32x4_t v710;
  float32x4_t v711;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  uint64_t v717;
  const __CFDictionary *v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t v721;
  uint64_t v722;
  uint64_t v723;
  uint64_t v724;
  uint64_t v725;
  uint64_t v726;
  uint64_t v727;
  uint64_t v728;
  uint64_t v729;
  uint64_t v730;
  uint64_t v731;
  uint64_t v732;
  uint64_t v733;
  float32x4_t v734;
  float32x4_t v735;
  float32x4_t v736;
  float32x4_t v737;
  float32x4_t v738;
  float v739;
  uint64_t v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  uint64_t v751;
  uint64_t v752;
  uint64_t v753;
  const __CFBoolean *v754;
  uint64_t v755;
  uint64_t v756;
  uint64_t v757;
  uint64_t v758;
  uint64_t v759;
  uint64_t v760;
  uint64_t v761;
  const __CFArray *v762;
  const __CFArray *v763;
  const __CFDictionary *v764;
  CFIndex v765;
  CFIndex v766;
  CFIndex kk;
  const void *v768;
  uint64_t v769;
  uint64_t v770;
  uint64_t v771;
  uint64_t v772;
  uint64_t v773;
  uint64_t v774;
  uint64_t v775;
  uint64_t v776;
  uint64_t v777;
  uint64_t v778;
  uint64_t v779;
  uint64_t v780;
  uint64_t v781;
  uint64_t v782;
  uint64_t v783;
  const __CFDictionary *v784;
  uint64_t v785;
  uint64_t v786;
  uint64_t v787;
  uint64_t v788;
  uint64_t v789;
  uint64_t v790;
  uint64_t v791;
  uint64_t v792;
  uint64_t v793;
  uint64_t v794;
  uint64_t v795;
  uint64_t v796;
  BOOL v797;
  _BOOL4 v798;
  const void *v799;
  uint64_t v800;
  uint64_t v801;
  uint64_t v802;
  uint64_t v803;
  uint64_t v804;
  uint64_t v805;
  uint64_t v806;
  uint64_t v807;
  uint64_t v808;
  uint64_t v809;
  uint64_t v810;
  uint64_t v811;
  uint64_t v812;
  uint64_t v813;
  uint64_t v814;
  _QWORD *v815;
  __CFArray *v816;
  CFIndex v817;
  uint64_t v818;
  uint64_t v819;
  uint64_t v820;
  uint64_t v821;
  CFTypeRef *v822;
  const __CFDictionary *v823;
  void *v824;
  uint64_t *v825;
  __CFArray *v826;
  CFIndex v827;
  CFIndex v828;
  CFIndex mm;
  const void *v830;
  uint64_t v831;
  uint64_t v832;
  uint64_t v833;
  uint64_t v834;
  uint64_t v835;
  uint64_t v836;
  uint64_t v837;
  uint64_t v838;
  uint64_t v839;
  uint64_t v840;
  uint64_t v841;
  uint64_t v842;
  const void *v843;
  uint64_t v844;
  uint64_t v845;
  uint64_t v846;
  uint64_t v847;
  uint64_t v848;
  uint64_t v849;
  float32x4_t *v850;
  uint64_t v851;
  uint64_t v852;
  uint64_t v853;
  uint64_t v854;
  uint64_t v855;
  uint64_t v856;
  uint64_t v857;
  uint64_t v858;
  uint64_t v859;
  uint64_t v860;
  uint64_t v861;
  uint64_t v862;
  uint64_t v863;
  uint64_t v864;
  uint64_t v865;
  uint64_t v866;
  uint64_t v867;
  uint64_t v868;
  const void *v869;
  uint64_t v870;
  uint64_t v871;
  uint64_t v872;
  uint64_t v873;
  uint64_t v874;
  uint64_t v875;
  uint64_t v876;
  uint64_t v877;
  uint64_t v878;
  uint64_t v879;
  uint64_t v880;
  uint64_t v881;
  uint64_t v882;
  void *v883;
  uint64_t v884;
  uint64_t v885;
  uint64_t v886;
  uint64_t v887;
  uint64_t v888;
  uint64_t v889;
  uint64_t v890;
  uint64_t v891;
  uint64_t v892;
  uint64_t v893;
  uint64_t v894;
  uint64_t v895;
  const void *v896;
  char isMetal;
  uint64_t v898;
  uint64_t v899;
  uint64_t v900;
  uint64_t v901;
  uint64_t v902;
  uint64_t v903;
  uint64_t v904;
  uint64_t v905;
  uint64_t v906;
  uint64_t v907;
  uint64_t v908;
  uint64_t v909;
  uint64_t v910;
  uint64_t v911;
  const __CFBoolean *v912;
  uint64_t v913;
  uint64_t v914;
  uint64_t v915;
  uint64_t v916;
  uint64_t v917;
  uint64_t v918;
  uint64_t v919;
  uint64_t v920;
  uint64_t v921;
  uint64_t v922;
  uint64_t v923;
  uint64_t v924;
  uint64_t v925;
  const __CFArray *v926;
  const __CFArray *v927;
  CFIndex v928;
  CFIndex v929;
  CFIndex nn;
  const void *v931;
  uint64_t v932;
  uint64_t v933;
  uint64_t v934;
  uint64_t v935;
  uint64_t v936;
  uint64_t v937;
  uint64_t v938;
  uint64_t v939;
  uint64_t v940;
  uint64_t v941;
  uint64_t v942;
  uint64_t v943;
  uint64_t v944;
  uint64_t v945;
  uint64_t v946;
  uint64_t v947;
  uint64_t v948;
  uint64_t v949;
  uint64_t v950;
  uint64_t v951;
  uint64_t v952;
  uint64_t v953;
  uint64_t v954;
  uint64_t v955;
  uint64_t v956;
  uint64_t v957;
  uint64_t v958;
  uint64_t v959;
  uint64_t v960;
  uint64_t v961;
  const void *v962;
  uint64_t v963;
  const __CFDictionary *v964;
  __n128 *v965;
  __CFSet *v966;
  const __CFArray *cf;
  CFIndex v969;
  CFIndex v970;
  __CFSet *theSet;
  const __CFAllocator *allocator;
  uint64_t *v973;
  uint64_t v974;
  unsigned int v975;
  uint64_t v976;
  uint64_t v977;
  void *v978;
  uint64_t n;
  uint64_t v980;
  float32x4_t v981[6];
  float32x4_t valuePtr;
  float32x4_t v983;
  float32x4_t v984;
  float32x4_t v985;
  float32x4_t v986;
  float32x4_t v987;
  __int128 v988;
  __int128 v989;
  __int128 v990;
  __int128 v991;
  __int128 v992;
  __int128 v993;
  __int128 v994;
  __int128 v995;
  __int128 v996;
  __int128 v997;
  __int128 v998;
  float32x4_t v999;
  float32x4_t v1000;
  uint64_t v1001;

  v1001 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return;
  v8 = (const __CFDictionary *)a2;
  v9 = (__n128 *)a1;
  v10 = sub_1B187A934(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v10)
    sub_1B186B018(v10, (uint64_t)&unk_1E63D1230);
  v14 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
  if (v8)
  {
    Value = CFDictionaryGetValue(v8, CFSTR("kWorldSourceRemoveColorArrays"));
    if (Value)
    {
      if (CFEqual(*v14, Value))
      {
        v23 = sub_1B187A934((uint64_t)v9, v16, v17, v18, v19, v20, v21, v22);
        if (v23)
        {
          v29 = sub_1B186C054(v23, CFSTR("model"), 0, v24, v25, v26, v27, v28);
          if (v29)
          {
            v30 = v29;
            Count = CFArrayGetCount(v29);
            if (Count >= 1)
            {
              v32 = Count;
              for (i = 0; i != v32; ++i)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v30, i);
                v42 = sub_1B1868FA0((uint64_t)ValueAtIndex, v35, v36, v37, v38, v39, v40, v41);
                v50 = sub_1B17A0848(v42, v43, v44, v45, v46, v47, v48, v49);
                sub_1B187589C(v50, 2, v51, v52, v53, v54, v55, v56);
              }
            }
            CFRelease(v30);
          }
        }
      }
    }
    v57 = CFDictionaryGetValue(v8, CFSTR("kWorldSourceRemoveAllLights"));
    if (v57)
    {
      if (CFEqual(*v14, v57))
      {
        v65 = sub_1B187A934((uint64_t)v9, v58, v59, v60, v61, v62, v63, v64);
        if (v65)
        {
          v71 = sub_1B186C054(v65, CFSTR("kLightKey"), 0, v66, v67, v68, v69, v70);
          if (v71)
          {
            v72 = v71;
            v73 = CFArrayGetCount(v71);
            if (v73 >= 1)
            {
              v74 = v73;
              for (j = 0; j != v74; ++j)
              {
                v76 = CFArrayGetValueAtIndex(v72, j);
                sub_1B186B464(v76, v77, v78, v79, v80, v81, v82, v83);
              }
            }
            CFRelease(v72);
          }
        }
      }
    }
    v84 = CFDictionaryGetValue(v8, CFSTR("kWorldSourceCleanupMeshes"));
    if (v84)
    {
      if (CFEqual(*v14, v84))
      {
        v92 = sub_1B187A934((uint64_t)v9, v85, v86, v87, v88, v89, v90, v91);
        if (v92)
        {
          v98 = sub_1B186C054(v92, CFSTR("model"), 0, v93, v94, v95, v96, v97);
          if (v98)
          {
            v99 = v98;
            v969 = CFArrayGetCount(v98);
            if (v969 <= 0)
            {
              CFRelease(v99);
            }
            else
            {
              v964 = v8;
              v965 = v9;
              v100 = 0;
              allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              cf = v99;
              do
              {
                v970 = v100;
                v101 = CFArrayGetValueAtIndex(v99, v100);
                v109 = sub_1B1868FA0((uint64_t)v101, v102, v103, v104, v105, v106, v107, v108);
                v117 = sub_1B186D1B0((uint64_t)v101, v110, v111, v112, v113, v114, v115, v116);
                v125 = sub_1B186AE38((uint64_t)v101, v118, v119, v120, v121, v122, v123, v124);
                v133 = (void *)sub_1B17A0848(v109, v126, v127, v128, v129, v130, v131, v132);
                v134 = (const CFSetCallBacks *)MEMORY[0x1E0C9B3B0];
                Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
                theSet = CFSetCreateMutable(0, 0, v134);
                valuePtr.i32[0] = 0;
                if (v117)
                {
                  v143 = (const __CFNumber *)CFDictionaryGetValue(v117, CFSTR("uv_set"));
                  if (v143)
                  {
                    CFNumberGetValue(v143, kCFNumberIntType, &valuePtr);
                    v144 = valuePtr.i32[0];
                  }
                  else
                  {
                    v144 = 1;
                    valuePtr.i32[0] = 1;
                  }
                  v145 = sub_1B1875F00((uint64_t)v133, 3);
                  v152 = valuePtr.i32[0];
                  if (v144 >= v145)
                  {
                    sub_1B17C4408(0, (uint64_t)CFSTR("Warning: light_map uv_set:%d is pointing to an invalid uv_set(no corresponding source) and was reset to 1"), v146, v147, v148, v149, v150, v151, valuePtr.u32[0]);
                    v152 = 1;
                    valuePtr.i32[0] = 1;
                  }
                  v153 = sub_1B1875540((uint64_t)v133, 3, v152, 0, v148, v149, v150, v151);
                  if (v153)
                    CFSetSetValue(Mutable, v153);
                }
                v154 = sub_1B17A08A0(v109, v136, v137, v138, v139, v140, v141, v142);
                if ((uint64_t)v154 >= 1)
                {
                  v161 = v154;
                  for (k = 0; (const __CFArray *)k != v161; ++k)
                  {
                    v163 = sub_1B17A08FC(v109, k, v155, v156, v157, v158, v159, v160);
                    v171 = sub_1B187813C((uint64_t)v163, v164, v165, v166, v167, v168, v169, v170);
                    if (v171)
                    {
                      v172 = v171;
                      v173 = sub_1B1841ED8(v171, 0, v155, v156, v157, v158, v159, v160);
                      sub_1B1923434((uint64_t)v133, Mutable, v173, v174, v175, v176, v177, v178);
                      v185 = sub_1B1841ED8(v172, 1, v179, v180, v181, v182, v183, v184);
                      sub_1B1923434((uint64_t)v133, Mutable, v185, v186, v187, v188, v189, v190);
                      v197 = sub_1B1841ED8(v172, 2, v191, v192, v193, v194, v195, v196);
                      sub_1B1923434((uint64_t)v133, Mutable, v197, v198, v199, v200, v201, v202);
                      v209 = sub_1B1841ED8(v172, 4, v203, v204, v205, v206, v207, v208);
                      sub_1B1923434((uint64_t)v133, Mutable, v209, v210, v211, v212, v213, v214);
                      v221 = sub_1B1841ED8(v172, 6, v215, v216, v217, v218, v219, v220);
                      sub_1B1923434((uint64_t)v133, Mutable, v221, v222, v223, v224, v225, v226);
                      v233 = sub_1B1841ED8(v172, 7, v227, v228, v229, v230, v231, v232);
                      sub_1B1923434((uint64_t)v133, Mutable, v233, v234, v235, v236, v237, v238);
                      v245 = sub_1B1841ED8(v172, 8, v239, v240, v241, v242, v243, v244);
                      sub_1B1923434((uint64_t)v133, Mutable, v245, v246, v247, v248, v249, v250);
                      v257 = sub_1B1841ED8(v172, 9, v251, v252, v253, v254, v255, v256);
                      sub_1B1923434((uint64_t)v133, Mutable, v257, v258, v259, v260, v261, v262);
                      v269 = sub_1B1841ED8(v172, 10, v263, v264, v265, v266, v267, v268);
                      sub_1B1923434((uint64_t)v133, Mutable, v269, v270, v271, v272, v273, v274);
                      v281 = sub_1B1841ED8(v172, 11, v275, v276, v277, v278, v279, v280);
                      sub_1B1923434((uint64_t)v133, Mutable, v281, v282, v283, v284, v285, v286);
                      v293 = sub_1B1841ED8(v172, 12, v287, v288, v289, v290, v291, v292);
                      sub_1B1923434((uint64_t)v133, Mutable, v293, v294, v295, v296, v297, v298);
                      v305 = sub_1B1841ED8(v172, 13, v299, v300, v301, v302, v303, v304);
                      sub_1B1923434((uint64_t)v133, Mutable, v305, v306, v307, v308, v309, v310);
                      v317 = sub_1B1841ED8(v172, 14, v311, v312, v313, v314, v315, v316);
                      sub_1B1923434((uint64_t)v133, Mutable, v317, v318, v319, v320, v321, v322);
                      v329 = sub_1B1841ED8(v172, 15, v323, v324, v325, v326, v327, v328);
                      sub_1B1923434((uint64_t)v133, Mutable, v329, v330, v331, v332, v333, v334);
                      v341 = sub_1B1841ED8(v172, 16, v335, v336, v337, v338, v339, v340);
                      sub_1B1923434((uint64_t)v133, Mutable, v341, v342, v343, v344, v345, v346);
                      v353 = sub_1B1841ED8(v172, 17, v347, v348, v349, v350, v351, v352);
                      sub_1B1923434((uint64_t)v133, Mutable, v353, v354, v355, v356, v357, v358);
                    }
                  }
                }
                v359 = sub_1B1875F00((uint64_t)v133, 3);
                if (v359 >= 1)
                {
                  v364 = v359;
                  for (m = 0; m != v364; ++m)
                  {
                    v366 = sub_1B1875540((uint64_t)v133, 3, m, 0, v360, v361, v362, v363);
                    if (v366)
                    {
                      v367 = v366;
                      if (!CFSetContainsValue(Mutable, v366))
                        CFSetSetValue(theSet, v367);
                    }
                  }
                }
                v368 = theSet;
                CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_1B1924934, v133);
                v376 = sub_1B17A0848(v109, v369, v370, v371, v372, v373, v374, v375);
                if (!v125)
                {
                  v383 = v376;
                  v384 = sub_1B1875E70(v376, 1, v377, v378, v379, v380, v381, v382);
                  v391 = sub_1B1875E80(v383, 1, v385, v386, v387, v388, v389, v390);
                  v399 = sub_1B17EDAE0((uint64_t)v384, v392, v393, v394, v395, v396, v397, v398);
                  v400 = malloc_type_malloc(8 * v399, 0x100004000313F17uLL);
                  v973 = (uint64_t *)malloc_type_malloc(8 * v399, 0x100004000313F17uLL);
                  v974 = v383;
                  v966 = Mutable;
                  v401 = v383;
                  v978 = v400;
                  if (v399 < 1)
                  {
                    v403 = 0;
                  }
                  else
                  {
                    memset(v400, 255, 8 * v399);
                    v402 = 0;
                    v403 = 0;
                    v976 = v399;
                    do
                    {
                      if (v399 <= v402 + 1)
                        v404 = v402 + 1;
                      else
                        v404 = v399;
                      while (*((_QWORD *)v400 + v402) != -1)
                      {
                        if (v404 == ++v402)
                        {
                          v402 = v404 + 1;
                          goto LABEL_66;
                        }
                      }
                      *((_QWORD *)v400 + v402) = v403;
                      v405 = v402 + 1;
                      for (n = v403; v405 < v399; ++v405)
                      {
                        if (*((_QWORD *)v400 + v405) == -1)
                        {
                          v406 = CFArrayGetCount(v391);
                          if (v406 < 1)
                            goto LABEL_63;
                          v407 = v406;
                          v408 = 0;
                          for (ii = 0; ii != v407; v408 = ii >= v407)
                          {
                            v410 = CFArrayGetValueAtIndex(v391, ii);
                            v418 = sub_1B17EE3B4((uint64_t)v410, v411, v412, v413, v414, v415, v416, v417);
                            if (v418)
                            {
                              v419 = (_QWORD *)v418;
                              v420 = sub_1B18F3854(v418);
                              v428 = sub_1B179E250(v420, v421, v422, v423, v424, v425, v426, v427);
                              v435 = sub_1B18F39D4(v419, v402, v429, v430, v431, v432, v433, v434);
                              v442 = sub_1B18F39D4(v419, v405, v436, v437, v438, v439, v440, v441);
                              v443 = sub_1B18F385C((uint64_t)v419);
                              if (memcmp(v435, v442, v443 * v428))
                                break;
                            }
                            ++ii;
                          }
                          v400 = v978;
                          v403 = n;
                          v399 = v976;
                          if (v408)
LABEL_63:
                            *((_QWORD *)v400 + v405) = v403;
                        }
                      }
                      v401 = v974;
                      v973[v403++] = v402++;
LABEL_66:
                      ;
                    }
                    while (v402 < v399);
                  }
                  if (CFArrayGetCount(v391) >= 1)
                  {
                    v451 = 0;
                    v980 = v403;
                    do
                    {
                      v452 = CFArrayGetValueAtIndex(v391, v451);
                      v977 = sub_1B1875428(v401, v452, 1, v453, v454, v455, v456, v457);
                      v465 = (_QWORD *)sub_1B17EE3B4((uint64_t)v452, v458, v459, v460, v461, v462, v463, v464);
                      v466 = sub_1B18F3854((uint64_t)v465);
                      v474 = sub_1B179E250(v466, v467, v468, v469, v470, v471, v472, v473);
                      v481 = sub_1B18F385C((uint64_t)v465) * v474;
                      v482 = v481 * v403;
                      v975 = v466;
                      if (v481 * v403)
                        v483 = (UInt8 *)malloc_type_malloc(v481 * v403, 0xE64776CBuLL);
                      else
                        v483 = 0;
                      if (v403 >= 1)
                      {
                        v484 = v973;
                        v485 = v483;
                        v486 = v980;
                        do
                        {
                          v487 = *v484++;
                          v488 = sub_1B18F39D4(v465, v487, v475, v476, v477, v478, v479, v480);
                          memcpy(v485, v488, v481);
                          v485 += v481;
                          --v486;
                        }
                        while (v486);
                      }
                      v489 = CFDataCreate(allocator, v483, v482);
                      v497 = sub_1B17ED7B4((uint64_t)v452, v490, v491, v492, v493, v494, v495, v496);
                      v498 = sub_1B18F385C((uint64_t)v465);
                      v499 = sub_1B18F3B74((uint64_t)v465);
                      v507 = sub_1B18F3D80((uint64_t)v465, v500, v501, v502, v503, v504, v505, v506);
                      v403 = v980;
                      v509 = (const void *)sub_1B17ED264(v497, v489, v975, v498, v980, v499, v507, v508);
                      CFRelease(v489);
                      free(v483);
                      v401 = v974;
                      sub_1B187541C(v974, v509, v977, v510, v511, v512, v513, v514);
                      CFRelease(v509);
                      ++v451;
                      v400 = v978;
                    }
                    while (v451 < CFArrayGetCount(v391));
                  }
                  v515 = sub_1B1874BE0(v401, v444, v445, v446, v447, v448, v449, v450);
                  v14 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
                  Mutable = v966;
                  if ((uint64_t)v515 >= 1)
                  {
                    v521 = 0;
                    do
                    {
                      v522 = sub_1B1874C3C(v401, v521, 1, v516, v517, v518, v519, v520);
                      LODWORD(v988) = 0;
                      v523 = (const __CFData *)sub_1B17A4570((uint64_t)v522, &v988);
                      v524 = sub_1B17A47FC((uint64_t)v522);
                      v538 = sub_1B17A4410((uint64_t)v522, v525, v526, v527, v528, v529, v530, v531) * v524;
                      switch((_DWORD)v988)
                      {
                        case 4:
                          BytePtr = (UInt8 *)CFDataGetBytePtr(v523);
                          if (v538 >= 1)
                          {
                            do
                            {
                              *(_DWORD *)BytePtr = *((_QWORD *)v400 + *(unsigned int *)BytePtr);
                              BytePtr += 4;
                              --v538;
                            }
                            while (v538);
                          }
                          break;
                        case 2:
                          v547 = (UInt8 *)CFDataGetBytePtr(v523);
                          if (v538 >= 1)
                          {
                            do
                            {
                              *(_WORD *)v547 = *((_QWORD *)v400 + *(unsigned __int16 *)v547);
                              v547 += 2;
                              --v538;
                            }
                            while (v538);
                          }
                          break;
                        case 1:
                          v539 = (UInt8 *)CFDataGetBytePtr(v523);
                          if (v538 >= 1)
                          {
                            do
                            {
                              *v539 = *((_QWORD *)v400 + *v539);
                              ++v539;
                              --v538;
                            }
                            while (v538);
                          }
                          break;
                        default:
                          sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: __OptimizeMesh:bytesPerIndex != 1, 2, or 4 during conversion, this should not happen !!"), v532, v533, v534, v535, v536, v537, v963);
                          break;
                      }
                      ++v521;
                    }
                    while (v521 < (uint64_t)sub_1B1874BE0(v401, v540, v541, v542, v543, v544, v545, v546));
                  }
                  CFRelease(v391);
                  free(v400);
                  free(v973);
                  v368 = theSet;
                }
                CFRelease(v368);
                CFRelease(Mutable);
                v100 = v970 + 1;
                v99 = cf;
              }
              while (v970 + 1 != v969);
              CFRelease(cf);
              v8 = v964;
              v9 = v965;
            }
          }
        }
      }
    }
    v549 = CFDictionaryGetValue(v8, CFSTR("kWorldSourceCreateCameraIfAbsent"));
    if (v549)
    {
      if (CFEqual(*v14, v549))
      {
        v557 = sub_1B187A934((uint64_t)v9, v550, v551, v552, v553, v554, v555, v556);
        if (v557)
        {
          v563 = sub_1B186C054(v557, CFSTR("kCameraKey"), 1, v558, v559, v560, v561, v562);
          if (!v563 || (v570 = v563, v571 = CFArrayGetCount(v563), CFRelease(v570), v571 <= 0))
          {
            v572 = sub_1B17B2908(v9, 1, v564, v565, v566, v567, v568, v569);
            if (v572)
            {
              v580 = (const void *)v572;
              v581 = sub_1B187A934((uint64_t)v9, v573, v574, v575, v576, v577, v578, v579);
              sub_1B186A858(v581, v580, v582, v583, v584, v585, v586, v587);
              CFRelease(v580);
            }
          }
        }
      }
    }
    v588 = (const __CFBoolean *)CFDictionaryGetValue(v8, CFSTR("kWorldSourceCreateLightIfAbsent"));
    if (v588 && CFBooleanGetValue(v588))
    {
      v596 = sub_1B187A934((uint64_t)v9, v589, v590, v591, v592, v593, v594, v595);
      if (v596)
      {
        v602 = sub_1B186C054(v596, CFSTR("kLightKey"), 0, v597, v598, v599, v600, v601);
        if (v602)
        {
          v603 = v602;
          v604 = CFArrayGetCount(v602);
          if (v604 >= 1)
          {
            v605 = v604;
            v606 = 1;
            do
            {
              v607 = CFArrayGetValueAtIndex(v603, v606 - 1);
              v615 = sub_1B1868FE8((uint64_t)v607, v608, v609, v610, v611, v612, v613, v614);
              v623 = sub_1B186064C((uint64_t)v615, v616, v617, v618, v619, v620, v621, v622);
              if (v606 >= v605)
                break;
              ++v606;
            }
            while (!v623);
            if (!v623)
            {
              for (jj = 0; jj != v605; ++jj)
              {
                v625 = CFArrayGetValueAtIndex(v603, jj);
                v633 = (float32x4_t *)sub_1B1868FE8((uint64_t)v625, v626, v627, v628, v629, v630, v631, v632);
                v641 = (float *)sub_1B185F68C((uint64_t)v633, v634, v635, v636, v637, v638, v639, v640);
                if ((float)((float)(*v641 + v641[1]) + v641[2]) >= 1.5)
                {
                  v988 = 0uLL;
                  sub_1B179CD74((float *)&v988, 0.0, 0.0, 0.0, 0.0);
                  sub_1B185EE88(v633, (float *)&v988, v642, v643, v644, v645, v646, v647, v963);
                }
              }
            }
          }
          CFRelease(v603);
        }
      }
      sub_1B187A77C((CFTypeRef *)v9, CFSTR("defaultLight"), (const __CFDictionary *)*v14, v597, v598, v599, v600, v601);
    }
    v648 = CFDictionaryGetValue(v8, CFSTR("kWorldSourceCreateNormalsIfAbsent"));
    if (v648)
    {
      if (CFEqual(*v14, v648))
      {
        v656 = sub_1B187A934((uint64_t)v9, v649, v650, v651, v652, v653, v654, v655);
        if (v656)
          sub_1B186B018(v656, (uint64_t)&unk_1E63D1770);
      }
    }
    v657 = CFDictionaryGetValue(v8, CFSTR("kWorldSourceAdjustInvalidClippingPlanes"));
    if (v657)
    {
      if (CFEqual(*v14, v657))
      {
        v665 = sub_1B187A934((uint64_t)v9, v658, v659, v660, v661, v662, v663, v664);
        if (v665)
        {
          v671 = (const void *)v665;
          v672 = sub_1B186C054(v665, CFSTR("kCameraKey"), 0, v666, v667, v668, v669, v670);
          if (v672)
          {
            v673 = v672;
            v674 = CFArrayGetCount(v672);
            if (v674 > 0)
            {
              v675 = v674;
              v676 = v8;
              v677 = 0;
              v678 = 0;
              while (1)
              {
                v997 = 0u;
                v998 = 0u;
                v995 = 0u;
                v996 = 0u;
                v993 = 0u;
                v994 = 0u;
                v991 = 0u;
                v992 = 0u;
                v989 = 0u;
                v990 = 0u;
                v988 = 0u;
                v679 = CFArrayGetValueAtIndex(v673, v677);
                if (!v679)
                  goto LABEL_144;
                v686 = (uint64_t)v679;
                if (!sub_1B17B33F4((uint64_t)v679, (uint64_t)&v988, v680, v681, v682, v683, v684, v685))
                  goto LABEL_144;
                v694 = sub_1B18666D8((uint64_t)&v988, v687, v688, v689, v690, v691, v692, v693);
                if (v694 <= sub_1B1866690((uint64_t)&v988, v695, v696, v697, v698, v699, v700, v701))
                  break;
                if ((v678 & 1) == 0
                  && !sub_1B17C5C88(v671, 1, (uint64_t)&v999, (uint64_t)&v1000, v705, v706, v707, v708))
                {
                  goto LABEL_143;
                }
                v986 = 0u;
                v987 = 0u;
                v984 = 0u;
                v985 = 0u;
                valuePtr = 0u;
                v983 = 0u;
                sub_1B17B30D0(v686, &valuePtr, v703, v704, v705, v706, v707, v708, (__n128)xmmword_1B2244E10);
                v709 = v999;
                v710 = v1000;
                v709.i32[3] = 1.0;
                v710.i32[3] = 1.0;
                v711.i64[0] = 0x3F0000003F000000;
                v711.i64[1] = 0x3F0000003F000000;
                v981[2] = v984;
                v981[3] = v985;
                v981[4] = v986;
                v981[5] = v987;
                v981[0] = valuePtr;
                v981[1] = v983;
                if (vfx_frustum_classify_aabb(v981, vmulq_f32(vaddq_f32(v709, v710), v711), vmulq_f32(vsubq_f32(v710, v709), v711)) == 1)
                {
                  sub_1B17C4408(0, (uint64_t)CFSTR("Warning: invalid zRange detected (whole world clipped)"), v712, v713, v714, v715, v716, v717, v963);
LABEL_139:
                  v718 = sub_1B186CFA8(v686, v702, v703, v704, v705, v706, v707, v708);
                  if (v718)
                  {
                    v726 = sub_1B1866E38((uint64_t)v718, v719, v720, v721, v722, v723, v724, v725);
                    if (v726)
                    {
                      v733 = v726;
                      valuePtr.i32[2] = 0;
                      valuePtr.i64[0] = 0;
                      sub_1B186B5BC(v686, (__n128 *)&valuePtr, v727, v728, v729, v730, v731, v732);
                      v734.i64[0] = 0xBF000000BF000000;
                      v734.i64[1] = 0xBF000000BF000000;
                      v735 = vsubq_f32(v999, v1000);
                      v736 = vmulq_f32(v735, v735);
                      v737 = vaddq_f32(valuePtr, vmulq_f32(vaddq_f32(v999, v1000), v734));
                      v738 = vmulq_f32(v737, v737);
                      v739 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v736, 2), vaddq_f32(v736, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v736.f32, 1))).f32[0])+ sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v738, 2), vaddq_f32(v738, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v738.f32, 1))).f32[0]);
                      sub_1B186644C(v733, v739, v740, v741, v742, v743, v744, v745, v746);
                      sub_1B186652C(v733, v739 / 250.0, v747, v748, v749, v750, v751, v752, v753);
                    }
                  }
                }
                v678 = 1;
LABEL_144:
                if (v675 == ++v677)
                {
                  CFRelease(v673);
                  v8 = v676;
                  v14 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
                  goto LABEL_147;
                }
              }
              if ((v678 & 1) == 0
                && !sub_1B17C5C88(v671, 1, (uint64_t)&v999, (uint64_t)&v1000, v705, v706, v707, v708))
              {
LABEL_143:
                v678 = 0;
                goto LABEL_144;
              }
              goto LABEL_139;
            }
            CFRelease(v673);
          }
        }
      }
    }
LABEL_147:
    v754 = (const __CFBoolean *)CFDictionaryGetValue(v8, CFSTR("kWorldSourceMakeSourcesCheaper"));
    if (v754)
    {
      if (CFBooleanGetValue(v754))
      {
        v759 = sub_1B187A934((uint64_t)v9, v755, v756, v757, v758, v11, v12, v13);
        if (v759)
        {
          v762 = sub_1B186C054(v759, CFSTR("model"), 0, v760, v761, v11, v12, v13);
          if (v762)
          {
            v763 = v762;
            v764 = v8;
            v765 = CFArrayGetCount(v762);
            if (v765 >= 1)
            {
              v766 = v765;
              for (kk = 0; kk != v766; ++kk)
              {
                v768 = CFArrayGetValueAtIndex(v763, kk);
                v776 = sub_1B1868FA0((uint64_t)v768, v769, v770, v771, v772, v773, v774, v775);
                v784 = sub_1B186D1B0((uint64_t)v768, v777, v778, v779, v780, v781, v782, v783);
                sub_1B17B277C(v776, (uint64_t)v784, v785, v786, v787, v788, v789, v790);
              }
            }
            CFRelease(v763);
            v8 = v764;
          }
        }
      }
    }
  }
  LODWORD(v988) = 0;
  valuePtr.i32[0] = 0;
  v981[0].i32[0] = 0;
  if (sub_1B192347C(v9, v8, (int *)&v988, valuePtr.f32, v981, v11, v12, v13))
  {
    v797 = valuePtr.f32[0] == 1.0 && (_DWORD)v988 == 0;
    v798 = !v797;
    if (a4 == 1 && v798)
      sub_1B17C4408(0, (uint64_t)CFSTR("Info: VFXWorldLoaderConvertUnitsToMetersKey and VFXWorldLoaderConvertToYUpKey have no effect on compressed assets. Use Xcode's compression options instead"), v791, v792, v793, v794, v795, v796, v963);
  }
  if (!v8)
  {
    if ((+[VFXView _isMetalSupported]_0() & 1) != 0)
      return;
    goto LABEL_182;
  }
  v799 = CFDictionaryGetValue(v8, CFSTR("kWorldSourceFlattenWorld"));
  if (v799)
  {
    if (CFEqual(*v14, v799))
    {
      v807 = sub_1B187A97C((uint64_t)v9, v800, v801, v802, v803, v804, v805, v806);
      if (!v807 || sub_1B17F2FC4(v807, v808, v809, v810, v811, v812, v813, v814))
      {
        v815 = (_QWORD *)sub_1B187A934((uint64_t)v9, v808, v809, v810, v811, v812, v813, v814);
        v816 = sub_1B186C304(v815, (uint64_t)&unk_1E63D18B0, 1);
        v817 = CFArrayGetCount(v816);
        CFRelease(v816);
        if (v817 <= 0)
        {
          v822 = v14;
          v823 = v8;
          v824 = (void *)sub_1B17AE1F4((uint64_t)v815, 1, 1, 0, v818, v819, v820, v821);
          v825 = (uint64_t *)sub_1B186A0A0();
          v826 = sub_1B186C304(v815, (uint64_t)&unk_1E63D96C0, 1);
          v990 = 0u;
          v991 = 0u;
          v988 = 0u;
          v989 = 0u;
          v827 = CFArrayGetCount(v826);
          if (v827 >= 1)
          {
            v828 = v827;
            for (mm = 0; mm != v828; ++mm)
            {
              v830 = CFArrayGetValueAtIndex(v826, mm);
              sub_1B186BDB8((uint64_t)v830, (uint64_t)&v988, v831, v832, v833, v834, v835, v836);
              sub_1B186BC48((uint64_t)v830, (uint64_t)&v988);
              v843 = (const void *)sub_1B186A758((uint64_t)v830, 0, v837, v838, v839, v840, v841, v842);
              sub_1B186A858((uint64_t)v825, v843, v844, v845, v846, v847, v848, v849);
              CFRelease(v843);
            }
          }
          v850 = (float32x4_t *)sub_1B186A0A0();
          sub_1B186A58C(v850, v824, v851, v852, v853, v854, v855, v856);
          CFRelease(v824);
          sub_1B186C458((uint64_t)v850, CFSTR("nodeFromflattenedMesh"), v857, v858, v859, v860, v861, v862);
          sub_1B186A858((uint64_t)v825, v850, v863, v864, v865, v866, v867, v868);
          CFRelease(v850);
          v869 = (const void *)sub_1B187A58C();
          sub_1B187A780((uint64_t)v869, v825, v870, v871, v872, v873, v874, v875);
          CFRelease(v825);
          CFRelease(v826);
          v8 = v823;
          v14 = v822;
          if (v869)
          {
            v883 = (void *)sub_1B187A934((uint64_t)v869, v876, v877, v878, v879, v880, v881, v882);
            CFRetain(v883);
            sub_1B187A780((uint64_t)v869, 0, v884, v885, v886, v887, v888, v889);
            sub_1B187A780((uint64_t)v9, (uint64_t *)v883, v890, v891, v892, v893, v894, v895);
            CFRelease(v883);
            CFRelease(v869);
          }
        }
      }
    }
  }
  v896 = CFDictionaryGetValue(v8, CFSTR("kWorldSourceSplitMeshesForGLES"));
  isMetal = +[VFXView _isMetalSupported]_0();
  if (v896)
  {
    if (!CFEqual(*v14, v896))
      goto LABEL_183;
LABEL_182:
    v905 = sub_1B187A934((uint64_t)v9, v898, v899, v900, v901, v902, v903, v904);
    sub_1B17AF50C(v905, 0xFFFFLL, v906, v907, v908, v909, v910, v911);
    if (!v8)
      return;
    goto LABEL_183;
  }
  if ((isMetal & 1) == 0)
    goto LABEL_182;
LABEL_183:
  v912 = (const __CFBoolean *)CFDictionaryGetValue(v8, CFSTR("kWorldSourceInterleaveSources"));
  if (v912)
  {
    if (CFBooleanGetValue(v912))
    {
      v920 = sub_1B187A934((uint64_t)v9, v913, v914, v915, v916, v917, v918, v919);
      if (v920)
      {
        v926 = sub_1B186C054(v920, CFSTR("model"), 0, v921, v922, v923, v924, v925);
        if (v926)
        {
          v927 = v926;
          v928 = CFArrayGetCount(v926);
          if (v928 >= 1)
          {
            v929 = v928;
            for (nn = 0; nn != v929; ++nn)
            {
              v931 = CFArrayGetValueAtIndex(v927, nn);
              v939 = sub_1B1868FA0((uint64_t)v931, v932, v933, v934, v935, v936, v937, v938);
              v947 = sub_1B17A0848(v939, v940, v941, v942, v943, v944, v945, v946);
              v955 = sub_1B17B2334(v947, v948, v949, v950, v951, v952, v953, v954);
              if (v955)
              {
                v962 = (const void *)v955;
                sub_1B17A14D4(v939, v955, v956, v957, v958, v959, v960, v961);
                CFRelease(v962);
              }
            }
          }
          CFRelease(v927);
        }
      }
    }
  }
}

uint64_t sub_1B192486C(const __CFURL *a1, CFDictionaryRef theDict)
{
  const __CFBoolean *Value;
  int v5;
  int v6;
  const __CFString *v7;
  const __CFString *v8;
  int HasPrefix;

  if (theDict)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("kWorldSourceCheckConsistency"));
    if (Value)
      return CFBooleanGetValue(Value) != 0;
  }
  v5 = sub_1B179FC38(a1);
  v6 = v5;
  if (a1
    && (v5 & 1) == 0
    && (v7 = CFURLCopyPath(a1)) != 0
    && (v8 = v7, HasPrefix = CFStringHasPrefix(v7, CFSTR("/System")), CFRelease(v8), HasPrefix))
  {
    return 0;
  }
  else
  {
    return v6 ^ 1u;
  }
}

uint64_t sub_1B192490C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v8 = sub_1B1868FA0(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
    sub_1B17B21D0(v8, 1, v9, v10, v11, v12, v13, v14);
  return 0;
}

void sub_1B1924934(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B18757DC(a2, a1, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B1924944(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const void *v49;
  unsigned __int8 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;

  v8 = sub_1B1868FA0(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
  {
    v16 = v8;
    if (!sub_1B184A830(v8, v9, v10, v11, v12, v13, v14, v15))
    {
      v24 = sub_1B17A0848(v16, v17, v18, v19, v20, v21, v22, v23);
      if (v24)
      {
        v31 = v24;
        if (!sub_1B18760A0(v24, 0, v25, v26, v27, v28, v29, v30))
        {
          if (sub_1B1875E70(v31, 0, v32, v33, v34, v35, v36, v37))
          {
            v43 = sub_1B17B13D4(v31, 0, 0, v38, v39, v40, v41, v42);
            if (v43)
            {
              v49 = (const void *)v43;
              v50 = sub_1B1875D94(v31, 0, 0, v44, v45, v46, v47, v48);
              sub_1B1875414(v31, v49, 0, v50, v51, v52, v53, v54);
              CFRelease(v49);
            }
          }
        }
      }
    }
  }
  return 0;
}

BOOL sub_1B19249E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  return sub_1B186AE38(a2, a2, a3, a4, a5, a6, a7, a8) || sub_1B186ACAC(a2, v9, v10, v11, v12, v13, v14, v15) != 0;
}

BOOL sub_1B1924A28(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  return sub_1B186CFA8(a2, a2, a3, a4, a5, a6, a7, a8) || sub_1B1868FE8(a2, v9, v10, v11, v12, v13, v14, v15) != 0;
}

void sub_1B1924A68()
{
  if (qword_1EEF66578 != -1)
    dispatch_once(&qword_1EEF66578, &unk_1E63D1250);
}

void *sub_1B1924A90()
{
  sub_1B221BA34(sub_1B1924AB4);
  return sub_1B221BA40(sub_1B1924AE0);
}

void sub_1B1924AB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B17C4408(16, (uint64_t)CFSTR("Error (OpenSubdiv): %s"), a3, a4, a5, a6, a7, a8, a2);
}

void sub_1B1924AE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B17C4408(0, (uint64_t)CFSTR("Warning (OpenSubdiv): %s"), a3, a4, a5, a6, a7, a8, a1);
}

uint64_t sub_1B1924B0C(int a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3;

  if (a1 == 4)
    v3 = a3;
  else
    v3 = 0;
  if (a2)
    v3 = 0;
  if ((a1 & 0xFE) == 2)
    v3 = 1;
  if (a1)
    return v3;
  else
    return a2 == 0;
}

uint64_t sub_1B1924B44(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const void *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const void *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const void *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const void *v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const void *v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const void *v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  const void *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  const void *v73;
  int v75;
  _QWORD v76[2];
  uint64_t (*v77)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v78;
  uint64_t v79;

  sub_1B1924D88(a1);
  v2 = *(_QWORD *)(a1 + 168);
  v76[0] = MEMORY[0x1E0C809B0];
  v76[1] = 0x40000000;
  v77 = sub_1B19255F4;
  v78 = &unk_1E63D9700;
  v79 = v2;
  v10 = sub_1B17A0848(a1, v3, v4, v5, v6, v7, v8, v9);
  v15 = v10;
  v16 = *(_QWORD *)(v2 + 80);
  v17 = *(_QWORD *)(v2 + 88);
  if (v16 == v17)
  {
LABEL_9:
    v75 = 0;
    goto LABEL_10;
  }
  v18 = -1;
  while (1)
  {
    if (*(_DWORD *)(v16 + 12) == 3)
    {
      if (v18 == -1)
      {
        v18 = *(_BYTE *)(v16 + 8);
        goto LABEL_8;
      }
      if (*(unsigned __int8 *)(v16 + 8) != v18)
        break;
    }
LABEL_8:
    v16 += 16;
    if (v16 == v17)
      goto LABEL_9;
  }
  v75 = 1;
LABEL_10:
  v19 = sub_1B1875540(v10, 2, 0, 0, v11, v12, v13, v14);
  v26 = v75 & 0xFFFFFFF9 | (2 * (sub_1B19255F4((uint64_t)v76, (uint64_t)v19, v20, v21, v22, v23, v24, v25) & 3));
  v31 = sub_1B1875540(v15, 3, 0, 0, v27, v28, v29, v30);
  v32 = v26 & 0xFFFFFFE7 | (8 * (((uint64_t (*)(_QWORD *, const void *))v77)(v76, v31) & 3));
  v37 = sub_1B1875540(v15, 3, 1, 0, v33, v34, v35, v36);
  v38 = v32 & 0xFFFFFF9F | (32 * (((uint64_t (*)(_QWORD *, const void *))v77)(v76, v37) & 3));
  v43 = sub_1B1875540(v15, 3, 2, 0, v39, v40, v41, v42);
  v44 = v38 & 0xFFFFFE7F | ((((uint64_t (*)(_QWORD *, const void *))v77)(v76, v43) & 3) << 7);
  v49 = sub_1B1875540(v15, 3, 3, 0, v45, v46, v47, v48);
  v50 = ((uint64_t (*)(_QWORD *, const void *))v77)(v76, v49);
  v55 = sub_1B1875540(v15, 3, 4, 0, v51, v52, v53, v54);
  v56 = ((uint64_t (*)(_QWORD *, const void *))v77)(v76, v55);
  v61 = sub_1B1875540(v15, 3, 5, 0, v57, v58, v59, v60);
  v62 = (((uint64_t (*)(_QWORD *, const void *))v77)(v76, v61) & 3) << 13;
  v67 = sub_1B1875540(v15, 3, 6, 0, v63, v64, v65, v66);
  v68 = (((uint64_t (*)(_QWORD *, const void *))v77)(v76, v67) & 3) << 15;
  v73 = sub_1B1875540(v15, 3, 7, 0, v69, v70, v71, v72);
  return v44 & 0xFFFFE1FF | ((v50 & 3) << 9) & 0xE7FF | ((v56 & 3) << 11) | v62 | v68 | ((((uint64_t (*)(_QWORD *, const void *))v77)(v76, v73) & 3) << 17);
}

uint64_t sub_1B1924D88(uint64_t result)
{
  uint64_t v1;
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float32x4_t v42;
  float v43;
  float v44;
  uint64_t v45;
  int v46;
  int v47;
  float32x4_t v48;
  _OWORD *v49;
  char v50;
  int v51;
  unint64_t v52;
  char *v53;
  _DWORD *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  char *v62;
  int v63;
  unint64_t v64;
  char *v65;
  _DWORD *v66;
  char *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  char *v73;
  int v74;
  _QWORD *v75;
  void **v76;
  void **v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  unint64_t v84;
  char *v85;
  _DWORD *v86;
  char *v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  char *v92;
  char *v93;
  int v94;
  unint64_t v95;
  char *v96;
  _DWORD *v97;
  char *v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  unint64_t v102;
  char *v103;
  char *v104;
  int v105;
  void **v106;
  void **v107;
  int v108;
  unint64_t v109;
  char *v110;
  _DWORD *v111;
  char *v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  char *v117;
  char *v118;
  int v119;
  unint64_t v120;
  char *v121;
  _DWORD *v122;
  char *v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  char *v128;
  char *v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  const __CFArray *v144;
  CFIndex v145;
  int v146;
  const void *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  char v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  void *v161;
  CFIndex i;
  const void *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  char v171;
  size_t v172;
  void *v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  CFIndex j;
  const void *v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  char v194;
  uint64_t v195;
  uint64_t v196;
  int v197;
  _QWORD v198[9];
  int v199;
  _QWORD v200[8];
  _QWORD v201[5];
  uint64_t *v202;
  _QWORD *v203;
  uint64_t v204;
  float32x4_t v205;
  int v206;
  uint64_t v207;

  v207 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(result + 168))
    return result;
  v1 = result;
  v2 = (char *)malloc_type_calloc(1uLL, 0xD8uLL, 0x10F004000FC2A7CuLL);
  *(_QWORD *)(v1 + 168) = v2;
  v10 = sub_1B17A0848(v1, v3, v4, v5, v6, v7, v8, v9);
  if (sub_1B1875F00(v10, 0) != 1)
    sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Trying to subdivide a mesh that does not have exactly 1 position source."), v11, v12, v13, v14, v15, v16, v195);
  v17 = sub_1B1875540(v10, 0, 0, 0, v13, v14, v15, v16);
  v25 = sub_1B17ED6C4((uint64_t)v17, v18, v19, v20, v21, v22, v23, v24);
  v27 = v26;
  v28 = v26;
  v196 = v26;
  v197 = v26;
  if (sub_1B1875CD4(v10, 0))
  {
    if (*(_BYTE *)(v1 + 130))
    {
      if (sub_1B17A289C(v1, v29, v30, v31, v32, v33, v34, v35))
      {
        *v2 = 2;
        v203 = 0;
        v204 = 0;
        v202 = (uint64_t *)&v203;
        if ((_DWORD)v27)
        {
          v45 = 0;
          v46 = BYTE4(v27);
          v47 = BYTE5(v27);
          do
          {
            *(double *)v48.i64 = sub_1B198D4F8(v46, (const float *)(v25 + (v47 * v45)), v36, v37, v38, v39, v40, v41, v42, v43, v44);
            v205 = v48;
            v206 = v204;
            v49 = sub_1B193C3C0(&v202, &v205, (uint64_t)&v205);
            v205.i8[0] = v50 ^ 1;
            v51 = *((_DWORD *)v49 + 12);
            v53 = (char *)*((_QWORD *)v2 + 2);
            v52 = *((_QWORD *)v2 + 3);
            if ((unint64_t)v53 >= v52)
            {
              v56 = (char *)*((_QWORD *)v2 + 1);
              v57 = (v53 - v56) >> 2;
              v58 = v57 + 1;
              if ((unint64_t)(v57 + 1) >> 62)
                goto LABEL_145;
              v59 = v52 - (_QWORD)v56;
              if (v59 >> 1 > v58)
                v58 = v59 >> 1;
              if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFFCLL)
                v60 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v60 = v58;
              if (v60)
              {
                v61 = (char *)sub_1B17F7E58((uint64_t)(v2 + 24), v60);
                v56 = (char *)*((_QWORD *)v2 + 1);
                v53 = (char *)*((_QWORD *)v2 + 2);
              }
              else
              {
                v61 = 0;
              }
              v62 = &v61[4 * v57];
              *(_DWORD *)v62 = v51;
              v54 = v62 + 4;
              if (v53 == v56)
              {
                v55 = v196;
              }
              else
              {
                v55 = v196;
                do
                {
                  v63 = *((_DWORD *)v53 - 1);
                  v53 -= 4;
                  *((_DWORD *)v62 - 1) = v63;
                  v62 -= 4;
                }
                while (v53 != v56);
              }
              *((_QWORD *)v2 + 1) = v62;
              *((_QWORD *)v2 + 2) = v54;
              *((_QWORD *)v2 + 3) = &v61[4 * v60];
              if (v56)
                operator delete(v56);
            }
            else
            {
              *(_DWORD *)v53 = v51;
              v54 = v53 + 4;
              v55 = v196;
            }
            *((_QWORD *)v2 + 2) = v54;
            sub_1B1925820((uint64_t)(v2 + 56), &v205);
            if (v205.i8[0])
            {
              *v2 = 3;
            }
            else
            {
              v65 = (char *)*((_QWORD *)v2 + 5);
              v64 = *((_QWORD *)v2 + 6);
              if ((unint64_t)v65 >= v64)
              {
                v67 = (char *)*((_QWORD *)v2 + 4);
                v68 = (v65 - v67) >> 2;
                v69 = v68 + 1;
                if ((unint64_t)(v68 + 1) >> 62)
                  goto LABEL_145;
                v70 = v64 - (_QWORD)v67;
                if (v70 >> 1 > v69)
                  v69 = v70 >> 1;
                if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFFCLL)
                  v71 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v71 = v69;
                if (v71)
                {
                  v72 = (char *)sub_1B17F7E58((uint64_t)(v2 + 48), v71);
                  v67 = (char *)*((_QWORD *)v2 + 4);
                  v65 = (char *)*((_QWORD *)v2 + 5);
                }
                else
                {
                  v72 = 0;
                }
                v73 = &v72[4 * v68];
                *(_DWORD *)v73 = v45;
                v66 = v73 + 4;
                while (v65 != v67)
                {
                  v74 = *((_DWORD *)v65 - 1);
                  v65 -= 4;
                  *((_DWORD *)v73 - 1) = v74;
                  v73 -= 4;
                }
                *((_QWORD *)v2 + 4) = v73;
                *((_QWORD *)v2 + 5) = v66;
                *((_QWORD *)v2 + 6) = &v72[4 * v71];
                if (v67)
                  operator delete(v67);
              }
              else
              {
                *(_DWORD *)v65 = v45;
                v66 = v65 + 4;
              }
              *((_QWORD *)v2 + 5) = v66;
            }
            ++v45;
          }
          while (v45 != v55);
          v75 = v203;
        }
        else
        {
          v75 = 0;
        }
        v28 = (uint64_t)(*((_QWORD *)v2 + 5) - *((_QWORD *)v2 + 4)) >> 2;
        sub_1B1805B90((uint64_t)&v202, v75);
        goto LABEL_124;
      }
      if ((byte_1EEF66580 & 1) == 0)
      {
        byte_1EEF66580 = 1;
        sub_1B17C4408(16, (uint64_t)CFSTR("Warning: Subdivision process might lead to gaps in surface because vertex welding is disabled when subdividing on the GPU"), v36, v37, v38, v39, v40, v41, v195);
      }
    }
    *v2 = 1;
    v106 = (void **)(v2 + 32);
    v107 = (void **)(v2 + 8);
    sub_1B17F7530((void **)v2 + 1, v28);
    sub_1B17F7530((void **)v2 + 4, v28);
    if ((_DWORD)v27)
    {
      v108 = 0;
      do
      {
        v110 = (char *)*((_QWORD *)v2 + 2);
        v109 = *((_QWORD *)v2 + 3);
        if ((unint64_t)v110 >= v109)
        {
          v112 = (char *)*v107;
          v113 = (v110 - (_BYTE *)*v107) >> 2;
          v114 = v113 + 1;
          if ((unint64_t)(v113 + 1) >> 62)
            goto LABEL_145;
          v115 = v109 - (_QWORD)v112;
          if (v115 >> 1 > v114)
            v114 = v115 >> 1;
          if ((unint64_t)v115 >= 0x7FFFFFFFFFFFFFFCLL)
            v116 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v116 = v114;
          if (v116)
          {
            v117 = (char *)sub_1B17F7E58((uint64_t)(v2 + 24), v116);
            v112 = (char *)*((_QWORD *)v2 + 1);
            v110 = (char *)*((_QWORD *)v2 + 2);
          }
          else
          {
            v117 = 0;
          }
          v118 = &v117[4 * v113];
          *(_DWORD *)v118 = v108;
          v111 = v118 + 4;
          while (v110 != v112)
          {
            v119 = *((_DWORD *)v110 - 1);
            v110 -= 4;
            *((_DWORD *)v118 - 1) = v119;
            v118 -= 4;
          }
          *((_QWORD *)v2 + 1) = v118;
          *((_QWORD *)v2 + 2) = v111;
          *((_QWORD *)v2 + 3) = &v117[4 * v116];
          if (v112)
            operator delete(v112);
        }
        else
        {
          *(_DWORD *)v110 = v108;
          v111 = v110 + 4;
        }
        *((_QWORD *)v2 + 2) = v111;
        v121 = (char *)*((_QWORD *)v2 + 5);
        v120 = *((_QWORD *)v2 + 6);
        if ((unint64_t)v121 >= v120)
        {
          v123 = (char *)*v106;
          v124 = (v121 - (_BYTE *)*v106) >> 2;
          v125 = v124 + 1;
          if ((unint64_t)(v124 + 1) >> 62)
            goto LABEL_145;
          v126 = v120 - (_QWORD)v123;
          if (v126 >> 1 > v125)
            v125 = v126 >> 1;
          if ((unint64_t)v126 >= 0x7FFFFFFFFFFFFFFCLL)
            v127 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v127 = v125;
          if (v127)
          {
            v128 = (char *)sub_1B17F7E58((uint64_t)(v2 + 48), v127);
            v123 = (char *)*((_QWORD *)v2 + 4);
            v121 = (char *)*((_QWORD *)v2 + 5);
          }
          else
          {
            v128 = 0;
          }
          v129 = &v128[4 * v124];
          *(_DWORD *)v129 = v108;
          v122 = v129 + 4;
          while (v121 != v123)
          {
            v130 = *((_DWORD *)v121 - 1);
            v121 -= 4;
            *((_DWORD *)v129 - 1) = v130;
            v129 -= 4;
          }
          *((_QWORD *)v2 + 4) = v129;
          *((_QWORD *)v2 + 5) = v122;
          *((_QWORD *)v2 + 6) = &v128[4 * v127];
          if (v123)
            operator delete(v123);
        }
        else
        {
          *(_DWORD *)v121 = v108;
          v122 = v121 + 4;
        }
        *((_QWORD *)v2 + 5) = v122;
        ++v108;
      }
      while (v108 != v197);
LABEL_121:
      LODWORD(v28) = v196;
    }
  }
  else
  {
    *v2 = 0;
    v76 = (void **)(v2 + 32);
    v77 = (void **)(v2 + 8);
    sub_1B17F7530((void **)v2 + 1, v28);
    sub_1B17F7530((void **)v2 + 4, v28);
    if ((_DWORD)v27)
    {
      v83 = 0;
      do
      {
        v85 = (char *)*((_QWORD *)v2 + 2);
        v84 = *((_QWORD *)v2 + 3);
        if ((unint64_t)v85 >= v84)
        {
          v87 = (char *)*v77;
          v88 = (v85 - (_BYTE *)*v77) >> 2;
          v89 = v88 + 1;
          if ((unint64_t)(v88 + 1) >> 62)
            goto LABEL_145;
          v90 = v84 - (_QWORD)v87;
          if (v90 >> 1 > v89)
            v89 = v90 >> 1;
          if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFFCLL)
            v91 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v91 = v89;
          if (v91)
          {
            v92 = (char *)sub_1B17F7E58((uint64_t)(v2 + 24), v91);
            v87 = (char *)*((_QWORD *)v2 + 1);
            v85 = (char *)*((_QWORD *)v2 + 2);
          }
          else
          {
            v92 = 0;
          }
          v93 = &v92[4 * v88];
          *(_DWORD *)v93 = v83;
          v86 = v93 + 4;
          while (v85 != v87)
          {
            v94 = *((_DWORD *)v85 - 1);
            v85 -= 4;
            *((_DWORD *)v93 - 1) = v94;
            v93 -= 4;
          }
          *((_QWORD *)v2 + 1) = v93;
          *((_QWORD *)v2 + 2) = v86;
          *((_QWORD *)v2 + 3) = &v92[4 * v91];
          if (v87)
            operator delete(v87);
        }
        else
        {
          *(_DWORD *)v85 = v83;
          v86 = v85 + 4;
        }
        *((_QWORD *)v2 + 2) = v86;
        v96 = (char *)*((_QWORD *)v2 + 5);
        v95 = *((_QWORD *)v2 + 6);
        if ((unint64_t)v96 >= v95)
        {
          v98 = (char *)*v76;
          v99 = (v96 - (_BYTE *)*v76) >> 2;
          v100 = v99 + 1;
          if ((unint64_t)(v99 + 1) >> 62)
LABEL_145:
            abort();
          v101 = v95 - (_QWORD)v98;
          if (v101 >> 1 > v100)
            v100 = v101 >> 1;
          if ((unint64_t)v101 >= 0x7FFFFFFFFFFFFFFCLL)
            v102 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v102 = v100;
          if (v102)
          {
            v103 = (char *)sub_1B17F7E58((uint64_t)(v2 + 48), v102);
            v98 = (char *)*((_QWORD *)v2 + 4);
            v96 = (char *)*((_QWORD *)v2 + 5);
          }
          else
          {
            v103 = 0;
          }
          v104 = &v103[4 * v99];
          *(_DWORD *)v104 = v83;
          v97 = v104 + 4;
          while (v96 != v98)
          {
            v105 = *((_DWORD *)v96 - 1);
            v96 -= 4;
            *((_DWORD *)v104 - 1) = v105;
            v104 -= 4;
          }
          *((_QWORD *)v2 + 4) = v104;
          *((_QWORD *)v2 + 5) = v97;
          *((_QWORD *)v2 + 6) = &v103[4 * v102];
          if (v98)
            operator delete(v98);
        }
        else
        {
          *(_DWORD *)v96 = v83;
          v97 = v96 + 4;
        }
        *((_QWORD *)v2 + 5) = v97;
        ++v83;
      }
      while (v83 != v197);
      goto LABEL_121;
    }
  }
LABEL_124:
  v131 = MEMORY[0x1E0C809B0];
  v201[0] = MEMORY[0x1E0C809B0];
  v201[1] = 0x40000000;
  v201[2] = sub_1B19258C0;
  v201[3] = &unk_1E63D9720;
  v201[4] = v2;
  sub_1B1873EE0(v10, 0, (uint64_t)v201, v78, v79, v80, v81, v82);
  *((_DWORD *)v2 + 26) = v28;
  v144 = sub_1B1874BE0(v10, v132, v133, v134, v135, v136, v137, v138);
  if ((uint64_t)v144 < 1)
  {
    v146 = 0;
  }
  else
  {
    v145 = 0;
    v146 = 0;
    do
    {
      v147 = sub_1B1874C3C(v10, v145, 0, v139, v140, v141, v142, v143);
      v155 = sub_1B17A426C((uint64_t)v147, v148, v149, v150, v151, v152, v153, v154);
      if (sub_1B17A44A0(v155))
        v146 += sub_1B17A46C4((uint64_t)v147);
      ++v145;
    }
    while (v144 != (const __CFArray *)v145);
  }
  *((_DWORD *)v2 + 27) = v146;
  v161 = malloc_type_malloc(4 * v146, 0x100004052888210uLL);
  *((_DWORD *)v2 + 52) = 0;
  v2[212] = 1;
  v205.i32[0] = 0;
  if ((uint64_t)v144 < 1)
  {
    v172 = 0;
  }
  else
  {
    for (i = 0; (const __CFArray *)i != v144; ++i)
    {
      v163 = sub_1B1874C3C(v10, i, 0, v156, v157, v158, v159, v160);
      v171 = sub_1B17A426C((uint64_t)v163, v164, v165, v166, v167, v168, v169, v170);
      if (sub_1B17A44A0(v171))
      {
        v200[0] = v131;
        v200[1] = 0x40000000;
        v200[2] = sub_1B1925A20;
        v200[3] = &unk_1E63D9740;
        v200[4] = v163;
        v200[5] = v161;
        v200[6] = &v205;
        v200[7] = v2;
        sub_1B17A4700((uint64_t)v163, (uint64_t)v200);
      }
    }
    v172 = 4 * *((unsigned int *)v2 + 52);
  }
  *((_QWORD *)v2 + 14) = v161;
  v173 = malloc_type_malloc(v172, 0x100004052888210uLL);
  result = sub_1B1875D94(v10, 0, 0, v174, v175, v176, v177, v178);
  LODWORD(v202) = 0;
  if ((uint64_t)v144 >= 1)
  {
    v184 = result;
    for (j = 0; (const __CFArray *)j != v144; ++j)
    {
      v186 = sub_1B1874C3C(v10, j, 0, v179, v180, v181, v182, v183);
      v194 = sub_1B17A426C((uint64_t)v186, v187, v188, v189, v190, v191, v192, v193);
      result = sub_1B17A44A0(v194);
      if ((_DWORD)result)
      {
        v198[0] = v131;
        v198[1] = 0x40000000;
        v198[2] = sub_1B1925A78;
        v198[3] = &unk_1E63D9760;
        v198[4] = v186;
        v198[5] = v184;
        v199 = v197;
        v198[6] = v2;
        v198[7] = v173;
        v198[8] = &v202;
        result = sub_1B17A4700((uint64_t)v186, (uint64_t)v198);
      }
    }
  }
  *((_QWORD *)v2 + 15) = v173;
  return result;
}

uint64_t sub_1B19255F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a2)
    return 0;
  v8 = *(_QWORD *)(a1 + 32);
  v9 = *(_QWORD *)(v8 + 80);
  v10 = *(_QWORD *)(v8 + 88);
  while (1)
  {
    if (v9 == v10)
    {
      sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Could not find mesh source indexing info for source %p"), a3, a4, a5, a6, a7, a8, a2);
      return 0;
    }
    if (*(_QWORD *)v9 == a2)
      break;
    v9 += 16;
  }
  return *(unsigned int *)(v9 + 12);
}

uint64_t sub_1B192565C(unsigned int a1)
{
  return (a1 >> 1) & 3;
}

uint64_t sub_1B1925664(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  switch(a2)
  {
    case 0u:
      result = (a1 >> 3) & 3;
      break;
    case 1u:
      result = (a1 >> 5) & 3;
      break;
    case 2u:
      result = (a1 >> 7) & 3;
      break;
    case 3u:
      result = (a1 >> 9) & 3;
      break;
    case 4u:
      result = (a1 >> 11) & 3;
      break;
    case 5u:
      result = (a1 >> 13) & 3;
      break;
    case 6u:
      result = (a1 >> 15) & 3;
      break;
    case 7u:
      result = (a1 >> 17) & 3;
      break;
    default:
      sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Unssuported texture coordinates channel (%d)"), a3, a4, a5, a6, a7, a8, a2);
      result = 0;
      break;
  }
  return result;
}

BOOL sub_1B19256F8(char a1)
{
  return (a1 & 6) == 4;
}

uint64_t sub_1B1925708(unsigned int a1)
{
  int v1;
  int v2;
  int32x4_t v3;
  uint8x8_t v4;
  __int32 v5;

  v1 = (a1 & 0x18) == 16;
  if ((a1 & 0x18) == 0x10)
    v2 = 2;
  else
    v2 = 1;
  if ((a1 & 0x60) == 0x40)
    v1 = v2;
  v3 = (int32x4_t)vandq_s8((int8x16_t)vceqq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_n_s32(a1), (int8x16_t)xmmword_1B22682E0), (int32x4_t)xmmword_1B22682F0), (int8x16_t)xmmword_1B2245E50);
  v3.i32[0] = vaddvq_s32(v3) & 0xF;
  v4 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v3.i8);
  v4.i16[0] = vaddlv_u8(v4);
  v5 = v4.i32[0];
  if ((a1 & 0x18000) == 0x10000)
    v5 = v4.i32[0] + 1;
  if ((a1 & 0x60000) == 0x40000)
    ++v1;
  return (v5 + v1);
}

BOOL sub_1B192578C(int a1)
{
  return (~a1 & 6) == 0;
}

uint64_t sub_1B192579C(unsigned int a1)
{
  int v1;
  int v2;
  int32x4_t v3;
  uint8x8_t v4;
  __int32 v5;

  v1 = (~a1 & 0x18) == 0;
  if ((~a1 & 0x18) != 0)
    v2 = 1;
  else
    v2 = 2;
  if ((~a1 & 0x60) == 0)
    v1 = v2;
  v3 = (int32x4_t)vandq_s8((int8x16_t)vceqq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_n_s32(a1), (int8x16_t)xmmword_1B22682E0), (int32x4_t)xmmword_1B22682E0), (int8x16_t)xmmword_1B2245E50);
  v3.i32[0] = vaddvq_s32(v3) & 0xF;
  v4 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v3.i8);
  v4.i16[0] = vaddlv_u8(v4);
  v5 = v4.i32[0];
  if ((~a1 & 0x18000) == 0)
    v5 = v4.i32[0] + 1;
  if ((~a1 & 0x60000) == 0)
    ++v1;
  return (v5 + v1);
}

uint64_t sub_1B1925818(char a1)
{
  return a1 & 1;
}

void sub_1B1925820(uint64_t a1, _BYTE *a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v4 == v5 << 6)
  {
    if ((uint64_t)(v4 + 1) < 0)
      abort();
    v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0) + 64)
      v6 = (v4 & 0xFFFFFFFFFFFFFFC0) + 64;
    if (v4 <= 0x3FFFFFFFFFFFFFFELL)
      v7 = v6;
    else
      v7 = 0x7FFFFFFFFFFFFFFFLL;
    sub_1B1928BFC((char **)a1, v7);
    v4 = *(_QWORD *)(a1 + 8);
  }
  *(_QWORD *)(a1 + 8) = v4 + 1;
  v8 = *(char **)a1;
  v9 = v4 >> 6;
  v10 = 1 << v4;
  if (*a2)
    v11 = *(_QWORD *)&v8[8 * v9] | v10;
  else
    v11 = *(_QWORD *)&v8[8 * v9] & ~v10;
  *(_QWORD *)&v8[8 * v9] = v11;
}

void sub_1B19258C0(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5)
{
  _QWORD *v7;
  unsigned int v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;

  if (a3)
  {
    if ((a3 & 0xFE) != 2)
      return;
    v7 = *(_QWORD **)(a1 + 32);
    v8 = *(unsigned __int8 *)v7;
    if (v8 >= 2)
    {
      if (v8 == 2)
      {
        v9 = 2;
        goto LABEL_11;
      }
      if (v8 != 3)
      {
        v9 = 0;
        goto LABEL_11;
      }
    }
    v9 = 3;
  }
  else
  {
    if (a4)
      return;
    v7 = *(_QWORD **)(a1 + 32);
    v9 = 1;
  }
LABEL_11:
  v10 = v7[12];
  v11 = v7[11];
  if (v11 >= v10)
  {
    v13 = v7[10];
    v14 = (uint64_t)(v11 - v13) >> 4;
    v15 = v14 + 1;
    if ((unint64_t)(v14 + 1) >> 60)
      abort();
    v16 = v10 - v13;
    if (v16 >> 3 > v15)
      v15 = v16 >> 3;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
      v17 = 0xFFFFFFFFFFFFFFFLL;
    else
      v17 = v15;
    if (v17)
      v18 = (char *)sub_1B17F7824((uint64_t)(v7 + 12), v17);
    else
      v18 = 0;
    v19 = &v18[16 * v14];
    v20 = &v18[16 * v17];
    *(_QWORD *)v19 = a2;
    v19[8] = a5;
    *(_WORD *)(v19 + 9) = 0;
    v19[11] = 0;
    *((_DWORD *)v19 + 3) = v9;
    v12 = v19 + 16;
    v22 = (char *)v7[10];
    v21 = (char *)v7[11];
    if (v21 != v22)
    {
      do
      {
        *((_OWORD *)v19 - 1) = *((_OWORD *)v21 - 1);
        v19 -= 16;
        v21 -= 16;
      }
      while (v21 != v22);
      v21 = (char *)v7[10];
    }
    v7[10] = v19;
    v7[11] = v12;
    v7[12] = v20;
    if (v21)
      operator delete(v21);
  }
  else
  {
    *(_QWORD *)v11 = a2;
    *(_BYTE *)(v11 + 8) = a5;
    *(_WORD *)(v11 + 9) = 0;
    *(_BYTE *)(v11 + 11) = 0;
    v12 = (char *)(v11 + 16);
    *(_DWORD *)(v11 + 12) = v9;
  }
  v7[11] = v12;
}

uint64_t sub_1B1925A20(uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;

  result = sub_1B17A4914(a1[4], a2, a3, a4, a5, a6, a7, a8);
  v10 = a1[5];
  v11 = (_DWORD *)a1[6];
  v12 = *v11;
  *v11 = v12 + 1;
  *(_DWORD *)(v10 + 4 * v12) = result;
  v13 = a1[7];
  *(_DWORD *)(v13 + 208) += result;
  if (result != 4)
    *(_BYTE *)(v13 + 212) = 0;
  return result;
}

uint64_t sub_1B1925A78(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  uint64_t v21;

  v9 = a2;
  result = sub_1B17A4914(*(_QWORD *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  if (result >= 1)
  {
    v15 = result;
    for (i = 0; i != v15; ++i)
    {
      result = sub_1B17A4A74(*(_QWORD *)(a1 + 32), v9, i, *(_QWORD *)(a1 + 40), v11, v12, v13, v14);
      v17 = *(_DWORD *)(a1 + 72) - 1;
      if (v17 >= (int)result)
        v17 = result;
      v18 = *(_QWORD *)(a1 + 48);
      if (*(_BYTE *)v18 == 3)
        v17 = *(_DWORD *)(*(_QWORD *)(v18 + 8) + 4 * v17);
      v19 = *(_QWORD *)(a1 + 56);
      v20 = *(_DWORD **)(a1 + 64);
      v21 = *v20;
      *v20 = v21 + 1;
      *(_DWORD *)(v19 + 4 * v21) = v17;
    }
  }
  return result;
}

void sub_1B1925B14(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFArray *v19;
  CFIndex v20;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  unsigned __int8 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  CFIndex v50;
  uint64_t v51;
  const void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  char *v70;
  const void *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _QWORD *v79;
  size_t v80;
  _DWORD *v81;
  _DWORD *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  CFIndex v101;
  const void *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  char v110;
  uint64_t v111;
  uint64_t i;
  uint64_t v113;
  uint64_t v114;
  uint64_t j;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  uint64_t v124;
  uint64_t v125;
  _QWORD *v126;
  size_t v127;
  char *v128;
  const __CFArray *v129;
  _DWORD *v130;
  CFIndex v131;
  BOOL v132;
  uint64_t v133;
  _QWORD v135[5];
  int v136;
  int v137;
  _OWORD v138[3];
  uint64_t v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t *v145;
  uint64_t v146;
  char v147;

  v9 = a1[5];
  if (!v9)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"topologyInfo");
  if (*(int *)(v9 + 128) <= 0 && *(int *)(v9 + 152) <= 0)
  {
    v10 = a1[2];
    if (v10)
    {
      v11 = a1[1];
      if (v11)
      {
        v19 = sub_1B1874BE0(a2, a2, a3, a4, a5, a6, a7, a8);
        v125 = v11;
        if ((uint64_t)v19 < 1)
        {
          v132 = 0;
        }
        else
        {
          v20 = 0;
          v132 = 1;
          do
          {
            v21 = sub_1B1874C3C(a2, v20, 0, v14, v15, v16, v17, v18);
            v29 = sub_1B17A426C((uint64_t)v21, v22, v23, v24, v25, v26, v27, v28);
            if (sub_1B17A44A0(v29) && sub_1B17A4584((uint64_t)v21) != -1)
              break;
            v132 = ++v20 < (uint64_t)v19;
          }
          while (v19 != (const __CFArray *)v20);
        }
        v126 = (_QWORD *)sub_1B17EE3B4(v10, v12, v13, v14, v15, v16, v17, v18);
        v30 = v125;
        v31 = sub_1B17A47FC(v125);
        v130 = malloc_type_malloc(4 * v31, 0x100004052888210uLL);
        v128 = (char *)malloc_type_malloc(8 * v31, 0x100004052888210uLL);
        if (sub_1B17A47BC(v125) != 1)
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Found crease element with more than 1 channel"), v32, v33, a5, a6, a7, a8, (uint64_t)"CFXMeshElementGetIndicesChannelCount(creasesElement) == 1");
        if (v31 < 1)
        {
          LODWORD(v35) = 0;
        }
        else
        {
          v34 = 0;
          v35 = 0;
          v124 = v31;
          do
          {
            v36 = sub_1B17A4A74(v30, v34, 0, 0, a5, a6, a7, a8);
            v43 = sub_1B17A4A74(v30, v34, 1, 0, v37, v38, v39, v40);
            if (!v132)
              goto LABEL_25;
            v144 = 0;
            v145 = &v144;
            v146 = 0x2000000000;
            v147 = 0;
            v44 = sub_1B1875D94(a2, 0, 0, v42, a5, a6, a7, a8);
            if ((uint64_t)v19 >= 1)
            {
              v50 = 0;
              v51 = v44;
              do
              {
                v52 = sub_1B1874C3C(a2, v50, 0, v45, v46, v47, v48, v49);
                v60 = sub_1B17A426C((uint64_t)v52, v53, v54, v55, v56, v57, v58, v59);
                if (sub_1B17A44A0(v60))
                {
                  v143 = 0;
                  v141 = 0u;
                  v142 = 0u;
                  v140 = 0u;
                  sub_1B17A4804((uint64_t)v52, v51, v61, v45, v46, v47, v48, v49, (uint64_t)&v140);
                  v138[0] = v140;
                  v138[1] = v141;
                  v138[2] = v142;
                  v139 = v143;
                  v135[0] = MEMORY[0x1E0C809B0];
                  v135[1] = 0x40000000;
                  v135[2] = sub_1B1925FBC;
                  v135[3] = &unk_1E63D9788;
                  v136 = v36;
                  v137 = v43;
                  v135[4] = &v144;
                  sub_1B17A5F50((uint64_t)v138, (uint64_t)v135, v62, v63, v64, v65, v66, v67);
                }
                ++v50;
              }
              while (v19 != (const __CFArray *)v50);
            }
            v68 = *((unsigned __int8 *)v145 + 24);
            _Block_object_dispose(&v144, 8);
            v31 = v124;
            v30 = v125;
            if (v68)
            {
LABEL_25:
              if (*(_BYTE *)v9 == 3)
              {
                v69 = *(_QWORD *)(v9 + 8);
                v36 = *(_DWORD *)(v69 + 4 * v36);
                v43 = *(_DWORD *)(v69 + 4 * v43);
              }
              v70 = &v128[8 * v35];
              *(_DWORD *)v70 = v36;
              *((_DWORD *)v70 + 1) = v43;
              v130[v35++] = *(_DWORD *)sub_1B18F39D4(v126, v34, v41, v42, a5, a6, a7, a8);
            }
            ++v34;
          }
          while (v34 != v31);
        }
        *(_DWORD *)(v9 + 128) = v35;
        *(_QWORD *)(v9 + 136) = v128;
        *(_QWORD *)(v9 + 144) = v130;
      }
    }
    v71 = sub_1B1875540(a2, 7, 0, 0, a5, a6, a7, a8);
    if (v71)
    {
      v79 = (_QWORD *)sub_1B17EE3B4((uint64_t)v71, v72, v73, v74, v75, v76, v77, v78);
      v80 = *(_QWORD *)(v9 + 40) - *(_QWORD *)(v9 + 32);
      v81 = malloc_type_malloc(v80, 0x100004052888210uLL);
      v127 = v80;
      v82 = malloc_type_malloc(v80, 0x100004052888210uLL);
      v88 = sub_1B1875D94(a2, 7, 0, v83, v84, v85, v86, v87);
      v129 = sub_1B1874BE0(a2, v89, v90, v91, v92, v93, v94, v95);
      if ((uint64_t)v129 >= 1)
      {
        v101 = 0;
        do
        {
          v131 = v101;
          v102 = sub_1B1874C3C(a2, v101, 0, v96, v97, v98, v99, v100);
          v110 = sub_1B17A426C((uint64_t)v102, v103, v104, v105, v106, v107, v108, v109);
          if (sub_1B17A44A0(v110))
          {
            v133 = sub_1B17A47FC((uint64_t)v102);
            if (v133 >= 1)
            {
              for (i = 0; i != v133; ++i)
              {
                v113 = sub_1B17A4914((uint64_t)v102, i, v111, v96, v97, v98, v99, v100);
                if (v113 >= 1)
                {
                  v114 = v113;
                  for (j = 0; j != v114; ++j)
                  {
                    v116 = sub_1B17A4A74((uint64_t)v102, i, j, v88, v97, v98, v99, v100);
                    v123 = v116;
                    if (*(_BYTE *)v9 == 3)
                      v123 = *(_DWORD *)(*(_QWORD *)(v9 + 8) + 4 * v116);
                    v81[v123] = *(_DWORD *)sub_1B18F39D4(v79, v116, v117, v118, v119, v120, v121, v122);
                    v82[v123] = v123;
                  }
                }
              }
            }
          }
          v101 = v131 + 1;
        }
        while ((const __CFArray *)(v131 + 1) != v129);
      }
      *(_DWORD *)(v9 + 152) = v127 >> 2;
      *(_QWORD *)(v9 + 160) = v82;
      *(_QWORD *)(v9 + 168) = v81;
    }
  }
}

uint64_t sub_1B1925FBC(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;

  if (a4)
  {
    v4 = 0;
    v5 = *(_DWORD *)(result + 40);
    do
    {
      v6 = *(_DWORD *)(a3 + 4 * v4);
      if (a4 - 1 == v4)
        v7 = 0;
      else
        v7 = v4 + 1;
      v8 = *(_DWORD *)(a3 + 4 * v7);
      if (v5 == v6 && *(_DWORD *)(result + 44) == v8 || v5 == v8 && *(_DWORD *)(result + 44) == v6)
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
      ++v4;
    }
    while (a4 != v4);
  }
  return result;
}

uint64_t sub_1B1926028(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  __int16 v11;
  unsigned __int16 v12;
  __int16 v13;

  v9 = *(_QWORD *)(a1 + 40);
  if (!v9)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"topologyInfo");
  v10 = *(unsigned __int8 *)(a1 + 3);
  if (v10 == 1)
    v11 = 21;
  else
    v11 = 20;
  if (v10 == 2)
    v12 = 22;
  else
    v12 = v11;
  switch(*(_BYTE *)(a1 + 4))
  {
    case 0:
      v12 &= 3u;
      break;
    case 1:
      v12 &= 7u;
      break;
    case 2:
      v13 = 8;
      goto LABEL_14;
    case 3:
      v13 = 12;
LABEL_14:
      v12 = v13 & 0xFFFC | v12 & 3;
      break;
    case 4:
      v12 &= 0x13u;
      break;
    default:
      return sub_1B19260F4((int *)(v9 + 104), ((unint64_t)v12 << 32) | 1, 0);
  }
  return sub_1B19260F4((int *)(v9 + 104), ((unint64_t)v12 << 32) | 1, 0);
}

uint64_t sub_1B19260F4(int *a1, unint64_t a2, char a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = HIDWORD(a2);
  v7 = operator new();
  v8 = sub_1B2222A38(v7, a2, v6);
  if ((sub_1B193C514(v8, a1, a2, a3) & 1) == 0)
  {
    v9 = sub_1B2222B2C(v7);
    MEMORY[0x1B5E22E18](v9, 0x10A0C40D2671FEALL);
    return 0;
  }
  return v7;
}

void sub_1B192618C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unsigned int v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFArray *v29;
  const __CFArray *v30;
  CFIndex v31;
  uint64_t v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD v44[9];
  char v45;
  int v46;
  _QWORD v47[7];

  v11 = *(_QWORD *)(a2 + 40);
  if (!v11)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"topologyInfo");
  v47[0] = MEMORY[0x1E0C809B0];
  v47[1] = 0x40000000;
  v47[2] = sub_1B19263B8;
  v47[3] = &unk_1E63D97A8;
  v47[4] = a2;
  v47[5] = a1;
  sub_1B1873EE0(a3, 0, (uint64_t)v47, a4, a5, a6, a7, a8);
  v19 = *(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48);
  v20 = (v19 >> 5);
  if ((v19 >> 5))
  {
    if (!*(_DWORD *)(v11 + 196))
    {
      v21 = (char *)malloc_type_malloc((v19 >> 1) & 0xFF0, 0x105004037B82EA9uLL);
      v22 = 0;
      do
      {
        v23 = *(unsigned int *)(v11 + 208);
        *(_DWORD *)&v21[v22] = v23;
        *(_QWORD *)&v21[v22 + 8] = malloc_type_malloc(4 * v23, 0x100004052888210uLL);
        v22 += 16;
      }
      while (16 * v20 != v22);
      *(_DWORD *)(v11 + 196) = v20;
      *(_QWORD *)(v11 + 200) = v21;
    }
    v24 = 0;
    if (v20 <= 1)
      v25 = 1;
    else
      v25 = v20;
    v42 = v25;
    v43 = a1;
    do
    {
      v26 = *(_QWORD *)(a1 + 48) + 32 * v24;
      v28 = *(_QWORD *)(v26 + 8);
      v27 = *(_QWORD *)(v26 + 16);
      v46 = 0;
      v29 = sub_1B1874BE0(a3, v12, v13, v14, v15, v16, v17, v18);
      if ((uint64_t)v29 >= 1)
      {
        v30 = v29;
        v31 = 0;
        v32 = (v27 - v28) >> 3;
        do
        {
          v33 = sub_1B1874C3C(a3, v31, 0, v14, v15, v16, v17, v18);
          v41 = sub_1B17A426C((uint64_t)v33, v34, v35, v36, v37, v38, v39, v40);
          if (sub_1B17A44A0(v41))
          {
            v44[0] = MEMORY[0x1E0C809B0];
            v44[1] = 0x40000000;
            v44[2] = sub_1B19266B0;
            v44[3] = &unk_1E63D97C8;
            v44[4] = v33;
            v44[5] = v32;
            v44[6] = v26;
            v44[7] = v11;
            v45 = v24;
            v44[8] = &v46;
            sub_1B17A4700((uint64_t)v33, (uint64_t)v44);
          }
          ++v31;
        }
        while (v30 != (const __CFArray *)v31);
      }
      if (v46 != *(_DWORD *)(v11 + 208))
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Error while building face-varying channel."), v13, v14, v15, v16, v17, v18, (uint64_t)"currentIndex == topologyInfo->totalIndexCount");
      ++v24;
      a1 = v43;
    }
    while (v24 != v42);
  }
  else
  {
    *(_DWORD *)(v11 + 196) = 0;
    *(_QWORD *)(v11 + 200) = 0;
  }
}

void sub_1B19263B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  uint64_t v30;
  void **v31;
  unint64_t v32;
  uint64_t *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  uint64_t *v40;
  char *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  void *__p[2];
  __int128 v46;

  v8 = a5;
  v12 = a3;
  if (!(_DWORD)a3)
    goto LABEL_4;
  if ((a3 & 0xFE) != 2)
  {
    if (a3 != 4)
      return;
LABEL_4:
    if (a4)
      return;
  }
  sub_1B17ED6C4(a2, a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)v13 && sub_1B179E6DC(BYTE4(v13), v13, v14, v15, v16, v17, v18, v19))
  {
    if (v12)
    {
      if ((v12 & 0xFE) != 2 && (v12 != 4 || a4))
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Semantic %d can not be a primvar"), v20, v21, v22, v23, v24, v25, (uint64_t)"CFXSubdivSourceSemanticCanBePrimvar(semantic, inputSet, isCPUSubdiv)");
      v26 = *(_QWORD *)(a1 + 40);
      v28 = *(unsigned __int8 **)(v26 + 48);
      v29 = *(unsigned __int8 **)(v26 + 56);
      v27 = (uint64_t *)(v26 + 48);
      while (v28 != v29)
      {
        if (*v28 == v8)
        {
          v31 = (void **)(v28 + 8);
          goto LABEL_23;
        }
        v28 += 32;
      }
      *(_OWORD *)__p = 0u;
      v46 = 0u;
      sub_1B19265A0(v27, (char *)__p);
      if (__p[1])
      {
        *(void **)&v46 = __p[1];
        operator delete(__p[1]);
      }
      v30 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 56);
      *(_BYTE *)(v30 - 32) = v8;
      v31 = (void **)(v30 - 24);
    }
    else
    {
      if (a4)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Semantic %d can not be a primvar"), v20, v21, v22, v23, v24, v25, (uint64_t)"CFXSubdivSourceSemanticCanBePrimvar(semantic, inputSet, isCPUSubdiv)");
      v31 = *(void ***)(a1 + 40);
    }
LABEL_23:
    v32 = (unint64_t)v31[2];
    v33 = (uint64_t *)v31[1];
    if ((unint64_t)v33 >= v32)
    {
      v35 = ((char *)v33 - (_BYTE *)*v31) >> 3;
      if ((unint64_t)(v35 + 1) >> 61)
        abort();
      v36 = v32 - (_QWORD)*v31;
      v37 = v36 >> 2;
      if (v36 >> 2 <= (unint64_t)(v35 + 1))
        v37 = v35 + 1;
      if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8)
        v38 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v38 = v37;
      if (v38)
        v39 = (char *)sub_1B17F812C((uint64_t)(v31 + 2), v38);
      else
        v39 = 0;
      v40 = (uint64_t *)&v39[8 * v35];
      v41 = &v39[8 * v38];
      *v40 = a2;
      v34 = v40 + 1;
      v43 = (char *)*v31;
      v42 = (char *)v31[1];
      if (v42 != *v31)
      {
        do
        {
          v44 = *((_QWORD *)v42 - 1);
          v42 -= 8;
          *--v40 = v44;
        }
        while (v42 != v43);
        v42 = (char *)*v31;
      }
      *v31 = v40;
      v31[1] = v34;
      v31[2] = v41;
      if (v42)
        operator delete(v42);
    }
    else
    {
      *v33 = a2;
      v34 = v33 + 1;
    }
    v31[1] = v34;
  }
}

uint64_t sub_1B19265A0(uint64_t *a1, char *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _QWORD v16[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (v7 >= v6)
  {
    v9 = (uint64_t)(v7 - *a1) >> 5;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 59)
      abort();
    v11 = v5 - *a1;
    if (v11 >> 4 > v10)
      v10 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    v16[4] = result;
    v13 = (char *)sub_1B1928F6C(result, v12);
    v14 = &v13[32 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[32 * v15];
    *v14 = *a2;
    *((_QWORD *)v14 + 2) = 0;
    *((_QWORD *)v14 + 3) = 0;
    *((_QWORD *)v14 + 1) = 0;
    *(_OWORD *)(v14 + 8) = *(_OWORD *)(a2 + 8);
    *((_QWORD *)v14 + 3) = *((_QWORD *)a2 + 3);
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *((_QWORD *)a2 + 3) = 0;
    v16[2] = v14 + 32;
    sub_1B1928ED8(a1, v16);
    v8 = a1[1];
    result = sub_1B1928FA0((uint64_t)v16);
  }
  else
  {
    *(_BYTE *)v7 = *a2;
    *(_QWORD *)(v7 + 16) = 0;
    *(_QWORD *)(v7 + 24) = 0;
    *(_QWORD *)(v7 + 8) = 0;
    *(_OWORD *)(v7 + 8) = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(v7 + 24) = *((_QWORD *)a2 + 3);
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *((_QWORD *)a2 + 3) = 0;
    v8 = v7 + 32;
  }
  a1[1] = v8;
  return result;
}

uint64_t sub_1B19266B0(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t i;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  _DWORD *v28;

  v9 = a2;
  result = sub_1B17A4914(*(_QWORD *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  if (result >= 1)
  {
    v15 = result;
    v16 = 0;
    v17 = *(_QWORD *)(a1 + 40);
    do
    {
      if (v17)
      {
        for (i = 0; i < v17; ++i)
        {
          v19 = sub_1B17A4A74(*(_QWORD *)(a1 + 32), v9, v16, **(unsigned __int8 **)(a1 + 48), v11, v12, v13, v14);
          result = sub_1B17EDAE0(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 8 * i), v20, v21, v22, v23, v24, v25, v26);
          v27 = result - 1;
          if (v19 < result - 1)
            v27 = v19;
          v28 = *(_DWORD **)(a1 + 64);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 200) + 16 * *(unsigned __int8 *)(a1 + 72) + 8)
                    + 4 * *v28) = v27;
          v17 = *(_QWORD *)(a1 + 40);
        }
      }
      else
      {
        v28 = *(_DWORD **)(a1 + 64);
      }
      ++*v28;
      ++v16;
    }
    while (v16 != v15);
  }
  return result;
}

void sub_1B192678C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;

  v11 = *(uint64_t **)a1;
  v12 = *(uint64_t **)(a1 + 8);
  if (*(uint64_t **)a1 != v12)
  {
    do
    {
      v13 = *v11++;
      sub_1B19268AC(a2, a3, v13, 0, (uint64_t *)(a1 + 72), 0, a7, a8);
    }
    while (v11 != v12);
  }
  v14 = *(uint64_t **)(a1 + 24);
  v15 = *(uint64_t **)(a1 + 32);
  while (v14 != v15)
  {
    v16 = *v14++;
    sub_1B19268AC(a2, a3, v16, 0, (uint64_t *)(a1 + 144), 1, a7, a8);
  }
  v17 = *(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48);
  v18 = (v17 >> 5);
  sub_1B1926A14((uint64_t *)(a1 + 216), v18);
  if ((v17 & 0x1FE0) != 0)
  {
    v21 = 0;
    do
    {
      v22 = *(_QWORD *)(a1 + 48) + 32 * v21;
      v23 = *(uint64_t **)(v22 + 8);
      v24 = *(uint64_t **)(v22 + 16);
      if (v23 != v24)
      {
        v25 = (uint64_t *)(*(_QWORD *)(a1 + 216) + 72 * v21);
        do
        {
          v26 = *v23++;
          sub_1B19268AC(a2, a3, v26, v21, v25, 2, v19, v20);
        }
        while (v23 != v24);
      }
      ++v21;
    }
    while (v21 != v18);
  }
}

void sub_1B19268AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  void *v22[3];
  void *v23;
  void *v24;
  void *__p;
  void *v26;

  v13 = *(_QWORD *)(a1 + 40);
  if (!v13)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, (uint64_t)a5, a6, a7, a8, (uint64_t)"topologyInfo");
  sub_1B17ED6C4(a3, a2, a3, a4, (uint64_t)a5, a6, a7, a8);
  if ((v14 & 0xFE00000000) == 0x1600000000)
    v21 = 4;
  else
    v21 = HIBYTE(v14);
  switch(v21)
  {
    case 4:
      sub_1B19294E8((uint64_t)v22, a3, v13, a2, a4, a6, v19, v20);
      sub_1B192902C(a5 + 6, (uint64_t)v22);
      break;
    case 3:
      sub_1B19294E8((uint64_t)v22, a3, v13, a2, a4, a6, v19, v20);
      sub_1B192902C(a5 + 3, (uint64_t)v22);
      break;
    case 2:
      sub_1B1929148((uint64_t)v22, a3, v13, a2, a4, a6, v19, v20);
      sub_1B192902C(a5, (uint64_t)v22);
      break;
    default:
      sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Can not subdivide primvar data with %d values per component"), v15, v16, v17, v18, v19, v20, HIBYTE(v14));
      return;
  }
  if (__p)
  {
    v26 = __p;
    operator delete(__p);
  }
  if (v23)
  {
    v24 = v23;
    operator delete(v23);
  }
  if (v22[0])
  {
    v22[1] = v22[0];
    operator delete(v22[0]);
  }
}

void sub_1B1926A14(uint64_t *a1, unint64_t a2)
{
  void **v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = (void **)a1[1];
  v4 = 0x8E38E38E38E38E39 * (((uint64_t)v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1B19296A4(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 72 * a2;
    while (v3 != (void **)v7)
    {
      v3 -= 9;
      sub_1B18F86BC(v3);
    }
    a1[1] = v7;
  }
}

void sub_1B1926AA0(uint64_t a1, double a2, float32x4_t a3, float32x4_t a4, uint64_t a5, uint64_t a6, int **a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  float32x4_t v20;
  float32x4_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double v27;
  float32x4_t v28;
  float32x4_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;

  sub_1B1926B34((_QWORD *)(a1 + 72), a6, a7, a2, a3, a4, (uint64_t)a7, a8, a9, a10, a11);
  sub_1B1926B34((_QWORD *)(a1 + 144), a6, a7, v19, v20, v21, v14, v15, v16, v17, v18);
  v30 = *(_DWORD *)(a1 + 48);
  if (((*(_DWORD *)(a1 + 56) - v30) >> 5))
  {
    v31 = 0;
    v32 = 72 * ((*(_DWORD *)(a1 + 56) - v30) >> 5);
    do
    {
      sub_1B1926B34((_QWORD *)(*(_QWORD *)(a1 + 216) + v31), a6, a7, v27, v28, v29, v22, v23, v24, v25, v26);
      v31 += 72;
    }
    while (v32 != v31);
  }
}

void sub_1B1926B34(_QWORD *a1, uint64_t a2, int **a3, double a4, float32x4_t a5, float32x4_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;

  if ((*(_BYTE *)(a2 + 8) & 0x3C) != 0)
  {
    v14 = 0;
    do
    {
      v15 = a1[1] - *a1;
      if (v15)
      {
        v16 = 0;
        v17 = v15 / 112;
        if (v17 <= 1)
          v18 = 1;
        else
          v18 = v17;
        do
        {
          sub_1B19299B8(*a1 + v16, v14 + 1, a3, a2, a8, a9, a10, a11, a4, *(double *)a5.i64);
          v16 += 112;
          --v18;
        }
        while (v18);
      }
      v19 = a1[4] - a1[3];
      if (v19)
      {
        v20 = 0;
        v21 = v19 / 112;
        if (v21 <= 1)
          v22 = 1;
        else
          v22 = v21;
        do
        {
          sub_1B1929B64(a1[3] + v20, v14 + 1, a3, a2, a8, a9, a10, a11, a4, *(double *)a5.i64, a6);
          v20 += 112;
          --v22;
        }
        while (v22);
      }
      v23 = a1[7] - a1[6];
      if (v23)
      {
        v24 = 0;
        v25 = v23 / 112;
        if (v25 <= 1)
          v26 = 1;
        else
          v26 = v25;
        do
        {
          sub_1B1929FF4(a1[6] + v24, v14 + 1, a3, a2, a8, a9, a10, a11, a4, a5);
          v24 += 112;
          --v26;
        }
        while (v26);
      }
      ++v14;
    }
    while (v14 < (((unint64_t)*(unsigned __int8 *)(a2 + 8) >> 2) & 0xF));
  }
}

void sub_1B1926C88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  float32x4_t v36;
  float v37;
  float v38;
  unint64_t v39;
  __int16 v40;
  unint64_t v41;
  int8x16_t v42;
  unsigned __int8 v43;
  int32x2_t v44;
  int32x4_t v45;
  int32x4_t v46;
  unsigned __int16 v47;
  int8x16_t v48;
  int8x16_t v49;
  char *v50;
  int v51;
  char *v52;
  char *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  float32x4_t v70;
  float v71;
  float v72;
  unint64_t v73;
  __int16 v74;
  unint64_t v75;
  int8x16_t v76;
  unsigned __int8 v77;
  int32x2_t v78;
  int32x4_t v79;
  int32x4_t v80;
  unsigned __int16 v81;
  int8x16_t v82;
  int8x16_t v83;
  char *v84;
  int v85;
  char *v86;
  char *v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  char *v91;
  char *v92;
  int v93;
  unint64_t v94;
  unsigned int v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  const __CFArray *v104;
  const __CFArray *v105;
  CFIndex v106;
  uint64_t v107;
  const void *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  char v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  int v126;
  void **v127;
  void **v128;
  int8x16_t v129;
  int8x16_t v130;
  uint64_t v131;
  int8x16_t v132;
  int8x16_t v133;
  _QWORD v134[9];
  char v135;
  int v136;
  _QWORD v137[7];

  v11 = *(_QWORD *)(a2 + 40);
  if (!v11)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"topologyInfo");
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 56) = 0;
  v137[0] = MEMORY[0x1E0C809B0];
  v137[1] = 0x40000000;
  v137[2] = sub_1B1927310;
  v137[3] = &unk_1E63D97E8;
  v137[4] = a2;
  v137[5] = a1;
  v125 = a3;
  sub_1B1873EE0(a3, 0, (uint64_t)v137, a4, a5, a6, a7, a8);
  v119 = *(_QWORD *)(a1 + 8);
  v120 = *(_QWORD *)(a1 + 16);
  v117 = *(_QWORD *)(a1 + 64);
  v118 = *(_QWORD *)(a1 + 72);
  v128 = (void **)(a1 + 32);
  sub_1B1927690((void **)(a1 + 32), (*(_DWORD *)(v11 + 208) * *(_DWORD *)a1));
  v127 = (void **)(a1 + 88);
  sub_1B1927690((void **)(a1 + 88), (*(_DWORD *)(v11 + 208) * *(_DWORD *)(a1 + 56)));
  v19 = *(_QWORD *)(a1 + 112);
  v20 = *(_QWORD *)(a1 + 120);
  while (v19 != v20)
  {
    sub_1B1927690((void **)(v19 + 40), (*(_DWORD *)(v11 + 208) * *(_DWORD *)(v19 + 8)));
    v19 += 64;
  }
  v122 = v11;
  if (*(_DWORD *)(v11 + 104))
  {
    v21 = 0;
    v22 = (_QWORD *)(a1 + 48);
    v23 = (_QWORD *)(a1 + 104);
    if ((unint64_t)((v120 - v119) >> 4) <= 1)
      v24 = 1;
    else
      v24 = (v120 - v119) >> 4;
    if ((unint64_t)((v118 - v117) >> 4) <= 1)
      v25 = 1;
    else
      v25 = (v118 - v117) >> 4;
    v123 = v25;
    v124 = v24;
    do
    {
      v121 = v21;
      v126 = *(_DWORD *)(*(_QWORD *)(v11 + 32) + 4 * v21);
      if (v120 != v119)
      {
        v26 = 0;
        do
        {
          v27 = *(_QWORD *)(a1 + 8) + 16 * v26;
          v28 = *(_DWORD *)(v27 + 4);
          v35 = sub_1B17ED6C4(*(_QWORD *)(v27 + 8), v12, v13, v14, v15, v16, v17, v18);
          v40 = WORD2(v39);
          v41 = HIBYTE(v39);
          if (HIBYTE(v39) >= 5)
            sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Primvar data size is too big (cannot fit %d floats in a float4)"), v29, v30, v31, v32, v33, v34, (uint64_t)"srcContent.componentCount <= 4");
          *(double *)v42.i64 = sub_1B198D4F8(v40, (const float *)(v35 + HIBYTE(v40) * v126), v29, v30, v31, v32, v33, v34, v36, v37, v38);
          if (v28)
          {
            v43 = 0;
            v44.i32[0] = 0;
            v44.i32[1] = v41;
            v45 = vzip1q_s32((int32x4_t)(unint64_t)v44, vdupq_lane_s32(v44, 1));
            v46.i64[0] = v41 | 0x100000000;
            v46.i64[1] = 0x300000002;
            v47 = vmovn_s32(vceqq_s32(v45, v46)).u16[0];
            *(int16x4_t *)v45.i8 = vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)v45, (uint32x4_t)v46));
            v45.i16[0] = v47;
            v48 = (int8x16_t)xmmword_1B2244E20;
            v48.i32[0] = v42.i32[0];
            v42.i32[0] = 0;
            v49 = vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v45.i8), v42, v48);
            v50 = *(char **)(a1 + 40);
            v129 = v49;
            do
            {
              v133 = v49;
              v51 = *(_DWORD *)((unint64_t)&v133 & 0xFFFFFFFFFFFFFFF3 | (4 * (v43 & 3)));
              if ((unint64_t)v50 >= *v22)
              {
                v53 = (char *)*v128;
                v54 = (v50 - (_BYTE *)*v128) >> 2;
                v55 = v54 + 1;
                if ((unint64_t)(v54 + 1) >> 62)
LABEL_84:
                  abort();
                v56 = *v22 - (_QWORD)v53;
                if (v56 >> 1 > v55)
                  v55 = v56 >> 1;
                if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFFCLL)
                  v12 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v12 = v55;
                if (v12)
                {
                  v57 = (char *)sub_1B17F7E58(a1 + 48, v12);
                  v53 = *(char **)(a1 + 32);
                  v50 = *(char **)(a1 + 40);
                }
                else
                {
                  v57 = 0;
                }
                v58 = &v57[4 * v54];
                *(_DWORD *)v58 = v51;
                v52 = v58 + 4;
                while (v50 != v53)
                {
                  v59 = *((_DWORD *)v50 - 1);
                  v50 -= 4;
                  *((_DWORD *)v58 - 1) = v59;
                  v58 -= 4;
                }
                *(_QWORD *)(a1 + 32) = v58;
                *(_QWORD *)(a1 + 40) = v52;
                *(_QWORD *)(a1 + 48) = &v57[4 * v12];
                if (v53)
                  operator delete(v53);
                v49 = v129;
              }
              else
              {
                *(_DWORD *)v50 = v51;
                v52 = v50 + 4;
              }
              *(_QWORD *)(a1 + 40) = v52;
              ++v43;
              v50 = v52;
            }
            while (v28 > v43);
          }
          ++v26;
        }
        while (v26 != v124);
      }
      if (v118 != v117)
      {
        v60 = 0;
        do
        {
          v61 = *(_QWORD *)(a1 + 64) + 16 * v60;
          v62 = *(_DWORD *)(v61 + 4);
          v69 = sub_1B17ED6C4(*(_QWORD *)(v61 + 8), v12, v13, v14, v15, v16, v17, v18);
          v74 = WORD2(v73);
          v75 = HIBYTE(v73);
          if (HIBYTE(v73) >= 5)
            sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Primvar data size is too big (cannot fit %d floats in a float4)"), v63, v64, v65, v66, v67, v68, (uint64_t)"srcContent.componentCount <= 4");
          *(double *)v76.i64 = sub_1B198D4F8(v74, (const float *)(v69 + HIBYTE(v74) * v126), v63, v64, v65, v66, v67, v68, v70, v71, v72);
          if (v62)
          {
            v77 = 0;
            v78.i32[0] = 0;
            v78.i32[1] = v75;
            v79 = vzip1q_s32((int32x4_t)(unint64_t)v78, vdupq_lane_s32(v78, 1));
            v80.i64[0] = v75 | 0x100000000;
            v80.i64[1] = 0x300000002;
            v81 = vmovn_s32(vceqq_s32(v79, v80)).u16[0];
            *(int16x4_t *)v79.i8 = vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)v79, (uint32x4_t)v80));
            v79.i16[0] = v81;
            v82 = (int8x16_t)xmmword_1B2244E20;
            v82.i32[0] = v76.i32[0];
            v76.i32[0] = 0;
            v83 = vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v79.i8), v76, v82);
            v84 = *(char **)(a1 + 96);
            v130 = v83;
            do
            {
              v132 = v83;
              v85 = *(_DWORD *)((unint64_t)&v132 & 0xFFFFFFFFFFFFFFF3 | (4 * (v77 & 3)));
              if ((unint64_t)v84 >= *v23)
              {
                v87 = (char *)*v127;
                v88 = (v84 - (_BYTE *)*v127) >> 2;
                v89 = v88 + 1;
                if ((unint64_t)(v88 + 1) >> 62)
                  goto LABEL_84;
                v90 = *v23 - (_QWORD)v87;
                if (v90 >> 1 > v89)
                  v89 = v90 >> 1;
                if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFFCLL)
                  v12 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v12 = v89;
                if (v12)
                {
                  v91 = (char *)sub_1B17F7E58(a1 + 104, v12);
                  v87 = *(char **)(a1 + 88);
                  v84 = *(char **)(a1 + 96);
                }
                else
                {
                  v91 = 0;
                }
                v92 = &v91[4 * v88];
                *(_DWORD *)v92 = v85;
                v86 = v92 + 4;
                while (v84 != v87)
                {
                  v93 = *((_DWORD *)v84 - 1);
                  v84 -= 4;
                  *((_DWORD *)v92 - 1) = v93;
                  v92 -= 4;
                }
                *(_QWORD *)(a1 + 88) = v92;
                *(_QWORD *)(a1 + 96) = v86;
                *(_QWORD *)(a1 + 104) = &v91[4 * v12];
                if (v87)
                  operator delete(v87);
                v83 = v130;
              }
              else
              {
                *(_DWORD *)v84 = v85;
                v86 = v84 + 4;
              }
              *(_QWORD *)(a1 + 96) = v86;
              ++v77;
              v84 = v86;
            }
            while (v62 > v77);
          }
          ++v60;
        }
        while (v60 != v123);
      }
      v11 = v122;
      v21 = v121 + 1;
    }
    while (v121 + 1 < (unint64_t)*(unsigned int *)(v122 + 104));
  }
  v94 = *(_QWORD *)(a1 + 120) - *(_QWORD *)(a1 + 112);
  v95 = (v94 >> 6);
  if ((v94 >> 6))
  {
    if (!*(_DWORD *)(v11 + 196))
    {
      v96 = (char *)malloc_type_malloc((v94 >> 2) & 0xFF0, 0x105004037B82EA9uLL);
      v97 = 0;
      do
      {
        v98 = *(unsigned int *)(v11 + 208);
        *(_DWORD *)&v96[v97] = v98;
        *(_QWORD *)&v96[v97 + 8] = malloc_type_malloc(4 * v98, 0x100004052888210uLL);
        v97 += 16;
      }
      while (16 * v95 != v97);
      *(_DWORD *)(v11 + 196) = v95;
      *(_QWORD *)(v11 + 200) = v96;
    }
    v99 = 0;
    if (v95 <= 1)
      v100 = 1;
    else
      v100 = v95;
    v131 = v100;
    do
    {
      v101 = *(_QWORD *)(a1 + 112) + (v99 << 6);
      v103 = *(_QWORD *)(v101 + 16);
      v102 = *(_QWORD *)(v101 + 24);
      v136 = 0;
      v104 = sub_1B1874BE0(v125, v12, v13, v14, v15, v16, v17, v18);
      if ((uint64_t)v104 >= 1)
      {
        v105 = v104;
        v106 = 0;
        v107 = (v102 - v103) >> 4;
        do
        {
          v108 = sub_1B1874C3C(v125, v106, 0, v14, v15, v16, v17, v18);
          v116 = sub_1B17A426C((uint64_t)v108, v109, v110, v111, v112, v113, v114, v115);
          if (sub_1B17A44A0(v116))
          {
            v134[0] = MEMORY[0x1E0C809B0];
            v134[1] = 0x40000000;
            v134[2] = sub_1B1927720;
            v134[3] = &unk_1E63D9808;
            v134[4] = v108;
            v134[5] = v107;
            v134[6] = v101;
            v134[7] = v122;
            v135 = v99;
            v134[8] = &v136;
            sub_1B17A4700((uint64_t)v108, (uint64_t)v134);
          }
          ++v106;
        }
        while (v105 != (const __CFArray *)v106);
      }
      if (v136 != *(_DWORD *)(v122 + 208))
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Error while building face-varying channel."), v13, v14, v15, v16, v17, v18, (uint64_t)"overallVertexIndex == topologyInfo->totalIndexCount");
      ++v99;
    }
    while (v99 != v131);
  }
  else
  {
    *(_DWORD *)(v11 + 196) = 0;
    *(_QWORD *)(v11 + 200) = 0;
  }
}

unint64_t sub_1B1927310(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const __CFString *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *i;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  v9 = a3;
  v11 = result;
  if ((_DWORD)a3)
  {
    if ((a3 & 0xFFFFFFFE) != 2)
      return result;
  }
  else if (a4)
  {
    return result;
  }
  result = sub_1B17ED6C4(a2, a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)v12)
  {
    result = sub_1B179E6DC(BYTE4(v12), v12, v13, v14, v15, v16, v17, v18);
    if ((_DWORD)result)
    {
      if (v9 == 3 || v9 == 2)
      {
        v25 = *(_QWORD *)(v11 + 32);
        goto LABEL_15;
      }
      if (v9)
      {
        v26 = sub_1B17ED08C(v9);
        sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Invalid GPU primvar semantic '%@'"), v27, v28, v29, v30, v31, v32, (uint64_t)v26);
        v25 = *(_QWORD *)(v11 + 32);
      }
      else
      {
        v25 = *(_QWORD *)(v11 + 32);
        if (!a4)
        {
LABEL_15:
          v33 = *(_QWORD *)(v25 + 40);
          if (!v33)
            sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v19, v20, v21, v22, v23, v24, (uint64_t)"topologyInfo");
          for (i = *(_QWORD **)(v33 + 80); i != *(_QWORD **)(v33 + 88); i += 2)
          {
            if (*i == a2)
              __asm { BR              X10 }
          }
          sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Could not find mesh source indexing info for source %p"), v19, v20, v21, v22, v23, v24, a2);
          sub_1B2227C28(v35, v36, v37, v38, v39, v40, v41, v42);
        }
      }
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Semantic %d can not be a primvar"), v19, v20, v21, v22, v23, v24, (uint64_t)"CFXSubdivSourceSemanticCanBePrimvar(semantic, inputSet, isCPUSubdiv)");
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t sub_1B19275C4(uint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t result;

  v3 = a1[1];
  if (v3 >= a1[2])
  {
    result = sub_1B19365D0(a1, (char *)a2);
  }
  else
  {
    *(_BYTE *)v3 = *(_BYTE *)a2;
    *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
    *(_QWORD *)(v3 + 24) = 0;
    *(_QWORD *)(v3 + 32) = 0;
    *(_QWORD *)(v3 + 16) = 0;
    *(_OWORD *)(v3 + 16) = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(v3 + 32) = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(v3 + 40) = 0;
    *(_QWORD *)(v3 + 48) = 0;
    *(_QWORD *)(v3 + 56) = 0;
    *(_OWORD *)(v3 + 40) = *(_OWORD *)(a2 + 40);
    *(_QWORD *)(v3 + 56) = *(_QWORD *)(a2 + 56);
    *(_QWORD *)(a2 + 40) = 0;
    *(_QWORD *)(a2 + 48) = 0;
    *(_QWORD *)(a2 + 56) = 0;
    result = v3 + 64;
  }
  a1[1] = result;
  return result;
}

_QWORD *sub_1B1927650(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1B1927690(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 2)
  {
    if (a2 >> 62)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)sub_1B17F7E58(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = &v6[4 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void sub_1B1927720(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t i;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  float32x4_t v43;
  float v44;
  float v45;
  unint64_t v46;
  __int16 v47;
  unint64_t v48;
  int8x16_t v49;
  unsigned __int8 v50;
  int32x2_t v51;
  int32x4_t v52;
  int32x4_t v53;
  unsigned __int16 v54;
  int8x16_t v55;
  int8x16_t v56;
  _QWORD *v57;
  int v58;
  char *v59;
  unint64_t v60;
  _DWORD *v61;
  char *v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  char *v67;
  char *v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  int8x16_t v72;
  int8x16_t v73;

  v71 = a2;
  v70 = sub_1B17A4914(*(_QWORD *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  if (v70 >= 1)
  {
    v13 = 0;
    v14 = *(_QWORD *)(a1 + 40);
    do
    {
      if (v14)
      {
        for (i = 0; i < v14; ++i)
        {
          v16 = sub_1B17A4A74(*(_QWORD *)(a1 + 32), v71, v13, **(unsigned __int8 **)(a1 + 48), v9, v10, v11, v12);
          v24 = sub_1B17EDAE0(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) + 16 * i + 8), v17, v18, v19, v20, v21, v22, v23);
          v32 = *(_QWORD *)(a1 + 48);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 200) + 16 * *(unsigned __int8 *)(a1 + 72) + 8)
                    + 4 * **(unsigned int **)(a1 + 64)) = **(_DWORD **)(a1 + 64);
          if (v16 >= v24 - 1)
            v33 = v24 - 1;
          else
            v33 = v16;
          v34 = *(_QWORD *)(v32 + 16) + 16 * i;
          v35 = *(_DWORD *)(v34 + 4);
          v42 = sub_1B17ED6C4(*(_QWORD *)(v34 + 8), v25, v26, v27, v28, v29, v30, v31);
          v47 = WORD2(v46);
          v48 = HIBYTE(v46);
          if (HIBYTE(v46) >= 5)
            sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Primvar data size is too big (cannot fit %d floats in a float4)"), v36, v37, v38, v39, v40, v41, (uint64_t)"srcContent.componentCount <= 4");
          *(double *)v49.i64 = sub_1B198D4F8(v47, (const float *)(v42 + HIBYTE(v47) * v33), v36, v37, v38, v39, v40, v41, v43, v44, v45);
          if (v35)
          {
            v50 = 0;
            v51.i32[0] = 0;
            v51.i32[1] = v48;
            v52.i64[0] = v48 | 0x100000000;
            v53 = vzip1q_s32((int32x4_t)(unint64_t)v51, vdupq_lane_s32(v51, 1));
            v52.i64[1] = 0x300000002;
            v54 = vmovn_s32(vceqq_s32(v53, v52)).u16[0];
            *(int16x4_t *)v53.i8 = vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)v53, (uint32x4_t)v52));
            v53.i16[0] = v54;
            v55 = (int8x16_t)xmmword_1B2244E20;
            v55.i32[0] = v49.i32[0];
            v49.i32[0] = 0;
            v56 = vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v53.i8), v49, v55);
            v72 = v56;
            do
            {
              v57 = *(_QWORD **)(a1 + 48);
              v73 = v56;
              v58 = *(_DWORD *)((unint64_t)&v73 & 0xFFFFFFFFFFFFFFF3 | (4 * (v50 & 3)));
              v59 = (char *)v57[6];
              v60 = v57[7];
              if ((unint64_t)v59 >= v60)
              {
                v62 = (char *)v57[5];
                v63 = (v59 - v62) >> 2;
                v64 = v63 + 1;
                if ((unint64_t)(v63 + 1) >> 62)
                  abort();
                v65 = v60 - (_QWORD)v62;
                if (v65 >> 1 > v64)
                  v64 = v65 >> 1;
                if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFFCLL)
                  v66 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v66 = v64;
                if (v66)
                {
                  v67 = (char *)sub_1B17F7E58((uint64_t)(v57 + 7), v66);
                  v62 = (char *)v57[5];
                  v59 = (char *)v57[6];
                }
                else
                {
                  v67 = 0;
                }
                v68 = &v67[4 * v63];
                *(_DWORD *)v68 = v58;
                v61 = v68 + 4;
                while (v59 != v62)
                {
                  v69 = *((_DWORD *)v59 - 1);
                  v59 -= 4;
                  *((_DWORD *)v68 - 1) = v69;
                  v68 -= 4;
                }
                v57[5] = v68;
                v57[6] = v61;
                v57[7] = &v67[4 * v66];
                if (v62)
                  operator delete(v62);
                v56 = v72;
              }
              else
              {
                *(_DWORD *)v59 = v58;
                v61 = v59 + 4;
              }
              v57[6] = v61;
              ++v50;
            }
            while (v35 > v50);
          }
          v14 = *(_QWORD *)(a1 + 40);
        }
      }
      ++**(_DWORD **)(a1 + 64);
      ++v13;
    }
    while (v13 != v70);
  }
}

uint64_t *sub_1B19279C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  int v17;
  const void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  int v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t *v50;
  unsigned int v51;
  uint64_t v52;
  unsigned __int8 i;
  uint64_t v54;
  unsigned int v55;
  char **v56;
  char *v57;
  char **v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  uint64_t v70;
  char *v71;
  char *v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  _QWORD *v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  char *v83;
  char *v84;
  char *v85;
  char *__p;
  char *v88;
  char *v89;

  __p = 0;
  v88 = 0;
  v89 = 0;
  v15 = sub_1B1874BE0(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v15)
  {
    v16 = 0;
    v17 = 0;
    do
    {
      v18 = sub_1B1874C3C(a2, v16, 0, v10, v11, v12, v13, v14);
      v26 = sub_1B17A426C((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25);
      if (sub_1B17A44A0(v26))
      {
        v17 += sub_1B17A46C4((uint64_t)v18);
        v27 = v88;
        if (v88 >= v89)
        {
          v29 = __p;
          v30 = (v88 - __p) >> 2;
          v31 = v30 + 1;
          if ((unint64_t)(v30 + 1) >> 62)
LABEL_73:
            abort();
          v32 = v89 - __p;
          if ((v89 - __p) >> 1 > v31)
            v31 = v32 >> 1;
          if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL)
            v33 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v33 = v31;
          if (v33)
          {
            v34 = (char *)sub_1B17F7E58((uint64_t)&v89, v33);
            v29 = __p;
            v27 = v88;
          }
          else
          {
            v34 = 0;
          }
          v35 = &v34[4 * v30];
          *(_DWORD *)v35 = v17;
          v28 = v35 + 4;
          while (v27 != v29)
          {
            v36 = *((_DWORD *)v27 - 1);
            v27 -= 4;
            *((_DWORD *)v35 - 1) = v36;
            v35 -= 4;
          }
          __p = v35;
          v89 = &v34[4 * v33];
          if (v29)
            operator delete(v29);
        }
        else
        {
          *(_DWORD *)v88 = v17;
          v28 = v88 + 4;
        }
        v88 = v28;
      }
      ++v16;
    }
    while (v16 != v15);
    v37 = (v88 - __p) >> 2;
  }
  else
  {
    LODWORD(v37) = 0;
  }
  v38 = (uint64_t *)operator new();
  sub_1B1936854(v38, v37);
  v45 = **(unsigned int **)(*(_QWORD *)(a1 + 88) + 24 * (((unint64_t)*(unsigned __int8 *)(a1 + 8) >> 2) & 0xF));
  if ((_DWORD)v45)
  {
    v46 = 0;
    while (1)
    {
      v47 = *(unsigned __int8 *)(a1 + 8);
      if ((v47 & 0x3C) != 0)
      {
        v48 = (v47 >> 2) & 0xF;
        v49 = v48 + 1;
        v50 = (uint64_t *)(*(_QWORD *)(a1 + 88) + 24 * v48 + 8);
        v51 = v46;
        do
        {
          v52 = *v50;
          v50 -= 3;
          v51 = *(_DWORD *)(*(_QWORD *)(v52 + 264) + 4 * (int)v51);
          --v49;
        }
        while (v49 > 1);
      }
      else
      {
        v51 = v46;
      }
      for (i = 0; v37 > i; ++i)
      {
        if (v51 < *(_DWORD *)&__p[4 * i])
          break;
      }
      if (v37 <= i)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Internal consistency error"), v39, v40, v41, v42, v43, v44, (uint64_t)"subdividedElementIndexForFace < subdividedElementCount");
      v54 = *v38;
      if (0xAAAAAAAAAAAAAAABLL * ((v38[1] - *v38) >> 3) <= i)
        goto LABEL_73;
      v55 = i;
      v56 = (char **)(v54 + 24 * i);
      v58 = v56 + 1;
      v57 = v56[1];
      v59 = *v56;
      v60 = (v57 - *v56) >> 4;
      if (v57 == *v56)
        break;
      v61 = *((_QWORD *)v57 - 1);
      if (v46 != (_DWORD)v61 + *((_DWORD *)v57 - 4))
      {
        v76 = v54 + 24 * v55;
        v79 = *(_QWORD *)(v76 + 16);
        v78 = (_QWORD *)(v76 + 16);
        v77 = v79;
        if ((unint64_t)v57 < v79)
        {
LABEL_53:
          *(_QWORD *)v57 = v46;
          *((_QWORD *)v57 + 1) = 1;
          v75 = v57 + 16;
          goto LABEL_68;
        }
        v80 = v60 + 1;
        if ((unint64_t)(v60 + 1) >> 60)
          goto LABEL_73;
        v81 = v77 - (_QWORD)v59;
        if (v81 >> 3 > v80)
          v80 = v81 >> 3;
        if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFF0)
          v82 = 0xFFFFFFFFFFFFFFFLL;
        else
          v82 = v80;
        if (v82)
        {
          v83 = (char *)sub_1B17F7824((uint64_t)v78, v82);
          v57 = *v58;
          v59 = *v56;
        }
        else
        {
          v83 = 0;
        }
        v84 = &v83[16 * v60];
        *(_QWORD *)v84 = v46;
        *((_QWORD *)v84 + 1) = 1;
        v85 = v84;
        if (v57 != v59)
        {
          do
          {
            *((_OWORD *)v85 - 1) = *((_OWORD *)v57 - 1);
            v85 -= 16;
            v57 -= 16;
          }
          while (v57 != v59);
          v59 = *v56;
        }
        *v56 = v85;
        v75 = v84 + 16;
        *v58 = v84 + 16;
        *v78 = &v83[16 * v82];
        if (!v59)
          goto LABEL_68;
        goto LABEL_67;
      }
      *((_QWORD *)v57 - 1) = v61 + 1;
LABEL_69:
      if (++v46 == v45)
        goto LABEL_70;
    }
    v62 = v54 + 24 * v55;
    v65 = *(_QWORD *)(v62 + 16);
    v64 = (_QWORD *)(v62 + 16);
    v63 = v65;
    if ((unint64_t)v57 < v65)
      goto LABEL_53;
    v66 = v63 - (_QWORD)v59;
    if (v66 >> 3 <= (unint64_t)(v60 + 1))
      v67 = v60 + 1;
    else
      v67 = v66 >> 3;
    if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF0)
      v68 = 0xFFFFFFFFFFFFFFFLL;
    else
      v68 = v67;
    v69 = (char *)sub_1B17F7824((uint64_t)v64, v68);
    v71 = &v69[16 * v60];
    *(_QWORD *)v71 = v46;
    *((_QWORD *)v71 + 1) = 1;
    v72 = *v58;
    v73 = *v56;
    v74 = v71;
    if (*v58 != *v56)
    {
      do
      {
        *((_OWORD *)v74 - 1) = *((_OWORD *)v72 - 1);
        v74 -= 16;
        v72 -= 16;
      }
      while (v72 != v73);
      v72 = *v56;
    }
    *v56 = v74;
    v75 = v71 + 16;
    *v58 = v71 + 16;
    *v64 = &v69[16 * v70];
    if (!v72)
    {
LABEL_68:
      *v58 = v75;
      goto LABEL_69;
    }
    v59 = v72;
LABEL_67:
    operator delete(v59);
    goto LABEL_68;
  }
LABEL_70:
  if (__p)
    operator delete(__p);
  return v38;
}

_QWORD *sub_1B1927DE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  uint64_t v17;
  const void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  unsigned __int8 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  int v52;
  char *v53;
  unint64_t v54;
  unint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int8 v68;
  unsigned int v69;
  unsigned __int8 v70;
  uint64_t v71;
  uint64_t *v72;
  char **v73;
  char *v74;
  char **v75;
  char *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  _QWORD *v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  char *v86;
  uint64_t v87;
  char *v88;
  char *v89;
  char *v90;
  char *v91;
  char *v92;
  uint64_t v93;
  unint64_t v94;
  _QWORD *v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  char *v100;
  char *v101;
  char *v102;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  uint64_t v109[3];
  __int128 v110;
  __int128 v111;
  __int128 v112;
  uint64_t v113;
  _QWORD v114[5];
  _OWORD v115[3];
  uint64_t v116;
  char *v117;
  char *v118;
  char *v119;
  uint64_t v120;
  uint64_t *v121;
  uint64_t v122;
  int v123;
  void **v124;

  v120 = 0;
  v121 = &v120;
  v122 = 0x2000000000;
  v123 = 0;
  v117 = 0;
  v118 = 0;
  v119 = 0;
  v10 = sub_1B1874BE0(a3, a2, a3, a4, a5, a6, a7, a8);
  if ((v10 & 0xFE) == 0)
  {
    v56 = 0;
    goto LABEL_81;
  }
  v16 = 0;
  v17 = v10;
  do
  {
    v18 = sub_1B1874C3C(a3, v16, 0, v11, v12, v13, v14, v15);
    v26 = sub_1B17A426C((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25);
    if (!sub_1B17A44A0(v26))
      goto LABEL_27;
    if (v26 >= 2)
    {
      if (v26 == 4)
      {
        v29 = sub_1B1875D94(a3, 0, 0, v11, v12, v13, v14, v15);
        v113 = 0;
        v111 = 0u;
        v112 = 0u;
        v110 = 0u;
        sub_1B17A4804((uint64_t)v18, v29, v30, v31, v32, v33, v34, v35, (uint64_t)&v110);
        v115[0] = v110;
        v115[1] = v111;
        v115[2] = v112;
        v116 = v113;
        v114[0] = MEMORY[0x1E0C809B0];
        v114[1] = 0x40000000;
        v114[2] = sub_1B1928390;
        v114[3] = &unk_1E63D9830;
        v114[4] = &v120;
        sub_1B17A5F50((uint64_t)v115, (uint64_t)v114, v36, v37, v38, v39, v40, v41);
        goto LABEL_10;
      }
      if (v26 != 5)
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Internal consistency error - Unexpected element type"), v27, v11, v12, v13, v14, v15, v104);
        goto LABEL_10;
      }
    }
    v28 = sub_1B17A46C4((uint64_t)v18);
    *((_DWORD *)v121 + 6) += 3 * v28;
LABEL_10:
    v42 = v121;
    v43 = v118;
    if (v118 >= v119)
    {
      v45 = v117;
      v46 = (v118 - v117) >> 2;
      v47 = v46 + 1;
      if ((unint64_t)(v46 + 1) >> 62)
LABEL_82:
        abort();
      v48 = v119 - v117;
      if ((v119 - v117) >> 1 > v47)
        v47 = v48 >> 1;
      if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFFCLL)
        v49 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v49 = v47;
      if (v49)
      {
        v50 = (char *)sub_1B17F7E58((uint64_t)&v119, v49);
        v45 = v117;
        v43 = v118;
      }
      else
      {
        v50 = 0;
      }
      v51 = &v50[4 * v46];
      *(_DWORD *)v51 = *((_DWORD *)v42 + 6);
      v44 = v51 + 4;
      while (v43 != v45)
      {
        v52 = *((_DWORD *)v43 - 1);
        v43 -= 4;
        *((_DWORD *)v51 - 1) = v52;
        v51 -= 4;
      }
      v117 = v51;
      v118 = v44;
      v119 = &v50[4 * v49];
      if (v45)
        operator delete(v45);
    }
    else
    {
      *(_DWORD *)v118 = *((_DWORD *)v121 + 6);
      v44 = v43 + 4;
    }
    v118 = v44;
LABEL_27:
    ++v16;
  }
  while (v16 != v17);
  v53 = v117;
  v54 = v118 - v117;
  v55 = (unint64_t)(v118 - v117) >> 2;
  if (v55 >= 2)
  {
    sub_1B220E31C(&v110, a2);
    v106 = v110;
    v107 = v113;
    v57 = *((_QWORD *)&v110 + 1) - v110;
    v105 = ((*((_QWORD *)&v110 + 1) - (_QWORD)v110) >> 4);
    sub_1B1936854(v109, v105);
    v56 = (_QWORD *)operator new();
    sub_1B193691C(v56, (v54 >> 2), v109);
    if ((v57 & 0xFFFFFFFF0) == 0)
    {
LABEL_79:
      v124 = (void **)v109;
      sub_1B17F7664(&v124);
      sub_1B1936A0C((uint64_t)&v110);
      v53 = v117;
      if (v117)
        goto LABEL_80;
      goto LABEL_81;
    }
    v64 = 0;
    while (1)
    {
      v65 = v106 + 16 * v64;
      v66 = *(unsigned int *)(v65 + 4);
      if ((_DWORD)v66)
        break;
LABEL_78:
      if (++v64 == v105)
        goto LABEL_79;
    }
    v67 = 0;
    v108 = *(_DWORD *)(v65 + 12);
    while (1)
    {
      v68 = 0;
      while ((*(_DWORD *)(v107 + 12 * (v108 + v67)) & 0xFFFFFFFu) >= *(_DWORD *)&v117[4 * v68])
      {
        v69 = ++v68;
        if (v68 >= v55)
          goto LABEL_41;
      }
      v69 = v68;
LABEL_41:
      v70 = v68;
      if (v69 >= v55)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Internal consistency error"), v58, v59, v60, v61, v62, v63, (uint64_t)"subdividedElementIndexForFace < subdividedElementCount");
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v56[1] - *v56) >> 3) <= v70)
        goto LABEL_82;
      v72 = (uint64_t *)(*v56 + 24 * v70);
      v71 = *v72;
      if (0xAAAAAAAAAAAAAAABLL * ((v72[1] - *v72) >> 3) <= v64)
        goto LABEL_82;
      v73 = (char **)(v71 + 24 * v64);
      v75 = v73 + 1;
      v74 = v73[1];
      v76 = *v73;
      v77 = (v74 - *v73) >> 4;
      if (v74 == *v73)
        break;
      v78 = *((_QWORD *)v74 - 1);
      if (v67 != (_DWORD)v78 + *((_DWORD *)v74 - 4))
      {
        v93 = v71 + 24 * v64;
        v96 = *(_QWORD *)(v93 + 16);
        v95 = (_QWORD *)(v93 + 16);
        v94 = v96;
        if ((unint64_t)v74 < v96)
        {
LABEL_61:
          *(_QWORD *)v74 = v67;
          *((_QWORD *)v74 + 1) = 1;
          v92 = v74 + 16;
          goto LABEL_76;
        }
        v97 = v77 + 1;
        if ((unint64_t)(v77 + 1) >> 60)
          goto LABEL_82;
        v98 = v94 - (_QWORD)v76;
        if (v98 >> 3 > v97)
          v97 = v98 >> 3;
        if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFF0)
          v99 = 0xFFFFFFFFFFFFFFFLL;
        else
          v99 = v97;
        if (v99)
        {
          v100 = (char *)sub_1B17F7824((uint64_t)v95, v99);
          v74 = *v75;
          v76 = *v73;
        }
        else
        {
          v100 = 0;
        }
        v101 = &v100[16 * v77];
        *(_QWORD *)v101 = v67;
        *((_QWORD *)v101 + 1) = 1;
        v102 = v101;
        if (v74 != v76)
        {
          do
          {
            *((_OWORD *)v102 - 1) = *((_OWORD *)v74 - 1);
            v102 -= 16;
            v74 -= 16;
          }
          while (v74 != v76);
          v76 = *v73;
        }
        *v73 = v102;
        v92 = v101 + 16;
        *v75 = v101 + 16;
        *v95 = &v100[16 * v99];
        if (!v76)
          goto LABEL_76;
        goto LABEL_75;
      }
      *((_QWORD *)v74 - 1) = v78 + 1;
LABEL_77:
      if (++v67 == v66)
        goto LABEL_78;
    }
    v79 = v71 + 24 * v64;
    v82 = *(_QWORD *)(v79 + 16);
    v81 = (_QWORD *)(v79 + 16);
    v80 = v82;
    if ((unint64_t)v74 < v82)
      goto LABEL_61;
    v83 = v80 - (_QWORD)v76;
    if (v83 >> 3 <= (unint64_t)(v77 + 1))
      v84 = v77 + 1;
    else
      v84 = v83 >> 3;
    if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF0)
      v85 = 0xFFFFFFFFFFFFFFFLL;
    else
      v85 = v84;
    v86 = (char *)sub_1B17F7824((uint64_t)v81, v85);
    v88 = &v86[16 * v77];
    *(_QWORD *)v88 = v67;
    *((_QWORD *)v88 + 1) = 1;
    v89 = *v75;
    v90 = *v73;
    v91 = v88;
    if (*v75 != *v73)
    {
      do
      {
        *((_OWORD *)v91 - 1) = *((_OWORD *)v89 - 1);
        v91 -= 16;
        v89 -= 16;
      }
      while (v89 != v90);
      v89 = *v73;
    }
    *v73 = v91;
    v92 = v88 + 16;
    *v75 = v88 + 16;
    *v81 = &v86[16 * v87];
    if (!v89)
    {
LABEL_76:
      *v75 = v92;
      goto LABEL_77;
    }
    v76 = v89;
LABEL_75:
    operator delete(v76);
    goto LABEL_76;
  }
  v56 = 0;
  if (!v117)
    goto LABEL_81;
LABEL_80:
  v118 = v53;
  operator delete(v53);
LABEL_81:
  _Block_object_dispose(&v120, 8);
  return v56;
}

uint64_t sub_1B1928390(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4;

  if (a4 == 4)
    v4 = 1;
  else
    v4 = a4;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) += v4;
  return result;
}

uint64_t sub_1B19283B0(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  CFIndex v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __CFArray *Mutable;
  uint64_t v31;
  uint64_t v32;
  _BYTE *v33;
  const void **v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  const void **v45;
  size_t v46;
  unint64_t v47;
  unint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void **v56;
  void **v57;
  int v58;
  void **v59;
  unint64_t v60;
  unsigned int v61;
  char *v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  _DWORD *v68;
  int v69;
  unsigned int v70;
  int *v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int i;
  unsigned int j;
  int *v78;
  int v79;
  int v80;
  int v81;
  int v82;
  _DWORD *v83;
  int v84;
  unint64_t v85;
  CFDataRef v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  const void **v90;
  const __CFArray *v91;
  const void *v92;
  uint64_t *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v101;
  _BYTE *v102;
  int v103;
  unint64_t v104;
  int v105;
  const void **v106;
  unint64_t v107;
  __CFArray *v108;
  CFAllocatorRef v109;
  uint64_t *v110;
  unint64_t v111;
  _DWORD *v112;
  char *v113;
  uint64_t v114;
  void **v115;
  void **v116;
  _BYTE *v117;
  _BYTE *v118;
  uint64_t v119;
  uint64_t v120;

  v120 = *MEMORY[0x1E0C80C00];
  v13 = (uint64_t *)(*(_QWORD *)(a3 + 88) + 24 * (((unint64_t)*(unsigned __int8 *)(a3 + 8) >> 2) & 0xF));
  v117 = 0;
  v118 = 0;
  v119 = 0;
  sub_1B192894C(a2, a4, v13, a1 + 9, 0, (void **)&v117, a7, a8);
  sub_1B192894C(a2, a4, v13, a1 + 18, 0, (void **)&v117, v14, v15);
  v20 = (_QWORD *)a1[27];
  v21 = (_QWORD *)a1[28];
  while (v20 != v21)
  {
    sub_1B192894C(a2, a4, v13, v20, 1, (void **)&v117, v18, v19);
    v20 += 9;
  }
  v101 = (uint64_t)&v101;
  v22 = (-85 * (((_DWORD)v118 - (_DWORD)v117) >> 3));
  MEMORY[0x1E0C80A78](v16, v17);
  v102 = (char *)&v101 - v23;
  v109 = (CFAllocatorRef)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable(v109, v22, MEMORY[0x1E0C9B378]);
  if (v22)
  {
    v31 = 0;
    v32 = 24 * v22;
    v33 = v102;
    do
    {
      v34 = (const void **)&v117[v31];
      if (v117[v31])
        v35 = v117[v31 + 1] + 1;
      else
        v35 = 0;
      *v33++ = v35;
      CFArrayAppendValue(Mutable, v34[2]);
      CFRelease(v34[2]);
      v31 += 24;
    }
    while (v32 != v31);
  }
  v37 = a1[6];
  v36 = a1[7];
  v38 = sub_1B19279C4(a3, a5, v24, v25, v26, v27, v28, v29);
  v40 = *v38;
  v39 = v38[1];
  v110 = v38;
  v41 = (-85 * ((v39 - v40) >> 3));
  MEMORY[0x1E0C80A78](v38, v42);
  v45 = (const void **)((char *)&v101 - v44);
  if (v43 >= 0x200)
    v46 = 512;
  else
    v46 = v43;
  bzero((char *)&v101 - v44, v46);
  if (v41)
  {
    v47 = 0;
    v48 = (unint64_t)(v36 - v37) >> 5;
    v49 = v48;
    v105 = v48 + 1;
    v104 = 3 * (v48 + 1);
    v103 = 6 * (v48 + 1);
    v107 = v41;
    v108 = Mutable;
    v106 = v45;
    do
    {
      if (0xAAAAAAAAAAAAAAABLL * ((v110[1] - *v110) >> 3) <= v47)
        abort();
      sub_1B193C35C(&v115, *v110 + 24 * v47);
      v57 = v115;
      v56 = v116;
      if (v115 == v116)
      {
        v58 = 0;
      }
      else
      {
        v58 = 0;
        v59 = v115;
        do
        {
          v58 += *((_DWORD *)v59 + 2);
          v59 += 2;
        }
        while (v59 != v116);
      }
      v60 = (v103 * v58);
      v112 = 0;
      v113 = 0;
      v114 = 0;
      v111 = v60;
      if ((_DWORD)v60)
      {
        v61 = v103 * v58;
        sub_1B183C0A8(&v112, v60);
        v62 = v113;
        bzero(v113, 4 * v61);
        v113 = &v62[4 * v61];
        v57 = v115;
        v56 = v116;
      }
      if (v57 == v56)
      {
        v63 = 0;
      }
      else
      {
        v63 = 0;
        do
        {
          v64 = *(_DWORD *)v57;
          v65 = *((_DWORD *)v57 + 2) + *(_DWORD *)v57 - 1;
          if (v65 >= *(_DWORD *)v57)
          {
            v66 = *(_QWORD *)(*v13 + 24);
            v67 = *(_QWORD *)(*v13 + 48);
            v68 = v112;
            v69 = (2 * v64) | 1;
            v70 = *(_DWORD *)v57;
            do
            {
              v71 = (int *)(v67 + 4 * *(int *)(v66 + 4 * v69));
              v72 = *v71;
              v73 = v71[1];
              v74 = v71[2];
              LODWORD(v71) = v71[3];
              v68[v63] = v72;
              v68[v63 + 1] = v73;
              v68[v63 + 2] = v74;
              v68[v63 + 3] = v72;
              v75 = v63 + 5;
              v68[v63 + 4] = v74;
              v63 += 6;
              v68[v75] = (_DWORD)v71;
              ++v70;
              v69 += 2;
            }
            while (v70 <= v65);
          }
          if (v49)
          {
            for (i = 0; i != v49; ++i)
            {
              for (j = v64; j <= v65; ++j)
              {
                v78 = (int *)sub_1B2211A58(*v13, j, i);
                v79 = *v78;
                v80 = v78[1];
                v81 = v78[2];
                v82 = v78[3];
                v83 = v112;
                v112[v63] = *v78;
                v83[v63 + 1] = v80;
                v83[v63 + 2] = v81;
                v83[v63 + 3] = v79;
                v83[v63 + 4] = v81;
                v84 = v63 + 5;
                v63 += 6;
                v83[v84] = v82;
              }
            }
          }
          v57 += 2;
        }
        while (v57 != v56);
      }
      if (v63 != (_DWORD)v111)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Internal consistency error"), v50, v51, v52, v53, v54, v55, (uint64_t)"indexBufferIndex == indexBufferIndexCount");
      v85 = ((v113 - (char *)v112) >> 2) / v104;
      v86 = CFDataCreate(v109, (const UInt8 *)v112, v113 - (char *)v112);
      v87 = sub_1B17A39B4();
      sub_1B17A3ABC(v87, 0, v85, v105, 0, v86, 4, v88);
      CFRelease(v86);
      v90 = v106;
      v89 = v107;
      v106[v47] = (const void *)v87;
      if (v112)
      {
        v113 = (char *)v112;
        operator delete(v112);
      }
      Mutable = v108;
      if (v115)
      {
        v116 = v115;
        operator delete(v115);
      }
      ++v47;
    }
    while (v47 < v89);
    v91 = CFArrayCreate(v109, v90, v89, MEMORY[0x1E0C9B378]);
    do
    {
      v92 = *v90++;
      CFRelease(v92);
      --v89;
    }
    while (v89);
  }
  else
  {
    v91 = CFArrayCreate(v109, v45, 0, MEMORY[0x1E0C9B378]);
  }
  v93 = v110;
  v115 = (void **)v110;
  sub_1B17F7664(&v115);
  MEMORY[0x1B5E22E18](v93, 0x20C40960023A9);
  v99 = sub_1B17AF674(Mutable, v91, (uint64_t)v102, v94, v95, v96, v97, v98);
  CFRelease(Mutable);
  CFRelease(v91);
  if (v117)
  {
    v118 = v117;
    operator delete(v117);
  }
  return v99;
}

void sub_1B192894C(uint64_t a1, uint64_t *a2, uint64_t *a3, _QWORD *a4, uint64_t a5, void **a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v14 = a4[1] - *a4;
  if (v14)
  {
    v15 = 0;
    v16 = v14 / 112;
    if (v16 <= 1)
      v17 = 1;
    else
      v17 = v16;
    do
    {
      sub_1B1936AB4(*a4 + v15, a3, a2, a5, a1 + 2, a6, a7, a8);
      v15 += 112;
      --v17;
    }
    while (v17);
  }
  v18 = a4[4] - a4[3];
  if (v18)
  {
    v19 = 0;
    v20 = v18 / 112;
    if (v20 <= 1)
      v21 = 1;
    else
      v21 = v20;
    do
    {
      sub_1B19370EC(a4[3] + v19, a3, a2, a5, a1 + 2, a6, a7, a8);
      v19 += 112;
      --v21;
    }
    while (v21);
  }
  v22 = a4[7] - a4[6];
  if (v22)
  {
    v23 = 0;
    v24 = v22 / 112;
    v25 = a1 + 2;
    if (v24 <= 1)
      v26 = 1;
    else
      v26 = v24;
    do
    {
      sub_1B1937790(a4[6] + v23, a3, a2, a5, v25, a6, a7, a8);
      v23 += 112;
      --v26;
    }
    while (v26);
  }
}

void sub_1B1928AC8(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 168);
  if (v1)
  {
    free(*(void **)(v1 + 136));
    free(*(void **)(v1 + 144));
    free(*(void **)(v1 + 160));
    free(*(void **)(v1 + 168));
    *(_DWORD *)(v1 + 128) = 0;
    *(_QWORD *)(v1 + 136) = 0;
    *(_QWORD *)(v1 + 144) = 0;
    *(_DWORD *)(v1 + 152) = 0;
    *(_QWORD *)(v1 + 160) = 0;
    *(_QWORD *)(v1 + 168) = 0;
  }
}

void sub_1B1928B18(uint64_t a1)
{
  uint64_t v1;
  int v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v1 = *(_QWORD *)(a1 + 168);
  if (v1)
  {
    if (*(int *)(v1 + 196) >= 1)
    {
      v3 = 0;
      do
        free(*(void **)(*(_QWORD *)(v1 + 200) + 16 * v3++ + 8));
      while (*(_DWORD *)(v1 + 196) > (int)v3);
    }
    free(*(void **)(v1 + 200));
    free(*(void **)(v1 + 112));
    free(*(void **)(v1 + 120));
    free(*(void **)(v1 + 136));
    free(*(void **)(v1 + 144));
    free(*(void **)(v1 + 160));
    free(*(void **)(v1 + 168));
    free(*(void **)(v1 + 184));
    v4 = *(void **)(v1 + 80);
    if (v4)
    {
      *(_QWORD *)(v1 + 88) = v4;
      operator delete(v4);
    }
    v5 = *(void **)(v1 + 56);
    if (v5)
      operator delete(v5);
    v6 = *(void **)(v1 + 32);
    if (v6)
    {
      *(_QWORD *)(v1 + 40) = v6;
      operator delete(v6);
    }
    v7 = *(void **)(v1 + 8);
    if (v7)
    {
      *(_QWORD *)(v1 + 16) = v7;
      operator delete(v7);
    }
    free(*(void **)(a1 + 168));
    *(_QWORD *)(a1 + 168) = 0;
  }
}

void sub_1B1928BFC(char **a1, unint64_t a2)
{
  unint64_t v3;
  char *v4;
  __int128 v5;
  char *v6;
  int v7;
  char *v8;
  int v9;
  char *v10;
  __int128 v11;

  if (a2 > (_QWORD)a1[2] << 6)
  {
    if ((a2 & 0x8000000000000000) != 0)
      abort();
    v10 = 0;
    v11 = 0uLL;
    sub_1B1928C9C(&v10, a2);
    v3 = (unint64_t)a1[1];
    v8 = *a1;
    v9 = 0;
    v6 = &v8[8 * (v3 >> 6)];
    v7 = v3 & 0x3F;
    sub_1B1928CDC(&v10, (uint64_t)&v8, (uint64_t)&v6, v3);
    v4 = *a1;
    *a1 = v10;
    v10 = v4;
    v5 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = v11;
    v11 = v5;
    if (v4)
      operator delete(v4);
  }
}

void *sub_1B1928C9C(_QWORD *a1, uint64_t a2)
{
  void *result;
  uint64_t v4;

  if (a2 < 0)
    abort();
  result = sub_1B17F812C((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

void sub_1B1928CDC(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;

  v4 = a1[1];
  v5 = v4 + a4;
  a1[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41)
      v6 = (v5 - 1) >> 6;
    else
      v6 = 0;
    *(_QWORD *)(*a1 + 8 * v6) = 0;
  }
  v7 = *(_DWORD *)(a2 + 8);
  v8 = *(_QWORD *)a3;
  v9 = *(_DWORD *)(a3 + 8);
  v10 = *a1 + 8 * (v4 >> 6);
  v16 = *(_QWORD *)a2;
  v17 = v7;
  v14 = v8;
  v15 = v9;
  v12 = v10;
  v13 = v4 & 0x3F;
  sub_1B1928D7C(&v16, &v14, &v12, (uint64_t)&v11);
}

void sub_1B1928D7C(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;

  v5 = *((_DWORD *)a1 + 2);
  v6 = *a2;
  v7 = *((_DWORD *)a2 + 2);
  v16 = *a1;
  v17 = v5;
  v14 = v6;
  v15 = v7;
  v8 = *((_DWORD *)a3 + 2);
  v12 = *a3;
  v13 = v8;
  sub_1B1928E08((uint64_t)&v16, (uint64_t)&v14, (uint64_t)&v12, (uint64_t)&v18);
  v9 = v19;
  v10 = v20;
  v11 = v21;
  *(_QWORD *)a4 = v18;
  *(_DWORD *)(a4 + 8) = v9;
  *(_QWORD *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 24) = v11;
}

void sub_1B1928E08(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  _QWORD *v4;
  int v5;
  int i;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  v4 = *(_QWORD **)a1;
  v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(_QWORD *)a1 != *(_QWORD *)a2 || v5 != *(_DWORD *)(a2 + 8); v5 = *(_DWORD *)(a1 + 8))
  {
    v8 = *(uint64_t **)a3;
    v9 = 1 << i;
    if (((*v4 >> v5) & 1) != 0)
      v10 = *v8 | v9;
    else
      v10 = *v8 & ~v9;
    *v8 = v10;
    if (v5 == 63)
    {
      v11 = 0;
      *(_QWORD *)a1 = v4 + 1;
    }
    else
    {
      v11 = v5 + 1;
    }
    *(_DWORD *)(a1 + 8) = v11;
    v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      i = 0;
      *(_QWORD *)a3 += 8;
    }
    else
    {
      i = v12 + 1;
    }
    *(_DWORD *)(a3 + 8) = i;
    v4 = *(_QWORD **)a1;
  }
  *(_QWORD *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v5;
  *(_QWORD *)(a4 + 16) = *(_QWORD *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

uint64_t *sub_1B1928ED8(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  if (v2 != *result)
  {
    v5 = 0;
    do
    {
      v6 = v4 + v5;
      v7 = v2 + v5;
      *(_BYTE *)(v6 - 32) = *(_BYTE *)(v2 + v5 - 32);
      *(_QWORD *)(v6 - 16) = 0;
      *(_QWORD *)(v6 - 8) = 0;
      *(_QWORD *)(v6 - 24) = 0;
      *(_OWORD *)(v6 - 24) = *(_OWORD *)(v2 + v5 - 24);
      *(_QWORD *)(v6 - 8) = *(_QWORD *)(v2 + v5 - 8);
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v5 -= 32;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  v8 = *result;
  *result = v4;
  a2[1] = v8;
  v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void *sub_1B1928F6C(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    sub_1B179C4A8();
  return operator new(32 * a2);
}

uint64_t sub_1B1928FA0(uint64_t a1)
{
  sub_1B1928FD4(a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1B1928FD4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    *(_QWORD *)(a1 + 16) = v2 - 32;
    v5 = *(void **)(v2 - 24);
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
}

void sub_1B192902C(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v9 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - *a1) >> 4);
    if ((unint64_t)(v9 + 1) > 0x249249249249249)
      abort();
    v10 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v5 - *a1) >> 4);
    v11 = 2 * v10;
    if (2 * v10 <= v9 + 1)
      v11 = v9 + 1;
    if (v10 >= 0x124924924924924)
      v12 = 0x249249249249249;
    else
      v12 = v11;
    v18 = v4;
    if (v12)
      v13 = (char *)sub_1B1929454(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[112 * v9];
    v17 = &v13[112 * v12];
    sub_1B1929304((uint64_t)v15, a2);
    v16 = v15 + 112;
    sub_1B19293D0(a1, &v14);
    v8 = a1[1];
    sub_1B192949C((uint64_t)&v14);
  }
  else
  {
    sub_1B1929304(*(_QWORD *)(v4 - 8), a2);
    v8 = v7 + 112;
  }
  a1[1] = v8;
}

uint64_t sub_1B1929148(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 v26;
  unsigned __int8 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float32x4_t v34;
  float v35;
  float v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  int v41;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned __int8 v52;
  unsigned __int8 v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  float32x4_t v60;
  float v61;
  float v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  int v67;
  uint64_t v68;

  *(_QWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 72) = a5;
  v11 = ((unint64_t)*(unsigned __int8 *)(a4 + 8) >> 2) & 0xF;
  *(_DWORD *)(a1 + 76) = v11;
  *(_QWORD *)(a1 + 80) = a2;
  *(_BYTE *)(a1 + 88) = a6;
  v12 = *(uint64_t **)(a4 + 88);
  v13 = &v12[3 * v11];
  if ((_DWORD)a6 == 2)
  {
    v14 = sub_1B17EDAE0(a2, a2, a3, a4, a5, a6, a7, a8);
    v15 = (int)sub_1B22138D4(*v13, *(unsigned __int8 *)(a1 + 72));
    v16 = sub_1B2222DB0(a4, *(unsigned __int8 *)(a1 + 72));
    v17 = (int)(v16 - sub_1B22138D4(*v12, *(unsigned __int8 *)(a1 + 72))) - v15;
    sub_1B17F8000(a1, v14);
    v25 = sub_1B17ED6C4(a2, v18, v19, v20, v21, v22, v23, v24);
    if ((_DWORD)v14)
    {
      v37 = v25;
      v38 = 0;
      v39 = 0;
      v40 = v26;
      v41 = v27;
      do
      {
        *(double *)v34.i64 = sub_1B198D4F8(v40, (const float *)(v37 + v38), v28, v29, v30, v31, v32, v33, v34, v35, v36);
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v39++) = v34.i64[0];
        v38 += v41;
      }
      while ((_DWORD)v14 != v39);
    }
  }
  else
  {
    v43 = *(int *)(*v12 + 8);
    v15 = *(int *)(*v13 + 8);
    v17 = *(int *)(a4 + 20) - v43 - v15;
    sub_1B17F8000(a1, v43);
    v51 = sub_1B17ED6C4(a2, v44, v45, v46, v47, v48, v49, v50);
    if ((_DWORD)v43)
    {
      v63 = v51;
      v64 = 0;
      v65 = v43;
      v66 = v52;
      v67 = v53;
      do
      {
        *(double *)v60.i64 = sub_1B198D4F8(v66, (const float *)(v63 + *(int *)(*(_QWORD *)(a3 + 32) + 4 * v64) * (uint64_t)v67), v54, v55, v56, v57, v58, v59, v60, v61, v62);
        *(_QWORD *)(*(_QWORD *)a1 + 8 * (int)v64++) = v60.i64[0];
      }
      while (v65 != (_DWORD)v64);
    }
  }
  sub_1B17F8000(a1 + 24, v17);
  sub_1B17F8000(a1 + 48, v15);
  v68 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 104) = v68;
  return a1;
}

double sub_1B1929304(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(a1 + 64) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v3;
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v4;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v5;
  v6 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v6;
  v7 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v7;
  v8 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v8;
  v9 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v9;
  v10 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v10;
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(a2 + 76);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a2 + 88);
  v11 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 104) = v11;
  return result;
}

void sub_1B19293D0(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  v6 = a2[1];
  while (v4 != v5)
  {
    v4 -= 112;
    sub_1B1929304(v6 - 112, v4);
  }
  a2[1] = v6;
  v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void *sub_1B1929454(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL)
    sub_1B179C4A8();
  return operator new(112 * a2);
}

uint64_t sub_1B192949C(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 112;
    sub_1B18F877C(i - 112);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1B19294E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 v26;
  unsigned __int8 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float32x4_t v34;
  float v35;
  float v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  int v41;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned __int8 v52;
  unsigned __int8 v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  float32x4_t v60;
  float v61;
  float v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  int v67;
  uint64_t v68;

  *(_QWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 72) = a5;
  v11 = ((unint64_t)*(unsigned __int8 *)(a4 + 8) >> 2) & 0xF;
  *(_DWORD *)(a1 + 76) = v11;
  *(_QWORD *)(a1 + 80) = a2;
  *(_BYTE *)(a1 + 88) = a6;
  v12 = *(uint64_t **)(a4 + 88);
  v13 = &v12[3 * v11];
  if ((_DWORD)a6 == 2)
  {
    v14 = sub_1B17EDAE0(a2, a2, a3, a4, a5, a6, a7, a8);
    v15 = (int)sub_1B22138D4(*v13, *(unsigned __int8 *)(a1 + 72));
    v16 = sub_1B2222DB0(a4, *(unsigned __int8 *)(a1 + 72));
    v17 = (int)(v16 - sub_1B22138D4(*v12, *(unsigned __int8 *)(a1 + 72))) - v15;
    sub_1B18261CC(a1, v14);
    v25 = sub_1B17ED6C4(a2, v18, v19, v20, v21, v22, v23, v24);
    if ((_DWORD)v14)
    {
      v37 = v25;
      v38 = 0;
      v39 = 0;
      v40 = v26;
      v41 = v27;
      do
      {
        *(double *)v34.i64 = sub_1B198D4F8(v40, (const float *)(v37 + v38), v28, v29, v30, v31, v32, v33, v34, v35, v36);
        *(float32x4_t *)(*(_QWORD *)a1 + 16 * v39++) = v34;
        v38 += v41;
      }
      while ((_DWORD)v14 != v39);
    }
  }
  else
  {
    v43 = *(int *)(*v12 + 8);
    v15 = *(int *)(*v13 + 8);
    v17 = *(int *)(a4 + 20) - v43 - v15;
    sub_1B18261CC(a1, v43);
    v51 = sub_1B17ED6C4(a2, v44, v45, v46, v47, v48, v49, v50);
    if ((_DWORD)v43)
    {
      v63 = v51;
      v64 = 0;
      v65 = v43;
      v66 = v52;
      v67 = v53;
      do
      {
        *(double *)v60.i64 = sub_1B198D4F8(v66, (const float *)(v63 + *(int *)(*(_QWORD *)(a3 + 32) + 4 * v64) * (uint64_t)v67), v54, v55, v56, v57, v58, v59, v60, v61, v62);
        *(float32x4_t *)(*(_QWORD *)a1 + 16 * (int)v64++) = v60;
      }
      while (v65 != (_DWORD)v64);
    }
  }
  sub_1B18261CC(a1 + 24, v17);
  sub_1B18261CC(a1 + 48, v15);
  v68 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 104) = v68;
  return a1;
}

void sub_1B19296A4(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0x8E38E38E38E38E39 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 72 * ((72 * a2 - 72) / 0x48) + 72;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x8E38E38E38E38E39 * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x38E38E38E38E38ELL)
      abort();
    v10 = 0x8E38E38E38E38E39 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x1C71C71C71C71C7)
      v11 = 0x38E38E38E38E38ELL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)sub_1B19298C0(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[72 * v8];
    v18 = &v12[72 * v11];
    v14 = 72 * ((72 * a2 - 72) / 0x48) + 72;
    bzero(v16, v14);
    v17 = &v16[v14];
    sub_1B1929830(a1, &v15);
    sub_1B192996C((uint64_t)&v15);
  }
}

void sub_1B1929830(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  v6 = (_QWORD *)a2[1];
  while (v4 != v5)
  {
    v6 -= 9;
    v4 -= 72;
    sub_1B1929908(v6, v4);
  }
  a2[1] = v6;
  v7 = *a1;
  *a1 = (uint64_t)v6;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void *sub_1B19298C0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL)
    sub_1B179C4A8();
  return operator new(72 * a2);
}

__n128 sub_1B1929908(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  *(_OWORD *)(a1 + 3) = *(_OWORD *)(a2 + 24);
  a1[5] = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  result = *(__n128 *)(a2 + 48);
  *((__n128 *)a1 + 3) = result;
  a1[8] = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  return result;
}

uint64_t sub_1B192996C(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 72;
    sub_1B18F86BC((void **)(i - 72));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1B19299B8(uint64_t a1, int a2, int **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v14 = *(_DWORD *)(a1 + 76);
  if (v14 < a2)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Can't subdivide further"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"level <= _finalLevel");
    v14 = *(_DWORD *)(a1 + 76);
  }
  v15 = *(unsigned __int8 *)(a1 + 88);
  if (v14 != a2)
  {
    if (v15 == 2)
    {
      sub_1B192A79C(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104), *(unsigned __int8 *)(a1 + 72));
    }
    else if (v15 == 1)
    {
      sub_1B192A4AC((uint64_t)a3, a2, (_QWORD *)(a1 + 96), (_QWORD *)(a1 + 104), a9, a10);
    }
    else
    {
      if (*(_BYTE *)(a1 + 88))
      {
LABEL_19:
        v16 = *(_QWORD *)(a1 + 104);
        v17 = v16 + 8 * *(int *)(*(_QWORD *)(*(_QWORD *)(a4 + 88) + 24 * a2) + 8);
        *(_QWORD *)(a1 + 96) = v16;
        *(_QWORD *)(a1 + 104) = v17;
        return;
      }
      sub_1B192A1A0((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104));
    }
    if (*(_BYTE *)(a1 + 88) == 2)
    {
      *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 104);
      *(_QWORD *)(a1 + 104) += 8
                             * (int)sub_1B22138D4(*(_QWORD *)(*(_QWORD *)(a4 + 88) + 24 * a2), *(unsigned __int8 *)(a1 + 72));
      return;
    }
    goto LABEL_19;
  }
  if (v15 == 2)
  {
    sub_1B192A63C(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48), *(unsigned __int8 *)(a1 + 72));
  }
  else if (v15 == 1)
  {
    sub_1B192A4AC((uint64_t)a3, a2, (_QWORD *)(a1 + 96), (_QWORD *)(a1 + 48), a9, a10);
  }
  else if (!*(_BYTE *)(a1 + 88))
  {
    sub_1B192A1A0((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48));
  }
  sub_1B17F8000(a1, 0);
  sub_1B17F8000(a1 + 24, 0);
}

void sub_1B1929B64(uint64_t a1, int a2, int **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, float32x4_t a11)
{
  int v15;
  int v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  float32x4_t v29;
  uint64_t v30;
  int *v31;
  int v32;
  uint64_t j;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  float32x4_t v47;
  uint64_t v48;
  int *v49;
  int v50;
  uint64_t i;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;

  v15 = *(_DWORD *)(a1 + 76);
  if (v15 < a2)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Can't subdivide further"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"level <= _finalLevel");
    v15 = *(_DWORD *)(a1 + 76);
  }
  v16 = *(unsigned __int8 *)(a1 + 88);
  if (v15 != a2)
  {
    if (v16 == 2)
    {
      sub_1B192F47C(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104), *(unsigned __int8 *)(a1 + 72));
    }
    else if (v16 == 1)
    {
      v35 = *(_QWORD *)(*((_QWORD *)*a3 + 8) + 8 * a2 - 8);
      v36 = *(int **)(v35 + 8);
      if (*(int *)(v35 + 52) >= 1 && *v36 >= 1)
      {
        v37 = 0;
        do
        {
          v38 = *(int *)(*(_QWORD *)(v35 + 168) + 4 * v37);
          if ((_DWORD)v38 != -1)
          {
            v39 = *((_QWORD *)v36 + 6);
            v40 = *(unsigned int *)(*((_QWORD *)v36 + 3) + 8 * v37);
            v41 = *(int *)(*((_QWORD *)v36 + 3) + 8 * v37 + 4);
            *(_OWORD *)(*(_QWORD *)(a1 + 104) + 16 * v38) = 0uLL;
            if ((int)v40 >= 1)
            {
              v42 = (int *)(v39 + 4 * v41);
              a11.f32[0] = 1.0 / (float)(int)v40;
              a11 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a11.f32, 0);
              do
              {
                v43 = *v42++;
                *(float32x4_t *)(*(_QWORD *)(a1 + 104) + 16 * v38) = vmlaq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 104) + 16 * v38), *(float32x4_t *)(*(_QWORD *)(a1 + 96) + 16 * v43), a11);
                --v40;
              }
              while (v40);
            }
          }
          ++v37;
        }
        while (v37 < *v36);
      }
      v44 = v36[1];
      if (v44 >= 1)
      {
        v45 = 0;
        v46 = 0;
        v47.i64[0] = 0x3F0000003F000000;
        v47.i64[1] = 0x3F0000003F000000;
        do
        {
          v48 = *(int *)(*(_QWORD *)(v35 + 216) + 4 * v46);
          if ((_DWORD)v48 != -1)
          {
            v49 = (int *)(*((_QWORD *)v36 + 15) + v45);
            *(_OWORD *)(*(_QWORD *)(a1 + 104) + 16 * v48) = 0uLL;
            *(float32x4_t *)(*(_QWORD *)(a1 + 104) + 16 * v48) = vmlaq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 104) + 16 * v48), v47, *(float32x4_t *)(*(_QWORD *)(a1 + 96) + 16 * *v49));
            *(float32x4_t *)(*(_QWORD *)(a1 + 104) + 16 * v48) = vmlaq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 104) + 16 * v48), v47, *(float32x4_t *)(*(_QWORD *)(a1 + 96) + 16 * v49[1]));
            v44 = v36[1];
          }
          ++v46;
          v45 += 8;
        }
        while (v46 < v44);
      }
      v50 = v36[2];
      if (v50 >= 1)
      {
        for (i = 0; i < v50; ++i)
        {
          v52 = *(int *)(*(_QWORD *)(v35 + 240) + 4 * i);
          if ((_DWORD)v52 != -1)
          {
            *(_OWORD *)(*(_QWORD *)(a1 + 104) + 16 * v52) = 0uLL;
            *(float32x4_t *)(*(_QWORD *)(a1 + 104) + 16 * v52) = vaddq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 96) + 16 * i), *(float32x4_t *)(*(_QWORD *)(a1 + 104) + 16 * v52));
            v50 = v36[2];
          }
        }
      }
    }
    else
    {
      if (*(_BYTE *)(a1 + 88))
      {
LABEL_53:
        v53 = *(_QWORD *)(a1 + 104);
        v54 = v53 + 16 * *(int *)(*(_QWORD *)(*(_QWORD *)(a4 + 88) + 24 * a2) + 8);
        *(_QWORD *)(a1 + 96) = v53;
        *(_QWORD *)(a1 + 104) = v54;
        return;
      }
      sub_1B192F010((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104));
    }
    if (*(_BYTE *)(a1 + 88) == 2)
    {
      *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 104);
      *(_QWORD *)(a1 + 104) += 16
                             * (int)sub_1B22138D4(*(_QWORD *)(*(_QWORD *)(a4 + 88) + 24 * a2), *(unsigned __int8 *)(a1 + 72));
      return;
    }
    goto LABEL_53;
  }
  if (v16 == 2)
  {
    sub_1B192F31C(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48), *(unsigned __int8 *)(a1 + 72));
  }
  else if (v16 == 1)
  {
    v17 = *(_QWORD *)(*((_QWORD *)*a3 + 8) + 8 * a2 - 8);
    v18 = *(int **)(v17 + 8);
    if (*(int *)(v17 + 52) >= 1 && *v18 >= 1)
    {
      v19 = 0;
      do
      {
        v20 = *(int *)(*(_QWORD *)(v17 + 168) + 4 * v19);
        if ((_DWORD)v20 != -1)
        {
          v21 = *((_QWORD *)v18 + 6);
          v22 = *(unsigned int *)(*((_QWORD *)v18 + 3) + 8 * v19);
          v23 = *(int *)(*((_QWORD *)v18 + 3) + 8 * v19 + 4);
          *(_OWORD *)(*(_QWORD *)(a1 + 48) + 16 * v20) = 0uLL;
          if ((int)v22 >= 1)
          {
            v24 = (int *)(v21 + 4 * v23);
            a11.f32[0] = 1.0 / (float)(int)v22;
            a11 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a11.f32, 0);
            do
            {
              v25 = *v24++;
              *(float32x4_t *)(*(_QWORD *)(a1 + 48) + 16 * v20) = vmlaq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 48) + 16 * v20), *(float32x4_t *)(*(_QWORD *)(a1 + 96) + 16 * v25), a11);
              --v22;
            }
            while (v22);
          }
        }
        ++v19;
      }
      while (v19 < *v18);
    }
    v26 = v18[1];
    if (v26 >= 1)
    {
      v27 = 0;
      v28 = 0;
      v29.i64[0] = 0x3F0000003F000000;
      v29.i64[1] = 0x3F0000003F000000;
      do
      {
        v30 = *(int *)(*(_QWORD *)(v17 + 216) + 4 * v28);
        if ((_DWORD)v30 != -1)
        {
          v31 = (int *)(*((_QWORD *)v18 + 15) + v27);
          *(_OWORD *)(*(_QWORD *)(a1 + 48) + 16 * v30) = 0uLL;
          *(float32x4_t *)(*(_QWORD *)(a1 + 48) + 16 * v30) = vmlaq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 48) + 16 * v30), v29, *(float32x4_t *)(*(_QWORD *)(a1 + 96) + 16 * *v31));
          *(float32x4_t *)(*(_QWORD *)(a1 + 48) + 16 * v30) = vmlaq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 48) + 16 * v30), v29, *(float32x4_t *)(*(_QWORD *)(a1 + 96) + 16 * v31[1]));
          v26 = v18[1];
        }
        ++v28;
        v27 += 8;
      }
      while (v28 < v26);
    }
    v32 = v18[2];
    if (v32 >= 1)
    {
      for (j = 0; j < v32; ++j)
      {
        v34 = *(int *)(*(_QWORD *)(v17 + 240) + 4 * j);
        if ((_DWORD)v34 != -1)
        {
          *(_OWORD *)(*(_QWORD *)(a1 + 48) + 16 * v34) = 0uLL;
          *(float32x4_t *)(*(_QWORD *)(a1 + 48) + 16 * v34) = vaddq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 96) + 16 * j), *(float32x4_t *)(*(_QWORD *)(a1 + 48) + 16 * v34));
          v32 = v18[2];
        }
      }
    }
  }
  else if (!*(_BYTE *)(a1 + 88))
  {
    sub_1B192F010((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48));
  }
  sub_1B18261CC(a1, 0);
  sub_1B18261CC(a1 + 24, 0);
}

void sub_1B1929FF4(uint64_t a1, int a2, int **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, float32x4_t a10)
{
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v14 = *(_DWORD *)(a1 + 76);
  if (v14 < a2)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Can't subdivide further"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"level <= _finalLevel");
    v14 = *(_DWORD *)(a1 + 76);
  }
  v15 = *(unsigned __int8 *)(a1 + 88);
  if (v14 != a2)
  {
    if (v15 == 2)
    {
      sub_1B1933024(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104), *(unsigned __int8 *)(a1 + 72));
    }
    else if (v15 == 1)
    {
      sub_1B1932D34((uint64_t)a3, a2, (_QWORD *)(a1 + 96), (_QWORD *)(a1 + 104), a9, a10);
    }
    else
    {
      if (*(_BYTE *)(a1 + 88))
      {
LABEL_19:
        v16 = *(_QWORD *)(a1 + 104);
        v17 = v16 + 16 * *(int *)(*(_QWORD *)(*(_QWORD *)(a4 + 88) + 24 * a2) + 8);
        *(_QWORD *)(a1 + 96) = v16;
        *(_QWORD *)(a1 + 104) = v17;
        return;
      }
      sub_1B1932A28((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 104));
    }
    if (*(_BYTE *)(a1 + 88) == 2)
    {
      *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 104);
      *(_QWORD *)(a1 + 104) += 16
                             * (int)sub_1B22138D4(*(_QWORD *)(*(_QWORD *)(a4 + 88) + 24 * a2), *(unsigned __int8 *)(a1 + 72));
      return;
    }
    goto LABEL_19;
  }
  if (v15 == 2)
  {
    sub_1B1932EC4(a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48), *(unsigned __int8 *)(a1 + 72));
  }
  else if (v15 == 1)
  {
    sub_1B1932D34((uint64_t)a3, a2, (_QWORD *)(a1 + 96), (_QWORD *)(a1 + 48), a9, a10);
  }
  else if (!*(_BYTE *)(a1 + 88))
  {
    sub_1B1932A28((uint64_t *)a3, a2, (uint64_t *)(a1 + 96), (uint64_t *)(a1 + 48));
  }
  sub_1B18261CC(a1, 0);
  sub_1B18261CC(a1 + 24, 0);
}

void sub_1B192A1A0(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  int v8;
  void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  int *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t j;
  uint64_t v24;
  void *__p;
  void *v26;

  v8 = *(_DWORD *)*a1;
  if (v8)
  {
    if (v8 == 2)
    {
      sub_1B192A8FC((uint64_t)a1, a2, a3, a4);
      sub_1B192AFC0(a1, a2, a3, a4);
      sub_1B192B258(a1, a2, a3, a4);
    }
    else if (v8 == 1)
    {
      sub_1B192A8FC((uint64_t)a1, a2, a3, a4);
      sub_1B192AA8C(a1, a2, a3, a4);
      sub_1B192AD24(a1, a2, a3, a4);
    }
  }
  else
  {
    sub_1B192A8FC((uint64_t)a1, a2, a3, a4);
    v9 = 0;
    v10 = a2 - 1;
    v11 = *(_QWORD *)(*(_QWORD *)(*a1 + 64) + 8 * (a2 - 1));
    v12 = *(_QWORD *)(v11 + 8);
    v13 = *(unsigned int *)(v12 + 16);
    __p = 0;
    if (v13 >= 9)
    {
      v9 = operator new(4 * v13);
      __p = v9;
    }
    v14 = *(_DWORD *)(v12 + 4);
    if (v14 >= 1)
    {
      v15 = 0;
      for (i = 0; i < v14; ++i)
      {
        v17 = *(int *)(*(_QWORD *)(v11 + 216) + 4 * i);
        if ((_DWORD)v17 != -1)
        {
          v18 = (int *)(*(_QWORD *)(v12 + 120) + v15);
          *(_QWORD *)(*a4 + 8 * v17) = 0;
          *(float32x2_t *)(*a4 + 8 * v17) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v17), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * *v18));
          *(float32x2_t *)(*a4 + 8 * v17) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v17), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v18[1]));
          v14 = *(_DWORD *)(v12 + 4);
        }
        v15 += 8;
      }
      v9 = __p;
    }
    operator delete(v9);
    v19 = 0;
    v20 = *(_QWORD *)(*(_QWORD *)(*a1 + 64) + 8 * v10);
    v21 = *(_QWORD *)(v20 + 8);
    v26 = 0;
    if ((2 * *(_DWORD *)(v21 + 20)) >= 0x21)
    {
      v19 = operator new(4 * (2 * *(_DWORD *)(v21 + 20)));
      v26 = v19;
    }
    v22 = *(_DWORD *)(v21 + 8);
    if (v22 >= 1)
    {
      for (j = 0; j < v22; ++j)
      {
        v24 = *(int *)(*(_QWORD *)(v20 + 240) + 4 * j);
        if ((_DWORD)v24 != -1)
        {
          *(_QWORD *)(*a4 + 8 * v24) = 0;
          *(float32x2_t *)(*a4 + 8 * v24) = vadd_f32(*(float32x2_t *)(*a3 + 8 * j), *(float32x2_t *)(*a4 + 8 * v24));
          v22 = *(_DWORD *)(v21 + 8);
        }
      }
      v19 = v26;
    }
    operator delete(v19);
  }
}

uint64_t sub_1B192A4AC(uint64_t result, int a2, _QWORD *a3, _QWORD *a4, double a5, double a6)
{
  uint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t i;
  uint64_t v18;
  int *v19;
  int v20;
  uint64_t j;
  uint64_t v22;

  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)result + 64) + 8 * (a2 - 1));
  v7 = *(int **)(v6 + 8);
  if (*(int *)(v6 + 52) >= 1 && *v7 >= 1)
  {
    v8 = 0;
    do
    {
      v9 = *(int *)(*(_QWORD *)(v6 + 168) + 4 * v8);
      if ((_DWORD)v9 != -1)
      {
        v10 = *((_QWORD *)v7 + 6);
        v11 = *(unsigned int *)(*((_QWORD *)v7 + 3) + 8 * v8);
        v12 = *(int *)(*((_QWORD *)v7 + 3) + 8 * v8 + 4);
        *(_QWORD *)(*a4 + 8 * v9) = 0;
        if ((int)v11 >= 1)
        {
          v13 = (int *)(v10 + 4 * v12);
          *(float *)&a6 = 1.0 / (float)(int)v11;
          a6 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)&a6, 0));
          do
          {
            v14 = *v13++;
            *(float32x2_t *)(*a4 + 8 * v9) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v9), *(float32x2_t *)(*a3 + 8 * v14), *(float32x2_t *)&a6);
            --v11;
          }
          while (v11);
        }
      }
      ++v8;
    }
    while (v8 < *v7);
  }
  v15 = v7[1];
  if (v15 >= 1)
  {
    v16 = 0;
    for (i = 0; i < v15; ++i)
    {
      v18 = *(int *)(*(_QWORD *)(v6 + 216) + 4 * i);
      if ((_DWORD)v18 != -1)
      {
        v19 = (int *)(*((_QWORD *)v7 + 15) + v16);
        *(_QWORD *)(*a4 + 8 * v18) = 0;
        *(float32x2_t *)(*a4 + 8 * v18) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v18), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * *v19));
        *(float32x2_t *)(*a4 + 8 * v18) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v18), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v19[1]));
        v15 = v7[1];
      }
      v16 += 8;
    }
  }
  v20 = v7[2];
  if (v20 >= 1)
  {
    for (j = 0; j < v20; ++j)
    {
      v22 = *(int *)(*(_QWORD *)(v6 + 240) + 4 * j);
      if ((_DWORD)v22 != -1)
      {
        *(_QWORD *)(*a4 + 8 * v22) = 0;
        *(float32x2_t *)(*a4 + 8 * v22) = vadd_f32(*(float32x2_t *)(*a3 + 8 * j), *(float32x2_t *)(*a4 + 8 * v22));
        v20 = v7[2];
      }
    }
  }
  return result;
}

void sub_1B192A63C(int **a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  int v10;

  v10 = **a1;
  if (v10)
  {
    if (v10 == 2)
    {
      sub_1B192C778((uint64_t)a1, a2, a3, a4, a5);
      sub_1B192D26C((uint64_t)a1, a2, a3, a4, a5);
      sub_1B192D644((uint64_t)a1, a2, a3, a4, a5);
    }
    else if (v10 == 1)
    {
      sub_1B192C778((uint64_t)a1, a2, a3, a4, a5);
      sub_1B192C92C((uint64_t)a1, a2, a3, a4, a5);
      sub_1B192CD04((uint64_t)a1, a2, a3, a4, a5);
    }
  }
  else
  {
    sub_1B192C778((uint64_t)a1, a2, a3, a4, a5);
    sub_1B192DBAC((uint64_t)a1, a2, a3, a4, a5);
    sub_1B192DDE8((uint64_t)a1, a2, a3, a4, a5);
  }
}

void sub_1B192A79C(int **a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  int v10;

  v10 = **a1;
  if (v10)
  {
    if (v10 == 2)
    {
      sub_1B192C778((uint64_t)a1, a2, a3, a4, a5);
      sub_1B192D26C((uint64_t)a1, a2, a3, a4, a5);
      sub_1B192E6FC((uint64_t)a1, a2, a3, a4, a5);
    }
    else if (v10 == 1)
    {
      sub_1B192C778((uint64_t)a1, a2, a3, a4, a5);
      sub_1B192C92C((uint64_t)a1, a2, a3, a4, a5);
      sub_1B192E194((uint64_t)a1, a2, a3, a4, a5);
    }
  }
  else
  {
    sub_1B192C778((uint64_t)a1, a2, a3, a4, a5);
    sub_1B192DBAC((uint64_t)a1, a2, a3, a4, a5);
    sub_1B192EC64((uint64_t)a1, a2, a3, a4, a5);
  }
}

void sub_1B192A8FC(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  void *v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  void *__p;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  if (*(_DWORD *)(v4 + 52))
  {
    v7 = 0;
    v8 = *(int **)(v4 + 8);
    v9 = v8[5];
    v19 = (float *)&v20;
    __p = 0;
    if (v9 >= 0x11)
    {
      v7 = operator new(4 * v9);
      __p = v7;
      v19 = (float *)v7;
    }
    if (*v8 >= 1)
    {
      v10 = 0;
      do
      {
        v11 = *(int *)(*(_QWORD *)(v4 + 168) + 4 * v10);
        if ((_DWORD)v11 != -1)
        {
          v12 = (unsigned int *)(*((_QWORD *)v8 + 3) + 8 * v10);
          v13 = *v12;
          if ((int)v13 < 1)
          {
            *(_QWORD *)(*a4 + 8 * v11) = 0;
          }
          else
          {
            v14 = *((_QWORD *)v8 + 6) + 4 * (int)v12[1];
            v15 = v19;
            v16 = v13;
            do
            {
              *v15++ = 1.0 / (float)(int)v13;
              --v16;
            }
            while (v16);
            *(_QWORD *)(*a4 + 8 * v11) = 0;
            v17 = 0;
            v18 = 4 * v13;
            do
            {
              *(float32x2_t *)(*a4 + 8 * v11) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v11), *(float32x2_t *)(*a3 + 8 * *(int *)(v14 + v17)), v19[v17 / 4]);
              v17 += 4;
            }
            while (v18 != v17);
          }
        }
        ++v10;
      }
      while (v10 < *v8);
      v7 = __p;
    }
    operator delete(v7);
  }
}

void sub_1B192AA8C(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t i;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t j;
  uint64_t v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD v33[5];
  uint64_t v34;
  int v35;
  int v36;
  float *v37;
  int v38;
  int v39;
  uint64_t v40;
  void *__p;
  float v42[2];
  uint64_t v43;

  v7 = 0;
  v43 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v10 = v9[1];
  v32 = v9[2];
  v36 = *(_DWORD *)(v8 + 4);
  v11 = *(unsigned int *)(v10 + 16);
  v37 = (float *)&v40;
  v38 = v11;
  v39 = 8;
  v34 = v10;
  __p = 0;
  if (v11 >= 9)
  {
    v7 = operator new(4 * v11);
    __p = v7;
    v37 = (float *)v7;
    v39 = v11;
  }
  v12 = *(_DWORD *)(v10 + 4);
  if (v12 >= 1)
  {
    for (i = 0; i < v12; ++i)
    {
      v14 = *(int *)(v9[27] + 4 * i);
      if ((_DWORD)v14 != -1)
      {
        v15 = (int *)(*(_QWORD *)(v10 + 120) + 8 * i);
        v16 = *(_QWORD *)(v10 + 168);
        v17 = (unsigned int *)(*(_QWORD *)(v10 + 144) + 8 * i);
        v18 = *v17;
        v19 = (int)v17[1];
        v33[0] = v42;
        v33[1] = 0;
        v33[2] = v37;
        memset(&v33[3], 0, 13);
        v35 = i;
        if (*(float *)(*(_QWORD *)(v10 + 216) + 4 * i) <= 0.0)
          v20 = 1;
        else
          v20 = 4;
        sub_1B192B4F4(&v36, (int *)&v34, (uint64_t)v33, v20, (*(unsigned __int16 *)(*(_QWORD *)(v32 + 432) + 2 * v14) >> 7) & 0xF);
        *(_QWORD *)(*a4 + 8 * v14) = 0;
        *(float32x2_t *)(*a4 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v14), *(float32x2_t *)(*a3 + 8 * *v15), v42[0]);
        *(float32x2_t *)(*a4 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v14), *(float32x2_t *)(*a3 + 8 * v15[1]), v42[1]);
        if (SLODWORD(v33[4]) >= 1 && (int)v18 >= 1)
        {
          for (j = 0; j != v18; ++j)
          {
            v22 = *(int *)(v16 + 4 * v19 + 4 * j);
            if (BYTE4(v33[4]))
            {
              v23 = (int *)(v9[21] + 4 * v22);
              v24 = *a4;
              v25 = *a4;
            }
            else
            {
              v26 = 0;
              v27 = *(_QWORD *)(v10 + 24);
              v28 = *(int *)(v27 + 8 * (_DWORD)v22 + 4);
              v29 = *(_DWORD *)(v27 + 8 * v22);
              do
                v30 = *(unsigned int *)(*(_QWORD *)(v10 + 72) + 4 * v28 + 4 * v26++);
              while (i != v30);
              v31 = *(_QWORD *)(v10 + 48) + 4 * v28;
              if ((int)v26 + 1 < v29)
                v29 = 0;
              v23 = (int *)(v31 + 4 * ((int)v26 - v29 + 1));
              v25 = *a4;
              v24 = *a3;
            }
            *(float32x2_t *)(v25 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(v25 + 8 * v14), *(float32x2_t *)(v24 + 8 * *v23), v37[j]);
          }
        }
        v12 = *(_DWORD *)(v10 + 4);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B192AD24(uint64_t *a1, int a2, _QWORD *a3, _QWORD *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t i;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  _DWORD *v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v30;
  uint64_t v31;
  _DWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  _QWORD v38[5];
  float v39;
  _QWORD v40[2];
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t *v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  void *__p;
  uint64_t v51;

  v7 = 0;
  v51 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v11 = v9[1];
  v10 = v9[2];
  v45 = *(_DWORD *)(v8 + 4);
  v12 = 2 * *(_DWORD *)(v11 + 20);
  v46 = &v49;
  v47 = v12;
  v48 = 32;
  v40[0] = v11;
  v40[1] = v10;
  v33 = v10;
  __p = 0;
  if (v12 >= 0x21)
  {
    v7 = operator new(4 * v12);
    __p = v7;
    v46 = (uint64_t *)v7;
    v48 = v12;
  }
  v13 = *(_DWORD *)(v11 + 8);
  if (v13 >= 1)
  {
    for (i = 0; i < v13; ++i)
    {
      v15 = *(_DWORD *)(v9[30] + 4 * i);
      if (v15 != -1)
      {
        v16 = v15;
        v36 = *(_QWORD *)(v11 + 360);
        v17 = *(_QWORD *)(v11 + 336);
        v18 = (8 * i) | 4;
        v35 = *(int *)(v17 + v18);
        v19 = *(int *)(v17 + 8 * i);
        v20 = *(_QWORD *)(v11 + 264);
        v34 = *(int *)(v20 + v18);
        v21 = *(unsigned int *)(v20 + 8 * i);
        v39 = 0.0;
        v22 = v46;
        v23 = (_DWORD *)v46 + v19;
        v37 = v19;
        v38[0] = &v39;
        v38[1] = v46;
        v38[2] = v23;
        memset(&v38[3], 0, 13);
        v41 = i;
        v42 = v15;
        v43 = *(_DWORD *)(*(_QWORD *)(v40[0] + 336) + 8 * i);
        v44 = *(_DWORD *)(*(_QWORD *)(v40[0] + 264) + 8 * i);
        v24 = *(_QWORD *)(v11 + 288);
        sub_1B192B8C0(&v45, (uint64_t)v40, (uint64_t)v38, (*(unsigned __int16 *)(*(_QWORD *)(v11 + 432) + 2 * i) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v33 + 432) + 2 * v15) >> 7) & 0xF);
        *(_QWORD *)(*a4 + 8 * v16) = 0;
        if (SLODWORD(v38[4]) >= 1 && (int)v21 >= 1)
        {
          v25 = (int *)(v24 + 4 * v34);
          do
          {
            v26 = *v25++;
            v27 = *(int *)(v9[21] + 4 * v26);
            LODWORD(v26) = *v23++;
            *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a4 + 8 * v27), *(float *)&v26);
            --v21;
          }
          while (v21);
        }
        v28 = v37;
        if (SHIDWORD(v38[3]) >= 1 && v37 >= 1)
        {
          v30 = (int *)(v36 + 4 * v35);
          do
          {
            v31 = *v30++;
            v32 = (_DWORD *)(*(_QWORD *)(v11 + 120) + 8 * v31);
            LODWORD(v31) = *(_DWORD *)v22;
            v22 = (uint64_t *)((char *)v22 + 4);
            *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a3 + 8 * (int)v32[i == *v32]), *(float *)&v31);
            --v28;
          }
          while (v28);
        }
        *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a3 + 8 * i), v39);
        v13 = *(_DWORD *)(v11 + 8);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B192AFC0(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t i;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t j;
  uint64_t v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD v33[5];
  uint64_t v34;
  int v35;
  int v36;
  float *v37;
  int v38;
  int v39;
  uint64_t v40;
  void *__p;
  float v42[2];
  uint64_t v43;

  v7 = 0;
  v43 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v10 = v9[1];
  v32 = v9[2];
  v36 = *(_DWORD *)(v8 + 4);
  v11 = *(unsigned int *)(v10 + 16);
  v37 = (float *)&v40;
  v38 = v11;
  v39 = 8;
  v34 = v10;
  __p = 0;
  if (v11 >= 9)
  {
    v7 = operator new(4 * v11);
    __p = v7;
    v37 = (float *)v7;
    v39 = v11;
  }
  v12 = *(_DWORD *)(v10 + 4);
  if (v12 >= 1)
  {
    for (i = 0; i < v12; ++i)
    {
      v14 = *(int *)(v9[27] + 4 * i);
      if ((_DWORD)v14 != -1)
      {
        v15 = (int *)(*(_QWORD *)(v10 + 120) + 8 * i);
        v16 = *(_QWORD *)(v10 + 168);
        v17 = (unsigned int *)(*(_QWORD *)(v10 + 144) + 8 * i);
        v18 = *v17;
        v19 = (int)v17[1];
        v33[0] = v42;
        v33[1] = 0;
        v33[2] = v37;
        memset(&v33[3], 0, 13);
        v35 = i;
        if (*(float *)(*(_QWORD *)(v10 + 216) + 4 * i) <= 0.0)
          v20 = 1;
        else
          v20 = 4;
        sub_1B192BFA0(&v36, (int *)&v34, (uint64_t)v33, v20, (*(unsigned __int16 *)(*(_QWORD *)(v32 + 432) + 2 * v14) >> 7) & 0xF);
        *(_QWORD *)(*a4 + 8 * v14) = 0;
        *(float32x2_t *)(*a4 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v14), *(float32x2_t *)(*a3 + 8 * *v15), v42[0]);
        *(float32x2_t *)(*a4 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v14), *(float32x2_t *)(*a3 + 8 * v15[1]), v42[1]);
        if (SLODWORD(v33[4]) >= 1 && (int)v18 >= 1)
        {
          for (j = 0; j != v18; ++j)
          {
            v22 = *(int *)(v16 + 4 * v19 + 4 * j);
            if (BYTE4(v33[4]))
            {
              v23 = (int *)(v9[21] + 4 * v22);
              v24 = *a4;
              v25 = *a4;
            }
            else
            {
              v26 = 0;
              v27 = *(_QWORD *)(v10 + 24);
              v28 = *(int *)(v27 + 8 * (_DWORD)v22 + 4);
              v29 = *(_DWORD *)(v27 + 8 * v22);
              do
                v30 = *(unsigned int *)(*(_QWORD *)(v10 + 72) + 4 * v28 + 4 * v26++);
              while (i != v30);
              v31 = *(_QWORD *)(v10 + 48) + 4 * v28;
              if ((int)v26 + 1 < v29)
                v29 = 0;
              v23 = (int *)(v31 + 4 * ((int)v26 - v29 + 1));
              v25 = *a4;
              v24 = *a3;
            }
            *(float32x2_t *)(v25 + 8 * v14) = vmla_n_f32(*(float32x2_t *)(v25 + 8 * v14), *(float32x2_t *)(v24 + 8 * *v23), v37[j]);
          }
        }
        v12 = *(_DWORD *)(v10 + 4);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B192B258(uint64_t *a1, int a2, _QWORD *a3, _QWORD *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t i;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  _DWORD *v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v30;
  uint64_t v31;
  _DWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  _QWORD v38[5];
  float v39;
  _QWORD v40[2];
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t *v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  void *__p;
  uint64_t v51;

  v7 = 0;
  v51 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v11 = v9[1];
  v10 = v9[2];
  v45 = *(_DWORD *)(v8 + 4);
  v12 = 2 * *(_DWORD *)(v11 + 20);
  v46 = &v49;
  v47 = v12;
  v48 = 32;
  v40[0] = v11;
  v40[1] = v10;
  v33 = v10;
  __p = 0;
  if (v12 >= 0x21)
  {
    v7 = operator new(4 * v12);
    __p = v7;
    v46 = (uint64_t *)v7;
    v48 = v12;
  }
  v13 = *(_DWORD *)(v11 + 8);
  if (v13 >= 1)
  {
    for (i = 0; i < v13; ++i)
    {
      v15 = *(_DWORD *)(v9[30] + 4 * i);
      if (v15 != -1)
      {
        v16 = v15;
        v36 = *(_QWORD *)(v11 + 360);
        v17 = *(_QWORD *)(v11 + 336);
        v18 = (8 * i) | 4;
        v35 = *(int *)(v17 + v18);
        v19 = *(int *)(v17 + 8 * i);
        v20 = *(_QWORD *)(v11 + 264);
        v34 = *(int *)(v20 + v18);
        v21 = *(unsigned int *)(v20 + 8 * i);
        v39 = 0.0;
        v22 = v46;
        v23 = (_DWORD *)v46 + v19;
        v37 = v19;
        v38[0] = &v39;
        v38[1] = v46;
        v38[2] = v23;
        memset(&v38[3], 0, 13);
        v41 = i;
        v42 = v15;
        v43 = *(_DWORD *)(*(_QWORD *)(v40[0] + 336) + 8 * i);
        v44 = *(_DWORD *)(*(_QWORD *)(v40[0] + 264) + 8 * i);
        v24 = *(_QWORD *)(v11 + 288);
        sub_1B192C184(&v45, (uint64_t)v40, (uint64_t)v38, (*(unsigned __int16 *)(*(_QWORD *)(v11 + 432) + 2 * i) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v33 + 432) + 2 * v15) >> 7) & 0xF);
        *(_QWORD *)(*a4 + 8 * v16) = 0;
        if (SLODWORD(v38[4]) >= 1 && (int)v21 >= 1)
        {
          v25 = (int *)(v24 + 4 * v34);
          do
          {
            v26 = *v25++;
            v27 = *(int *)(v9[21] + 4 * v26);
            LODWORD(v26) = *v23++;
            *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a4 + 8 * v27), *(float *)&v26);
            --v21;
          }
          while (v21);
        }
        v28 = v37;
        if (SHIDWORD(v38[3]) >= 1 && v37 >= 1)
        {
          v30 = (int *)(v36 + 4 * v35);
          do
          {
            v31 = *v30++;
            v32 = (_DWORD *)(*(_QWORD *)(v11 + 120) + 8 * v31);
            LODWORD(v31) = *(_DWORD *)v22;
            v22 = (uint64_t *)((char *)v22 + 4);
            *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a3 + 8 * (int)v32[i == *v32]), *(float *)&v31);
            --v28;
          }
          while (v28);
        }
        *(float32x2_t *)(*a4 + 8 * v16) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v16), *(float32x2_t *)(*a3 + 8 * i), v39);
        v13 = *(_DWORD *)(v11 + 8);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

int *sub_1B192B4F4(int *result, int *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x2_t *v12;
  uint64_t v18;
  float *v21;
  float v22;
  float v23;
  float v25;
  float *v26;
  float *v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float *v33;
  float *v35;
  uint64_t v36;
  float v37;
  float v38;
  float32_t v39;
  float v40;
  float *v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (!a4)
  {
    v7 = *(_QWORD *)a2;
    v8 = a2[2];
    if (*(float *)(*(_QWORD *)(*(_QWORD *)a2 + 216) + 4 * v8) <= 0.0)
      goto LABEL_13;
LABEL_5:
    if (a5)
    {
      if (a5 != 4)
      {
        v9 = *(_QWORD *)a2;
        LODWORD(v10) = a2[2];
        goto LABEL_8;
      }
    }
    else if (a4 != 4)
    {
      v9 = *(_QWORD *)a2;
      v10 = a2[2];
      v23 = *(float *)(*(_QWORD *)(*(_QWORD *)a2 + 216) + 4 * v10);
      if (v23 < 1.0 && ((*result & 0x60) == 0 || (float)(v23 + -1.0) <= 0.0))
      {
LABEL_8:
        v11 = *(unsigned int *)(*(_QWORD *)(v9 + 144) + 8 * (_DWORD)v10);
        *(_QWORD *)(a3 + 24) = 2;
        *(_DWORD *)(a3 + 32) = v11;
        *(_BYTE *)(a3 + 36) = 1;
        if ((*(_WORD *)result & 0x180) == 0x80)
        {
          if ((_DWORD)v11 == 2)
          {
            result = sub_1B192B874(a2, &v43);
            if (v43 == 3 || v44 == 3)
            {
              v37 = 0.47;
              if (v44 == 3)
                v38 = 0.47;
              else
                v38 = 0.25;
              if (v43 != 3)
                v37 = 0.25;
              v29 = (float)(v37 + v38) * 0.5;
              v39 = (float)((float)(v29 * -2.0) + 1.0) * 0.5;
              v12 = *(float32x2_t **)a3;
              v12->f32[0] = v39;
              v12->f32[1] = v39;
              v28 = *(float **)(a3 + 16);
              *v28 = v29;
              goto LABEL_50;
            }
            v12 = *(float32x2_t **)a3;
            __asm { FMOV            V0.2S, #0.25 }
            **(_QWORD **)a3 = _D0;
LABEL_32:
            v28 = *(float **)(a3 + 16);
            *v28 = 0.25;
            v29 = 0.25;
LABEL_50:
            v28[1] = v29;
            v9 = *(_QWORD *)a2;
            LODWORD(v11) = *(_DWORD *)(a3 + 32);
LABEL_51:
            v40 = *(float *)(*(_QWORD *)(v9 + 216) + 4 * a2[2]);
            *v12 = vmla_n_f32(vmul_n_f32(*v12, 1.0 - v40), (float32x2_t)0x3F0000003F000000, v40);
            if ((int)v11 >= 1)
            {
              v41 = *(float **)(a3 + 16);
              v42 = v11;
              do
              {
                *v41 = (float)(1.0 - v40) * *v41;
                ++v41;
                --v42;
              }
              while (v42);
            }
            return result;
          }
          v12 = *(float32x2_t **)a3;
          __asm { FMOV            V0.2S, #0.25 }
          **(_QWORD **)a3 = _D0;
        }
        else
        {
          v12 = *(float32x2_t **)a3;
          __asm { FMOV            V0.2S, #0.25 }
          **(_QWORD **)a3 = _D0;
          if ((_DWORD)v11 == 2)
            goto LABEL_32;
        }
        if ((int)v11 >= 1)
        {
          v35 = *(float **)(a3 + 16);
          v36 = v11;
          do
          {
            *v35++ = 0.5 / (float)(int)v11;
            --v36;
          }
          while (v36);
        }
        goto LABEL_51;
      }
    }
    *(_DWORD *)(a3 + 24) = 2;
    *(_QWORD *)(a3 + 28) = 0;
    *(_BYTE *)(a3 + 36) = 0;
    v21 = *(float **)a3;
    **(_DWORD **)a3 = 1056964608;
    v22 = 0.5;
    goto LABEL_25;
  }
  if (a4 != 1)
    goto LABEL_5;
  v7 = *(_QWORD *)a2;
  LODWORD(v8) = a2[2];
LABEL_13:
  v18 = *(unsigned int *)(*(_QWORD *)(v7 + 144) + 8 * (_DWORD)v8);
  *(_QWORD *)(a3 + 24) = 2;
  *(_DWORD *)(a3 + 32) = v18;
  *(_BYTE *)(a3 + 36) = 1;
  if ((*(_WORD *)result & 0x180) == 0x80)
  {
    if ((_DWORD)v18 == 2)
    {
      result = sub_1B192B874(a2, &v43);
      if (v43 == 3 || v44 == 3)
      {
        v30 = 0.47;
        if (v44 == 3)
          v31 = 0.47;
        else
          v31 = 0.25;
        if (v43 != 3)
          v30 = 0.25;
        v22 = (float)(v30 + v31) * 0.5;
        v32 = (float)((float)(v22 * -2.0) + 1.0) * 0.5;
        v33 = *(float **)a3;
        *v33 = v32;
        v33[1] = v32;
        v21 = *(float **)(a3 + 16);
        *v21 = v22;
        goto LABEL_25;
      }
      __asm { FMOV            V0.2S, #0.25 }
      **(_QWORD **)a3 = _D0;
      goto LABEL_19;
    }
    __asm { FMOV            V0.2S, #0.25 }
    **(_QWORD **)a3 = _D0;
  }
  else
  {
    __asm { FMOV            V0.2S, #0.25 }
    **(_QWORD **)a3 = _D0;
    if ((_DWORD)v18 == 2)
    {
LABEL_19:
      v21 = *(float **)(a3 + 16);
      *v21 = 0.25;
      v22 = 0.25;
LABEL_25:
      v21[1] = v22;
      return result;
    }
  }
  if ((int)v18 >= 1)
  {
    v25 = 0.5 / (float)(int)v18;
    v26 = *(float **)(a3 + 16);
    do
    {
      *v26++ = v25;
      --v18;
    }
    while (v18);
  }
  return result;
}

int *sub_1B192B874(int *result, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_QWORD *)result;
  v3 = result[2];
  v4 = *(_QWORD *)(*(_QWORD *)result + 144);
  v5 = *(unsigned int *)(v4 + 8 * (_DWORD)v3);
  if ((int)v5 >= 1)
  {
    v6 = (int *)(*(_QWORD *)(v2 + 168) + 4 * *(int *)(v4 + 8 * v3 + 4));
    v7 = *(_QWORD *)(v2 + 24);
    do
    {
      v8 = *v6++;
      *a2++ = *(_DWORD *)(v7 + 8 * v8);
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_1B192B8C0(int *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  unsigned int v7;
  uint64_t v8;
  float v9;
  float *v10;
  float *v11;
  int v12;
  BOOL v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  float v24;
  int *v25;
  uint64_t v26;
  _DWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float *v32;
  float *v33;
  uint64_t v34;
  float *v35;
  float v36;
  uint64_t v37;
  float *v38;
  float v39;
  uint64_t v40;
  uint64_t v41;
  float *v42;
  float *v43;
  uint64_t v44;
  uint64_t v45;
  float v46;
  uint64_t v47;
  float *v48;
  size_t v49;
  _DWORD *v50;
  uint64_t v51;
  float v52;
  float *v53;
  uint64_t v54;
  char v55;
  uint64_t v56;
  float *v57;
  float v58;
  uint64_t v59;
  float *v60;
  float v61;
  uint64_t v62;
  float v63;
  float v64;
  float *v65;
  uint64_t v66;
  float *v67;
  float v68;
  float *v69;
  uint64_t v70;
  float *v71;
  float v72;
  float *v73;
  float *v74;
  uint64_t v75;
  float v76;
  float *v77;
  uint64_t v78;
  float v79;
  _BYTE v80[4];
  int v81;
  uint64_t v82;
  int v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v7 = a4 - 1;
  if ((a4 - 1) <= 1)
  {
    v8 = *(unsigned int *)(a2 + 28);
    *(_DWORD *)(a3 + 24) = 1;
    *(_DWORD *)(a3 + 28) = v8;
    *(_DWORD *)(a3 + 32) = v8;
    *(_BYTE *)(a3 + 36) = 1;
    **(float **)a3 = (float)(v8 - 2) / (float)(int)v8;
    if ((int)v8 >= 1)
    {
      v9 = 1.0 / (float)(v8 * v8);
      v10 = *(float **)(a3 + 8);
      v11 = *(float **)(a3 + 16);
      do
      {
        *v10++ = v9;
        *v11++ = v9;
        --v8;
      }
      while (v8);
    }
    return;
  }
  v12 = a4;
  if (a5)
    v14 = 1;
  else
    v14 = a4 == 0;
  if (v14)
    v15 = a5;
  else
    v15 = a4;
  v16 = *(int *)(a2 + 24);
  v17 = *(unsigned int *)(a2 + 24);
  v18 = 4 * v16;
  MEMORY[0x1E0C80A78](a1, a2);
  v19 = &v80[-((4 * v16 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v19, 4 * v16);
  if ((v12 | 4) != 4 && v15 == v12)
  {
    v19 = 0;
    v24 = 0.0;
LABEL_25:
    if (v12 == 4)
    {
      v81 = v15;
      v82 = v17;
      v34 = 0xFFFFFFFF00000000;
      v35 = (float *)v19;
      do
      {
        v36 = *v35++;
        v34 += 0x100000000;
      }
      while (v36 <= 0.0);
      v37 = v16 << 32;
      v38 = (float *)&v19[4 * v16 - 4];
      do
      {
        v39 = *v38--;
        v37 -= 0x100000000;
      }
      while (v39 <= 0.0);
      v40 = *(unsigned int *)(a2 + 24);
      *(_DWORD *)(a3 + 24) = 1;
      *(_QWORD *)(a3 + 28) = v40;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1061158912;
      v41 = *(_QWORD *)(a3 + 8);
      if ((int)v40 >= 1)
        bzero(*(void **)(a3 + 8), 4 * v40);
      *(_DWORD *)(v41 + (v34 >> 30)) = 1040187392;
      *(_DWORD *)(v41 + (v37 >> 30)) = 1040187392;
      v17 = v82;
      v15 = v81;
    }
    else
    {
      *(_DWORD *)(a3 + 24) = 1;
      *(_QWORD *)(a3 + 28) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1065353216;
    }
    if (v15 != v12)
    {
      v83 = *a1;
      MEMORY[0x1E0C80A78](v20, v21);
      bzero(&v80[-((v18 + 15) & 0xFFFFFFFFFFFFFFF0)], 4 * v16);
      v42 = sub_1B192BEA0((int *)a2, &v83, (float *)&v80[-((v18 + 15) & 0xFFFFFFFFFFFFFFF0)]);
      v43 = v42;
      v44 = *(int *)(a2 + 20);
      v45 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 408);
      v46 = *(float *)(v45 + 4 * v44);
      if (v15
        || (v42 = (float *)sub_1B2210480(*(float *)(v45 + 4 * v44), (uint64_t)&v83, v16, v42),
            v15 = (int)v42,
            (_DWORD)v42 != v12))
      {
        MEMORY[0x1E0C80A78](v42, 4 * (int)((2 * v17) | 1));
        v48 = (float *)&v80[-v47];
        bzero(&v80[-v47], v49);
        v50 = v48 + 1;
        if ((v15 - 1) > 1)
        {
          if (v15 == 4)
          {
            v82 = v17;
            v17 = 0xFFFFFFFF00000000;
            v57 = v43;
            do
            {
              v58 = *v57++;
              v17 += 0x100000000;
            }
            while (v58 <= 0.0);
            v59 = v16 << 32;
            v60 = &v43[v16 - 1];
            do
            {
              v61 = *v60--;
              v59 -= 0x100000000;
            }
            while (v61 <= 0.0);
            v56 = *(unsigned int *)(a2 + 24);
            *v48 = 0.75;
            if ((int)v56 >= 1)
              bzero(v48 + 1, 4 * v56);
            LODWORD(v51) = 0;
            *(_DWORD *)((char *)v50 + (v17 >> 30)) = 1040187392;
            v62 = v59 >> 30;
            v55 = 0;
            *(_DWORD *)((char *)v50 + v62) = 1040187392;
            LODWORD(v17) = v82;
          }
          else
          {
            v55 = 0;
            LODWORD(v51) = 0;
            LODWORD(v56) = 0;
            *v48 = 1.0;
          }
        }
        else
        {
          v51 = *(unsigned int *)(a2 + 28);
          *v48 = (float)(v51 - 2) / (float)(int)v51;
          if ((int)v51 >= 1)
          {
            v52 = 1.0 / (float)(v51 * v51);
            v53 = v48 + 1;
            v54 = v51;
            do
            {
              *v53 = v52;
              v53[v16] = v52;
              ++v53;
              --v54;
            }
            while (v54);
          }
          v55 = 1;
          LODWORD(v56) = v51;
        }
        v63 = sub_1B22104D4(&v83, v17, (float *)v19, v43, v24, v46);
        v64 = 1.0 - v63;
        **(float **)a3 = (float)((float)(1.0 - v63) * *v48) + (float)(v63 * **(float **)a3);
        if ((_DWORD)v56)
        {
          if (*(_DWORD *)(a3 + 28))
          {
            if ((int)v56 >= 1)
            {
              v65 = *(float **)(a3 + 8);
              v66 = v56;
              v67 = v48 + 1;
              do
              {
                v68 = *v67++;
                *v65 = (float)(v64 * v68) + (float)(v63 * *v65);
                ++v65;
                --v66;
              }
              while (v66);
            }
          }
          else
          {
            *(_DWORD *)(a3 + 28) = v56;
            if ((int)v56 >= 1)
            {
              v69 = *(float **)(a3 + 8);
              v70 = v56;
              v71 = v48 + 1;
              do
              {
                v72 = *v71++;
                *v69++ = v64 * v72;
                --v70;
              }
              while (v70);
            }
          }
        }
        if ((_DWORD)v51)
        {
          v73 = (float *)&v50[v16];
          if (*(_DWORD *)(a3 + 32))
          {
            if ((int)v51 >= 1)
            {
              v74 = *(float **)(a3 + 16);
              v75 = v51;
              do
              {
                v76 = *v73++;
                *v74 = (float)(v64 * v76) + (float)(v63 * *v74);
                ++v74;
                --v75;
              }
              while (v75);
            }
          }
          else
          {
            *(_DWORD *)(a3 + 32) = v51;
            *(_BYTE *)(a3 + 36) = v55;
            if ((int)v51 >= 1)
            {
              v77 = *(float **)(a3 + 16);
              v78 = v51;
              do
              {
                v79 = *v73++;
                *v77++ = v64 * v79;
                --v78;
              }
              while (v78);
            }
          }
        }
      }
    }
    return;
  }
  v22 = *(_QWORD **)a2;
  v23 = *(int *)(a2 + 16);
  v24 = *(float *)(*(_QWORD *)(*(_QWORD *)a2 + 408) + 4 * v23);
  if ((int)v16 >= 1)
  {
    v25 = (int *)(v22[45] + 4 * *(int *)(v22[42] + 8 * v23 + 4));
    v26 = v22[27];
    v27 = &v80[-((v18 + 15) & 0xFFFFFFFFFFFFFFF0)];
    v28 = v17;
    do
    {
      v29 = *v25++;
      *v27++ = *(_DWORD *)(v26 + 4 * v29);
      --v28;
    }
    while (v28);
  }
  if (!v12)
  {
    v83 = *a1;
    v20 = sub_1B2210480(v24, (uint64_t)&v83, v17, (float *)&v80[-((v18 + 15) & 0xFFFFFFFFFFFFFFF0)]);
    v12 = v20;
    v7 = v20 - 1;
  }
  if (v7 > 1)
    goto LABEL_25;
  v30 = *(unsigned int *)(a2 + 28);
  *(_DWORD *)(a3 + 24) = 1;
  *(_DWORD *)(a3 + 28) = v30;
  *(_DWORD *)(a3 + 32) = v30;
  *(_BYTE *)(a3 + 36) = 1;
  **(float **)a3 = (float)(v30 - 2) / (float)(int)v30;
  if ((int)v30 >= 1)
  {
    v31 = 1.0 / (float)(v30 * v30);
    v32 = *(float **)(a3 + 8);
    v33 = *(float **)(a3 + 16);
    do
    {
      *v32++ = v31;
      *v33++ = v31;
      --v30;
    }
    while (v30);
  }
}

float *sub_1B192BEA0(int *a1, _WORD *a2, float *a3)
{
  uint64_t v6;
  uint64_t *v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v14;
  void *__p;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v6 = a1[6];
  v7 = &v14;
  __p = 0;
  if (v6 >= 0x11)
  {
    v7 = (uint64_t *)operator new(4 * v6);
    __p = v7;
    LODWORD(v6) = a1[6];
  }
  if ((int)v6 >= 1)
  {
    v8 = (int *)(*(_QWORD *)(*(_QWORD *)a1 + 360)
               + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)a1 + 336) + 8 * a1[4] + 4));
    v9 = *(_QWORD *)(*(_QWORD *)a1 + 216);
    v10 = v6;
    v11 = v7;
    do
    {
      v12 = *v8++;
      *(_DWORD *)v11 = *(_DWORD *)(v9 + 4 * v12);
      v11 = (uint64_t *)((char *)v11 + 4);
      --v10;
    }
    while (v10);
  }
  sub_1B2210680(a2, v6, (float *)v7, a3);
  operator delete(__p);
  return a3;
}

_DWORD *sub_1B192BFA0(_DWORD *result, int *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x2_t *v11;
  uint64_t v17;
  float32x2_t *v19;
  float v20;
  float v21;
  float *v22;
  float v23;
  float *v24;
  uint64_t v25;
  float v26;
  float *v27;

  if (!a4)
  {
    v5 = *(_QWORD *)a2;
    v6 = a2[2];
    if (*(float *)(*(_QWORD *)(*(_QWORD *)a2 + 216) + 4 * v6) <= 0.0)
      goto LABEL_10;
LABEL_5:
    if (a5)
    {
      if (a5 != 4)
      {
        v7 = *(_QWORD *)a2;
        LODWORD(v8) = a2[2];
LABEL_8:
        v9 = (int)v8;
        v10 = *(unsigned int *)(*(_QWORD *)(v7 + 144) + 8 * (int)v8);
        *(_QWORD *)(a3 + 24) = 2;
        *(_DWORD *)(a3 + 32) = v10;
        *(_BYTE *)(a3 + 36) = 0;
        v11 = *(float32x2_t **)a3;
        __asm { FMOV            V0.2S, #0.375 }
        **(_QWORD **)a3 = _D0;
        if ((_DWORD)v10 == 2)
        {
          **(_QWORD **)(a3 + 16) = 0x3E0000003E000000;
        }
        else if ((int)v10 >= 1)
        {
          v24 = *(float **)(a3 + 16);
          v25 = v10;
          do
          {
            *v24++ = (float)(2.0 / (float)(int)v10) * 0.125;
            --v25;
          }
          while (v25);
        }
        v26 = *(float *)(*(_QWORD *)(v7 + 216) + 4 * v9);
        *v11 = vmla_n_f32(vmul_n_f32(*v11, 1.0 - v26), (float32x2_t)0x3F0000003F000000, v26);
        if ((int)v10 >= 1)
        {
          v27 = *(float **)(a3 + 16);
          do
          {
            *v27 = (float)(1.0 - v26) * *v27;
            ++v27;
            --v10;
          }
          while (v10);
        }
        return result;
      }
    }
    else if (a4 != 4)
    {
      v7 = *(_QWORD *)a2;
      v8 = a2[2];
      v23 = *(float *)(*(_QWORD *)(*(_QWORD *)a2 + 216) + 4 * v8);
      if (v23 < 1.0 && ((*result & 0x60) == 0 || (float)(v23 + -1.0) <= 0.0))
        goto LABEL_8;
    }
    *(_DWORD *)(a3 + 24) = 2;
    *(_QWORD *)(a3 + 28) = 0;
    *(_BYTE *)(a3 + 36) = 0;
    v19 = *(float32x2_t **)a3;
    **(_DWORD **)a3 = 1056964608;
    v20 = 0.5;
    goto LABEL_21;
  }
  if (a4 != 1)
    goto LABEL_5;
  v5 = *(_QWORD *)a2;
  LODWORD(v6) = a2[2];
LABEL_10:
  v17 = *(unsigned int *)(*(_QWORD *)(v5 + 144) + 8 * (_DWORD)v6);
  *(_QWORD *)(a3 + 24) = 2;
  *(_DWORD *)(a3 + 32) = v17;
  *(_BYTE *)(a3 + 36) = 0;
  __asm { FMOV            V0.2S, #0.375 }
  **(_QWORD **)a3 = _D0;
  if ((_DWORD)v17 == 2)
  {
    v19 = *(float32x2_t **)(a3 + 16);
    v19->i32[0] = 1040187392;
    v20 = 0.125;
LABEL_21:
    v19->f32[1] = v20;
    return result;
  }
  if ((int)v17 >= 1)
  {
    v21 = (float)(2.0 / (float)(int)v17) * 0.125;
    v22 = *(float **)(a3 + 16);
    do
    {
      *v22++ = v21;
      --v17;
    }
    while (v17);
  }
  return result;
}

void sub_1B192C184(int *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  unsigned int v7;
  uint64_t v8;
  float v9;
  int v10;
  BOOL v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  float v22;
  int *v23;
  uint64_t v24;
  _DWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float v29;
  float v30;
  float v31;
  float *v32;
  float *v33;
  float v34;
  uint64_t v35;
  float *v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  float *v40;
  float *v41;
  uint64_t v42;
  uint64_t v43;
  float v44;
  uint64_t v45;
  float *v46;
  size_t v47;
  float *v48;
  uint64_t v49;
  float v50;
  float v51;
  float v52;
  float *v53;
  int v54;
  float *v55;
  float v56;
  uint64_t v57;
  float *v58;
  float v59;
  float v60;
  float v61;
  float *v62;
  uint64_t v63;
  float v64;
  float v65;
  float *v66;
  uint64_t v67;
  float v68;
  float *v69;
  uint64_t v70;
  float v71;
  _BYTE v72[4];
  int v73;
  uint64_t v74;
  int v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v7 = a4 - 1;
  if ((a4 - 1) <= 1)
  {
    v8 = *(unsigned int *)(a2 + 28);
    *(_DWORD *)(a3 + 24) = 1;
    *(_QWORD *)(a3 + 28) = v8;
    *(_BYTE *)(a3 + 36) = 0;
    if ((_DWORD)v8 == 6)
    {
      **(_DWORD **)a3 = 1059061760;
      v9 = 0.0625;
    }
    else
    {
      v30 = 1.0 / (float)(int)v8;
      v31 = cosf(v30 * 6.2832);
      v9 = v30 * (float)(0.625 - (float)((float)((float)(v31 * 0.25) + 0.375) * (float)((float)(v31 * 0.25) + 0.375)));
      **(float **)a3 = 1.0 - (float)(v9 * (float)(int)v8);
      if ((int)v8 < 1)
        return;
    }
    v32 = *(float **)(a3 + 8);
    do
    {
      *v32++ = v9;
      --v8;
    }
    while (v8);
    return;
  }
  v10 = a4;
  if (a5)
    v12 = 1;
  else
    v12 = a4 == 0;
  if (v12)
    v13 = a5;
  else
    v13 = a4;
  v14 = *(int *)(a2 + 24);
  v15 = *(unsigned int *)(a2 + 24);
  v16 = 4 * v14;
  MEMORY[0x1E0C80A78](a1, a2);
  v17 = &v72[-((4 * v14 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v17, 4 * v14);
  if ((v10 | 4) != 4 && v13 == v10)
  {
    v17 = 0;
    v22 = 0.0;
    goto LABEL_25;
  }
  v20 = *(_QWORD **)a2;
  v21 = *(int *)(a2 + 16);
  v22 = *(float *)(*(_QWORD *)(*(_QWORD *)a2 + 408) + 4 * v21);
  if ((int)v14 >= 1)
  {
    v23 = (int *)(v20[45] + 4 * *(int *)(v20[42] + 8 * v21 + 4));
    v24 = v20[27];
    v25 = &v72[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0)];
    v26 = v15;
    do
    {
      v27 = *v23++;
      *v25++ = *(_DWORD *)(v24 + 4 * v27);
      --v26;
    }
    while (v26);
  }
  if (!v10)
  {
    v75 = *a1;
    v18 = sub_1B2210480(v22, (uint64_t)&v75, v15, (float *)&v72[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0)]);
    v10 = v18;
    v7 = v18 - 1;
  }
  if (v7 > 1)
  {
LABEL_25:
    if (v10 == 4)
    {
      v73 = v13;
      v74 = v15;
      v15 = 0xFFFFFFFF00000000;
      v33 = (float *)v17;
      do
      {
        v34 = *v33++;
        v15 += 0x100000000;
      }
      while (v34 <= 0.0);
      v35 = v14 << 32;
      v36 = (float *)&v17[4 * v14 - 4];
      do
      {
        v37 = *v36--;
        v35 -= 0x100000000;
      }
      while (v37 <= 0.0);
      v38 = *(unsigned int *)(a2 + 24);
      *(_DWORD *)(a3 + 24) = 1;
      *(_QWORD *)(a3 + 28) = v38;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1061158912;
      v39 = *(_QWORD *)(a3 + 8);
      if ((int)v38 >= 1)
        bzero(*(void **)(a3 + 8), 4 * v38);
      *(_DWORD *)(v39 + (v15 >> 30)) = 1040187392;
      *(_DWORD *)(v39 + (v35 >> 30)) = 1040187392;
      LODWORD(v15) = v74;
      v13 = v73;
    }
    else
    {
      *(_DWORD *)(a3 + 24) = 1;
      *(_QWORD *)(a3 + 28) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1065353216;
    }
    if (v13 == v10)
      return;
    v75 = *a1;
    MEMORY[0x1E0C80A78](v18, v19);
    bzero(&v72[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0)], 4 * v14);
    v40 = sub_1B192BEA0((int *)a2, &v75, (float *)&v72[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0)]);
    v41 = v40;
    v42 = *(int *)(a2 + 20);
    v43 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 408);
    v44 = *(float *)(v43 + 4 * v42);
    if (!v13)
    {
      v40 = (float *)sub_1B2210480(*(float *)(v43 + 4 * v42), (uint64_t)&v75, v14, v40);
      v13 = (int)v40;
      if ((_DWORD)v40 == v10)
        return;
    }
    MEMORY[0x1E0C80A78](v40, 4 * (int)((2 * v15) | 1));
    v46 = (float *)&v72[-v45];
    bzero(&v72[-v45], v47);
    v48 = v46 + 1;
    if ((v13 - 1) > 1)
    {
      if (v13 == 4)
      {
        v54 = v15;
        v15 = 0xFFFFFFFF00000000;
        v55 = v41;
        do
        {
          v56 = *v55++;
          v15 += 0x100000000;
        }
        while (v56 <= 0.0);
        v57 = v14 << 32;
        v58 = &v41[v14 - 1];
        do
        {
          v59 = *v58--;
          v57 -= 0x100000000;
        }
        while (v59 <= 0.0);
        v49 = *(unsigned int *)(a2 + 24);
        *v46 = 0.75;
        if ((int)v49 >= 1)
          bzero(v46 + 1, 4 * v49);
        *(float *)((char *)v48 + (v15 >> 30)) = 0.125;
        *(float *)((char *)v48 + (v57 >> 30)) = 0.125;
        LODWORD(v15) = v54;
      }
      else
      {
        LODWORD(v49) = 0;
        *v46 = 1.0;
      }
      goto LABEL_57;
    }
    v49 = *(unsigned int *)(a2 + 28);
    if ((_DWORD)v49 == 6)
    {
      *v46 = 0.625;
      v50 = 0.0625;
    }
    else
    {
      v60 = 1.0 / (float)(int)v49;
      v61 = cosf(v60 * 6.2832);
      v50 = v60 * (float)(0.625 - (float)((float)((float)(v61 * 0.25) + 0.375) * (float)((float)(v61 * 0.25) + 0.375)));
      *v46 = 1.0 - (float)(v50 * (float)(int)v49);
      if ((int)v49 < 1)
        goto LABEL_57;
    }
    v62 = v46 + 1;
    v63 = v49;
    do
    {
      *v62++ = v50;
      --v63;
    }
    while (v63);
LABEL_57:
    v64 = sub_1B22104D4(&v75, v15, (float *)v17, v41, v22, v44);
    v65 = 1.0 - v64;
    **(float **)a3 = (float)((float)(1.0 - v64) * *v46) + (float)(v64 * **(float **)a3);
    if ((_DWORD)v49)
    {
      if (*(_DWORD *)(a3 + 28))
      {
        if ((int)v49 >= 1)
        {
          v66 = *(float **)(a3 + 8);
          v67 = v49;
          do
          {
            v68 = *v48++;
            *v66 = (float)(v65 * v68) + (float)(v64 * *v66);
            ++v66;
            --v67;
          }
          while (v67);
        }
      }
      else
      {
        *(_DWORD *)(a3 + 28) = v49;
        if ((int)v49 >= 1)
        {
          v69 = *(float **)(a3 + 8);
          v70 = v49;
          do
          {
            v71 = *v48++;
            *v69++ = v65 * v71;
            --v70;
          }
          while (v70);
        }
      }
    }
    return;
  }
  v28 = *(unsigned int *)(a2 + 28);
  *(_DWORD *)(a3 + 24) = 1;
  *(_QWORD *)(a3 + 28) = v28;
  *(_BYTE *)(a3 + 36) = 0;
  if ((_DWORD)v28 == 6)
  {
    **(_DWORD **)a3 = 1059061760;
    v29 = 0.0625;
  }
  else
  {
    v51 = 1.0 / (float)(int)v28;
    v52 = cosf(v51 * 6.2832);
    v29 = v51 * (float)(0.625 - (float)((float)((float)(v52 * 0.25) + 0.375) * (float)((float)(v52 * 0.25) + 0.375)));
    **(float **)a3 = 1.0 - (float)(v29 * (float)(int)v28);
    if ((int)v28 < 1)
      return;
  }
  v53 = *(float **)(a3 + 8);
  do
  {
    *v53++ = v29;
    --v28;
  }
  while (v28);
}

void sub_1B192C778(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  uint64_t v5;
  void *v8;
  int *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  float *v23;
  uint64_t v24;
  void *__p;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  if (*(_DWORD *)(v5 + 52))
  {
    v8 = 0;
    v9 = *(int **)(v5 + 8);
    v10 = *(_QWORD **)(*((_QWORD *)v9 + 57) + 8 * a5);
    v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 16) + 456) + 8 * a5);
    v12 = v9[5];
    v23 = (float *)&v24;
    __p = 0;
    if (v12 >= 0x11)
    {
      v8 = operator new(4 * v12);
      __p = v8;
      v23 = (float *)v8;
    }
    if (*v9 >= 1)
    {
      v13 = 0;
      do
      {
        v14 = *(int *)(*(_QWORD *)(v5 + 168) + 4 * v13);
        if ((_DWORD)v14 != -1)
        {
          v15 = *(int *)(*(_QWORD *)(v11 + 96) + 4 * v14);
          v16 = (unsigned int *)(*(_QWORD *)(*v10 + 24) + 8 * v13);
          v17 = *v16;
          if ((int)v17 < 1)
          {
            *(_QWORD *)(*a4 + 8 * v15) = 0;
          }
          else
          {
            v18 = v10[3] + 4 * (int)v16[1];
            v19 = v23;
            v20 = v17;
            do
            {
              *v19++ = 1.0 / (float)(int)v17;
              --v20;
            }
            while (v20);
            *(_QWORD *)(*a4 + 8 * v15) = 0;
            v21 = 0;
            v22 = 4 * v17;
            do
            {
              *(float32x2_t *)(*a4 + 8 * v15) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v15), *(float32x2_t *)(*a3 + 8 * *(int *)(v18 + v21)), v23[v21 / 4]);
              v21 += 4;
            }
            while (v22 != v21);
          }
        }
        ++v13;
      }
      while (v13 < *v9);
      v8 = __p;
    }
    operator delete(v8);
  }
}

void sub_1B192C92C(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  uint64_t v20;
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  _QWORD v45[5];
  int v46;
  int v47;
  int v48;
  _BYTE *v49;
  int v50;
  int v51;
  _BYTE v52[32];
  void *__p;
  _QWORD v54[3];

  v54[1] = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v46 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v9 = v8[1];
  v10 = *(_QWORD *)(v8[60] + 8 * a5);
  v11 = *(_QWORD *)(*(_QWORD *)(v9 + 456) + 8 * a5);
  v39 = v8[2];
  v12 = *(_QWORD **)(*(_QWORD *)(v39 + 456) + 8 * a5);
  v42 = v9;
  v13 = *(unsigned int *)(v9 + 16);
  v14 = v52;
  v49 = v52;
  v50 = v13;
  v51 = 8;
  __p = 0;
  if (v13 < 9)
  {
    v15 = 0;
  }
  else
  {
    v15 = operator new(4 * v13);
    __p = v15;
    v49 = v15;
    v51 = v13;
    v14 = v15;
  }
  v45[0] = v54;
  v45[1] = 0;
  v45[2] = v14;
  memset(&v45[3], 0, 13);
  if (*(_BYTE *)(v11 + 12) || !**(_DWORD **)a1)
  {
    LODWORD(v45[3]) = 2;
    LODWORD(v45[4]) = 0;
    v54[0] = 0x3F0000003F000000;
    v40 = 1;
  }
  else
  {
    v40 = 0;
  }
  v43 = v42;
  if (*(int *)(v42 + 4) >= 1)
  {
    v16 = 0;
    v41 = v8;
    do
    {
      v17 = *(int *)(v8[27] + 4 * v16);
      if ((_DWORD)v17 != -1)
      {
        v18 = (int *)(v12[18] + 4 * *(int *)(v12[12] + 4 * v17));
        if ((*(_BYTE *)(v12[21] + *v18) & 1) != 0)
        {
          v35 = v12[9];
          v36 = *(unsigned __int16 *)(v35 + 2 * v17);
          if (*(_WORD *)(v35 + 2 * v17))
          {
            v37 = 0;
            do
            {
              sub_1B2208948((_QWORD *)v11, v16, *(unsigned __int16 *)(*(_QWORD *)(v10 + 40)+ 2 * (v37 + *(int *)(*(_QWORD *)(*(_QWORD *)(v10 + 32) + 96) + 4 * v17))), &v47);
              v38 = v18[v37];
              *(_QWORD *)(*a4 + 8 * v38) = 0;
              *(float32x2_t *)(*a4 + 8 * v38) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v38), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v47));
              *(float32x2_t *)(*a4 + 8 * v38) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v38), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v48));
              ++v37;
            }
            while (v36 != v37);
          }
        }
        else
        {
          if ((v40 & 1) == 0)
          {
            v44 = v16;
            if (*(float *)(*(_QWORD *)(v42 + 216) + 4 * v16) <= 0.0)
              v19 = 1;
            else
              v19 = 4;
            sub_1B192B4F4(&v46, (int *)&v43, (uint64_t)v45, v19, (*(unsigned __int16 *)(*(_QWORD *)(v39 + 432) + 2 * v17) >> 7) & 0xF);
          }
          sub_1B2208948((_QWORD *)v11, v16, 0, &v47);
          v20 = *v18;
          *(_QWORD *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v20), *(float32x2_t *)(*a3 + 8 * v47), *(float *)v54);
          *(float32x2_t *)(*a4 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v20), *(float32x2_t *)(*a3 + 8 * v48), *((float *)v54 + 1));
          if (SLODWORD(v45[4]) >= 1)
          {
            v21 = (unsigned int *)(*(_QWORD *)(v42 + 144) + 8 * v16);
            v22 = *v21;
            if ((int)v22 >= 1)
            {
              v23 = 0;
              v24 = *(_QWORD *)(v42 + 168) + 4 * (int)v21[1];
              do
              {
                v25 = *(int *)(v24 + 4 * v23);
                if (BYTE4(v45[4]))
                {
                  v26 = (int *)(v12[12] + 4 * *(int *)(v41[21] + 4 * v25));
                  v27 = *a4;
                  v28 = *a4;
                }
                else
                {
                  v29 = 0;
                  v30 = (2 * (int)v25) | 1;
                  v31 = *(_QWORD *)(v42 + 24);
                  v32 = *(_QWORD *)(v42 + 72) + 4 * *(int *)(v31 + 4 * v30);
                  v33 = *(_DWORD *)(v31 + 8 * v25);
                  do
                    v34 = *(unsigned int *)(v32 + 4 * v29++);
                  while (v16 != v34);
                  if ((int)v29 + 1 < v33)
                    v33 = 0;
                  v26 = (int *)(*(_QWORD *)(v11 + 24)
                              + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)v11 + 24) + 4 * v30)
                              + 4 * ((int)v29 - v33 + 1));
                  v28 = *a4;
                  v27 = *a3;
                }
                *(float32x2_t *)(v28 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(v28 + 8 * v20), *(float32x2_t *)(v27 + 8 * *v26), *(float *)&v49[4 * v23++]);
              }
              while (v23 != v22);
            }
          }
        }
      }
      ++v16;
      v8 = v41;
    }
    while (v16 < *(int *)(v42 + 4));
    v15 = __p;
  }
  operator delete(v15);
}

void sub_1B192CD04(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _BOOL4 v14;
  _QWORD *v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t *v24;
  _DWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  float v43;
  _QWORD *v44;
  int v45;
  unsigned int v46;
  float v47;
  float v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  _BOOL4 v53;
  _QWORD *v54;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  float v60;
  _QWORD v61[2];
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  _QWORD v67[5];
  uint64_t *v68;
  unsigned int v69;
  int v70;
  uint64_t v71;
  _DWORD *v72;
  uint64_t *v73;
  int v74;
  int v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v54 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v66 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v57 = v54[1];
  v49 = v54[2];
  v58 = *(_QWORD *)(*(_QWORD *)(v57 + 456) + 8 * a5);
  if (*(_BYTE *)(v58 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v53 = v7;
  v56 = *(_QWORD **)(v54[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v49 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v57 + 20);
  v73 = &v76;
  v74 = 2 * v9;
  v75 = 32;
  v77 = 0;
  if (2 * v9 >= 0x21)
  {
    v77 = (uint64_t *)operator new(8 * v9);
    v73 = v77;
    v75 = 2 * v9;
    v9 = *(_DWORD *)(v57 + 20);
  }
  v10 = 0;
  v68 = &v71;
  v69 = v9;
  v70 = 16;
  v72 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v72 = v10;
    v68 = (uint64_t *)v10;
    v70 = v9;
  }
  v61[0] = v57;
  v61[1] = v49;
  if (*(int *)(v57 + 8) >= 1)
  {
    v50 = v8;
    v11 = 0;
    v13 = v54;
    v12 = a3;
    v14 = v53;
    v15 = v56;
    do
    {
      v59 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v59 != -1)
      {
        v16 = *(int *)(*(_QWORD *)(v58 + 96) + 4 * v11);
        v17 = (int *)(*(_QWORD *)(v58 + 144) + 4 * v16);
        v18 = *(int *)(v50[12] + 4 * v59);
        v19 = (int *)(v50[18] + 4 * v18);
        v20 = *v19;
        v21 = v50[21];
        if ((*(_BYTE *)(v21 + v20) & 1) == 0 && v14)
        {
          *(_QWORD *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * *v19) = vadd_f32(*(float32x2_t *)(*v12 + 8 * *v17), *(float32x2_t *)(*a4 + 8 * *v19));
        }
        else if ((*(_BYTE *)(v21 + v20) & 1) != 0)
        {
          v34 = v50[9];
          v35 = *(unsigned __int16 *)(v34 + 2 * v59);
          if (*(_WORD *)(v34 + 2 * v59))
          {
            v36 = 0;
            v51 = *(_QWORD *)(v58 + 144) + 4 * v16;
            v52 = *(_QWORD *)(v58 + 168) + v16;
            v37 = v21 + v18;
            do
            {
              v38 = *(unsigned __int16 *)(v15[5] + 2 * (v36 + *(int *)(*(_QWORD *)(v15[4] + 96) + 4 * v59)));
              v39 = v17[v38];
              v40 = v19[v36];
              *(_QWORD *)(*a4 + 8 * v40) = 0;
              if (!v14 && (*(_BYTE *)(v37 + v36) & 8) != 0)
              {
                v41 = v37;
                sub_1B22087A4((_QWORD *)v58, v11, v38, v67);
                if ((*(_BYTE *)(v52 + v38) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v52 + v38) & 0x20) != 0)
                  {
                    v46 = v38 == 0;
                    v44 = v56;
                    v45 = v11;
                  }
                  else
                  {
                    v44 = v56;
                    v45 = v11;
                    v46 = v38;
                  }
                  v47 = sub_1B221C7C8(v44, v45, v46, v59);
                  v48 = 1.0 - v47;
                  v43 = v47 + (float)((float)(1.0 - v47) * 0.75);
                  v42 = v48 * 0.125;
                }
                else
                {
                  v42 = 0.125;
                  v43 = 0.75;
                }
                v13 = v54;
                v12 = a3;
                v14 = v53;
                v15 = v56;
                v37 = v41;
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * SLODWORD(v67[0])), v42);
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * SHIDWORD(v67[0])), v42);
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * v39), v43);
                v17 = (int *)v51;
              }
              else
              {
                *(float32x2_t *)(*a4 + 8 * v40) = vadd_f32(*(float32x2_t *)(*v12 + 8 * v39), *(float32x2_t *)(*a4 + 8 * v40));
              }
              ++v36;
            }
            while (v35 != v36);
          }
        }
        else
        {
          v23 = *(int *)(*(_QWORD *)(v57 + 336) + 8 * v11);
          v60 = 0.0;
          v24 = v73;
          v25 = (_DWORD *)v73 + v23;
          v67[0] = &v60;
          v67[1] = v73;
          v67[2] = v25;
          memset(&v67[3], 0, 13);
          v62 = v11;
          v63 = v59;
          v64 = *(_DWORD *)(*(_QWORD *)(v61[0] + 336) + 8 * v11);
          v65 = *(_DWORD *)(*(_QWORD *)(v61[0] + 264) + 8 * v11);
          sub_1B192B8C0(&v66, (uint64_t)v61, (uint64_t)v67, (*(unsigned __int16 *)(*(_QWORD *)(v57 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v49 + 432) + 2 * v59) >> 7) & 0xF);
          v13 = v54;
          v26 = *v17;
          v27 = *v19;
          *(_QWORD *)(*a4 + 8 * v27) = 0;
          if (SLODWORD(v67[4]) >= 1)
          {
            v28 = *(_QWORD *)(v57 + 264);
            v29 = *(unsigned int *)(v28 + 8 * v11);
            if ((int)v29 >= 1)
            {
              v30 = (int *)(*(_QWORD *)(v57 + 288) + 4 * *(int *)(v28 + ((8 * v11) | 4)));
              do
              {
                v31 = *v30++;
                v32 = *(int *)(v50[12] + 4 * *(int *)(v54[21] + 4 * v31));
                LODWORD(v31) = *v25++;
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a4 + 8 * v32), *(float *)&v31);
                --v29;
              }
              while (v29);
            }
          }
          v12 = a3;
          if (SHIDWORD(v67[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v58, v11, v68);
            v13 = v54;
            v12 = a3;
            if ((int)v23 >= 1)
            {
              v33 = 0;
              do
              {
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a3 + 8 * *(int *)((char *)v68 + v33)), *(float *)((char *)v24 + v33));
                v33 += 4;
              }
              while (4 * v23 != v33);
            }
          }
          *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*v12 + 8 * v26), v60);
          v14 = v53;
          v15 = v56;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v57 + 8));
    v10 = v72;
  }
  operator delete(v10);
  operator delete(v77);
}

void sub_1B192D26C(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  uint64_t v20;
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  _QWORD v45[5];
  int v46;
  int v47;
  int v48;
  _BYTE *v49;
  int v50;
  int v51;
  _BYTE v52[32];
  void *__p;
  _QWORD v54[3];

  v54[1] = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v46 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v9 = v8[1];
  v10 = *(_QWORD *)(v8[60] + 8 * a5);
  v11 = *(_QWORD *)(*(_QWORD *)(v9 + 456) + 8 * a5);
  v39 = v8[2];
  v12 = *(_QWORD **)(*(_QWORD *)(v39 + 456) + 8 * a5);
  v42 = v9;
  v13 = *(unsigned int *)(v9 + 16);
  v14 = v52;
  v49 = v52;
  v50 = v13;
  v51 = 8;
  __p = 0;
  if (v13 < 9)
  {
    v15 = 0;
  }
  else
  {
    v15 = operator new(4 * v13);
    __p = v15;
    v49 = v15;
    v51 = v13;
    v14 = v15;
  }
  v45[0] = v54;
  v45[1] = 0;
  v45[2] = v14;
  memset(&v45[3], 0, 13);
  if (*(_BYTE *)(v11 + 12) || !**(_DWORD **)a1)
  {
    LODWORD(v45[3]) = 2;
    LODWORD(v45[4]) = 0;
    v54[0] = 0x3F0000003F000000;
    v40 = 1;
  }
  else
  {
    v40 = 0;
  }
  v43 = v42;
  if (*(int *)(v42 + 4) >= 1)
  {
    v16 = 0;
    v41 = v8;
    do
    {
      v17 = *(int *)(v8[27] + 4 * v16);
      if ((_DWORD)v17 != -1)
      {
        v18 = (int *)(v12[18] + 4 * *(int *)(v12[12] + 4 * v17));
        if ((*(_BYTE *)(v12[21] + *v18) & 1) != 0)
        {
          v35 = v12[9];
          v36 = *(unsigned __int16 *)(v35 + 2 * v17);
          if (*(_WORD *)(v35 + 2 * v17))
          {
            v37 = 0;
            do
            {
              sub_1B2208948((_QWORD *)v11, v16, *(unsigned __int16 *)(*(_QWORD *)(v10 + 40)+ 2 * (v37 + *(int *)(*(_QWORD *)(*(_QWORD *)(v10 + 32) + 96) + 4 * v17))), &v47);
              v38 = v18[v37];
              *(_QWORD *)(*a4 + 8 * v38) = 0;
              *(float32x2_t *)(*a4 + 8 * v38) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v38), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v47));
              *(float32x2_t *)(*a4 + 8 * v38) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v38), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v48));
              ++v37;
            }
            while (v36 != v37);
          }
        }
        else
        {
          if ((v40 & 1) == 0)
          {
            v44 = v16;
            if (*(float *)(*(_QWORD *)(v42 + 216) + 4 * v16) <= 0.0)
              v19 = 1;
            else
              v19 = 4;
            sub_1B192BFA0(&v46, (int *)&v43, (uint64_t)v45, v19, (*(unsigned __int16 *)(*(_QWORD *)(v39 + 432) + 2 * v17) >> 7) & 0xF);
          }
          sub_1B2208948((_QWORD *)v11, v16, 0, &v47);
          v20 = *v18;
          *(_QWORD *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v20), *(float32x2_t *)(*a3 + 8 * v47), *(float *)v54);
          *(float32x2_t *)(*a4 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v20), *(float32x2_t *)(*a3 + 8 * v48), *((float *)v54 + 1));
          if (SLODWORD(v45[4]) >= 1)
          {
            v21 = (unsigned int *)(*(_QWORD *)(v42 + 144) + 8 * v16);
            v22 = *v21;
            if ((int)v22 >= 1)
            {
              v23 = 0;
              v24 = *(_QWORD *)(v42 + 168) + 4 * (int)v21[1];
              do
              {
                v25 = *(int *)(v24 + 4 * v23);
                if (BYTE4(v45[4]))
                {
                  v26 = (int *)(v12[12] + 4 * *(int *)(v41[21] + 4 * v25));
                  v27 = *a4;
                  v28 = *a4;
                }
                else
                {
                  v29 = 0;
                  v30 = (2 * (int)v25) | 1;
                  v31 = *(_QWORD *)(v42 + 24);
                  v32 = *(_QWORD *)(v42 + 72) + 4 * *(int *)(v31 + 4 * v30);
                  v33 = *(_DWORD *)(v31 + 8 * v25);
                  do
                    v34 = *(unsigned int *)(v32 + 4 * v29++);
                  while (v16 != v34);
                  if ((int)v29 + 1 < v33)
                    v33 = 0;
                  v26 = (int *)(*(_QWORD *)(v11 + 24)
                              + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)v11 + 24) + 4 * v30)
                              + 4 * ((int)v29 - v33 + 1));
                  v28 = *a4;
                  v27 = *a3;
                }
                *(float32x2_t *)(v28 + 8 * v20) = vmla_n_f32(*(float32x2_t *)(v28 + 8 * v20), *(float32x2_t *)(v27 + 8 * *v26), *(float *)&v49[4 * v23++]);
              }
              while (v23 != v22);
            }
          }
        }
      }
      ++v16;
      v8 = v41;
    }
    while (v16 < *(int *)(v42 + 4));
    v15 = __p;
  }
  operator delete(v15);
}

void sub_1B192D644(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _BOOL4 v14;
  _QWORD *v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t *v24;
  _DWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  float v43;
  _QWORD *v44;
  int v45;
  unsigned int v46;
  float v47;
  float v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  _BOOL4 v53;
  _QWORD *v54;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  float v60;
  _QWORD v61[2];
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  _QWORD v67[5];
  uint64_t *v68;
  unsigned int v69;
  int v70;
  uint64_t v71;
  _DWORD *v72;
  uint64_t *v73;
  int v74;
  int v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v54 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v66 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v57 = v54[1];
  v49 = v54[2];
  v58 = *(_QWORD *)(*(_QWORD *)(v57 + 456) + 8 * a5);
  if (*(_BYTE *)(v58 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v53 = v7;
  v56 = *(_QWORD **)(v54[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v49 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v57 + 20);
  v73 = &v76;
  v74 = 2 * v9;
  v75 = 32;
  v77 = 0;
  if (2 * v9 >= 0x21)
  {
    v77 = (uint64_t *)operator new(8 * v9);
    v73 = v77;
    v75 = 2 * v9;
    v9 = *(_DWORD *)(v57 + 20);
  }
  v10 = 0;
  v68 = &v71;
  v69 = v9;
  v70 = 16;
  v72 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v72 = v10;
    v68 = (uint64_t *)v10;
    v70 = v9;
  }
  v61[0] = v57;
  v61[1] = v49;
  if (*(int *)(v57 + 8) >= 1)
  {
    v50 = v8;
    v11 = 0;
    v13 = v54;
    v12 = a3;
    v14 = v53;
    v15 = v56;
    do
    {
      v59 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v59 != -1)
      {
        v16 = *(int *)(*(_QWORD *)(v58 + 96) + 4 * v11);
        v17 = (int *)(*(_QWORD *)(v58 + 144) + 4 * v16);
        v18 = *(int *)(v50[12] + 4 * v59);
        v19 = (int *)(v50[18] + 4 * v18);
        v20 = *v19;
        v21 = v50[21];
        if ((*(_BYTE *)(v21 + v20) & 1) == 0 && v14)
        {
          *(_QWORD *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * *v19) = vadd_f32(*(float32x2_t *)(*v12 + 8 * *v17), *(float32x2_t *)(*a4 + 8 * *v19));
        }
        else if ((*(_BYTE *)(v21 + v20) & 1) != 0)
        {
          v34 = v50[9];
          v35 = *(unsigned __int16 *)(v34 + 2 * v59);
          if (*(_WORD *)(v34 + 2 * v59))
          {
            v36 = 0;
            v51 = *(_QWORD *)(v58 + 144) + 4 * v16;
            v52 = *(_QWORD *)(v58 + 168) + v16;
            v37 = v21 + v18;
            do
            {
              v38 = *(unsigned __int16 *)(v15[5] + 2 * (v36 + *(int *)(*(_QWORD *)(v15[4] + 96) + 4 * v59)));
              v39 = v17[v38];
              v40 = v19[v36];
              *(_QWORD *)(*a4 + 8 * v40) = 0;
              if (!v14 && (*(_BYTE *)(v37 + v36) & 8) != 0)
              {
                v41 = v37;
                sub_1B22087A4((_QWORD *)v58, v11, v38, v67);
                if ((*(_BYTE *)(v52 + v38) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v52 + v38) & 0x20) != 0)
                  {
                    v46 = v38 == 0;
                    v44 = v56;
                    v45 = v11;
                  }
                  else
                  {
                    v44 = v56;
                    v45 = v11;
                    v46 = v38;
                  }
                  v47 = sub_1B221C7C8(v44, v45, v46, v59);
                  v48 = 1.0 - v47;
                  v43 = v47 + (float)((float)(1.0 - v47) * 0.75);
                  v42 = v48 * 0.125;
                }
                else
                {
                  v42 = 0.125;
                  v43 = 0.75;
                }
                v13 = v54;
                v12 = a3;
                v14 = v53;
                v15 = v56;
                v37 = v41;
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * SLODWORD(v67[0])), v42);
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * SHIDWORD(v67[0])), v42);
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * v39), v43);
                v17 = (int *)v51;
              }
              else
              {
                *(float32x2_t *)(*a4 + 8 * v40) = vadd_f32(*(float32x2_t *)(*v12 + 8 * v39), *(float32x2_t *)(*a4 + 8 * v40));
              }
              ++v36;
            }
            while (v35 != v36);
          }
        }
        else
        {
          v23 = *(int *)(*(_QWORD *)(v57 + 336) + 8 * v11);
          v60 = 0.0;
          v24 = v73;
          v25 = (_DWORD *)v73 + v23;
          v67[0] = &v60;
          v67[1] = v73;
          v67[2] = v25;
          memset(&v67[3], 0, 13);
          v62 = v11;
          v63 = v59;
          v64 = *(_DWORD *)(*(_QWORD *)(v61[0] + 336) + 8 * v11);
          v65 = *(_DWORD *)(*(_QWORD *)(v61[0] + 264) + 8 * v11);
          sub_1B192C184(&v66, (uint64_t)v61, (uint64_t)v67, (*(unsigned __int16 *)(*(_QWORD *)(v57 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v49 + 432) + 2 * v59) >> 7) & 0xF);
          v13 = v54;
          v26 = *v17;
          v27 = *v19;
          *(_QWORD *)(*a4 + 8 * v27) = 0;
          if (SLODWORD(v67[4]) >= 1)
          {
            v28 = *(_QWORD *)(v57 + 264);
            v29 = *(unsigned int *)(v28 + 8 * v11);
            if ((int)v29 >= 1)
            {
              v30 = (int *)(*(_QWORD *)(v57 + 288) + 4 * *(int *)(v28 + ((8 * v11) | 4)));
              do
              {
                v31 = *v30++;
                v32 = *(int *)(v50[12] + 4 * *(int *)(v54[21] + 4 * v31));
                LODWORD(v31) = *v25++;
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a4 + 8 * v32), *(float *)&v31);
                --v29;
              }
              while (v29);
            }
          }
          v12 = a3;
          if (SHIDWORD(v67[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v58, v11, v68);
            v13 = v54;
            v12 = a3;
            if ((int)v23 >= 1)
            {
              v33 = 0;
              do
              {
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a3 + 8 * *(int *)((char *)v68 + v33)), *(float *)((char *)v24 + v33));
                v33 += 4;
              }
              while (4 * v23 != v33);
            }
          }
          *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*v12 + 8 * v26), v60);
          v14 = v53;
          v15 = v56;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v57 + 8));
    v10 = v72;
  }
  operator delete(v10);
  operator delete(v77);
}

void sub_1B192DBAC(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  void *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t *v25;
  int v26;
  int v27;
  uint64_t v28;
  void *__p;
  uint64_t v30;

  v8 = 0;
  v30 = *MEMORY[0x1E0C80C00];
  v21 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v22 = v21[1];
  v9 = *(_QWORD *)(v21[60] + 8 * a5);
  v10 = *(_QWORD **)(*(_QWORD *)(v22 + 456) + 8 * a5);
  v11 = *(_QWORD **)(*(_QWORD *)(v21[2] + 456) + 8 * a5);
  v12 = *(unsigned int *)(v22 + 16);
  v25 = &v28;
  v26 = v12;
  v27 = 8;
  __p = 0;
  if (v12 >= 9)
  {
    v8 = operator new(4 * v12);
    __p = v8;
    v25 = (uint64_t *)v8;
    v27 = v12;
  }
  if (*(int *)(v22 + 4) >= 1)
  {
    v13 = 0;
    do
    {
      v14 = *(int *)(v21[27] + 4 * v13);
      if ((_DWORD)v14 != -1)
      {
        v15 = (int *)(v11[18] + 4 * *(int *)(v11[12] + 4 * v14));
        if ((*(_BYTE *)(v11[21] + *v15) & 1) != 0)
        {
          v17 = v11[9];
          v18 = *(unsigned __int16 *)(v17 + 2 * v14);
          if (*(_WORD *)(v17 + 2 * v14))
          {
            v19 = 0;
            do
            {
              sub_1B2208948(v10, v13, *(unsigned __int16 *)(*(_QWORD *)(v9 + 40)+ 2 * (v19 + *(int *)(*(_QWORD *)(*(_QWORD *)(v9 + 32) + 96) + 4 * v14))), &v23);
              v20 = v15[v19];
              *(_QWORD *)(*a4 + 8 * v20) = 0;
              *(float32x2_t *)(*a4 + 8 * v20) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v20), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v23));
              *(float32x2_t *)(*a4 + 8 * v20) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v20), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v24));
              ++v19;
            }
            while (v18 != v19);
          }
        }
        else
        {
          sub_1B2208948(v10, v13, 0, &v23);
          v16 = *v15;
          *(_QWORD *)(*a4 + 8 * v16) = 0;
          *(float32x2_t *)(*a4 + 8 * v16) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v16), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v23));
          *(float32x2_t *)(*a4 + 8 * v16) = vmla_f32(*(float32x2_t *)(*a4 + 8 * v16), (float32x2_t)0x3F0000003F000000, *(float32x2_t *)(*a3 + 8 * v24));
        }
      }
      ++v13;
    }
    while (v13 < *(int *)(v22 + 4));
    v8 = __p;
  }
  operator delete(v8);
}

void sub_1B192DDE8(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  _QWORD *v11;
  unsigned int v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  float32x2_t *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  _QWORD *v36;
  int v37;
  unsigned int v38;
  float v39;
  float v40;
  _QWORD *v41;
  _BOOL4 v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  _DWORD v50[2];
  uint64_t *v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  void *__p;
  uint64_t *v56;
  int v57;
  int v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v7 = v6[2];
  v47 = v6;
  v48 = v6[1];
  v8 = v6[60];
  v9 = *(_QWORD *)(v7 + 456);
  v49 = *(_QWORD *)(*(_QWORD *)(v48 + 456) + 8 * a5);
  if (*(_BYTE *)(v49 + 12))
    v10 = 1;
  else
    v10 = **(_DWORD **)a1 == 0;
  v42 = v10;
  v11 = *(_QWORD **)(v8 + 8 * a5);
  v41 = *(_QWORD **)(v9 + 8 * a5);
  v12 = *(_DWORD *)(v48 + 20);
  v56 = &v59;
  v57 = 2 * v12;
  v58 = 32;
  v60 = 0;
  if (2 * v12 >= 0x21)
  {
    v60 = operator new(8 * v12);
    v56 = (uint64_t *)v60;
    v58 = 2 * v12;
    v12 = *(_DWORD *)(v48 + 20);
  }
  v13 = 0;
  v51 = &v54;
  v52 = v12;
  v53 = 16;
  __p = 0;
  if (v12 >= 0x11)
  {
    v13 = operator new(4 * v12);
    __p = v13;
    v51 = (uint64_t *)v13;
    v53 = v12;
  }
  if (*(int *)(v48 + 8) >= 1)
  {
    v14 = 0;
    v15 = a3;
    v16 = v42;
    while (1)
    {
      v17 = *(int *)(v47[30] + 4 * v14);
      if ((_DWORD)v17 != -1)
      {
        v18 = *(int *)(*(_QWORD *)(v49 + 96) + 4 * v14);
        v19 = (int *)(*(_QWORD *)(v49 + 144) + 4 * v18);
        v20 = *(int *)(v41[12] + 4 * v17);
        v21 = (int *)(v41[18] + 4 * v20);
        v22 = *v21;
        v23 = v41[21];
        if ((*(_BYTE *)(v23 + v22) & 1) == 0 && v16)
        {
          *(_QWORD *)(*a4 + 8 * v22) = 0;
          v25 = (float32x2_t *)(*a4 + 8 * *v21);
          v26 = *v19;
        }
        else
        {
          if ((*(_BYTE *)(v23 + v22) & 1) != 0)
          {
            v27 = v41[9];
            v28 = *(unsigned __int16 *)(v27 + 2 * v17);
            if (*(_WORD *)(v27 + 2 * v17))
            {
              v29 = 0;
              v45 = *(_QWORD *)(v49 + 168) + v18;
              v46 = *(unsigned __int16 *)(v27 + 2 * v17);
              v30 = v23 + v20;
              v44 = v30;
              do
              {
                v31 = *(unsigned __int16 *)(v11[5] + 2 * (v29 + *(int *)(*(_QWORD *)(v11[4] + 96) + 4 * v17)));
                v32 = v19[v31];
                v33 = v21[v29];
                *(_QWORD *)(*a4 + 8 * v33) = 0;
                if (!v16 && (*(_BYTE *)(v30 + v29) & 8) != 0)
                {
                  sub_1B22087A4((_QWORD *)v49, v14, v31, v50);
                  if ((*(_BYTE *)(v45 + v31) & 0x10) != 0)
                  {
                    if ((*(_BYTE *)(v45 + v31) & 0x20) != 0)
                    {
                      v38 = v31 == 0;
                      v36 = v11;
                      v37 = v14;
                    }
                    else
                    {
                      v36 = v11;
                      v37 = v14;
                      v38 = v31;
                    }
                    v39 = sub_1B221C7C8(v36, v37, v38, v17);
                    v40 = 1.0 - v39;
                    v35 = v39 + (float)((float)(1.0 - v39) * 0.75);
                    v34 = v40 * 0.125;
                  }
                  else
                  {
                    v34 = 0.125;
                    v35 = 0.75;
                  }
                  v15 = a3;
                  v30 = v44;
                  v16 = v42;
                  v28 = v46;
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v50[0]), v34);
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v50[1]), v34);
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v32), v35);
                }
                else
                {
                  *(float32x2_t *)(*a4 + 8 * v33) = vadd_f32(*(float32x2_t *)(*v15 + 8 * v32), *(float32x2_t *)(*a4 + 8 * v33));
                }
                ++v29;
              }
              while (v28 != v29);
            }
            goto LABEL_19;
          }
          v26 = *v19;
          *(_QWORD *)(*a4 + 8 * v22) = 0;
          v25 = (float32x2_t *)(*a4 + 8 * v22);
        }
        *v25 = vadd_f32(*(float32x2_t *)(*v15 + 8 * v26), *v25);
      }
LABEL_19:
      if (++v14 >= *(int *)(v48 + 8))
      {
        v13 = __p;
        break;
      }
    }
  }
  operator delete(v13);
  operator delete(v60);
}

void sub_1B192E194(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _BOOL4 v14;
  _QWORD *v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t *v24;
  _DWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  float v43;
  _QWORD *v44;
  int v45;
  unsigned int v46;
  float v47;
  float v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  _BOOL4 v53;
  _QWORD *v54;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  float v60;
  _QWORD v61[2];
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  _QWORD v67[5];
  uint64_t *v68;
  unsigned int v69;
  int v70;
  uint64_t v71;
  _DWORD *v72;
  uint64_t *v73;
  int v74;
  int v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v54 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v66 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v57 = v54[1];
  v49 = v54[2];
  v58 = *(_QWORD *)(*(_QWORD *)(v57 + 456) + 8 * a5);
  if (*(_BYTE *)(v58 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v53 = v7;
  v56 = *(_QWORD **)(v54[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v49 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v57 + 20);
  v73 = &v76;
  v74 = 2 * v9;
  v75 = 32;
  v77 = 0;
  if (2 * v9 >= 0x21)
  {
    v77 = (uint64_t *)operator new(8 * v9);
    v73 = v77;
    v75 = 2 * v9;
    v9 = *(_DWORD *)(v57 + 20);
  }
  v10 = 0;
  v68 = &v71;
  v69 = v9;
  v70 = 16;
  v72 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v72 = v10;
    v68 = (uint64_t *)v10;
    v70 = v9;
  }
  v61[0] = v57;
  v61[1] = v49;
  if (*(int *)(v57 + 8) >= 1)
  {
    v50 = v8;
    v11 = 0;
    v13 = v54;
    v12 = a3;
    v14 = v53;
    v15 = v56;
    do
    {
      v59 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v59 != -1)
      {
        v16 = *(int *)(*(_QWORD *)(v58 + 96) + 4 * v11);
        v17 = (int *)(*(_QWORD *)(v58 + 144) + 4 * v16);
        v18 = *(int *)(v50[12] + 4 * v59);
        v19 = (int *)(v50[18] + 4 * v18);
        v20 = *v19;
        v21 = v50[21];
        if ((*(_BYTE *)(v21 + v20) & 1) == 0 && v14)
        {
          *(_QWORD *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * *v19) = vadd_f32(*(float32x2_t *)(*v12 + 8 * *v17), *(float32x2_t *)(*a4 + 8 * *v19));
        }
        else if ((*(_BYTE *)(v21 + v20) & 1) != 0)
        {
          v34 = v50[9];
          v35 = *(unsigned __int16 *)(v34 + 2 * v59);
          if (*(_WORD *)(v34 + 2 * v59))
          {
            v36 = 0;
            v51 = *(_QWORD *)(v58 + 144) + 4 * v16;
            v52 = *(_QWORD *)(v58 + 168) + v16;
            v37 = v21 + v18;
            do
            {
              v38 = *(unsigned __int16 *)(v15[5] + 2 * (v36 + *(int *)(*(_QWORD *)(v15[4] + 96) + 4 * v59)));
              v39 = v17[v38];
              v40 = v19[v36];
              *(_QWORD *)(*a4 + 8 * v40) = 0;
              if (!v14 && (*(_BYTE *)(v37 + v36) & 8) != 0)
              {
                v41 = v37;
                sub_1B22087A4((_QWORD *)v58, v11, v38, v67);
                if ((*(_BYTE *)(v52 + v38) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v52 + v38) & 0x20) != 0)
                  {
                    v46 = v38 == 0;
                    v44 = v56;
                    v45 = v11;
                  }
                  else
                  {
                    v44 = v56;
                    v45 = v11;
                    v46 = v38;
                  }
                  v47 = sub_1B221C7C8(v44, v45, v46, v59);
                  v48 = 1.0 - v47;
                  v43 = v47 + (float)((float)(1.0 - v47) * 0.75);
                  v42 = v48 * 0.125;
                }
                else
                {
                  v42 = 0.125;
                  v43 = 0.75;
                }
                v13 = v54;
                v12 = a3;
                v14 = v53;
                v15 = v56;
                v37 = v41;
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * SLODWORD(v67[0])), v42);
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * SHIDWORD(v67[0])), v42);
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * v39), v43);
                v17 = (int *)v51;
              }
              else
              {
                *(float32x2_t *)(*a4 + 8 * v40) = vadd_f32(*(float32x2_t *)(*v12 + 8 * v39), *(float32x2_t *)(*a4 + 8 * v40));
              }
              ++v36;
            }
            while (v35 != v36);
          }
        }
        else
        {
          v23 = *(int *)(*(_QWORD *)(v57 + 336) + 8 * v11);
          v60 = 0.0;
          v24 = v73;
          v25 = (_DWORD *)v73 + v23;
          v67[0] = &v60;
          v67[1] = v73;
          v67[2] = v25;
          memset(&v67[3], 0, 13);
          v62 = v11;
          v63 = v59;
          v64 = *(_DWORD *)(*(_QWORD *)(v61[0] + 336) + 8 * v11);
          v65 = *(_DWORD *)(*(_QWORD *)(v61[0] + 264) + 8 * v11);
          sub_1B192B8C0(&v66, (uint64_t)v61, (uint64_t)v67, (*(unsigned __int16 *)(*(_QWORD *)(v57 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v49 + 432) + 2 * v59) >> 7) & 0xF);
          v13 = v54;
          v26 = *v17;
          v27 = *v19;
          *(_QWORD *)(*a4 + 8 * v27) = 0;
          if (SLODWORD(v67[4]) >= 1)
          {
            v28 = *(_QWORD *)(v57 + 264);
            v29 = *(unsigned int *)(v28 + 8 * v11);
            if ((int)v29 >= 1)
            {
              v30 = (int *)(*(_QWORD *)(v57 + 288) + 4 * *(int *)(v28 + ((8 * v11) | 4)));
              do
              {
                v31 = *v30++;
                v32 = *(int *)(v50[12] + 4 * *(int *)(v54[21] + 4 * v31));
                LODWORD(v31) = *v25++;
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a4 + 8 * v32), *(float *)&v31);
                --v29;
              }
              while (v29);
            }
          }
          v12 = a3;
          if (SHIDWORD(v67[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v58, v11, v68);
            v13 = v54;
            v12 = a3;
            if ((int)v23 >= 1)
            {
              v33 = 0;
              do
              {
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a3 + 8 * *(int *)((char *)v68 + v33)), *(float *)((char *)v24 + v33));
                v33 += 4;
              }
              while (4 * v23 != v33);
            }
          }
          *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*v12 + 8 * v26), v60);
          v14 = v53;
          v15 = v56;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v57 + 8));
    v10 = v72;
  }
  operator delete(v10);
  operator delete(v77);
}

void sub_1B192E6FC(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _BOOL4 v14;
  _QWORD *v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t *v24;
  _DWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  float v43;
  _QWORD *v44;
  int v45;
  unsigned int v46;
  float v47;
  float v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  _BOOL4 v53;
  _QWORD *v54;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  float v60;
  _QWORD v61[2];
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  _QWORD v67[5];
  uint64_t *v68;
  unsigned int v69;
  int v70;
  uint64_t v71;
  _DWORD *v72;
  uint64_t *v73;
  int v74;
  int v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v54 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v66 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v57 = v54[1];
  v49 = v54[2];
  v58 = *(_QWORD *)(*(_QWORD *)(v57 + 456) + 8 * a5);
  if (*(_BYTE *)(v58 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v53 = v7;
  v56 = *(_QWORD **)(v54[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v49 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v57 + 20);
  v73 = &v76;
  v74 = 2 * v9;
  v75 = 32;
  v77 = 0;
  if (2 * v9 >= 0x21)
  {
    v77 = (uint64_t *)operator new(8 * v9);
    v73 = v77;
    v75 = 2 * v9;
    v9 = *(_DWORD *)(v57 + 20);
  }
  v10 = 0;
  v68 = &v71;
  v69 = v9;
  v70 = 16;
  v72 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v72 = v10;
    v68 = (uint64_t *)v10;
    v70 = v9;
  }
  v61[0] = v57;
  v61[1] = v49;
  if (*(int *)(v57 + 8) >= 1)
  {
    v50 = v8;
    v11 = 0;
    v13 = v54;
    v12 = a3;
    v14 = v53;
    v15 = v56;
    do
    {
      v59 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v59 != -1)
      {
        v16 = *(int *)(*(_QWORD *)(v58 + 96) + 4 * v11);
        v17 = (int *)(*(_QWORD *)(v58 + 144) + 4 * v16);
        v18 = *(int *)(v50[12] + 4 * v59);
        v19 = (int *)(v50[18] + 4 * v18);
        v20 = *v19;
        v21 = v50[21];
        if ((*(_BYTE *)(v21 + v20) & 1) == 0 && v14)
        {
          *(_QWORD *)(*a4 + 8 * v20) = 0;
          *(float32x2_t *)(*a4 + 8 * *v19) = vadd_f32(*(float32x2_t *)(*v12 + 8 * *v17), *(float32x2_t *)(*a4 + 8 * *v19));
        }
        else if ((*(_BYTE *)(v21 + v20) & 1) != 0)
        {
          v34 = v50[9];
          v35 = *(unsigned __int16 *)(v34 + 2 * v59);
          if (*(_WORD *)(v34 + 2 * v59))
          {
            v36 = 0;
            v51 = *(_QWORD *)(v58 + 144) + 4 * v16;
            v52 = *(_QWORD *)(v58 + 168) + v16;
            v37 = v21 + v18;
            do
            {
              v38 = *(unsigned __int16 *)(v15[5] + 2 * (v36 + *(int *)(*(_QWORD *)(v15[4] + 96) + 4 * v59)));
              v39 = v17[v38];
              v40 = v19[v36];
              *(_QWORD *)(*a4 + 8 * v40) = 0;
              if (!v14 && (*(_BYTE *)(v37 + v36) & 8) != 0)
              {
                v41 = v37;
                sub_1B22087A4((_QWORD *)v58, v11, v38, v67);
                if ((*(_BYTE *)(v52 + v38) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v52 + v38) & 0x20) != 0)
                  {
                    v46 = v38 == 0;
                    v44 = v56;
                    v45 = v11;
                  }
                  else
                  {
                    v44 = v56;
                    v45 = v11;
                    v46 = v38;
                  }
                  v47 = sub_1B221C7C8(v44, v45, v46, v59);
                  v48 = 1.0 - v47;
                  v43 = v47 + (float)((float)(1.0 - v47) * 0.75);
                  v42 = v48 * 0.125;
                }
                else
                {
                  v42 = 0.125;
                  v43 = 0.75;
                }
                v13 = v54;
                v12 = a3;
                v14 = v53;
                v15 = v56;
                v37 = v41;
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * SLODWORD(v67[0])), v42);
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * SHIDWORD(v67[0])), v42);
                *(float32x2_t *)(*a4 + 8 * v40) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v40), *(float32x2_t *)(*a3 + 8 * v39), v43);
                v17 = (int *)v51;
              }
              else
              {
                *(float32x2_t *)(*a4 + 8 * v40) = vadd_f32(*(float32x2_t *)(*v12 + 8 * v39), *(float32x2_t *)(*a4 + 8 * v40));
              }
              ++v36;
            }
            while (v35 != v36);
          }
        }
        else
        {
          v23 = *(int *)(*(_QWORD *)(v57 + 336) + 8 * v11);
          v60 = 0.0;
          v24 = v73;
          v25 = (_DWORD *)v73 + v23;
          v67[0] = &v60;
          v67[1] = v73;
          v67[2] = v25;
          memset(&v67[3], 0, 13);
          v62 = v11;
          v63 = v59;
          v64 = *(_DWORD *)(*(_QWORD *)(v61[0] + 336) + 8 * v11);
          v65 = *(_DWORD *)(*(_QWORD *)(v61[0] + 264) + 8 * v11);
          sub_1B192C184(&v66, (uint64_t)v61, (uint64_t)v67, (*(unsigned __int16 *)(*(_QWORD *)(v57 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v49 + 432) + 2 * v59) >> 7) & 0xF);
          v13 = v54;
          v26 = *v17;
          v27 = *v19;
          *(_QWORD *)(*a4 + 8 * v27) = 0;
          if (SLODWORD(v67[4]) >= 1)
          {
            v28 = *(_QWORD *)(v57 + 264);
            v29 = *(unsigned int *)(v28 + 8 * v11);
            if ((int)v29 >= 1)
            {
              v30 = (int *)(*(_QWORD *)(v57 + 288) + 4 * *(int *)(v28 + ((8 * v11) | 4)));
              do
              {
                v31 = *v30++;
                v32 = *(int *)(v50[12] + 4 * *(int *)(v54[21] + 4 * v31));
                LODWORD(v31) = *v25++;
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a4 + 8 * v32), *(float *)&v31);
                --v29;
              }
              while (v29);
            }
          }
          v12 = a3;
          if (SHIDWORD(v67[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v58, v11, v68);
            v13 = v54;
            v12 = a3;
            if ((int)v23 >= 1)
            {
              v33 = 0;
              do
              {
                *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*a3 + 8 * *(int *)((char *)v68 + v33)), *(float *)((char *)v24 + v33));
                v33 += 4;
              }
              while (4 * v23 != v33);
            }
          }
          *(float32x2_t *)(*a4 + 8 * v27) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v27), *(float32x2_t *)(*v12 + 8 * v26), v60);
          v14 = v53;
          v15 = v56;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v57 + 8));
    v10 = v72;
  }
  operator delete(v10);
  operator delete(v77);
}

void sub_1B192EC64(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  _QWORD *v11;
  unsigned int v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  float32x2_t *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  _QWORD *v36;
  int v37;
  unsigned int v38;
  float v39;
  float v40;
  _QWORD *v41;
  _BOOL4 v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  _DWORD v50[2];
  uint64_t *v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  void *__p;
  uint64_t *v56;
  int v57;
  int v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v7 = v6[2];
  v47 = v6;
  v48 = v6[1];
  v8 = v6[60];
  v9 = *(_QWORD *)(v7 + 456);
  v49 = *(_QWORD *)(*(_QWORD *)(v48 + 456) + 8 * a5);
  if (*(_BYTE *)(v49 + 12))
    v10 = 1;
  else
    v10 = **(_DWORD **)a1 == 0;
  v42 = v10;
  v11 = *(_QWORD **)(v8 + 8 * a5);
  v41 = *(_QWORD **)(v9 + 8 * a5);
  v12 = *(_DWORD *)(v48 + 20);
  v56 = &v59;
  v57 = 2 * v12;
  v58 = 32;
  v60 = 0;
  if (2 * v12 >= 0x21)
  {
    v60 = operator new(8 * v12);
    v56 = (uint64_t *)v60;
    v58 = 2 * v12;
    v12 = *(_DWORD *)(v48 + 20);
  }
  v13 = 0;
  v51 = &v54;
  v52 = v12;
  v53 = 16;
  __p = 0;
  if (v12 >= 0x11)
  {
    v13 = operator new(4 * v12);
    __p = v13;
    v51 = (uint64_t *)v13;
    v53 = v12;
  }
  if (*(int *)(v48 + 8) >= 1)
  {
    v14 = 0;
    v15 = a3;
    v16 = v42;
    while (1)
    {
      v17 = *(int *)(v47[30] + 4 * v14);
      if ((_DWORD)v17 != -1)
      {
        v18 = *(int *)(*(_QWORD *)(v49 + 96) + 4 * v14);
        v19 = (int *)(*(_QWORD *)(v49 + 144) + 4 * v18);
        v20 = *(int *)(v41[12] + 4 * v17);
        v21 = (int *)(v41[18] + 4 * v20);
        v22 = *v21;
        v23 = v41[21];
        if ((*(_BYTE *)(v23 + v22) & 1) == 0 && v16)
        {
          *(_QWORD *)(*a4 + 8 * v22) = 0;
          v25 = (float32x2_t *)(*a4 + 8 * *v21);
          v26 = *v19;
        }
        else
        {
          if ((*(_BYTE *)(v23 + v22) & 1) != 0)
          {
            v27 = v41[9];
            v28 = *(unsigned __int16 *)(v27 + 2 * v17);
            if (*(_WORD *)(v27 + 2 * v17))
            {
              v29 = 0;
              v45 = *(_QWORD *)(v49 + 168) + v18;
              v46 = *(unsigned __int16 *)(v27 + 2 * v17);
              v30 = v23 + v20;
              v44 = v30;
              do
              {
                v31 = *(unsigned __int16 *)(v11[5] + 2 * (v29 + *(int *)(*(_QWORD *)(v11[4] + 96) + 4 * v17)));
                v32 = v19[v31];
                v33 = v21[v29];
                *(_QWORD *)(*a4 + 8 * v33) = 0;
                if (!v16 && (*(_BYTE *)(v30 + v29) & 8) != 0)
                {
                  sub_1B22087A4((_QWORD *)v49, v14, v31, v50);
                  if ((*(_BYTE *)(v45 + v31) & 0x10) != 0)
                  {
                    if ((*(_BYTE *)(v45 + v31) & 0x20) != 0)
                    {
                      v38 = v31 == 0;
                      v36 = v11;
                      v37 = v14;
                    }
                    else
                    {
                      v36 = v11;
                      v37 = v14;
                      v38 = v31;
                    }
                    v39 = sub_1B221C7C8(v36, v37, v38, v17);
                    v40 = 1.0 - v39;
                    v35 = v39 + (float)((float)(1.0 - v39) * 0.75);
                    v34 = v40 * 0.125;
                  }
                  else
                  {
                    v34 = 0.125;
                    v35 = 0.75;
                  }
                  v15 = a3;
                  v30 = v44;
                  v16 = v42;
                  v28 = v46;
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v50[0]), v34);
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v50[1]), v34);
                  *(float32x2_t *)(*a4 + 8 * v33) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v33), *(float32x2_t *)(*a3 + 8 * v32), v35);
                }
                else
                {
                  *(float32x2_t *)(*a4 + 8 * v33) = vadd_f32(*(float32x2_t *)(*v15 + 8 * v32), *(float32x2_t *)(*a4 + 8 * v33));
                }
                ++v29;
              }
              while (v28 != v29);
            }
            goto LABEL_19;
          }
          v26 = *v19;
          *(_QWORD *)(*a4 + 8 * v22) = 0;
          v25 = (float32x2_t *)(*a4 + 8 * v22);
        }
        *v25 = vadd_f32(*(float32x2_t *)(*v15 + 8 * v26), *v25);
      }
LABEL_19:
      if (++v14 >= *(int *)(v48 + 8))
      {
        v13 = __p;
        break;
      }
    }
  }
  operator delete(v13);
  operator delete(v60);
}

void sub_1B192F010(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  int v8;
  void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  float32x4_t v17;
  uint64_t v18;
  int *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t i;
  uint64_t v25;
  void *__p;
  void *v27;

  v8 = *(_DWORD *)*a1;
  if (v8)
  {
    if (v8 == 2)
    {
      sub_1B192F5DC((uint64_t)a1, a2, a3, a4);
      sub_1B192FC98(a1, a2, a3, a4);
      sub_1B192FF2C(a1, a2, a3, a4);
    }
    else if (v8 == 1)
    {
      sub_1B192F5DC((uint64_t)a1, a2, a3, a4);
      sub_1B192F768(a1, a2, a3, a4);
      sub_1B192F9FC(a1, a2, a3, a4);
    }
  }
  else
  {
    sub_1B192F5DC((uint64_t)a1, a2, a3, a4);
    v9 = 0;
    v10 = a2 - 1;
    v11 = *(_QWORD *)(*(_QWORD *)(*a1 + 64) + 8 * (a2 - 1));
    v12 = *(_QWORD *)(v11 + 8);
    v13 = *(unsigned int *)(v12 + 16);
    __p = 0;
    if (v13 >= 9)
    {
      v9 = operator new(4 * v13);
      __p = v9;
    }
    v14 = *(_DWORD *)(v12 + 4);
    if (v14 >= 1)
    {
      v15 = 0;
      v16 = 0;
      v17.i64[0] = 0x3F0000003F000000;
      v17.i64[1] = 0x3F0000003F000000;
      do
      {
        v18 = *(int *)(*(_QWORD *)(v11 + 216) + 4 * v16);
        if ((_DWORD)v18 != -1)
        {
          v19 = (int *)(*(_QWORD *)(v12 + 120) + v15);
          *(_OWORD *)(*a4 + 16 * v18) = 0uLL;
          *(float32x4_t *)(*a4 + 16 * v18) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v18), v17, *(float32x4_t *)(*a3 + 16 * *v19));
          *(float32x4_t *)(*a4 + 16 * v18) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v18), v17, *(float32x4_t *)(*a3 + 16 * v19[1]));
          v14 = *(_DWORD *)(v12 + 4);
        }
        ++v16;
        v15 += 8;
      }
      while (v16 < v14);
      v9 = __p;
    }
    operator delete(v9);
    v20 = 0;
    v21 = *(_QWORD *)(*(_QWORD *)(*a1 + 64) + 8 * v10);
    v22 = *(_QWORD *)(v21 + 8);
    v27 = 0;
    if ((2 * *(_DWORD *)(v22 + 20)) >= 0x21)
    {
      v20 = operator new(4 * (2 * *(_DWORD *)(v22 + 20)));
      v27 = v20;
    }
    v23 = *(_DWORD *)(v22 + 8);
    if (v23 >= 1)
    {
      for (i = 0; i < v23; ++i)
      {
        v25 = *(int *)(*(_QWORD *)(v21 + 240) + 4 * i);
        if ((_DWORD)v25 != -1)
        {
          *(_OWORD *)(*a4 + 16 * v25) = 0uLL;
          *(float32x4_t *)(*a4 + 16 * v25) = vaddq_f32(*(float32x4_t *)(*a3 + 16 * i), *(float32x4_t *)(*a4 + 16 * v25));
          v23 = *(_DWORD *)(v22 + 8);
        }
      }
      v20 = v27;
    }
    operator delete(v20);
  }
}

void sub_1B192F31C(int **a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  int v10;

  v10 = **a1;
  if (v10)
  {
    if (v10 == 2)
    {
      sub_1B19301C8((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1930CA8((uint64_t)a1, a2, a3, a4, a5);
      sub_1B193106C((uint64_t)a1, a2, a3, a4, a5);
    }
    else if (v10 == 1)
    {
      sub_1B19301C8((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1930378((uint64_t)a1, a2, a3, a4, a5);
      sub_1B193073C((uint64_t)a1, a2, a3, a4, a5);
    }
  }
  else
  {
    sub_1B19301C8((uint64_t)a1, a2, a3, a4, a5);
    sub_1B19315D8((uint64_t)a1, a2, a3, a4, a5);
    sub_1B1931808((uint64_t)a1, a2, a3, a4, a5);
  }
}

void sub_1B192F47C(int **a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  int v10;

  v10 = **a1;
  if (v10)
  {
    if (v10 == 2)
    {
      sub_1B19301C8((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1930CA8((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1932118((uint64_t)a1, a2, a3, a4, a5);
    }
    else if (v10 == 1)
    {
      sub_1B19301C8((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1930378((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1931BAC((uint64_t)a1, a2, a3, a4, a5);
    }
  }
  else
  {
    sub_1B19301C8((uint64_t)a1, a2, a3, a4, a5);
    sub_1B19315D8((uint64_t)a1, a2, a3, a4, a5);
    sub_1B1932684((uint64_t)a1, a2, a3, a4, a5);
  }
}

void sub_1B192F5DC(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  void *v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  void *__p;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  if (*(_DWORD *)(v4 + 52))
  {
    v7 = 0;
    v8 = *(int **)(v4 + 8);
    v9 = v8[5];
    v19 = (float *)&v20;
    __p = 0;
    if (v9 >= 0x11)
    {
      v7 = operator new(4 * v9);
      __p = v7;
      v19 = (float *)v7;
    }
    if (*v8 >= 1)
    {
      v10 = 0;
      do
      {
        v11 = *(int *)(*(_QWORD *)(v4 + 168) + 4 * v10);
        if ((_DWORD)v11 != -1)
        {
          v12 = (unsigned int *)(*((_QWORD *)v8 + 3) + 8 * v10);
          v13 = *v12;
          if ((int)v13 < 1)
          {
            *(_OWORD *)(*a4 + 16 * v11) = 0uLL;
          }
          else
          {
            v14 = *((_QWORD *)v8 + 6) + 4 * (int)v12[1];
            v15 = v19;
            v16 = v13;
            do
            {
              *v15++ = 1.0 / (float)(int)v13;
              --v16;
            }
            while (v16);
            *(_OWORD *)(*a4 + 16 * v11) = 0uLL;
            v17 = 0;
            v18 = 4 * v13;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v11) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v11), *(float32x4_t *)(*a3 + 16 * *(int *)(v14 + v17)), v19[v17 / 4]);
              v17 += 4;
            }
            while (v18 != v17);
          }
        }
        ++v10;
      }
      while (v10 < *v8);
      v7 = __p;
    }
    operator delete(v7);
  }
}

void sub_1B192F768(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t i;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  float32x2_t v21;
  uint64_t j;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[5];
  uint64_t v35;
  int v36;
  int v37;
  float *v38;
  int v39;
  int v40;
  uint64_t v41;
  void *__p;
  _QWORD v43[3];

  v7 = 0;
  v43[1] = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v10 = v9[1];
  v33 = v9[2];
  v37 = *(_DWORD *)(v8 + 4);
  v11 = *(unsigned int *)(v10 + 16);
  v38 = (float *)&v41;
  v39 = v11;
  v40 = 8;
  v35 = v10;
  __p = 0;
  if (v11 >= 9)
  {
    v7 = operator new(4 * v11);
    __p = v7;
    v38 = (float *)v7;
    v40 = v11;
  }
  v12 = *(_DWORD *)(v10 + 4);
  if (v12 >= 1)
  {
    for (i = 0; i < v12; ++i)
    {
      v14 = *(int *)(v9[27] + 4 * i);
      if ((_DWORD)v14 != -1)
      {
        v15 = (int *)(*(_QWORD *)(v10 + 120) + 8 * i);
        v16 = *(_QWORD *)(v10 + 168);
        v17 = (unsigned int *)(*(_QWORD *)(v10 + 144) + 8 * i);
        v18 = *v17;
        v19 = (int)v17[1];
        v34[0] = v43;
        v34[1] = 0;
        v34[2] = v38;
        memset(&v34[3], 0, 13);
        v36 = i;
        if (*(float *)(*(_QWORD *)(v10 + 216) + 4 * i) <= 0.0)
          v20 = 1;
        else
          v20 = 4;
        sub_1B192B4F4(&v37, (int *)&v35, (uint64_t)v34, v20, (*(unsigned __int16 *)(*(_QWORD *)(v33 + 432) + 2 * v14) >> 7) & 0xF);
        *(_OWORD *)(*a4 + 16 * v14) = 0u;
        v21 = (float32x2_t)v43[0];
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * *v15), *(float *)v43);
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * v15[1]), v21, 1);
        if (SLODWORD(v34[4]) >= 1 && (int)v18 >= 1)
        {
          for (j = 0; j != v18; ++j)
          {
            v23 = *(int *)(v16 + 4 * v19 + 4 * j);
            if (BYTE4(v34[4]))
            {
              v24 = (int *)(v9[21] + 4 * v23);
              v25 = *a4;
              v26 = *a4;
            }
            else
            {
              v27 = 0;
              v28 = *(_QWORD *)(v10 + 24);
              v29 = *(int *)(v28 + 8 * (_DWORD)v23 + 4);
              v30 = *(_DWORD *)(v28 + 8 * v23);
              do
                v31 = *(unsigned int *)(*(_QWORD *)(v10 + 72) + 4 * v29 + 4 * v27++);
              while (i != v31);
              v32 = *(_QWORD *)(v10 + 48) + 4 * v29;
              if ((int)v27 + 1 < v30)
                v30 = 0;
              v24 = (int *)(v32 + 4 * ((int)v27 - v30 + 1));
              v26 = *a4;
              v25 = *a3;
            }
            *(float32x4_t *)(v26 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(v26 + 16 * v14), *(float32x4_t *)(v25 + 16 * *v24), v38[j]);
          }
        }
        v12 = *(_DWORD *)(v10 + 4);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B192F9FC(uint64_t *a1, int a2, _QWORD *a3, _QWORD *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t i;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  _DWORD *v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v30;
  uint64_t v31;
  _DWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  _QWORD v38[5];
  float v39;
  _QWORD v40[2];
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t *v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  void *__p;
  uint64_t v51;

  v7 = 0;
  v51 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v11 = v9[1];
  v10 = v9[2];
  v45 = *(_DWORD *)(v8 + 4);
  v12 = 2 * *(_DWORD *)(v11 + 20);
  v46 = &v49;
  v47 = v12;
  v48 = 32;
  v40[0] = v11;
  v40[1] = v10;
  v33 = v10;
  __p = 0;
  if (v12 >= 0x21)
  {
    v7 = operator new(4 * v12);
    __p = v7;
    v46 = (uint64_t *)v7;
    v48 = v12;
  }
  v13 = *(_DWORD *)(v11 + 8);
  if (v13 >= 1)
  {
    for (i = 0; i < v13; ++i)
    {
      v15 = *(_DWORD *)(v9[30] + 4 * i);
      if (v15 != -1)
      {
        v16 = v15;
        v36 = *(_QWORD *)(v11 + 360);
        v17 = *(_QWORD *)(v11 + 336);
        v18 = (8 * i) | 4;
        v35 = *(int *)(v17 + v18);
        v19 = *(int *)(v17 + 8 * i);
        v20 = *(_QWORD *)(v11 + 264);
        v34 = *(int *)(v20 + v18);
        v21 = *(unsigned int *)(v20 + 8 * i);
        v39 = 0.0;
        v22 = v46;
        v23 = (_DWORD *)v46 + v19;
        v37 = v19;
        v38[0] = &v39;
        v38[1] = v46;
        v38[2] = v23;
        memset(&v38[3], 0, 13);
        v41 = i;
        v42 = v15;
        v43 = *(_DWORD *)(*(_QWORD *)(v40[0] + 336) + 8 * i);
        v44 = *(_DWORD *)(*(_QWORD *)(v40[0] + 264) + 8 * i);
        v24 = *(_QWORD *)(v11 + 288);
        sub_1B192B8C0(&v45, (uint64_t)v40, (uint64_t)v38, (*(unsigned __int16 *)(*(_QWORD *)(v11 + 432) + 2 * i) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v33 + 432) + 2 * v15) >> 7) & 0xF);
        *(_OWORD *)(*a4 + 16 * v16) = 0u;
        if (SLODWORD(v38[4]) >= 1 && (int)v21 >= 1)
        {
          v25 = (int *)(v24 + 4 * v34);
          do
          {
            v26 = *v25++;
            v27 = *(int *)(v9[21] + 4 * v26);
            LODWORD(v26) = *v23++;
            *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a4 + 16 * v27), *(float *)&v26);
            --v21;
          }
          while (v21);
        }
        v28 = v37;
        if (SHIDWORD(v38[3]) >= 1 && v37 >= 1)
        {
          v30 = (int *)(v36 + 4 * v35);
          do
          {
            v31 = *v30++;
            v32 = (_DWORD *)(*(_QWORD *)(v11 + 120) + 8 * v31);
            LODWORD(v31) = *(_DWORD *)v22;
            v22 = (uint64_t *)((char *)v22 + 4);
            *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * (int)v32[i == *v32]), *(float *)&v31);
            --v28;
          }
          while (v28);
        }
        *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * i), v39);
        v13 = *(_DWORD *)(v11 + 8);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B192FC98(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t i;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  float32x2_t v21;
  uint64_t j;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[5];
  uint64_t v35;
  int v36;
  int v37;
  float *v38;
  int v39;
  int v40;
  uint64_t v41;
  void *__p;
  _QWORD v43[3];

  v7 = 0;
  v43[1] = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v10 = v9[1];
  v33 = v9[2];
  v37 = *(_DWORD *)(v8 + 4);
  v11 = *(unsigned int *)(v10 + 16);
  v38 = (float *)&v41;
  v39 = v11;
  v40 = 8;
  v35 = v10;
  __p = 0;
  if (v11 >= 9)
  {
    v7 = operator new(4 * v11);
    __p = v7;
    v38 = (float *)v7;
    v40 = v11;
  }
  v12 = *(_DWORD *)(v10 + 4);
  if (v12 >= 1)
  {
    for (i = 0; i < v12; ++i)
    {
      v14 = *(int *)(v9[27] + 4 * i);
      if ((_DWORD)v14 != -1)
      {
        v15 = (int *)(*(_QWORD *)(v10 + 120) + 8 * i);
        v16 = *(_QWORD *)(v10 + 168);
        v17 = (unsigned int *)(*(_QWORD *)(v10 + 144) + 8 * i);
        v18 = *v17;
        v19 = (int)v17[1];
        v34[0] = v43;
        v34[1] = 0;
        v34[2] = v38;
        memset(&v34[3], 0, 13);
        v36 = i;
        if (*(float *)(*(_QWORD *)(v10 + 216) + 4 * i) <= 0.0)
          v20 = 1;
        else
          v20 = 4;
        sub_1B192BFA0(&v37, (int *)&v35, (uint64_t)v34, v20, (*(unsigned __int16 *)(*(_QWORD *)(v33 + 432) + 2 * v14) >> 7) & 0xF);
        *(_OWORD *)(*a4 + 16 * v14) = 0u;
        v21 = (float32x2_t)v43[0];
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * *v15), *(float *)v43);
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * v15[1]), v21, 1);
        if (SLODWORD(v34[4]) >= 1 && (int)v18 >= 1)
        {
          for (j = 0; j != v18; ++j)
          {
            v23 = *(int *)(v16 + 4 * v19 + 4 * j);
            if (BYTE4(v34[4]))
            {
              v24 = (int *)(v9[21] + 4 * v23);
              v25 = *a4;
              v26 = *a4;
            }
            else
            {
              v27 = 0;
              v28 = *(_QWORD *)(v10 + 24);
              v29 = *(int *)(v28 + 8 * (_DWORD)v23 + 4);
              v30 = *(_DWORD *)(v28 + 8 * v23);
              do
                v31 = *(unsigned int *)(*(_QWORD *)(v10 + 72) + 4 * v29 + 4 * v27++);
              while (i != v31);
              v32 = *(_QWORD *)(v10 + 48) + 4 * v29;
              if ((int)v27 + 1 < v30)
                v30 = 0;
              v24 = (int *)(v32 + 4 * ((int)v27 - v30 + 1));
              v26 = *a4;
              v25 = *a3;
            }
            *(float32x4_t *)(v26 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(v26 + 16 * v14), *(float32x4_t *)(v25 + 16 * *v24), v38[j]);
          }
        }
        v12 = *(_DWORD *)(v10 + 4);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B192FF2C(uint64_t *a1, int a2, _QWORD *a3, _QWORD *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t i;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  _DWORD *v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v30;
  uint64_t v31;
  _DWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  _QWORD v38[5];
  float v39;
  _QWORD v40[2];
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t *v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  void *__p;
  uint64_t v51;

  v7 = 0;
  v51 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v11 = v9[1];
  v10 = v9[2];
  v45 = *(_DWORD *)(v8 + 4);
  v12 = 2 * *(_DWORD *)(v11 + 20);
  v46 = &v49;
  v47 = v12;
  v48 = 32;
  v40[0] = v11;
  v40[1] = v10;
  v33 = v10;
  __p = 0;
  if (v12 >= 0x21)
  {
    v7 = operator new(4 * v12);
    __p = v7;
    v46 = (uint64_t *)v7;
    v48 = v12;
  }
  v13 = *(_DWORD *)(v11 + 8);
  if (v13 >= 1)
  {
    for (i = 0; i < v13; ++i)
    {
      v15 = *(_DWORD *)(v9[30] + 4 * i);
      if (v15 != -1)
      {
        v16 = v15;
        v36 = *(_QWORD *)(v11 + 360);
        v17 = *(_QWORD *)(v11 + 336);
        v18 = (8 * i) | 4;
        v35 = *(int *)(v17 + v18);
        v19 = *(int *)(v17 + 8 * i);
        v20 = *(_QWORD *)(v11 + 264);
        v34 = *(int *)(v20 + v18);
        v21 = *(unsigned int *)(v20 + 8 * i);
        v39 = 0.0;
        v22 = v46;
        v23 = (_DWORD *)v46 + v19;
        v37 = v19;
        v38[0] = &v39;
        v38[1] = v46;
        v38[2] = v23;
        memset(&v38[3], 0, 13);
        v41 = i;
        v42 = v15;
        v43 = *(_DWORD *)(*(_QWORD *)(v40[0] + 336) + 8 * i);
        v44 = *(_DWORD *)(*(_QWORD *)(v40[0] + 264) + 8 * i);
        v24 = *(_QWORD *)(v11 + 288);
        sub_1B192C184(&v45, (uint64_t)v40, (uint64_t)v38, (*(unsigned __int16 *)(*(_QWORD *)(v11 + 432) + 2 * i) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v33 + 432) + 2 * v15) >> 7) & 0xF);
        *(_OWORD *)(*a4 + 16 * v16) = 0u;
        if (SLODWORD(v38[4]) >= 1 && (int)v21 >= 1)
        {
          v25 = (int *)(v24 + 4 * v34);
          do
          {
            v26 = *v25++;
            v27 = *(int *)(v9[21] + 4 * v26);
            LODWORD(v26) = *v23++;
            *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a4 + 16 * v27), *(float *)&v26);
            --v21;
          }
          while (v21);
        }
        v28 = v37;
        if (SHIDWORD(v38[3]) >= 1 && v37 >= 1)
        {
          v30 = (int *)(v36 + 4 * v35);
          do
          {
            v31 = *v30++;
            v32 = (_DWORD *)(*(_QWORD *)(v11 + 120) + 8 * v31);
            LODWORD(v31) = *(_DWORD *)v22;
            v22 = (uint64_t *)((char *)v22 + 4);
            *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * (int)v32[i == *v32]), *(float *)&v31);
            --v28;
          }
          while (v28);
        }
        *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * i), v39);
        v13 = *(_DWORD *)(v11 + 8);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B19301C8(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  uint64_t v5;
  void *v8;
  int *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  float *v23;
  uint64_t v24;
  void *__p;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  if (*(_DWORD *)(v5 + 52))
  {
    v8 = 0;
    v9 = *(int **)(v5 + 8);
    v10 = *(_QWORD **)(*((_QWORD *)v9 + 57) + 8 * a5);
    v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 16) + 456) + 8 * a5);
    v12 = v9[5];
    v23 = (float *)&v24;
    __p = 0;
    if (v12 >= 0x11)
    {
      v8 = operator new(4 * v12);
      __p = v8;
      v23 = (float *)v8;
    }
    if (*v9 >= 1)
    {
      v13 = 0;
      do
      {
        v14 = *(int *)(*(_QWORD *)(v5 + 168) + 4 * v13);
        if ((_DWORD)v14 != -1)
        {
          v15 = *(int *)(*(_QWORD *)(v11 + 96) + 4 * v14);
          v16 = (unsigned int *)(*(_QWORD *)(*v10 + 24) + 8 * v13);
          v17 = *v16;
          if ((int)v17 < 1)
          {
            *(_OWORD *)(*a4 + 16 * v15) = 0uLL;
          }
          else
          {
            v18 = v10[3] + 4 * (int)v16[1];
            v19 = v23;
            v20 = v17;
            do
            {
              *v19++ = 1.0 / (float)(int)v17;
              --v20;
            }
            while (v20);
            *(_OWORD *)(*a4 + 16 * v15) = 0uLL;
            v21 = 0;
            v22 = 4 * v17;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v15) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v15), *(float32x4_t *)(*a3 + 16 * *(int *)(v18 + v21)), v23[v21 / 4]);
              v21 += 4;
            }
            while (v22 != v21);
          }
        }
        ++v13;
      }
      while (v13 < *v9);
      v8 = __p;
    }
    operator delete(v8);
  }
}

void sub_1B1930378(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  float32x2_t v22;
  unsigned int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  float32x4_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  _QWORD v49[5];
  int v50;
  int v51;
  int v52;
  _BYTE *v53;
  int v54;
  int v55;
  _BYTE v56[32];
  void *__p;
  _QWORD v58[3];

  v58[1] = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v50 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v9 = v8[1];
  v10 = *(_QWORD *)(v8[60] + 8 * a5);
  v11 = *(_QWORD *)(*(_QWORD *)(v9 + 456) + 8 * a5);
  v43 = v8[2];
  v12 = *(_QWORD **)(*(_QWORD *)(v43 + 456) + 8 * a5);
  v46 = v9;
  v13 = *(unsigned int *)(v9 + 16);
  v14 = v56;
  v53 = v56;
  v54 = v13;
  v55 = 8;
  __p = 0;
  if (v13 < 9)
  {
    v15 = 0;
  }
  else
  {
    v15 = operator new(4 * v13);
    __p = v15;
    v53 = v15;
    v55 = v13;
    v14 = v15;
  }
  v49[0] = v58;
  v49[1] = 0;
  v49[2] = v14;
  memset(&v49[3], 0, 13);
  if (*(_BYTE *)(v11 + 12) || !**(_DWORD **)a1)
  {
    LODWORD(v49[3]) = 2;
    LODWORD(v49[4]) = 0;
    v58[0] = 0x3F0000003F000000;
    v44 = 1;
  }
  else
  {
    v44 = 0;
  }
  v47 = v46;
  if (*(int *)(v46 + 4) >= 1)
  {
    v16 = 0;
    v45 = v8;
    do
    {
      v17 = *(int *)(v8[27] + 4 * v16);
      if ((_DWORD)v17 != -1)
      {
        v18 = (int *)(v12[18] + 4 * *(int *)(v12[12] + 4 * v17));
        if ((*(_BYTE *)(v12[21] + *v18) & 1) != 0)
        {
          v37 = v12[9];
          v38 = *(unsigned __int16 *)(v37 + 2 * v17);
          if (*(_WORD *)(v37 + 2 * v17))
          {
            v39 = 0;
            do
            {
              sub_1B2208948((_QWORD *)v11, v16, *(unsigned __int16 *)(*(_QWORD *)(v10 + 40)+ 2 * (v39 + *(int *)(*(_QWORD *)(*(_QWORD *)(v10 + 32) + 96) + 4 * v17))), &v51);
              v40.i64[0] = 0x3F0000003F000000;
              v40.i64[1] = 0x3F0000003F000000;
              v41 = v18[v39];
              *(_OWORD *)(*a4 + 16 * v41) = 0u;
              v42 = v52;
              *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v41), v40, *(float32x4_t *)(*a3 + 16 * v51));
              *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v41), v40, *(float32x4_t *)(*a3 + 16 * v42));
              ++v39;
            }
            while (v38 != v39);
          }
        }
        else
        {
          if ((v44 & 1) == 0)
          {
            v48 = v16;
            if (*(float *)(*(_QWORD *)(v46 + 216) + 4 * v16) <= 0.0)
              v19 = 1;
            else
              v19 = 4;
            sub_1B192B4F4(&v50, (int *)&v47, (uint64_t)v49, v19, (*(unsigned __int16 *)(*(_QWORD *)(v43 + 432) + 2 * v17) >> 7) & 0xF);
          }
          sub_1B2208948((_QWORD *)v11, v16, 0, &v51);
          v20 = *v18;
          *(_OWORD *)(*a4 + 16 * v20) = 0u;
          v21 = v52;
          v22 = (float32x2_t)v58[0];
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v51), *(float *)v58);
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v21), v22, 1);
          if (SLODWORD(v49[4]) >= 1)
          {
            v23 = (unsigned int *)(*(_QWORD *)(v46 + 144) + 8 * v16);
            v24 = *v23;
            if ((int)v24 >= 1)
            {
              v25 = 0;
              v26 = *(_QWORD *)(v46 + 168) + 4 * (int)v23[1];
              do
              {
                v27 = *(int *)(v26 + 4 * v25);
                if (BYTE4(v49[4]))
                {
                  v28 = (int *)(v12[12] + 4 * *(int *)(v45[21] + 4 * v27));
                  v29 = *a4;
                  v30 = *a4;
                }
                else
                {
                  v31 = 0;
                  v32 = (2 * (int)v27) | 1;
                  v33 = *(_QWORD *)(v46 + 24);
                  v34 = *(_QWORD *)(v46 + 72) + 4 * *(int *)(v33 + 4 * v32);
                  v35 = *(_DWORD *)(v33 + 8 * v27);
                  do
                    v36 = *(unsigned int *)(v34 + 4 * v31++);
                  while (v16 != v36);
                  if ((int)v31 + 1 < v35)
                    v35 = 0;
                  v28 = (int *)(*(_QWORD *)(v11 + 24)
                              + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)v11 + 24) + 4 * v32)
                              + 4 * ((int)v31 - v35 + 1));
                  v30 = *a4;
                  v29 = *a3;
                }
                *(float32x4_t *)(v30 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(v30 + 16 * v20), *(float32x4_t *)(v29 + 16 * *v28), *(float *)&v53[4 * v25++]);
              }
              while (v25 != v24);
            }
          }
        }
      }
      ++v16;
      v8 = v45;
    }
    while (v16 < *(int *)(v46 + 4));
    v15 = __p;
  }
  operator delete(v15);
}

void sub_1B193073C(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  __int128 v12;
  _QWORD *v13;
  _QWORD *v14;
  _BOOL4 v15;
  _QWORD *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t *v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  float v43;
  float v44;
  _QWORD *v45;
  int v46;
  unsigned int v47;
  float v48;
  float v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _BOOL4 v54;
  _QWORD *v55;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  float v61;
  _QWORD v62[2];
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  _QWORD v68[5];
  uint64_t *v69;
  unsigned int v70;
  int v71;
  uint64_t v72;
  _DWORD *v73;
  uint64_t *v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v55 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v67 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v58 = v55[1];
  v50 = v55[2];
  v59 = *(_QWORD *)(*(_QWORD *)(v58 + 456) + 8 * a5);
  if (*(_BYTE *)(v59 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v54 = v7;
  v57 = *(_QWORD **)(v55[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v50 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v58 + 20);
  v74 = &v77;
  v75 = 2 * v9;
  v76 = 32;
  v78 = 0;
  if (2 * v9 >= 0x21)
  {
    v78 = (uint64_t *)operator new(8 * v9);
    v74 = v78;
    v76 = 2 * v9;
    v9 = *(_DWORD *)(v58 + 20);
  }
  v10 = 0;
  v69 = &v72;
  v70 = v9;
  v71 = 16;
  v73 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v73 = v10;
    v69 = (uint64_t *)v10;
    v71 = v9;
  }
  v62[0] = v58;
  v62[1] = v50;
  if (*(int *)(v58 + 8) >= 1)
  {
    v51 = v8;
    v11 = 0;
    v12 = 0uLL;
    v14 = v55;
    v13 = a3;
    v15 = v54;
    v16 = v57;
    do
    {
      v60 = *(_DWORD *)(v14[30] + 4 * v11);
      if (v60 != -1)
      {
        v17 = *(int *)(*(_QWORD *)(v59 + 96) + 4 * v11);
        v18 = (int *)(*(_QWORD *)(v59 + 144) + 4 * v17);
        v19 = *(int *)(v51[12] + 4 * v60);
        v20 = (int *)(v51[18] + 4 * v19);
        v21 = *v20;
        v22 = v51[21];
        if ((*(_BYTE *)(v22 + v21) & 1) == 0 && v15)
        {
          *(_OWORD *)(*a4 + 16 * v21) = v12;
          *(float32x4_t *)(*a4 + 16 * *v20) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * *v18), *(float32x4_t *)(*a4 + 16 * *v20));
        }
        else if ((*(_BYTE *)(v22 + v21) & 1) != 0)
        {
          v35 = v51[9];
          v36 = *(unsigned __int16 *)(v35 + 2 * v60);
          if (*(_WORD *)(v35 + 2 * v60))
          {
            v37 = 0;
            v52 = *(_QWORD *)(v59 + 144) + 4 * v17;
            v53 = *(_QWORD *)(v59 + 168) + v17;
            v38 = v22 + v19;
            do
            {
              v39 = *(unsigned __int16 *)(v16[5] + 2 * (v37 + *(int *)(*(_QWORD *)(v16[4] + 96) + 4 * v60)));
              v40 = v18[v39];
              v41 = v20[v37];
              *(_OWORD *)(*a4 + 16 * v41) = v12;
              if (!v15 && (*(_BYTE *)(v38 + v37) & 8) != 0)
              {
                v42 = v38;
                sub_1B22087A4((_QWORD *)v59, v11, v39, v68);
                if ((*(_BYTE *)(v53 + v39) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v53 + v39) & 0x20) != 0)
                  {
                    v47 = v39 == 0;
                    v45 = v57;
                    v46 = v11;
                  }
                  else
                  {
                    v45 = v57;
                    v46 = v11;
                    v47 = v39;
                  }
                  v48 = sub_1B221C7C8(v45, v46, v47, v60);
                  v49 = 1.0 - v48;
                  v44 = v48 + (float)((float)(1.0 - v48) * 0.75);
                  v43 = v49 * 0.125;
                }
                else
                {
                  v43 = 0.125;
                  v44 = 0.75;
                }
                v14 = v55;
                v13 = a3;
                v15 = v54;
                v16 = v57;
                v12 = 0uLL;
                v38 = v42;
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * SLODWORD(v68[0])), v43);
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * SHIDWORD(v68[0])), v43);
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * v40), v44);
                v18 = (int *)v52;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v41) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * v40), *(float32x4_t *)(*a4 + 16 * v41));
              }
              ++v37;
            }
            while (v36 != v37);
          }
        }
        else
        {
          v24 = *(int *)(*(_QWORD *)(v58 + 336) + 8 * v11);
          v61 = 0.0;
          v25 = v74;
          v26 = (_DWORD *)v74 + v24;
          v68[0] = &v61;
          v68[1] = v74;
          v68[2] = v26;
          memset(&v68[3], 0, 13);
          v63 = v11;
          v64 = v60;
          v65 = *(_DWORD *)(*(_QWORD *)(v62[0] + 336) + 8 * v11);
          v66 = *(_DWORD *)(*(_QWORD *)(v62[0] + 264) + 8 * v11);
          sub_1B192B8C0(&v67, (uint64_t)v62, (uint64_t)v68, (*(unsigned __int16 *)(*(_QWORD *)(v58 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v50 + 432) + 2 * v60) >> 7) & 0xF);
          v12 = 0uLL;
          v14 = v55;
          v27 = *v18;
          v28 = *v20;
          *(_OWORD *)(*a4 + 16 * v28) = 0u;
          if (SLODWORD(v68[4]) >= 1)
          {
            v29 = *(_QWORD *)(v58 + 264);
            v30 = *(unsigned int *)(v29 + 8 * v11);
            if ((int)v30 >= 1)
            {
              v31 = (int *)(*(_QWORD *)(v58 + 288) + 4 * *(int *)(v29 + ((8 * v11) | 4)));
              do
              {
                v32 = *v31++;
                v33 = *(int *)(v51[12] + 4 * *(int *)(v55[21] + 4 * v32));
                LODWORD(v32) = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * v33), *(float *)&v32);
                --v30;
              }
              while (v30);
            }
          }
          v13 = a3;
          if (SHIDWORD(v68[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v59, v11, v69);
            v12 = 0uLL;
            v14 = v55;
            v13 = a3;
            if ((int)v24 >= 1)
            {
              v34 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * *(int *)((char *)v69 + v34)), *(float *)((char *)v25 + v34));
                v34 += 4;
              }
              while (4 * v24 != v34);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v13 + 16 * v27), v61);
          v15 = v54;
          v16 = v57;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v58 + 8));
    v10 = v73;
  }
  operator delete(v10);
  operator delete(v78);
}

void sub_1B1930CA8(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  float32x2_t v22;
  unsigned int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  float32x4_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  _QWORD v49[5];
  int v50;
  int v51;
  int v52;
  _BYTE *v53;
  int v54;
  int v55;
  _BYTE v56[32];
  void *__p;
  _QWORD v58[3];

  v58[1] = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v50 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v9 = v8[1];
  v10 = *(_QWORD *)(v8[60] + 8 * a5);
  v11 = *(_QWORD *)(*(_QWORD *)(v9 + 456) + 8 * a5);
  v43 = v8[2];
  v12 = *(_QWORD **)(*(_QWORD *)(v43 + 456) + 8 * a5);
  v46 = v9;
  v13 = *(unsigned int *)(v9 + 16);
  v14 = v56;
  v53 = v56;
  v54 = v13;
  v55 = 8;
  __p = 0;
  if (v13 < 9)
  {
    v15 = 0;
  }
  else
  {
    v15 = operator new(4 * v13);
    __p = v15;
    v53 = v15;
    v55 = v13;
    v14 = v15;
  }
  v49[0] = v58;
  v49[1] = 0;
  v49[2] = v14;
  memset(&v49[3], 0, 13);
  if (*(_BYTE *)(v11 + 12) || !**(_DWORD **)a1)
  {
    LODWORD(v49[3]) = 2;
    LODWORD(v49[4]) = 0;
    v58[0] = 0x3F0000003F000000;
    v44 = 1;
  }
  else
  {
    v44 = 0;
  }
  v47 = v46;
  if (*(int *)(v46 + 4) >= 1)
  {
    v16 = 0;
    v45 = v8;
    do
    {
      v17 = *(int *)(v8[27] + 4 * v16);
      if ((_DWORD)v17 != -1)
      {
        v18 = (int *)(v12[18] + 4 * *(int *)(v12[12] + 4 * v17));
        if ((*(_BYTE *)(v12[21] + *v18) & 1) != 0)
        {
          v37 = v12[9];
          v38 = *(unsigned __int16 *)(v37 + 2 * v17);
          if (*(_WORD *)(v37 + 2 * v17))
          {
            v39 = 0;
            do
            {
              sub_1B2208948((_QWORD *)v11, v16, *(unsigned __int16 *)(*(_QWORD *)(v10 + 40)+ 2 * (v39 + *(int *)(*(_QWORD *)(*(_QWORD *)(v10 + 32) + 96) + 4 * v17))), &v51);
              v40.i64[0] = 0x3F0000003F000000;
              v40.i64[1] = 0x3F0000003F000000;
              v41 = v18[v39];
              *(_OWORD *)(*a4 + 16 * v41) = 0u;
              v42 = v52;
              *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v41), v40, *(float32x4_t *)(*a3 + 16 * v51));
              *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v41), v40, *(float32x4_t *)(*a3 + 16 * v42));
              ++v39;
            }
            while (v38 != v39);
          }
        }
        else
        {
          if ((v44 & 1) == 0)
          {
            v48 = v16;
            if (*(float *)(*(_QWORD *)(v46 + 216) + 4 * v16) <= 0.0)
              v19 = 1;
            else
              v19 = 4;
            sub_1B192BFA0(&v50, (int *)&v47, (uint64_t)v49, v19, (*(unsigned __int16 *)(*(_QWORD *)(v43 + 432) + 2 * v17) >> 7) & 0xF);
          }
          sub_1B2208948((_QWORD *)v11, v16, 0, &v51);
          v20 = *v18;
          *(_OWORD *)(*a4 + 16 * v20) = 0u;
          v21 = v52;
          v22 = (float32x2_t)v58[0];
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v51), *(float *)v58);
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v21), v22, 1);
          if (SLODWORD(v49[4]) >= 1)
          {
            v23 = (unsigned int *)(*(_QWORD *)(v46 + 144) + 8 * v16);
            v24 = *v23;
            if ((int)v24 >= 1)
            {
              v25 = 0;
              v26 = *(_QWORD *)(v46 + 168) + 4 * (int)v23[1];
              do
              {
                v27 = *(int *)(v26 + 4 * v25);
                if (BYTE4(v49[4]))
                {
                  v28 = (int *)(v12[12] + 4 * *(int *)(v45[21] + 4 * v27));
                  v29 = *a4;
                  v30 = *a4;
                }
                else
                {
                  v31 = 0;
                  v32 = (2 * (int)v27) | 1;
                  v33 = *(_QWORD *)(v46 + 24);
                  v34 = *(_QWORD *)(v46 + 72) + 4 * *(int *)(v33 + 4 * v32);
                  v35 = *(_DWORD *)(v33 + 8 * v27);
                  do
                    v36 = *(unsigned int *)(v34 + 4 * v31++);
                  while (v16 != v36);
                  if ((int)v31 + 1 < v35)
                    v35 = 0;
                  v28 = (int *)(*(_QWORD *)(v11 + 24)
                              + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)v11 + 24) + 4 * v32)
                              + 4 * ((int)v31 - v35 + 1));
                  v30 = *a4;
                  v29 = *a3;
                }
                *(float32x4_t *)(v30 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(v30 + 16 * v20), *(float32x4_t *)(v29 + 16 * *v28), *(float *)&v53[4 * v25++]);
              }
              while (v25 != v24);
            }
          }
        }
      }
      ++v16;
      v8 = v45;
    }
    while (v16 < *(int *)(v46 + 4));
    v15 = __p;
  }
  operator delete(v15);
}

void sub_1B193106C(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  __int128 v12;
  _QWORD *v13;
  _QWORD *v14;
  _BOOL4 v15;
  _QWORD *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t *v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  float v43;
  float v44;
  _QWORD *v45;
  int v46;
  unsigned int v47;
  float v48;
  float v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _BOOL4 v54;
  _QWORD *v55;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  float v61;
  _QWORD v62[2];
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  _QWORD v68[5];
  uint64_t *v69;
  unsigned int v70;
  int v71;
  uint64_t v72;
  _DWORD *v73;
  uint64_t *v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v55 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v67 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v58 = v55[1];
  v50 = v55[2];
  v59 = *(_QWORD *)(*(_QWORD *)(v58 + 456) + 8 * a5);
  if (*(_BYTE *)(v59 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v54 = v7;
  v57 = *(_QWORD **)(v55[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v50 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v58 + 20);
  v74 = &v77;
  v75 = 2 * v9;
  v76 = 32;
  v78 = 0;
  if (2 * v9 >= 0x21)
  {
    v78 = (uint64_t *)operator new(8 * v9);
    v74 = v78;
    v76 = 2 * v9;
    v9 = *(_DWORD *)(v58 + 20);
  }
  v10 = 0;
  v69 = &v72;
  v70 = v9;
  v71 = 16;
  v73 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v73 = v10;
    v69 = (uint64_t *)v10;
    v71 = v9;
  }
  v62[0] = v58;
  v62[1] = v50;
  if (*(int *)(v58 + 8) >= 1)
  {
    v51 = v8;
    v11 = 0;
    v12 = 0uLL;
    v14 = v55;
    v13 = a3;
    v15 = v54;
    v16 = v57;
    do
    {
      v60 = *(_DWORD *)(v14[30] + 4 * v11);
      if (v60 != -1)
      {
        v17 = *(int *)(*(_QWORD *)(v59 + 96) + 4 * v11);
        v18 = (int *)(*(_QWORD *)(v59 + 144) + 4 * v17);
        v19 = *(int *)(v51[12] + 4 * v60);
        v20 = (int *)(v51[18] + 4 * v19);
        v21 = *v20;
        v22 = v51[21];
        if ((*(_BYTE *)(v22 + v21) & 1) == 0 && v15)
        {
          *(_OWORD *)(*a4 + 16 * v21) = v12;
          *(float32x4_t *)(*a4 + 16 * *v20) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * *v18), *(float32x4_t *)(*a4 + 16 * *v20));
        }
        else if ((*(_BYTE *)(v22 + v21) & 1) != 0)
        {
          v35 = v51[9];
          v36 = *(unsigned __int16 *)(v35 + 2 * v60);
          if (*(_WORD *)(v35 + 2 * v60))
          {
            v37 = 0;
            v52 = *(_QWORD *)(v59 + 144) + 4 * v17;
            v53 = *(_QWORD *)(v59 + 168) + v17;
            v38 = v22 + v19;
            do
            {
              v39 = *(unsigned __int16 *)(v16[5] + 2 * (v37 + *(int *)(*(_QWORD *)(v16[4] + 96) + 4 * v60)));
              v40 = v18[v39];
              v41 = v20[v37];
              *(_OWORD *)(*a4 + 16 * v41) = v12;
              if (!v15 && (*(_BYTE *)(v38 + v37) & 8) != 0)
              {
                v42 = v38;
                sub_1B22087A4((_QWORD *)v59, v11, v39, v68);
                if ((*(_BYTE *)(v53 + v39) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v53 + v39) & 0x20) != 0)
                  {
                    v47 = v39 == 0;
                    v45 = v57;
                    v46 = v11;
                  }
                  else
                  {
                    v45 = v57;
                    v46 = v11;
                    v47 = v39;
                  }
                  v48 = sub_1B221C7C8(v45, v46, v47, v60);
                  v49 = 1.0 - v48;
                  v44 = v48 + (float)((float)(1.0 - v48) * 0.75);
                  v43 = v49 * 0.125;
                }
                else
                {
                  v43 = 0.125;
                  v44 = 0.75;
                }
                v14 = v55;
                v13 = a3;
                v15 = v54;
                v16 = v57;
                v12 = 0uLL;
                v38 = v42;
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * SLODWORD(v68[0])), v43);
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * SHIDWORD(v68[0])), v43);
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * v40), v44);
                v18 = (int *)v52;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v41) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * v40), *(float32x4_t *)(*a4 + 16 * v41));
              }
              ++v37;
            }
            while (v36 != v37);
          }
        }
        else
        {
          v24 = *(int *)(*(_QWORD *)(v58 + 336) + 8 * v11);
          v61 = 0.0;
          v25 = v74;
          v26 = (_DWORD *)v74 + v24;
          v68[0] = &v61;
          v68[1] = v74;
          v68[2] = v26;
          memset(&v68[3], 0, 13);
          v63 = v11;
          v64 = v60;
          v65 = *(_DWORD *)(*(_QWORD *)(v62[0] + 336) + 8 * v11);
          v66 = *(_DWORD *)(*(_QWORD *)(v62[0] + 264) + 8 * v11);
          sub_1B192C184(&v67, (uint64_t)v62, (uint64_t)v68, (*(unsigned __int16 *)(*(_QWORD *)(v58 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v50 + 432) + 2 * v60) >> 7) & 0xF);
          v12 = 0uLL;
          v14 = v55;
          v27 = *v18;
          v28 = *v20;
          *(_OWORD *)(*a4 + 16 * v28) = 0u;
          if (SLODWORD(v68[4]) >= 1)
          {
            v29 = *(_QWORD *)(v58 + 264);
            v30 = *(unsigned int *)(v29 + 8 * v11);
            if ((int)v30 >= 1)
            {
              v31 = (int *)(*(_QWORD *)(v58 + 288) + 4 * *(int *)(v29 + ((8 * v11) | 4)));
              do
              {
                v32 = *v31++;
                v33 = *(int *)(v51[12] + 4 * *(int *)(v55[21] + 4 * v32));
                LODWORD(v32) = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * v33), *(float *)&v32);
                --v30;
              }
              while (v30);
            }
          }
          v13 = a3;
          if (SHIDWORD(v68[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v59, v11, v69);
            v12 = 0uLL;
            v14 = v55;
            v13 = a3;
            if ((int)v24 >= 1)
            {
              v34 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * *(int *)((char *)v69 + v34)), *(float *)((char *)v25 + v34));
                v34 += 4;
              }
              while (4 * v24 != v34);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v13 + 16 * v27), v61);
          v15 = v54;
          v16 = v57;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v58 + 8));
    v10 = v73;
  }
  operator delete(v10);
  operator delete(v78);
}

void sub_1B19315D8(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  void *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  float32x4_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float32x4_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t *v29;
  int v30;
  int v31;
  uint64_t v32;
  void *__p;
  uint64_t v34;

  v8 = 0;
  v34 = *MEMORY[0x1E0C80C00];
  v25 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v26 = v25[1];
  v9 = *(_QWORD *)(v25[60] + 8 * a5);
  v10 = *(_QWORD **)(*(_QWORD *)(v26 + 456) + 8 * a5);
  v11 = *(_QWORD **)(*(_QWORD *)(v25[2] + 456) + 8 * a5);
  v12 = *(unsigned int *)(v26 + 16);
  v29 = &v32;
  v30 = v12;
  v31 = 8;
  __p = 0;
  if (v12 >= 9)
  {
    v8 = operator new(4 * v12);
    __p = v8;
    v29 = (uint64_t *)v8;
    v31 = v12;
  }
  if (*(int *)(v26 + 4) >= 1)
  {
    v13 = 0;
    do
    {
      v14 = *(int *)(v25[27] + 4 * v13);
      if ((_DWORD)v14 != -1)
      {
        v15 = (int *)(v11[18] + 4 * *(int *)(v11[12] + 4 * v14));
        if ((*(_BYTE *)(v11[21] + *v15) & 1) != 0)
        {
          v19 = v11[9];
          v20 = *(unsigned __int16 *)(v19 + 2 * v14);
          if (*(_WORD *)(v19 + 2 * v14))
          {
            v21 = 0;
            do
            {
              sub_1B2208948(v10, v13, *(unsigned __int16 *)(*(_QWORD *)(v9 + 40)+ 2 * (v21 + *(int *)(*(_QWORD *)(*(_QWORD *)(v9 + 32) + 96) + 4 * v14))), &v27);
              v22.i64[0] = 0x3F0000003F000000;
              v22.i64[1] = 0x3F0000003F000000;
              v23 = v15[v21];
              *(_OWORD *)(*a4 + 16 * v23) = 0u;
              v24 = v28;
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v23), v22, *(float32x4_t *)(*a3 + 16 * v27));
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v23), v22, *(float32x4_t *)(*a3 + 16 * v24));
              ++v21;
            }
            while (v20 != v21);
          }
        }
        else
        {
          sub_1B2208948(v10, v13, 0, &v27);
          v16.i64[0] = 0x3F0000003F000000;
          v16.i64[1] = 0x3F0000003F000000;
          v17 = *v15;
          *(_OWORD *)(*a4 + 16 * v17) = 0u;
          v18 = v28;
          *(float32x4_t *)(*a4 + 16 * v17) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v17), v16, *(float32x4_t *)(*a3 + 16 * v27));
          *(float32x4_t *)(*a4 + 16 * v17) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v17), v16, *(float32x4_t *)(*a3 + 16 * v18));
        }
      }
      ++v13;
    }
    while (v13 < *(int *)(v26 + 4));
    v8 = __p;
  }
  operator delete(v8);
}

void sub_1B1931808(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  _QWORD *v11;
  unsigned int v12;
  void *v13;
  uint64_t v14;
  __int128 v15;
  _QWORD *v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  float32x4_t *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float v35;
  float v36;
  _QWORD *v37;
  int v38;
  unsigned int v39;
  float v40;
  float v41;
  uint64_t v42;
  _QWORD *v43;
  _BOOL4 v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _DWORD v52[2];
  uint64_t *v53;
  unsigned int v54;
  int v55;
  uint64_t v56;
  void *__p;
  uint64_t *v58;
  int v59;
  int v60;
  uint64_t v61;
  void *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v7 = v6[2];
  v49 = v6;
  v50 = v6[1];
  v8 = v6[60];
  v9 = *(_QWORD *)(v7 + 456);
  v51 = *(_QWORD *)(*(_QWORD *)(v50 + 456) + 8 * a5);
  if (*(_BYTE *)(v51 + 12))
    v10 = 1;
  else
    v10 = **(_DWORD **)a1 == 0;
  v44 = v10;
  v11 = *(_QWORD **)(v8 + 8 * a5);
  v43 = *(_QWORD **)(v9 + 8 * a5);
  v12 = *(_DWORD *)(v50 + 20);
  v58 = &v61;
  v59 = 2 * v12;
  v60 = 32;
  v62 = 0;
  if (2 * v12 >= 0x21)
  {
    v62 = operator new(8 * v12);
    v58 = (uint64_t *)v62;
    v60 = 2 * v12;
    v12 = *(_DWORD *)(v50 + 20);
  }
  v13 = 0;
  v53 = &v56;
  v54 = v12;
  v55 = 16;
  __p = 0;
  if (v12 >= 0x11)
  {
    v13 = operator new(4 * v12);
    __p = v13;
    v53 = (uint64_t *)v13;
    v55 = v12;
  }
  if (*(int *)(v50 + 8) >= 1)
  {
    v14 = 0;
    v15 = 0uLL;
    v16 = a3;
    v17 = v44;
    while (1)
    {
      v18 = *(int *)(v49[30] + 4 * v14);
      if ((_DWORD)v18 != -1)
      {
        v19 = *(int *)(*(_QWORD *)(v51 + 96) + 4 * v14);
        v20 = (int *)(*(_QWORD *)(v51 + 144) + 4 * v19);
        v21 = *(int *)(v43[12] + 4 * v18);
        v22 = (int *)(v43[18] + 4 * v21);
        v23 = *v22;
        v24 = v43[21];
        if ((*(_BYTE *)(v24 + v23) & 1) == 0 && v17)
        {
          *(_OWORD *)(*a4 + 16 * v23) = v15;
          v26 = (float32x4_t *)(*a4 + 16 * *v22);
          v27 = *v20;
        }
        else
        {
          if ((*(_BYTE *)(v24 + v23) & 1) != 0)
          {
            v28 = v43[9];
            v29 = *(unsigned __int16 *)(v28 + 2 * v18);
            if (*(_WORD *)(v28 + 2 * v18))
            {
              v30 = 0;
              v47 = *(_QWORD *)(v51 + 168) + v19;
              v48 = *(unsigned __int16 *)(v28 + 2 * v18);
              v31 = v24 + v21;
              v46 = v24 + v21;
              do
              {
                v32 = *(unsigned __int16 *)(v11[5] + 2 * (v30 + *(int *)(*(_QWORD *)(v11[4] + 96) + 4 * v18)));
                v33 = v20[v32];
                v34 = v22[v30];
                *(_OWORD *)(*a4 + 16 * v34) = v15;
                if (!v17 && (*(_BYTE *)(v31 + v30) & 8) != 0)
                {
                  sub_1B22087A4((_QWORD *)v51, v14, v32, v52);
                  if ((*(_BYTE *)(v47 + v32) & 0x10) != 0)
                  {
                    if ((*(_BYTE *)(v47 + v32) & 0x20) != 0)
                    {
                      v39 = v32 == 0;
                      v37 = v11;
                      v38 = v14;
                    }
                    else
                    {
                      v37 = v11;
                      v38 = v14;
                      v39 = v32;
                    }
                    v40 = sub_1B221C7C8(v37, v38, v39, v18);
                    v41 = 1.0 - v40;
                    v36 = v40 + (float)((float)(1.0 - v40) * 0.75);
                    v35 = v41 * 0.125;
                  }
                  else
                  {
                    v35 = 0.125;
                    v36 = 0.75;
                  }
                  v16 = a3;
                  v31 = v46;
                  v17 = v44;
                  v15 = 0uLL;
                  v29 = v48;
                  v42 = v52[1];
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v52[0]), v35);
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v42), v35);
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v33), v36);
                }
                else
                {
                  *(float32x4_t *)(*a4 + 16 * v34) = vaddq_f32(*(float32x4_t *)(*v16 + 16 * v33), *(float32x4_t *)(*a4 + 16 * v34));
                }
                ++v30;
              }
              while (v29 != v30);
            }
            goto LABEL_19;
          }
          v27 = *v20;
          *(_OWORD *)(*a4 + 16 * v23) = v15;
          v26 = (float32x4_t *)(*a4 + 16 * v23);
        }
        *v26 = vaddq_f32(*(float32x4_t *)(*v16 + 16 * v27), *v26);
      }
LABEL_19:
      if (++v14 >= *(int *)(v50 + 8))
      {
        v13 = __p;
        break;
      }
    }
  }
  operator delete(v13);
  operator delete(v62);
}

void sub_1B1931BAC(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  __int128 v12;
  _QWORD *v13;
  _QWORD *v14;
  _BOOL4 v15;
  _QWORD *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t *v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  float v43;
  float v44;
  _QWORD *v45;
  int v46;
  unsigned int v47;
  float v48;
  float v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _BOOL4 v54;
  _QWORD *v55;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  float v61;
  _QWORD v62[2];
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  _QWORD v68[5];
  uint64_t *v69;
  unsigned int v70;
  int v71;
  uint64_t v72;
  _DWORD *v73;
  uint64_t *v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v55 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v67 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v58 = v55[1];
  v50 = v55[2];
  v59 = *(_QWORD *)(*(_QWORD *)(v58 + 456) + 8 * a5);
  if (*(_BYTE *)(v59 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v54 = v7;
  v57 = *(_QWORD **)(v55[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v50 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v58 + 20);
  v74 = &v77;
  v75 = 2 * v9;
  v76 = 32;
  v78 = 0;
  if (2 * v9 >= 0x21)
  {
    v78 = (uint64_t *)operator new(8 * v9);
    v74 = v78;
    v76 = 2 * v9;
    v9 = *(_DWORD *)(v58 + 20);
  }
  v10 = 0;
  v69 = &v72;
  v70 = v9;
  v71 = 16;
  v73 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v73 = v10;
    v69 = (uint64_t *)v10;
    v71 = v9;
  }
  v62[0] = v58;
  v62[1] = v50;
  if (*(int *)(v58 + 8) >= 1)
  {
    v51 = v8;
    v11 = 0;
    v12 = 0uLL;
    v14 = v55;
    v13 = a3;
    v15 = v54;
    v16 = v57;
    do
    {
      v60 = *(_DWORD *)(v14[30] + 4 * v11);
      if (v60 != -1)
      {
        v17 = *(int *)(*(_QWORD *)(v59 + 96) + 4 * v11);
        v18 = (int *)(*(_QWORD *)(v59 + 144) + 4 * v17);
        v19 = *(int *)(v51[12] + 4 * v60);
        v20 = (int *)(v51[18] + 4 * v19);
        v21 = *v20;
        v22 = v51[21];
        if ((*(_BYTE *)(v22 + v21) & 1) == 0 && v15)
        {
          *(_OWORD *)(*a4 + 16 * v21) = v12;
          *(float32x4_t *)(*a4 + 16 * *v20) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * *v18), *(float32x4_t *)(*a4 + 16 * *v20));
        }
        else if ((*(_BYTE *)(v22 + v21) & 1) != 0)
        {
          v35 = v51[9];
          v36 = *(unsigned __int16 *)(v35 + 2 * v60);
          if (*(_WORD *)(v35 + 2 * v60))
          {
            v37 = 0;
            v52 = *(_QWORD *)(v59 + 144) + 4 * v17;
            v53 = *(_QWORD *)(v59 + 168) + v17;
            v38 = v22 + v19;
            do
            {
              v39 = *(unsigned __int16 *)(v16[5] + 2 * (v37 + *(int *)(*(_QWORD *)(v16[4] + 96) + 4 * v60)));
              v40 = v18[v39];
              v41 = v20[v37];
              *(_OWORD *)(*a4 + 16 * v41) = v12;
              if (!v15 && (*(_BYTE *)(v38 + v37) & 8) != 0)
              {
                v42 = v38;
                sub_1B22087A4((_QWORD *)v59, v11, v39, v68);
                if ((*(_BYTE *)(v53 + v39) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v53 + v39) & 0x20) != 0)
                  {
                    v47 = v39 == 0;
                    v45 = v57;
                    v46 = v11;
                  }
                  else
                  {
                    v45 = v57;
                    v46 = v11;
                    v47 = v39;
                  }
                  v48 = sub_1B221C7C8(v45, v46, v47, v60);
                  v49 = 1.0 - v48;
                  v44 = v48 + (float)((float)(1.0 - v48) * 0.75);
                  v43 = v49 * 0.125;
                }
                else
                {
                  v43 = 0.125;
                  v44 = 0.75;
                }
                v14 = v55;
                v13 = a3;
                v15 = v54;
                v16 = v57;
                v12 = 0uLL;
                v38 = v42;
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * SLODWORD(v68[0])), v43);
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * SHIDWORD(v68[0])), v43);
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * v40), v44);
                v18 = (int *)v52;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v41) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * v40), *(float32x4_t *)(*a4 + 16 * v41));
              }
              ++v37;
            }
            while (v36 != v37);
          }
        }
        else
        {
          v24 = *(int *)(*(_QWORD *)(v58 + 336) + 8 * v11);
          v61 = 0.0;
          v25 = v74;
          v26 = (_DWORD *)v74 + v24;
          v68[0] = &v61;
          v68[1] = v74;
          v68[2] = v26;
          memset(&v68[3], 0, 13);
          v63 = v11;
          v64 = v60;
          v65 = *(_DWORD *)(*(_QWORD *)(v62[0] + 336) + 8 * v11);
          v66 = *(_DWORD *)(*(_QWORD *)(v62[0] + 264) + 8 * v11);
          sub_1B192B8C0(&v67, (uint64_t)v62, (uint64_t)v68, (*(unsigned __int16 *)(*(_QWORD *)(v58 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v50 + 432) + 2 * v60) >> 7) & 0xF);
          v12 = 0uLL;
          v14 = v55;
          v27 = *v18;
          v28 = *v20;
          *(_OWORD *)(*a4 + 16 * v28) = 0u;
          if (SLODWORD(v68[4]) >= 1)
          {
            v29 = *(_QWORD *)(v58 + 264);
            v30 = *(unsigned int *)(v29 + 8 * v11);
            if ((int)v30 >= 1)
            {
              v31 = (int *)(*(_QWORD *)(v58 + 288) + 4 * *(int *)(v29 + ((8 * v11) | 4)));
              do
              {
                v32 = *v31++;
                v33 = *(int *)(v51[12] + 4 * *(int *)(v55[21] + 4 * v32));
                LODWORD(v32) = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * v33), *(float *)&v32);
                --v30;
              }
              while (v30);
            }
          }
          v13 = a3;
          if (SHIDWORD(v68[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v59, v11, v69);
            v12 = 0uLL;
            v14 = v55;
            v13 = a3;
            if ((int)v24 >= 1)
            {
              v34 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * *(int *)((char *)v69 + v34)), *(float *)((char *)v25 + v34));
                v34 += 4;
              }
              while (4 * v24 != v34);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v13 + 16 * v27), v61);
          v15 = v54;
          v16 = v57;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v58 + 8));
    v10 = v73;
  }
  operator delete(v10);
  operator delete(v78);
}

void sub_1B1932118(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  __int128 v12;
  _QWORD *v13;
  _QWORD *v14;
  _BOOL4 v15;
  _QWORD *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t *v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  float v43;
  float v44;
  _QWORD *v45;
  int v46;
  unsigned int v47;
  float v48;
  float v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _BOOL4 v54;
  _QWORD *v55;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  float v61;
  _QWORD v62[2];
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  _QWORD v68[5];
  uint64_t *v69;
  unsigned int v70;
  int v71;
  uint64_t v72;
  _DWORD *v73;
  uint64_t *v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v55 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v67 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v58 = v55[1];
  v50 = v55[2];
  v59 = *(_QWORD *)(*(_QWORD *)(v58 + 456) + 8 * a5);
  if (*(_BYTE *)(v59 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v54 = v7;
  v57 = *(_QWORD **)(v55[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v50 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v58 + 20);
  v74 = &v77;
  v75 = 2 * v9;
  v76 = 32;
  v78 = 0;
  if (2 * v9 >= 0x21)
  {
    v78 = (uint64_t *)operator new(8 * v9);
    v74 = v78;
    v76 = 2 * v9;
    v9 = *(_DWORD *)(v58 + 20);
  }
  v10 = 0;
  v69 = &v72;
  v70 = v9;
  v71 = 16;
  v73 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v73 = v10;
    v69 = (uint64_t *)v10;
    v71 = v9;
  }
  v62[0] = v58;
  v62[1] = v50;
  if (*(int *)(v58 + 8) >= 1)
  {
    v51 = v8;
    v11 = 0;
    v12 = 0uLL;
    v14 = v55;
    v13 = a3;
    v15 = v54;
    v16 = v57;
    do
    {
      v60 = *(_DWORD *)(v14[30] + 4 * v11);
      if (v60 != -1)
      {
        v17 = *(int *)(*(_QWORD *)(v59 + 96) + 4 * v11);
        v18 = (int *)(*(_QWORD *)(v59 + 144) + 4 * v17);
        v19 = *(int *)(v51[12] + 4 * v60);
        v20 = (int *)(v51[18] + 4 * v19);
        v21 = *v20;
        v22 = v51[21];
        if ((*(_BYTE *)(v22 + v21) & 1) == 0 && v15)
        {
          *(_OWORD *)(*a4 + 16 * v21) = v12;
          *(float32x4_t *)(*a4 + 16 * *v20) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * *v18), *(float32x4_t *)(*a4 + 16 * *v20));
        }
        else if ((*(_BYTE *)(v22 + v21) & 1) != 0)
        {
          v35 = v51[9];
          v36 = *(unsigned __int16 *)(v35 + 2 * v60);
          if (*(_WORD *)(v35 + 2 * v60))
          {
            v37 = 0;
            v52 = *(_QWORD *)(v59 + 144) + 4 * v17;
            v53 = *(_QWORD *)(v59 + 168) + v17;
            v38 = v22 + v19;
            do
            {
              v39 = *(unsigned __int16 *)(v16[5] + 2 * (v37 + *(int *)(*(_QWORD *)(v16[4] + 96) + 4 * v60)));
              v40 = v18[v39];
              v41 = v20[v37];
              *(_OWORD *)(*a4 + 16 * v41) = v12;
              if (!v15 && (*(_BYTE *)(v38 + v37) & 8) != 0)
              {
                v42 = v38;
                sub_1B22087A4((_QWORD *)v59, v11, v39, v68);
                if ((*(_BYTE *)(v53 + v39) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v53 + v39) & 0x20) != 0)
                  {
                    v47 = v39 == 0;
                    v45 = v57;
                    v46 = v11;
                  }
                  else
                  {
                    v45 = v57;
                    v46 = v11;
                    v47 = v39;
                  }
                  v48 = sub_1B221C7C8(v45, v46, v47, v60);
                  v49 = 1.0 - v48;
                  v44 = v48 + (float)((float)(1.0 - v48) * 0.75);
                  v43 = v49 * 0.125;
                }
                else
                {
                  v43 = 0.125;
                  v44 = 0.75;
                }
                v14 = v55;
                v13 = a3;
                v15 = v54;
                v16 = v57;
                v12 = 0uLL;
                v38 = v42;
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * SLODWORD(v68[0])), v43);
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * SHIDWORD(v68[0])), v43);
                *(float32x4_t *)(*a4 + 16 * v41) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v41), *(float32x4_t *)(*a3 + 16 * v40), v44);
                v18 = (int *)v52;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v41) = vaddq_f32(*(float32x4_t *)(*v13 + 16 * v40), *(float32x4_t *)(*a4 + 16 * v41));
              }
              ++v37;
            }
            while (v36 != v37);
          }
        }
        else
        {
          v24 = *(int *)(*(_QWORD *)(v58 + 336) + 8 * v11);
          v61 = 0.0;
          v25 = v74;
          v26 = (_DWORD *)v74 + v24;
          v68[0] = &v61;
          v68[1] = v74;
          v68[2] = v26;
          memset(&v68[3], 0, 13);
          v63 = v11;
          v64 = v60;
          v65 = *(_DWORD *)(*(_QWORD *)(v62[0] + 336) + 8 * v11);
          v66 = *(_DWORD *)(*(_QWORD *)(v62[0] + 264) + 8 * v11);
          sub_1B192C184(&v67, (uint64_t)v62, (uint64_t)v68, (*(unsigned __int16 *)(*(_QWORD *)(v58 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v50 + 432) + 2 * v60) >> 7) & 0xF);
          v12 = 0uLL;
          v14 = v55;
          v27 = *v18;
          v28 = *v20;
          *(_OWORD *)(*a4 + 16 * v28) = 0u;
          if (SLODWORD(v68[4]) >= 1)
          {
            v29 = *(_QWORD *)(v58 + 264);
            v30 = *(unsigned int *)(v29 + 8 * v11);
            if ((int)v30 >= 1)
            {
              v31 = (int *)(*(_QWORD *)(v58 + 288) + 4 * *(int *)(v29 + ((8 * v11) | 4)));
              do
              {
                v32 = *v31++;
                v33 = *(int *)(v51[12] + 4 * *(int *)(v55[21] + 4 * v32));
                LODWORD(v32) = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * v33), *(float *)&v32);
                --v30;
              }
              while (v30);
            }
          }
          v13 = a3;
          if (SHIDWORD(v68[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v59, v11, v69);
            v12 = 0uLL;
            v14 = v55;
            v13 = a3;
            if ((int)v24 >= 1)
            {
              v34 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * *(int *)((char *)v69 + v34)), *(float *)((char *)v25 + v34));
                v34 += 4;
              }
              while (4 * v24 != v34);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v13 + 16 * v27), v61);
          v15 = v54;
          v16 = v57;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v58 + 8));
    v10 = v73;
  }
  operator delete(v10);
  operator delete(v78);
}

void sub_1B1932684(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  _QWORD *v11;
  unsigned int v12;
  void *v13;
  uint64_t v14;
  __int128 v15;
  _QWORD *v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  float32x4_t *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float v35;
  float v36;
  _QWORD *v37;
  int v38;
  unsigned int v39;
  float v40;
  float v41;
  uint64_t v42;
  _QWORD *v43;
  _BOOL4 v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _DWORD v52[2];
  uint64_t *v53;
  unsigned int v54;
  int v55;
  uint64_t v56;
  void *__p;
  uint64_t *v58;
  int v59;
  int v60;
  uint64_t v61;
  void *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v7 = v6[2];
  v49 = v6;
  v50 = v6[1];
  v8 = v6[60];
  v9 = *(_QWORD *)(v7 + 456);
  v51 = *(_QWORD *)(*(_QWORD *)(v50 + 456) + 8 * a5);
  if (*(_BYTE *)(v51 + 12))
    v10 = 1;
  else
    v10 = **(_DWORD **)a1 == 0;
  v44 = v10;
  v11 = *(_QWORD **)(v8 + 8 * a5);
  v43 = *(_QWORD **)(v9 + 8 * a5);
  v12 = *(_DWORD *)(v50 + 20);
  v58 = &v61;
  v59 = 2 * v12;
  v60 = 32;
  v62 = 0;
  if (2 * v12 >= 0x21)
  {
    v62 = operator new(8 * v12);
    v58 = (uint64_t *)v62;
    v60 = 2 * v12;
    v12 = *(_DWORD *)(v50 + 20);
  }
  v13 = 0;
  v53 = &v56;
  v54 = v12;
  v55 = 16;
  __p = 0;
  if (v12 >= 0x11)
  {
    v13 = operator new(4 * v12);
    __p = v13;
    v53 = (uint64_t *)v13;
    v55 = v12;
  }
  if (*(int *)(v50 + 8) >= 1)
  {
    v14 = 0;
    v15 = 0uLL;
    v16 = a3;
    v17 = v44;
    while (1)
    {
      v18 = *(int *)(v49[30] + 4 * v14);
      if ((_DWORD)v18 != -1)
      {
        v19 = *(int *)(*(_QWORD *)(v51 + 96) + 4 * v14);
        v20 = (int *)(*(_QWORD *)(v51 + 144) + 4 * v19);
        v21 = *(int *)(v43[12] + 4 * v18);
        v22 = (int *)(v43[18] + 4 * v21);
        v23 = *v22;
        v24 = v43[21];
        if ((*(_BYTE *)(v24 + v23) & 1) == 0 && v17)
        {
          *(_OWORD *)(*a4 + 16 * v23) = v15;
          v26 = (float32x4_t *)(*a4 + 16 * *v22);
          v27 = *v20;
        }
        else
        {
          if ((*(_BYTE *)(v24 + v23) & 1) != 0)
          {
            v28 = v43[9];
            v29 = *(unsigned __int16 *)(v28 + 2 * v18);
            if (*(_WORD *)(v28 + 2 * v18))
            {
              v30 = 0;
              v47 = *(_QWORD *)(v51 + 168) + v19;
              v48 = *(unsigned __int16 *)(v28 + 2 * v18);
              v31 = v24 + v21;
              v46 = v24 + v21;
              do
              {
                v32 = *(unsigned __int16 *)(v11[5] + 2 * (v30 + *(int *)(*(_QWORD *)(v11[4] + 96) + 4 * v18)));
                v33 = v20[v32];
                v34 = v22[v30];
                *(_OWORD *)(*a4 + 16 * v34) = v15;
                if (!v17 && (*(_BYTE *)(v31 + v30) & 8) != 0)
                {
                  sub_1B22087A4((_QWORD *)v51, v14, v32, v52);
                  if ((*(_BYTE *)(v47 + v32) & 0x10) != 0)
                  {
                    if ((*(_BYTE *)(v47 + v32) & 0x20) != 0)
                    {
                      v39 = v32 == 0;
                      v37 = v11;
                      v38 = v14;
                    }
                    else
                    {
                      v37 = v11;
                      v38 = v14;
                      v39 = v32;
                    }
                    v40 = sub_1B221C7C8(v37, v38, v39, v18);
                    v41 = 1.0 - v40;
                    v36 = v40 + (float)((float)(1.0 - v40) * 0.75);
                    v35 = v41 * 0.125;
                  }
                  else
                  {
                    v35 = 0.125;
                    v36 = 0.75;
                  }
                  v16 = a3;
                  v31 = v46;
                  v17 = v44;
                  v15 = 0uLL;
                  v29 = v48;
                  v42 = v52[1];
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v52[0]), v35);
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v42), v35);
                  *(float32x4_t *)(*a4 + 16 * v34) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v34), *(float32x4_t *)(*a3 + 16 * v33), v36);
                }
                else
                {
                  *(float32x4_t *)(*a4 + 16 * v34) = vaddq_f32(*(float32x4_t *)(*v16 + 16 * v33), *(float32x4_t *)(*a4 + 16 * v34));
                }
                ++v30;
              }
              while (v29 != v30);
            }
            goto LABEL_19;
          }
          v27 = *v20;
          *(_OWORD *)(*a4 + 16 * v23) = v15;
          v26 = (float32x4_t *)(*a4 + 16 * v23);
        }
        *v26 = vaddq_f32(*(float32x4_t *)(*v16 + 16 * v27), *v26);
      }
LABEL_19:
      if (++v14 >= *(int *)(v50 + 8))
      {
        v13 = __p;
        break;
      }
    }
  }
  operator delete(v13);
  operator delete(v62);
}

void sub_1B1932A28(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  int v8;
  void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  float32x4_t v17;
  uint64_t v18;
  int *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t i;
  uint64_t v26;
  _QWORD *v27;
  void *__p;
  void *v29;

  v8 = *(_DWORD *)*a1;
  if (v8)
  {
    if (v8 == 2)
    {
      sub_1B1933184((uint64_t)a1, a2, a3, a4);
      sub_1B1933844(a1, a2, a3, a4);
      sub_1B1933AD8(a1, a2, a3, a4);
    }
    else if (v8 == 1)
    {
      sub_1B1933184((uint64_t)a1, a2, a3, a4);
      sub_1B1933314(a1, a2, a3, a4);
      sub_1B19335A8(a1, a2, a3, a4);
    }
  }
  else
  {
    sub_1B1933184((uint64_t)a1, a2, a3, a4);
    v9 = 0;
    v10 = a2 - 1;
    v11 = *(_QWORD *)(*(_QWORD *)(*a1 + 64) + 8 * (a2 - 1));
    v12 = *(_QWORD *)(v11 + 8);
    v13 = *(unsigned int *)(v12 + 16);
    __p = 0;
    if (v13 >= 9)
    {
      v9 = operator new(4 * v13);
      __p = v9;
    }
    v14 = *(_DWORD *)(v12 + 4);
    if (v14 >= 1)
    {
      v15 = 0;
      v16 = 0;
      v17.i64[0] = 0x3F0000003F000000;
      v17.i64[1] = 0x3F0000003F000000;
      do
      {
        v18 = *(int *)(*(_QWORD *)(v11 + 216) + 4 * v16);
        if ((_DWORD)v18 != -1)
        {
          v19 = (int *)(*(_QWORD *)(v12 + 120) + v15);
          v20 = (_QWORD *)(*a4 + 16 * v18);
          *v20 = 0;
          v20[1] = 0;
          *(float32x4_t *)(*a4 + 16 * v18) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v18), v17, *(float32x4_t *)(*a3 + 16 * *v19));
          *(float32x4_t *)(*a4 + 16 * v18) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v18), v17, *(float32x4_t *)(*a3 + 16 * v19[1]));
          v14 = *(_DWORD *)(v12 + 4);
        }
        ++v16;
        v15 += 8;
      }
      while (v16 < v14);
      v9 = __p;
    }
    operator delete(v9);
    v21 = 0;
    v22 = *(_QWORD *)(*(_QWORD *)(*a1 + 64) + 8 * v10);
    v23 = *(_QWORD *)(v22 + 8);
    v29 = 0;
    if ((2 * *(_DWORD *)(v23 + 20)) >= 0x21)
    {
      v21 = operator new(4 * (2 * *(_DWORD *)(v23 + 20)));
      v29 = v21;
    }
    v24 = *(_DWORD *)(v23 + 8);
    if (v24 >= 1)
    {
      for (i = 0; i < v24; ++i)
      {
        v26 = *(int *)(*(_QWORD *)(v22 + 240) + 4 * i);
        if ((_DWORD)v26 != -1)
        {
          v27 = (_QWORD *)(*a4 + 16 * v26);
          *v27 = 0;
          v27[1] = 0;
          *(float32x4_t *)(*a4 + 16 * v26) = vaddq_f32(*(float32x4_t *)(*a3 + 16 * i), *(float32x4_t *)(*a4 + 16 * v26));
          v24 = *(_DWORD *)(v23 + 8);
        }
      }
      v21 = v29;
    }
    operator delete(v21);
  }
}

uint64_t sub_1B1932D34(uint64_t result, int a2, _QWORD *a3, _QWORD *a4, double a5, float32x4_t a6)
{
  uint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  int *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  float32x4_t v19;
  uint64_t v20;
  int *v21;
  _QWORD *v22;
  int v23;
  uint64_t i;
  uint64_t v25;
  _QWORD *v26;

  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)result + 64) + 8 * (a2 - 1));
  v7 = *(int **)(v6 + 8);
  if (*(int *)(v6 + 52) >= 1 && *v7 >= 1)
  {
    v8 = 0;
    do
    {
      v9 = *(int *)(*(_QWORD *)(v6 + 168) + 4 * v8);
      if ((_DWORD)v9 != -1)
      {
        v10 = *((_QWORD *)v7 + 6);
        v11 = *(unsigned int *)(*((_QWORD *)v7 + 3) + 8 * v8);
        v12 = *(int *)(*((_QWORD *)v7 + 3) + 8 * v8 + 4);
        v13 = (_QWORD *)(*a4 + 16 * v9);
        *v13 = 0;
        v13[1] = 0;
        if ((int)v11 >= 1)
        {
          v14 = (int *)(v10 + 4 * v12);
          a6.f32[0] = 1.0 / (float)(int)v11;
          a6 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 0);
          do
          {
            v15 = *v14++;
            *(float32x4_t *)(*a4 + 16 * v9) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v9), *(float32x4_t *)(*a3 + 16 * v15), a6);
            --v11;
          }
          while (v11);
        }
      }
      ++v8;
    }
    while (v8 < *v7);
  }
  v16 = v7[1];
  if (v16 >= 1)
  {
    v17 = 0;
    v18 = 0;
    v19.i64[0] = 0x3F0000003F000000;
    v19.i64[1] = 0x3F0000003F000000;
    do
    {
      v20 = *(int *)(*(_QWORD *)(v6 + 216) + 4 * v18);
      if ((_DWORD)v20 != -1)
      {
        v21 = (int *)(*((_QWORD *)v7 + 15) + v17);
        v22 = (_QWORD *)(*a4 + 16 * v20);
        *v22 = 0;
        v22[1] = 0;
        *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v20), v19, *(float32x4_t *)(*a3 + 16 * *v21));
        *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v20), v19, *(float32x4_t *)(*a3 + 16 * v21[1]));
        v16 = v7[1];
      }
      ++v18;
      v17 += 8;
    }
    while (v18 < v16);
  }
  v23 = v7[2];
  if (v23 >= 1)
  {
    for (i = 0; i < v23; ++i)
    {
      v25 = *(int *)(*(_QWORD *)(v6 + 240) + 4 * i);
      if ((_DWORD)v25 != -1)
      {
        v26 = (_QWORD *)(*a4 + 16 * v25);
        *v26 = 0;
        v26[1] = 0;
        *(float32x4_t *)(*a4 + 16 * v25) = vaddq_f32(*(float32x4_t *)(*a3 + 16 * i), *(float32x4_t *)(*a4 + 16 * v25));
        v23 = v7[2];
      }
    }
  }
  return result;
}

void sub_1B1932EC4(int **a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  int v10;

  v10 = **a1;
  if (v10)
  {
    if (v10 == 2)
    {
      sub_1B1933D74((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1934854((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1934C18((uint64_t)a1, a2, a3, a4, a5);
    }
    else if (v10 == 1)
    {
      sub_1B1933D74((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1933F28((uint64_t)a1, a2, a3, a4, a5);
      sub_1B19342EC((uint64_t)a1, a2, a3, a4, a5);
    }
  }
  else
  {
    sub_1B1933D74((uint64_t)a1, a2, a3, a4, a5);
    sub_1B1935180((uint64_t)a1, a2, a3, a4, a5);
    sub_1B19353B0((uint64_t)a1, a2, a3, a4, a5);
  }
}

void sub_1B1933024(int **a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  int v10;

  v10 = **a1;
  if (v10)
  {
    if (v10 == 2)
    {
      sub_1B1933D74((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1934854((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1935CC0((uint64_t)a1, a2, a3, a4, a5);
    }
    else if (v10 == 1)
    {
      sub_1B1933D74((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1933F28((uint64_t)a1, a2, a3, a4, a5);
      sub_1B1935758((uint64_t)a1, a2, a3, a4, a5);
    }
  }
  else
  {
    sub_1B1933D74((uint64_t)a1, a2, a3, a4, a5);
    sub_1B1935180((uint64_t)a1, a2, a3, a4, a5);
    sub_1B1936228((uint64_t)a1, a2, a3, a4, a5);
  }
}

void sub_1B1933184(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  void *v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  uint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  float *v21;
  uint64_t v22;
  void *__p;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  if (*(_DWORD *)(v4 + 52))
  {
    v7 = 0;
    v8 = *(int **)(v4 + 8);
    v9 = v8[5];
    v21 = (float *)&v22;
    __p = 0;
    if (v9 >= 0x11)
    {
      v7 = operator new(4 * v9);
      __p = v7;
      v21 = (float *)v7;
    }
    if (*v8 >= 1)
    {
      v10 = 0;
      do
      {
        v11 = *(int *)(*(_QWORD *)(v4 + 168) + 4 * v10);
        if ((_DWORD)v11 != -1)
        {
          v12 = (unsigned int *)(*((_QWORD *)v8 + 3) + 8 * v10);
          v13 = *v12;
          if ((int)v13 < 1)
          {
            v20 = (_QWORD *)(*a4 + 16 * v11);
            *v20 = 0;
            v20[1] = 0;
          }
          else
          {
            v14 = *((_QWORD *)v8 + 6) + 4 * (int)v12[1];
            v15 = v21;
            v16 = v13;
            do
            {
              *v15++ = 1.0 / (float)(int)v13;
              --v16;
            }
            while (v16);
            v17 = (_QWORD *)(*a4 + 16 * v11);
            *v17 = 0;
            v17[1] = 0;
            v18 = 0;
            v19 = 4 * v13;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v11) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v11), *(float32x4_t *)(*a3 + 16 * *(int *)(v14 + v18)), v21[v18 / 4]);
              v18 += 4;
            }
            while (v19 != v18);
          }
        }
        ++v10;
      }
      while (v10 < *v8);
      v7 = __p;
    }
    operator delete(v7);
  }
}

void sub_1B1933314(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t i;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _QWORD *v21;
  float32x2_t v22;
  uint64_t j;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[5];
  uint64_t v36;
  int v37;
  int v38;
  float *v39;
  int v40;
  int v41;
  uint64_t v42;
  void *__p;
  _QWORD v44[3];

  v7 = 0;
  v44[1] = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v10 = v9[1];
  v34 = v9[2];
  v38 = *(_DWORD *)(v8 + 4);
  v11 = *(unsigned int *)(v10 + 16);
  v39 = (float *)&v42;
  v40 = v11;
  v41 = 8;
  v36 = v10;
  __p = 0;
  if (v11 >= 9)
  {
    v7 = operator new(4 * v11);
    __p = v7;
    v39 = (float *)v7;
    v41 = v11;
  }
  v12 = *(_DWORD *)(v10 + 4);
  if (v12 >= 1)
  {
    for (i = 0; i < v12; ++i)
    {
      v14 = *(int *)(v9[27] + 4 * i);
      if ((_DWORD)v14 != -1)
      {
        v15 = (int *)(*(_QWORD *)(v10 + 120) + 8 * i);
        v16 = *(_QWORD *)(v10 + 168);
        v17 = (unsigned int *)(*(_QWORD *)(v10 + 144) + 8 * i);
        v18 = *v17;
        v19 = (int)v17[1];
        v35[0] = v44;
        v35[1] = 0;
        v35[2] = v39;
        memset(&v35[3], 0, 13);
        v37 = i;
        if (*(float *)(*(_QWORD *)(v10 + 216) + 4 * i) <= 0.0)
          v20 = 1;
        else
          v20 = 4;
        sub_1B192B4F4(&v38, (int *)&v36, (uint64_t)v35, v20, (*(unsigned __int16 *)(*(_QWORD *)(v34 + 432) + 2 * v14) >> 7) & 0xF);
        v21 = (_QWORD *)(*a4 + 16 * v14);
        *v21 = 0;
        v21[1] = 0;
        v22 = (float32x2_t)v44[0];
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * *v15), *(float *)v44);
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * v15[1]), v22, 1);
        if (SLODWORD(v35[4]) >= 1 && (int)v18 >= 1)
        {
          for (j = 0; j != v18; ++j)
          {
            v24 = *(int *)(v16 + 4 * v19 + 4 * j);
            if (BYTE4(v35[4]))
            {
              v25 = (int *)(v9[21] + 4 * v24);
              v26 = *a4;
              v27 = *a4;
            }
            else
            {
              v28 = 0;
              v29 = *(_QWORD *)(v10 + 24);
              v30 = *(int *)(v29 + 8 * (_DWORD)v24 + 4);
              v31 = *(_DWORD *)(v29 + 8 * v24);
              do
                v32 = *(unsigned int *)(*(_QWORD *)(v10 + 72) + 4 * v30 + 4 * v28++);
              while (i != v32);
              v33 = *(_QWORD *)(v10 + 48) + 4 * v30;
              if ((int)v28 + 1 < v31)
                v31 = 0;
              v25 = (int *)(v33 + 4 * ((int)v28 - v31 + 1));
              v27 = *a4;
              v26 = *a3;
            }
            *(float32x4_t *)(v27 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(v27 + 16 * v14), *(float32x4_t *)(v26 + 16 * *v25), v39[j]);
          }
        }
        v12 = *(_DWORD *)(v10 + 4);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B19335A8(uint64_t *a1, int a2, _QWORD *a3, _QWORD *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t i;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  _DWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  _QWORD v39[5];
  float v40;
  _QWORD v41[2];
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  uint64_t *v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  void *__p;
  uint64_t v52;

  v7 = 0;
  v52 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v11 = v9[1];
  v10 = v9[2];
  v46 = *(_DWORD *)(v8 + 4);
  v12 = 2 * *(_DWORD *)(v11 + 20);
  v47 = &v50;
  v48 = v12;
  v49 = 32;
  v41[0] = v11;
  v41[1] = v10;
  v34 = v10;
  __p = 0;
  if (v12 >= 0x21)
  {
    v7 = operator new(4 * v12);
    __p = v7;
    v47 = (uint64_t *)v7;
    v49 = v12;
  }
  v13 = *(_DWORD *)(v11 + 8);
  if (v13 >= 1)
  {
    for (i = 0; i < v13; ++i)
    {
      v15 = *(_DWORD *)(v9[30] + 4 * i);
      if (v15 != -1)
      {
        v16 = v15;
        v37 = *(_QWORD *)(v11 + 360);
        v17 = *(_QWORD *)(v11 + 336);
        v18 = (8 * i) | 4;
        v36 = *(int *)(v17 + v18);
        v19 = *(int *)(v17 + 8 * i);
        v20 = *(_QWORD *)(v11 + 264);
        v35 = *(int *)(v20 + v18);
        v21 = *(unsigned int *)(v20 + 8 * i);
        v40 = 0.0;
        v22 = v47;
        v23 = (_DWORD *)v47 + v19;
        v38 = v19;
        v39[0] = &v40;
        v39[1] = v47;
        v39[2] = v23;
        memset(&v39[3], 0, 13);
        v42 = i;
        v43 = v15;
        v44 = *(_DWORD *)(*(_QWORD *)(v41[0] + 336) + 8 * i);
        v45 = *(_DWORD *)(*(_QWORD *)(v41[0] + 264) + 8 * i);
        v24 = *(_QWORD *)(v11 + 288);
        sub_1B192B8C0(&v46, (uint64_t)v41, (uint64_t)v39, (*(unsigned __int16 *)(*(_QWORD *)(v11 + 432) + 2 * i) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v34 + 432) + 2 * v15) >> 7) & 0xF);
        v25 = (_QWORD *)(*a4 + 16 * v16);
        *v25 = 0;
        v25[1] = 0;
        if (SLODWORD(v39[4]) >= 1 && (int)v21 >= 1)
        {
          v26 = (int *)(v24 + 4 * v35);
          do
          {
            v27 = *v26++;
            v28 = *(int *)(v9[21] + 4 * v27);
            LODWORD(v27) = *v23++;
            *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a4 + 16 * v28), *(float *)&v27);
            --v21;
          }
          while (v21);
        }
        v29 = v38;
        if (SHIDWORD(v39[3]) >= 1 && v38 >= 1)
        {
          v31 = (int *)(v37 + 4 * v36);
          do
          {
            v32 = *v31++;
            v33 = (_DWORD *)(*(_QWORD *)(v11 + 120) + 8 * v32);
            LODWORD(v32) = *(_DWORD *)v22;
            v22 = (uint64_t *)((char *)v22 + 4);
            *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * (int)v33[i == *v33]), *(float *)&v32);
            --v29;
          }
          while (v29);
        }
        *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * i), v40);
        v13 = *(_DWORD *)(v11 + 8);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B1933844(uint64_t *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t i;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _QWORD *v21;
  float32x2_t v22;
  uint64_t j;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[5];
  uint64_t v36;
  int v37;
  int v38;
  float *v39;
  int v40;
  int v41;
  uint64_t v42;
  void *__p;
  _QWORD v44[3];

  v7 = 0;
  v44[1] = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v10 = v9[1];
  v34 = v9[2];
  v38 = *(_DWORD *)(v8 + 4);
  v11 = *(unsigned int *)(v10 + 16);
  v39 = (float *)&v42;
  v40 = v11;
  v41 = 8;
  v36 = v10;
  __p = 0;
  if (v11 >= 9)
  {
    v7 = operator new(4 * v11);
    __p = v7;
    v39 = (float *)v7;
    v41 = v11;
  }
  v12 = *(_DWORD *)(v10 + 4);
  if (v12 >= 1)
  {
    for (i = 0; i < v12; ++i)
    {
      v14 = *(int *)(v9[27] + 4 * i);
      if ((_DWORD)v14 != -1)
      {
        v15 = (int *)(*(_QWORD *)(v10 + 120) + 8 * i);
        v16 = *(_QWORD *)(v10 + 168);
        v17 = (unsigned int *)(*(_QWORD *)(v10 + 144) + 8 * i);
        v18 = *v17;
        v19 = (int)v17[1];
        v35[0] = v44;
        v35[1] = 0;
        v35[2] = v39;
        memset(&v35[3], 0, 13);
        v37 = i;
        if (*(float *)(*(_QWORD *)(v10 + 216) + 4 * i) <= 0.0)
          v20 = 1;
        else
          v20 = 4;
        sub_1B192BFA0(&v38, (int *)&v36, (uint64_t)v35, v20, (*(unsigned __int16 *)(*(_QWORD *)(v34 + 432) + 2 * v14) >> 7) & 0xF);
        v21 = (_QWORD *)(*a4 + 16 * v14);
        *v21 = 0;
        v21[1] = 0;
        v22 = (float32x2_t)v44[0];
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * *v15), *(float *)v44);
        *(float32x4_t *)(*a4 + 16 * v14) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v14), *(float32x4_t *)(*a3 + 16 * v15[1]), v22, 1);
        if (SLODWORD(v35[4]) >= 1 && (int)v18 >= 1)
        {
          for (j = 0; j != v18; ++j)
          {
            v24 = *(int *)(v16 + 4 * v19 + 4 * j);
            if (BYTE4(v35[4]))
            {
              v25 = (int *)(v9[21] + 4 * v24);
              v26 = *a4;
              v27 = *a4;
            }
            else
            {
              v28 = 0;
              v29 = *(_QWORD *)(v10 + 24);
              v30 = *(int *)(v29 + 8 * (_DWORD)v24 + 4);
              v31 = *(_DWORD *)(v29 + 8 * v24);
              do
                v32 = *(unsigned int *)(*(_QWORD *)(v10 + 72) + 4 * v30 + 4 * v28++);
              while (i != v32);
              v33 = *(_QWORD *)(v10 + 48) + 4 * v30;
              if ((int)v28 + 1 < v31)
                v31 = 0;
              v25 = (int *)(v33 + 4 * ((int)v28 - v31 + 1));
              v27 = *a4;
              v26 = *a3;
            }
            *(float32x4_t *)(v27 + 16 * v14) = vmlaq_n_f32(*(float32x4_t *)(v27 + 16 * v14), *(float32x4_t *)(v26 + 16 * *v25), v39[j]);
          }
        }
        v12 = *(_DWORD *)(v10 + 4);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B1933AD8(uint64_t *a1, int a2, _QWORD *a3, _QWORD *a4)
{
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t i;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  _DWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  _QWORD v39[5];
  float v40;
  _QWORD v41[2];
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  uint64_t *v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  void *__p;
  uint64_t v52;

  v7 = 0;
  v52 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = *(_QWORD **)(*(_QWORD *)(v8 + 64) + 8 * (a2 - 1));
  v11 = v9[1];
  v10 = v9[2];
  v46 = *(_DWORD *)(v8 + 4);
  v12 = 2 * *(_DWORD *)(v11 + 20);
  v47 = &v50;
  v48 = v12;
  v49 = 32;
  v41[0] = v11;
  v41[1] = v10;
  v34 = v10;
  __p = 0;
  if (v12 >= 0x21)
  {
    v7 = operator new(4 * v12);
    __p = v7;
    v47 = (uint64_t *)v7;
    v49 = v12;
  }
  v13 = *(_DWORD *)(v11 + 8);
  if (v13 >= 1)
  {
    for (i = 0; i < v13; ++i)
    {
      v15 = *(_DWORD *)(v9[30] + 4 * i);
      if (v15 != -1)
      {
        v16 = v15;
        v37 = *(_QWORD *)(v11 + 360);
        v17 = *(_QWORD *)(v11 + 336);
        v18 = (8 * i) | 4;
        v36 = *(int *)(v17 + v18);
        v19 = *(int *)(v17 + 8 * i);
        v20 = *(_QWORD *)(v11 + 264);
        v35 = *(int *)(v20 + v18);
        v21 = *(unsigned int *)(v20 + 8 * i);
        v40 = 0.0;
        v22 = v47;
        v23 = (_DWORD *)v47 + v19;
        v38 = v19;
        v39[0] = &v40;
        v39[1] = v47;
        v39[2] = v23;
        memset(&v39[3], 0, 13);
        v42 = i;
        v43 = v15;
        v44 = *(_DWORD *)(*(_QWORD *)(v41[0] + 336) + 8 * i);
        v45 = *(_DWORD *)(*(_QWORD *)(v41[0] + 264) + 8 * i);
        v24 = *(_QWORD *)(v11 + 288);
        sub_1B192C184(&v46, (uint64_t)v41, (uint64_t)v39, (*(unsigned __int16 *)(*(_QWORD *)(v11 + 432) + 2 * i) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v34 + 432) + 2 * v15) >> 7) & 0xF);
        v25 = (_QWORD *)(*a4 + 16 * v16);
        *v25 = 0;
        v25[1] = 0;
        if (SLODWORD(v39[4]) >= 1 && (int)v21 >= 1)
        {
          v26 = (int *)(v24 + 4 * v35);
          do
          {
            v27 = *v26++;
            v28 = *(int *)(v9[21] + 4 * v27);
            LODWORD(v27) = *v23++;
            *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a4 + 16 * v28), *(float *)&v27);
            --v21;
          }
          while (v21);
        }
        v29 = v38;
        if (SHIDWORD(v39[3]) >= 1 && v38 >= 1)
        {
          v31 = (int *)(v37 + 4 * v36);
          do
          {
            v32 = *v31++;
            v33 = (_DWORD *)(*(_QWORD *)(v11 + 120) + 8 * v32);
            LODWORD(v32) = *(_DWORD *)v22;
            v22 = (uint64_t *)((char *)v22 + 4);
            *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * (int)v33[i == *v33]), *(float *)&v32);
            --v29;
          }
          while (v29);
        }
        *(float32x4_t *)(*a4 + 16 * v16) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v16), *(float32x4_t *)(*a3 + 16 * i), v40);
        v13 = *(_DWORD *)(v11 + 8);
      }
    }
    v7 = __p;
  }
  operator delete(v7);
}

void sub_1B1933D74(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  uint64_t v5;
  void *v8;
  int *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  float *v25;
  uint64_t v26;
  void *__p;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  if (*(_DWORD *)(v5 + 52))
  {
    v8 = 0;
    v9 = *(int **)(v5 + 8);
    v10 = *(_QWORD **)(*((_QWORD *)v9 + 57) + 8 * a5);
    v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 16) + 456) + 8 * a5);
    v12 = v9[5];
    v25 = (float *)&v26;
    __p = 0;
    if (v12 >= 0x11)
    {
      v8 = operator new(4 * v12);
      __p = v8;
      v25 = (float *)v8;
    }
    if (*v9 >= 1)
    {
      v13 = 0;
      do
      {
        v14 = *(int *)(*(_QWORD *)(v5 + 168) + 4 * v13);
        if ((_DWORD)v14 != -1)
        {
          v15 = *(int *)(*(_QWORD *)(v11 + 96) + 4 * v14);
          v16 = (unsigned int *)(*(_QWORD *)(*v10 + 24) + 8 * v13);
          v17 = *v16;
          if ((int)v17 < 1)
          {
            v24 = (_QWORD *)(*a4 + 16 * v15);
            *v24 = 0;
            v24[1] = 0;
          }
          else
          {
            v18 = v10[3] + 4 * (int)v16[1];
            v19 = v25;
            v20 = v17;
            do
            {
              *v19++ = 1.0 / (float)(int)v17;
              --v20;
            }
            while (v20);
            v21 = (_QWORD *)(*a4 + 16 * v15);
            *v21 = 0;
            v21[1] = 0;
            v22 = 0;
            v23 = 4 * v17;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v15) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v15), *(float32x4_t *)(*a3 + 16 * *(int *)(v18 + v22)), v25[v22 / 4]);
              v22 += 4;
            }
            while (v23 != v22);
          }
        }
        ++v13;
      }
      while (v13 < *v9);
      v8 = __p;
    }
    operator delete(v8);
  }
}

void sub_1B1933F28(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  float32x2_t v23;
  unsigned int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  float32x4_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  _QWORD v51[5];
  int v52;
  int v53;
  int v54;
  _BYTE *v55;
  int v56;
  int v57;
  _BYTE v58[32];
  void *__p;
  _QWORD v60[3];

  v60[1] = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v52 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v9 = v8[1];
  v10 = *(_QWORD *)(v8[60] + 8 * a5);
  v11 = *(_QWORD *)(*(_QWORD *)(v9 + 456) + 8 * a5);
  v45 = v8[2];
  v12 = *(_QWORD **)(*(_QWORD *)(v45 + 456) + 8 * a5);
  v48 = v9;
  v13 = *(unsigned int *)(v9 + 16);
  v14 = v58;
  v55 = v58;
  v56 = v13;
  v57 = 8;
  __p = 0;
  if (v13 < 9)
  {
    v15 = 0;
  }
  else
  {
    v15 = operator new(4 * v13);
    __p = v15;
    v55 = v15;
    v57 = v13;
    v14 = v15;
  }
  v51[0] = v60;
  v51[1] = 0;
  v51[2] = v14;
  memset(&v51[3], 0, 13);
  if (*(_BYTE *)(v11 + 12) || !**(_DWORD **)a1)
  {
    LODWORD(v51[3]) = 2;
    LODWORD(v51[4]) = 0;
    v60[0] = 0x3F0000003F000000;
    v46 = 1;
  }
  else
  {
    v46 = 0;
  }
  v49 = v48;
  if (*(int *)(v48 + 4) >= 1)
  {
    v16 = 0;
    v47 = v8;
    do
    {
      v17 = *(int *)(v8[27] + 4 * v16);
      if ((_DWORD)v17 != -1)
      {
        v18 = (int *)(v12[18] + 4 * *(int *)(v12[12] + 4 * v17));
        if ((*(_BYTE *)(v12[21] + *v18) & 1) != 0)
        {
          v38 = v12[9];
          v39 = *(unsigned __int16 *)(v38 + 2 * v17);
          if (*(_WORD *)(v38 + 2 * v17))
          {
            v40 = 0;
            do
            {
              sub_1B2208948((_QWORD *)v11, v16, *(unsigned __int16 *)(*(_QWORD *)(v10 + 40)+ 2 * (v40 + *(int *)(*(_QWORD *)(*(_QWORD *)(v10 + 32) + 96) + 4 * v17))), &v53);
              v41.i64[0] = 0x3F0000003F000000;
              v41.i64[1] = 0x3F0000003F000000;
              v42 = v18[v40];
              v43 = (_QWORD *)(*a4 + 16 * v42);
              *v43 = 0;
              v43[1] = 0;
              v44 = v54;
              *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v42), v41, *(float32x4_t *)(*a3 + 16 * v53));
              *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v42), v41, *(float32x4_t *)(*a3 + 16 * v44));
              ++v40;
            }
            while (v39 != v40);
          }
        }
        else
        {
          if ((v46 & 1) == 0)
          {
            v50 = v16;
            if (*(float *)(*(_QWORD *)(v48 + 216) + 4 * v16) <= 0.0)
              v19 = 1;
            else
              v19 = 4;
            sub_1B192B4F4(&v52, (int *)&v49, (uint64_t)v51, v19, (*(unsigned __int16 *)(*(_QWORD *)(v45 + 432) + 2 * v17) >> 7) & 0xF);
          }
          sub_1B2208948((_QWORD *)v11, v16, 0, &v53);
          v20 = *v18;
          v21 = (_QWORD *)(*a4 + 16 * v20);
          *v21 = 0;
          v21[1] = 0;
          v22 = v54;
          v23 = (float32x2_t)v60[0];
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v53), *(float *)v60);
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v22), v23, 1);
          if (SLODWORD(v51[4]) >= 1)
          {
            v24 = (unsigned int *)(*(_QWORD *)(v48 + 144) + 8 * v16);
            v25 = *v24;
            if ((int)v25 >= 1)
            {
              v26 = 0;
              v27 = *(_QWORD *)(v48 + 168) + 4 * (int)v24[1];
              do
              {
                v28 = *(int *)(v27 + 4 * v26);
                if (BYTE4(v51[4]))
                {
                  v29 = (int *)(v12[12] + 4 * *(int *)(v47[21] + 4 * v28));
                  v30 = *a4;
                  v31 = *a4;
                }
                else
                {
                  v32 = 0;
                  v33 = (2 * (int)v28) | 1;
                  v34 = *(_QWORD *)(v48 + 24);
                  v35 = *(_QWORD *)(v48 + 72) + 4 * *(int *)(v34 + 4 * v33);
                  v36 = *(_DWORD *)(v34 + 8 * v28);
                  do
                    v37 = *(unsigned int *)(v35 + 4 * v32++);
                  while (v16 != v37);
                  if ((int)v32 + 1 < v36)
                    v36 = 0;
                  v29 = (int *)(*(_QWORD *)(v11 + 24)
                              + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)v11 + 24) + 4 * v33)
                              + 4 * ((int)v32 - v36 + 1));
                  v31 = *a4;
                  v30 = *a3;
                }
                *(float32x4_t *)(v31 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(v31 + 16 * v20), *(float32x4_t *)(v30 + 16 * *v29), *(float *)&v55[4 * v26++]);
              }
              while (v26 != v25);
            }
          }
        }
      }
      ++v16;
      v8 = v47;
    }
    while (v16 < *(int *)(v48 + 4));
    v15 = __p;
  }
  operator delete(v15);
}

void sub_1B19342EC(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _BOOL4 v14;
  _QWORD *v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v23;
  uint64_t v24;
  uint64_t *v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  float v45;
  float v46;
  _QWORD *v47;
  int v48;
  unsigned int v49;
  float v50;
  float v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  _BOOL4 v56;
  _QWORD *v57;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  float v63;
  _QWORD v64[2];
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  _QWORD v70[5];
  uint64_t *v71;
  unsigned int v72;
  int v73;
  uint64_t v74;
  _DWORD *v75;
  uint64_t *v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v57 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v69 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v60 = v57[1];
  v52 = v57[2];
  v61 = *(_QWORD *)(*(_QWORD *)(v60 + 456) + 8 * a5);
  if (*(_BYTE *)(v61 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v56 = v7;
  v59 = *(_QWORD **)(v57[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v52 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v60 + 20);
  v76 = &v79;
  v77 = 2 * v9;
  v78 = 32;
  v80 = 0;
  if (2 * v9 >= 0x21)
  {
    v80 = (uint64_t *)operator new(8 * v9);
    v76 = v80;
    v78 = 2 * v9;
    v9 = *(_DWORD *)(v60 + 20);
  }
  v10 = 0;
  v71 = &v74;
  v72 = v9;
  v73 = 16;
  v75 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v75 = v10;
    v71 = (uint64_t *)v10;
    v73 = v9;
  }
  v64[0] = v60;
  v64[1] = v52;
  if (*(int *)(v60 + 8) >= 1)
  {
    v53 = v8;
    v11 = 0;
    v13 = v57;
    v12 = a3;
    v14 = v56;
    v15 = v59;
    do
    {
      v62 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v62 != -1)
      {
        v16 = *(int *)(*(_QWORD *)(v61 + 96) + 4 * v11);
        v17 = (int *)(*(_QWORD *)(v61 + 144) + 4 * v16);
        v18 = *(int *)(v53[12] + 4 * v62);
        v19 = (int *)(v53[18] + 4 * v18);
        v20 = *v19;
        v21 = v53[21];
        if ((*(_BYTE *)(v21 + v20) & 1) == 0 && v14)
        {
          v23 = (_QWORD *)(*a4 + 16 * v20);
          *v23 = 0;
          v23[1] = 0;
          *(float32x4_t *)(*a4 + 16 * *v19) = vaddq_f32(*(float32x4_t *)(*v12 + 16 * *v17), *(float32x4_t *)(*a4 + 16 * *v19));
        }
        else if ((*(_BYTE *)(v21 + v20) & 1) != 0)
        {
          v36 = v53[9];
          v37 = *(unsigned __int16 *)(v36 + 2 * v62);
          if (*(_WORD *)(v36 + 2 * v62))
          {
            v38 = 0;
            v54 = *(_QWORD *)(v61 + 144) + 4 * v16;
            v55 = *(_QWORD *)(v61 + 168) + v16;
            v39 = v21 + v18;
            do
            {
              v40 = *(unsigned __int16 *)(v15[5] + 2 * (v38 + *(int *)(*(_QWORD *)(v15[4] + 96) + 4 * v62)));
              v41 = v17[v40];
              v42 = v19[v38];
              v43 = (_QWORD *)(*a4 + 16 * v42);
              *v43 = 0;
              v43[1] = 0;
              if (!v14 && (*(_BYTE *)(v39 + v38) & 8) != 0)
              {
                v44 = v39;
                sub_1B22087A4((_QWORD *)v61, v11, v40, v70);
                if ((*(_BYTE *)(v55 + v40) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v55 + v40) & 0x20) != 0)
                  {
                    v49 = v40 == 0;
                    v47 = v59;
                    v48 = v11;
                  }
                  else
                  {
                    v47 = v59;
                    v48 = v11;
                    v49 = v40;
                  }
                  v50 = sub_1B221C7C8(v47, v48, v49, v62);
                  v51 = 1.0 - v50;
                  v46 = v50 + (float)((float)(1.0 - v50) * 0.75);
                  v45 = v51 * 0.125;
                }
                else
                {
                  v45 = 0.125;
                  v46 = 0.75;
                }
                v13 = v57;
                v12 = a3;
                v14 = v56;
                v15 = v59;
                v39 = v44;
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * SLODWORD(v70[0])), v45);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * SHIDWORD(v70[0])), v45);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v41), v46);
                v17 = (int *)v54;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v42) = vaddq_f32(*(float32x4_t *)(*v12 + 16 * v41), *(float32x4_t *)(*a4 + 16 * v42));
              }
              ++v38;
            }
            while (v37 != v38);
          }
        }
        else
        {
          v24 = *(int *)(*(_QWORD *)(v60 + 336) + 8 * v11);
          v63 = 0.0;
          v25 = v76;
          v26 = (_DWORD *)v76 + v24;
          v70[0] = &v63;
          v70[1] = v76;
          v70[2] = v26;
          memset(&v70[3], 0, 13);
          v65 = v11;
          v66 = v62;
          v67 = *(_DWORD *)(*(_QWORD *)(v64[0] + 336) + 8 * v11);
          v68 = *(_DWORD *)(*(_QWORD *)(v64[0] + 264) + 8 * v11);
          sub_1B192B8C0(&v69, (uint64_t)v64, (uint64_t)v70, (*(unsigned __int16 *)(*(_QWORD *)(v60 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v52 + 432) + 2 * v62) >> 7) & 0xF);
          v13 = v57;
          v27 = *v17;
          v28 = *v19;
          v29 = (_QWORD *)(*a4 + 16 * v28);
          *v29 = 0;
          v29[1] = 0;
          if (SLODWORD(v70[4]) >= 1)
          {
            v30 = *(_QWORD *)(v60 + 264);
            v31 = *(unsigned int *)(v30 + 8 * v11);
            if ((int)v31 >= 1)
            {
              v32 = (int *)(*(_QWORD *)(v60 + 288) + 4 * *(int *)(v30 + ((8 * v11) | 4)));
              do
              {
                v33 = *v32++;
                v34 = *(int *)(v53[12] + 4 * *(int *)(v57[21] + 4 * v33));
                LODWORD(v33) = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * v34), *(float *)&v33);
                --v31;
              }
              while (v31);
            }
          }
          v12 = a3;
          if (SHIDWORD(v70[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v61, v11, v71);
            v13 = v57;
            v12 = a3;
            if ((int)v24 >= 1)
            {
              v35 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * *(int *)((char *)v71 + v35)), *(float *)((char *)v25 + v35));
                v35 += 4;
              }
              while (4 * v24 != v35);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v12 + 16 * v27), v63);
          v14 = v56;
          v15 = v59;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v60 + 8));
    v10 = v75;
  }
  operator delete(v10);
  operator delete(v80);
}

void sub_1B1934854(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, int a5)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  float32x2_t v23;
  unsigned int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  float32x4_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  _QWORD v51[5];
  int v52;
  int v53;
  int v54;
  _BYTE *v55;
  int v56;
  int v57;
  _BYTE v58[32];
  void *__p;
  _QWORD v60[3];

  v60[1] = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v52 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v9 = v8[1];
  v10 = *(_QWORD *)(v8[60] + 8 * a5);
  v11 = *(_QWORD *)(*(_QWORD *)(v9 + 456) + 8 * a5);
  v45 = v8[2];
  v12 = *(_QWORD **)(*(_QWORD *)(v45 + 456) + 8 * a5);
  v48 = v9;
  v13 = *(unsigned int *)(v9 + 16);
  v14 = v58;
  v55 = v58;
  v56 = v13;
  v57 = 8;
  __p = 0;
  if (v13 < 9)
  {
    v15 = 0;
  }
  else
  {
    v15 = operator new(4 * v13);
    __p = v15;
    v55 = v15;
    v57 = v13;
    v14 = v15;
  }
  v51[0] = v60;
  v51[1] = 0;
  v51[2] = v14;
  memset(&v51[3], 0, 13);
  if (*(_BYTE *)(v11 + 12) || !**(_DWORD **)a1)
  {
    LODWORD(v51[3]) = 2;
    LODWORD(v51[4]) = 0;
    v60[0] = 0x3F0000003F000000;
    v46 = 1;
  }
  else
  {
    v46 = 0;
  }
  v49 = v48;
  if (*(int *)(v48 + 4) >= 1)
  {
    v16 = 0;
    v47 = v8;
    do
    {
      v17 = *(int *)(v8[27] + 4 * v16);
      if ((_DWORD)v17 != -1)
      {
        v18 = (int *)(v12[18] + 4 * *(int *)(v12[12] + 4 * v17));
        if ((*(_BYTE *)(v12[21] + *v18) & 1) != 0)
        {
          v38 = v12[9];
          v39 = *(unsigned __int16 *)(v38 + 2 * v17);
          if (*(_WORD *)(v38 + 2 * v17))
          {
            v40 = 0;
            do
            {
              sub_1B2208948((_QWORD *)v11, v16, *(unsigned __int16 *)(*(_QWORD *)(v10 + 40)+ 2 * (v40 + *(int *)(*(_QWORD *)(*(_QWORD *)(v10 + 32) + 96) + 4 * v17))), &v53);
              v41.i64[0] = 0x3F0000003F000000;
              v41.i64[1] = 0x3F0000003F000000;
              v42 = v18[v40];
              v43 = (_QWORD *)(*a4 + 16 * v42);
              *v43 = 0;
              v43[1] = 0;
              v44 = v54;
              *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v42), v41, *(float32x4_t *)(*a3 + 16 * v53));
              *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v42), v41, *(float32x4_t *)(*a3 + 16 * v44));
              ++v40;
            }
            while (v39 != v40);
          }
        }
        else
        {
          if ((v46 & 1) == 0)
          {
            v50 = v16;
            if (*(float *)(*(_QWORD *)(v48 + 216) + 4 * v16) <= 0.0)
              v19 = 1;
            else
              v19 = 4;
            sub_1B192BFA0(&v52, (int *)&v49, (uint64_t)v51, v19, (*(unsigned __int16 *)(*(_QWORD *)(v45 + 432) + 2 * v17) >> 7) & 0xF);
          }
          sub_1B2208948((_QWORD *)v11, v16, 0, &v53);
          v20 = *v18;
          v21 = (_QWORD *)(*a4 + 16 * v20);
          *v21 = 0;
          v21[1] = 0;
          v22 = v54;
          v23 = (float32x2_t)v60[0];
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v53), *(float *)v60);
          *(float32x4_t *)(*a4 + 16 * v20) = vmlaq_lane_f32(*(float32x4_t *)(*a4 + 16 * v20), *(float32x4_t *)(*a3 + 16 * v22), v23, 1);
          if (SLODWORD(v51[4]) >= 1)
          {
            v24 = (unsigned int *)(*(_QWORD *)(v48 + 144) + 8 * v16);
            v25 = *v24;
            if ((int)v25 >= 1)
            {
              v26 = 0;
              v27 = *(_QWORD *)(v48 + 168) + 4 * (int)v24[1];
              do
              {
                v28 = *(int *)(v27 + 4 * v26);
                if (BYTE4(v51[4]))
                {
                  v29 = (int *)(v12[12] + 4 * *(int *)(v47[21] + 4 * v28));
                  v30 = *a4;
                  v31 = *a4;
                }
                else
                {
                  v32 = 0;
                  v33 = (2 * (int)v28) | 1;
                  v34 = *(_QWORD *)(v48 + 24);
                  v35 = *(_QWORD *)(v48 + 72) + 4 * *(int *)(v34 + 4 * v33);
                  v36 = *(_DWORD *)(v34 + 8 * v28);
                  do
                    v37 = *(unsigned int *)(v35 + 4 * v32++);
                  while (v16 != v37);
                  if ((int)v32 + 1 < v36)
                    v36 = 0;
                  v29 = (int *)(*(_QWORD *)(v11 + 24)
                              + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)v11 + 24) + 4 * v33)
                              + 4 * ((int)v32 - v36 + 1));
                  v31 = *a4;
                  v30 = *a3;
                }
                *(float32x4_t *)(v31 + 16 * v20) = vmlaq_n_f32(*(float32x4_t *)(v31 + 16 * v20), *(float32x4_t *)(v30 + 16 * *v29), *(float *)&v55[4 * v26++]);
              }
              while (v26 != v25);
            }
          }
        }
      }
      ++v16;
      v8 = v47;
    }
    while (v16 < *(int *)(v48 + 4));
    v15 = __p;
  }
  operator delete(v15);
}

void sub_1B1934C18(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _BOOL4 v14;
  _QWORD *v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v23;
  uint64_t v24;
  uint64_t *v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  float v45;
  float v46;
  _QWORD *v47;
  int v48;
  unsigned int v49;
  float v50;
  float v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  _BOOL4 v56;
  _QWORD *v57;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  float v63;
  _QWORD v64[2];
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  _QWORD v70[5];
  uint64_t *v71;
  unsigned int v72;
  int v73;
  uint64_t v74;
  _DWORD *v75;
  uint64_t *v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v57 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v69 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v60 = v57[1];
  v52 = v57[2];
  v61 = *(_QWORD *)(*(_QWORD *)(v60 + 456) + 8 * a5);
  if (*(_BYTE *)(v61 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v56 = v7;
  v59 = *(_QWORD **)(v57[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v52 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v60 + 20);
  v76 = &v79;
  v77 = 2 * v9;
  v78 = 32;
  v80 = 0;
  if (2 * v9 >= 0x21)
  {
    v80 = (uint64_t *)operator new(8 * v9);
    v76 = v80;
    v78 = 2 * v9;
    v9 = *(_DWORD *)(v60 + 20);
  }
  v10 = 0;
  v71 = &v74;
  v72 = v9;
  v73 = 16;
  v75 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v75 = v10;
    v71 = (uint64_t *)v10;
    v73 = v9;
  }
  v64[0] = v60;
  v64[1] = v52;
  if (*(int *)(v60 + 8) >= 1)
  {
    v53 = v8;
    v11 = 0;
    v13 = v57;
    v12 = a3;
    v14 = v56;
    v15 = v59;
    do
    {
      v62 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v62 != -1)
      {
        v16 = *(int *)(*(_QWORD *)(v61 + 96) + 4 * v11);
        v17 = (int *)(*(_QWORD *)(v61 + 144) + 4 * v16);
        v18 = *(int *)(v53[12] + 4 * v62);
        v19 = (int *)(v53[18] + 4 * v18);
        v20 = *v19;
        v21 = v53[21];
        if ((*(_BYTE *)(v21 + v20) & 1) == 0 && v14)
        {
          v23 = (_QWORD *)(*a4 + 16 * v20);
          *v23 = 0;
          v23[1] = 0;
          *(float32x4_t *)(*a4 + 16 * *v19) = vaddq_f32(*(float32x4_t *)(*v12 + 16 * *v17), *(float32x4_t *)(*a4 + 16 * *v19));
        }
        else if ((*(_BYTE *)(v21 + v20) & 1) != 0)
        {
          v36 = v53[9];
          v37 = *(unsigned __int16 *)(v36 + 2 * v62);
          if (*(_WORD *)(v36 + 2 * v62))
          {
            v38 = 0;
            v54 = *(_QWORD *)(v61 + 144) + 4 * v16;
            v55 = *(_QWORD *)(v61 + 168) + v16;
            v39 = v21 + v18;
            do
            {
              v40 = *(unsigned __int16 *)(v15[5] + 2 * (v38 + *(int *)(*(_QWORD *)(v15[4] + 96) + 4 * v62)));
              v41 = v17[v40];
              v42 = v19[v38];
              v43 = (_QWORD *)(*a4 + 16 * v42);
              *v43 = 0;
              v43[1] = 0;
              if (!v14 && (*(_BYTE *)(v39 + v38) & 8) != 0)
              {
                v44 = v39;
                sub_1B22087A4((_QWORD *)v61, v11, v40, v70);
                if ((*(_BYTE *)(v55 + v40) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v55 + v40) & 0x20) != 0)
                  {
                    v49 = v40 == 0;
                    v47 = v59;
                    v48 = v11;
                  }
                  else
                  {
                    v47 = v59;
                    v48 = v11;
                    v49 = v40;
                  }
                  v50 = sub_1B221C7C8(v47, v48, v49, v62);
                  v51 = 1.0 - v50;
                  v46 = v50 + (float)((float)(1.0 - v50) * 0.75);
                  v45 = v51 * 0.125;
                }
                else
                {
                  v45 = 0.125;
                  v46 = 0.75;
                }
                v13 = v57;
                v12 = a3;
                v14 = v56;
                v15 = v59;
                v39 = v44;
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * SLODWORD(v70[0])), v45);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * SHIDWORD(v70[0])), v45);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v41), v46);
                v17 = (int *)v54;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v42) = vaddq_f32(*(float32x4_t *)(*v12 + 16 * v41), *(float32x4_t *)(*a4 + 16 * v42));
              }
              ++v38;
            }
            while (v37 != v38);
          }
        }
        else
        {
          v24 = *(int *)(*(_QWORD *)(v60 + 336) + 8 * v11);
          v63 = 0.0;
          v25 = v76;
          v26 = (_DWORD *)v76 + v24;
          v70[0] = &v63;
          v70[1] = v76;
          v70[2] = v26;
          memset(&v70[3], 0, 13);
          v65 = v11;
          v66 = v62;
          v67 = *(_DWORD *)(*(_QWORD *)(v64[0] + 336) + 8 * v11);
          v68 = *(_DWORD *)(*(_QWORD *)(v64[0] + 264) + 8 * v11);
          sub_1B192C184(&v69, (uint64_t)v64, (uint64_t)v70, (*(unsigned __int16 *)(*(_QWORD *)(v60 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v52 + 432) + 2 * v62) >> 7) & 0xF);
          v13 = v57;
          v27 = *v17;
          v28 = *v19;
          v29 = (_QWORD *)(*a4 + 16 * v28);
          *v29 = 0;
          v29[1] = 0;
          if (SLODWORD(v70[4]) >= 1)
          {
            v30 = *(_QWORD *)(v60 + 264);
            v31 = *(unsigned int *)(v30 + 8 * v11);
            if ((int)v31 >= 1)
            {
              v32 = (int *)(*(_QWORD *)(v60 + 288) + 4 * *(int *)(v30 + ((8 * v11) | 4)));
              do
              {
                v33 = *v32++;
                v34 = *(int *)(v53[12] + 4 * *(int *)(v57[21] + 4 * v33));
                LODWORD(v33) = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * v34), *(float *)&v33);
                --v31;
              }
              while (v31);
            }
          }
          v12 = a3;
          if (SHIDWORD(v70[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v61, v11, v71);
            v13 = v57;
            v12 = a3;
            if ((int)v24 >= 1)
            {
              v35 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * *(int *)((char *)v71 + v35)), *(float *)((char *)v25 + v35));
                v35 += 4;
              }
              while (4 * v24 != v35);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v12 + 16 * v27), v63);
          v14 = v56;
          v15 = v59;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v60 + 8));
    v10 = v75;
  }
  operator delete(v10);
  operator delete(v80);
}

void sub_1B1935180(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  void *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  float32x4_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float32x4_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t *v31;
  int v32;
  int v33;
  uint64_t v34;
  void *__p;
  uint64_t v36;

  v8 = 0;
  v36 = *MEMORY[0x1E0C80C00];
  v27 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v28 = v27[1];
  v9 = *(_QWORD *)(v27[60] + 8 * a5);
  v10 = *(_QWORD **)(*(_QWORD *)(v28 + 456) + 8 * a5);
  v11 = *(_QWORD **)(*(_QWORD *)(v27[2] + 456) + 8 * a5);
  v12 = *(unsigned int *)(v28 + 16);
  v31 = &v34;
  v32 = v12;
  v33 = 8;
  __p = 0;
  if (v12 >= 9)
  {
    v8 = operator new(4 * v12);
    __p = v8;
    v31 = (uint64_t *)v8;
    v33 = v12;
  }
  if (*(int *)(v28 + 4) >= 1)
  {
    v13 = 0;
    do
    {
      v14 = *(int *)(v27[27] + 4 * v13);
      if ((_DWORD)v14 != -1)
      {
        v15 = (int *)(v11[18] + 4 * *(int *)(v11[12] + 4 * v14));
        if ((*(_BYTE *)(v11[21] + *v15) & 1) != 0)
        {
          v20 = v11[9];
          v21 = *(unsigned __int16 *)(v20 + 2 * v14);
          if (*(_WORD *)(v20 + 2 * v14))
          {
            v22 = 0;
            do
            {
              sub_1B2208948(v10, v13, *(unsigned __int16 *)(*(_QWORD *)(v9 + 40)+ 2 * (v22 + *(int *)(*(_QWORD *)(*(_QWORD *)(v9 + 32) + 96) + 4 * v14))), &v29);
              v23.i64[0] = 0x3F0000003F000000;
              v23.i64[1] = 0x3F0000003F000000;
              v24 = v15[v22];
              v25 = (_QWORD *)(*a4 + 16 * v24);
              *v25 = 0;
              v25[1] = 0;
              v26 = v30;
              *(float32x4_t *)(*a4 + 16 * v24) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v24), v23, *(float32x4_t *)(*a3 + 16 * v29));
              *(float32x4_t *)(*a4 + 16 * v24) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v24), v23, *(float32x4_t *)(*a3 + 16 * v26));
              ++v22;
            }
            while (v21 != v22);
          }
        }
        else
        {
          sub_1B2208948(v10, v13, 0, &v29);
          v16.i64[0] = 0x3F0000003F000000;
          v16.i64[1] = 0x3F0000003F000000;
          v17 = *v15;
          v18 = (_QWORD *)(*a4 + 16 * v17);
          *v18 = 0;
          v18[1] = 0;
          v19 = v30;
          *(float32x4_t *)(*a4 + 16 * v17) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v17), v16, *(float32x4_t *)(*a3 + 16 * v29));
          *(float32x4_t *)(*a4 + 16 * v17) = vmlaq_f32(*(float32x4_t *)(*a4 + 16 * v17), v16, *(float32x4_t *)(*a3 + 16 * v19));
        }
      }
      ++v13;
    }
    while (v13 < *(int *)(v28 + 4));
    v8 = __p;
  }
  operator delete(v8);
}

void sub_1B19353B0(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  _QWORD *v11;
  unsigned int v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v25;
  float32x4_t *v26;
  int v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  float v37;
  float v38;
  _QWORD *v39;
  int v40;
  unsigned int v41;
  float v42;
  float v43;
  uint64_t v44;
  _QWORD *v45;
  _BOOL4 v46;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _DWORD v54[2];
  uint64_t *v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  void *__p;
  uint64_t *v60;
  int v61;
  int v62;
  uint64_t v63;
  void *v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v7 = v6[2];
  v51 = v6;
  v52 = v6[1];
  v8 = v6[60];
  v9 = *(_QWORD *)(v7 + 456);
  v53 = *(_QWORD *)(*(_QWORD *)(v52 + 456) + 8 * a5);
  if (*(_BYTE *)(v53 + 12))
    v10 = 1;
  else
    v10 = **(_DWORD **)a1 == 0;
  v46 = v10;
  v11 = *(_QWORD **)(v8 + 8 * a5);
  v45 = *(_QWORD **)(v9 + 8 * a5);
  v12 = *(_DWORD *)(v52 + 20);
  v60 = &v63;
  v61 = 2 * v12;
  v62 = 32;
  v64 = 0;
  if (2 * v12 >= 0x21)
  {
    v64 = operator new(8 * v12);
    v60 = (uint64_t *)v64;
    v62 = 2 * v12;
    v12 = *(_DWORD *)(v52 + 20);
  }
  v13 = 0;
  v55 = &v58;
  v56 = v12;
  v57 = 16;
  __p = 0;
  if (v12 >= 0x11)
  {
    v13 = operator new(4 * v12);
    __p = v13;
    v55 = (uint64_t *)v13;
    v57 = v12;
  }
  if (*(int *)(v52 + 8) >= 1)
  {
    v14 = 0;
    v15 = a3;
    v16 = v46;
    while (1)
    {
      v17 = *(int *)(v51[30] + 4 * v14);
      if ((_DWORD)v17 != -1)
      {
        v18 = *(int *)(*(_QWORD *)(v53 + 96) + 4 * v14);
        v19 = (int *)(*(_QWORD *)(v53 + 144) + 4 * v18);
        v20 = *(int *)(v45[12] + 4 * v17);
        v21 = (int *)(v45[18] + 4 * v20);
        v22 = *v21;
        v23 = v45[21];
        if ((*(_BYTE *)(v23 + v22) & 1) == 0 && v16)
        {
          v25 = (_QWORD *)(*a4 + 16 * v22);
          *v25 = 0;
          v25[1] = 0;
          v26 = (float32x4_t *)(*a4 + 16 * *v21);
          v27 = *v19;
        }
        else
        {
          if ((*(_BYTE *)(v23 + v22) & 1) != 0)
          {
            v29 = v45[9];
            v30 = *(unsigned __int16 *)(v29 + 2 * v17);
            if (*(_WORD *)(v29 + 2 * v17))
            {
              v31 = 0;
              v49 = *(_QWORD *)(v53 + 168) + v18;
              v50 = *(unsigned __int16 *)(v29 + 2 * v17);
              v32 = v23 + v20;
              v48 = v32;
              do
              {
                v33 = *(unsigned __int16 *)(v11[5] + 2 * (v31 + *(int *)(*(_QWORD *)(v11[4] + 96) + 4 * v17)));
                v34 = v19[v33];
                v35 = v21[v31];
                v36 = (_QWORD *)(*a4 + 16 * v35);
                *v36 = 0;
                v36[1] = 0;
                if (!v16 && (*(_BYTE *)(v32 + v31) & 8) != 0)
                {
                  sub_1B22087A4((_QWORD *)v53, v14, v33, v54);
                  if ((*(_BYTE *)(v49 + v33) & 0x10) != 0)
                  {
                    if ((*(_BYTE *)(v49 + v33) & 0x20) != 0)
                    {
                      v41 = v33 == 0;
                      v39 = v11;
                      v40 = v14;
                    }
                    else
                    {
                      v39 = v11;
                      v40 = v14;
                      v41 = v33;
                    }
                    v42 = sub_1B221C7C8(v39, v40, v41, v17);
                    v43 = 1.0 - v42;
                    v38 = v42 + (float)((float)(1.0 - v42) * 0.75);
                    v37 = v43 * 0.125;
                  }
                  else
                  {
                    v37 = 0.125;
                    v38 = 0.75;
                  }
                  v15 = a3;
                  v32 = v48;
                  v16 = v46;
                  v30 = v50;
                  v44 = v54[1];
                  *(float32x4_t *)(*a4 + 16 * v35) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v35), *(float32x4_t *)(*a3 + 16 * v54[0]), v37);
                  *(float32x4_t *)(*a4 + 16 * v35) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v35), *(float32x4_t *)(*a3 + 16 * v44), v37);
                  *(float32x4_t *)(*a4 + 16 * v35) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v35), *(float32x4_t *)(*a3 + 16 * v34), v38);
                }
                else
                {
                  *(float32x4_t *)(*a4 + 16 * v35) = vaddq_f32(*(float32x4_t *)(*v15 + 16 * v34), *(float32x4_t *)(*a4 + 16 * v35));
                }
                ++v31;
              }
              while (v30 != v31);
            }
            goto LABEL_19;
          }
          v27 = *v19;
          v28 = (_QWORD *)(*a4 + 16 * v22);
          *v28 = 0;
          v28[1] = 0;
          v26 = (float32x4_t *)(*a4 + 16 * v22);
        }
        *v26 = vaddq_f32(*(float32x4_t *)(*v15 + 16 * v27), *v26);
      }
LABEL_19:
      if (++v14 >= *(int *)(v52 + 8))
      {
        v13 = __p;
        break;
      }
    }
  }
  operator delete(v13);
  operator delete(v64);
}

void sub_1B1935758(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _BOOL4 v14;
  _QWORD *v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v23;
  uint64_t v24;
  uint64_t *v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  float v45;
  float v46;
  _QWORD *v47;
  int v48;
  unsigned int v49;
  float v50;
  float v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  _BOOL4 v56;
  _QWORD *v57;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  float v63;
  _QWORD v64[2];
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  _QWORD v70[5];
  uint64_t *v71;
  unsigned int v72;
  int v73;
  uint64_t v74;
  _DWORD *v75;
  uint64_t *v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v57 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v69 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v60 = v57[1];
  v52 = v57[2];
  v61 = *(_QWORD *)(*(_QWORD *)(v60 + 456) + 8 * a5);
  if (*(_BYTE *)(v61 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v56 = v7;
  v59 = *(_QWORD **)(v57[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v52 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v60 + 20);
  v76 = &v79;
  v77 = 2 * v9;
  v78 = 32;
  v80 = 0;
  if (2 * v9 >= 0x21)
  {
    v80 = (uint64_t *)operator new(8 * v9);
    v76 = v80;
    v78 = 2 * v9;
    v9 = *(_DWORD *)(v60 + 20);
  }
  v10 = 0;
  v71 = &v74;
  v72 = v9;
  v73 = 16;
  v75 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v75 = v10;
    v71 = (uint64_t *)v10;
    v73 = v9;
  }
  v64[0] = v60;
  v64[1] = v52;
  if (*(int *)(v60 + 8) >= 1)
  {
    v53 = v8;
    v11 = 0;
    v13 = v57;
    v12 = a3;
    v14 = v56;
    v15 = v59;
    do
    {
      v62 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v62 != -1)
      {
        v16 = *(int *)(*(_QWORD *)(v61 + 96) + 4 * v11);
        v17 = (int *)(*(_QWORD *)(v61 + 144) + 4 * v16);
        v18 = *(int *)(v53[12] + 4 * v62);
        v19 = (int *)(v53[18] + 4 * v18);
        v20 = *v19;
        v21 = v53[21];
        if ((*(_BYTE *)(v21 + v20) & 1) == 0 && v14)
        {
          v23 = (_QWORD *)(*a4 + 16 * v20);
          *v23 = 0;
          v23[1] = 0;
          *(float32x4_t *)(*a4 + 16 * *v19) = vaddq_f32(*(float32x4_t *)(*v12 + 16 * *v17), *(float32x4_t *)(*a4 + 16 * *v19));
        }
        else if ((*(_BYTE *)(v21 + v20) & 1) != 0)
        {
          v36 = v53[9];
          v37 = *(unsigned __int16 *)(v36 + 2 * v62);
          if (*(_WORD *)(v36 + 2 * v62))
          {
            v38 = 0;
            v54 = *(_QWORD *)(v61 + 144) + 4 * v16;
            v55 = *(_QWORD *)(v61 + 168) + v16;
            v39 = v21 + v18;
            do
            {
              v40 = *(unsigned __int16 *)(v15[5] + 2 * (v38 + *(int *)(*(_QWORD *)(v15[4] + 96) + 4 * v62)));
              v41 = v17[v40];
              v42 = v19[v38];
              v43 = (_QWORD *)(*a4 + 16 * v42);
              *v43 = 0;
              v43[1] = 0;
              if (!v14 && (*(_BYTE *)(v39 + v38) & 8) != 0)
              {
                v44 = v39;
                sub_1B22087A4((_QWORD *)v61, v11, v40, v70);
                if ((*(_BYTE *)(v55 + v40) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v55 + v40) & 0x20) != 0)
                  {
                    v49 = v40 == 0;
                    v47 = v59;
                    v48 = v11;
                  }
                  else
                  {
                    v47 = v59;
                    v48 = v11;
                    v49 = v40;
                  }
                  v50 = sub_1B221C7C8(v47, v48, v49, v62);
                  v51 = 1.0 - v50;
                  v46 = v50 + (float)((float)(1.0 - v50) * 0.75);
                  v45 = v51 * 0.125;
                }
                else
                {
                  v45 = 0.125;
                  v46 = 0.75;
                }
                v13 = v57;
                v12 = a3;
                v14 = v56;
                v15 = v59;
                v39 = v44;
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * SLODWORD(v70[0])), v45);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * SHIDWORD(v70[0])), v45);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v41), v46);
                v17 = (int *)v54;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v42) = vaddq_f32(*(float32x4_t *)(*v12 + 16 * v41), *(float32x4_t *)(*a4 + 16 * v42));
              }
              ++v38;
            }
            while (v37 != v38);
          }
        }
        else
        {
          v24 = *(int *)(*(_QWORD *)(v60 + 336) + 8 * v11);
          v63 = 0.0;
          v25 = v76;
          v26 = (_DWORD *)v76 + v24;
          v70[0] = &v63;
          v70[1] = v76;
          v70[2] = v26;
          memset(&v70[3], 0, 13);
          v65 = v11;
          v66 = v62;
          v67 = *(_DWORD *)(*(_QWORD *)(v64[0] + 336) + 8 * v11);
          v68 = *(_DWORD *)(*(_QWORD *)(v64[0] + 264) + 8 * v11);
          sub_1B192B8C0(&v69, (uint64_t)v64, (uint64_t)v70, (*(unsigned __int16 *)(*(_QWORD *)(v60 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v52 + 432) + 2 * v62) >> 7) & 0xF);
          v13 = v57;
          v27 = *v17;
          v28 = *v19;
          v29 = (_QWORD *)(*a4 + 16 * v28);
          *v29 = 0;
          v29[1] = 0;
          if (SLODWORD(v70[4]) >= 1)
          {
            v30 = *(_QWORD *)(v60 + 264);
            v31 = *(unsigned int *)(v30 + 8 * v11);
            if ((int)v31 >= 1)
            {
              v32 = (int *)(*(_QWORD *)(v60 + 288) + 4 * *(int *)(v30 + ((8 * v11) | 4)));
              do
              {
                v33 = *v32++;
                v34 = *(int *)(v53[12] + 4 * *(int *)(v57[21] + 4 * v33));
                LODWORD(v33) = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * v34), *(float *)&v33);
                --v31;
              }
              while (v31);
            }
          }
          v12 = a3;
          if (SHIDWORD(v70[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v61, v11, v71);
            v13 = v57;
            v12 = a3;
            if ((int)v24 >= 1)
            {
              v35 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * *(int *)((char *)v71 + v35)), *(float *)((char *)v25 + v35));
                v35 += 4;
              }
              while (4 * v24 != v35);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v12 + 16 * v27), v63);
          v14 = v56;
          v15 = v59;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v60 + 8));
    v10 = v75;
  }
  operator delete(v10);
  operator delete(v80);
}

void sub_1B1935CC0(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _DWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _BOOL4 v14;
  _QWORD *v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v23;
  uint64_t v24;
  uint64_t *v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  float v45;
  float v46;
  _QWORD *v47;
  int v48;
  unsigned int v49;
  float v50;
  float v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  _BOOL4 v56;
  _QWORD *v57;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  float v63;
  _QWORD v64[2];
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  _QWORD v70[5];
  uint64_t *v71;
  unsigned int v72;
  int v73;
  uint64_t v74;
  _DWORD *v75;
  uint64_t *v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)a1;
  v57 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v69 = *(_DWORD *)(*(_QWORD *)a1 + 4);
  v60 = v57[1];
  v52 = v57[2];
  v61 = *(_QWORD *)(*(_QWORD *)(v60 + 456) + 8 * a5);
  if (*(_BYTE *)(v61 + 12))
    v7 = 1;
  else
    v7 = *v6 == 0;
  v56 = v7;
  v59 = *(_QWORD **)(v57[60] + 8 * a5);
  v8 = *(_QWORD **)(*(_QWORD *)(v52 + 456) + 8 * a5);
  v9 = *(_DWORD *)(v60 + 20);
  v76 = &v79;
  v77 = 2 * v9;
  v78 = 32;
  v80 = 0;
  if (2 * v9 >= 0x21)
  {
    v80 = (uint64_t *)operator new(8 * v9);
    v76 = v80;
    v78 = 2 * v9;
    v9 = *(_DWORD *)(v60 + 20);
  }
  v10 = 0;
  v71 = &v74;
  v72 = v9;
  v73 = 16;
  v75 = 0;
  if (v9 >= 0x11)
  {
    v10 = operator new(4 * v9);
    v75 = v10;
    v71 = (uint64_t *)v10;
    v73 = v9;
  }
  v64[0] = v60;
  v64[1] = v52;
  if (*(int *)(v60 + 8) >= 1)
  {
    v53 = v8;
    v11 = 0;
    v13 = v57;
    v12 = a3;
    v14 = v56;
    v15 = v59;
    do
    {
      v62 = *(_DWORD *)(v13[30] + 4 * v11);
      if (v62 != -1)
      {
        v16 = *(int *)(*(_QWORD *)(v61 + 96) + 4 * v11);
        v17 = (int *)(*(_QWORD *)(v61 + 144) + 4 * v16);
        v18 = *(int *)(v53[12] + 4 * v62);
        v19 = (int *)(v53[18] + 4 * v18);
        v20 = *v19;
        v21 = v53[21];
        if ((*(_BYTE *)(v21 + v20) & 1) == 0 && v14)
        {
          v23 = (_QWORD *)(*a4 + 16 * v20);
          *v23 = 0;
          v23[1] = 0;
          *(float32x4_t *)(*a4 + 16 * *v19) = vaddq_f32(*(float32x4_t *)(*v12 + 16 * *v17), *(float32x4_t *)(*a4 + 16 * *v19));
        }
        else if ((*(_BYTE *)(v21 + v20) & 1) != 0)
        {
          v36 = v53[9];
          v37 = *(unsigned __int16 *)(v36 + 2 * v62);
          if (*(_WORD *)(v36 + 2 * v62))
          {
            v38 = 0;
            v54 = *(_QWORD *)(v61 + 144) + 4 * v16;
            v55 = *(_QWORD *)(v61 + 168) + v16;
            v39 = v21 + v18;
            do
            {
              v40 = *(unsigned __int16 *)(v15[5] + 2 * (v38 + *(int *)(*(_QWORD *)(v15[4] + 96) + 4 * v62)));
              v41 = v17[v40];
              v42 = v19[v38];
              v43 = (_QWORD *)(*a4 + 16 * v42);
              *v43 = 0;
              v43[1] = 0;
              if (!v14 && (*(_BYTE *)(v39 + v38) & 8) != 0)
              {
                v44 = v39;
                sub_1B22087A4((_QWORD *)v61, v11, v40, v70);
                if ((*(_BYTE *)(v55 + v40) & 0x10) != 0)
                {
                  if ((*(_BYTE *)(v55 + v40) & 0x20) != 0)
                  {
                    v49 = v40 == 0;
                    v47 = v59;
                    v48 = v11;
                  }
                  else
                  {
                    v47 = v59;
                    v48 = v11;
                    v49 = v40;
                  }
                  v50 = sub_1B221C7C8(v47, v48, v49, v62);
                  v51 = 1.0 - v50;
                  v46 = v50 + (float)((float)(1.0 - v50) * 0.75);
                  v45 = v51 * 0.125;
                }
                else
                {
                  v45 = 0.125;
                  v46 = 0.75;
                }
                v13 = v57;
                v12 = a3;
                v14 = v56;
                v15 = v59;
                v39 = v44;
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * SLODWORD(v70[0])), v45);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * SHIDWORD(v70[0])), v45);
                *(float32x4_t *)(*a4 + 16 * v42) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v42), *(float32x4_t *)(*a3 + 16 * v41), v46);
                v17 = (int *)v54;
              }
              else
              {
                *(float32x4_t *)(*a4 + 16 * v42) = vaddq_f32(*(float32x4_t *)(*v12 + 16 * v41), *(float32x4_t *)(*a4 + 16 * v42));
              }
              ++v38;
            }
            while (v37 != v38);
          }
        }
        else
        {
          v24 = *(int *)(*(_QWORD *)(v60 + 336) + 8 * v11);
          v63 = 0.0;
          v25 = v76;
          v26 = (_DWORD *)v76 + v24;
          v70[0] = &v63;
          v70[1] = v76;
          v70[2] = v26;
          memset(&v70[3], 0, 13);
          v65 = v11;
          v66 = v62;
          v67 = *(_DWORD *)(*(_QWORD *)(v64[0] + 336) + 8 * v11);
          v68 = *(_DWORD *)(*(_QWORD *)(v64[0] + 264) + 8 * v11);
          sub_1B192C184(&v69, (uint64_t)v64, (uint64_t)v70, (*(unsigned __int16 *)(*(_QWORD *)(v60 + 432) + 2 * v11) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v52 + 432) + 2 * v62) >> 7) & 0xF);
          v13 = v57;
          v27 = *v17;
          v28 = *v19;
          v29 = (_QWORD *)(*a4 + 16 * v28);
          *v29 = 0;
          v29[1] = 0;
          if (SLODWORD(v70[4]) >= 1)
          {
            v30 = *(_QWORD *)(v60 + 264);
            v31 = *(unsigned int *)(v30 + 8 * v11);
            if ((int)v31 >= 1)
            {
              v32 = (int *)(*(_QWORD *)(v60 + 288) + 4 * *(int *)(v30 + ((8 * v11) | 4)));
              do
              {
                v33 = *v32++;
                v34 = *(int *)(v53[12] + 4 * *(int *)(v57[21] + 4 * v33));
                LODWORD(v33) = *v26++;
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a4 + 16 * v34), *(float *)&v33);
                --v31;
              }
              while (v31);
            }
          }
          v12 = a3;
          if (SHIDWORD(v70[3]) >= 1)
          {
            sub_1B2208A48((_QWORD *)v61, v11, v71);
            v13 = v57;
            v12 = a3;
            if ((int)v24 >= 1)
            {
              v35 = 0;
              do
              {
                *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*a3 + 16 * *(int *)((char *)v71 + v35)), *(float *)((char *)v25 + v35));
                v35 += 4;
              }
              while (4 * v24 != v35);
            }
          }
          *(float32x4_t *)(*a4 + 16 * v28) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v28), *(float32x4_t *)(*v12 + 16 * v27), v63);
          v14 = v56;
          v15 = v59;
        }
      }
      ++v11;
    }
    while (v11 < *(int *)(v60 + 8));
    v10 = v75;
  }
  operator delete(v10);
  operator delete(v80);
}

void sub_1B1936228(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  _QWORD *v11;
  unsigned int v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v25;
  float32x4_t *v26;
  int v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  float v37;
  float v38;
  _QWORD *v39;
  int v40;
  unsigned int v41;
  float v42;
  float v43;
  uint64_t v44;
  _QWORD *v45;
  _BOOL4 v46;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _DWORD v54[2];
  uint64_t *v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  void *__p;
  uint64_t *v60;
  int v61;
  int v62;
  uint64_t v63;
  void *v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 64) + 8 * (a2 - 1));
  v7 = v6[2];
  v51 = v6;
  v52 = v6[1];
  v8 = v6[60];
  v9 = *(_QWORD *)(v7 + 456);
  v53 = *(_QWORD *)(*(_QWORD *)(v52 + 456) + 8 * a5);
  if (*(_BYTE *)(v53 + 12))
    v10 = 1;
  else
    v10 = **(_DWORD **)a1 == 0;
  v46 = v10;
  v11 = *(_QWORD **)(v8 + 8 * a5);
  v45 = *(_QWORD **)(v9 + 8 * a5);
  v12 = *(_DWORD *)(v52 + 20);
  v60 = &v63;
  v61 = 2 * v12;
  v62 = 32;
  v64 = 0;
  if (2 * v12 >= 0x21)
  {
    v64 = operator new(8 * v12);
    v60 = (uint64_t *)v64;
    v62 = 2 * v12;
    v12 = *(_DWORD *)(v52 + 20);
  }
  v13 = 0;
  v55 = &v58;
  v56 = v12;
  v57 = 16;
  __p = 0;
  if (v12 >= 0x11)
  {
    v13 = operator new(4 * v12);
    __p = v13;
    v55 = (uint64_t *)v13;
    v57 = v12;
  }
  if (*(int *)(v52 + 8) >= 1)
  {
    v14 = 0;
    v15 = a3;
    v16 = v46;
    while (1)
    {
      v17 = *(int *)(v51[30] + 4 * v14);
      if ((_DWORD)v17 != -1)
      {
        v18 = *(int *)(*(_QWORD *)(v53 + 96) + 4 * v14);
        v19 = (int *)(*(_QWORD *)(v53 + 144) + 4 * v18);
        v20 = *(int *)(v45[12] + 4 * v17);
        v21 = (int *)(v45[18] + 4 * v20);
        v22 = *v21;
        v23 = v45[21];
        if ((*(_BYTE *)(v23 + v22) & 1) == 0 && v16)
        {
          v25 = (_QWORD *)(*a4 + 16 * v22);
          *v25 = 0;
          v25[1] = 0;
          v26 = (float32x4_t *)(*a4 + 16 * *v21);
          v27 = *v19;
        }
        else
        {
          if ((*(_BYTE *)(v23 + v22) & 1) != 0)
          {
            v29 = v45[9];
            v30 = *(unsigned __int16 *)(v29 + 2 * v17);
            if (*(_WORD *)(v29 + 2 * v17))
            {
              v31 = 0;
              v49 = *(_QWORD *)(v53 + 168) + v18;
              v50 = *(unsigned __int16 *)(v29 + 2 * v17);
              v32 = v23 + v20;
              v48 = v32;
              do
              {
                v33 = *(unsigned __int16 *)(v11[5] + 2 * (v31 + *(int *)(*(_QWORD *)(v11[4] + 96) + 4 * v17)));
                v34 = v19[v33];
                v35 = v21[v31];
                v36 = (_QWORD *)(*a4 + 16 * v35);
                *v36 = 0;
                v36[1] = 0;
                if (!v16 && (*(_BYTE *)(v32 + v31) & 8) != 0)
                {
                  sub_1B22087A4((_QWORD *)v53, v14, v33, v54);
                  if ((*(_BYTE *)(v49 + v33) & 0x10) != 0)
                  {
                    if ((*(_BYTE *)(v49 + v33) & 0x20) != 0)
                    {
                      v41 = v33 == 0;
                      v39 = v11;
                      v40 = v14;
                    }
                    else
                    {
                      v39 = v11;
                      v40 = v14;
                      v41 = v33;
                    }
                    v42 = sub_1B221C7C8(v39, v40, v41, v17);
                    v43 = 1.0 - v42;
                    v38 = v42 + (float)((float)(1.0 - v42) * 0.75);
                    v37 = v43 * 0.125;
                  }
                  else
                  {
                    v37 = 0.125;
                    v38 = 0.75;
                  }
                  v15 = a3;
                  v32 = v48;
                  v16 = v46;
                  v30 = v50;
                  v44 = v54[1];
                  *(float32x4_t *)(*a4 + 16 * v35) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v35), *(float32x4_t *)(*a3 + 16 * v54[0]), v37);
                  *(float32x4_t *)(*a4 + 16 * v35) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v35), *(float32x4_t *)(*a3 + 16 * v44), v37);
                  *(float32x4_t *)(*a4 + 16 * v35) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v35), *(float32x4_t *)(*a3 + 16 * v34), v38);
                }
                else
                {
                  *(float32x4_t *)(*a4 + 16 * v35) = vaddq_f32(*(float32x4_t *)(*v15 + 16 * v34), *(float32x4_t *)(*a4 + 16 * v35));
                }
                ++v31;
              }
              while (v30 != v31);
            }
            goto LABEL_19;
          }
          v27 = *v19;
          v28 = (_QWORD *)(*a4 + 16 * v22);
          *v28 = 0;
          v28[1] = 0;
          v26 = (float32x4_t *)(*a4 + 16 * v22);
        }
        *v26 = vaddq_f32(*(float32x4_t *)(*v15 + 16 * v27), *v26);
      }
LABEL_19:
      if (++v14 >= *(int *)(v52 + 8))
      {
        v13 = __p;
        break;
      }
    }
  }
  operator delete(v13);
  operator delete(v64);
}

uint64_t sub_1B19365D0(uint64_t *a1, char *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v16[5];

  v2 = *a1;
  v3 = (a1[1] - *a1) >> 6;
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 58)
    abort();
  v8 = a1[2];
  v7 = (uint64_t)(a1 + 2);
  v9 = v8 - v2;
  if (v9 >> 5 > v4)
    v4 = v9 >> 5;
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFC0)
    v10 = 0x3FFFFFFFFFFFFFFLL;
  else
    v10 = v4;
  v16[4] = v7;
  v11 = (char *)sub_1B183C9C0(v7, v10);
  v12 = &v11[64 * v3];
  v16[0] = v11;
  v16[1] = v12;
  v16[3] = &v11[64 * v13];
  *v12 = *a2;
  *((_DWORD *)v12 + 2) = *((_DWORD *)a2 + 2);
  *((_QWORD *)v12 + 3) = 0;
  *((_QWORD *)v12 + 4) = 0;
  *((_QWORD *)v12 + 2) = 0;
  *((_OWORD *)v12 + 1) = *((_OWORD *)a2 + 1);
  *((_QWORD *)v12 + 4) = *((_QWORD *)a2 + 4);
  *((_QWORD *)a2 + 2) = 0;
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)v12 + 6) = 0;
  *((_QWORD *)v12 + 7) = 0;
  *((_QWORD *)v12 + 5) = 0;
  *(_OWORD *)(v12 + 40) = *(_OWORD *)(a2 + 40);
  *((_QWORD *)v12 + 7) = *((_QWORD *)a2 + 7);
  *((_QWORD *)a2 + 5) = 0;
  *((_QWORD *)a2 + 6) = 0;
  *((_QWORD *)a2 + 7) = 0;
  v16[2] = v12 + 64;
  sub_1B19366CC(a1, v16);
  v14 = a1[1];
  sub_1B19367C4((uint64_t)v16);
  return v14;
}

void sub_1B19366CC(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_1B1936740((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

__n128 sub_1B1936740(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __n128 result;

  if (a3 != a5)
  {
    v7 = 0;
    do
    {
      v8 = a7 + v7;
      v9 = a3 + v7;
      *(_BYTE *)(v8 - 64) = *(_BYTE *)(a3 + v7 - 64);
      *(_DWORD *)(v8 - 56) = *(_DWORD *)(a3 + v7 - 56);
      *(_QWORD *)(v8 - 40) = 0;
      *(_QWORD *)(v8 - 32) = 0;
      *(_QWORD *)(v8 - 48) = 0;
      *(_OWORD *)(v8 - 48) = *(_OWORD *)(a3 + v7 - 48);
      *(_QWORD *)(v8 - 32) = *(_QWORD *)(a3 + v7 - 32);
      *(_QWORD *)(v9 - 48) = 0;
      *(_QWORD *)(v9 - 40) = 0;
      *(_QWORD *)(v9 - 32) = 0;
      *(_QWORD *)(v8 - 24) = 0;
      *(_QWORD *)(v8 - 16) = 0;
      *(_QWORD *)(v8 - 8) = 0;
      result = *(__n128 *)(a3 + v7 - 24);
      *(__n128 *)(v8 - 24) = result;
      *(_QWORD *)(v8 - 8) = *(_QWORD *)(a3 + v7 - 8);
      *(_QWORD *)(v9 - 24) = 0;
      *(_QWORD *)(v9 - 16) = 0;
      *(_QWORD *)(v9 - 8) = 0;
      v7 -= 64;
    }
    while (a3 + v7 != a5);
  }
  return result;
}

uint64_t sub_1B19367C4(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 64;
    sub_1B1936810((_QWORD *)(i - 64));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1B1936810(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
}

_QWORD *sub_1B1936854(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1B19368D0(a1, a2);
    v4 = (char *)a1[1];
    v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

char *sub_1B19368D0(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    abort();
  result = (char *)sub_1B17F7D88((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

_QWORD *sub_1B193691C(_QWORD *a1, unint64_t a2, uint64_t *a3)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1B19368D0(a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = 3 * a2;
    v8 = &v6[3 * a2];
    v9 = 8 * v7;
    do
    {
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      sub_1B19369B0(v6, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

_QWORD *sub_1B19369B0(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;

  if (a4)
  {
    v6 = result;
    sub_1B19368D0(result, a4);
    result = (_QWORD *)v6[1];
    while (a2 != a3)
    {
      v7 = sub_1B193C35C(result, a2);
      a2 += 24;
      result = v7 + 3;
    }
    v6[1] = result;
  }
  return result;
}

uint64_t sub_1B1936A0C(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void **v8;

  v8 = (void **)(a1 + 168);
  sub_1B17F7664(&v8);
  v8 = (void **)(a1 + 144);
  sub_1B17F7664(&v8);
  v8 = (void **)(a1 + 120);
  sub_1B17F7664(&v8);
  v2 = *(void **)(a1 + 96);
  if (v2)
  {
    *(_QWORD *)(a1 + 104) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 72);
  if (v3)
  {
    *(_QWORD *)(a1 + 80) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 48);
  if (v4)
  {
    *(_QWORD *)(a1 + 56) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 24);
  if (v5)
  {
    *(_QWORD *)(a1 + 32) = v5;
    operator delete(v5);
  }
  v6 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v6;
    operator delete(v6);
  }
  return a1;
}

void sub_1B1936AB4(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, void **a6, uint64_t a7, uint64_t a8)
{
  void **v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int16 v34;
  __int16 v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  size_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const UInt8 *v46;
  float32x4_t v47;
  float v48;
  float v49;
  uint64_t i;
  int *v51;
  int v52;
  int v53;
  int v54;
  float32x4_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float v62;
  float v63;
  float32x4_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  float v71;
  float v72;
  float32x4_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  float v80;
  float v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  unsigned __int32 v91;
  float32x2_t v92;
  float32x2_t v93;
  uint64_t v94;
  int v95;
  _DWORD *v96;
  int32x4_t v97;
  float32x2_t v98;
  float32x2_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  int64_t v109;
  char *v110;
  char *v111;
  char *v112;
  int v113;
  uint64_t v114;
  CFDataRef v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  _QWORD *v119;
  _QWORD *v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  char *v125;
  char *v126;
  char *v127;
  char *v128;
  char *v129;
  __int128 v130;
  uint64_t v131;
  uint64_t v132;
  void **v133;
  uint64_t v134;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  void *__p;
  void *v141;
  uint64_t v142;
  void *v143;
  void *v144;
  uint64_t v145;
  char *v146;
  char *v147;
  uint64_t v148;

  v8 = a6;
  v11 = sub_1B1937DC8(a1, a2, a4, *(_QWORD *)(a1 + 80), a6, (uint64_t)a6, a7, a8);
  if (!v11)
    return;
  v19 = v11;
  if (sub_1B17ED7B4(v11, v12, v13, v14, v15, v16, v17, v18))
    return;
  v33 = sub_1B17ED6C4(v19, v20, v21, v22, v23, v24, v25, v26);
  v35 = v34;
  v37 = v36;
  if (*(_BYTE *)(a1 + 88))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Position sources must use the 'vertex' interpolation mode"), v27, v28, v29, v30, v31, v32, (uint64_t)"_interpolationMode == kCFXSubdivPrimvarDataInterpolationModeInterpolateVertex");
  v38 = *(unsigned __int8 *)(a5 + 3);
  if (v38 >= 2)
  {
    if (v38 != 2)
      return;
    if (v37 != *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*a3 + 88)
                                      + 24 * (((unint64_t)*(unsigned __int8 *)(*a3 + 8) >> 2) & 0xF))
                          + 8))
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Number of normals at limit surface is not equal to number of vertex positions"), v27, v28, v29, v30, v31, v32, (uint64_t)"subdividedDataCount == refiner.GetLevel(refiner.GetMaxLevel()).GetNumVertices()");
    v46 = (const UInt8 *)malloc_type_malloc(12 * v37, 0x100004052888210uLL);
    v106 = *(_QWORD *)(a1 + 48);
    v107 = *(_QWORD *)(a1 + 56);
    v108 = (_QWORD *)(a1 + 48);
    v146 = 0;
    v147 = 0;
    v148 = 0;
    v109 = v107 - v106;
    if (v107 == v106)
    {
      v143 = 0;
      v144 = 0;
      v145 = 0;
      __p = 0;
      v141 = 0;
      v142 = 0;
    }
    else
    {
      sub_1B183C0E4(&v146, v109 >> 3);
      v110 = v147;
      bzero(v147, v109);
      v147 = &v110[v109];
      v143 = 0;
      v144 = 0;
      v145 = 0;
      sub_1B183C0E4(&v143, v109 >> 3);
      v111 = (char *)v144;
      bzero(v144, v109);
      v144 = &v111[v109];
      __p = 0;
      v141 = 0;
      v142 = 0;
      sub_1B183C0E4(&__p, v109 >> 3);
      v112 = (char *)v141;
      bzero(v141, v109);
      v141 = &v112[v109];
    }
    if (((*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a3 + 40)
                                 + 8 * (((unint64_t)*(unsigned __int8 *)(*a3 + 8) >> 2) & 0xF))
                     + 368)
         - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a3 + 40)
                                 + 8 * (((unint64_t)*(unsigned __int8 *)(*a3 + 8) >> 2) & 0xF))
                     + 360)) & 0x3FFFFFFFCLL) != 0)
    {
      v113 = *(_DWORD *)*a3;
      if (v113)
      {
        if (v113 == 2)
        {
          sub_1B19385E4(a3, v108, &v146, &v143, &__p);
        }
        else if (v113 == 1)
        {
          sub_1B1938094(a3, v108, &v146, &v143, &__p);
        }
      }
      else
      {
        sub_1B1938B34((uint64_t)a3, v108, &v146, &v143, &__p);
      }
    }
    else
    {
      sub_1B221BA4C(4, (uint64_t)"Failure in PrimvarRefiner::Limit() -- last level of refinement does not include full topology.", v100, v101, v102, v103, v104, v105, v131);
    }
    if (v37)
    {
      v114 = v37;
      do
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Does not make sense"), v100, v101, v102, v103, v104, v105, v131);
        --v114;
      }
      while (v114);
    }
    if (__p)
    {
      v141 = __p;
      operator delete(__p);
    }
    if (v143)
    {
      v144 = v143;
      operator delete(v143);
    }
    if (v146)
    {
      v147 = v146;
      operator delete(v146);
    }
LABEL_42:
    if (!v46)
      return;
    goto LABEL_43;
  }
  v132 = v37;
  v133 = v8;
  v39 = *(int *)(*a2 + 8);
  v46 = (const UInt8 *)malloc_type_calloc(v39, 0xCuLL, 0x100004052888210uLL);
  v134 = *(unsigned int *)*a2;
  if ((int)v134 >= 1)
  {
    for (i = 0; i != v134; ++i)
    {
      v51 = (int *)(*(_QWORD *)(*a2 + 48) + 4 * *(int *)(*(_QWORD *)(*a2 + 24) + 8 * i + 4));
      v52 = v51[1];
      v53 = v51[2];
      v54 = v51[3];
      *(double *)v55.i64 = sub_1B198D4F8(v35, (const float *)(v33 + *v51 * (unint64_t)HIBYTE(v35)), v40, v41, v42, v43, v44, v45, v47, v48, v49);
      v139 = v55;
      *(double *)v64.i64 = sub_1B198D4F8(v35, (const float *)(v33 + v52 * (unint64_t)HIBYTE(v35)), v56, v57, v58, v59, v60, v61, v55, v62, v63);
      v138 = v64;
      *(double *)v73.i64 = sub_1B198D4F8(v35, (const float *)(v33 + v53 * (unint64_t)HIBYTE(v35)), v65, v66, v67, v68, v69, v70, v64, v71, v72);
      v137 = v73;
      *(double *)v82.i64 = sub_1B198D4F8(v35, (const float *)(v33 + v54 * (unint64_t)HIBYTE(v35)), v74, v75, v76, v77, v78, v79, v73, v80, v81);
      if (*(_BYTE *)(a5 + 3))
      {
        v83 = vsubq_f32(v137, v139);
        v84 = vsubq_f32(v82, v138);
        v85 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v84, (int32x4_t)v84), (int8x16_t)v84, 0xCuLL), vnegq_f32(v83)), v84, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v83, (int32x4_t)v83), (int8x16_t)v83, 0xCuLL));
        v86 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v85, (int32x4_t)v85), (int8x16_t)v85, 0xCuLL);
        v87 = (int32x4_t)vmulq_f32(v85, v85);
      }
      else
      {
        v88 = vsubq_f32(v138, v139);
        v89 = vsubq_f32(v137, v139);
        v90 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v89, (int32x4_t)v89), (int8x16_t)v89, 0xCuLL), vnegq_f32(v88)), v89, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v88, (int32x4_t)v88), (int8x16_t)v88, 0xCuLL));
        v86 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v90, (int32x4_t)v90), (int8x16_t)v90, 0xCuLL);
        v87 = (int32x4_t)vmulq_f32(v90, v90);
      }
      v91 = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v87.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v87, 2), *(float32x2_t *)v87.i8)).u32[0];
      v92 = vrsqrte_f32((float32x2_t)v91);
      v93 = vmul_f32(v92, vrsqrts_f32((float32x2_t)v91, vmul_f32(v92, v92)));
      v94 = 0;
      v47 = vmulq_n_f32(v86, vmul_f32(v93, vrsqrts_f32((float32x2_t)v91, vmul_f32(v93, v93))).f32[0]);
      v48 = v47.f32[2];
      do
      {
        v95 = 3 * v51[v94];
        *(float32x2_t *)&v46[12 * v51[v94]] = vadd_f32(*(float32x2_t *)v47.f32, *(float32x2_t *)&v46[12 * v51[v94]]);
        v95 += 2;
        v49 = v47.f32[2] + *(float *)&v46[4 * v95];
        *(float *)&v46[4 * v95] = v49;
        ++v94;
      }
      while (v94 != 4);
    }
  }
  if ((int)v39 < 1)
  {
    v37 = v132;
    v8 = v133;
    goto LABEL_42;
  }
  v96 = v46 + 8;
  v37 = v132;
  v8 = v133;
  do
  {
    v47.i64[0] = *((_QWORD *)v96 - 1);
    v47.i32[2] = *v96;
    v97 = (int32x4_t)vmulq_f32(v47, v47);
    v97.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v97, 2), vadd_f32(*(float32x2_t *)v97.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v97.i8, 1))).u32[0];
    v98 = vrsqrte_f32((float32x2_t)v97.u32[0]);
    v99 = vmul_f32(v98, vrsqrts_f32((float32x2_t)v97.u32[0], vmul_f32(v98, v98)));
    v47 = vmulq_n_f32(v47, vmul_f32(v99, vrsqrts_f32((float32x2_t)v97.u32[0], vmul_f32(v99, v99))).f32[0]);
    *((_QWORD *)v96 - 1) = v47.i64[0];
    *v96 = v47.i32[2];
    v96 += 3;
    --v39;
  }
  while (v39);
LABEL_43:
  v115 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v46, 12 * v37, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
  v117 = sub_1B17ED264(1, v115, 1, 3, v37, 12, 0, v116);
  CFRelease(v115);
  v118 = (unint64_t)v8[2];
  v119 = v8[1];
  if ((unint64_t)v119 >= v118)
  {
    v121 = 0xAAAAAAAAAAAAAAABLL * (((char *)v119 - (_BYTE *)*v8) >> 3);
    v122 = v121 + 1;
    if (v121 + 1 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v123 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v118 - (_QWORD)*v8) >> 3);
    if (2 * v123 > v122)
      v122 = 2 * v123;
    if (v123 >= 0x555555555555555)
      v124 = 0xAAAAAAAAAAAAAAALL;
    else
      v124 = v122;
    if (v124)
      v125 = (char *)sub_1B17F7D88((uint64_t)(v8 + 2), v124);
    else
      v125 = 0;
    v126 = &v125[24 * v121];
    v127 = &v125[24 * v124];
    *(_QWORD *)v126 = 0;
    *((_QWORD *)v126 + 1) = 0;
    *((_QWORD *)v126 + 2) = v117;
    v120 = v126 + 24;
    v129 = (char *)*v8;
    v128 = (char *)v8[1];
    if (v128 != *v8)
    {
      do
      {
        v130 = *(_OWORD *)(v128 - 24);
        *((_QWORD *)v126 - 1) = *((_QWORD *)v128 - 1);
        *(_OWORD *)(v126 - 24) = v130;
        v126 -= 24;
        v128 -= 24;
      }
      while (v128 != v129);
      v128 = (char *)*v8;
    }
    *v8 = v126;
    v8[1] = v120;
    v8[2] = v127;
    if (v128)
      operator delete(v128);
  }
  else
  {
    *v119 = 0;
    v119[1] = 0;
    v120 = v119 + 3;
    v119[2] = v117;
  }
  v8[1] = v120;
}

void sub_1B19370EC(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, void **a6, uint64_t a7, uint64_t a8)
{
  void **v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int16 v34;
  __int16 v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  size_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const UInt8 *v46;
  float32x4_t v47;
  float v48;
  float v49;
  uint64_t i;
  int *v51;
  int v52;
  int v53;
  int v54;
  float32x4_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float v62;
  float v63;
  float32x4_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  float v71;
  float v72;
  float32x4_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  float v80;
  float v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  unsigned __int32 v91;
  float32x2_t v92;
  float32x2_t v93;
  uint64_t v94;
  int v95;
  _DWORD *v96;
  int32x4_t v97;
  float32x2_t v98;
  float32x2_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  int64_t v109;
  char *v110;
  char *v111;
  char *v112;
  int v113;
  void *v114;
  float32x4_t *v115;
  _DWORD *v116;
  uint64_t v117;
  float32x4_t *v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  int32x4_t v123;
  float32x2_t v124;
  float32x2_t v125;
  float32x4_t v126;
  CFDataRef v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  _QWORD *v131;
  _QWORD *v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  char *v141;
  __int128 v142;
  char v143;
  void **v144;
  uint64_t v145;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  void *__p;
  void *v152;
  uint64_t v153;
  void *v154;
  void *v155;
  uint64_t v156;
  char *v157;
  char *v158;
  uint64_t v159;

  v8 = a6;
  v11 = sub_1B193A24C(a1, a2, a4, *(_QWORD *)(a1 + 80), a6, (uint64_t)a6, a7, a8);
  if (!v11)
    return;
  v19 = v11;
  if (sub_1B17ED7B4(v11, v12, v13, v14, v15, v16, v17, v18))
    return;
  v33 = sub_1B17ED6C4(v19, v20, v21, v22, v23, v24, v25, v26);
  v35 = v34;
  v37 = v36;
  if (*(_BYTE *)(a1 + 88))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Position sources must use the 'vertex' interpolation mode"), v27, v28, v29, v30, v31, v32, (uint64_t)"_interpolationMode == kCFXSubdivPrimvarDataInterpolationModeInterpolateVertex");
  v38 = *(unsigned __int8 *)(a5 + 3);
  if (v38 >= 2)
  {
    if (v38 != 2)
      return;
    if (v37 != *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*a3 + 88)
                                      + 24 * (((unint64_t)*(unsigned __int8 *)(*a3 + 8) >> 2) & 0xF))
                          + 8))
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Number of normals at limit surface is not equal to number of vertex positions"), v27, v28, v29, v30, v31, v32, (uint64_t)"subdividedDataCount == refiner.GetLevel(refiner.GetMaxLevel()).GetNumVertices()");
    v46 = (const UInt8 *)malloc_type_malloc(12 * v37, 0x100004052888210uLL);
    v106 = *(_QWORD *)(a1 + 48);
    v107 = *(_QWORD *)(a1 + 56);
    v108 = (_QWORD *)(a1 + 48);
    v157 = 0;
    v158 = 0;
    v159 = 0;
    v109 = v107 - v106;
    if (v107 == v106)
    {
      v154 = 0;
      v155 = 0;
      v156 = 0;
      __p = 0;
      v152 = 0;
      v153 = 0;
    }
    else
    {
      sub_1B193A518(&v157, v109 >> 4);
      v110 = v158;
      bzero(v158, v109);
      v158 = &v110[v109];
      v154 = 0;
      v155 = 0;
      v156 = 0;
      sub_1B193A518(&v154, v109 >> 4);
      v111 = (char *)v155;
      bzero(v155, v109);
      v155 = &v111[v109];
      __p = 0;
      v152 = 0;
      v153 = 0;
      sub_1B193A518(&__p, v109 >> 4);
      v112 = (char *)v152;
      bzero(v152, v109);
      v152 = &v112[v109];
    }
    if (((*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a3 + 40)
                                 + 8 * (((unint64_t)*(unsigned __int8 *)(*a3 + 8) >> 2) & 0xF))
                     + 368)
         - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a3 + 40)
                                 + 8 * (((unint64_t)*(unsigned __int8 *)(*a3 + 8) >> 2) & 0xF))
                     + 360)) & 0x3FFFFFFFCLL) != 0)
    {
      v113 = *(_DWORD *)*a3;
      if (v113)
      {
        if (v113 == 2)
        {
          sub_1B193AA94(a3, v108, &v157, &v154, &__p);
        }
        else if (v113 == 1)
        {
          sub_1B193A554(a3, v108, &v157, &v154, &__p);
        }
      }
      else
      {
        sub_1B193AFD4((uint64_t)a3, v108, &v157, &v154, &__p);
      }
    }
    else
    {
      sub_1B221BA4C(4, (uint64_t)"Failure in PrimvarRefiner::Limit() -- last level of refinement does not include full topology.", v100, v101, v102, v103, v104, v105, v143);
    }
    v114 = __p;
    if (v37)
    {
      v115 = (float32x4_t *)v154;
      v116 = v46 + 8;
      v117 = v37;
      v118 = (float32x4_t *)__p;
      do
      {
        v119 = *v115++;
        v120 = v119;
        v121 = *v118++;
        v122 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v121, (int32x4_t)v121), (int8x16_t)v121, 0xCuLL), vnegq_f32(v120)), v121, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v120, (int32x4_t)v120), (int8x16_t)v120, 0xCuLL));
        v123 = (int32x4_t)vmulq_f32(v122, v122);
        v123.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v123.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v123, 2), *(float32x2_t *)v123.i8)).u32[0];
        v124 = vrsqrte_f32((float32x2_t)v123.u32[0]);
        v125 = vmul_f32(v124, vrsqrts_f32((float32x2_t)v123.u32[0], vmul_f32(v124, v124)));
        v126 = vmulq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v122, (int32x4_t)v122), (int8x16_t)v122, 0xCuLL), vmul_f32(v125, vrsqrts_f32((float32x2_t)v123.u32[0], vmul_f32(v125, v125))).f32[0]);
        *((_QWORD *)v116 - 1) = v126.i64[0];
        *v116 = v126.i32[2];
        v116 += 3;
        --v117;
      }
      while (v117);
    }
    else if (!__p)
    {
LABEL_39:
      if (v154)
      {
        v155 = v154;
        operator delete(v154);
      }
      if (v157)
      {
        v158 = v157;
        operator delete(v157);
      }
LABEL_43:
      if (!v46)
        return;
      goto LABEL_44;
    }
    v152 = v114;
    operator delete(v114);
    goto LABEL_39;
  }
  v144 = v8;
  v39 = *(int *)(*a2 + 8);
  v46 = (const UInt8 *)malloc_type_calloc(v39, 0xCuLL, 0x100004052888210uLL);
  v145 = *(unsigned int *)*a2;
  if ((int)v145 >= 1)
  {
    for (i = 0; i != v145; ++i)
    {
      v51 = (int *)(*(_QWORD *)(*a2 + 48) + 4 * *(int *)(*(_QWORD *)(*a2 + 24) + 8 * i + 4));
      v52 = v51[1];
      v53 = v51[2];
      v54 = v51[3];
      *(double *)v55.i64 = sub_1B198D4F8(v35, (const float *)(v33 + *v51 * (unint64_t)HIBYTE(v35)), v40, v41, v42, v43, v44, v45, v47, v48, v49);
      v150 = v55;
      *(double *)v64.i64 = sub_1B198D4F8(v35, (const float *)(v33 + v52 * (unint64_t)HIBYTE(v35)), v56, v57, v58, v59, v60, v61, v55, v62, v63);
      v149 = v64;
      *(double *)v73.i64 = sub_1B198D4F8(v35, (const float *)(v33 + v53 * (unint64_t)HIBYTE(v35)), v65, v66, v67, v68, v69, v70, v64, v71, v72);
      v148 = v73;
      *(double *)v82.i64 = sub_1B198D4F8(v35, (const float *)(v33 + v54 * (unint64_t)HIBYTE(v35)), v74, v75, v76, v77, v78, v79, v73, v80, v81);
      if (*(_BYTE *)(a5 + 3))
      {
        v83 = vsubq_f32(v148, v150);
        v84 = vsubq_f32(v82, v149);
        v85 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v84, (int32x4_t)v84), (int8x16_t)v84, 0xCuLL), vnegq_f32(v83)), v84, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v83, (int32x4_t)v83), (int8x16_t)v83, 0xCuLL));
        v86 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v85, (int32x4_t)v85), (int8x16_t)v85, 0xCuLL);
        v87 = (int32x4_t)vmulq_f32(v85, v85);
      }
      else
      {
        v88 = vsubq_f32(v149, v150);
        v89 = vsubq_f32(v148, v150);
        v90 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v89, (int32x4_t)v89), (int8x16_t)v89, 0xCuLL), vnegq_f32(v88)), v89, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v88, (int32x4_t)v88), (int8x16_t)v88, 0xCuLL));
        v86 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v90, (int32x4_t)v90), (int8x16_t)v90, 0xCuLL);
        v87 = (int32x4_t)vmulq_f32(v90, v90);
      }
      v91 = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v87.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v87, 2), *(float32x2_t *)v87.i8)).u32[0];
      v92 = vrsqrte_f32((float32x2_t)v91);
      v93 = vmul_f32(v92, vrsqrts_f32((float32x2_t)v91, vmul_f32(v92, v92)));
      v94 = 0;
      v47 = vmulq_n_f32(v86, vmul_f32(v93, vrsqrts_f32((float32x2_t)v91, vmul_f32(v93, v93))).f32[0]);
      v48 = v47.f32[2];
      do
      {
        v95 = 3 * v51[v94];
        *(float32x2_t *)&v46[12 * v51[v94]] = vadd_f32(*(float32x2_t *)v47.f32, *(float32x2_t *)&v46[12 * v51[v94]]);
        v95 += 2;
        v49 = v47.f32[2] + *(float *)&v46[4 * v95];
        *(float *)&v46[4 * v95] = v49;
        ++v94;
      }
      while (v94 != 4);
    }
  }
  if ((int)v39 < 1)
  {
    v8 = v144;
    goto LABEL_43;
  }
  v96 = v46 + 8;
  v8 = v144;
  do
  {
    v47.i64[0] = *((_QWORD *)v96 - 1);
    v47.i32[2] = *v96;
    v97 = (int32x4_t)vmulq_f32(v47, v47);
    v97.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v97, 2), vadd_f32(*(float32x2_t *)v97.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v97.i8, 1))).u32[0];
    v98 = vrsqrte_f32((float32x2_t)v97.u32[0]);
    v99 = vmul_f32(v98, vrsqrts_f32((float32x2_t)v97.u32[0], vmul_f32(v98, v98)));
    v47 = vmulq_n_f32(v47, vmul_f32(v99, vrsqrts_f32((float32x2_t)v97.u32[0], vmul_f32(v99, v99))).f32[0]);
    *((_QWORD *)v96 - 1) = v47.i64[0];
    *v96 = v47.i32[2];
    v96 += 3;
    --v39;
  }
  while (v39);
LABEL_44:
  v127 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v46, 12 * v37, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
  v129 = sub_1B17ED264(1, v127, 1, 3, v37, 12, 0, v128);
  CFRelease(v127);
  v130 = (unint64_t)v8[2];
  v131 = v8[1];
  if ((unint64_t)v131 >= v130)
  {
    v133 = 0xAAAAAAAAAAAAAAABLL * (((char *)v131 - (_BYTE *)*v8) >> 3);
    v134 = v133 + 1;
    if (v133 + 1 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v135 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v130 - (_QWORD)*v8) >> 3);
    if (2 * v135 > v134)
      v134 = 2 * v135;
    if (v135 >= 0x555555555555555)
      v136 = 0xAAAAAAAAAAAAAAALL;
    else
      v136 = v134;
    if (v136)
      v137 = (char *)sub_1B17F7D88((uint64_t)(v8 + 2), v136);
    else
      v137 = 0;
    v138 = &v137[24 * v133];
    v139 = &v137[24 * v136];
    *(_QWORD *)v138 = 0;
    *((_QWORD *)v138 + 1) = 0;
    *((_QWORD *)v138 + 2) = v129;
    v132 = v138 + 24;
    v141 = (char *)*v8;
    v140 = (char *)v8[1];
    if (v140 != *v8)
    {
      do
      {
        v142 = *(_OWORD *)(v140 - 24);
        *((_QWORD *)v138 - 1) = *((_QWORD *)v140 - 1);
        *(_OWORD *)(v138 - 24) = v142;
        v138 -= 24;
        v140 -= 24;
      }
      while (v140 != v141);
      v140 = (char *)*v8;
    }
    *v8 = v138;
    v8[1] = v132;
    v8[2] = v139;
    if (v140)
      operator delete(v140);
  }
  else
  {
    *v131 = 0;
    v131[1] = 0;
    v132 = v131 + 3;
    v131[2] = v129;
  }
  v8[1] = v132;
}

void sub_1B1937790(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, void **a6, uint64_t a7, uint64_t a8)
{
  void **v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int16 v34;
  __int16 v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  size_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const UInt8 *v46;
  float32x4_t v47;
  float v48;
  float v49;
  uint64_t i;
  int *v51;
  int v52;
  int v53;
  int v54;
  float32x4_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float v62;
  float v63;
  float32x4_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  float v71;
  float v72;
  float32x4_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  float v80;
  float v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  unsigned __int32 v91;
  float32x2_t v92;
  float32x2_t v93;
  uint64_t v94;
  int v95;
  _DWORD *v96;
  int32x4_t v97;
  float32x2_t v98;
  float32x2_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  int64_t v109;
  char *v110;
  char *v111;
  char *v112;
  int v113;
  uint64_t v114;
  CFDataRef v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  _QWORD *v119;
  _QWORD *v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  char *v125;
  char *v126;
  char *v127;
  char *v128;
  char *v129;
  __int128 v130;
  uint64_t v131;
  uint64_t v132;
  void **v133;
  uint64_t v134;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  void *__p;
  void *v141;
  uint64_t v142;
  void *v143;
  void *v144;
  uint64_t v145;
  char *v146;
  char *v147;
  uint64_t v148;

  v8 = a6;
  v11 = sub_1B193B2E8(a1, a2, a4, *(_QWORD *)(a1 + 80), a6, (uint64_t)a6, a7, a8);
  if (!v11)
    return;
  v19 = v11;
  if (sub_1B17ED7B4(v11, v12, v13, v14, v15, v16, v17, v18))
    return;
  v33 = sub_1B17ED6C4(v19, v20, v21, v22, v23, v24, v25, v26);
  v35 = v34;
  v37 = v36;
  if (*(_BYTE *)(a1 + 88))
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Position sources must use the 'vertex' interpolation mode"), v27, v28, v29, v30, v31, v32, (uint64_t)"_interpolationMode == kCFXSubdivPrimvarDataInterpolationModeInterpolateVertex");
  v38 = *(unsigned __int8 *)(a5 + 3);
  if (v38 >= 2)
  {
    if (v38 != 2)
      return;
    if (v37 != *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*a3 + 88)
                                      + 24 * (((unint64_t)*(unsigned __int8 *)(*a3 + 8) >> 2) & 0xF))
                          + 8))
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Number of normals at limit surface is not equal to number of vertex positions"), v27, v28, v29, v30, v31, v32, (uint64_t)"subdividedDataCount == refiner.GetLevel(refiner.GetMaxLevel()).GetNumVertices()");
    v46 = (const UInt8 *)malloc_type_malloc(12 * v37, 0x100004052888210uLL);
    v106 = *(_QWORD *)(a1 + 48);
    v107 = *(_QWORD *)(a1 + 56);
    v108 = (_QWORD *)(a1 + 48);
    v146 = 0;
    v147 = 0;
    v148 = 0;
    v109 = v107 - v106;
    if (v107 == v106)
    {
      v143 = 0;
      v144 = 0;
      v145 = 0;
      __p = 0;
      v141 = 0;
      v142 = 0;
    }
    else
    {
      sub_1B193A518(&v146, v109 >> 4);
      v110 = v147;
      bzero(v147, v109);
      v147 = &v110[v109];
      v143 = 0;
      v144 = 0;
      v145 = 0;
      sub_1B193A518(&v143, v109 >> 4);
      v111 = (char *)v144;
      bzero(v144, v109);
      v144 = &v111[v109];
      __p = 0;
      v141 = 0;
      v142 = 0;
      sub_1B193A518(&__p, v109 >> 4);
      v112 = (char *)v141;
      bzero(v141, v109);
      v141 = &v112[v109];
    }
    if (((*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a3 + 40)
                                 + 8 * (((unint64_t)*(unsigned __int8 *)(*a3 + 8) >> 2) & 0xF))
                     + 368)
         - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a3 + 40)
                                 + 8 * (((unint64_t)*(unsigned __int8 *)(*a3 + 8) >> 2) & 0xF))
                     + 360)) & 0x3FFFFFFFCLL) != 0)
    {
      v113 = *(_DWORD *)*a3;
      if (v113)
      {
        if (v113 == 2)
        {
          sub_1B193BAF8(a3, v108, &v146, &v143, &__p);
        }
        else if (v113 == 1)
        {
          sub_1B193B5B0(a3, v108, &v146, &v143, &__p);
        }
      }
      else
      {
        sub_1B193C040((uint64_t)a3, v108, &v146, &v143, &__p);
      }
    }
    else
    {
      sub_1B221BA4C(4, (uint64_t)"Failure in PrimvarRefiner::Limit() -- last level of refinement does not include full topology.", v100, v101, v102, v103, v104, v105, v131);
    }
    if (v37)
    {
      v114 = v37;
      do
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: Does not make sense"), v100, v101, v102, v103, v104, v105, v131);
        --v114;
      }
      while (v114);
    }
    if (__p)
    {
      v141 = __p;
      operator delete(__p);
    }
    if (v143)
    {
      v144 = v143;
      operator delete(v143);
    }
    if (v146)
    {
      v147 = v146;
      operator delete(v146);
    }
LABEL_42:
    if (!v46)
      return;
    goto LABEL_43;
  }
  v132 = v37;
  v133 = v8;
  v39 = *(int *)(*a2 + 8);
  v46 = (const UInt8 *)malloc_type_calloc(v39, 0xCuLL, 0x100004052888210uLL);
  v134 = *(unsigned int *)*a2;
  if ((int)v134 >= 1)
  {
    for (i = 0; i != v134; ++i)
    {
      v51 = (int *)(*(_QWORD *)(*a2 + 48) + 4 * *(int *)(*(_QWORD *)(*a2 + 24) + 8 * i + 4));
      v52 = v51[1];
      v53 = v51[2];
      v54 = v51[3];
      *(double *)v55.i64 = sub_1B198D4F8(v35, (const float *)(v33 + *v51 * (unint64_t)HIBYTE(v35)), v40, v41, v42, v43, v44, v45, v47, v48, v49);
      v139 = v55;
      *(double *)v64.i64 = sub_1B198D4F8(v35, (const float *)(v33 + v52 * (unint64_t)HIBYTE(v35)), v56, v57, v58, v59, v60, v61, v55, v62, v63);
      v138 = v64;
      *(double *)v73.i64 = sub_1B198D4F8(v35, (const float *)(v33 + v53 * (unint64_t)HIBYTE(v35)), v65, v66, v67, v68, v69, v70, v64, v71, v72);
      v137 = v73;
      *(double *)v82.i64 = sub_1B198D4F8(v35, (const float *)(v33 + v54 * (unint64_t)HIBYTE(v35)), v74, v75, v76, v77, v78, v79, v73, v80, v81);
      if (*(_BYTE *)(a5 + 3))
      {
        v83 = vsubq_f32(v137, v139);
        v84 = vsubq_f32(v82, v138);
        v85 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v84, (int32x4_t)v84), (int8x16_t)v84, 0xCuLL), vnegq_f32(v83)), v84, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v83, (int32x4_t)v83), (int8x16_t)v83, 0xCuLL));
        v86 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v85, (int32x4_t)v85), (int8x16_t)v85, 0xCuLL);
        v87 = (int32x4_t)vmulq_f32(v85, v85);
      }
      else
      {
        v88 = vsubq_f32(v138, v139);
        v89 = vsubq_f32(v137, v139);
        v90 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v89, (int32x4_t)v89), (int8x16_t)v89, 0xCuLL), vnegq_f32(v88)), v89, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v88, (int32x4_t)v88), (int8x16_t)v88, 0xCuLL));
        v86 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v90, (int32x4_t)v90), (int8x16_t)v90, 0xCuLL);
        v87 = (int32x4_t)vmulq_f32(v90, v90);
      }
      v91 = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v87.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v87, 2), *(float32x2_t *)v87.i8)).u32[0];
      v92 = vrsqrte_f32((float32x2_t)v91);
      v93 = vmul_f32(v92, vrsqrts_f32((float32x2_t)v91, vmul_f32(v92, v92)));
      v94 = 0;
      v47 = vmulq_n_f32(v86, vmul_f32(v93, vrsqrts_f32((float32x2_t)v91, vmul_f32(v93, v93))).f32[0]);
      v48 = v47.f32[2];
      do
      {
        v95 = 3 * v51[v94];
        *(float32x2_t *)&v46[12 * v51[v94]] = vadd_f32(*(float32x2_t *)v47.f32, *(float32x2_t *)&v46[12 * v51[v94]]);
        v95 += 2;
        v49 = v47.f32[2] + *(float *)&v46[4 * v95];
        *(float *)&v46[4 * v95] = v49;
        ++v94;
      }
      while (v94 != 4);
    }
  }
  if ((int)v39 < 1)
  {
    v37 = v132;
    v8 = v133;
    goto LABEL_42;
  }
  v96 = v46 + 8;
  v37 = v132;
  v8 = v133;
  do
  {
    v47.i64[0] = *((_QWORD *)v96 - 1);
    v47.i32[2] = *v96;
    v97 = (int32x4_t)vmulq_f32(v47, v47);
    v97.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v97, 2), vadd_f32(*(float32x2_t *)v97.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v97.i8, 1))).u32[0];
    v98 = vrsqrte_f32((float32x2_t)v97.u32[0]);
    v99 = vmul_f32(v98, vrsqrts_f32((float32x2_t)v97.u32[0], vmul_f32(v98, v98)));
    v47 = vmulq_n_f32(v47, vmul_f32(v99, vrsqrts_f32((float32x2_t)v97.u32[0], vmul_f32(v99, v99))).f32[0]);
    *((_QWORD *)v96 - 1) = v47.i64[0];
    *v96 = v47.i32[2];
    v96 += 3;
    --v39;
  }
  while (v39);
LABEL_43:
  v115 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v46, 12 * v37, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
  v117 = sub_1B17ED264(1, v115, 1, 3, v37, 12, 0, v116);
  CFRelease(v115);
  v118 = (unint64_t)v8[2];
  v119 = v8[1];
  if ((unint64_t)v119 >= v118)
  {
    v121 = 0xAAAAAAAAAAAAAAABLL * (((char *)v119 - (_BYTE *)*v8) >> 3);
    v122 = v121 + 1;
    if (v121 + 1 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v123 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v118 - (_QWORD)*v8) >> 3);
    if (2 * v123 > v122)
      v122 = 2 * v123;
    if (v123 >= 0x555555555555555)
      v124 = 0xAAAAAAAAAAAAAAALL;
    else
      v124 = v122;
    if (v124)
      v125 = (char *)sub_1B17F7D88((uint64_t)(v8 + 2), v124);
    else
      v125 = 0;
    v126 = &v125[24 * v121];
    v127 = &v125[24 * v124];
    *(_QWORD *)v126 = 0;
    *((_QWORD *)v126 + 1) = 0;
    *((_QWORD *)v126 + 2) = v117;
    v120 = v126 + 24;
    v129 = (char *)*v8;
    v128 = (char *)v8[1];
    if (v128 != *v8)
    {
      do
      {
        v130 = *(_OWORD *)(v128 - 24);
        *((_QWORD *)v126 - 1) = *((_QWORD *)v128 - 1);
        *(_OWORD *)(v126 - 24) = v130;
        v126 -= 24;
        v128 -= 24;
      }
      while (v128 != v129);
      v128 = (char *)*v8;
    }
    *v8 = v126;
    v8[1] = v120;
    v8[2] = v127;
    if (v128)
      operator delete(v128);
  }
  else
  {
    *v119 = 0;
    v119[1] = 0;
    v120 = v119 + 3;
    v119[2] = v117;
  }
  v8[1] = v120;
}

uint64_t sub_1B1937DC8(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, void **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  malloc_type_id_t v39;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  const UInt8 *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const UInt8 *v50;
  uint64_t v51;
  uint64_t v52;
  float32x4_t v53;
  CFDataRef v54;
  uint64_t v55;
  BOOL v56;
  char v57;
  BOOL *v58;
  BOOL *v59;
  char *v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  char *v65;
  BOOL *v66;
  char *v67;
  char *v68;
  char *v69;
  __int128 v70;
  uint64_t v72;

  v10 = a3;
  sub_1B17ED6C4(a4, (uint64_t)a2, a3, a4, (uint64_t)a5, a6, a7, a8);
  v14 = v13;
  v15 = BYTE4(v13);
  v22 = sub_1B179E250(BYTE4(v13), v13, v16, v17, v18, v19, v20, v21);
  v37 = sub_1B17ED7B4(a4, v23, v24, v25, v26, v27, v28, v29);
  if (v37 || HIBYTE(v14) >= 3 && (sub_1B179E6DC(BYTE6(v14), v30, v31, v32, v33, v34, v35, v36) & 1) != 0)
  {
    v72 = a4;
    if (v10)
    {
      v38 = sub_1B22138D4(*a2, *(unsigned __int8 *)(a1 + 72));
      v39 = 1175024481;
    }
    else
    {
      v38 = *(_DWORD *)(*a2 + 8);
      v39 = 995483109;
    }
    v41 = v38;
    v42 = v22 * v38;
    v43 = (const UInt8 *)malloc_type_malloc(v42, v39);
    v50 = v43;
    if (v38 >= 1)
    {
      v51 = 0;
      v52 = (uint64_t)v43;
      do
      {
        v53.i64[0] = *(_QWORD *)(*(_QWORD *)(a1 + 48) + v51);
        v53.i64[1] = v53.i64[0];
        sub_1B198D91C(v15, v52, v44, v45, v46, v47, v48, v49, v53);
        v52 += (unsigned __int16)v22;
        v51 += 8;
      }
      while (8 * v41 != v51);
    }
    v54 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v50, v42, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
    v40 = sub_1B17ED264(v37, v54, v15, 1, v41, v22, 0, v55);
    CFRelease(v54);
    v56 = *(_BYTE *)(a1 + 88) == 2;
    v57 = *(_BYTE *)(a1 + 72);
    v58 = (BOOL *)a5[2];
    v59 = (BOOL *)a5[1];
    if (v59 >= v58)
    {
      v61 = 0xAAAAAAAAAAAAAAABLL * ((v59 - (_BYTE *)*a5) >> 3);
      v62 = v61 + 1;
      if (v61 + 1 > 0xAAAAAAAAAAAAAAALL)
        abort();
      v63 = 0xAAAAAAAAAAAAAAABLL * ((v58 - (_BYTE *)*a5) >> 3);
      if (2 * v63 > v62)
        v62 = 2 * v63;
      if (v63 >= 0x555555555555555)
        v64 = 0xAAAAAAAAAAAAAAALL;
      else
        v64 = v62;
      if (v64)
        v65 = (char *)sub_1B17F7D88((uint64_t)(a5 + 2), v64);
      else
        v65 = 0;
      v66 = (BOOL *)&v65[24 * v61];
      v67 = &v65[24 * v64];
      *v66 = v56;
      v66[1] = v57;
      *(_DWORD *)(v66 + 2) = 0;
      *((_WORD *)v66 + 3) = 0;
      *((_QWORD *)v66 + 1) = v72;
      *((_QWORD *)v66 + 2) = v40;
      v60 = (char *)(v66 + 24);
      v69 = (char *)*a5;
      v68 = (char *)a5[1];
      if (v68 != *a5)
      {
        do
        {
          v70 = *(_OWORD *)(v68 - 24);
          *((_QWORD *)v66 - 1) = *((_QWORD *)v68 - 1);
          *(_OWORD *)(v66 - 24) = v70;
          v66 -= 24;
          v68 -= 24;
        }
        while (v68 != v69);
        v68 = (char *)*a5;
      }
      *a5 = v66;
      a5[1] = v60;
      a5[2] = v67;
      if (v68)
        operator delete(v68);
    }
    else
    {
      *v59 = v56;
      v59[1] = v57;
      *(_DWORD *)(v59 + 2) = 0;
      *((_WORD *)v59 + 3) = 0;
      v60 = (char *)(v59 + 24);
      *((_QWORD *)v59 + 1) = v72;
      *((_QWORD *)v59 + 2) = v40;
    }
    a5[1] = v60;
  }
  else
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Position must be float3 to be subdivided. Actual type is %d"), v31, v32, v33, v34, v35, v36, BYTE4(v14));
    return 0;
  }
  return v40;
}

void sub_1B1938094(uint64_t *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  BOOL v12;
  char v13;
  int v14;
  void *v15;
  unsigned int v16;
  float *v17;
  void *v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t *v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  char *v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  _WORD *v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  __int16 v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  float *v53;
  float *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  float *v58;
  char v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD v63[2];
  int v64;
  int v65;
  int v66;
  int v67;
  _QWORD v68[3];
  _QWORD v69[2];
  _QWORD v70[5];
  _QWORD v71[5];
  int v72;
  _BYTE *v73;
  unsigned int v74;
  int v75;
  _BYTE v76[400];
  void *__p;
  uint64_t *v78;
  int v79;
  int v80;
  uint64_t v81;
  void *v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  v9 = *a1;
  v72 = *(_DWORD *)(*a1 + 4);
  v10 = *(_QWORD **)(*(_QWORD *)(v9 + 40) + 8 * (((unint64_t)*(unsigned __int8 *)(v9 + 8) >> 2) & 0xF));
  v11 = (2 * *((int *)v10 + 5)) | 1;
  if (a4)
    v12 = a5 == 0;
  else
    v12 = 1;
  v13 = v12;
  if (v12)
    v14 = 1;
  else
    v14 = 3;
  v78 = &v81;
  v79 = v11;
  v80 = 33;
  v82 = 0;
  v60 = v10;
  v59 = v13;
  if (v11 >= 0x22)
  {
    v15 = operator new(4 * v11);
    v13 = v59;
    v10 = v60;
    v82 = v15;
    v78 = (uint64_t *)v15;
    v80 = v11;
  }
  v16 = v11 * v14;
  v17 = (float *)v76;
  v73 = v76;
  v74 = v16;
  v75 = 99;
  __p = 0;
  if (v16 < 0x64)
  {
    v18 = 0;
  }
  else
  {
    v18 = operator new(4 * v16);
    v13 = v59;
    v10 = v60;
    __p = v18;
    v73 = v18;
    v75 = v16;
    v17 = (float *)v18;
  }
  v19 = v17 + 1;
  v20 = (uint64_t)&v17[*((int *)v10 + 5) + 1];
  v21 = (uint64_t)&v17[v11 + 1];
  v71[0] = v17;
  v71[1] = v17 + 1;
  v22 = v20 + 4 * v11;
  v71[2] = v20;
  memset(&v71[3], 0, 13);
  v53 = &v17[v11 + v11];
  v54 = &v17[v11];
  v70[0] = v54;
  v70[1] = v21;
  v70[2] = v22;
  memset(&v70[3], 0, 13);
  v68[0] = v53;
  v68[1] = v21 + 4 * v11;
  v68[2] = v22 + 4 * v11;
  v69[0] = 0;
  *(_QWORD *)((char *)v69 + 5) = 0;
  v63[0] = v10;
  v63[1] = v10;
  if (*((int *)v10 + 2) >= 1)
  {
    v23 = 0;
    v57 = (uint64_t)&v17[v11 + 1];
    v58 = v17;
    v56 = v21 + 4 * v11;
    v55 = v22 + 4 * v11;
    do
    {
      v24 = *(unsigned __int16 *)(v10[54] + 2 * v23);
      if ((v24 & 0x800) != 0 || (v25 = v10[42], (v26 = *(_DWORD *)(v25 + 8 * v23)) == 0))
      {
        *(_QWORD *)(*a3 + 8 * v23) = 0;
        *(float32x2_t *)(*a3 + 8 * v23) = vadd_f32(*(float32x2_t *)(*a2 + 8 * v23), *(float32x2_t *)(*a3 + 8 * v23));
        if ((v13 & 1) == 0)
        {
          *(_QWORD *)(*a4 + 8 * v23) = 0;
          *(_QWORD *)(*a5 + 8 * v23) = 0;
        }
      }
      else
      {
        v27 = (2 * v23) | 1;
        v61 = *(int *)(v25 + 4 * v27);
        v62 = v10[45];
        v64 = v23;
        v65 = v23;
        v28 = (v24 >> 7) & 0xF;
        v66 = *(_DWORD *)(*(_QWORD *)(v63[0] + 336) + 8 * v23);
        v67 = *(_DWORD *)(*(_QWORD *)(v63[0] + 264) + 8 * v23);
        if ((v13 & 1) != 0)
          sub_1B19391D4((uint64_t)&v72, (unsigned int *)v63, (uint64_t)v71, v28);
        else
          sub_1B1938E50((uint64_t)&v72, (int *)v63, (uint64_t)v71, (uint64_t)v70, (uint64_t)v68, v28);
        v29 = v78;
        v10 = v60;
        if (v26 >= 1)
        {
          v30 = (int *)(v62 + 4 * v61);
          v31 = v60[15];
          v32 = v26;
          v33 = v78;
          do
          {
            v34 = *v30++;
            *(_DWORD *)v33 = *(_DWORD *)(v31 + 8 * v34 + 4 * (v23 == *(_DWORD *)(v31 + 8 * v34)));
            v33 = (uint64_t *)((char *)v33 + 4);
            --v32;
          }
          while (v32);
        }
        v35 = (char *)v29 + 4 * v26;
        v13 = v59;
        if (LODWORD(v71[4]) || (!LODWORD(v70[4]) ? (v36 = 1) : (v36 = v59), (v36 & 1) == 0))
        {
          v37 = v60[33];
          v38 = *(unsigned int *)(v37 + 8 * v23);
          if ((int)v38 >= 1)
          {
            v39 = *(int *)(v37 + 4 * v27);
            v40 = (int *)(v60[36] + 4 * v39);
            v41 = (_WORD *)(v60[39] + 2 * v39);
            v42 = v60[3];
            v43 = v60[6];
            v44 = (_DWORD *)v29 + v26;
            do
            {
              v45 = *v40++;
              v46 = v43 + 4 * *(int *)(v42 + 8 * v45 + 4);
              v47 = *(_DWORD *)(v42 + 8 * (_DWORD)v45);
              LOWORD(v45) = *v41++;
              v48 = v45 + 2;
              if (v47 > (unsigned __int16)(v45 + 2))
                LOWORD(v47) = 0;
              *v44++ = *(_DWORD *)(v46 + 4 * (unsigned __int16)(v48 - v47));
              --v38;
            }
            while (v38);
          }
        }
        *(_QWORD *)(*a3 + 8 * v23) = 0;
        if (SLODWORD(v71[4]) >= 1)
        {
          v49 = 0;
          do
          {
            *(float32x2_t *)(*a3 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a3 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *(int *)&v35[4 * v49]), *(float *)(v20 + 4 * v49));
            ++v49;
          }
          while (v49 < SLODWORD(v71[4]));
        }
        if (SHIDWORD(v71[3]) >= 1)
        {
          v50 = 0;
          do
          {
            *(float32x2_t *)(*a3 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a3 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *((int *)v29 + v50)), *(float *)&v19[4 * v50]);
            ++v50;
          }
          while (v50 < SHIDWORD(v71[3]));
        }
        *(float32x2_t *)(*a3 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a3 + 8 * v23), *(float32x2_t *)(*a2 + 8 * v23), *v58);
        if ((v59 & 1) == 0)
        {
          *(_QWORD *)(*a4 + 8 * v23) = 0;
          *(_QWORD *)(*a5 + 8 * v23) = 0;
          if (SLODWORD(v70[4]) >= 1)
          {
            v51 = 0;
            do
            {
              *(float32x2_t *)(*a4 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *(int *)&v35[4 * v51]), *(float *)(v20 + 4 * v11 + 4 * v51));
              *(float32x2_t *)(*a5 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a5 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *(int *)&v35[4 * v51]), *(float *)(v55 + 4 * v51));
              ++v51;
            }
            while (v51 < SLODWORD(v70[4]));
          }
          if (SHIDWORD(v70[3]) >= 1)
          {
            v52 = 0;
            do
            {
              *(float32x2_t *)(*a4 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *((int *)v29 + v52)), *(float *)(v57 + 4 * v52));
              *(float32x2_t *)(*a5 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a5 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *((int *)v29 + v52)), *(float *)(v56 + 4 * v52));
              ++v52;
            }
            while (v52 < SHIDWORD(v70[3]));
          }
          *(float32x2_t *)(*a4 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v23), *(float32x2_t *)(*a2 + 8 * v23), *v54);
          *(float32x2_t *)(*a5 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a5 + 8 * v23), *(float32x2_t *)(*a2 + 8 * v23), *v53);
        }
      }
      ++v23;
    }
    while (v23 < *((int *)v10 + 2));
    v18 = __p;
  }
  operator delete(v18);
  operator delete(v82);
}

void sub_1B19385E4(uint64_t *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  BOOL v12;
  char v13;
  int v14;
  void *v15;
  unsigned int v16;
  float *v17;
  void *v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t *v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  char *v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  _WORD *v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  __int16 v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  float *v53;
  float *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  float *v58;
  char v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD v63[2];
  int v64;
  int v65;
  int v66;
  int v67;
  _QWORD v68[3];
  _QWORD v69[2];
  _QWORD v70[5];
  _QWORD v71[5];
  int v72;
  _BYTE *v73;
  unsigned int v74;
  int v75;
  _BYTE v76[400];
  void *__p;
  uint64_t *v78;
  int v79;
  int v80;
  uint64_t v81;
  void *v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  v9 = *a1;
  v72 = *(_DWORD *)(*a1 + 4);
  v10 = *(_QWORD **)(*(_QWORD *)(v9 + 40) + 8 * (((unint64_t)*(unsigned __int8 *)(v9 + 8) >> 2) & 0xF));
  v11 = (2 * *((int *)v10 + 5)) | 1;
  if (a4)
    v12 = a5 == 0;
  else
    v12 = 1;
  v13 = v12;
  if (v12)
    v14 = 1;
  else
    v14 = 3;
  v78 = &v81;
  v79 = v11;
  v80 = 33;
  v82 = 0;
  v60 = v10;
  v59 = v13;
  if (v11 >= 0x22)
  {
    v15 = operator new(4 * v11);
    v13 = v59;
    v10 = v60;
    v82 = v15;
    v78 = (uint64_t *)v15;
    v80 = v11;
  }
  v16 = v11 * v14;
  v17 = (float *)v76;
  v73 = v76;
  v74 = v16;
  v75 = 99;
  __p = 0;
  if (v16 < 0x64)
  {
    v18 = 0;
  }
  else
  {
    v18 = operator new(4 * v16);
    v13 = v59;
    v10 = v60;
    __p = v18;
    v73 = v18;
    v75 = v16;
    v17 = (float *)v18;
  }
  v19 = v17 + 1;
  v20 = (uint64_t)&v17[*((int *)v10 + 5) + 1];
  v21 = (uint64_t)&v17[v11 + 1];
  v71[0] = v17;
  v71[1] = v17 + 1;
  v22 = v20 + 4 * v11;
  v71[2] = v20;
  memset(&v71[3], 0, 13);
  v53 = &v17[v11 + v11];
  v54 = &v17[v11];
  v70[0] = v54;
  v70[1] = v21;
  v70[2] = v22;
  memset(&v70[3], 0, 13);
  v68[0] = v53;
  v68[1] = v21 + 4 * v11;
  v68[2] = v22 + 4 * v11;
  v69[0] = 0;
  *(_QWORD *)((char *)v69 + 5) = 0;
  v63[0] = v10;
  v63[1] = v10;
  if (*((int *)v10 + 2) >= 1)
  {
    v23 = 0;
    v57 = (uint64_t)&v17[v11 + 1];
    v58 = v17;
    v56 = v21 + 4 * v11;
    v55 = v22 + 4 * v11;
    do
    {
      v24 = *(unsigned __int16 *)(v10[54] + 2 * v23);
      if ((v24 & 0x800) != 0 || (v25 = v10[42], (v26 = *(_DWORD *)(v25 + 8 * v23)) == 0))
      {
        *(_QWORD *)(*a3 + 8 * v23) = 0;
        *(float32x2_t *)(*a3 + 8 * v23) = vadd_f32(*(float32x2_t *)(*a2 + 8 * v23), *(float32x2_t *)(*a3 + 8 * v23));
        if ((v13 & 1) == 0)
        {
          *(_QWORD *)(*a4 + 8 * v23) = 0;
          *(_QWORD *)(*a5 + 8 * v23) = 0;
        }
      }
      else
      {
        v27 = (2 * v23) | 1;
        v61 = *(int *)(v25 + 4 * v27);
        v62 = v10[45];
        v64 = v23;
        v65 = v23;
        v28 = (v24 >> 7) & 0xF;
        v66 = *(_DWORD *)(*(_QWORD *)(v63[0] + 336) + 8 * v23);
        v67 = *(_DWORD *)(*(_QWORD *)(v63[0] + 264) + 8 * v23);
        if ((v13 & 1) != 0)
          sub_1B1939D48((uint64_t)&v72, (unsigned int *)v63, (uint64_t)v71, v28);
        else
          sub_1B1939940((uint64_t)&v72, (int *)v63, (uint64_t)v71, (uint64_t)v70, (uint64_t)v68, v28);
        v29 = v78;
        v10 = v60;
        if (v26 >= 1)
        {
          v30 = (int *)(v62 + 4 * v61);
          v31 = v60[15];
          v32 = v26;
          v33 = v78;
          do
          {
            v34 = *v30++;
            *(_DWORD *)v33 = *(_DWORD *)(v31 + 8 * v34 + 4 * (v23 == *(_DWORD *)(v31 + 8 * v34)));
            v33 = (uint64_t *)((char *)v33 + 4);
            --v32;
          }
          while (v32);
        }
        v35 = (char *)v29 + 4 * v26;
        v13 = v59;
        if (LODWORD(v71[4]) || (!LODWORD(v70[4]) ? (v36 = 1) : (v36 = v59), (v36 & 1) == 0))
        {
          v37 = v60[33];
          v38 = *(unsigned int *)(v37 + 8 * v23);
          if ((int)v38 >= 1)
          {
            v39 = *(int *)(v37 + 4 * v27);
            v40 = (int *)(v60[36] + 4 * v39);
            v41 = (_WORD *)(v60[39] + 2 * v39);
            v42 = v60[3];
            v43 = v60[6];
            v44 = (_DWORD *)v29 + v26;
            do
            {
              v45 = *v40++;
              v46 = v43 + 4 * *(int *)(v42 + 8 * v45 + 4);
              v47 = *(_DWORD *)(v42 + 8 * (_DWORD)v45);
              LOWORD(v45) = *v41++;
              v48 = v45 + 2;
              if (v47 > (unsigned __int16)(v45 + 2))
                LOWORD(v47) = 0;
              *v44++ = *(_DWORD *)(v46 + 4 * (unsigned __int16)(v48 - v47));
              --v38;
            }
            while (v38);
          }
        }
        *(_QWORD *)(*a3 + 8 * v23) = 0;
        if (SLODWORD(v71[4]) >= 1)
        {
          v49 = 0;
          do
          {
            *(float32x2_t *)(*a3 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a3 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *(int *)&v35[4 * v49]), *(float *)(v20 + 4 * v49));
            ++v49;
          }
          while (v49 < SLODWORD(v71[4]));
        }
        if (SHIDWORD(v71[3]) >= 1)
        {
          v50 = 0;
          do
          {
            *(float32x2_t *)(*a3 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a3 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *((int *)v29 + v50)), *(float *)&v19[4 * v50]);
            ++v50;
          }
          while (v50 < SHIDWORD(v71[3]));
        }
        *(float32x2_t *)(*a3 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a3 + 8 * v23), *(float32x2_t *)(*a2 + 8 * v23), *v58);
        if ((v59 & 1) == 0)
        {
          *(_QWORD *)(*a4 + 8 * v23) = 0;
          *(_QWORD *)(*a5 + 8 * v23) = 0;
          if (SLODWORD(v70[4]) >= 1)
          {
            v51 = 0;
            do
            {
              *(float32x2_t *)(*a4 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *(int *)&v35[4 * v51]), *(float *)(v20 + 4 * v11 + 4 * v51));
              *(float32x2_t *)(*a5 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a5 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *(int *)&v35[4 * v51]), *(float *)(v55 + 4 * v51));
              ++v51;
            }
            while (v51 < SLODWORD(v70[4]));
          }
          if (SHIDWORD(v70[3]) >= 1)
          {
            v52 = 0;
            do
            {
              *(float32x2_t *)(*a4 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *((int *)v29 + v52)), *(float *)(v57 + 4 * v52));
              *(float32x2_t *)(*a5 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a5 + 8 * v23), *(float32x2_t *)(*a2 + 8 * *((int *)v29 + v52)), *(float *)(v56 + 4 * v52));
              ++v52;
            }
            while (v52 < SHIDWORD(v70[3]));
          }
          *(float32x2_t *)(*a4 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v23), *(float32x2_t *)(*a2 + 8 * v23), *v54);
          *(float32x2_t *)(*a5 + 8 * v23) = vmla_n_f32(*(float32x2_t *)(*a5 + 8 * v23), *(float32x2_t *)(*a2 + 8 * v23), *v53);
        }
      }
      ++v23;
    }
    while (v23 < *((int *)v10 + 2));
    v18 = __p;
  }
  operator delete(v18);
  operator delete(v82);
}

void sub_1B1938B34(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  char v12;
  int v13;
  unsigned int v14;
  float *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  float *v20;
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  int *v26;
  int *v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  float *v32;
  float *v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *__p;
  int *v39;
  int v40;
  int v41;
  uint64_t v42;
  int *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 40)
                 + 8 * (((unint64_t)*(unsigned __int8 *)(*(_QWORD *)a1 + 8) >> 2) & 0xF));
  v10 = (2 * *(int *)(v9 + 20)) | 1;
  if (a4)
    v11 = a5 == 0;
  else
    v11 = 1;
  v12 = v11;
  if (v11)
    v13 = 1;
  else
    v13 = 3;
  v39 = (int *)&v42;
  v40 = v10;
  v41 = 33;
  v43 = 0;
  if (v10 >= 0x22)
  {
    v43 = (int *)operator new(4 * v10);
    v39 = v43;
    v41 = v10;
  }
  v14 = v10 * v13;
  v15 = (float *)&v37;
  __p = 0;
  if (v14 < 0x64)
  {
    v16 = 0;
  }
  else
  {
    v16 = operator new(4 * v14);
    __p = v16;
    v15 = (float *)v16;
  }
  if (*(int *)(v9 + 8) >= 1)
  {
    v17 = 0;
    v18 = 0;
    v19 = &v15[v10];
    v20 = &v19[v10];
    do
    {
      if ((*(_WORD *)(*(_QWORD *)(v9 + 432) + 2 * v17) & 0x800) != 0
        || (v21 = (unsigned int *)(*(_QWORD *)(v9 + 336) + 8 * v17), v22 = *v21, !(_DWORD)v22))
      {
        *(_QWORD *)(*a3 + 8 * v17) = 0;
        *(float32x2_t *)(*a3 + 8 * v17) = vadd_f32(*(float32x2_t *)(*a2 + 8 * v17), *(float32x2_t *)(*a3 + 8 * v17));
        if ((v12 & 1) == 0)
        {
          *(_QWORD *)(*a4 + 8 * v17) = 0;
          *(_QWORD *)(*a5 + 8 * v17) = 0;
        }
      }
      else
      {
        v23 = *(_QWORD *)(v9 + 360);
        v24 = (int)v21[1];
        v25 = v15;
        if ((v12 & 1) == 0)
        {
          *v15 = 1.0;
          *(_QWORD *)v19 = 0x3F800000BF800000;
          v19[2] = 0.0;
          v25 = &v19[v10 + 2];
          v18 = 2;
          *(_QWORD *)v20 = 3212836864;
        }
        *v25 = 1.0;
        v26 = v39;
        if ((int)v22 >= 1)
        {
          v27 = (int *)(v23 + 4 * v24);
          v28 = *(_QWORD *)(v9 + 120);
          v29 = v39;
          do
          {
            v30 = *v27++;
            *v29++ = *(_DWORD *)(v28 + 8 * v30 + 4 * (v17 == *(_DWORD *)(v28 + 8 * v30)));
            --v22;
          }
          while (v22);
        }
        *(_QWORD *)(*a3 + 8 * v17) = 0;
        *(float32x2_t *)(*a3 + 8 * v17) = vmla_n_f32(*(float32x2_t *)(*a3 + 8 * v17), *(float32x2_t *)(*a2 + 8 * v17), *v15);
        if ((v12 & 1) == 0)
        {
          *(_QWORD *)(*a4 + 8 * v17) = 0;
          *(_QWORD *)(*a5 + 8 * v17) = 0;
          v31 = v18;
          v32 = v19 + 1;
          v33 = &v19[v10 + 1];
          if ((int)v18 >= 1)
          {
            do
            {
              v34 = *v32++;
              *(float32x2_t *)(*a4 + 8 * v17) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v17), *(float32x2_t *)(*a2 + 8 * *v26), v34);
              v36 = *v26++;
              v35 = v36;
              *(float *)&v36 = *v33++;
              *(float32x2_t *)(*a5 + 8 * v17) = vmla_n_f32(*(float32x2_t *)(*a5 + 8 * v17), *(float32x2_t *)(*a2 + 8 * v35), *(float *)&v36);
              --v31;
            }
            while (v31);
          }
          *(float32x2_t *)(*a4 + 8 * v17) = vmla_n_f32(*(float32x2_t *)(*a4 + 8 * v17), *(float32x2_t *)(*a2 + 8 * v17), *v19);
          *(float32x2_t *)(*a5 + 8 * v17) = vmla_n_f32(*(float32x2_t *)(*a5 + 8 * v17), *(float32x2_t *)(*a2 + 8 * v17), *v20);
        }
      }
      ++v17;
    }
    while (v17 < *(int *)(v9 + 8));
    v16 = __p;
  }
  operator delete(v16);
  operator delete(v43);
}

void sub_1B1938E50(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  char *v15;
  int *v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  float *v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  float v27;
  char *v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  uint64_t v32;
  _DWORD *v33;
  _DWORD *v34;
  float v35;
  float *v36;
  float *v37;
  int v38[2];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if ((a6 - 1) > 1)
  {
    if (a6 == 4)
    {
      v12 = a2[6];
      v13 = a2[6];
      MEMORY[0x1E0C80A78](a1, 4 * v12);
      v15 = (char *)v38 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v15, v14);
      if ((int)v12 >= 1)
      {
        v16 = (int *)(*(_QWORD *)(*(_QWORD *)a2 + 360)
                    + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)a2 + 336) + 8 * a2[4] + 4));
        v17 = *(_QWORD *)(*(_QWORD *)a2 + 216);
        v18 = v15;
        v19 = v13;
        do
        {
          v20 = *v16++;
          *v18++ = *(_DWORD *)(v17 + 4 * v20);
          --v19;
        }
        while (v19);
      }
      v21 = 0xFFFFFFFF00000000;
      v22 = -1;
      v23 = (float *)v15;
      do
      {
        v24 = *v23++;
        v21 += 0x100000000;
        ++v22;
      }
      while (v24 <= 0.0);
      v25 = 0;
      v38[0] = v22;
      v26 = v12 << 32;
      do
      {
        v27 = *(float *)&v15[4 * v12 - 4 + 4 * v25];
        v26 -= 0x100000000;
        --v25;
      }
      while (v27 <= 0.0);
      v38[1] = v13 + v25;
      *(_DWORD *)(a3 + 24) = 1;
      *(_DWORD *)(a3 + 28) = v13;
      *(_DWORD *)(a3 + 32) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1059760811;
      v28 = *(char **)(a3 + 8);
      if ((int)v13 >= 1)
        bzero(v28, 4 * v12);
      *(_DWORD *)&v28[v21 >> 30] = 1042983595;
      *(_DWORD *)&v28[v26 >> 30] = 1042983595;
      sub_1B1939690(a1, (uint64_t)a2, a4, a5, v38);
    }
    else
    {
      *(_DWORD *)(a3 + 24) = 1;
      *(_QWORD *)(a3 + 28) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1065353216;
      v29 = a2[6];
      *(_DWORD *)(a4 + 24) = 1;
      *(_QWORD *)(a4 + 28) = v29;
      *(_BYTE *)(a4 + 36) = 0;
      *(_DWORD *)(a5 + 24) = 1;
      *(_QWORD *)(a5 + 28) = v29;
      *(_BYTE *)(a5 + 36) = 0;
      **(_DWORD **)a4 = -1082130432;
      v30 = *(_QWORD **)(a4 + 8);
      *v30 = 1065353216;
      **(_DWORD **)a5 = -1082130432;
      v31 = *(_QWORD **)(a5 + 8);
      *v31 = 0x3F80000000000000;
      if ((int)v29 >= 3)
      {
        v32 = v29 - 2;
        v33 = v31 + 1;
        v34 = v30 + 1;
        do
        {
          *v34++ = 0;
          *v33++ = 0;
          --v32;
        }
        while (v32);
      }
    }
  }
  else
  {
    v11 = a2[7];
    *(_DWORD *)(a3 + 24) = 1;
    if ((_DWORD)v11 == 2)
    {
      *(_BYTE *)(a3 + 36) = 0;
      *(_QWORD *)(a3 + 28) = 0;
      **(_DWORD **)a3 = 1065353216;
    }
    else
    {
      *(_DWORD *)(a3 + 28) = v11;
      *(_DWORD *)(a3 + 32) = v11;
      *(_BYTE *)(a3 + 36) = 0;
      if ((_DWORD)v11 == 4)
      {
        **(_DWORD **)a3 = 1055100473;
        *(int32x4_t *)*(_QWORD *)(a3 + 8) = vdupq_n_s32(0x3DE38E39u);
        *(int32x4_t *)*(_QWORD *)(a3 + 16) = vdupq_n_s32(0x3CE38E39u);
      }
      else
      {
        v35 = 1.0 / (float)((float)((float)(int)v11 + 5.0) * (float)(int)v11);
        **(float **)a3 = 1.0 - (float)((float)(int)v11 * (float)(v35 + (float)(v35 * 4.0)));
        if ((int)v11 >= 1)
        {
          v36 = *(float **)(a3 + 8);
          v37 = *(float **)(a3 + 16);
          do
          {
            *v36++ = v35 * 4.0;
            *v37++ = v35;
            --v11;
          }
          while (v11);
        }
      }
    }
    sub_1B1939438(a1, (uint64_t)a2, a4, a5);
  }
}

void sub_1B19391D4(uint64_t a1, unsigned int *a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  size_t v10;
  int *v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  float v18;
  uint64_t v19;
  float *v20;
  float v21;
  float *v22;
  char *v23;
  int32x4_t *v24;
  float v25;
  float *v26;
  float *v27;
  _QWORD v28[2];

  v28[1] = *MEMORY[0x1E0C80C00];
  if ((a4 - 1) > 1)
  {
    if (a4 != 4)
    {
      *(_DWORD *)(a3 + 24) = 1;
      *(_QWORD *)(a3 + 28) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      goto LABEL_18;
    }
    v7 = a2[6];
    MEMORY[0x1E0C80A78](a1, 4 * (int)v7);
    v9 = (char *)v28 - v8;
    bzero((char *)v28 - v8, v10);
    if ((int)v7 >= 1)
    {
      v11 = (int *)(*(_QWORD *)(*(_QWORD *)a2 + 360)
                  + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)a2 + 336) + 8 * (int)a2[4] + 4));
      v12 = *(_QWORD *)(*(_QWORD *)a2 + 216);
      v13 = v9;
      v14 = v7;
      do
      {
        v15 = *v11++;
        *v13++ = *(_DWORD *)(v12 + 4 * v15);
        --v14;
      }
      while (v14);
    }
    v16 = 0xFFFFFFFF00000000;
    v17 = (float *)v9;
    do
    {
      v18 = *v17++;
      v16 += 0x100000000;
    }
    while (v18 <= 0.0);
    v19 = (uint64_t)(int)v7 << 32;
    v20 = (float *)&v9[4 * (int)v7 - 4];
    do
    {
      v21 = *v20--;
      v19 -= 0x100000000;
    }
    while (v21 <= 0.0);
    *(_DWORD *)(a3 + 24) = 1;
    *(_DWORD *)(a3 + 28) = v7;
    *(_DWORD *)(a3 + 32) = 0;
    *(_BYTE *)(a3 + 36) = 0;
    v22 = *(float **)a3;
    v23 = *(char **)(a3 + 8);
    *v22 = 0.66667;
    if ((int)v7 >= 1)
      bzero(v23, 4 * v7);
    *(_DWORD *)&v23[v16 >> 30] = 1042983595;
    *(_DWORD *)&v23[v19 >> 30] = 1042983595;
  }
  else
  {
    v6 = a2[7];
    *(_DWORD *)(a3 + 24) = 1;
    if ((_DWORD)v6 == 2)
    {
      *(_BYTE *)(a3 + 36) = 0;
      *(_QWORD *)(a3 + 28) = 0;
LABEL_18:
      **(_DWORD **)a3 = 1065353216;
      return;
    }
    *(_DWORD *)(a3 + 28) = v6;
    *(_DWORD *)(a3 + 32) = v6;
    *(_BYTE *)(a3 + 36) = 0;
    if ((_DWORD)v6 == 4)
    {
      v24 = *(int32x4_t **)(a3 + 8);
      **(_DWORD **)a3 = 1055100473;
      *v24 = vdupq_n_s32(0x3DE38E39u);
      *(int32x4_t *)*(_QWORD *)(a3 + 16) = vdupq_n_s32(0x3CE38E39u);
    }
    else
    {
      v25 = 1.0 / (float)((float)((float)(int)v6 + 5.0) * (float)(int)v6);
      **(float **)a3 = 1.0 - (float)((float)(int)v6 * (float)(v25 + (float)(v25 * 4.0)));
      if ((int)v6 >= 1)
      {
        v26 = *(float **)(a3 + 8);
        v27 = *(float **)(a3 + 16);
        do
        {
          *v26++ = v25 * 4.0;
          *v27++ = v25;
          --v6;
        }
        while (v6);
      }
    }
  }
}

void sub_1B1939438(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _DWORD *v11;
  _DWORD *v12;
  _OWORD *v13;
  _OWORD *v14;
  double v15;
  double v16;
  double v17;
  int v18;
  uint64_t v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  double v23;
  long double v24;
  float v25;
  _DWORD *v26;
  int *v27;
  int *v28;
  _DWORD *v29;
  _DWORD *v30;
  _DWORD *v31;
  uint64_t v32;
  int v33;
  int v34;

  v6 = *(unsigned int *)(a2 + 28);
  if ((_DWORD)v6 == 2)
  {
    v7 = *(unsigned int *)(a2 + 24);
    *(_DWORD *)(a3 + 24) = 1;
    *(_QWORD *)(a3 + 28) = v7;
    *(_BYTE *)(a3 + 36) = 0;
    *(_DWORD *)(a4 + 24) = 1;
    *(_QWORD *)(a4 + 28) = v7;
    *(_BYTE *)(a4 + 36) = 0;
    v8 = *(_QWORD **)(a3 + 8);
    **(_DWORD **)a3 = -1082130432;
    *v8 = 1065353216;
    v9 = *(_QWORD **)(a4 + 8);
    **(_DWORD **)a4 = -1082130432;
    *v9 = 0x3F80000000000000;
    if ((int)v7 >= 3)
    {
      v10 = v7 - 2;
      v11 = v9 + 1;
      v12 = v8 + 1;
      do
      {
        *v12++ = 0;
        *v11++ = 0;
        --v10;
      }
      while (v10);
    }
  }
  else
  {
    *(_DWORD *)(a3 + 24) = 1;
    *(_DWORD *)(a3 + 28) = v6;
    *(_DWORD *)(a3 + 32) = v6;
    *(_BYTE *)(a3 + 36) = 0;
    **(_DWORD **)a3 = 0;
    if ((_DWORD)v6 == 4)
    {
      v13 = *(_OWORD **)(a3 + 16);
      *(_OWORD *)*(_QWORD *)(a3 + 8) = xmmword_1B2268300;
      *v13 = xmmword_1B2268310;
      *(_QWORD *)(a4 + 24) = 0x400000001;
      *(_DWORD *)(a4 + 32) = 4;
      *(_BYTE *)(a4 + 36) = 0;
      v14 = *(_OWORD **)(a4 + 8);
      **(_DWORD **)a4 = 0;
      *v14 = xmmword_1B2268320;
      *(_OWORD *)*(_QWORD *)(a4 + 16) = xmmword_1B2268330;
    }
    else
    {
      v15 = 6.28318531 / (double)(int)v6;
      v16 = cos(v15);
      v17 = cos(v15 * 0.5);
      v18 = v6 - 1;
      if ((int)v6 >= 1)
      {
        v19 = 0;
        v20 = 1.0 / (((v16 + v17 * sqrt(v16 + 9.0 + v16 + 9.0)) * 0.0625 + 0.3125) * 4.0 + -1.0);
        v21 = *(_QWORD *)(a3 + 8);
        v22 = *(_QWORD *)(a3 + 16);
        do
        {
          v23 = cos(v15 * (double)(int)v19);
          v24 = cos(v15 * (double)((int)v19 + 1));
          v25 = v23 * 4.0;
          *(float *)(v21 + 4 * v19) = v25;
          *(float *)&v24 = v20 * (v23 + v24);
          *(_DWORD *)(v22 + 4 * v19++) = LODWORD(v24);
        }
        while (v6 != v19);
      }
      *(_DWORD *)(a4 + 24) = 1;
      *(_DWORD *)(a4 + 28) = v6;
      *(_DWORD *)(a4 + 32) = v6;
      *(_BYTE *)(a4 + 36) = 0;
      v26 = *(_DWORD **)(a4 + 8);
      **(_DWORD **)a4 = 0;
      v27 = *(int **)(a3 + 8);
      v28 = *(int **)(a3 + 16);
      *v26 = v27[v18];
      v29 = *(_DWORD **)(a4 + 16);
      *v29 = v28[v18];
      if ((int)v6 > 1)
      {
        v30 = v29 + 1;
        v31 = v26 + 1;
        v32 = v6 - 1;
        do
        {
          v33 = *v27++;
          *v31++ = v33;
          v34 = *v28++;
          *v30++ = v34;
          --v32;
        }
        while (v32);
      }
    }
  }
}

void sub_1B1939690(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _DWORD *v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  double v22;
  double v23;
  __double2 v24;
  double sinval;
  double v26;
  double v27;
  float v28;
  _DWORD *v29;
  _DWORD *v30;
  uint64_t v31;
  double v32;
  long double v33;
  float v34;
  float v35;

  v8 = *(unsigned int *)(a2 + 24);
  v9 = *(unsigned int *)(a2 + 28);
  *(_DWORD *)(a3 + 24) = 1;
  *(_DWORD *)(a3 + 28) = v8;
  *(_DWORD *)(a3 + 32) = v9;
  *(_BYTE *)(a3 + 36) = 0;
  **(_DWORD **)a3 = 0;
  if ((int)v8 >= 1)
    bzero(*(void **)(a3 + 8), 4 * v8);
  if ((int)v9 >= 1)
    bzero(*(void **)(a3 + 16), 4 * v9);
  v10 = *(_QWORD *)(a3 + 8);
  v11 = a5[1];
  *(_DWORD *)(v10 + 4 * *a5) = 1056964608;
  *(_DWORD *)(v10 + 4 * v11) = -1090519040;
  *(_DWORD *)(a4 + 24) = 1;
  *(_DWORD *)(a4 + 28) = v8;
  *(_DWORD *)(a4 + 32) = v9;
  *(_BYTE *)(a4 + 36) = 0;
  v12 = *a5;
  if (*a5 >= 1)
  {
    v13 = *(_DWORD **)(a4 + 8);
    v14 = *(_DWORD **)(a4 + 16);
    v15 = *a5;
    do
    {
      *v13++ = 0;
      *v14++ = 0;
      --v15;
    }
    while (v15);
  }
  v16 = v12;
  v17 = a5[1];
  v18 = v17 - v12;
  if ((_DWORD)v17 - v12 == 2)
  {
    v19 = *(_QWORD *)(a4 + 8);
    **(_DWORD **)a4 = -1087722837;
    *(_DWORD *)(v19 + 4 * v12) = -1104500053;
    v20 = v12 + 1;
    *(_DWORD *)(v19 + 4 * v20) = 1059760811;
    *(_DWORD *)(v19 + 4 * v17) = -1104500053;
    v21 = *(_QWORD *)(a4 + 16);
    *(_DWORD *)(v21 + 4 * v12) = 1042983595;
    *(_DWORD *)(v21 + 4 * v20) = 1042983595;
  }
  else if (v18 < 3)
  {
    v19 = *(_QWORD *)(a4 + 8);
    **(_DWORD **)a4 = -1061158912;
    *(_DWORD *)(v19 + 4 * v12) = 1077936128;
    *(_DWORD *)(v19 + 4 * v17) = 1077936128;
    v21 = *(_QWORD *)(a4 + 16);
    *(_DWORD *)(v21 + 4 * v12) = 0;
  }
  else
  {
    v22 = (double)v18;
    v23 = 3.14159265 / (double)v18;
    v24 = __sincos_stret(v23);
    sinval = v24.__sinval;
    v26 = 1.0 / ((v24.__cosval + 3.0) * v22);
    v27 = (v24.__cosval + 1.0) / v24.__sinval;
    v28 = v26 * ((v24.__cosval + -1.0) * (v27 * 4.0));
    v19 = *(_QWORD *)(a4 + 8);
    **(float **)a4 = v28;
    *(float *)&v27 = -(v27 * (v24.__cosval * 2.0 + 1.0)) * v26;
    v29 = (_DWORD *)(v19 + 4 * v16);
    *v29 = LODWORD(v27);
    *(_DWORD *)(v19 + 4 * v17) = LODWORD(v27);
    *(float *)&v27 = v24.__sinval * v26;
    v21 = *(_QWORD *)(a4 + 16);
    v30 = (_DWORD *)(v21 + 4 * v16);
    *v30 = LODWORD(v27);
    v31 = 1;
    do
    {
      v32 = (double)((int)v31 + 1);
      v33 = sin(v23 * v32);
      v34 = v26 * (sinval * 4.0);
      *(float *)&v29[v31] = v34;
      v35 = v26 * (sinval + v33);
      *(float *)&v30[v31++] = v35;
      sinval = v33;
    }
    while (v32 < v22);
  }
  if ((int)v17 < (int)v9)
    bzero((void *)(v21 + 4 * v17), 4 * (v9 + ~(_DWORD)v17) + 4);
  if ((int)v17 + 1 < (int)v8)
    bzero((void *)(v19 + 4 * ((int)v17 + 1)), 4 * (v8 - v17 - 2) + 4);
}

void sub_1B1939940(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v10;
  int32x4_t *v11;
  int32x4_t v12;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  char *v17;
  int *v18;
  uint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  float *v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  float v29;
  char *v30;
  float v31;
  float v32;
  float v33;
  float *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  _DWORD *v42;
  _DWORD *v43;
  uint64_t v44;
  float v45;
  uint64_t v46;
  uint64_t v47;
  __double2 v48;
  float cosval;
  float sinval;
  unsigned int v51[2];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if ((a6 - 1) > 1)
  {
    if (a6 == 4)
    {
      v14 = a2[6];
      v15 = a2[6];
      MEMORY[0x1E0C80A78](a1, 4 * v14);
      v17 = (char *)v51 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v17, v16);
      if ((int)v14 >= 1)
      {
        v18 = (int *)(*(_QWORD *)(*(_QWORD *)a2 + 360)
                    + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)a2 + 336) + 8 * a2[4] + 4));
        v19 = *(_QWORD *)(*(_QWORD *)a2 + 216);
        v20 = v17;
        v21 = v15;
        do
        {
          v22 = *v18++;
          *v20++ = *(_DWORD *)(v19 + 4 * v22);
          --v21;
        }
        while (v21);
      }
      v23 = 0xFFFFFFFF00000000;
      v24 = -1;
      v25 = (float *)v17;
      do
      {
        v26 = *v25++;
        v23 += 0x100000000;
        ++v24;
      }
      while (v26 <= 0.0);
      v27 = 0;
      v51[0] = v24;
      v28 = v14 << 32;
      do
      {
        v29 = *(float *)&v17[4 * v14 - 4 + 4 * v27];
        v28 -= 0x100000000;
        --v27;
      }
      while (v29 <= 0.0);
      v51[1] = v15 + v27;
      *(_DWORD *)(a3 + 24) = 1;
      *(_DWORD *)(a3 + 28) = v15;
      *(_DWORD *)(a3 + 32) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1059760811;
      v30 = *(char **)(a3 + 8);
      if ((int)v15 >= 1)
        bzero(v30, 4 * v14);
      *(_DWORD *)&v30[v23 >> 30] = 1042983595;
      *(_DWORD *)&v30[v28 >> 30] = 1042983595;
      sub_1B1939FB4(a1, (uint64_t)a2, a4, a5, v51);
    }
    else
    {
      *(_DWORD *)(a3 + 24) = 1;
      *(_QWORD *)(a3 + 28) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1065353216;
      v38 = a2[6];
      *(_DWORD *)(a4 + 24) = 1;
      *(_QWORD *)(a4 + 28) = v38;
      *(_BYTE *)(a4 + 36) = 0;
      *(_DWORD *)(a5 + 24) = 1;
      *(_QWORD *)(a5 + 28) = v38;
      *(_BYTE *)(a5 + 36) = 0;
      **(_DWORD **)a4 = -1069547520;
      v39 = *(_QWORD **)(a4 + 8);
      *v39 = 1077936128;
      **(_DWORD **)a5 = -1069547520;
      v40 = *(_QWORD **)(a5 + 8);
      *v40 = 0x4040000000000000;
      if ((int)v38 >= 3)
      {
        v41 = v38 - 2;
        v42 = v40 + 1;
        v43 = v39 + 1;
        do
        {
          *v43++ = 0;
          *v42++ = 0;
          --v41;
        }
        while (v41);
      }
    }
  }
  else
  {
    v10 = a2[7];
    *(_DWORD *)(a3 + 24) = 1;
    *(_QWORD *)(a3 + 28) = v10;
    *(_BYTE *)(a3 + 36) = 0;
    if ((_DWORD)v10 == 6)
    {
      **(_DWORD **)a3 = 1056964608;
      v11 = *(int32x4_t **)(a3 + 8);
      v12 = vdupq_n_s32(0x3DAAAAABu);
      *v11 = v12;
      v11[1].i64[0] = v12.i64[0];
    }
    else
    {
      v31 = 1.0 / (float)(int)v10;
      v32 = cosf(v31 * 6.2832);
      v33 = 1.0
          / (float)((float)(3.0
                          / (float)((float)(v31
                                          * (float)(0.625
                                                  - (float)((float)((float)(v32 * 0.25) + 0.375)
                                                          * (float)((float)(v32 * 0.25) + 0.375))))
                                  * 8.0))
                  + (float)(int)v10);
      **(float **)a3 = 1.0 - (float)(v33 * (float)(int)v10);
      if ((int)v10 >= 1)
      {
        v34 = *(float **)(a3 + 8);
        v35 = v10;
        do
        {
          *v34++ = v33;
          --v35;
        }
        while (v35);
      }
    }
    *(_DWORD *)(a4 + 24) = 1;
    *(_DWORD *)(a4 + 28) = v10;
    *(_DWORD *)(a4 + 32) = 0;
    *(_BYTE *)(a4 + 36) = 0;
    *(_DWORD *)(a5 + 24) = 1;
    *(_DWORD *)(a5 + 28) = v10;
    *(_DWORD *)(a5 + 32) = 0;
    *(_BYTE *)(a5 + 36) = 0;
    **(_DWORD **)a4 = 0;
    **(_DWORD **)a5 = 0;
    if ((_DWORD)v10 == 6)
    {
      v36 = *(_QWORD *)(a4 + 8);
      *(_OWORD *)v36 = xmmword_1B2268340;
      *(_QWORD *)(v36 + 16) = 0x3F000000BF000000;
      v37 = *(_QWORD *)(a5 + 8);
      *(_OWORD *)v37 = xmmword_1B2268350;
      *(int32x2_t *)(v37 + 16) = vdup_n_s32(0xBF5DB3D7);
    }
    else if ((int)v10 >= 1)
    {
      v44 = 0;
      v46 = *(_QWORD *)(a4 + 8);
      v47 = *(_QWORD *)(a5 + 8);
      do
      {
        v45 = 6.28318531 / (double)(int)v10;
        v48 = __sincos_stret((float)(v45 * (float)(int)v44));
        cosval = v48.__cosval;
        *(float *)(v46 + 4 * v44) = cosval;
        sinval = v48.__sinval;
        *(float *)(v47 + 4 * v44++) = sinval;
      }
      while (v10 != v44);
    }
  }
}

void sub_1B1939D48(uint64_t a1, unsigned int *a2, uint64_t a3, int a4)
{
  uint64_t v6;
  int32x4_t *v7;
  int32x4_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  size_t v12;
  int *v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  float v20;
  uint64_t v21;
  float *v22;
  float v23;
  float *v24;
  char *v25;
  float v26;
  float v27;
  float v28;
  float *v29;
  _QWORD v30[2];

  v30[1] = *MEMORY[0x1E0C80C00];
  if ((a4 - 1) > 1)
  {
    if (a4 == 4)
    {
      v9 = a2[6];
      MEMORY[0x1E0C80A78](a1, 4 * (int)v9);
      v11 = (char *)v30 - v10;
      bzero((char *)v30 - v10, v12);
      if ((int)v9 >= 1)
      {
        v13 = (int *)(*(_QWORD *)(*(_QWORD *)a2 + 360)
                    + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)a2 + 336) + 8 * (int)a2[4] + 4));
        v14 = *(_QWORD *)(*(_QWORD *)a2 + 216);
        v15 = v11;
        v16 = v9;
        do
        {
          v17 = *v13++;
          *v15++ = *(_DWORD *)(v14 + 4 * v17);
          --v16;
        }
        while (v16);
      }
      v18 = 0xFFFFFFFF00000000;
      v19 = (float *)v11;
      do
      {
        v20 = *v19++;
        v18 += 0x100000000;
      }
      while (v20 <= 0.0);
      v21 = (uint64_t)(int)v9 << 32;
      v22 = (float *)&v11[4 * (int)v9 - 4];
      do
      {
        v23 = *v22--;
        v21 -= 0x100000000;
      }
      while (v23 <= 0.0);
      *(_DWORD *)(a3 + 24) = 1;
      *(_DWORD *)(a3 + 28) = v9;
      *(_DWORD *)(a3 + 32) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      v24 = *(float **)a3;
      v25 = *(char **)(a3 + 8);
      *v24 = 0.66667;
      if ((int)v9 >= 1)
        bzero(v25, 4 * v9);
      *(_DWORD *)&v25[v18 >> 30] = 1042983595;
      *(_DWORD *)&v25[v21 >> 30] = 1042983595;
    }
    else
    {
      *(_DWORD *)(a3 + 24) = 1;
      *(_QWORD *)(a3 + 28) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1065353216;
    }
  }
  else
  {
    v6 = a2[7];
    *(_DWORD *)(a3 + 24) = 1;
    *(_QWORD *)(a3 + 28) = v6;
    *(_BYTE *)(a3 + 36) = 0;
    if ((_DWORD)v6 == 6)
    {
      v7 = *(int32x4_t **)(a3 + 8);
      **(_DWORD **)a3 = 1056964608;
      v8 = vdupq_n_s32(0x3DAAAAABu);
      *v7 = v8;
      v7[1].i64[0] = v8.i64[0];
    }
    else
    {
      v26 = 1.0 / (float)(int)v6;
      v27 = cosf(v26 * 6.2832);
      v28 = 1.0
          / (float)((float)(3.0
                          / (float)((float)(v26
                                          * (float)(0.625
                                                  - (float)((float)((float)(v27 * 0.25) + 0.375)
                                                          * (float)((float)(v27 * 0.25) + 0.375))))
                                  * 8.0))
                  + (float)(int)v6);
      **(float **)a3 = 1.0 - (float)(v28 * (float)(int)v6);
      if ((int)v6 >= 1)
      {
        v29 = *(float **)(a3 + 8);
        do
        {
          *v29++ = v28;
          --v6;
        }
        while (v6);
      }
    }
  }
}

void sub_1B1939FB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  int v16;
  int v17;
  __double2 v18;
  unint64_t v19;
  float cosval;
  _DWORD *v21;
  float sinval;
  float v23;
  float v24;
  float *v25;
  uint64_t v26;
  float *v27;
  int64x2_t v28;
  double v29;
  float v30;
  float v31;
  _DWORD *v32;
  uint64x2_t v33;
  double v34;
  float64x2_t __x;
  double v36;
  int32x2_t v37;

  v7 = *(unsigned int *)(a2 + 24);
  *(_DWORD *)(a3 + 24) = 1;
  *(_QWORD *)(a3 + 28) = v7;
  *(_BYTE *)(a3 + 36) = 0;
  v8 = *(void **)(a3 + 8);
  **(_DWORD **)a3 = 0;
  if ((int)v7 >= 1)
    bzero(v8, 4 * v7);
  v9 = (int)a5[1];
  *((_DWORD *)v8 + (int)*a5) = 1069547520;
  *((_DWORD *)v8 + v9) = -1077936128;
  *(_DWORD *)(a4 + 24) = 1;
  *(_DWORD *)(a4 + 28) = v7;
  *(_DWORD *)(a4 + 32) = 0;
  *(_BYTE *)(a4 + 36) = 0;
  v10 = *a5;
  v11 = (int)v10;
  if ((int)v10 >= 1)
    bzero(*(void **)(a4 + 8), 4 * v10);
  v12 = (int)a5[1];
  v13 = (v12 - v10);
  if ((_DWORD)v13 == 3)
  {
    v14 = *(_DWORD **)a4;
    v15 = *(_QWORD *)(a4 + 8);
    *v14 = -1075989545;
    *(_DWORD *)(v15 + 4 * (int)v10) = -1084378153;
    *(_DWORD *)(v15 + 4 * v12) = -1084378153;
    v16 = 1071494103;
    *(_DWORD *)(v15 + 4 * ((int)v10 + 1)) = 1071494103;
    v17 = v10 + 2;
LABEL_17:
    *(_DWORD *)(v15 + 4 * v17) = v16;
    goto LABEL_18;
  }
  if ((int)v13 < 4)
  {
    v32 = *(_DWORD **)a4;
    if ((_DWORD)v13 == 2)
    {
      *v32 = -1069547520;
      v15 = *(_QWORD *)(a4 + 8);
      *(_DWORD *)(v15 + 4 * (int)v10) = 0;
      *(_DWORD *)(v15 + 4 * v12) = 0;
      v17 = v10 + 1;
      v16 = 1077936128;
      goto LABEL_17;
    }
    *v32 = -1061158912;
    v15 = *(_QWORD *)(a4 + 8);
    *(_DWORD *)(v15 + 4 * (int)v10) = 1077936128;
    *(_DWORD *)(v15 + 4 * v12) = 1077936128;
  }
  else
  {
    v34 = 3.14159265 / (double)(int)v13;
    v18 = __sincos_stret(v34);
    v19 = 0;
    cosval = v18.__cosval;
    v21 = *(_DWORD **)a4;
    v15 = *(_QWORD *)(a4 + 8);
    *v21 = 0;
    v33 = (uint64x2_t)vdupq_n_s64(v13 - 2);
    sinval = v18.__sinval;
    v23 = sinval * -3.0;
    v24 = (float)((float)(cosval * 2.0) + -2.0) * -3.0;
    v25 = (float *)(v15 + 4 * v11);
    *v25 = v23;
    *(float *)(v15 + 4 * v12) = v23;
    v26 = v13 & 0xFFFFFFFE;
    v27 = v25 + 2;
    do
    {
      v37 = vmovn_s64((int64x2_t)vcgeq_u64(v33, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v19), (int8x16_t)xmmword_1B2244C80)));
      v28.i64[0] = (int)(v19 | 1);
      v28.i64[1] = vadd_s32(vdup_lane_s32((int32x2_t)v19, 0), (int32x2_t)0x200000002).i32[1];
      __x = vmulq_n_f64(vcvtq_f64_s64(v28), v34);
      v36 = sin(__x.f64[1]);
      v29 = sin(__x.f64[0]);
      if ((v37.i8[0] & 1) != 0)
      {
        v30 = v29;
        *(v27 - 1) = v24 * v30;
      }
      if ((v37.i8[4] & 1) != 0)
      {
        v31 = v36;
        *v27 = v24 * v31;
      }
      v19 += 2;
      v27 += 2;
    }
    while (v26 != v19);
  }
LABEL_18:
  if ((int)v12 + 1 < (int)v7)
    bzero((void *)(v15 + 4 * ((int)v12 + 1)), 4 * (v7 - v12 - 2) + 4);
}

uint64_t sub_1B193A24C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, void **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  malloc_type_id_t v39;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  const UInt8 *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const UInt8 *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  float32x4_t v54;
  CFDataRef v55;
  uint64_t v56;
  BOOL v57;
  char v58;
  BOOL *v59;
  BOOL *v60;
  char *v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  char *v66;
  BOOL *v67;
  char *v68;
  char *v69;
  char *v70;
  __int128 v71;
  uint64_t v73;

  v10 = a3;
  sub_1B17ED6C4(a4, (uint64_t)a2, a3, a4, (uint64_t)a5, a6, a7, a8);
  v14 = v13;
  v15 = BYTE4(v13);
  v22 = sub_1B179E250(BYTE4(v13), v13, v16, v17, v18, v19, v20, v21);
  v37 = sub_1B17ED7B4(a4, v23, v24, v25, v26, v27, v28, v29);
  if (v37 || HIBYTE(v14) >= 3 && (sub_1B179E6DC(BYTE6(v14), v30, v31, v32, v33, v34, v35, v36) & 1) != 0)
  {
    v73 = a4;
    if (v10)
    {
      v38 = sub_1B22138D4(*a2, *(unsigned __int8 *)(a1 + 72));
      v39 = 1175024481;
    }
    else
    {
      v38 = *(_DWORD *)(*a2 + 8);
      v39 = 995483109;
    }
    v41 = v38;
    v42 = v22 * v38;
    v43 = (const UInt8 *)malloc_type_malloc(v42, v39);
    v50 = v43;
    if (v38 >= 1)
    {
      v51 = 0;
      v52 = (uint64_t)v43;
      do
      {
        v53 = *(_QWORD *)(a1 + 48);
        v54 = *(float32x4_t *)(v53 + v51);
        v54.i32[3] = *(_QWORD *)(v53 + v51 + 8);
        sub_1B198D91C(v15, v52, v44, v45, v46, v47, v48, v49, v54);
        v52 += (unsigned __int16)v22;
        v51 += 16;
      }
      while (16 * v41 != v51);
    }
    v55 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v50, v42, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
    v40 = sub_1B17ED264(v37, v55, v15, 1, v41, v22, 0, v56);
    CFRelease(v55);
    v57 = *(_BYTE *)(a1 + 88) == 2;
    v58 = *(_BYTE *)(a1 + 72);
    v59 = (BOOL *)a5[2];
    v60 = (BOOL *)a5[1];
    if (v60 >= v59)
    {
      v62 = 0xAAAAAAAAAAAAAAABLL * ((v60 - (_BYTE *)*a5) >> 3);
      v63 = v62 + 1;
      if (v62 + 1 > 0xAAAAAAAAAAAAAAALL)
        abort();
      v64 = 0xAAAAAAAAAAAAAAABLL * ((v59 - (_BYTE *)*a5) >> 3);
      if (2 * v64 > v63)
        v63 = 2 * v64;
      if (v64 >= 0x555555555555555)
        v65 = 0xAAAAAAAAAAAAAAALL;
      else
        v65 = v63;
      if (v65)
        v66 = (char *)sub_1B17F7D88((uint64_t)(a5 + 2), v65);
      else
        v66 = 0;
      v67 = (BOOL *)&v66[24 * v62];
      v68 = &v66[24 * v65];
      *v67 = v57;
      v67[1] = v58;
      *(_DWORD *)(v67 + 2) = 0;
      *((_WORD *)v67 + 3) = 0;
      *((_QWORD *)v67 + 1) = v73;
      *((_QWORD *)v67 + 2) = v40;
      v61 = (char *)(v67 + 24);
      v70 = (char *)*a5;
      v69 = (char *)a5[1];
      if (v69 != *a5)
      {
        do
        {
          v71 = *(_OWORD *)(v69 - 24);
          *((_QWORD *)v67 - 1) = *((_QWORD *)v69 - 1);
          *(_OWORD *)(v67 - 24) = v71;
          v67 -= 24;
          v69 -= 24;
        }
        while (v69 != v70);
        v69 = (char *)*a5;
      }
      *a5 = v67;
      a5[1] = v61;
      a5[2] = v68;
      if (v69)
        operator delete(v69);
    }
    else
    {
      *v60 = v57;
      v60[1] = v58;
      *(_DWORD *)(v60 + 2) = 0;
      *((_WORD *)v60 + 3) = 0;
      v61 = (char *)(v60 + 24);
      *((_QWORD *)v60 + 1) = v73;
      *((_QWORD *)v60 + 2) = v40;
    }
    a5[1] = v61;
  }
  else
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Position must be float3 to be subdivided. Actual type is %d"), v31, v32, v33, v34, v35, v36, BYTE4(v14));
    return 0;
  }
  return v40;
}

char *sub_1B193A518(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    abort();
  result = (char *)sub_1B17F7824((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void sub_1B193A554(uint64_t *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  BOOL v12;
  char v13;
  int v14;
  void *v15;
  unsigned int v16;
  float *v17;
  void *v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t *v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char *v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  _WORD *v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  __int16 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  float *v54;
  float *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  float *v59;
  char v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD v64[2];
  int v65;
  int v66;
  int v67;
  int v68;
  _QWORD v69[3];
  _QWORD v70[2];
  _QWORD v71[5];
  _QWORD v72[5];
  int v73;
  _BYTE *v74;
  unsigned int v75;
  int v76;
  _BYTE v77[400];
  void *__p;
  uint64_t *v79;
  int v80;
  int v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v9 = *a1;
  v73 = *(_DWORD *)(*a1 + 4);
  v10 = *(_QWORD **)(*(_QWORD *)(v9 + 40) + 8 * (((unint64_t)*(unsigned __int8 *)(v9 + 8) >> 2) & 0xF));
  v11 = (2 * *((int *)v10 + 5)) | 1;
  if (a4)
    v12 = a5 == 0;
  else
    v12 = 1;
  v13 = v12;
  if (v12)
    v14 = 1;
  else
    v14 = 3;
  v79 = &v82;
  v80 = v11;
  v81 = 33;
  v83 = 0;
  v61 = v10;
  v60 = v13;
  if (v11 >= 0x22)
  {
    v15 = operator new(4 * v11);
    v13 = v60;
    v10 = v61;
    v83 = v15;
    v79 = (uint64_t *)v15;
    v81 = v11;
  }
  v16 = v11 * v14;
  v17 = (float *)v77;
  v74 = v77;
  v75 = v16;
  v76 = 99;
  __p = 0;
  if (v16 < 0x64)
  {
    v18 = 0;
  }
  else
  {
    v18 = operator new(4 * v16);
    v13 = v60;
    v10 = v61;
    __p = v18;
    v74 = v18;
    v76 = v16;
    v17 = (float *)v18;
  }
  v19 = v17 + 1;
  v20 = (uint64_t)&v17[*((int *)v10 + 5) + 1];
  v21 = (uint64_t)&v17[v11 + 1];
  v72[0] = v17;
  v72[1] = v17 + 1;
  v22 = v20 + 4 * v11;
  v72[2] = v20;
  memset(&v72[3], 0, 13);
  v54 = &v17[v11 + v11];
  v55 = &v17[v11];
  v71[0] = v55;
  v71[1] = v21;
  v71[2] = v22;
  memset(&v71[3], 0, 13);
  v69[0] = v54;
  v69[1] = v21 + 4 * v11;
  v69[2] = v22 + 4 * v11;
  v70[0] = 0;
  *(_QWORD *)((char *)v70 + 5) = 0;
  v64[0] = v10;
  v64[1] = v10;
  if (*((int *)v10 + 2) >= 1)
  {
    v23 = 0;
    v24 = 0uLL;
    v58 = (uint64_t)&v17[v11 + 1];
    v59 = v17;
    v57 = v21 + 4 * v11;
    v56 = v22 + 4 * v11;
    do
    {
      v25 = *(unsigned __int16 *)(v10[54] + 2 * v23);
      if ((v25 & 0x800) != 0 || (v26 = v10[42], (v27 = *(_DWORD *)(v26 + 8 * v23)) == 0))
      {
        *(_OWORD *)(*a3 + 16 * v23) = v24;
        *(float32x4_t *)(*a3 + 16 * v23) = vaddq_f32(*(float32x4_t *)(*a2 + 16 * v23), *(float32x4_t *)(*a3 + 16 * v23));
        if ((v13 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v23) = v24;
          *(_OWORD *)(*a5 + 16 * v23) = v24;
        }
      }
      else
      {
        v28 = (2 * v23) | 1;
        v62 = *(int *)(v26 + 4 * v28);
        v63 = v10[45];
        v65 = v23;
        v66 = v23;
        v29 = (v25 >> 7) & 0xF;
        v67 = *(_DWORD *)(*(_QWORD *)(v64[0] + 336) + 8 * v23);
        v68 = *(_DWORD *)(*(_QWORD *)(v64[0] + 264) + 8 * v23);
        if ((v13 & 1) != 0)
          sub_1B19391D4((uint64_t)&v73, (unsigned int *)v64, (uint64_t)v72, v29);
        else
          sub_1B1938E50((uint64_t)&v73, (int *)v64, (uint64_t)v72, (uint64_t)v71, (uint64_t)v69, v29);
        v30 = v79;
        v10 = v61;
        v24 = 0uLL;
        if (v27 >= 1)
        {
          v31 = (int *)(v63 + 4 * v62);
          v32 = v61[15];
          v33 = v27;
          v34 = v79;
          do
          {
            v35 = *v31++;
            *(_DWORD *)v34 = *(_DWORD *)(v32 + 8 * v35 + 4 * (v23 == *(_DWORD *)(v32 + 8 * v35)));
            v34 = (uint64_t *)((char *)v34 + 4);
            --v33;
          }
          while (v33);
        }
        v36 = (char *)v30 + 4 * v27;
        v13 = v60;
        if (LODWORD(v72[4]) || (!LODWORD(v71[4]) ? (v37 = 1) : (v37 = v60), (v37 & 1) == 0))
        {
          v38 = v61[33];
          v39 = *(unsigned int *)(v38 + 8 * v23);
          if ((int)v39 >= 1)
          {
            v40 = *(int *)(v38 + 4 * v28);
            v41 = (int *)(v61[36] + 4 * v40);
            v42 = (_WORD *)(v61[39] + 2 * v40);
            v43 = v61[3];
            v44 = v61[6];
            v45 = (_DWORD *)v30 + v27;
            do
            {
              v46 = *v41++;
              v47 = v44 + 4 * *(int *)(v43 + 8 * v46 + 4);
              v48 = *(_DWORD *)(v43 + 8 * (_DWORD)v46);
              LOWORD(v46) = *v42++;
              v49 = v46 + 2;
              if (v48 > (unsigned __int16)(v46 + 2))
                LOWORD(v48) = 0;
              *v45++ = *(_DWORD *)(v47 + 4 * (unsigned __int16)(v49 - v48));
              --v39;
            }
            while (v39);
          }
        }
        *(_OWORD *)(*a3 + 16 * v23) = 0uLL;
        if (SLODWORD(v72[4]) >= 1)
        {
          v50 = 0;
          do
          {
            *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v50]), *(float *)(v20 + 4 * v50));
            ++v50;
          }
          while (v50 < SLODWORD(v72[4]));
        }
        if (SHIDWORD(v72[3]) >= 1)
        {
          v51 = 0;
          do
          {
            *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v51)), *(float *)&v19[4 * v51]);
            ++v51;
          }
          while (v51 < SHIDWORD(v72[3]));
        }
        *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v59);
        if ((v60 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v23) = 0uLL;
          *(_OWORD *)(*a5 + 16 * v23) = 0uLL;
          if (SLODWORD(v71[4]) >= 1)
          {
            v52 = 0;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v52]), *(float *)(v20 + 4 * v11 + 4 * v52));
              *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v52]), *(float *)(v56 + 4 * v52));
              ++v52;
            }
            while (v52 < SLODWORD(v71[4]));
          }
          if (SHIDWORD(v71[3]) >= 1)
          {
            v53 = 0;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v53)), *(float *)(v58 + 4 * v53));
              *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v53)), *(float *)(v57 + 4 * v53));
              ++v53;
            }
            while (v53 < SHIDWORD(v71[3]));
          }
          *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v55);
          *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v54);
        }
      }
      ++v23;
    }
    while (v23 < *((int *)v10 + 2));
    v18 = __p;
  }
  operator delete(v18);
  operator delete(v83);
}

void sub_1B193AA94(uint64_t *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  BOOL v12;
  char v13;
  int v14;
  void *v15;
  unsigned int v16;
  float *v17;
  void *v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t *v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char *v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  _WORD *v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  __int16 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  float *v54;
  float *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  float *v59;
  char v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD v64[2];
  int v65;
  int v66;
  int v67;
  int v68;
  _QWORD v69[3];
  _QWORD v70[2];
  _QWORD v71[5];
  _QWORD v72[5];
  int v73;
  _BYTE *v74;
  unsigned int v75;
  int v76;
  _BYTE v77[400];
  void *__p;
  uint64_t *v79;
  int v80;
  int v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v9 = *a1;
  v73 = *(_DWORD *)(*a1 + 4);
  v10 = *(_QWORD **)(*(_QWORD *)(v9 + 40) + 8 * (((unint64_t)*(unsigned __int8 *)(v9 + 8) >> 2) & 0xF));
  v11 = (2 * *((int *)v10 + 5)) | 1;
  if (a4)
    v12 = a5 == 0;
  else
    v12 = 1;
  v13 = v12;
  if (v12)
    v14 = 1;
  else
    v14 = 3;
  v79 = &v82;
  v80 = v11;
  v81 = 33;
  v83 = 0;
  v61 = v10;
  v60 = v13;
  if (v11 >= 0x22)
  {
    v15 = operator new(4 * v11);
    v13 = v60;
    v10 = v61;
    v83 = v15;
    v79 = (uint64_t *)v15;
    v81 = v11;
  }
  v16 = v11 * v14;
  v17 = (float *)v77;
  v74 = v77;
  v75 = v16;
  v76 = 99;
  __p = 0;
  if (v16 < 0x64)
  {
    v18 = 0;
  }
  else
  {
    v18 = operator new(4 * v16);
    v13 = v60;
    v10 = v61;
    __p = v18;
    v74 = v18;
    v76 = v16;
    v17 = (float *)v18;
  }
  v19 = v17 + 1;
  v20 = (uint64_t)&v17[*((int *)v10 + 5) + 1];
  v21 = (uint64_t)&v17[v11 + 1];
  v72[0] = v17;
  v72[1] = v17 + 1;
  v22 = v20 + 4 * v11;
  v72[2] = v20;
  memset(&v72[3], 0, 13);
  v54 = &v17[v11 + v11];
  v55 = &v17[v11];
  v71[0] = v55;
  v71[1] = v21;
  v71[2] = v22;
  memset(&v71[3], 0, 13);
  v69[0] = v54;
  v69[1] = v21 + 4 * v11;
  v69[2] = v22 + 4 * v11;
  v70[0] = 0;
  *(_QWORD *)((char *)v70 + 5) = 0;
  v64[0] = v10;
  v64[1] = v10;
  if (*((int *)v10 + 2) >= 1)
  {
    v23 = 0;
    v24 = 0uLL;
    v58 = (uint64_t)&v17[v11 + 1];
    v59 = v17;
    v57 = v21 + 4 * v11;
    v56 = v22 + 4 * v11;
    do
    {
      v25 = *(unsigned __int16 *)(v10[54] + 2 * v23);
      if ((v25 & 0x800) != 0 || (v26 = v10[42], (v27 = *(_DWORD *)(v26 + 8 * v23)) == 0))
      {
        *(_OWORD *)(*a3 + 16 * v23) = v24;
        *(float32x4_t *)(*a3 + 16 * v23) = vaddq_f32(*(float32x4_t *)(*a2 + 16 * v23), *(float32x4_t *)(*a3 + 16 * v23));
        if ((v13 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v23) = v24;
          *(_OWORD *)(*a5 + 16 * v23) = v24;
        }
      }
      else
      {
        v28 = (2 * v23) | 1;
        v62 = *(int *)(v26 + 4 * v28);
        v63 = v10[45];
        v65 = v23;
        v66 = v23;
        v29 = (v25 >> 7) & 0xF;
        v67 = *(_DWORD *)(*(_QWORD *)(v64[0] + 336) + 8 * v23);
        v68 = *(_DWORD *)(*(_QWORD *)(v64[0] + 264) + 8 * v23);
        if ((v13 & 1) != 0)
          sub_1B1939D48((uint64_t)&v73, (unsigned int *)v64, (uint64_t)v72, v29);
        else
          sub_1B1939940((uint64_t)&v73, (int *)v64, (uint64_t)v72, (uint64_t)v71, (uint64_t)v69, v29);
        v30 = v79;
        v10 = v61;
        v24 = 0uLL;
        if (v27 >= 1)
        {
          v31 = (int *)(v63 + 4 * v62);
          v32 = v61[15];
          v33 = v27;
          v34 = v79;
          do
          {
            v35 = *v31++;
            *(_DWORD *)v34 = *(_DWORD *)(v32 + 8 * v35 + 4 * (v23 == *(_DWORD *)(v32 + 8 * v35)));
            v34 = (uint64_t *)((char *)v34 + 4);
            --v33;
          }
          while (v33);
        }
        v36 = (char *)v30 + 4 * v27;
        v13 = v60;
        if (LODWORD(v72[4]) || (!LODWORD(v71[4]) ? (v37 = 1) : (v37 = v60), (v37 & 1) == 0))
        {
          v38 = v61[33];
          v39 = *(unsigned int *)(v38 + 8 * v23);
          if ((int)v39 >= 1)
          {
            v40 = *(int *)(v38 + 4 * v28);
            v41 = (int *)(v61[36] + 4 * v40);
            v42 = (_WORD *)(v61[39] + 2 * v40);
            v43 = v61[3];
            v44 = v61[6];
            v45 = (_DWORD *)v30 + v27;
            do
            {
              v46 = *v41++;
              v47 = v44 + 4 * *(int *)(v43 + 8 * v46 + 4);
              v48 = *(_DWORD *)(v43 + 8 * (_DWORD)v46);
              LOWORD(v46) = *v42++;
              v49 = v46 + 2;
              if (v48 > (unsigned __int16)(v46 + 2))
                LOWORD(v48) = 0;
              *v45++ = *(_DWORD *)(v47 + 4 * (unsigned __int16)(v49 - v48));
              --v39;
            }
            while (v39);
          }
        }
        *(_OWORD *)(*a3 + 16 * v23) = 0uLL;
        if (SLODWORD(v72[4]) >= 1)
        {
          v50 = 0;
          do
          {
            *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v50]), *(float *)(v20 + 4 * v50));
            ++v50;
          }
          while (v50 < SLODWORD(v72[4]));
        }
        if (SHIDWORD(v72[3]) >= 1)
        {
          v51 = 0;
          do
          {
            *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v51)), *(float *)&v19[4 * v51]);
            ++v51;
          }
          while (v51 < SHIDWORD(v72[3]));
        }
        *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v59);
        if ((v60 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v23) = 0uLL;
          *(_OWORD *)(*a5 + 16 * v23) = 0uLL;
          if (SLODWORD(v71[4]) >= 1)
          {
            v52 = 0;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v52]), *(float *)(v20 + 4 * v11 + 4 * v52));
              *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v52]), *(float *)(v56 + 4 * v52));
              ++v52;
            }
            while (v52 < SLODWORD(v71[4]));
          }
          if (SHIDWORD(v71[3]) >= 1)
          {
            v53 = 0;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v53)), *(float *)(v58 + 4 * v53));
              *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v53)), *(float *)(v57 + 4 * v53));
              ++v53;
            }
            while (v53 < SHIDWORD(v71[3]));
          }
          *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v55);
          *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v54);
        }
      }
      ++v23;
    }
    while (v23 < *((int *)v10 + 2));
    v18 = __p;
  }
  operator delete(v18);
  operator delete(v83);
}

void sub_1B193AFD4(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  char v12;
  int v13;
  unsigned int v14;
  float *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  float *v20;
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  int *v26;
  int *v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  float *v32;
  float *v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *__p;
  int *v39;
  int v40;
  int v41;
  uint64_t v42;
  int *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 40)
                 + 8 * (((unint64_t)*(unsigned __int8 *)(*(_QWORD *)a1 + 8) >> 2) & 0xF));
  v10 = (2 * *(int *)(v9 + 20)) | 1;
  if (a4)
    v11 = a5 == 0;
  else
    v11 = 1;
  v12 = v11;
  if (v11)
    v13 = 1;
  else
    v13 = 3;
  v39 = (int *)&v42;
  v40 = v10;
  v41 = 33;
  v43 = 0;
  if (v10 >= 0x22)
  {
    v43 = (int *)operator new(4 * v10);
    v39 = v43;
    v41 = v10;
  }
  v14 = v10 * v13;
  v15 = (float *)&v37;
  __p = 0;
  if (v14 < 0x64)
  {
    v16 = 0;
  }
  else
  {
    v16 = operator new(4 * v14);
    __p = v16;
    v15 = (float *)v16;
  }
  if (*(int *)(v9 + 8) >= 1)
  {
    v17 = 0;
    v18 = 0;
    v19 = &v15[v10];
    v20 = &v19[v10];
    do
    {
      if ((*(_WORD *)(*(_QWORD *)(v9 + 432) + 2 * v17) & 0x800) != 0
        || (v21 = (unsigned int *)(*(_QWORD *)(v9 + 336) + 8 * v17), v22 = *v21, !(_DWORD)v22))
      {
        *(_OWORD *)(*a3 + 16 * v17) = 0uLL;
        *(float32x4_t *)(*a3 + 16 * v17) = vaddq_f32(*(float32x4_t *)(*a2 + 16 * v17), *(float32x4_t *)(*a3 + 16 * v17));
        if ((v12 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v17) = 0uLL;
          *(_OWORD *)(*a5 + 16 * v17) = 0uLL;
        }
      }
      else
      {
        v23 = *(_QWORD *)(v9 + 360);
        v24 = (int)v21[1];
        v25 = v15;
        if ((v12 & 1) == 0)
        {
          *v15 = 1.0;
          *(_QWORD *)v19 = 0x3F800000BF800000;
          v19[2] = 0.0;
          v25 = &v19[v10 + 2];
          v18 = 2;
          *(_QWORD *)v20 = 3212836864;
        }
        *v25 = 1.0;
        v26 = v39;
        if ((int)v22 >= 1)
        {
          v27 = (int *)(v23 + 4 * v24);
          v28 = *(_QWORD *)(v9 + 120);
          v29 = v39;
          do
          {
            v30 = *v27++;
            *v29++ = *(_DWORD *)(v28 + 8 * v30 + 4 * (v17 == *(_DWORD *)(v28 + 8 * v30)));
            --v22;
          }
          while (v22);
        }
        *(_OWORD *)(*a3 + 16 * v17) = 0uLL;
        *(float32x4_t *)(*a3 + 16 * v17) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v17), *(float32x4_t *)(*a2 + 16 * v17), *v15);
        if ((v12 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v17) = 0uLL;
          *(_OWORD *)(*a5 + 16 * v17) = 0uLL;
          v31 = v18;
          v32 = v19 + 1;
          v33 = &v19[v10 + 1];
          if ((int)v18 >= 1)
          {
            do
            {
              v34 = *v32++;
              *(float32x4_t *)(*a4 + 16 * v17) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v17), *(float32x4_t *)(*a2 + 16 * *v26), v34);
              v36 = *v26++;
              v35 = v36;
              *(float *)&v36 = *v33++;
              *(float32x4_t *)(*a5 + 16 * v17) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v17), *(float32x4_t *)(*a2 + 16 * v35), *(float *)&v36);
              --v31;
            }
            while (v31);
          }
          *(float32x4_t *)(*a4 + 16 * v17) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v17), *(float32x4_t *)(*a2 + 16 * v17), *v19);
          *(float32x4_t *)(*a5 + 16 * v17) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v17), *(float32x4_t *)(*a2 + 16 * v17), *v20);
        }
      }
      ++v17;
    }
    while (v17 < *(int *)(v9 + 8));
    v16 = __p;
  }
  operator delete(v16);
  operator delete(v43);
}

uint64_t sub_1B193B2E8(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, void **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  malloc_type_id_t v39;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  const UInt8 *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const UInt8 *v50;
  uint64_t v51;
  uint64_t v52;
  CFDataRef v53;
  uint64_t v54;
  BOOL v55;
  char v56;
  BOOL *v57;
  BOOL *v58;
  char *v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  char *v64;
  BOOL *v65;
  char *v66;
  char *v67;
  char *v68;
  __int128 v69;
  uint64_t v71;

  v10 = a3;
  sub_1B17ED6C4(a4, (uint64_t)a2, a3, a4, (uint64_t)a5, a6, a7, a8);
  v14 = v13;
  v15 = BYTE4(v13);
  v22 = sub_1B179E250(BYTE4(v13), v13, v16, v17, v18, v19, v20, v21);
  v37 = sub_1B17ED7B4(a4, v23, v24, v25, v26, v27, v28, v29);
  if (v37 || HIBYTE(v14) >= 3 && (sub_1B179E6DC(BYTE6(v14), v30, v31, v32, v33, v34, v35, v36) & 1) != 0)
  {
    v71 = a4;
    if (v10)
    {
      v38 = sub_1B22138D4(*a2, *(unsigned __int8 *)(a1 + 72));
      v39 = 1175024481;
    }
    else
    {
      v38 = *(_DWORD *)(*a2 + 8);
      v39 = 995483109;
    }
    v41 = v38;
    v42 = v22 * v38;
    v43 = (const UInt8 *)malloc_type_malloc(v42, v39);
    v50 = v43;
    if (v38 >= 1)
    {
      v51 = 0;
      v52 = (uint64_t)v43;
      do
      {
        sub_1B198D91C(v15, v52, v44, v45, v46, v47, v48, v49, *(float32x4_t *)(*(_QWORD *)(a1 + 48) + v51));
        v52 += (unsigned __int16)v22;
        v51 += 16;
      }
      while (16 * v41 != v51);
    }
    v53 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v50, v42, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
    v40 = sub_1B17ED264(v37, v53, v15, 1, v41, v22, 0, v54);
    CFRelease(v53);
    v55 = *(_BYTE *)(a1 + 88) == 2;
    v56 = *(_BYTE *)(a1 + 72);
    v57 = (BOOL *)a5[2];
    v58 = (BOOL *)a5[1];
    if (v58 >= v57)
    {
      v60 = 0xAAAAAAAAAAAAAAABLL * ((v58 - (_BYTE *)*a5) >> 3);
      v61 = v60 + 1;
      if (v60 + 1 > 0xAAAAAAAAAAAAAAALL)
        abort();
      v62 = 0xAAAAAAAAAAAAAAABLL * ((v57 - (_BYTE *)*a5) >> 3);
      if (2 * v62 > v61)
        v61 = 2 * v62;
      if (v62 >= 0x555555555555555)
        v63 = 0xAAAAAAAAAAAAAAALL;
      else
        v63 = v61;
      if (v63)
        v64 = (char *)sub_1B17F7D88((uint64_t)(a5 + 2), v63);
      else
        v64 = 0;
      v65 = (BOOL *)&v64[24 * v60];
      v66 = &v64[24 * v63];
      *v65 = v55;
      v65[1] = v56;
      *(_DWORD *)(v65 + 2) = 0;
      *((_WORD *)v65 + 3) = 0;
      *((_QWORD *)v65 + 1) = v71;
      *((_QWORD *)v65 + 2) = v40;
      v59 = (char *)(v65 + 24);
      v68 = (char *)*a5;
      v67 = (char *)a5[1];
      if (v67 != *a5)
      {
        do
        {
          v69 = *(_OWORD *)(v67 - 24);
          *((_QWORD *)v65 - 1) = *((_QWORD *)v67 - 1);
          *(_OWORD *)(v65 - 24) = v69;
          v65 -= 24;
          v67 -= 24;
        }
        while (v67 != v68);
        v67 = (char *)*a5;
      }
      *a5 = v65;
      a5[1] = v59;
      a5[2] = v66;
      if (v67)
        operator delete(v67);
    }
    else
    {
      *v58 = v55;
      v58[1] = v56;
      *(_DWORD *)(v58 + 2) = 0;
      *((_WORD *)v58 + 3) = 0;
      v59 = (char *)(v58 + 24);
      *((_QWORD *)v58 + 1) = v71;
      *((_QWORD *)v58 + 2) = v40;
    }
    a5[1] = v59;
  }
  else
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Position must be float3 to be subdivided. Actual type is %d"), v31, v32, v33, v34, v35, v36, BYTE4(v14));
    return 0;
  }
  return v40;
}

void sub_1B193B5B0(uint64_t *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  BOOL v12;
  char v13;
  int v14;
  void *v15;
  unsigned int v16;
  float *v17;
  void *v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  _QWORD *v29;
  uint64_t *v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char *v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  _WORD *v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  __int16 v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  float *v55;
  float *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  float *v60;
  char v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD v65[2];
  int v66;
  int v67;
  int v68;
  int v69;
  _QWORD v70[3];
  _QWORD v71[2];
  _QWORD v72[5];
  _QWORD v73[5];
  int v74;
  _BYTE *v75;
  unsigned int v76;
  int v77;
  _BYTE v78[400];
  void *__p;
  uint64_t *v80;
  int v81;
  int v82;
  uint64_t v83;
  void *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v9 = *a1;
  v74 = *(_DWORD *)(*a1 + 4);
  v10 = *(_QWORD **)(*(_QWORD *)(v9 + 40) + 8 * (((unint64_t)*(unsigned __int8 *)(v9 + 8) >> 2) & 0xF));
  v11 = (2 * *((int *)v10 + 5)) | 1;
  if (a4)
    v12 = a5 == 0;
  else
    v12 = 1;
  v13 = v12;
  if (v12)
    v14 = 1;
  else
    v14 = 3;
  v80 = &v83;
  v81 = v11;
  v82 = 33;
  v84 = 0;
  v62 = v10;
  v61 = v13;
  if (v11 >= 0x22)
  {
    v15 = operator new(4 * v11);
    v13 = v61;
    v10 = v62;
    v84 = v15;
    v80 = (uint64_t *)v15;
    v82 = v11;
  }
  v16 = v11 * v14;
  v17 = (float *)v78;
  v75 = v78;
  v76 = v16;
  v77 = 99;
  __p = 0;
  if (v16 < 0x64)
  {
    v18 = 0;
  }
  else
  {
    v18 = operator new(4 * v16);
    v13 = v61;
    v10 = v62;
    __p = v18;
    v75 = v18;
    v77 = v16;
    v17 = (float *)v18;
  }
  v19 = v17 + 1;
  v20 = (uint64_t)&v17[*((int *)v10 + 5) + 1];
  v21 = (uint64_t)&v17[v11 + 1];
  v73[0] = v17;
  v73[1] = v17 + 1;
  v22 = v20 + 4 * v11;
  v73[2] = v20;
  memset(&v73[3], 0, 13);
  v55 = &v17[v11 + v11];
  v56 = &v17[v11];
  v72[0] = v56;
  v72[1] = v21;
  v72[2] = v22;
  memset(&v72[3], 0, 13);
  v70[0] = v55;
  v70[1] = v21 + 4 * v11;
  v70[2] = v22 + 4 * v11;
  v71[0] = 0;
  *(_QWORD *)((char *)v71 + 5) = 0;
  v65[0] = v10;
  v65[1] = v10;
  if (*((int *)v10 + 2) >= 1)
  {
    v23 = 0;
    v59 = (uint64_t)&v17[v11 + 1];
    v60 = v17;
    v58 = v21 + 4 * v11;
    v57 = v22 + 4 * v11;
    do
    {
      v24 = *(unsigned __int16 *)(v10[54] + 2 * v23);
      if ((v24 & 0x800) != 0 || (v25 = v10[42], (v26 = *(_DWORD *)(v25 + 8 * v23)) == 0))
      {
        v29 = (_QWORD *)(*a3 + 16 * v23);
        *v29 = 0;
        v29[1] = 0;
        *(float32x4_t *)(*a3 + 16 * v23) = vaddq_f32(*(float32x4_t *)(*a2 + 16 * v23), *(float32x4_t *)(*a3 + 16 * v23));
        if ((v13 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v23) = 0u;
          *(_OWORD *)(*a5 + 16 * v23) = 0u;
        }
      }
      else
      {
        v27 = (2 * v23) | 1;
        v63 = *(int *)(v25 + 4 * v27);
        v64 = v10[45];
        v66 = v23;
        v67 = v23;
        v28 = (v24 >> 7) & 0xF;
        v68 = *(_DWORD *)(*(_QWORD *)(v65[0] + 336) + 8 * v23);
        v69 = *(_DWORD *)(*(_QWORD *)(v65[0] + 264) + 8 * v23);
        if ((v13 & 1) != 0)
          sub_1B19391D4((uint64_t)&v74, (unsigned int *)v65, (uint64_t)v73, v28);
        else
          sub_1B1938E50((uint64_t)&v74, (int *)v65, (uint64_t)v73, (uint64_t)v72, (uint64_t)v70, v28);
        v30 = v80;
        v10 = v62;
        if (v26 >= 1)
        {
          v31 = (int *)(v64 + 4 * v63);
          v32 = v62[15];
          v33 = v26;
          v34 = v80;
          do
          {
            v35 = *v31++;
            *(_DWORD *)v34 = *(_DWORD *)(v32 + 8 * v35 + 4 * (v23 == *(_DWORD *)(v32 + 8 * v35)));
            v34 = (uint64_t *)((char *)v34 + 4);
            --v33;
          }
          while (v33);
        }
        v36 = (char *)v30 + 4 * v26;
        v13 = v61;
        if (LODWORD(v73[4]) || (!LODWORD(v72[4]) ? (v37 = 1) : (v37 = v61), (v37 & 1) == 0))
        {
          v38 = v62[33];
          v39 = *(unsigned int *)(v38 + 8 * v23);
          if ((int)v39 >= 1)
          {
            v40 = *(int *)(v38 + 4 * v27);
            v41 = (int *)(v62[36] + 4 * v40);
            v42 = (_WORD *)(v62[39] + 2 * v40);
            v43 = v62[3];
            v44 = v62[6];
            v45 = (_DWORD *)v30 + v26;
            do
            {
              v46 = *v41++;
              v47 = v44 + 4 * *(int *)(v43 + 8 * v46 + 4);
              v48 = *(_DWORD *)(v43 + 8 * (_DWORD)v46);
              LOWORD(v46) = *v42++;
              v49 = v46 + 2;
              if (v48 > (unsigned __int16)(v46 + 2))
                LOWORD(v48) = 0;
              *v45++ = *(_DWORD *)(v47 + 4 * (unsigned __int16)(v49 - v48));
              --v39;
            }
            while (v39);
          }
        }
        v50 = (_QWORD *)(*a3 + 16 * v23);
        *v50 = 0;
        v50[1] = 0;
        if (SLODWORD(v73[4]) >= 1)
        {
          v51 = 0;
          do
          {
            *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v51]), *(float *)(v20 + 4 * v51));
            ++v51;
          }
          while (v51 < SLODWORD(v73[4]));
        }
        if (SHIDWORD(v73[3]) >= 1)
        {
          v52 = 0;
          do
          {
            *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v52)), *(float *)&v19[4 * v52]);
            ++v52;
          }
          while (v52 < SHIDWORD(v73[3]));
        }
        *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v60);
        if ((v61 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v23) = 0u;
          *(_OWORD *)(*a5 + 16 * v23) = 0u;
          if (SLODWORD(v72[4]) >= 1)
          {
            v53 = 0;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v53]), *(float *)(v20 + 4 * v11 + 4 * v53));
              *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v53]), *(float *)(v57 + 4 * v53));
              ++v53;
            }
            while (v53 < SLODWORD(v72[4]));
          }
          if (SHIDWORD(v72[3]) >= 1)
          {
            v54 = 0;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v54)), *(float *)(v59 + 4 * v54));
              *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v54)), *(float *)(v58 + 4 * v54));
              ++v54;
            }
            while (v54 < SHIDWORD(v72[3]));
          }
          *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v56);
          *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v55);
        }
      }
      ++v23;
    }
    while (v23 < *((int *)v10 + 2));
    v18 = __p;
  }
  operator delete(v18);
  operator delete(v84);
}

void sub_1B193BAF8(uint64_t *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  BOOL v12;
  char v13;
  int v14;
  void *v15;
  unsigned int v16;
  float *v17;
  void *v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  _QWORD *v29;
  uint64_t *v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char *v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  _WORD *v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  __int16 v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  float *v55;
  float *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  float *v60;
  char v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD v65[2];
  int v66;
  int v67;
  int v68;
  int v69;
  _QWORD v70[3];
  _QWORD v71[2];
  _QWORD v72[5];
  _QWORD v73[5];
  int v74;
  _BYTE *v75;
  unsigned int v76;
  int v77;
  _BYTE v78[400];
  void *__p;
  uint64_t *v80;
  int v81;
  int v82;
  uint64_t v83;
  void *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v9 = *a1;
  v74 = *(_DWORD *)(*a1 + 4);
  v10 = *(_QWORD **)(*(_QWORD *)(v9 + 40) + 8 * (((unint64_t)*(unsigned __int8 *)(v9 + 8) >> 2) & 0xF));
  v11 = (2 * *((int *)v10 + 5)) | 1;
  if (a4)
    v12 = a5 == 0;
  else
    v12 = 1;
  v13 = v12;
  if (v12)
    v14 = 1;
  else
    v14 = 3;
  v80 = &v83;
  v81 = v11;
  v82 = 33;
  v84 = 0;
  v62 = v10;
  v61 = v13;
  if (v11 >= 0x22)
  {
    v15 = operator new(4 * v11);
    v13 = v61;
    v10 = v62;
    v84 = v15;
    v80 = (uint64_t *)v15;
    v82 = v11;
  }
  v16 = v11 * v14;
  v17 = (float *)v78;
  v75 = v78;
  v76 = v16;
  v77 = 99;
  __p = 0;
  if (v16 < 0x64)
  {
    v18 = 0;
  }
  else
  {
    v18 = operator new(4 * v16);
    v13 = v61;
    v10 = v62;
    __p = v18;
    v75 = v18;
    v77 = v16;
    v17 = (float *)v18;
  }
  v19 = v17 + 1;
  v20 = (uint64_t)&v17[*((int *)v10 + 5) + 1];
  v21 = (uint64_t)&v17[v11 + 1];
  v73[0] = v17;
  v73[1] = v17 + 1;
  v22 = v20 + 4 * v11;
  v73[2] = v20;
  memset(&v73[3], 0, 13);
  v55 = &v17[v11 + v11];
  v56 = &v17[v11];
  v72[0] = v56;
  v72[1] = v21;
  v72[2] = v22;
  memset(&v72[3], 0, 13);
  v70[0] = v55;
  v70[1] = v21 + 4 * v11;
  v70[2] = v22 + 4 * v11;
  v71[0] = 0;
  *(_QWORD *)((char *)v71 + 5) = 0;
  v65[0] = v10;
  v65[1] = v10;
  if (*((int *)v10 + 2) >= 1)
  {
    v23 = 0;
    v59 = (uint64_t)&v17[v11 + 1];
    v60 = v17;
    v58 = v21 + 4 * v11;
    v57 = v22 + 4 * v11;
    do
    {
      v24 = *(unsigned __int16 *)(v10[54] + 2 * v23);
      if ((v24 & 0x800) != 0 || (v25 = v10[42], (v26 = *(_DWORD *)(v25 + 8 * v23)) == 0))
      {
        v29 = (_QWORD *)(*a3 + 16 * v23);
        *v29 = 0;
        v29[1] = 0;
        *(float32x4_t *)(*a3 + 16 * v23) = vaddq_f32(*(float32x4_t *)(*a2 + 16 * v23), *(float32x4_t *)(*a3 + 16 * v23));
        if ((v13 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v23) = 0u;
          *(_OWORD *)(*a5 + 16 * v23) = 0u;
        }
      }
      else
      {
        v27 = (2 * v23) | 1;
        v63 = *(int *)(v25 + 4 * v27);
        v64 = v10[45];
        v66 = v23;
        v67 = v23;
        v28 = (v24 >> 7) & 0xF;
        v68 = *(_DWORD *)(*(_QWORD *)(v65[0] + 336) + 8 * v23);
        v69 = *(_DWORD *)(*(_QWORD *)(v65[0] + 264) + 8 * v23);
        if ((v13 & 1) != 0)
          sub_1B1939D48((uint64_t)&v74, (unsigned int *)v65, (uint64_t)v73, v28);
        else
          sub_1B1939940((uint64_t)&v74, (int *)v65, (uint64_t)v73, (uint64_t)v72, (uint64_t)v70, v28);
        v30 = v80;
        v10 = v62;
        if (v26 >= 1)
        {
          v31 = (int *)(v64 + 4 * v63);
          v32 = v62[15];
          v33 = v26;
          v34 = v80;
          do
          {
            v35 = *v31++;
            *(_DWORD *)v34 = *(_DWORD *)(v32 + 8 * v35 + 4 * (v23 == *(_DWORD *)(v32 + 8 * v35)));
            v34 = (uint64_t *)((char *)v34 + 4);
            --v33;
          }
          while (v33);
        }
        v36 = (char *)v30 + 4 * v26;
        v13 = v61;
        if (LODWORD(v73[4]) || (!LODWORD(v72[4]) ? (v37 = 1) : (v37 = v61), (v37 & 1) == 0))
        {
          v38 = v62[33];
          v39 = *(unsigned int *)(v38 + 8 * v23);
          if ((int)v39 >= 1)
          {
            v40 = *(int *)(v38 + 4 * v27);
            v41 = (int *)(v62[36] + 4 * v40);
            v42 = (_WORD *)(v62[39] + 2 * v40);
            v43 = v62[3];
            v44 = v62[6];
            v45 = (_DWORD *)v30 + v26;
            do
            {
              v46 = *v41++;
              v47 = v44 + 4 * *(int *)(v43 + 8 * v46 + 4);
              v48 = *(_DWORD *)(v43 + 8 * (_DWORD)v46);
              LOWORD(v46) = *v42++;
              v49 = v46 + 2;
              if (v48 > (unsigned __int16)(v46 + 2))
                LOWORD(v48) = 0;
              *v45++ = *(_DWORD *)(v47 + 4 * (unsigned __int16)(v49 - v48));
              --v39;
            }
            while (v39);
          }
        }
        v50 = (_QWORD *)(*a3 + 16 * v23);
        *v50 = 0;
        v50[1] = 0;
        if (SLODWORD(v73[4]) >= 1)
        {
          v51 = 0;
          do
          {
            *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v51]), *(float *)(v20 + 4 * v51));
            ++v51;
          }
          while (v51 < SLODWORD(v73[4]));
        }
        if (SHIDWORD(v73[3]) >= 1)
        {
          v52 = 0;
          do
          {
            *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v52)), *(float *)&v19[4 * v52]);
            ++v52;
          }
          while (v52 < SHIDWORD(v73[3]));
        }
        *(float32x4_t *)(*a3 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v60);
        if ((v61 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v23) = 0u;
          *(_OWORD *)(*a5 + 16 * v23) = 0u;
          if (SLODWORD(v72[4]) >= 1)
          {
            v53 = 0;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v53]), *(float *)(v20 + 4 * v11 + 4 * v53));
              *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *(int *)&v36[4 * v53]), *(float *)(v57 + 4 * v53));
              ++v53;
            }
            while (v53 < SLODWORD(v72[4]));
          }
          if (SHIDWORD(v72[3]) >= 1)
          {
            v54 = 0;
            do
            {
              *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v54)), *(float *)(v59 + 4 * v54));
              *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * *((int *)v30 + v54)), *(float *)(v58 + 4 * v54));
              ++v54;
            }
            while (v54 < SHIDWORD(v72[3]));
          }
          *(float32x4_t *)(*a4 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v56);
          *(float32x4_t *)(*a5 + 16 * v23) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v23), *(float32x4_t *)(*a2 + 16 * v23), *v55);
        }
      }
      ++v23;
    }
    while (v23 < *((int *)v10 + 2));
    v18 = __p;
  }
  operator delete(v18);
  operator delete(v84);
}

void sub_1B193C040(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  char v12;
  int v13;
  unsigned int v14;
  float *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  float *v20;
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  int *v26;
  int *v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  float *v33;
  float *v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  void *__p;
  int *v41;
  int v42;
  int v43;
  uint64_t v44;
  int *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 40)
                 + 8 * (((unint64_t)*(unsigned __int8 *)(*(_QWORD *)a1 + 8) >> 2) & 0xF));
  v10 = (2 * *(int *)(v9 + 20)) | 1;
  if (a4)
    v11 = a5 == 0;
  else
    v11 = 1;
  v12 = v11;
  if (v11)
    v13 = 1;
  else
    v13 = 3;
  v41 = (int *)&v44;
  v42 = v10;
  v43 = 33;
  v45 = 0;
  if (v10 >= 0x22)
  {
    v45 = (int *)operator new(4 * v10);
    v41 = v45;
    v43 = v10;
  }
  v14 = v10 * v13;
  v15 = (float *)&v39;
  __p = 0;
  if (v14 < 0x64)
  {
    v16 = 0;
  }
  else
  {
    v16 = operator new(4 * v14);
    __p = v16;
    v15 = (float *)v16;
  }
  if (*(int *)(v9 + 8) >= 1)
  {
    v17 = 0;
    v18 = 0;
    v19 = &v15[v10];
    v20 = &v19[v10];
    do
    {
      if ((*(_WORD *)(*(_QWORD *)(v9 + 432) + 2 * v17) & 0x800) != 0
        || (v21 = (unsigned int *)(*(_QWORD *)(v9 + 336) + 8 * v17), v22 = *v21, !(_DWORD)v22))
      {
        v38 = (_QWORD *)(*a3 + 16 * v17);
        *v38 = 0;
        v38[1] = 0;
        *(float32x4_t *)(*a3 + 16 * v17) = vaddq_f32(*(float32x4_t *)(*a2 + 16 * v17), *(float32x4_t *)(*a3 + 16 * v17));
        if ((v12 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v17) = 0uLL;
          *(_OWORD *)(*a5 + 16 * v17) = 0uLL;
        }
      }
      else
      {
        v23 = *(_QWORD *)(v9 + 360);
        v24 = (int)v21[1];
        v25 = v15;
        if ((v12 & 1) == 0)
        {
          *v15 = 1.0;
          *(_QWORD *)v19 = 0x3F800000BF800000;
          v19[2] = 0.0;
          v25 = &v19[v10 + 2];
          v18 = 2;
          *(_QWORD *)v20 = 3212836864;
        }
        *v25 = 1.0;
        v26 = v41;
        if ((int)v22 >= 1)
        {
          v27 = (int *)(v23 + 4 * v24);
          v28 = *(_QWORD *)(v9 + 120);
          v29 = v41;
          do
          {
            v30 = *v27++;
            *v29++ = *(_DWORD *)(v28 + 8 * v30 + 4 * (v17 == *(_DWORD *)(v28 + 8 * v30)));
            --v22;
          }
          while (v22);
        }
        v31 = (_QWORD *)(*a3 + 16 * v17);
        *v31 = 0;
        v31[1] = 0;
        *(float32x4_t *)(*a3 + 16 * v17) = vmlaq_n_f32(*(float32x4_t *)(*a3 + 16 * v17), *(float32x4_t *)(*a2 + 16 * v17), *v15);
        if ((v12 & 1) == 0)
        {
          *(_OWORD *)(*a4 + 16 * v17) = 0uLL;
          *(_OWORD *)(*a5 + 16 * v17) = 0uLL;
          v32 = v18;
          v33 = v19 + 1;
          v34 = &v19[v10 + 1];
          if ((int)v18 >= 1)
          {
            do
            {
              v35 = *v33++;
              *(float32x4_t *)(*a4 + 16 * v17) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v17), *(float32x4_t *)(*a2 + 16 * *v26), v35);
              v37 = *v26++;
              v36 = v37;
              *(float *)&v37 = *v34++;
              *(float32x4_t *)(*a5 + 16 * v17) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v17), *(float32x4_t *)(*a2 + 16 * v36), *(float *)&v37);
              --v32;
            }
            while (v32);
          }
          *(float32x4_t *)(*a4 + 16 * v17) = vmlaq_n_f32(*(float32x4_t *)(*a4 + 16 * v17), *(float32x4_t *)(*a2 + 16 * v17), *v19);
          *(float32x4_t *)(*a5 + 16 * v17) = vmlaq_n_f32(*(float32x4_t *)(*a5 + 16 * v17), *(float32x4_t *)(*a2 + 16 * v17), *v20);
        }
      }
      ++v17;
    }
    while (v17 < *(int *)(v9 + 8));
    v16 = __p;
  }
  operator delete(v16);
  operator delete(v45);
}

_QWORD *sub_1B193C35C(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    sub_1B193A518(a1, v5 >> 4);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

_OWORD *sub_1B193C3C0(uint64_t **a1, float32x4_t *a2, uint64_t a3)
{
  float32x4_t **v5;
  _OWORD *v6;
  uint64_t **v7;
  float32x4_t **v9;

  v5 = sub_1B193C448((uint64_t)a1, &v9, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = operator new(0x40uLL);
    v6[2] = *(_OWORD *)a3;
    *((_DWORD *)v6 + 12) = *(_DWORD *)(a3 + 16);
    sub_1B181D728(a1, (uint64_t)v9, v7, (uint64_t *)v6);
  }
  return v6;
}

float32x4_t **sub_1B193C448(uint64_t a1, float32x4_t ***a2, float32x4_t *a3)
{
  float32x4_t **result;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t v6;
  float32x4_t **v7;
  float32x4_t v8;
  int32x4_t v9;
  uint32x4_t v10;
  int32x4_t v11;
  __int32 v12;
  int32x4_t v14;
  int32x2_t v15;
  BOOL v16;
  int v17;

  v5 = *(float32x4_t **)(a1 + 8);
  result = (float32x4_t **)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    v6 = *a3;
    while (1)
    {
      while (1)
      {
        v7 = (float32x4_t **)v4;
        v8 = v4[2];
        v9 = vceqq_f32(v6, v8);
        v10 = (uint32x4_t)v9;
        v10.i32[3] = v9.i32[2];
        if ((vminvq_u32(v10) & 0x80000000) != 0)
          goto LABEL_28;
        v11 = vcgtq_f32(v8, v6);
        if (!v11.i32[0])
          break;
LABEL_5:
        v4 = *v7;
        result = v7;
        if (!*v7)
          goto LABEL_28;
      }
      if (v9.i32[0])
      {
        if (v11.i32[1])
          goto LABEL_5;
        v12 = v9.i32[1];
        if (v9.i32[1] && v11.i32[2] != 0)
          goto LABEL_5;
        v14 = vcgtq_f32(v6, v8);
        v15 = vceqz_s32(vrev64_s32(*(int32x2_t *)v14.i8));
        if (v12)
          v16 = v14.i32[2] == 0;
        else
          v16 = 1;
        v17 = !v16;
        if ((v15.i8[4] & 1) != 0 && (v15.i8[0] & 1) != 0 && !v17)
          goto LABEL_28;
      }
      else if ((vmovn_s32(vcgtq_f32(v6, v8)).u8[0] & 1) == 0)
      {
        goto LABEL_28;
      }
      result = v7 + 1;
      v4 = v7[1];
      if (!v4)
        goto LABEL_28;
    }
  }
  v7 = result;
LABEL_28:
  *a2 = v7;
  return result;
}

uint64_t sub_1B193C514(uint64_t a1, int *a2, uint64_t a3, char a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (sub_1B222402C(a1, a2)
    && sub_1B220F3E8(a1, v7, v8, v9, v10, v11, v12, v13)
    && sub_1B2224170(a1, (uint64_t)a2)
    && sub_1B220F58C(a1, a4 & 1, (void (*)(uint64_t, char *, uint64_t))sub_1B2224420, (uint64_t)a2, v14, v15, v16, v17)&& sub_1B2224224(a1, (uint64_t)a2)&& sub_1B220F660(a1)&& sub_1B2224448(a1, (uint64_t)a2))
  {
    return sub_1B220FAF0(a1);
  }
  else
  {
    return 0;
  }
}

__CFDictionary *sub_1B193C5C4(CFDictionaryRef theDict, const __CFURL *a2)
{
  const __CFAllocator *v3;
  const __CFDictionary *MutableCopy;
  __CFDictionary *v5;
  const __CFArray *Value;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v8;
  CFStringRef v9;
  CFURLRef PathComponent;
  CFURLRef v11;
  CFRange v13;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (theDict)
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theDict);
  else
    MutableCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = MutableCopy;
  Value = (const __CFArray *)CFDictionaryGetValue(MutableCopy, CFSTR("kWorldSourceAssetDirectoryURLs"));
  if (Value)
    Mutable = CFArrayCreateMutableCopy(v3, 0, Value);
  else
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v8 = Mutable;
  CFDictionarySetValue(v5, CFSTR("kWorldSourceAssetDirectoryURLs"), Mutable);
  CFRelease(v8);
  v9 = CFURLCopyScheme(a2);
  PathComponent = CFURLCreateCopyDeletingLastPathComponent(0, a2);
  if (PathComponent)
  {
    v11 = PathComponent;
    CFDictionarySetValue(v5, CFSTR("kEnclosingDirectoryURL"), PathComponent);
    v13.length = CFArrayGetCount(v8);
    v13.location = 0;
    if (!CFArrayContainsValue(v8, v13, v11))
      CFArrayAppendValue(v8, v11);
    CFRelease(v11);
  }
  if (v9)
    CFRelease(v9);
  return v5;
}

void sub_1B193D334(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void **sub_1B193D354(uint64_t a1)
{
  void **result;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = (void **)objc_loadWeak((id *)(a1 + 32));
  if (result)
  {
    v5 = result;
    v6 = objc_msgSend_currentDrawable(result[1], v2, v3, v4);
    v10 = objc_msgSend_currentRenderPassDescriptor(v5[1], v7, v8, v9);
    return (void **)MEMORY[0x1E0DE7D20](v5, sel__drawInRenderingQueueWithDrawable_renderPassDescriptor_, v6, v10);
  }
  return result;
}

id sub_1B193E38C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;
  const void *v10;
  const void *v11;

  sub_1B193E3E4((void *)a1, a2, a3, a4, a5, a6, a7, a8);
  v9 = *(const void **)(a1 + 40);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v10 = *(const void **)(a1 + 24);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v11 = *(const void **)(a1 + 32);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 32) = 0;
  }
  return objc_storeWeak((id *)(a1 + 16), 0);
}

void sub_1B193E3E4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFDictionary *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  v9 = sub_1B17C61FC((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  v17 = v9;
  if (v9)
  {
    v18 = sub_1B187A97C(v9, v10, v11, v12, v13, v14, v15, v16);
    if (v18)
      sub_1B17F37B4(v18, a1, v19, v12, v13, v14, v15, v16);
  }
  v20 = sub_1B193EF6C((uint64_t)a1, CFSTR("kAnimationsKey"), 0, v12, v13, v14, v15, v16);
  if (v20)
  {
    sub_1B18C00E8((uint64_t)v20, (uint64_t)sub_1B193F2A4, v17);
    sub_1B193E88C((CFTypeRef *)a1, CFSTR("kAnimationsKey"), 0, 1, v21, v22, v23, v24);
  }
}

void sub_1B193E4A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: _CFXEntityCFInit"), a3, a4, a5, a6, a7, a8, a9);
}

void sub_1B193E4B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1B17C4408(16, (uint64_t)CFSTR("Unreachable code: _CFXEntityCFFinalize"), a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sub_1B193E4C8()
{
  if (qword_1ED4CEC48 != -1)
    dispatch_once(&qword_1ED4CEC48, &unk_1E63D1270);
  return qword_1ED4CEC50;
}

double sub_1B193E508()
{
  double result;

  if (!qword_1ED4CEC50)
  {
    qword_1ED4CEC50 = sub_1B179CB60(&qword_1ED4CEC50);
    *(_QWORD *)&result = 0x1B193FF88;
    unk_1ED4BDD28 = xmmword_1E63D2EE0;
    unk_1ED4BDD38 = *(_OWORD *)off_1E63D2EF0;
    qword_1ED4BDD48 = 0;
  }
  return result;
}

uint64_t sub_1B193E568(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  return *(_QWORD *)(a1 + 32);
}

CFStringRef sub_1B193E5B0(uint64_t a1, CFStringRef theString, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  result = *(CFStringRef *)(a1 + 32);
  if (result != theString)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 32) = 0;
    }
    if (theString)
      result = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theString);
    else
      result = 0;
    *(_QWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t sub_1B193E634(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  return *(_QWORD *)(a1 + 24);
}

id sub_1B193E67C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id result;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  result = *(id *)(a1 + 24);
  if (!result)
  {
    v10 = (void *)objc_msgSend_UUID(MEMORY[0x1E0CB3A28], a2, a3, a4);
    result = (id)objc_msgSend_UUIDString(v10, v11, v12, v13);
    *(_QWORD *)(a1 + 24) = result;
  }
  return result;
}

CFTypeRef sub_1B193E6E0(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  result = *(CFTypeRef *)(a1 + 24);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 24) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 24) = result;
  }
  return result;
}

id *sub_1B193E758(id *result)
{
  if (result)
    return (id *)objc_loadWeak(result + 2);
  return result;
}

id sub_1B193E768(uint64_t a1, id obj, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  return objc_storeWeak((id *)(a1 + 16), obj);
}

uint64_t sub_1B193E7B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  return *(_QWORD *)(a1 + 40);
}

const __CFDictionary *sub_1B193E800(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *result;

  if (a1)
  {
    if (key)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
    if (key)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"name");
LABEL_3:
  result = *(const __CFDictionary **)(a1 + 40);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, key);
  return result;
}

void sub_1B193E88C(CFTypeRef *a1, void *key, const __CFDictionary *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  __CFDictionary *Mutable;

  v8 = a4;
  if (a1)
  {
    if (key)
      goto LABEL_4;
    goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  if (!key)
LABEL_3:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"name");
LABEL_4:
  if (sub_1B193E800((uint64_t)a1, key, (uint64_t)a3, a4, a5, a6, a7, a8) == a3)
    return;
  Mutable = (__CFDictionary *)a1[5];
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    a1[5] = Mutable;
  }
  if (!a3)
  {
    CFDictionaryRemoveValue(Mutable, key);
    if (CFDictionaryGetCount((CFDictionaryRef)a1[5]))
    {
      if (!v8)
        return;
    }
    else
    {
      CFRelease(a1[5]);
      a1[5] = 0;
      if (!v8)
        return;
    }
LABEL_14:
    sub_1B194F874(CFSTR("kCFXNotificationEntityAttributeDidChange"), a1, (const __CFDictionary *)key, 1u);
    return;
  }
  CFDictionarySetValue(Mutable, key, a3);
  if (v8)
    goto LABEL_14;
}

void sub_1B193E9B8(CFTypeRef *a1, void *a2, const __CFDictionary *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B193E88C(a1, a2, a3, 1, a5, a6, a7, a8);
}

const __CFDictionary *sub_1B193E9C0(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *result;

  if (a1)
  {
    if (key)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
    if (key)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"name");
LABEL_3:
  result = *(const __CFDictionary **)(a1 + 40);
  if (result)
    return (const __CFDictionary *)(CFDictionaryContainsKey(result, key) != 0);
  return result;
}

void sub_1B193EA48(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v10;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  v10 = *(const void **)(a1 + 40);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 40) = 0;
  }
  if (theDict)
  {
    if (CFDictionaryGetCount(theDict))
      *(_QWORD *)(a1 + 40) = CFDictionaryCreateMutableCopy(0, 0, theDict);
  }
}

void sub_1B193EAC4(uint64_t a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if (a1)
  {
    if (a2)
      goto LABEL_3;
LABEL_6:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"dst");
    if (a1)
      goto LABEL_4;
LABEL_7:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
    goto LABEL_4;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"src");
  if (!a2)
    goto LABEL_6;
LABEL_3:
  if (!a1)
    goto LABEL_7;
LABEL_4:
  sub_1B193E5B0((uint64_t)a2, *(CFStringRef *)(a1 + 32), a3, a4, a5, a6, a7, a8);
  sub_1B193EA48((uint64_t)a2, *(CFDictionaryRef *)(a1 + 40), v10, v11, v12, v13, v14, v15);
  sub_1B193E88C(a2, CFSTR("_kvc"), 0, 1, v16, v17, v18, v19);
  sub_1B193E88C(a2, CFSTR("kAnimationsKey"), 0, 1, v20, v21, v22, v23);
}

const void *sub_1B193EBA0(const void *result)
{
  const void *v1;

  if (result)
  {
    v1 = (const void *)CFGetTypeID(result);
    if (qword_1ED4CEA88 != -1)
      dispatch_once(&qword_1ED4CEA88, &unk_1E63D98C8);
    return (const void *)(CFDictionaryGetValue((CFDictionaryRef)qword_1ED4CEA80, v1) != 0);
  }
  return result;
}

CFDictionaryRef sub_1B193EC04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;
  uint64_t v9;
  int64x2_t v10;
  CFDictionaryRef result;
  void *values[2];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  void *keys[53];

  keys[52] = *(void **)MEMORY[0x1E0C80C00];
  if (qword_1ED4CEA80)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. CFTypeIsCFXEntity - dispatched twice"), a3, a4, a5, a6, a7, a8, (uint64_t)"_cfTypeRegistry == NULL");
  keys[0] = (void *)sub_1B17A12B4();
  keys[1] = (void *)sub_1B1874018();
  keys[2] = (void *)sub_1B17F0CB0();
  keys[3] = (void *)sub_1B18FF324();
  keys[4] = (void *)sub_1B190B104();
  keys[5] = (void *)sub_1B180713C();
  keys[6] = (void *)sub_1B1877980();
  keys[7] = (void *)sub_1B18091DC();
  keys[8] = (void *)sub_1B17A3924();
  keys[9] = (void *)sub_1B1869F5C();
  keys[10] = (void *)sub_1B1863E18();
  keys[11] = (void *)sub_1B185EA24();
  keys[12] = (void *)sub_1B18F0014();
  keys[13] = (void *)sub_1B18E42EC();
  keys[14] = (void *)sub_1B18F52DC();
  keys[15] = (void *)sub_1B17ED128();
  keys[16] = (void *)sub_1B1941738();
  keys[17] = (void *)sub_1B19435F8();
  keys[18] = (void *)sub_1B187A3A8();
  keys[19] = (void *)sub_1B19156CC();
  keys[20] = (void *)sub_1B19DDABC();
  keys[21] = (void *)sub_1B19DDBE8();
  keys[22] = (void *)sub_1B18D9D1C();
  keys[23] = (void *)sub_1B18D5690();
  keys[24] = (void *)sub_1B181DD08();
  keys[25] = (void *)sub_1B1846814();
  keys[26] = (void *)sub_1B19BA5DC();
  keys[27] = (void *)sub_1B19BA514();
  keys[28] = (void *)sub_1B19BA69C();
  keys[29] = (void *)sub_1B19BA594();
  keys[30] = (void *)sub_1B19BC92C();
  keys[31] = (void *)sub_1B19BA554();
  keys[32] = (void *)sub_1B19BA61C();
  keys[33] = (void *)sub_1B182DCD4();
  keys[34] = (void *)sub_1B19BA65C();
  keys[35] = (void *)sub_1B182F8B4();
  keys[36] = (void *)sub_1B18F4824();
  keys[37] = (void *)sub_1B19D44E8();
  keys[38] = (void *)sub_1B1989FB0();
  keys[39] = (void *)sub_1B18E8B6C();
  keys[40] = (void *)sub_1B18E8E98();
  keys[41] = (void *)sub_1B18E904C();
  keys[42] = (void *)sub_1B18E93A4();
  keys[43] = (void *)sub_1B18E9984();
  keys[44] = (void *)sub_1B18EA440();
  keys[45] = (void *)sub_1B18EAE68();
  keys[46] = (void *)sub_1B18EAFF8();
  keys[47] = (void *)sub_1B18EA8F4();
  keys[48] = (void *)sub_1B18EB1CC();
  keys[49] = (void *)sub_1B18EB448();
  keys[50] = (void *)sub_1B18EBD0C();
  v8 = (void *)sub_1B18EBFD4();
  v9 = 0;
  keys[51] = v8;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  *(_OWORD *)values = 0u;
  v13 = 0u;
  v10 = vdupq_n_s64(1uLL);
  do
  {
    *(int64x2_t *)&values[v9] = v10;
    v9 += 2;
  }
  while (v9 != 52);
  result = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 52, 0, 0);
  qword_1ED4CEA80 = (uint64_t)result;
  return result;
}

BOOL sub_1B193EEA8(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeID v9;

  if (!cf)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  v9 = CFGetTypeID(cf);
  return sub_1B17A21D8(v9) || v9 == sub_1B1877980();
}

const __CFDictionary *sub_1B193EF14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  return sub_1B193EF6C(a1, CFSTR("kAnimationsKey"), 0, a4, a5, a6, a7, a8);
}

const __CFDictionary *sub_1B193EF6C(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  const __CFDictionary *v11;
  const __CFDictionary *Value;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v8 = a3;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  v11 = *(const __CFDictionary **)(a1 + 40);
  if (v11)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v11, key);
    if (Value)
      return Value;
  }
  else
  {
    Value = 0;
  }
  if (v8)
  {
    Value = (const __CFDictionary *)sub_1B18C00F4();
    sub_1B193E88C((CFTypeRef *)a1, key, Value, 1, v13, v14, v15, v16);
    if (CFGetRetainCount(Value) <= 1)
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. CFXEntitySetAttribute failed to cache attribute"), v17, v18, v19, v20, v21, v22, (uint64_t)"CFGetRetainCount(dict) >= 2");
    CFRelease(Value);
  }
  return Value;
}

void sub_1B193F03C(_QWORD *a1, uint64_t *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFDictionary *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  if (a1)
  {
    if (a2)
      goto LABEL_3;
LABEL_7:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
    if (a3)
      goto LABEL_4;
    goto LABEL_8;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  if (!a2)
    goto LABEL_7;
LABEL_3:
  if (a3)
    goto LABEL_4;
LABEL_8:
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"key");
LABEL_4:
  sub_1B193F164(a1, a3, 1, a4, a5, a6, a7, a8);
  v16 = sub_1B193EF6C((uint64_t)a1, CFSTR("kAnimationsKey"), 1, v11, v12, v13, v14, v15);
  sub_1B18C00D8(v16, (const char *)a3, (uint64_t)a2);
  v24 = sub_1B17C6244(a1, v17, v18, v19, v20, v21, v22, v23);
  if (v24)
  {
    v32 = v24;
    v33 = sub_1B187A97C(v24, v25, v26, v27, v28, v29, v30, v31);
    sub_1B17C5FC0(a2, v32, v34, v35, v36, v37, v38, v39);
    sub_1B17F31A8(v33, (uint64_t)a2, a1, a3, v40, v41, v42, v43);
  }
}

void sub_1B193F164(_QWORD *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;

  v8 = a3;
  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
    if (a2)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"key");
LABEL_3:
  v11 = sub_1B193EF6C((uint64_t)a1, CFSTR("kAnimationsKey"), 0, a4, a5, a6, a7, a8);
  if (v11)
  {
    v12 = v11;
    CFRetain(v11);
    v20 = sub_1B17C6244(a1, v13, v14, v15, v16, v17, v18, v19);
    v28 = v20;
    if (v20)
    {
      v29 = sub_1B187A97C(v20, v21, v22, v23, v24, v25, v26, v27);
      if (v8)
        sub_1B17F3D7C(v29, a1, a2, v30, v31, v32, v33, v34);
      else
        sub_1B17F2004(v29, a1, a2, v30, v31, v32, v33, v34);
    }
    v35 = (void *)sub_1B18C00D0(v12, (const char *)a2, v22, v23);
    if (v35)
    {
      sub_1B17C5DD0(v35, v28, v36, v37, v38, v39, v40, v41);
      sub_1B18C00E0(v12, (const char *)a2, v42, v43);
      if ((v8 & 1) == 0 && !j__objc_msgSend_count(v12, v44, v45, v46))
        sub_1B193E88C((CFTypeRef *)a1, CFSTR("kAnimationsKey"), 0, 1, v47, v48, v49, v50);
    }
    CFRelease(v12);
  }
}

void sub_1B193F2A4(int a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B17C5DD0(cf, a3, a3, a4, a5, a6, a7, a8);
}

void sub_1B193F2B0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFDictionary *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  v11 = sub_1B17C61FC((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  v19 = v11;
  if (v11)
  {
    v20 = sub_1B187A97C(v11, v12, v13, v14, v15, v16, v17, v18);
    if (v20)
      sub_1B17F3A60(v20, a1, v21, v14, v15, v16, v17, v18, a9);
  }
  v22 = sub_1B193EF6C((uint64_t)a1, CFSTR("kAnimationsKey"), 0, v14, v15, v16, v17, v18);
  if (v22)
  {
    sub_1B18C00E8((uint64_t)v22, (uint64_t)sub_1B193F2A4, v19);
    sub_1B193E88C((CFTypeRef *)a1, CFSTR("kAnimationsKey"), 0, 1, v23, v24, v25, v26);
  }
}

void sub_1B193F388(_QWORD *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  if (a1)
  {
    if (a2)
      goto LABEL_4;
    goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  if (!a2)
LABEL_3:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"key");
LABEL_4:
  v12 = sub_1B193EF6C((uint64_t)a1, CFSTR("kAnimationsKey"), 0, a4, a5, a6, a7, a8);
  if (v12)
  {
    v13 = v12;
    CFRetain(v12);
    v21 = sub_1B17C6244(a1, v14, v15, v16, v17, v18, v19, v20);
    v29 = v21;
    if (v21)
    {
      v30 = sub_1B187A97C(v21, v22, v23, v24, v25, v26, v27, v28);
      sub_1B17F3BFC(v30, a1, a2, v31, v32, v33, v34, v35, a9);
    }
    v36 = (void *)sub_1B18C00D0(v13, (const char *)a2, v23, v24);
    if (v36)
    {
      sub_1B17C5DD0(v36, v29, v37, v38, v39, v40, v41, v42);
      sub_1B18C00E0(v13, (const char *)a2, v43, v44);
      if (!j__objc_msgSend_count(v13, v45, v46, v47))
        sub_1B193E88C((CFTypeRef *)a1, CFSTR("kAnimationsKey"), 0, 1, v48, v49, v50, v51);
    }
    CFRelease(v13);
  }
}

uint64_t sub_1B193F4C8(_QWORD *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFArray *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  const __CFString *v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  const __CFString *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;

  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
    if (a2)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"b");
LABEL_3:
  v10 = sub_1B193F5D8((uint64_t)a1, CFSTR("kBindingsKey"), 1, a4, a5, a6, a7, a8);
  CFArrayAppendValue(v10, a2);
  result = sub_1B17C6244(a1, v11, v12, v13, v14, v15, v16, v17);
  if (result)
  {
    v26 = sub_1B187A97C(result, v19, v20, v21, v22, v23, v24, v25);
    v30 = (const __CFString *)objc_msgSend_keyPathDst(a2, v27, v28, v29);
    v34 = (_QWORD *)objc_msgSend_sourceObject(a2, v31, v32, v33);
    v38 = (const __CFString *)objc_msgSend_keyPathSrc(a2, v35, v36, v37);
    v42 = (void *)objc_msgSend_options(a2, v39, v40, v41);
    return sub_1B17F450C(v26, a1, v30, v34, v38, v42);
  }
  return result;
}

const __CFDictionary *sub_1B193F5D8(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  const __CFDictionary *v11;
  const __CFDictionary *Value;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v8 = a3;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  v11 = *(const __CFDictionary **)(a1 + 40);
  if (v11)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v11, key);
    if (Value)
      return Value;
  }
  else
  {
    Value = 0;
  }
  if (v8)
  {
    Value = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    sub_1B193E88C((CFTypeRef *)a1, key, Value, 1, v13, v14, v15, v16);
    CFRelease(Value);
  }
  return Value;
}

void sub_1B193F68C(CFTypeRef *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  v9 = sub_1B17C6244(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v9)
  {
    v17 = sub_1B187A97C(v9, v10, v11, v12, v13, v14, v15, v16);
    if (v17)
      sub_1B17F4804(v17, (uint64_t)a1);
  }
  sub_1B193E88C(a1, CFSTR("kBindingsKey"), 0, 1, v13, v14, v15, v16);
}

void sub_1B193F704(CFTypeRef *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  id v29;
  const char *v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t i;
  void *v38;
  void *v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _BYTE v50[128];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
    if (a2)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"keyPath");
LABEL_3:
  v10 = sub_1B193F5D8((uint64_t)a1, CFSTR("kBindingsKey"), 0, a4, a5, a6, a7, a8);
  if (v10)
  {
    v11 = v10;
    v12 = v10;
    v20 = sub_1B17C6244(a1, v13, v14, v15, v16, v17, v18, v19);
    if (v20)
    {
      v28 = sub_1B187A97C(v20, (uint64_t)v21, v22, v23, v24, v25, v26, v27);
      sub_1B17F4708(v28, a1, a2);
    }
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v29 = (id)objc_msgSend_copy(v11, v21, v22, v23);
    v31 = objc_msgSend_countByEnumeratingWithState_objects_count_(v29, v30, (uint64_t)&v46, (uint64_t)v50, 16);
    if (v31)
    {
      v35 = v31;
      v36 = *(_QWORD *)v47;
      do
      {
        for (i = 0; i != v35; ++i)
        {
          if (*(_QWORD *)v47 != v36)
            objc_enumerationMutation(v29);
          v38 = *(void **)(*((_QWORD *)&v46 + 1) + 8 * i);
          v39 = (void *)objc_msgSend_keyPathDst(v38, v32, v33, v34);
          if (objc_msgSend_isEqualToString_(v39, v40, (uint64_t)a2, v41))
            objc_msgSend_removeObject_(v11, v32, (uint64_t)v38, v34);
        }
        v35 = objc_msgSend_countByEnumeratingWithState_objects_count_(v29, v32, (uint64_t)&v46, (uint64_t)v50, 16);
      }
      while (v35);
    }
    if (!objc_msgSend_count(v11, v32, v33, v34))
      sub_1B193E88C(a1, CFSTR("kBindingsKey"), 0, 1, v42, v43, v44, v45);

  }
}

void sub_1B193F8D0(CFTypeRef *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeID v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  sub_1B193E88C(a1, CFSTR("kShaderModifiers"), a2, 1, a5, a6, a7, a8);
  v10 = CFGetTypeID(a1);
  if (sub_1B17A21D8(v10))
  {
    sub_1B17A20D4(a1, v11, v12, v13, v14, v15, v16, v17);
  }
  else if (v10 == sub_1B1877980())
  {
    sub_1B1878850((uint64_t)a1, v18, v19, v20, v21, v22, v23, v24);
  }
}

const __CFDictionary *sub_1B193F97C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  return sub_1B193E800(a1, CFSTR("kShaderModifiers"), a3, a4, a5, a6, a7, a8);
}

const __CFArray *sub_1B193F9D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  const __CFArray *result;
  const __CFArray *v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex v14;
  const void *ValueAtIndex;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;

  v8 = a2;
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  result = sub_1B193F97C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v11 = result;
    Count = CFArrayGetCount(result);
    v13 = Count - 1;
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      v14 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v11, v14);
        v23 = sub_1B19B97B8((uint64_t)ValueAtIndex, v16, v17, v18, v19, v20, v21, v22) == v8;
        result = (const __CFArray *)v23;
        v23 = v23 || v13 == v14++;
      }
      while (!v23);
    }
  }
  return result;
}

void sub_1B193FA6C(CFTypeRef *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  sub_1B193E88C(a1, CFSTR("kShadableMinimumMTLLanguageVersionKey"), a2, 1, a5, a6, a7, a8);
}

const __CFDictionary *sub_1B193FACC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  return sub_1B193E800(a1, CFSTR("kShadableMinimumMTLLanguageVersionKey"), a3, a4, a5, a6, a7, a8);
}

void sub_1B193FB20(uint64_t a1, void *a2, __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v11;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
    if (a2)
      goto LABEL_3;
LABEL_5:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"propertyName");
    goto LABEL_3;
  }
  if (!a2)
    goto LABEL_5;
LABEL_3:
  v11 = sub_1B193FBB0(a1, 1);
  sub_1B19D4900((uint64_t)v11, a2, a3);
}

const __CFDictionary *sub_1B193FBB0(uint64_t a1, int a2)
{
  const __CFDictionary *v4;
  const __CFDictionary *Value;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *(const __CFDictionary **)(a1 + 40);
  if (v4)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v4, CFSTR("_kvc"));
    if (Value)
      return Value;
  }
  else
  {
    Value = 0;
  }
  if (a2)
  {
    Value = (const __CFDictionary *)sub_1B19D457C();
    sub_1B193E88C((CFTypeRef *)a1, CFSTR("_kvc"), Value, 1, v6, v7, v8, v9);
    CFRelease(Value);
  }
  return Value;
}

void sub_1B193FC30(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v10;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
    if (a2)
      goto LABEL_3;
LABEL_5:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"propertyName");
    goto LABEL_3;
  }
  if (!a2)
    goto LABEL_5;
LABEL_3:
  v10 = sub_1B193FBB0(a1, 1);
  sub_1B19D4844((uint64_t)v10, a2);
}

const void *sub_1B193FCB0(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v10;
  const void *Value;

  if (!a1)
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
    if (a2)
      goto LABEL_3;
LABEL_8:
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"propertyName");
    goto LABEL_3;
  }
  if (!a2)
    goto LABEL_8;
LABEL_3:
  v10 = *(const __CFDictionary **)(a1 + 40);
  if (v10 && (Value = CFDictionaryGetValue(v10, CFSTR("_kvc"))) != 0)
    return sub_1B19D483C((uint64_t)Value, a2);
  else
    return 0;
}

const __CFDictionary *sub_1B193FD50(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *result;
  uint64_t v11;
  uint64_t v12;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  result = *(const __CFDictionary **)(a1 + 40);
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("_kvc"));
    if (result)
      return (const __CFDictionary *)sub_1B19D4A70((uint64_t)result, a2, v11, v12);
  }
  return result;
}

const __CFDictionary *sub_1B193FDC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *result;
  uint64_t v11;
  uint64_t v12;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
  result = *(const __CFDictionary **)(a1 + 40);
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("_kvc"));
    if (result)
      return (const __CFDictionary *)sub_1B19D4AD0((uint64_t)result, a2, v11, v12);
  }
  return result;
}

uint64_t sub_1B193FE38(uint64_t a1, const __CFArray *a2, int a3, uint64_t a4)
{
  const __CFDictionary *v4;
  CFDictionaryRef *Value;

  v4 = *(const __CFDictionary **)(a1 + 40);
  if (v4 && (Value = (CFDictionaryRef *)CFDictionaryGetValue(v4, CFSTR("_kvc"))) != 0)
    return sub_1B19D45F4(Value, a2, a3, a4);
  else
    return 0;
}

uint64_t sub_1B193FE9C(_QWORD *a1)
{
  const __CFDictionary *v2;
  const void *Value;
  uint64_t v4;
  CFTypeID v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = (const __CFDictionary *)a1[5];
  if (v2 && (Value = CFDictionaryGetValue(v2, CFSTR("_kvc"))) != 0)
    v4 = sub_1B19D4A68((uint64_t)Value);
  else
    v4 = 0;
  v5 = CFGetTypeID(a1);
  if (v5 == sub_1B1877980())
    return sub_1B1878A10((uint64_t)a1, v6, v7, v8, v9, v10, v11, v12) + v4;
  return v4;
}

CFStringRef sub_1B193FF10(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CFXEntity:%p>"), a1);
}

CFStringRef sub_1B193FF4C(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CFXEntity:%p>"), a1);
}

const __CFDictionary *sub_1B193FF90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *result;

  result = sub_1B193EF6C(a1, CFSTR("kAnimationsKey"), 0, a4, a5, a6, a7, a8);
  if (result)
    return (const __CFDictionary *)sub_1B18C00E8((uint64_t)result, (uint64_t)sub_1B193F2A4, a2);
  return result;
}

void *sub_1B193FFDC(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFDictionary *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *result;
  const char *v23;
  void *v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  void *v30;
  void *v31;
  const __CFString *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  const __CFString *v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _QWORD v49[18];

  v49[16] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"entity");
    if (a2)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"world");
LABEL_3:
  v10 = sub_1B187A97C(a2, a2, a3, a4, a5, a6, a7, a8);
  v16 = sub_1B193EF6C((uint64_t)a1, CFSTR("kAnimationsKey"), 0, v11, v12, v13, v14, v15);
  if (v16)
  {
    v49[0] = a1;
    v49[1] = v10;
    v49[2] = a2;
    sub_1B18C00E8((uint64_t)v16, (uint64_t)sub_1B19401B8, (uint64_t)v49);
  }
  result = sub_1B193F5D8((uint64_t)a1, CFSTR("kBindingsKey"), 0, v17, v18, v19, v20, v21);
  if (result)
  {
    v24 = result;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    result = (void *)objc_msgSend_countByEnumeratingWithState_objects_count_(result, v23, (uint64_t)&v45, (uint64_t)v49, 16);
    if (result)
    {
      v28 = result;
      v29 = *(_QWORD *)v46;
      do
      {
        v30 = 0;
        do
        {
          if (*(_QWORD *)v46 != v29)
            objc_enumerationMutation(v24);
          v31 = *(void **)(*((_QWORD *)&v45 + 1) + 8 * (_QWORD)v30);
          v32 = (const __CFString *)objc_msgSend_keyPathDst(v31, v25, v26, v27);
          v36 = (_QWORD *)objc_msgSend_sourceObject(v31, v33, v34, v35);
          v40 = (const __CFString *)objc_msgSend_keyPathSrc(v31, v37, v38, v39);
          v44 = (void *)objc_msgSend_options(v31, v41, v42, v43);
          sub_1B17F450C(v10, a1, v32, v36, v40, v44);
          v30 = (char *)v30 + 1;
        }
        while (v28 != v30);
        result = (void *)objc_msgSend_countByEnumeratingWithState_objects_count_(v24, v25, (uint64_t)&v45, (uint64_t)v49, 16);
        v28 = result;
      }
      while (result);
    }
  }
  return result;
}

void sub_1B19401B8(void *a1, uint64_t *cf, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v11 = (_QWORD *)*a3;
  v10 = a3[1];
  sub_1B17C5FC0(cf, a3[2], (uint64_t)a3, a4, a5, a6, a7, a8);
  sub_1B17F31A8(v10, (uint64_t)cf, v11, a1, v12, v13, v14, v15);
}

uint64_t sub_1B1940200(uint64_t *a1)
{
  uint64_t result;

  result = sub_1B179CB60(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B194022C(uint64_t a1)
{
  uint64_t v2;
  const __CFAllocator *v3;
  const CFDictionaryValueCallBacks *v4;

  if (qword_1EEF66590 != -1)
    dispatch_once_f(&qword_1EEF66590, &qword_1EEF66588, (dispatch_function_t)sub_1B1940200);
  v2 = sub_1B179CB90(qword_1EEF66588, 0x30uLL);
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  *(_QWORD *)(v2 + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v2 + 24) = CFDictionaryCreateMutable(v3, 0, 0, v4);
  *(_QWORD *)(v2 + 56) = a1;
  *(_DWORD *)(v2 + 32) = 0;
  return v2;
}

void sub_1B1940344(uint64_t a1, int a2, const void *a3, const void *a4)
{
  os_unfair_lock_s *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  void *Value;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;

  v8 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  if (a3)
  {
    if (a1)
      goto LABEL_3;
  }
  else
  {
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v9, v10, v11, v12, v13, v14, (uint64_t)"object");
    if (a1)
      goto LABEL_3;
  }
  sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v9, v10, v11, v12, v13, v14, (uint64_t)"notificationQueue");
LABEL_3:
  v15 = (const void *)CFGetTypeID(a3);
  if (sub_1B17A21D8((uint64_t)v15))
    v15 = (const void *)sub_1B17A12B4();
  Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v15);
  if (!Value)
  {
    Value = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], 0);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v15, Value);
    CFRelease(Value);
  }
  v17 = CFDictionaryGetValue((CFDictionaryRef)Value, a3);
  v24 = v17;
  switch(a2)
  {
    case 0:
      if ((v17 & 0x200) != 0)
        sub_1B17C4408(0, (uint64_t)CFSTR("Warning: adding a node that was just removed %p"), v18, v19, v20, v21, v22, v23, (uint64_t)a3);
      v25 = (const void *)(v24 & 0xFFF7FF00 | 0x80001);
      goto LABEL_24;
    case 2:
      if (!a4)
      {
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. missing attribute"), v18, v19, v20, v21, v22, v23, (uint64_t)"nil");
        goto LABEL_25;
      }
      if (CFEqual(a4, CFSTR("model")))
      {
        v26 = v24 & 0xFFFFEF00;
        v27 = 4097;
      }
      else if (CFEqual(a4, CFSTR("kCameraKey")))
      {
        v26 = v24 & 0xFFFFDF00;
        v27 = 8193;
      }
      else if (CFEqual(a4, CFSTR("kLightKey")))
      {
        v26 = v24 & 0xFFFFBF00;
        v27 = 16385;
      }
      else
      {
        if (!CFEqual(a4, CFSTR("kDeformerStackKey")))
          goto LABEL_25;
        v26 = v24 & 0xFFFEFF00;
        v27 = 65537;
      }
LABEL_23:
      v25 = (const void *)(v26 | v27);
LABEL_24:
      CFDictionarySetValue((CFMutableDictionaryRef)Value, a3, v25);
LABEL_25:
      if (!*(_BYTE *)(a1 + 48))
      {
        *(_BYTE *)(a1 + 48) = 1;
        sub_1B1940644(a1);
      }
      os_unfair_lock_unlock(v8);
      return;
    case 3:
      v26 = v17 & 0xFFFFFD00;
      v27 = 514;
      goto LABEL_23;
    case 4:
      v26 = v17 & 0xFFFFFB00;
      v27 = 1025;
      goto LABEL_23;
    case 5:
      v26 = v17 & 0xFFFFFF00;
      v27 = 2049;
      goto LABEL_23;
    case 6:
      v26 = v17 & 0xFFFFFB00;
      v27 = 1027;
      goto LABEL_23;
    case 7:
      v26 = v17 & 0xFFFFFF00;
      v27 = 2051;
      goto LABEL_23;
    case 8:
      v25 = (const void *)((v17 & 0xFFFBFF00) + 262145);
      goto LABEL_24;
    case 9:
      v26 = v17 & 0xFFFFFD00;
      v27 = 516;
      goto LABEL_23;
    default:
      goto LABEL_25;
  }
}

void sub_1B1940644(uint64_t a1)
{
  CFXEngineNotificationQueueTransientWrapper *v2;
  const char *v3;
  uint64_t v4;
  dispatch_time_t v5;
  _QWORD v6[6];

  if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16)))
  {
    v2 = objc_alloc_init(CFXEngineNotificationQueueTransientWrapper);
    objc_msgSend_setEngineNotificationQueue_(v2, v3, a1, v4);
    v5 = dispatch_time(0, 1000000000);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = sub_1B19409E0;
    v6[3] = &unk_1E63D83E0;
    v6[4] = v2;
    v6[5] = a1;
    dispatch_after(v5, MEMORY[0x1E0C80D38], v6);

  }
}

void sub_1B19406E0(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"queue");
  sub_1B194F7E4(a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))sub_1B1940750, CFSTR("kCFXNotificationEntityAttributeDidChange"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  a1[49] = 1;
}

void sub_1B1940750(int a1, uint64_t a2, CFTypeRef cf1, _QWORD *a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (CFEqual(cf1, CFSTR("kCFXNotificationEntityAttributeDidChange")))
  {
    v19 = sub_1B17C6244(a4, v12, v13, v14, v15, v16, v17, v18);
    v20 = *(_QWORD *)(a2 + 56);
    if (v19 == v20 && v20 != 0)
      sub_1B1940344(a2, 2, a4, a5);
  }
  else
  {
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: unknown notification name"), v13, v14, v15, v16, v17, v18, a9);
  }
}

void sub_1B19407E8(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"queue");
  if (a1[49])
    sub_1B194F838(a1, CFSTR("kCFXNotificationEntityAttributeDidChange"), 0);
}

void sub_1B1940858(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"notificationQueue");
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 24));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  *(int8x16_t *)(a1 + 16) = vextq_s8(*(int8x16_t *)(a1 + 16), *(int8x16_t *)(a1 + 16), 8uLL);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
  *(_BYTE *)(a1 + 50) = 0;
  *(CFTimeInterval *)(a1 + 40) = CACurrentMediaTime();
}

void sub_1B19408D0(uint64_t a1, const void *a2, void (__cdecl *a3)(const void *, const void *, void *), void *a4)
{
  const __CFDictionary *Value;

  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
    CFDictionaryApplyFunction(Value, a3, a4);
}

uint64_t sub_1B1940910(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 50);
}

void sub_1B194091C(uint64_t a1)
{
  os_unfair_lock_s *v2;
  const void *v3;
  const void *v4;

  v2 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v4 = *(const void **)(a1 + 24);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 24) = 0;
  }
  os_unfair_lock_unlock(v2);
}

CFStringRef sub_1B1940968(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXEngineNotificationQueue %p>"), a1);
}

CFStringRef sub_1B19409A4(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFXEngineNotificationQueue %p>"), a1);
}

void sub_1B19409E0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  CFTimeInterval v7;
  const __CFDictionary *v8;

  v5 = objc_msgSend_engineNotificationQueue(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    v6 = v5;
    v7 = CACurrentMediaTime() - *(double *)(v5 + 40);
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 32));
    if (v7 >= 1.0)
    {
      *(_BYTE *)(v6 + 48) = 0;
      v8 = *(const __CFDictionary **)(v6 + 16);
      *(_QWORD *)(v6 + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
      if (CFDictionaryGetCount(v8) >= 1)
        *(_BYTE *)(v6 + 50) = 1;
      os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 32));
      CFRelease(v8);
    }
    else
    {
      sub_1B1940644(v6);
      os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 32));
    }
  }
}

_DWORD *sub_1B1940ACC(uint64_t a1, unsigned int *a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  unsigned int *v12;
  int v13;
  float32x4_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float32x4_t v28;
  BOOL v29;
  char v30;
  float32x4_t v31;
  int32x4_t v32;
  float32x2_t v33;
  float32x2_t v34;
  uint64_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  int32x4_t v43;
  float32x2_t v44;
  float32x2_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  double v57;
  double v58;
  double v59;
  double v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  double v64;
  float32x4_t v65;
  double v66;
  double *v67;
  int v68;
  double v69;
  double v70;
  double v71;
  double v72;
  float v73;
  float v74;
  float v75;
  float v76;
  int v77;
  _QWORD *v78;
  _DWORD *v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int v83;
  _QWORD *v84;
  _DWORD *v85;
  uint64_t v86;
  unsigned int v87;
  unsigned int *v88;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  __int128 v94;
  float32x4_t v95;
  char **v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  unsigned int v101;
  char *v102;
  unsigned int v103;
  unsigned int v104;
  float v105;
  float v106;
  float v107;
  float v108;
  uint64_t v109;

  v9 = (a3 - 2);
  if (a3 <= 2)
  {
    v10 = 0;
    *a4 = 0;
    return v10;
  }
  v11 = a3;
  v12 = a2;
  if ((_DWORD)a3 == 4)
  {
    v10 = malloc_type_malloc(0x18uLL, 0x100004052888210uLL);
    *v10 = *v12;
    v10[1] = v12[1];
    v10[2] = v12[2];
    v10[3] = *v12;
    v10[4] = v12[2];
    v10[5] = v12[3];
    v13 = 6;
    goto LABEL_7;
  }
  if ((_DWORD)a3 == 3)
  {
    v10 = malloc_type_malloc(0xCuLL, 0x100004052888210uLL);
    *v10 = *v12;
    v10[1] = v12[1];
    v10[2] = v12[2];
    v13 = 3;
LABEL_7:
    *a4 = v13;
    return v10;
  }
  *(double *)v15.i64 = sub_1B17EE400(a1, *a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  v95 = v15;
  *(double *)v28.i64 = sub_1B17EE400(a1, v12[1], v16, v17, v18, v19, v20, v21);
  v29 = 0;
  v30 = 0;
  v31 = vsubq_f32(v28, v95);
  v32 = (int32x4_t)vmulq_f32(v31, v31);
  v32.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v32, 2), vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v32.i8, 1))).u32[0];
  v33 = vrsqrte_f32((float32x2_t)v32.u32[0]);
  v34 = vmul_f32(v33, vrsqrts_f32((float32x2_t)v32.u32[0], vmul_f32(v33, v33)));
  v90 = vmulq_n_f32(v31, vmul_f32(v34, vrsqrts_f32((float32x2_t)v32.u32[0], vmul_f32(v34, v34))).f32[0]);
  v91 = 0u;
  v35 = 2;
  v92 = vnegq_f32(v90);
  v93 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v90, (int32x4_t)v90), (int8x16_t)v90, 0xCuLL);
  do
  {
    *(double *)v36.i64 = sub_1B17EE400(a1, v12[v35], v22, v23, v24, v25, v26, v27);
    v37 = vsubq_f32(v36, v95);
    v38 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v37, (int32x4_t)v37), (int8x16_t)v37, 0xCuLL), v92), v37, v93);
    v39 = vmulq_f32(v38, v38);
    if (vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), v39)).f32[0] != 0.0)
    {
      v40 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v38, (int32x4_t)v38), (int8x16_t)v38, 0xCuLL);
      v41 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v40, (int32x4_t)v40), (int8x16_t)v40, 0xCuLL), v92), v40, v93);
      v42 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), (int8x16_t)v41, 0xCuLL);
      v43 = (int32x4_t)vmulq_f32(v41, v41);
      v43.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v43.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v43, 2), *(float32x2_t *)v43.i8)).u32[0];
      v44 = vrsqrte_f32((float32x2_t)v43.u32[0]);
      v45 = vmul_f32(v44, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v44, v44)));
      v46 = vmulq_n_f32(v42, vmul_f32(v45, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v45, v45))).f32[0]);
      if ((v30 & 1) != 0)
      {
        v47 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v46, (int32x4_t)v46), (int8x16_t)v46, 0xCuLL), vnegq_f32(v91)), v46, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v91, (int32x4_t)v91), (int8x16_t)v91, 0xCuLL));
        v48 = vmulq_f32(v47, v47);
        v30 = 1;
        if (vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), v48)).f32[0] > 0.00001)break;
      }
      else
      {
        v30 = 1;
        v91 = v46;
      }
    }
    v29 = ++v35 >= (unint64_t)v11;
  }
  while (v11 != v35);
  if (v29 && (v30 & 1) != 0)
  {
    v55 = (char *)malloc_type_malloc(80 * v11, 0x1000040B1CE3FD8uLL);
    v56 = 0;
    v57 = 0.0;
    v94 = *MEMORY[0x1E0C9D538];
    v58 = 0.0;
    v59 = 0.0;
    v60 = 0.0;
    do
    {
      *(double *)v61.i64 = sub_1B17EE400(a1, *v12, v49, v50, v51, v52, v53, v54);
      v62 = vsubq_f32(v61, v95);
      v63 = vmulq_f32(v90, v62);
      v64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v63, 2), vaddq_f32(v63, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v63.f32, 1))).f32[0];
      v65 = vmulq_f32(v91, v62);
      v66 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 2), vaddq_f32(v65, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v65.f32, 1))).f32[0];
      v67 = (double *)&v55[v56];
      v68 = *v12++;
      *v67 = v64;
      v67[1] = v66;
      *((_OWORD *)v67 + 1) = v94;
      *((_OWORD *)v67 + 2) = v94;
      *((_OWORD *)v67 + 3) = v94;
      *((_DWORD *)v67 + 16) = 0;
      *((_BYTE *)v67 + 68) = 0;
      *((_DWORD *)v67 + 18) = v68;
      v69 = fmin(v60, v64);
      v70 = fmin(v58, v66);
      v71 = fmax(v59, v64);
      v72 = fmax(v57, v66);
      if (v56)
        v60 = v69;
      else
        v60 = v64;
      if (v56)
        v59 = v71;
      else
        v59 = v64;
      if (v56)
        v58 = v70;
      else
        v58 = v66;
      if (v56)
        v57 = v72;
      else
        v57 = v66;
      v56 += 80;
    }
    while (80 * v11 != v56);
    v109 = 0;
    v102 = v55;
    v103 = v11;
    v104 = v11;
    v73 = v60 + -1.0;
    v74 = v59 + 1.0;
    v105 = v73;
    v106 = v74;
    v75 = v58 + -1.0;
    v76 = v57 + 1.0;
    v107 = v75;
    v108 = v76;
    v77 = sub_1B1992790((unsigned int *)&v102);
    if (v77 != 2)
      sub_1B199280C(&v102);
    v101 = 0;
    v96 = &v102;
    v97 = 1;
    v99 = 0;
    v98 = 0;
    v100 = 0;
    v78 = sub_1B1995BE0((uint64_t)&v96, &v101);
    v79 = malloc_type_malloc(12 * v101, 0x100004052888210uLL);
    v10 = v79;
    if (v101)
    {
      v80 = 0;
      v81 = 1;
      if (v77 == 2)
        v82 = 1;
      else
        v82 = 2;
      if (v77 == 2)
        v81 = 2;
      v83 = 2;
      v84 = v78;
      do
      {
        v79[v83 - 2] = *(_DWORD *)(*v84 + 72);
        v79[v83 - 1] = *(_DWORD *)(v84[v82] + 72);
        v79[v83] = *(_DWORD *)(v84[v81] + 72);
        ++v80;
        v83 += 3;
        v84 += 7;
      }
      while (v80 < v101);
    }
    else if (!v78)
    {
LABEL_47:
      free(v55);
      *a4 = (int)v78;
      return v10;
    }
    free(v78);
    LODWORD(v78) = 3 * v101;
    goto LABEL_47;
  }
  v85 = malloc_type_malloc(4 * (3 * v9), 0x100004052888210uLL);
  v10 = v85;
  v86 = 0;
  v87 = 2;
  do
  {
    v85[v87 - 2] = *v12;
    v88 = &v12[v86];
    v85[v87 - 1] = v88[1];
    v85[v87] = v88[2];
    v87 += 3;
    ++v86;
  }
  while (v9 != v86);
  *a4 = 3 * v9;
  return v10;
}

uint64_t sub_1B1941010(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  __int128 v15;
  __int128 v16;

  if (!a2)
    return 0;
  v9 = objc_msgSend__handle(a2, (const char *)a2, (uint64_t)a3, a4);
  v10 = *(_DWORD *)(a1 + 8);
  *(_QWORD *)&v16 = *(_QWORD *)a1;
  *((_QWORD *)&v16 + 1) = v10;
  if (a3)
  {
    v11 = objc_msgSend__handle(a3, v6, v7, v8);
    v12 = *(_DWORD *)(a1 + 24);
    *(_QWORD *)&v15 = *(_QWORD *)(a1 + 16);
    *((_QWORD *)&v15 + 1) = v12;
    v13 = sub_1B21FF5F0(432, 16);
    sub_1B21F52E4(v13, v9, v11, &v16, &v15);
  }
  else
  {
    v13 = sub_1B21FF5F0(432, 16);
    sub_1B21F53EC(v13, v9, &v16);
  }
  return v13;
}

void sub_1B19410EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B21FF5FC(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1B1941354(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  __n128 *v5;
  __n128 result;

  v5 = (__n128 *)objc_msgSend__ballSocketConstraint(*(void **)(a1 + 48), a2, a3, a4);
  if (v5)
  {
    result = *(__n128 *)(a1 + 32);
    result.n128_u32[3] = 0;
    v5[23] = result;
  }
  return result;
}

__n128 sub_1B1941418(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  __n128 *v5;
  __n128 result;

  v5 = (__n128 *)objc_msgSend__ballSocketConstraint(*(void **)(a1 + 48), a2, a3, a4);
  if (v5)
  {
    result = *(__n128 *)(a1 + 32);
    result.n128_u32[3] = 0;
    v5[24] = result;
  }
  return result;
}

uint64_t sub_1B1941738()
{
  if (qword_1ED4CED70 != -1)
    dispatch_once(&qword_1ED4CED70, &unk_1E63D1290);
  return qword_1ED4CED78;
}

double sub_1B1941778()
{
  uint64_t v0;
  double result;

  if (!qword_1ED4CED78)
  {
    v0 = sub_1B179CB60(&qword_1ED4CED78);
    *(_QWORD *)&result = 0x1B1943430;
    unk_1ED4BE8F8 = xmmword_1E63D3058;
    qword_1ED4CED78 = v0;
    qword_1ED4BE8E0 = (uint64_t)sub_1B1943270;
    unk_1ED4BE908 = unk_1E63D3068;
    qword_1ED4BE918 = 0;
    unk_1ED4BE920 = sub_1B1943214;
    qword_1ED4BE930 = (uint64_t)sub_1B1943450;
  }
  return result;
}

uint64_t sub_1B19417F8()
{
  uint64_t result;

  if (qword_1ED4CED70 != -1)
    dispatch_once(&qword_1ED4CED70, &unk_1E63D1290);
  result = sub_1B179CB90(qword_1ED4CED78, 0xC0uLL);
  *(_BYTE *)(result + 192) = 1;
  *(_QWORD *)(result + 184) = 0x13C23D70ALL;
  return result;
}

uint64_t sub_1B1941858(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 200) = a2;
  return result;
}

uint64_t sub_1B1941860(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 64) != a2)
  {
    *(_DWORD *)(result + 64) = a2;
    ++*(_DWORD *)(result + 188);
    result = *(_QWORD *)(result + 200);
    if (result)
      return sub_1B19437FC(result);
  }
  return result;
}

float sub_1B194188C(uint64_t a1)
{
  return *(float *)(a1 + 184);
}

__n128 sub_1B1941894@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;

  *(_QWORD *)a2 = *(_QWORD *)(a1 + 88);
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 96);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 112);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 120);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 128);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a1 + 136);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 144);
  result = *(__n128 *)(a1 + 152);
  *(__n128 *)(a2 + 64) = result;
  return result;
}

void sub_1B19418D8(uint64_t a1, CFTypeRef cf, uint64_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;
  int v11;
  CFTypeRef v12;
  CFTypeRef v14;
  int v15;
  int v16;
  int v17;
  size_t v18;
  void *v19;
  void *v20;
  int v21;
  size_t v22;
  void *v23;
  void *v24;
  int v25;
  int v26;
  size_t v27;
  int v28;
  int v29;
  int v30;
  size_t v31;
  void *v32;
  void *v33;
  int v34;
  int v35;
  int v36;
  size_t v37;
  void *v38;
  void *v39;
  int v40;
  size_t v41;
  void *v42;
  void *v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const void *v51;

  v9 = __n;
  v11 = *(_DWORD *)(a1 + 88);
  v12 = *(CFTypeRef *)(a1 + 72);
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      *(_QWORD *)(a1 + 72) = 0;
    }
    if (cf)
      v14 = CFRetain(cf);
    else
      v14 = 0;
    *(_QWORD *)(a1 + 72) = v14;
  }
  ++*(_DWORD *)(a1 + 188);
  *(_BYTE *)(a1 + 193) = v9;
  v15 = *(_DWORD *)a4;
  v16 = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)a4;
  if (v16)
  {
    v17 = *(_DWORD *)(a1 + 92);
    *(_DWORD *)(a1 + 92) = v16;
    v18 = (4 * v15);
    if (v15 != v11)
    {
      v19 = *(void **)(a1 + 96);
      if (v15)
      {
        v20 = malloc_type_realloc(v19, (4 * v15), 0xE2BDCFEDuLL);
      }
      else
      {
        free(v19);
        v20 = 0;
      }
      *(_QWORD *)(a1 + 96) = v20;
    }
    if (*(_DWORD *)a4)
      memcpy(*(void **)(a1 + 96), *(const void **)(a4 + 8), v18);
    v21 = *(_DWORD *)(a4 + 4);
    v22 = (4 * v21);
    if (v21 != v17)
    {
      v23 = *(void **)(a1 + 104);
      if (v21)
      {
        v24 = malloc_type_realloc(v23, (4 * v21), 0x5D9D022uLL);
      }
      else
      {
        free(v23);
        v24 = 0;
      }
      *(_QWORD *)(a1 + 104) = v24;
      v17 = *(_DWORD *)(a4 + 4);
    }
    if (v17)
      memcpy(*(void **)(a1 + 104), *(const void **)(a4 + 16), v22);
  }
  else
  {
    *(_DWORD *)(a1 + 92) = 0;
    free(*(void **)(a1 + 96));
    *(_QWORD *)(a1 + 96) = 0;
    free(*(void **)(a1 + 104));
    *(_QWORD *)(a1 + 104) = 0;
  }
  v25 = *(_DWORD *)(a1 + 112);
  v26 = *(_DWORD *)(a4 + 24);
  *(_DWORD *)(a1 + 112) = v26;
  if (v26)
  {
    v27 = (4 * v26);
    v28 = v25;
    if (v26 != v25)
    {
      *(_QWORD *)(a1 + 120) = malloc_type_realloc(*(void **)(a1 + 120), (4 * v26), 0x7471ADA2uLL);
      v28 = *(_DWORD *)(a4 + 24);
    }
    if (v28)
      memcpy(*(void **)(a1 + 120), *(const void **)(a4 + 32), v27);
    v29 = *(_DWORD *)(a1 + 128);
    v30 = *(_DWORD *)(a4 + 40);
    *(_DWORD *)(a1 + 128) = v30;
    v31 = (4 * v30);
    if (v30 != v29)
    {
      v32 = *(void **)(a1 + 136);
      if (v30)
      {
        v33 = malloc_type_realloc(v32, (4 * v30), 0x576811FuLL);
      }
      else
      {
        free(v32);
        v33 = 0;
      }
      *(_QWORD *)(a1 + 136) = v33;
      v29 = *(_DWORD *)(a4 + 40);
    }
    if (v29)
      memcpy(*(void **)(a1 + 136), *(const void **)(a4 + 48), v31);
    v34 = *(_DWORD *)(a4 + 56);
    if (v34)
    {
      v35 = *(_DWORD *)(a1 + 144);
      *(_DWORD *)(a1 + 144) = v34;
      v36 = *(_DWORD *)(a4 + 24);
      v37 = (4 * v36);
      if (v36 != v25)
      {
        v38 = *(void **)(a1 + 152);
        if (v36)
        {
          v39 = malloc_type_realloc(v38, (4 * v36), 0x2C0EC2E3uLL);
        }
        else
        {
          free(v38);
          v39 = 0;
        }
        *(_QWORD *)(a1 + 152) = v39;
      }
      if (*(_DWORD *)a4)
        memcpy(*(void **)(a1 + 152), *(const void **)(a4 + 64), v37);
      v40 = *(_DWORD *)(a4 + 56);
      v41 = (4 * v40);
      if (v40 != v35)
      {
        v42 = *(void **)(a1 + 160);
        if (*(_DWORD *)(a4 + 4))
        {
          v43 = malloc_type_realloc(v42, v41, 0xE92057CCuLL);
        }
        else
        {
          free(v42);
          v43 = 0;
        }
        *(_QWORD *)(a1 + 160) = v43;
        v35 = *(_DWORD *)(a4 + 56);
      }
      if (v35)
        memcpy(*(void **)(a1 + 160), *(const void **)(a4 + 72), v41);
    }
    else
    {
      *(_DWORD *)(a1 + 144) = 0;
      free(*(void **)(a1 + 152));
      *(_QWORD *)(a1 + 152) = 0;
      free(*(void **)(a1 + 160));
      *(_QWORD *)(a1 + 160) = 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 144) = 0;
    free(*(void **)(a1 + 120));
    *(_QWORD *)(a1 + 120) = 0;
    free(*(void **)(a1 + 136));
    *(_QWORD *)(a1 + 136) = 0;
    free(*(void **)(a1 + 152));
    *(_QWORD *)(a1 + 152) = 0;
    free(*(void **)(a1 + 160));
    *(_QWORD *)(a1 + 160) = 0;
    if (!v16)
    {
      free(*(void **)(a1 + 168));
      *(_QWORD *)(a1 + 168) = 0;
    }
  }
  v44 = *(_QWORD **)(a1 + 80);
  if (v44)
  {
    sub_1B17C5DD0(*(void **)(a1 + 80), *(_QWORD *)(a1 + 48), __n, a4, a5, a6, a7, a8);
    *(_QWORD *)(a1 + 80) = 0;
    sub_1B1941C34(a1, v44);
    sub_1B18F5C60((uint64_t)v44, 0, v45, v46, v47, v48, v49, v50);
    CFRelease(v44);
  }
  v51 = *(const void **)(a1 + 176);
  if (v51)
  {
    CFRelease(v51);
    *(_QWORD *)(a1 + 176) = 0;
  }
}

void sub_1B1941C34(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  __CFData *Mutable;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  UInt8 *MutableBytePtr;
  uint64_t i;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  v2 = *(unsigned int *)(a1 + 88);
  if ((_DWORD)v2)
  {
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4 * v2);
    CFDataSetLength(Mutable, 4 * v2);
    if (a2)
      a2 = (_QWORD *)sub_1B18F5B98((uint64_t)a2, v6, v7, v8, v9, v10, v11, v12);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    for (i = 0; i != v2; ++i)
    {
      v15 = 0;
      if (a2)
      {
        if (sub_1B18F39CC((uint64_t)a2) > i)
          v15 = *(_DWORD *)sub_1B18F39D4(a2, i, v16, v17, v18, v19, v20, v21);
      }
      *(_DWORD *)&MutableBytePtr[4 * i] = v15;
    }
    v22 = (const void *)sub_1B18F38F8(1, 1, v2, 0, 0);
    v29 = (void *)sub_1B18F54B4(v22, 0, v23, v24, v25, v26, v27, v28);
    sub_1B18F5564((uint64_t)v29, Mutable, v30, v31, v32, v33, v34, v35);
    sub_1B18F3B34((uint64_t)v22, (uint64_t)v29);
    CFRelease(v22);
    CFRelease(Mutable);
    sub_1B1941DDC(a1, v29, v36, v37, v38, v39, v40, v41);
    CFRelease(v29);
  }
}

void sub_1B1941D64(uint64_t a1, CFArrayRef theArray, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int Count;
  int v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _DWORD v16[7];

  if (theArray)
    Count = CFArrayGetCount(theArray);
  else
    Count = 0;
  memset(v16, 0, sizeof(v16));
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = Count;
  sub_1B19418D8(a1, theArray, a3, (uint64_t)&v12, a5, a6, a7, a8);
}

void sub_1B1941DDC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v9 = *(_QWORD *)(a1 + 80);
  if ((void *)v9 == a2)
    return;
  v10 = a2;
  if (v9)
  {
    sub_1B18F5C60(v9, 0, a3, a4, a5, a6, a7, a8);
    sub_1B17C5DD0(*(void **)(a1 + 80), *(_QWORD *)(a1 + 48), v11, v12, v13, v14, v15, v16);
    v17 = *(const void **)(a1 + 80);
    if (v17 != v10)
    {
      if (v17)
      {
        CFRelease(v17);
        *(_QWORD *)(a1 + 80) = 0;
      }
      if (!v10)
        goto LABEL_11;
      goto LABEL_10;
    }
  }
  else if (a2)
  {
LABEL_10:
    v10 = (void *)CFRetain(v10);
LABEL_11:
    *(_QWORD *)(a1 + 80) = v10;
  }
  if (v10)
  {
    sub_1B17C5FC0((uint64_t *)v10, *(_QWORD *)(a1 + 48), a3, a4, a5, a6, a7, a8);
    v18 = *(_QWORD *)(a1 + 80);
  }
  else
  {
    v18 = 0;
  }
  sub_1B18F5C60(v18, a1, a3, a4, a5, a6, a7, a8);
  sub_1B1941E88(a1, v19, v20, v21, v22, v23, v24, v25);
}

void sub_1B1941E88(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  const UInt8 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  const UInt8 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  int v26;
  float v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;

  ++*(_DWORD *)(a1 + 188);
  if (*(_QWORD *)(a1 + 168))
  {
    v9 = *(_QWORD *)(a1 + 80);
    if (!v9)
    {
      sub_1B1941C34(a1, 0);
      v9 = *(_QWORD *)(a1 + 80);
    }
    v10 = sub_1B18F5884(v9, a2, a3, a4, a5, a6, a7, a8);
    v18 = *(_DWORD *)(a1 + 112);
    if (*(_DWORD *)(a1 + 88) == (_DWORD)v11)
    {
      v19 = v10;
      v20 = (*(_DWORD *)(a1 + 92) + v11 + v18 + *(_DWORD *)(a1 + 144));
      v33 = 0;
      if ((_DWORD)v11)
      {
        v21 = 0;
        v22 = 4 * v11;
        do
        {
          if (*(_DWORD *)(a1 + 92))
            v23 = *(unsigned int *)(*(_QWORD *)(a1 + 96) + v21);
          else
            v23 = 0;
          sub_1B1943454(*(_QWORD *)(a1 + 168), (_DWORD *)&v33 + 1, (unsigned int *)&v33, v23, *(_QWORD *)(a1 + 104), v20, v16, v17, *(float *)&v19[v21]);
          v21 += 4;
        }
        while (v22 != v21);
        v18 = *(_DWORD *)(a1 + 112);
      }
      v32 = 0;
      if (v18)
      {
        v24 = 0;
        v25 = 0;
        do
        {
          v26 = *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4 * v24);
          if (v26)
          {
            v27 = 3.4028e38;
            v28 = *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4 * v24);
            v29 = v25;
            do
            {
              v30 = *(unsigned int *)(*(_QWORD *)(a1 + 136) + 4 * v29++);
              v27 = fminf(v27, *(float *)&v19[4 * v30]);
              --v28;
            }
            while (v28);
            v25 += v26;
          }
          else
          {
            v27 = 3.4028e38;
          }
          if (*(_DWORD *)(a1 + 144))
            v31 = *(unsigned int *)(*(_QWORD *)(a1 + 152) + 4 * v24);
          else
            v31 = 0;
          sub_1B1943454(*(_QWORD *)(a1 + 168), (_DWORD *)&v33 + 1, &v32, v31, *(_QWORD *)(a1 + 160), v20, v16, v17, v27);
          ++v24;
        }
        while (v24 < *(unsigned int *)(a1 + 112));
      }
      if (HIDWORD(v33) != (_DWORD)v20)
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Morpher failed to update all its runtime weights"), v12, v13, v14, v15, v16, v17, (uint64_t)"overallRuntimeTargetIndex == totalMorphTargetCount");
    }
    else
    {
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: Morpher has %d targets weights, but has %d main targets (note: there are %d in-betweens and %d correctives)"), v12, v13, v14, v15, v16, v17, v11);
    }
  }
}

uint64_t sub_1B194203C(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 80);
  if (!result)
  {
    sub_1B1941C34(a1, 0);
    return *(_QWORD *)(a1 + 80);
  }
  return result;
}

uint64_t sub_1B1942070(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

__CFArray *sub_1B1942078(uint64_t a1)
{
  __CFArray *Mutable;
  unint64_t v3;
  uint64_t v4;
  const void *ValueAtIndex;
  unint64_t v6;
  const void *v7;
  const void *v8;

  if (*(_DWORD *)(a1 + 92))
  {
    Mutable = CFArrayCreateMutable(0, *(unsigned int *)(a1 + 88), MEMORY[0x1E0C9B378]);
    if (*(_DWORD *)(a1 + 88))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        v4 += *(unsigned int *)(*(_QWORD *)(a1 + 96) + 4 * v3);
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v4 - 1);
        CFArrayAppendValue(Mutable, ValueAtIndex);
        ++v3;
      }
      while (v3 < *(unsigned int *)(a1 + 88));
    }
  }
  else if (*(_DWORD *)(a1 + 112))
  {
    Mutable = CFArrayCreateMutable(0, *(unsigned int *)(a1 + 88), MEMORY[0x1E0C9B378]);
    if (*(_DWORD *)(a1 + 88))
    {
      v6 = 0;
      do
      {
        v7 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v6);
        CFArrayAppendValue(Mutable, v7);
        ++v6;
      }
      while (v6 < *(unsigned int *)(a1 + 88));
    }
  }
  else
  {
    v8 = *(const void **)(a1 + 72);
    if (v8)
      return (__CFArray *)CFRetain(v8);
    return 0;
  }
  return Mutable;
}

uint64_t sub_1B194217C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"morph");
  v9 = *(_QWORD *)(a1 + 80);
  if (!v9)
  {
    sub_1B1941C34(a1, 0);
    v9 = *(_QWORD *)(a1 + 80);
    if (!v9)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"source");
      v9 = 0;
    }
  }
  result = sub_1B18F5B98(v9, a2, a3, a4, a5, a6, a7, a8);
  if (result)
    return sub_1B18F39CC(result);
  return result;
}

float sub_1B1942214(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  const UInt8 *v19;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"morph");
  v10 = *(_QWORD *)(a1 + 80);
  if (!v10)
  {
    sub_1B1941C34(a1, 0);
    v10 = *(_QWORD *)(a1 + 80);
    if (!v10)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"source");
      v10 = 0;
    }
  }
  v11 = (_QWORD *)sub_1B18F5B98(v10, a2, a3, a4, a5, a6, a7, a8);
  v18 = 0.0;
  if (sub_1B18F39CC((uint64_t)v11) > a2)
  {
    v19 = sub_1B18F39D4(v11, a2, v12, v13, v14, v15, v16, v17);
    if (v19)
      return *(float *)v19;
  }
  return v18;
}

void sub_1B19422D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __CFData *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"morph");
  v12 = *(_QWORD *)(a1 + 80);
  if (!v12)
  {
    sub_1B1941C34(a1, 0);
    v12 = *(_QWORD *)(a1 + 80);
    if (!v12)
    {
      sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"source");
      v12 = 0;
    }
  }
  v13 = (_QWORD *)sub_1B18F5B98(v12, a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B18F39CC((uint64_t)v13) > a2)
  {
    v20 = sub_1B18F3A4C(v13, a2, v14, v15, v16, v17, v18, v19);
    if (v20)
    {
      if (*(float *)v20 != a9)
      {
        *(float *)v20 = a9;
        sub_1B1941E88(a1, v21, v22, v23, v24, v25, v26, v27);
      }
    }
  }
}

uint64_t sub_1B19423B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFArray *v25;
  size_t v26;
  void *v27;
  size_t v28;
  void *v29;
  size_t v30;
  void *v31;
  size_t v32;
  void *v33;
  size_t v34;
  void *v35;
  size_t v36;
  void *v37;
  size_t v38;
  void *v39;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"morph");
  v16 = sub_1B19417F8();
  *(_DWORD *)(v16 + 64) = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(v16 + 184) = *(_DWORD *)(a1 + 184);
  *(_WORD *)(v16 + 192) = *(_WORD *)(a1 + 192);
  v17 = *(_QWORD *)(a1 + 80);
  if (v17)
  {
    v18 = (void *)sub_1B18F597C(v17, v9, v10, v11, v12, v13, v14, v15);
    sub_1B1941DDC(v16, v18, v19, v20, v21, v22, v23, v24);
    if (v18)
      CFRelease(v18);
  }
  v25 = *(const __CFArray **)(a1 + 72);
  if (v25)
    *(_QWORD *)(v16 + 72) = CFArrayCreateMutableCopy(0, 0, v25);
  *(_QWORD *)(v16 + 88) = *(_QWORD *)(a1 + 88);
  *(_DWORD *)(v16 + 112) = *(_DWORD *)(a1 + 112);
  *(_DWORD *)(v16 + 128) = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(v16 + 144) = *(_DWORD *)(a1 + 144);
  if (*(_QWORD *)(a1 + 96))
  {
    v26 = 4 * *(unsigned int *)(a1 + 88);
    v27 = malloc_type_malloc(v26, 0x3AE75981uLL);
    *(_QWORD *)(v16 + 96) = v27;
    memcpy(v27, *(const void **)(a1 + 96), v26);
  }
  if (*(_QWORD *)(a1 + 104))
  {
    v28 = 4 * *(unsigned int *)(a1 + 92);
    v29 = malloc_type_malloc(v28, 0x8EF6AA48uLL);
    *(_QWORD *)(v16 + 104) = v29;
    memcpy(v29, *(const void **)(a1 + 104), v28);
  }
  if (*(_QWORD *)(a1 + 120))
  {
    v30 = 4 * *(unsigned int *)(a1 + 112);
    v31 = malloc_type_malloc(v30, 0x5A1509EEuLL);
    *(_QWORD *)(v16 + 120) = v31;
    memcpy(v31, *(const void **)(a1 + 120), v30);
  }
  if (*(_QWORD *)(a1 + 136))
  {
    v32 = 4 * *(unsigned int *)(a1 + 128);
    v33 = malloc_type_malloc(v32, 0xE7FF1B31uLL);
    *(_QWORD *)(v16 + 136) = v33;
    memcpy(v33, *(const void **)(a1 + 136), v32);
  }
  if (*(_QWORD *)(a1 + 152))
  {
    v34 = 4 * *(unsigned int *)(a1 + 112);
    v35 = malloc_type_malloc(v34, 0xFD710948uLL);
    *(_QWORD *)(v16 + 152) = v35;
    memcpy(v35, *(const void **)(a1 + 152), v34);
  }
  if (*(_QWORD *)(a1 + 160))
  {
    v36 = 4 * *(unsigned int *)(a1 + 144);
    v37 = malloc_type_malloc(v36, 0xEDE5D889uLL);
    *(_QWORD *)(v16 + 160) = v37;
    memcpy(v37, *(const void **)(a1 + 160), v36);
  }
  if (*(_QWORD *)(a1 + 168))
  {
    v38 = 4
        * (*(_DWORD *)(a1 + 112) + *(_DWORD *)(a1 + 92) + *(_DWORD *)(a1 + 144) + *(_DWORD *)(a1 + 88));
    v39 = malloc_type_malloc(v38, 0x563F591uLL);
    *(_QWORD *)(v16 + 168) = v39;
    memcpy(v39, *(const void **)(a1 + 168), v38);
  }
  sub_1B193EAC4(a1, (CFTypeRef *)v16, (uint64_t)v25, v11, v12, v13, v14, v15);
  return v16;
}

uint64_t sub_1B19425F8(uint64_t result, char a2)
{
  *(_BYTE *)(result + 192) = a2;
  return result;
}

uint64_t sub_1B1942600(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 192);
}

void sub_1B1942608(uint64_t a1, uint64_t a2)
{
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  CFIndex v8;
  char v9;
  const void *ValueAtIndex;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (*(_BYTE *)(a1 + 192))
  {
    v3 = *(const __CFArray **)(a1 + 72);
    if (v3)
    {
      Count = CFArrayGetCount(v3);
      v6 = Count - 1;
      if (Count >= 1)
      {
        v7 = Count;
        v8 = 0;
        v9 = 0;
        do
        {
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v8);
            if (!ValueAtIndex)
              break;
            v17 = (uint64_t)ValueAtIndex;
            if (sub_1B18760A0((uint64_t)ValueAtIndex, 1, v11, v12, v13, v14, v15, v16))
              break;
            v9 = 1;
            sub_1B17B198C(v17, a2, 1, 1, v13, v14, v15, v16);
            if (v6 == v8++)
              goto LABEL_13;
          }
          ++v8;
        }
        while (v7 != v8);
        if ((v9 & 1) == 0)
          return;
LABEL_13:
        sub_1B17B198C(a2, a2, 1, 1, v13, v14, v15, v16);
      }
    }
  }
}

void sub_1B19426F0(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  CFIndex v10;
  const void *ValueAtIndex;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  CFArrayRef v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t i;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  const void *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const void *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  const void *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  const void **v88;
  const void *v89;
  uint64_t *v90;
  uint64_t *v91;
  uint64_t v92;
  uint64_t v93;
  const void *v94;
  uint64_t v95;
  const __CFAllocator *allocator;
  uint64_t v98;
  CFIndex Count;
  char v100;
  void *values;
  uint64_t v102;
  uint64_t v103;
  const void *v104;
  const void *v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v100 = a3;
  if (*(unsigned __int8 *)(a1 + 193) != a3)
  {
    v9 = a1;
    *(_BYTE *)(a1 + 193) = a3;
    if (a3)
      sub_1B1942AB4(a1, a2, 1, a4, a5, a6, a7, a8, v95);
    Count = CFArrayGetCount(*(CFArrayRef *)(v9 + 72));
    if (Count >= 1)
    {
      v10 = 0;
      allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v98 = v9;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v9 + 72), v10);
        v104 = 0;
        v105 = 0;
        v104 = sub_1B1875E70((uint64_t)ValueAtIndex, 0, v12, v13, v14, v15, v16, v17);
        v24 = sub_1B18760A0((uint64_t)ValueAtIndex, 0, v18, v19, v20, v21, v22, v23);
        v105 = v24;
        if (v104)
        {
          v32 = sub_1B1875D94((uint64_t)ValueAtIndex, 0, 0, v27, v28, v29, v30, v31);
          v24 = v105;
        }
        else
        {
          v32 = -1;
        }
        v102 = v32;
        if (v24)
        {
          v33 = sub_1B1875D94((uint64_t)ValueAtIndex, 1, 0, v27, v28, v29, v30, v31);
          v103 = v33;
          if (v105)
            v34 = 2;
          else
            v34 = 1;
          if (v105 && v33 != v32)
            sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. It doesn't make sense to call CFXMeshElementCreateIntervalList for sources with different channels"), v26, v27, v28, v29, v30, v31, (uint64_t)"channels[i] == channels[0]");
        }
        else
        {
          v103 = -1;
          v34 = 1;
        }
        if ((v100 & 1) != 0)
        {
          values = 0;
          v41 = (void *)sub_1B17B3EAC((uint64_t)&v104, v34, 1);
          values = v41;
          if (v41)
          {
            v42 = CFArrayCreate(allocator, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
            sub_1B18762F4((uint64_t)ValueAtIndex, v42, v43, v44, v45, v46, v47, v48);
            CFRelease(v42);
            CFRelease(values);
            for (i = 0; i != v34; ++i)
            {
              v55 = sub_1B17EDB28((uint64_t)*(&v104 + i), (uint64_t)values, *(&v102 + i), v49, v50, v51, v52, v53);
              if (v55)
              {
                v62 = (const void *)v55;
                if (a4)
                  (*(void (**)(uint64_t, const void *, _QWORD, uint64_t))(a4 + 16))(a4, ValueAtIndex, *(&v104 + i), v55);
                sub_1B1875414((uint64_t)ValueAtIndex, v62, 0, 255, v58, v59, v60, v61);
                CFRelease(v62);
              }
              else
              {
                sub_1B17C4408(16, (uint64_t)CFSTR("Error: Failed to create packed source %d for sparse morph target %d"), v56, v57, v58, v59, v60, v61, i);
              }
            }
          }
          else
          {
            sub_1B17C4408(16, (uint64_t)CFSTR("Error: Could not create intervals for sparse morph target %d (this morph target is useless)"), v35, v36, v37, v38, v39, v40, v10);
            sub_1B18762F4((uint64_t)ValueAtIndex, 0, v82, v83, v84, v85, v86, v87);
            v88 = &v104;
            do
            {
              v89 = *v88++;
              sub_1B18757DC((uint64_t)ValueAtIndex, v89, v63, v49, v50, v51, v52, v53);
              --v34;
            }
            while (v34);
          }
          if (!v41)
            goto LABEL_45;
        }
        else
        {
          if (sub_1B1874BE0((uint64_t)ValueAtIndex, v25, v26, v27, v28, v29, v30, v31) != (const __CFArray *)1)
            sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. sparse target should only contain 1 mesh element"), v64, v65, v66, v67, v68, v69, (uint64_t)"CFXMeshGetElementsCount(targetMesh) == 1");
          if (*(_DWORD *)(v9 + 64) != 1)
            sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. sparse targets should be in additive mode"), v64, v65, v66, v67, v68, v69, (uint64_t)"morph->_calculationMode == kCFXMorpherCalculationModeAdditive");
          v70 = sub_1B1874C3C((uint64_t)ValueAtIndex, 0, 0, v65, v66, v67, v68, v69);
          v77 = sub_1B1875E70(a2, 0, v71, v72, v73, v74, v75, v76);
          if (v77)
            v81 = sub_1B17EDAE0((uint64_t)v77, v78, v79, v80, v50, v51, v52, v53);
          else
            v81 = 0;
          v90 = &v102;
          v91 = (uint64_t *)&v104;
          do
          {
            v92 = *v90++;
            v93 = sub_1B17EDF54(*v91, (uint64_t)v70, v81, v92, v50, v51, v52, v53);
            if (v93)
            {
              v94 = (const void *)v93;
              if (a4)
                (*(void (**)(uint64_t, const void *, uint64_t, uint64_t))(a4 + 16))(a4, ValueAtIndex, *v91, v93);
              sub_1B1875414((uint64_t)ValueAtIndex, v94, 0, 255, v50, v51, v52, v53);
              CFRelease(v94);
            }
            ++v91;
            --v34;
          }
          while (v34);
        }
        sub_1B193E768((uint64_t)ValueAtIndex, 0, v63, v49, v50, v51, v52, v53);
LABEL_45:
        ++v10;
        v9 = v98;
      }
      while (v10 != Count);
    }
  }
}

void sub_1B1942AB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v10;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const void *v49;
  BOOL v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  const void *v62;
  CFIndex Count;
  uint64_t v64;

  if (*(_DWORD *)(a1 + 64) != (_DWORD)a3)
  {
    v10 = a3;
    *(_DWORD *)(a1 + 64) = a3;
    v13 = sub_1B1875E70(a2, 0, a3, a4, a5, a6, a7, a8);
    v20 = sub_1B18760A0(a2, 0, v14, v15, v16, v17, v18, v19);
    v64 = (uint64_t)v13;
    if (v13)
    {
      v27 = (uint64_t)v20;
      Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
      if (Count >= 1)
      {
        for (i = 0; Count != i; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
          v36 = sub_1B1875E70((uint64_t)ValueAtIndex, 0, v30, v31, v32, v33, v34, v35);
          v49 = sub_1B18760A0((uint64_t)ValueAtIndex, 0, v37, v38, v39, v40, v41, v42);
          if (v49)
            v50 = v27 == 0;
          else
            v50 = 1;
          v51 = !v50;
          if (v10 == 1)
          {
            v58 = (const void *)sub_1B17ED3B8(v64, (uint64_t)v36, v43, v44, v45, v46, v47, v48);
            if (v51)
            {
              v59 = sub_1B17ED3B8(v27, (uint64_t)v49, v52, v53, v54, v55, v56, v57);
              goto LABEL_16;
            }
          }
          else
          {
            v58 = (const void *)sub_1B17ED7FC(v64, (uint64_t)v36, v43, v44, v45, v46, v47, v48);
            if (v51)
            {
              v59 = sub_1B17ED7FC(v27, (uint64_t)v49, v60, v61, v54, v55, v56, v57);
LABEL_16:
              v62 = (const void *)v59;
              if (v58)
                goto LABEL_19;
              goto LABEL_22;
            }
          }
          v62 = 0;
          if (v58)
          {
LABEL_19:
            if (a4)
              (*(void (**)(uint64_t, const void *, const void *, const void *))(a4 + 16))(a4, ValueAtIndex, v36, v58);
            sub_1B1875414((uint64_t)ValueAtIndex, v58, 0, 255, v54, v55, v56, v57);
            CFRelease(v58);
          }
LABEL_22:
          if (v62)
          {
            if (a4)
              (*(void (**)(uint64_t, const void *, const void *, const void *))(a4 + 16))(a4, ValueAtIndex, v49, v62);
            sub_1B1875414((uint64_t)ValueAtIndex, v62, 0, 255, v54, v55, v56, v57);
            CFRelease(v62);
          }
        }
      }
    }
    else
    {
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: CFXMorphConvertToCalculationMode: no base source"), v21, v22, v23, v24, v25, v26, a9);
    }
  }
}

uint64_t sub_1B1942C9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"morph");
  return *(unsigned __int8 *)(a1 + 193);
}

uint64_t sub_1B1942CE4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 188);
}

const UInt8 *sub_1B1942CEC(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const UInt8 *result;
  int v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  result = *(const UInt8 **)(a1 + 168);
  if (result
    || (v11 = *(_DWORD *)(a1 + 112) + *(_DWORD *)(a1 + 92) + *(_DWORD *)(a1 + 144)) != 0
    && (*(_QWORD *)(a1 + 168) = malloc_type_malloc(4 * (*(_DWORD *)(a1 + 88) + v11), 0x100004052888210uLL), sub_1B1941E88(a1, v12, v13, v14, v15, v16, v17, v18), (result = *(const UInt8 **)(a1 + 168)) != 0))
  {
    *a2 = *(_DWORD *)(a1 + 112) + *(_DWORD *)(a1 + 92) + *(_DWORD *)(a1 + 144) + *(_DWORD *)(a1 + 88);
  }
  else
  {
    v19 = *(_QWORD *)(a1 + 80);
    if (!v19)
    {
      sub_1B1941C34(a1, 0);
      v19 = *(_QWORD *)(a1 + 80);
    }
    v20 = (_QWORD *)sub_1B18F5B98(v19, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    *a2 = sub_1B18F39CC((uint64_t)v20);
    return sub_1B18F39D4(v20, 0, v21, v22, v23, v24, v25, v26);
  }
  return result;
}

uint64_t sub_1B1942DB8(uint64_t a1, void *key)
{
  const __CFDictionary *v4;
  __CFArray *v5;
  const __CFArray *v6;
  const __CFAllocator *v7;
  __CFDictionary *Mutable;
  CFIndex Count;
  char *v10;
  char *i;
  const void *ValueAtIndex;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const void *v26;
  void *value;

  v4 = *(const __CFDictionary **)(a1 + 176);
  if (!v4)
  {
    v5 = sub_1B1942078(a1);
    if (!v5)
      return -1;
    v6 = v5;
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], 0);
    Count = CFArrayGetCount(v6);
    if (Count >= 1)
    {
      v10 = (char *)Count;
      for (i = 0; i != v10; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v6, (CFIndex)i);
        v26 = (const void *)sub_1B187677C((uint64_t)ValueAtIndex, v13, v14, v15, v16, v17, v18, v19);
        if (!v26)
          sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v20, v21, v22, v23, v24, v25, (uint64_t)"name");
        CFDictionaryAddValue(Mutable, v26, i);
      }
    }
    *(_QWORD *)(a1 + 176) = CFDictionaryCreateCopy(v7, Mutable);
    CFRelease(Mutable);
    CFRelease(v6);
    v4 = *(const __CFDictionary **)(a1 + 176);
  }
  value = 0;
  if (CFDictionaryGetValueIfPresent(v4, key, (const void **)&value))
    return (uint64_t)value;
  else
    return -1;
}

uint64_t sub_1B1942EF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"morph");
  return *(unsigned __int8 *)(a1 + 194);
}

void sub_1B1942F3C(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"morph");
  *(_BYTE *)(a1 + 194) = a2;
}

float sub_1B1942F88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"morph");
  return *(float *)(a1 + 184);
}

void sub_1B1942FD0(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a4, a5, a6, a7, a8, a9, (uint64_t)"morph");
  *(float *)(a1 + 184) = a2;
}

id sub_1B1943028(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  const void *v10;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  sub_1B194F874(CFSTR("kCFXNotificationMorphWillDie"), (const void *)a1, 0, 1u);
  v8 = *(_QWORD *)(a1 + 80);
  if (v8)
    sub_1B18F5C60(v8, 0, v2, v3, v4, v5, v6, v7);
  v9 = *(const void **)(a1 + 72);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v10 = *(const void **)(a1 + 80);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v11 = *(const void **)(a1 + 176);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 176) = 0;
  }
  free(*(void **)(a1 + 168));
  free(*(void **)(a1 + 96));
  free(*(void **)(a1 + 104));
  free(*(void **)(a1 + 120));
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 152));
  free(*(void **)(a1 + 160));
  return sub_1B193E38C(a1, v12, v13, v14, v15, v16, v17, v18);
}

__CFString *sub_1B19430E0(uint64_t a1)
{
  __CFArray *v2;
  const __CFArray *v3;
  CFIndex Count;
  __CFString *Mutable;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float v22;

  v2 = sub_1B1942078(a1);
  v3 = v2;
  if (v2)
    Count = CFArrayGetCount(v2);
  else
    Count = 0;
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v13 = sub_1B193E568(a1, v6, v7, v8, v9, v10, v11, v12);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFXMorph %p \"%@\"\n"), a1, v13);
  CFStringAppendFormat(Mutable, 0, CFSTR("  calc:%d morphNrm:%d targets:%ld\n"), *(unsigned int *)(a1 + 64), *(unsigned __int8 *)(a1 + 192), Count);
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v3, i);
      v22 = sub_1B1942214(a1, i, v16, v17, v18, v19, v20, v21);
      CFStringAppendFormat(Mutable, 0, CFSTR("[%ld] weight:%f %@\n"), i, v22, ValueAtIndex);
    }
  }
  CFStringAppend(Mutable, CFSTR(">"));
  if (v3)
    CFRelease(v3);
  return Mutable;
}

uint64_t sub_1B1943214(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v10;
  const void *v12;

  v10 = (const void *)sub_1B193E634(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B17987F8(v10, a2))
    return a1;
  v12 = *(const void **)(a1 + 80);
  if (!v12)
  {
    sub_1B1941C34(a1, 0);
    v12 = *(const void **)(a1 + 80);
  }
  return sub_1B17C62B4(v12, (uint64_t)a2);
}

__CFArray *sub_1B1943270(uint64_t a1)
{
  __CFArray *Mutable;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  CFStringRef v16;
  __CFDictionary *v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFNumberRef v20;
  const void *v22;
  int v23;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = *(const __CFArray **)(a1 + 72);
  if (v3)
  {
    Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      v5 = Count;
      for (i = 0; i != v5; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
        v15 = (const __CFString *)sub_1B17A0800((uint64_t)ValueAtIndex, v8, v9, v10, v11, v12, v13, v14);
        if (v15)
        {
          v16 = v15;
          CFRetain(v15);
        }
        else
        {
          v16 = CFStringCreateWithFormat(0, 0, CFSTR("<unnamed %d>"), i);
        }
        v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v23 = 1;
        valuePtr = 5;
        v22 = ValueAtIndex;
        v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
        v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
        v20 = CFNumberCreate(0, kCFNumberLongType, &v22);
        CFDictionarySetValue(v17, CFSTR("name"), v16);
        CFDictionarySetValue(v17, CFSTR("type"), v18);
        CFDictionarySetValue(v17, CFSTR("address"), v20);
        CFDictionarySetValue(v17, CFSTR("semantic"), v19);
        CFArrayAppendValue(Mutable, v17);
        CFRelease(v19);
        CFRelease(v17);
        CFRelease(v20);
        CFRelease(v18);
        CFRelease(v16);
      }
    }
  }
  return Mutable;
}

uint64_t sub_1B1943430(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = *(_QWORD *)(result + 80);
    if (v2)
      return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v2);
  }
  return result;
}

void sub_1B1943454(uint64_t a1, _DWORD *a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  char v12;
  int v13;
  uint64_t v14;
  int v15;
  float v16;
  float v17;
  float v18;
  int v19;

  v9 = *a2;
  v10 = *a3;
  if (a4 >= 2)
  {
    v11 = 0;
    v12 = 0;
    v13 = a6 - v9;
    if (a6 < v9)
      v13 = 0;
    v14 = a1 + 4 * v9;
    while (1)
    {
      if (v13 == (_DWORD)v11)
      {
        sub_1B17C4408(16, (uint64_t)CFSTR("Error: Internal consistency error. There should be %d runtime morph target weights, but we the current morph weight index is %d."), (uint64_t)a3, a4, a5, a6, a7, a8, a6);
        return;
      }
      v15 = v11 - a4;
      if ((v12 & 1) != 0)
      {
        *(_DWORD *)(v14 + 4 * v11) = 0;
      }
      else if (a9 >= 1.0)
      {
        if (v15 != -1)
          goto LABEL_16;
        *(float *)(v14 + 4 * v11) = a9;
      }
      else
      {
        if (v15 == -1)
          v16 = 1.0;
        else
          v16 = *(float *)(a5 + 4 * v10);
        if (v16 < a9)
        {
LABEL_16:
          v12 = 0;
          *(_DWORD *)(v14 + 4 * v11) = 0;
          goto LABEL_17;
        }
        if ((_DWORD)v11)
        {
          v17 = *(float *)(a5 + 4 * (v10 - 1));
          v18 = (float)(a9 - v17) / (float)(v16 - v17);
          *(float *)(a1 + 4 * (v9 - 1 + v11)) = 1.0 - v18;
        }
        else
        {
          v18 = a9 / v16;
        }
        *(float *)(v14 + 4 * v11) = v18;
      }
      v12 = 1;
LABEL_17:
      if (v15 != -1)
        ++v10;
      if ((_DWORD)++v11 == (_DWORD)a4)
      {
        v19 = v9 + v11;
        goto LABEL_27;
      }
    }
  }
  v19 = v9 + 1;
  *(float *)(a1 + 4 * v9) = a9;
LABEL_27:
  *a2 = v19;
  *a3 = v10;
}

const __CFArray *sub_1B1943578(uint64_t a1)
{
  const __CFArray *result;
  unsigned int v3;

  result = (const __CFArray *)sub_1B17A0A4C(*(_QWORD *)(a1 + 72));
  if (result)
  {
    result = (const __CFArray *)CFArrayGetCount(result);
    v3 = result;
  }
  else
  {
    v3 = 0;
  }
  if (v3 != *(_DWORD *)(a1 + 96))
  {
    free(*(void **)(a1 + 88));
    if (v3)
      result = (const __CFArray *)malloc_type_calloc(v3, 4uLL, 0x100004052888210uLL);
    else
      result = 0;
    *(_QWORD *)(a1 + 88) = result;
    *(_DWORD *)(a1 + 96) = v3;
    *(_DWORD *)(a1 + 80) = 0;
  }
  return result;
}

uint64_t sub_1B19435F8()
{
  if (qword_1ED4CED80 != -1)
    dispatch_once(&qword_1ED4CED80, &unk_1E63D12B0);
  return qword_1ED4CED88;
}

double sub_1B1943638()
{
  double result;

  if (!qword_1ED4CED88)
  {
    qword_1ED4CED88 = sub_1B179CB60(&qword_1ED4CED88);
    *(_QWORD *)&result = 0x1B1943BD0;
    unk_1ED4BE9D0 = xmmword_1E63D3080;
    unk_1ED4BE9E0 = *(_OWORD *)algn_1E63D3090;
    qword_1ED4BE9F0 = 0;
    unk_1ED4BE9F8 = sub_1B1943B88;
    qword_1ED4BE9B8 = (uint64_t)sub_1B1943BEC;
  }
  return result;
}

uint64_t sub_1B19436AC(const void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  const void *v19;
  CFTypeRef v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;

  if (qword_1ED4CED80 != -1)
    dispatch_once(&qword_1ED4CED80, &unk_1E63D12B0);
  v2 = sub_1B179CB90(qword_1ED4CED88, 0x58uLL);
  v16 = sub_1B17C61FC(v2, v3, v4, v5, v6, v7, v8, v9);
  if (v16)
  {
    v17 = *(void **)(v2 + 72);
    if (v17)
      sub_1B17C5DD0(v17, v16, v10, v11, v12, v13, v14, v15);
  }
  v18 = *(_QWORD *)(v2 + 72);
  if (!v18)
  {
    if (!a1)
      goto LABEL_15;
    goto LABEL_13;
  }
  sub_1B1941858(v18, 0);
  v19 = *(const void **)(v2 + 72);
  if (v19 == a1)
    goto LABEL_15;
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(v2 + 72) = 0;
  }
  if (a1)
  {
LABEL_13:
    v20 = CFRetain(a1);
    goto LABEL_14;
  }
  v20 = 0;
LABEL_14:
  *(_QWORD *)(v2 + 72) = v20;
LABEL_15:
  free(*(void **)(v2 + 88));
  *(_QWORD *)(v2 + 88) = 0;
  *(_DWORD *)(v2 + 100) = 0;
  if (a1)
  {
    sub_1B1941858((uint64_t)a1, v2);
    sub_1B1943578(v2);
  }
  if (v16)
  {
    v27 = *(uint64_t **)(v2 + 72);
    if (v27)
      sub_1B17C5FC0(v27, v16, v21, v22, v23, v24, v25, v26);
  }
  return v2;
}

CFTypeRef *sub_1B19437AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;
  CFTypeRef *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v9 = (const void *)sub_1B19423B8(*(_QWORD *)(a1 + 72), a2, a3, a4, a5, a6, a7, a8);
  v10 = (CFTypeRef *)sub_1B19436AC(v9);
  CFRelease(v9);
  sub_1B193EAC4(a1, v10, v11, v12, v13, v14, v15, v16);
  return v10;
}

uint64_t sub_1B19437FC(uint64_t result)
{
  *(_DWORD *)(result + 100) = 0;
  return result;
}

uint64_t sub_1B1943804(uint64_t a1, int a2, _QWORD *a3, const UInt8 **a4, _DWORD *a5, float *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v26;

  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, (uint64_t)"morpher");
  v14 = *(_QWORD *)(a1 + 72);
  if (!v14)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, (uint64_t)"morph");
  v15 = *(_DWORD *)(a1 + 100);
  v16 = sub_1B1942CE4(v14);
  if (v15 != a2 || v15 == 0)
  {
    v18 = 2;
LABEL_14:
    *(_DWORD *)(a1 + 80) = v16;
    sub_1B1943578(a1);
    *a3 = *(_QWORD *)(a1 + 88);
    v26 = 0;
    *a4 = sub_1B1942CEC(v14, &v26, v19, v20, v21, v22, v23, v24);
    *a5 = v26;
    *a6 = sub_1B194188C(v14);
    return v18;
  }
  if (*(_DWORD *)(a1 + 80) != v16)
  {
    v18 = 1;
    goto LABEL_14;
  }
  return 0;
}

uint64_t sub_1B1943910(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float *v9;
  float v10;
  uint64_t v11;
  float *v12;
  uint64_t result;
  unsigned int v14;

  v14 = 0;
  v9 = (float *)sub_1B1942CEC(*(_QWORD *)(a1 + 72), &v14, a3, a4, a5, a6, a7, a8);
  v10 = sub_1B194188C(*(_QWORD *)(a1 + 72));
  v11 = v14;
  if (v14)
  {
    v12 = *(float **)(a1 + 88);
    do
    {
      if (vabds_f32(*v9, *v12) > v10)
        *v12 = *v9;
      ++v9;
      ++v12;
      --v11;
    }
    while (v11);
  }
  result = (*(_DWORD *)(a1 + 100) + 1);
  *(_DWORD *)(a1 + 100) = result;
  return result;
}

uint64_t sub_1B1943990(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
    sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), a3, a4, a5, a6, a7, a8, (uint64_t)"morpher");
  return *(_QWORD *)(a1 + 64);
}

void sub_1B19439D8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  CFTypeRef v13;
  _BOOL8 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (a2)
    v10 = sub_1B17A0848((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  else
    v10 = 0;
  v11 = *(_QWORD *)(a1 + 64);
  if (v11)
    v11 = sub_1B17A0848(v11, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10 != v11)
  {
    v12 = *(const void **)(a1 + 64);
    if (v12 != a2)
    {
      if (v12)
      {
        CFRelease(v12);
        *(_QWORD *)(a1 + 64) = 0;
      }
      if (a2)
        v13 = CFRetain(a2);
      else
        v13 = 0;
      *(_QWORD *)(a1 + 64) = v13;
    }
    *(_DWORD *)(a1 + 80) = 0;
    if (v10)
    {
      v14 = sub_1B17A289C((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      if (sub_1B18756B0(v10, 1, v14, 0, v15, v16, v17, v18))
        sub_1B1942608(*(_QWORD *)(a1 + 72), v10);
    }
  }
}

id sub_1B1943AA0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;

  v2 = *(_QWORD *)(a1 + 72);
  if (v2)
  {
    sub_1B1941858(v2, 0);
    CFRelease(*(CFTypeRef *)(a1 + 72));
  }
  free(*(void **)(a1 + 88));
  *(_QWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  v10 = *(const void **)(a1 + 64);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 64) = 0;
  }
  return sub_1B193E38C(a1, v3, v4, v5, v6, v7, v8, v9);
}

__CFString *sub_1B1943AFC(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFXMorpher %p baseGeom:%p state:%d\n"), a1, *(_QWORD *)(a1 + 64), *(unsigned int *)(a1 + 80));
  CFStringAppendFormat(Mutable, 0, CFSTR("  morph:%@\n"), *(_QWORD *)(a1 + 72));
  CFStringAppend(Mutable, CFSTR(">"));
  return Mutable;
}

uint64_t sub_1B1943B88(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v10;

  v10 = (const void *)sub_1B193E634(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B17987F8(v10, a2))
    return a1;
  else
    return sub_1B17C62B4(*(const void **)(a1 + 72), (uint64_t)a2);
}

uint64_t sub_1B1943BD0(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 72);
  if (v2)
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v2);
  return result;
}

__CFArray *sub_1B1943BEC(uint64_t a1)
{
  __CFArray *Mutable;
  __CFDictionary *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  uint64_t v8;
  int v9;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v9 = 2;
  valuePtr = 5;
  v8 = a1 + 72;
  v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v9);
  v6 = CFNumberCreate(0, kCFNumberLongType, &v8);
  CFDictionarySetValue(v3, CFSTR("name"), CFSTR("morph"));
  CFDictionarySetValue(v3, CFSTR("type"), v4);
  CFDictionarySetValue(v3, CFSTR("address"), v6);
  CFDictionarySetValue(v3, CFSTR("semantic"), v5);
  CFArrayAppendValue(Mutable, v3);
  CFRelease(v5);
  CFRelease(v3);
  CFRelease(v6);
  CFRelease(v4);
  return Mutable;
}

uint64_t sub_1B1944138(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;

  v14 = 0;
  if (a2)
    v5 = objc_msgSend_newFunctionWithName_constantValues_error_(a3, a2, a1, (uint64_t)a2, &v14);
  else
    v5 = objc_msgSend_newFunctionWithName_(a3, 0, a1, a4);
  v12 = v5;
  if (!v5)
  return v12;
}

id sub_1B19441AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  id v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t j;
  uint64_t v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  void *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v57;

  v5 = sub_1B1944138(*(_QWORD *)(a1 + 296), *(const char **)(a1 + 280), *(void **)(a1 + 104), a4);
  if (!v5)
    return 0;
  v7 = (void *)v5;
  v8 = sub_1B1944138(*(_QWORD *)(a1 + 304), *(const char **)(a1 + 280), *(void **)(a1 + 104), v6);
  if (!v8)
    return 0;
  v9 = (void *)v8;
  v10 = objc_alloc_init(MEMORY[0x1E0CC6B68]);
  objc_msgSend_setVertexFunction_(v10, v11, (uint64_t)v7, v12);

  objc_msgSend_setFragmentFunction_(v10, v13, (uint64_t)v9, v14);
  for (i = 0; i != 8; ++i)
  {
    v19 = *(_QWORD *)(a1 + 112 + 8 * i);
    v20 = (void *)objc_msgSend_colorAttachments(v10, v15, v16, v17);
    v23 = (void *)objc_msgSend_objectAtIndexedSubscript_(v20, v21, i, v22);
    objc_msgSend_setPixelFormat_(v23, v24, v19, v25);
  }
  if (*(_BYTE *)(a1 + 323))
  {
    for (j = 0; j != 8; ++j)
    {
      v31 = *(_QWORD *)(a1 + 208 + 8 * j);
      v32 = (void *)objc_msgSend_colorAttachments(v10, v15, v16, v17);
      v35 = (void *)objc_msgSend_objectAtIndexedSubscript_(v32, v33, j, v34);
      objc_msgSend_setWriteMask_(v35, v36, v31, v37);
    }
  }
  v38 = *(_QWORD *)(a1 + 200);
  if (v38)
    sub_1B18F8B8C(v38, v10, v16, v17, v26, v27, v28, v29);
  objc_msgSend_setVertexDescriptor_(v10, v15, *(_QWORD *)(a1 + 288), v17);
  if (*(unsigned __int8 *)(a1 + 192) <= 1u)
    objc_msgSend_setRasterSampleCount_(v10, v39, 1, v40);
  else
    objc_msgSend_setRasterSampleCount_(v10, v39, *(unsigned __int8 *)(a1 + 192), v40);
  objc_msgSend_setDepthAttachmentPixelFormat_(v10, v41, *(_QWORD *)(a1 + 176), v42);
  objc_msgSend_setStencilAttachmentPixelFormat_(v10, v43, *(_QWORD *)(a1 + 184), v44);
  v47 = *(unsigned __int8 *)(a1 + 67);
  if (v47 >= 2)
    objc_msgSend_setMaxVertexAmplificationCount_(v10, v45, v47, v46);
  v48 = *(_QWORD *)(a1 + 312);
  if (v48)
    (*(void (**)(uint64_t, id))(v48 + 16))(v48, v10);
  if (!objc_msgSend_vertexFunction(v10, v45, v47, v46))
  {
    sub_1B17C4408(0, (uint64_t)CFSTR("Info: Shaders without a vertex function are not allowed"), v50, v51, v52, v53, v54, v55, v57);
    return 0;
  }
  objc_msgSend_setInputPrimitiveTopology_(v10, v49, *(unsigned __int8 *)(a1 + 272), v51);
  return v10;
}

void sub_1B19445C8(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  _BYTE __dst[328];

  if (!a2 && a3)
  {
    v6 = *(_QWORD *)(a1 + 104);
    objc_msgSend_description(a3, 0, (uint64_t)a3, a4);
    sub_1B17C4408(16, (uint64_t)CFSTR("Error: Compiler error while building render pipeline state for node %@:\n%@"), v7, v8, v9, v10, v11, v12, v6);
  }
  objc_msgSend_setState_(*(void **)(a1 + 32), a2, (uint64_t)a2, a4);
  v13 = *(_QWORD *)(a1 + 32) + 32;
  v15 = *(_OWORD *)(a1 + 208);
  v14 = *(_OWORD *)(a1 + 224);
  v16 = *(_OWORD *)(a1 + 192);
  *(_QWORD *)(v13 + 80) = *(_QWORD *)(a1 + 240);
  *(_OWORD *)(v13 + 48) = v15;
  *(_OWORD *)(v13 + 64) = v14;
  *(_OWORD *)(v13 + 32) = v16;
  v17 = *(_OWORD *)(a1 + 176);
  *(_OWORD *)v13 = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(v13 + 16) = v17;
  v21 = objc_msgSend_vertexDescriptor(*(void **)(a1 + 40), v18, v19, v20);
  objc_msgSend_setVertexDescriptor_(*(void **)(a1 + 32), v22, v21, v23);
  v27 = objc_msgSend_vertexFunction(*(void **)(a1 + 40), v24, v25, v26);
  objc_msgSend_setVertexFunction_(*(void **)(a1 + 32), v28, v27, v29);
  v33 = objc_msgSend_fragmentFunction(*(void **)(a1 + 40), v30, v31, v32);
  objc_msgSend_setFragmentFunction_(*(void **)(a1 + 32), v34, v33, v35);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = *(_QWORD *)(a1 + 72);
  memcpy(__dst, (const void *)(a1 + 48), sizeof(__dst));
  sub_1B1954EA0((uint64_t)__dst);
}

void sub_1B19446E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  _QWORD block[6];
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  _BYTE v17[328];
  _BYTE __dst[328];

  v8 = (const void *)(a1 + 64);
  memcpy(__dst, (const void *)(a1 + 64), sizeof(__dst));
  sub_1B1954E40((uint64_t)__dst);
  v12 = objc_msgSend_deviceQueue(*(void **)(*(_QWORD *)(a1 + 32) + 32), v9, v10, v11);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_1B19447C8;
  block[3] = &unk_1E63D9958;
  block[4] = a4;
  block[5] = a2;
  v14 = *(_OWORD *)(a1 + 32);
  v15 = a3;
  memcpy(v17, v8, sizeof(v17));
  v16 = *(_OWORD *)(a1 + 48);
  dispatch_async(v12, block);
}

void sub_1B19447C8(uint64_t a1)
{
  const char *v2;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  _BYTE __dst[328];

  (*(void (**)(void))(*(_QWORD *)(a1 + 80) + 16))();
  if (*(_QWORD *)(a1 + 40))
  {
    objc_msgSend_generateBindingsForPipeline_withReflection_program_material_geometry_pass_(*(void **)(*(_QWORD *)(a1 + 48) + 40), v2, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112));
    objc_msgSend_setState_(*(void **)(a1 + 56), v4, *(_QWORD *)(a1 + 40), v5);
  }
  else
  {
    objc_msgSend_setState_(*(void **)(a1 + 56), v2, 0, v3);
  }
  memcpy(__dst, (const void *)(a1 + 88), sizeof(__dst));
  sub_1B1954EA0((uint64_t)__dst);
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 72));
}

void sub_1B1944860(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1B1944A10(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const void *v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  id v58;
  const char *v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  _BYTE __dst[328];
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;

  v5 = (const void *)(a1 + 48);
  v6 = *(_QWORD *)(a1 + 48);
  v7 = *(_OWORD *)(a1 + 104);
  v78 = *(_OWORD *)(a1 + 88);
  v79 = v7;
  v8 = *(_OWORD *)(a1 + 136);
  v80 = *(_OWORD *)(a1 + 120);
  v81 = v8;
  v9 = *(_OWORD *)(a1 + 72);
  v76 = *(_OWORD *)(a1 + 56);
  v77 = v9;
  v10 = *(_OWORD *)(a1 + 176);
  v70 = *(_OWORD *)(a1 + 160);
  v71 = v10;
  v11 = *(_OWORD *)(a1 + 192);
  v12 = *(_OWORD *)(a1 + 208);
  v13 = *(_OWORD *)(a1 + 224);
  v14 = *(_QWORD *)(a1 + 248);
  v75 = *(_QWORD *)(a1 + 240);
  v73 = v12;
  v74 = v13;
  v72 = v11;
  v15 = *(_OWORD *)(a1 + 304);
  v67 = *(_OWORD *)(a1 + 288);
  v68 = v15;
  v16 = *(_OWORD *)(a1 + 256);
  v17 = *(_OWORD *)(a1 + 272);
  v18 = *(_QWORD *)(a1 + 328);
  v69 = *(_QWORD *)(a1 + 320);
  v65 = v16;
  v66 = v17;
  v20 = *(_QWORD *)(a1 + 336);
  v19 = *(_QWORD *)(a1 + 344);
  v21 = *(_QWORD *)(a1 + 352);
  v64 = *(_OWORD *)(a1 + 360);
  v22 = *(void **)(*(_QWORD *)(a1 + 32) + 32);
  if (a2)
  {
    v23 = (uint64_t)a2;
    if ((const char *)objc_msgSend_commonProfileCacheLibrary(v22, a2, a3, a4) == a2 && v6)
    {
      v19 = sub_1B181E40C(v6, 0, v25, v26, v27, v28, v29, v30);
      v21 = sub_1B181E40C(v6, 1, v31, v32, v33, v34, v35, v36);
    }
  }
  else
  {
    v23 = objc_msgSend_frameworkLibrary(v22, 0, a3, a4);
    v6 = objc_msgSend_defaultProgramUsingTessellation_(*(void **)(a1 + 32), v37, *(_QWORD *)(a1 + 360) != 0, v38);
    v19 = sub_1B181E40C(v6, 0, v39, v40, v41, v42, v43, v44);
    v21 = sub_1B181E40C(v6, 1, v45, v46, v47, v48, v49, v50);
    v18 = sub_1B181E6D8(v6, v51, v52, v53, v54, v55, v56, v57);
    v14 = 0;
  }
  *(_QWORD *)__dst = v6;
  *(_OWORD *)&__dst[40] = v78;
  *(_OWORD *)&__dst[56] = v79;
  *(_OWORD *)&__dst[72] = v80;
  *(_OWORD *)&__dst[88] = v81;
  *(_OWORD *)&__dst[8] = v76;
  *(_OWORD *)&__dst[24] = v77;
  *(_QWORD *)&__dst[104] = v23;
  *(_OWORD *)&__dst[128] = v71;
  *(_OWORD *)&__dst[112] = v70;
  *(_OWORD *)&__dst[176] = v74;
  *(_OWORD *)&__dst[160] = v73;
  *(_OWORD *)&__dst[144] = v72;
  *(_QWORD *)&__dst[192] = v75;
  *(_QWORD *)&__dst[200] = v14;
  *(_OWORD *)&__dst[256] = v68;
  *(_OWORD *)&__dst[240] = v67;
  *(_OWORD *)&__dst[208] = v65;
  *(_OWORD *)&__dst[224] = v66;
  *(_QWORD *)&__dst[272] = v69;
  *(_QWORD *)&__dst[280] = v18;
  *(_QWORD *)&__dst[288] = v20;
  *(_QWORD *)&__dst[296] = v19;
  *(_QWORD *)&__dst[304] = v21;
  *(_OWORD *)&__dst[312] = v64;
  v58 = sub_1B19441AC((uint64_t)__dst, v24, v25, v26);
  if (v58)
  {
    v60 = (uint64_t)v58;
    v61 = *(void **)(a1 + 32);
    v62 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)__dst = v6;
    *(_OWORD *)&__dst[40] = v78;
    *(_OWORD *)&__dst[56] = v79;
    *(_OWORD *)&__dst[72] = v80;
    *(_OWORD *)&__dst[88] = v81;
    *(_OWORD *)&__dst[8] = v76;
    *(_OWORD *)&__dst[24] = v77;
    *(_QWORD *)&__dst[104] = v23;
    *(_OWORD *)&__dst[128] = v71;
    *(_OWORD *)&__dst[112] = v70;
    *(_OWORD *)&__dst[176] = v74;
    *(_OWORD *)&__dst[160] = v73;
    *(_OWORD *)&__dst[144] = v72;
    *(_QWORD *)&__dst[192] = v75;
    *(_QWORD *)&__dst[200] = v14;
    *(_OWORD *)&__dst[256] = v68;
    *(_OWORD *)&__dst[240] = v67;
    *(_OWORD *)&__dst[208] = v65;
    *(_OWORD *)&__dst[224] = v66;
    *(_QWORD *)&__dst[272] = v69;
    *(_QWORD *)&__dst[280] = v18;
    *(_QWORD *)&__dst[288] = v20;
    *(_QWORD *)&__dst[296] = v19;
    *(_QWORD *)&__dst[304] = v21;
    *(_OWORD *)&__dst[312] = v64;
    objc_msgSend__createPipelineStateWithDescriptor_desc_pipeline_(v61, v59, v60, (uint64_t)__dst, v62);
  }
  memcpy(__dst, v5, sizeof(__dst));
  sub_1B1954EA0((uint64_t)__dst);
}

void sub_1B19463F4(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

void sub_1B19464CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198A24C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned int *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_1B19467CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198AC34(*(_OWORD **)(*(_QWORD *)(a1 + 160) + 8), (__int128 *)(a1 + 32), a3, a4, a5, a6, a7, a8);
}

void sub_1B19468FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198A36C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8, *(float *)(a1 + 40));
}

void sub_1B1946A14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198A7E0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned int *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_1B1946B44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198A42C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8, *(float *)(a1 + 40));
}

void sub_1B1946C60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198A4EC(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned __int8 *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_1B1946D80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198A664(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned int *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_1B1946EB8(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198A5A0(*(float32x4_t **)(a1[3].i64[0] + 8), a2, a3, a4, a5, a6, a7, a8, a1[2]);
}

void sub_1B1946FF0(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198A71C(*(float32x4_t **)(a1[3].i64[0] + 8), a2, a3, a4, a5, a6, a7, a8, a1[2]);
}

void sub_1B1947140(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198A94C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8, *(float *)(a1 + 40));
}

void sub_1B1947260(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198AACC(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned int *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_1B1947380(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198A894(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), *(unsigned int *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_1B19474B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B198AA0C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8, *(float *)(a1 + 40));
}

CFStringRef sub_1B194758C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  return sub_1B193E5B0(v5, *(CFStringRef *)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B19478DC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;

  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40), a4);
  if ((sub_1B18C2F24(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 160));
    objc_msgSend_removeObjectForKey_(*(void **)(*(_QWORD *)(a1 + 40) + 168), v10, *(_QWORD *)(a1 + 48), v11);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 160));
  }
}

void sub_1B1947AAC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C30E4(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B1947B58(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C3148(*(void **)(a1 + 32), a2, a3, a4, *(float *)(a1 + 40));
}

void sub_1B1947C14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C2FF4(*(void **)(a1 + 32), *(char **)(a1 + 40), a3, a4);
}

void sub_1B1947CD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B18C3064(*(void **)(a1 + 32), *(char **)(a1 + 40), a3, a4, *(float *)(a1 + 48));
}

void sub_1B19481B8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFXBinding *v24;

  v5 = (_QWORD *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  v24 = objc_alloc_init(CFXBinding);
  v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(_QWORD *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(_QWORD *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(_QWORD *)(a1 + 64), v17);
  sub_1B193F4C8(v5, v24, v18, v19, v20, v21, v22, v23);

}

void sub_1B19482E4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B193F704(v5, *(const __CFString **)(a1 + 40), v6, v7, v8, v9, v10, v11);
}

void sub_1B1948390(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B193F68C(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B1948930(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  _QWORD *v23;
  const void *v24;
  _QWORD *v25;
  _QWORD *v26;
  BOOL v27;

  objc_msgSend_reset(*(void **)(a1 + 16), a2, a3, a4);
  v8 = (void *)objc_msgSend_engine(*(void **)(a1 + 16), v5, v6, v7);
  objc_msgSend_disconnectNodeInput_(v8, v9, *(_QWORD *)(a1 + 16), v10);
  v14 = (void *)objc_msgSend_engine(*(void **)(a1 + 16), v11, v12, v13);
  objc_msgSend_disconnectNodeOutput_(v14, v15, *(_QWORD *)(a1 + 16), v16);
  v20 = (void *)objc_msgSend_engine(*(void **)(a1 + 16), v17, v18, v19);
  objc_msgSend_detachNode_(v20, v21, *(_QWORD *)(a1 + 16), v22);

  v23 = *(_QWORD **)(a1 + 32);
  if (v23 != (_QWORD *)(a1 + 40))
  {
    do
    {
      v24 = (const void *)v23[4];
      if (v24)
        CFRelease(v24);
      v25 = (_QWORD *)v23[1];
      if (v25)
      {
        do
        {
          v26 = v25;
          v25 = (_QWORD *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          v26 = (_QWORD *)v23[2];
          v27 = *v26 == (_QWORD)v23;
          v23 = v26;
        }
        while (!v27);
      }
      v23 = v26;
    }
    while (v26 != (_QWORD *)(a1 + 40));
  }
  sub_1B1805B90(a1 + 32, *(_QWORD **)(a1 + 40));
  return a1;
}

void sub_1B19489FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1B1805B90(v1 + 32, *(_QWORD **)(v1 + 40));
  _Unwind_Resume(a1);
}

id **sub_1B1948A18(id **result, const char *a2, uint64_t a3, uint64_t a4)
{
  id **v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  id *v8;
  id v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  id *v19;
  const char *v20;
  uint64_t v21;
  id v22;
  const char *v23;
  uint64_t v24;
  void *inited;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;

  if (!result[2])
  {
    v4 = result;
    objc_msgSend_lock((*result)[1], a2, a3, a4);
    v8 = *v4;
    if (!v4[2])
    {
      v9 = sub_1B1948B10(v8, v5, v6, v7);
      if (objc_msgSend_mainMixerNode(v9, v10, v11, v12))
      {
        v19 = (id *)objc_alloc_init(MEMORY[0x1E0C89A90]);
        v4[2] = v19;
        objc_msgSend_attachNode_(v9, v20, (uint64_t)v19, v21);
        v22 = objc_alloc(MEMORY[0x1E0C89AA8]);
        inited = (void *)objc_msgSend_initStandardFormatWithSampleRate_channels_(v22, v23, 2, v24, 44100.0);
        v26 = (uint64_t)v4[2];
        v30 = objc_msgSend_mainMixerNode(v9, v27, v28, v29);
        objc_msgSend_connect_to_format_(v9, v31, v26, v30, inited);

      }
      else
      {
        sub_1B17C4408(17, (uint64_t)CFSTR("Assertion '%s' failed. Null argument"), v13, v14, v15, v16, v17, v18, (uint64_t)"mainMixerNode");
      }
      v8 = *v4;
    }
    return (id **)objc_msgSend_unlock(v8[1], v5, v6, v7);
  }
  return result;
}

id sub_1B1948B10(id *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v19;
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_1B19492EC;
  block[3] = &unk_1E63D8F10;
  block[4] = a1;
  if (qword_1EEF665A0 != -1)
    dispatch_once(&qword_1EEF665A0, block);
  objc_msgSend_lock(a1[1], a2, a3, a4);
  if ((objc_msgSend_isRunning(*a1, v5, v6, v7) & 1) == 0)
  {
    v19 = 0;
    if ((objc_msgSend_startAndReturnError_(*a1, v8, (uint64_t)&v19, v10) & 1) == 0)
    {
      v11 = objc_msgSend_description(v19, v8, v9, v10);
      sub_1B17C4408(16, (uint64_t)CFSTR("Error: Error starting the audio engine: %@"), v12, v13, v14, v15, v16, v17, v11);

      *a1 = 0;
    }
  }
  objc_msgSend_unlock(a1[1], v8, v9, v10);
  return *a1;
}

uint64_t sub_1B1948BE4(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  const void *v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  const void *v39;

  sub_1B1948A18((id **)a1, a2, a3, a4);
  v9 = (void *)objc_msgSend_audioPlayer(a2, v6, v7, v8);
  if ((objc_msgSend_customAudioNode(a2, v10, v11, v12) & 1) == 0)
  {
    v16 = sub_1B1948B10(*(id **)a1, v13, v14, v15);
    if ((id)objc_msgSend_engine(v9, v17, v18, v19) != v16)
    {
      v23 = (void *)objc_msgSend_engine(v9, v20, v21, v22);
      objc_msgSend_detachNode_(v23, v24, (uint64_t)v9, v25);
      objc_msgSend_attachNode_(v16, v26, (uint64_t)v9, v27);
    }
    v28 = *(_QWORD *)(a1 + 16);
    v29 = objc_msgSend_audioBufferFormat(a2, v20, v21, v22);
    objc_msgSend_connect_to_format_(v16, v30, (uint64_t)v9, v28, v29);
    if (v9)
      objc_msgSend_play(a2, v13, v14, v15);
  }
  v31 = (const void *)objc_msgSend_nodeRef(a2, v13, v14, v15);
  v39 = v31;
  objc_msgSend_lock(*(void **)(*(_QWORD *)a1 + 8), v32, v33, v34);
  if (v31)
    CFRetain(v31);
  sub_1B1949968((uint64_t **)(a1 + 32), (unint64_t *)&v39, (uint64_t *)&v39);
  return objc_msgSend_unlock(*(void **)(*(_QWORD *)a1 + 8), v35, v36, v37);
}

uint64_t sub_1B1948CF8(id **a1, void *a2, uint64_t a3, uint64_t a4)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t result;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  CFTypeRef cf;

  cf = (CFTypeRef)objc_msgSend_nodeRef(a2, (const char *)a2, a3, a4);
  v9 = sub_1B1948B10(*a1, v6, v7, v8);
  v13 = objc_msgSend_audioNode(a2, v10, v11, v12);
  result = objc_msgSend_detachNode_(v9, v14, v13, v15);
  if (cf)
  {
    objc_msgSend_lock((*a1)[1], v17, v18, v19);
    sub_1B1949A20((uint64_t)(a1 + 4), (unint64_t *)&cf);
    if (cf)
      CFRelease(cf);
    return objc_msgSend_unlock((*a1)[1], v20, v21, v22);
  }
  return result;
}

uint64_t sub_1B1948D90(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const void *v9;
  float32x2_t *v10;
  void *v11;
  double v12;
  double v13;
  double v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  __int32 v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  BOOL v33;
  float32x2_t v34;
  float v35;
  float32x2_t v36;
  __int32 v37;

  if (*(_QWORD *)(result + 16))
  {
    v8 = result;
    v9 = *(const void **)(result + 24);
    if (v9 || (v9 = sub_1B1814984(*(uint64_t **)(v8 + 8), (uint64_t)a2, a3, a4, a5, a6, a7, a8)) != 0)
    {
      v10 = (float32x2_t *)sub_1B1869AC8((uint64_t)v9, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      v11 = *(void **)(v8 + 16);
      LODWORD(v12) = v10[6].i32[0];
      LODWORD(v13) = v10[6].i32[1];
      LODWORD(v14) = v10[7].i32[0];
      objc_msgSend_setListenerPosition_(v11, v15, v16, v17, v12, v13, v14);
      v18 = -v10[5].f32[0];
      v19 = v10[3].i32[0];
      v34 = vneg_f32(v10[4]);
      v35 = v18;
      v36 = v10[2];
      v37 = v19;
      objc_msgSend_setListenerVectorOrientation_(v11, v20, (uint64_t)&v34, v21);
    }
    objc_msgSend_lock(*(void **)(*(_QWORD *)v8 + 8), a2, a3, a4);
    v29 = *(_QWORD **)(v8 + 32);
    if (v29 != (_QWORD *)(v8 + 40))
    {
      do
      {
        v30 = v29[4];
        if (v30)
          sub_1B186D818(v30, (uint64_t)v22, v23, v24, v25, v26, v27, v28);
        v31 = (_QWORD *)v29[1];
        if (v31)
        {
          do
          {
            v32 = v31;
            v31 = (_QWORD *)*v31;
          }
          while (v31);
        }
        else
        {
          do
          {
            v32 = (_QWORD *)v29[2];
            v33 = *v32 == (_QWORD)v29;
            v29 = v32;
          }
          while (!v33);
        }
        v29 = v32;
      }
      while (v32 != (_QWORD *)(v8 + 40));
    }
    return objc_msgSend_unlock(*(void **)(*(_QWORD *)v8 + 8), v22, v23, v24);
  }
  return result;
}

_QWORD *sub_1B1948E94(_QWORD *a1)
{
  *a1 = 0;
  a1[3] = 0;
  a1[2] = a1 + 3;
  a1[4] = 0;
  a1[6] = 0;
  a1[5] = a1 + 6;
  a1[7] = 0;
  a1[1] = objc_alloc_init(MEMORY[0x1E0CB38E0]);
  return a1;
}

void sub_1B1948F00(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD **v3;
  _QWORD **v4;

  sub_1B1805B90(v2, *v4);
  sub_1B1949A98(v1, *v3);
  _Unwind_Resume(a1);
}

_QWORD *sub_1B1948F24()
{
  _QWORD *v0;
  _QWORD *result;

  v0 = (_QWORD *)operator new();
  result = sub_1B1948E94(v0);
  qword_1ED4CEEF0 = (uint64_t)v0;
  return result;
}

void sub_1B1948F64(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E22E18](v1, 0x10A0C40AC8DBCBCLL);
  _Unwind_Resume(a1);
}

_QWORD *sub_1B1948F88(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  BOOL v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  BOOL v27;
  _QWORD *v28;
  uint64_t *v29;
  _QWORD *v31;
  unint64_t v32;
  unint64_t *v33;

  v32 = a2;
  v13 = (_QWORD *)sub_1B1813884(a2, a2, a3, a4, a5, a6, a7, a8);
  v31 = v13;
  if (v13)
  {
    objc_msgSend_lock(*(void **)(a1 + 8), v10, v11, v12, v31, v32);
    v17 = *(_QWORD **)(a1 + 24);
    if (!v17)
      goto LABEL_24;
    v18 = (_QWORD *)(a1 + 24);
    do
    {
      v19 = v17[4];
      v20 = v19 >= (unint64_t)v13;
      if (v19 >= (unint64_t)v13)
        v21 = v17;
      else
        v21 = v17 + 1;
      if (v20)
        v18 = v17;
      v17 = (_QWORD *)*v21;
    }
    while (*v21);
    if (v18 == (_QWORD *)(a1 + 24))
      goto LABEL_24;
    if ((unint64_t)v13 < v18[4])
      goto LABEL_24;
    v24 = (_QWORD *)v18[6];
    v22 = v18 + 6;
    v23 = v24;
    if (!v24)
      goto LABEL_24;
    v25 = v22;
    do
    {
      v26 = v23[4];
      v27 = v26 >= a2;
      if (v26 >= a2)
        v28 = v23;
      else
        v28 = v23 + 1;
      if (v27)
        v25 = v23;
      v23 = (_QWORD *)*v28;
    }
    while (*v28);
    if (v25 != v22 && v25[4] <= a2)
    {
      v13 = (_QWORD *)v25[5];
    }
    else
    {
LABEL_24:
      v13 = (_QWORD *)operator new();
      *v13 = a1;
      v13[1] = a2;
      v13[5] = 0;
      v13[6] = 0;
      v13[2] = 0;
      v13[3] = 0;
      v13[4] = v13 + 5;
      v33 = (unint64_t *)&v31;
      v29 = sub_1B1949AE4((uint64_t **)(a1 + 16), (unint64_t *)&v31, (uint64_t)&unk_1B22458B0, (uint64_t **)&v33);
      v33 = &v32;
      sub_1B181D66C((uint64_t **)v29 + 5, &v32, (uint64_t)&unk_1B22458B0, (uint64_t **)&v33)[5] = (uint64_t)v13;
    }
    objc_msgSend_unlock(*(void **)(a1 + 8), v14, v15, v16);
  }
  return v13;
}

uint64_t sub_1B19490EC(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  BOOL v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t *v23;
  unint64_t v24;
  BOOL v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t *v31;
  unint64_t v32;
  BOOL v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t *v38;
  BOOL v39;

  v10 = sub_1B1813884(a2, a2, a3, a4, a5, a6, a7, a8);
  objc_msgSend_lock(*(void **)(a1 + 8), v11, v12, v13);
  if (v10)
  {
    v17 = *(_QWORD **)(a1 + 24);
    if (v17)
    {
      v18 = a1 + 24;
      do
      {
        v19 = v17[4];
        v20 = v19 >= v10;
        if (v19 >= v10)
          v21 = v17;
        else
          v21 = v17 + 1;
        if (v20)
          v18 = (uint64_t)v17;
        v17 = (_QWORD *)*v21;
      }
      while (*v21);
      if (v18 != a1 + 24 && v10 >= *(_QWORD *)(v18 + 32))
      {
        v22 = *(_QWORD **)(v18 + 48);
        if (v22)
        {
          v23 = (uint64_t *)(v18 + 48);
          do
          {
            v24 = v22[4];
            v25 = v24 >= a2;
            if (v24 >= a2)
              v26 = v22;
            else
              v26 = v22 + 1;
            if (v25)
              v23 = v22;
            v22 = (_QWORD *)*v26;
          }
          while (*v26);
          if (v23 != (uint64_t *)(v18 + 48) && v23[4] <= a2)
          {
            v27 = v23[5];
            if (v27)
            {
              v28 = sub_1B1948930(v27, v14, v15, v16);
              MEMORY[0x1B5E22E18](v28, 0x10A0C406E04462DLL);
            }
            sub_1B181D914((uint64_t **)(v18 + 40), v23);
            operator delete(v23);
          }
        }
        if (!*(_QWORD *)(v18 + 56))
          sub_1B1949BAC((uint64_t **)(a1 + 16), v18);
      }
    }
  }
  else
  {
    v29 = *(_QWORD *)(a1 + 16);
    if (v29 != a1 + 24)
    {
      do
      {
        v30 = *(_QWORD **)(v29 + 48);
        if (v30)
        {
          v31 = (uint64_t *)(v29 + 48);
          do
          {
            v32 = v30[4];
            v33 = v32 >= a2;
            if (v32 >= a2)
              v34 = v30;
            else
              v34 = v30 + 1;
            if (v33)
              v31 = v30;
            v30 = (_QWORD *)*v34;
          }
          while (*v34);
          if (v31 != (uint64_t *)(v29 + 48) && v31[4] <= a2)
          {
            v35 = v31[5];
            if (v35)
            {
              v36 = sub_1B1948930(v35, v14, v15, v16);
              MEMORY[0x1B5E22E18](v36, 0x10A0C406E04462DLL);
            }
            sub_1B181D914((uint64_t **)(v29 + 40), v31);
            operator delete(v31);
          }
        }
        if (*(_QWORD *)(v29 + 56))
        {
          v37 = *(uint64_t **)(v29 + 8);
          if (v37)
          {
            do
            {
              v38 = v37;
              v37 = (uint64_t *)*v37;
            }
            while (v37);
          }
          else
          {
            do
            {
              v38 = *(uint64_t **)(v29 + 16);
              v39 = *v38 == v29;
              v29 = (uint64_t)v38;
            }
            while (!v39);
          }
        }
        else
        {
          v38 = sub_1B1949BAC((uint64_t **)(a1 + 16), v29);
        }
        v29 = (uint64_t)v38;
      }
      while (v38 != (uint64_t *)(a1 + 24));
    }
  }
  return objc_msgSend_unlock(*(void **)(a1 + 8), v14, v15, v16);
}

