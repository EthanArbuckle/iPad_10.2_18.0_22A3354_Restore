_QWORD *MIL::AbstractConstExpr::AbstractConstExpr(_QWORD *this)
{
  *this = off_1EA9929A0;
  return this;
}

void MIL::Conversion::CopyTensorValue(MIL::Conversion *this@<X0>, MIL::MILContext *a2@<X1>, const MIL::IRTensorValueType *a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  const void *Data;
  uint64_t v29;
  uint64_t v30;
  const void *v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  std::logic_error *exception;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t v39;

  if ((*(unsigned int (**)(const MIL::IRTensorValueType *))(*(_QWORD *)a3 + 80))(a3))
  {
    v9 = (*(uint64_t (**)(const MIL::IRTensorValueType *))(*(_QWORD *)a3 + 88))(a3);
    std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)&v37, v9);
    MIL::IRTensorValueType::MakeValueFromFileProperties((std::string::size_type)a2, (uint64_t)this, &v37);
    *a4 = v36;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&v37);
  }
  else
  {
    switch((*(unsigned int (**)(MIL::MILContext *))(*(_QWORD *)a2 + 88))(a2))
    {
      case 4u:
        v10 = (const void *)MIL::IRTensorValue::GetDataView<MIL::Fp16>((uint64_t *)a3);
        v11 = MIL::IRTensorValue::GetDataView<MIL::Fp16>((uint64_t *)a3);
        v38 = 0;
        v39 = 0;
        v37 = 0;
        std::vector<MIL::Fp16>::__init_with_size[abi:ne180100]<MIL::Fp16 const*,MIL::Fp16 const*>(&v37, v10, v11 + 2 * v12, (v11 + 2 * v12 - (uint64_t)v10) >> 1);
        MIL::IRTensorValueType::MakeFloat16Value((uint64_t)a2, (uint64_t)&v37, &v36);
        break;
      case 5u:
        Data = (const void *)MIL::IRTensorValue::GetDataView<float>((uint64_t *)a3);
        v29 = MIL::IRTensorValue::GetDataView<float>((uint64_t *)a3);
        v38 = 0;
        v39 = 0;
        v37 = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float const*,float const*>(&v37, Data, v29 + 4 * v30, (v29 + 4 * v30 - (uint64_t)Data) >> 2);
        MIL::IRTensorValueType::MakeFloat32Value((uint64_t)a2, (uint64_t)&v37, &v36);
        break;
      case 9u:
        v13 = (const void *)MIL::IRTensorValue::GetDataView<signed char>((uint64_t *)a3);
        v14 = MIL::IRTensorValue::GetDataView<signed char>((uint64_t *)a3);
        v38 = 0;
        v39 = 0;
        v37 = 0;
        std::vector<signed char>::__init_with_size[abi:ne180100]<signed char const*,signed char const*>(&v37, v13, v14 + v15, v14 + v15 - (_QWORD)v13);
        MIL::IRTensorValueType::MakeInt8Value((uint64_t)a2, (uint64_t)&v37, &v36);
        break;
      case 0xEu:
        v16 = (const void *)MIL::IRTensorValue::GetDataView<unsigned char>(a3);
        v17 = MIL::IRTensorValue::GetDataView<unsigned char>(a3);
        v38 = 0;
        v39 = 0;
        v37 = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&v37, v16, v17 + v18, v17 + v18 - (_QWORD)v16);
        MIL::IRTensorValueType::MakeUInt8Value((uint64_t)a2, (uint64_t)&v37, &v36);
        break;
      case 0x13u:
        v19 = (const void *)MIL::IRTensorValue::GetDataView<unsigned char>(a3);
        v20 = MIL::IRTensorValue::GetDataView<unsigned char>(a3);
        v38 = 0;
        v39 = 0;
        v37 = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&v37, v19, v20 + v21, v20 + v21 - (_QWORD)v19);
        MIL::IRTensorValueType::MakeUInt2Value((uint64_t)a2, (uint64_t)&v37, &v36);
        break;
      case 0x14u:
        v22 = (const void *)MIL::IRTensorValue::GetDataView<unsigned char>(a3);
        v23 = MIL::IRTensorValue::GetDataView<unsigned char>(a3);
        v38 = 0;
        v39 = 0;
        v37 = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&v37, v22, v23 + v24, v23 + v24 - (_QWORD)v22);
        MIL::IRTensorValueType::MakeUInt4Value((uint64_t)a2, (uint64_t)&v37, &v36);
        break;
      case 0x15u:
        v31 = (const void *)MIL::IRTensorValue::GetDataView<unsigned char>(a3);
        v32 = MIL::IRTensorValue::GetDataView<unsigned char>(a3);
        v38 = 0;
        v39 = 0;
        v37 = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&v37, v31, v32 + v33, v32 + v33 - (_QWORD)v31);
        MIL::IRTensorValueType::MakeUInt1Value((uint64_t)a2, (uint64_t)&v37, &v36);
        break;
      case 0x17u:
        v25 = (const void *)MIL::IRTensorValue::GetDataView<unsigned char>(a3);
        v26 = MIL::IRTensorValue::GetDataView<unsigned char>(a3);
        v38 = 0;
        v39 = 0;
        v37 = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&v37, v25, v26 + v27, v26 + v27 - (_QWORD)v25);
        MIL::IRTensorValueType::MakeUInt6Value((uint64_t)a2, (uint64_t)&v37, &v36);
        break;
      default:
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::invalid_argument::invalid_argument[abi:ne180100](exception, "Unsupported type in CopyTensorValue.");
        __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
    }
    v34 = v37;
    *a4 = v36;
    v36 = 0;
    if (v34)
    {
      v38 = v34;
      operator delete(v34);
    }
  }
}

void sub_1E056BC44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  void *v11;

  __cxa_free_exception(v11);
  _Unwind_Resume(a1);
}

std::logic_error *std::invalid_argument::invalid_argument[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
  return result;
}

void MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  std::string *v4;
  int v5;
  std::string __p;

  if (*(char *)(a1 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  else
    __p = *(std::string *)a1;
  *(_QWORD *)(a2 + 24) = 0;
  v3 = operator new(0x20uLL);
  *v3 = off_1EA9929E8;
  v4 = (std::string *)(v3 + 1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v4, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    v5 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    *(_QWORD *)(a2 + 24) = v3;
    if (v5 < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    v3[3] = *((_QWORD *)&__p.__r_.__value_.__l + 2);
    *(_QWORD *)(a2 + 24) = v3;
  }
}

void sub_1E056BD64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;

  operator delete(v14);
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  std::string *v4;
  int v5;
  std::string __p;

  if (*(char *)(a1 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  else
    __p = *(std::string *)a1;
  *(_QWORD *)(a2 + 24) = 0;
  v3 = operator new(0x20uLL);
  *v3 = off_1EA992AD8;
  v4 = (std::string *)(v3 + 1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v4, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    v5 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    *(_QWORD *)(a2 + 24) = v3;
    if (v5 < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    v3[3] = *((_QWORD *)&__p.__r_.__value_.__l + 2);
    *(_QWORD *)(a2 + 24) = v3;
  }
}

void sub_1E056BE34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;

  operator delete(v14);
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA992B58;
  a1[3] = a1;
}

void MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA992C38;
  a1[3] = a1;
}

void MIL::Conversion::MakeIos17ToIos18ConstCastTransform(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA992CB8;
  a1[3] = a1;
}

void MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA992D38;
  a1[3] = a1;
}

void MIL::Conversion::MakeIos18DecompositionSDPATransform(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA992DB8;
  a1[3] = a1;
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1EA992580, MEMORY[0x1E0DE42D0]);
}

void sub_1E056BFB0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E0DE4E98], MEMORY[0x1E0DE4390]);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>,0>(uint64_t a1)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 24);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::~pair(uint64_t a1)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 24);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

uint64_t std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned __int8 **)(a2 + 16); i; i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRValue const>> const&>(a1, i + 16, (__int128 *)i + 1);
  return a1;
}

void sub_1E056C1AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRValue const>> const&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__construct_node_hash<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1E056C660(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__construct_node_hash<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x38uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100]((std::string *)(v8 + 16), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1E056C6D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

unint64_t std::__string_hash<char>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v3 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v3 = v2;
  }
  return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v5, (uint64_t *)a2, v3);
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;

  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      v4 = *(uint64_t *)((char *)a2 + a3 - 48);
      v5 = *(uint64_t *)((char *)a2 + a3 - 40);
      v6 = *(uint64_t *)((char *)a2 + a3 - 24);
      v8 = *(uint64_t *)((char *)a2 + a3 - 64);
      v7 = *(uint64_t *)((char *)a2 + a3 - 56);
      v9 = *(uint64_t *)((char *)a2 + a3 - 16);
      v10 = *(uint64_t *)((char *)a2 + a3 - 8);
      v11 = v7 + v9;
      v12 = 0x9DDFEA08EB382D69
          * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))));
      v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      v14 = v8 + a3 + v7 + v4;
      v15 = v14 + v5;
      v16 = __ROR8__(v14, 44) + v8 + a3 + __ROR8__(v5 + v8 + a3 - 0x622015F714C7D297 * (v12 ^ (v12 >> 47)), 21);
      v17 = v7 + v9 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      v18 = v17 + v6 + v9;
      v19 = __ROR8__(v18, 44);
      v20 = v18 + v10;
      v21 = v19 + v17 + __ROR8__(v17 + v5 + v10, 21);
      v23 = *a2;
      v22 = a2 + 4;
      v24 = v23 - 0x4B6D499041670D8DLL * v5;
      v25 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        v26 = *(v22 - 3);
        v27 = v24 + v15 + v11 + v26;
        v28 = v22[2];
        v29 = v22[3];
        v30 = v22[1];
        v11 = v30 + v15 - 0x4B6D499041670D8DLL * __ROR8__(v11 + v16 + v28, 42);
        v31 = v13 + v20;
        v32 = *(v22 - 2);
        v33 = *(v22 - 1);
        v34 = *(v22 - 4) - 0x4B6D499041670D8DLL * v16;
        v35 = v34 + v20 + v33;
        v36 = v34 + v26 + v32;
        v15 = v36 + v33;
        v37 = __ROR8__(v36, 44) + v34;
        v38 = (0xB492B66FBE98F273 * __ROR8__(v27, 37)) ^ v21;
        v24 = 0xB492B66FBE98F273 * __ROR8__(v31, 33);
        v16 = v37 + __ROR8__(v35 + v38, 21);
        v39 = v24 + v21 + *v22;
        v20 = v39 + v30 + v28 + v29;
        v21 = __ROR8__(v39 + v30 + v28, 44) + v39 + __ROR8__(v11 + v32 + v39 + v29, 21);
        v22 += 8;
        v13 = v38;
        v25 += 64;
      }
      while (v25);
      v40 = v24
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) >> 47));
      v41 = 0x9DDFEA08EB382D69
          * (v40 ^ (v38
                  - 0x4B6D499041670D8DLL * (v11 ^ (v11 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) ^ ((0x9DDFEA08EB382D69 * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
    }
    else
    {
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:ne180100](a2, a3);
    }
  }
  else if (a3 > 0x10)
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:ne180100](a2, a3);
  }
  else
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:ne180100](a2, a3);
  }
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:ne180100](_DWORD *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t result;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  if (a2 < 9)
  {
    if (a2 < 4)
    {
      result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        v8 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      v7 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }
  else
  {
    v3 = *(_QWORD *)((char *)a1 + a2 - 8);
    v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)))) >> 47))) ^ v3;
  }
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v2 = a1[1];
  v3 = 0xB492B66FBE98F273 * *a1;
  v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)a1 + a2 - 8);
  v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v4 - 0x3C5A37A36834CED9 * *(_QWORD *)((char *)a1 + a2 - 16)));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v2 = *(_QWORD *)((char *)a1 + a2 - 16);
  v3 = *a1 - 0x3C5A37A36834CED9 * (v2 + a2);
  v5 = a1[2];
  v4 = a1[3];
  v6 = __ROR8__(v3 + v4, 52);
  v7 = v3 + a1[1];
  v8 = __ROR8__(v7, 7);
  v9 = v7 + v5;
  v10 = *(_QWORD *)((char *)a1 + a2 - 32) + v5;
  v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  v12 = *(_QWORD *)((char *)a1 + a2 - 24) + v10 + v2;
  v13 = 0xC3A5C85C97CB3127 * (v12 + *(_QWORD *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(_QWORD *)((char *)a1 + a2 - 24) + v10, 7)
       + __ROR8__(*(_QWORD *)((char *)a1 + a2 - 8) + v4 + v10, 52)
       + __ROR8__(v12, 31));
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) >> 47));
}

uint64_t std::equal_to<std::string>::operator()[abi:ne180100](uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v14;
  uint64_t result;

  v3 = a3;
  v4 = a2[23];
  if ((v4 & 0x80u) == 0)
    v5 = a2[23];
  else
    v5 = *((_QWORD *)a2 + 1);
  v6 = a3[23];
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *((_QWORD *)a3 + 1);
  if (v5 != v6)
    return 0;
  if (v7 < 0)
    v3 = *(unsigned __int8 **)a3;
  if ((v4 & 0x80) != 0)
    return memcmp(*(const void **)a2, v3, *((_QWORD *)a2 + 1)) == 0;
  if (!a2[23])
    return 1;
  v8 = v4 - 1;
  do
  {
    v10 = *a2++;
    v9 = v10;
    v12 = *v3++;
    v11 = v12;
    v14 = v8-- != 0;
    result = v9 == v11;
  }
  while (v9 == v11 && v14);
  return result;
}

std::string *std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v4;
  std::string::size_type v5;
  unint64_t *v6;
  unint64_t v7;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  v5 = *((_QWORD *)a2 + 4);
  this[1].__r_.__value_.__r.__words[0] = *((_QWORD *)a2 + 3);
  this[1].__r_.__value_.__l.__size_ = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return this;
}

{
  __int128 v4;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = *(__int128 *)((char *)a2 + 24);
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 4) = 0;
  return this;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

_QWORD *std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(_QWORD *result, const void *a2, uint64_t a3, size_t __sz)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (__sz)
  {
    v6 = result;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1E056CD44(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__vallocate[abi:ne180100](_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void std::vector<unsigned char>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

_QWORD *std::vector<signed char>::__init_with_size[abi:ne180100]<signed char const*,signed char const*>(_QWORD *result, const void *a2, uint64_t a3, size_t __sz)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (__sz)
  {
    v6 = result;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1E056CE10(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<MIL::Fp16>::__init_with_size[abi:ne180100]<MIL::Fp16 const*,MIL::Fp16 const*>(_QWORD *result, const void *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1E056CE88(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<MIL::Fp16>::__vallocate[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 < 0)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(2 * a2);
}

_QWORD *std::vector<float>::__init_with_size[abi:ne180100]<float const*,float const*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1E056CF6C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

uint64_t std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9929E8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9929E8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1E0C023A0);
}

_QWORD *std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  std::string *v3;

  v2 = operator new(0x20uLL);
  *v2 = off_1EA9929E8;
  v3 = (std::string *)(v2 + 1);
  if (*(char *)(a1 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 8), *(_QWORD *)(a1 + 16));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 8);
    v2[3] = *(_QWORD *)(a1 + 24);
  }
  return v2;
}

void sub_1E056D0E4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone(uint64_t a1, _QWORD *a2)
{
  std::string *v2;
  __int128 v3;

  *a2 = off_1EA9929E8;
  v2 = (std::string *)(a2 + 1);
  if (*(char *)(a1 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a1 + 8), *(_QWORD *)(a1 + 16));
  }
  else
  {
    v3 = *(_OWORD *)(a1 + 8);
    v2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 24);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::destroy(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
}

void std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::destroy_deallocate(void **__p)
{
  if (*((char *)__p + 31) < 0)
    operator delete(__p[1]);
  operator delete(__p);
}

void std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::operator()(uint64_t a1, uint64_t **a2, _QWORD *a3)
{
  uint64_t Operator;
  uint64_t *i;
  unint64_t *v7;
  int v8;
  int *v9;
  int v10;
  int v11;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t **v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  int v25;
  uint64_t Value;
  const void *v29;
  int v30;
  void (***MILContext)(MIL::MILContextImpl *__hidden);
  void (***v32)(MIL::MILContextImpl *__hidden);
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t n;
  _QWORD *v37;
  uint64_t v38;
  unint64_t NumOutputs;
  __n128 *v40;
  uint64_t v41;
  MIL::MatchingPrivate::MatchItem *v42;
  _QWORD *v43;
  _QWORD *v44;
  unint64_t v45;
  __n128 v46;
  char v47;
  __n128 v48[2];
  __n128 v49[2];
  __n128 v50;
  char v51;
  void *__p;
  _BYTE v53[15];
  char v54;
  const char *v55;
  _BYTE v56[32];
  const char *v57;
  _BYTE v58[32];
  __n128 v59[2];
  __n128 v60[2];
  __n128 v61[2];
  uint64_t v62[2];
  uint64_t v63[2];
  uint64_t v64[3];

  v64[2] = *MEMORY[0x1E0C80C00];
  MIL::Matching::MatchView::MatchView(&v42, a3);
  v43 = 0;
  v44 = 0;
  v45 = 0;
  Operator = MIL::Matching::MatchView::GetOperator(&v42);
  for (i = *(uint64_t **)((*(uint64_t (**)(uint64_t))(*(_QWORD *)Operator + 64))(Operator) + 16);
        i;
        i = (uint64_t *)*i)
  {
    v7 = (unint64_t *)(i + 2);
    v8 = *((char *)i + 39);
    if (v8 < 0)
    {
      if (i[3] != 7)
        goto LABEL_11;
      v9 = (int *)*v7;
    }
    else
    {
      v9 = (int *)(i + 2);
      if (v8 != 7)
        goto LABEL_11;
    }
    v10 = *v9;
    v11 = *(int *)((char *)v9 + 3);
    if (v10 != 1768189545 || v11 != 1936024425)
    {
LABEL_11:
      if (MIL::Matching::MatchView::GetArgumentCount(&v42, (const void **)i + 2))
      {
        v13 = (unint64_t)(i + 2);
        if (*((char *)i + 39) < 0)
          v13 = *v7;
        MIL::Matching::MatchView::GetArgument(&v42, (uint64_t)(i + 2), (uint64_t *)v61);
        v46.n128_u64[0] = v13;
        MIL::Matching::ArgumentView::ArgumentView((__n128 *)&v46.n128_i8[8], v61);
        __p = (void *)v46.n128_u64[0];
        MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v53, (const MIL::Matching::ArgumentView *)&v46.n128_i8[8]);
        v14 = v44;
        if ((unint64_t)v44 >= v45)
        {
          v15 = std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__push_back_slow_path<std::pair<char const*,MIL::Transform::ArgumentDescription> const>((uint64_t *)&v43, &__p);
        }
        else
        {
          *v44 = __p;
          MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)(v14 + 1), (const MIL::Transform::ArgumentDescription *)v53);
          v15 = (uint64_t)(v14 + 5);
        }
        v44 = (_QWORD *)v15;
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)v53);
        MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)&v46.n128_i8[8]);
        MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v61);
      }
    }
  }
  MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)&v46, 1);
  __p = "validate_indices";
  MIL::Transform::ArgumentDescription::ArgumentDescription(v53, &v46);
  v16 = v44;
  if ((unint64_t)v44 >= v45)
  {
    v17 = std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__push_back_slow_path<std::pair<char const*,MIL::Transform::ArgumentDescription> const>((uint64_t *)&v43, &__p);
  }
  else
  {
    *v44 = __p;
    MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)(v16 + 1), (const MIL::Transform::ArgumentDescription *)v53);
    v17 = (uint64_t)(v16 + 5);
  }
  v44 = (_QWORD *)v17;
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)v53);
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v46);
  std::string::basic_string[abi:ne180100]<0>(&__p, "indices");
  MIL::Matching::MatchView::GetArgument(&v42, (uint64_t)&__p, v64);
  if (v54 < 0)
    operator delete(__p);
  v18 = (uint64_t **)(a1 + 8);
  if ((*(char *)(a1 + 31) & 0x80000000) == 0)
  {
    if (*(_BYTE *)(a1 + 31) == 6)
    {
      if (*(_DWORD *)v18 != 1752457575 || *(_WORD *)(a1 + 12) != 29285)
        goto LABEL_46;
      goto LABEL_40;
    }
    v19 = (uint64_t *)(a1 + 8);
    if (*(_BYTE *)(a1 + 31) != 17)
      goto LABEL_46;
    goto LABEL_31;
  }
  v20 = *(_QWORD *)(a1 + 16);
  if (v20 == 6)
  {
    v23 = *((unsigned __int16 *)*v18 + 2);
    v24 = *(_DWORD *)*v18 == 1752457575;
    v25 = 29285;
    goto LABEL_42;
  }
  if (v20 == 17)
  {
    v19 = *v18;
LABEL_31:
    v21 = *v19;
    v22 = v19[1];
    v23 = *((unsigned __int8 *)v19 + 16);
    v24 = v21 == 0x615F726568746167 && v22 == 0x6978615F676E6F6CLL;
    v25 = 115;
LABEL_42:
    if (!v24 || v23 != v25)
      goto LABEL_46;
LABEL_40:
    std::string::basic_string[abi:ne180100]<0>(&__p, "x");
    MIL::Matching::MatchView::GetArgument(&v42, (uint64_t)&__p, v63);
    goto LABEL_47;
  }
LABEL_46:
  std::string::basic_string[abi:ne180100]<0>(&__p, "data");
  MIL::Matching::MatchView::GetArgument(&v42, (uint64_t)&__p, v63);
LABEL_47:
  if (v54 < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "axis");
  MIL::Matching::MatchView::GetArgument(&v42, (uint64_t)&__p, v62);
  if (v54 < 0)
    operator delete(__p);
  Value = MIL::Matching::ArgumentView::TryGetValue((MIL::Matching::ArgumentView *)v62);
  v29 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)Value + 40))(Value);
  v30 = MIL::IRValue::GetScalar<int>(v29);
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v53, (const MIL::Matching::ArgumentView *)v63);
  v46.n128_u64[0] = (unint64_t)&__p;
  v46.n128_u64[1] = 1;
  MIL::Transform::MatchContext::AddOperation(a2, "ios17::shape", (uint64_t *)&v46, v61);
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)v53);
  std::string::basic_string[abi:ne180100]<0>(&__p, "ios17");
  MILContext = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext((MIL::Transform::MatchContext *)a2);
  if (v54 < 0)
    operator delete(__p);
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v53, v61);
  std::string::basic_string[abi:ne180100]<0>(&v50, "ios17");
  v32 = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext((MIL::Transform::MatchContext *)a2);
  v55 = "begin";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v56, &v46);
  v57 = "size";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v58, v60);
  v49[0].n128_u64[0] = (unint64_t)&__p;
  v49[0].n128_u64[1] = 3;
  MIL::Transform::MatchContext::AddOperation(a2, "ios17::slice_by_size", (uint64_t *)v49, v59);
  for (j = 88; j != -32; j -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v53[j - 8]);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v46);
  if (v51 < 0)
    operator delete((void *)v50.n128_u64[0]);
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v53, (const MIL::Matching::ArgumentView *)v64);
  v55 = "y";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v56, v59);
  v46.n128_u64[0] = (unint64_t)&__p;
  v46.n128_u64[1] = 2;
  MIL::Transform::MatchContext::AddOperation(a2, "ios17::add", (uint64_t *)&v46, &v50);
  for (k = 48; k != -32; k -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v53[k - 8]);
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v53, (const MIL::Matching::ArgumentView *)v64);
  v55 = "y";
  MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v56, 0);
  v46.n128_u64[0] = (unint64_t)&__p;
  v46.n128_u64[1] = 2;
  MIL::Transform::MatchContext::AddOperation(a2, "ios17::less", (uint64_t *)&v46, v49);
  for (m = 48; m != -32; m -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v53[m - 8]);
  __p = "cond";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v53, v49);
  v55 = "a";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v56, &v50);
  v57 = "b";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v58, (const MIL::Matching::ArgumentView *)v64);
  v46.n128_u64[0] = (unint64_t)&__p;
  v46.n128_u64[1] = 3;
  MIL::Transform::MatchContext::AddOperation(a2, "ios17::select", (uint64_t *)&v46, v48);
  for (n = 88; n != -32; n -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v53[n - 8]);
  v46.n128_u64[0] = (unint64_t)"indices";
  MIL::Transform::NewOperationOutput::NewOperationOutput((__n128 *)&v46.n128_i8[8], v48);
  __p = (void *)v46.n128_u64[0];
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v53, (__n128 *)&v46.n128_i8[8]);
  v37 = v44;
  if ((unint64_t)v44 >= v45)
  {
    v38 = std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__push_back_slow_path<std::pair<char const*,MIL::Transform::ArgumentDescription> const>((uint64_t *)&v43, &__p);
  }
  else
  {
    *v44 = __p;
    MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)(v37 + 1), (const MIL::Transform::ArgumentDescription *)v53);
    v38 = (uint64_t)(v37 + 5);
  }
  v44 = (_QWORD *)v38;
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)v53);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v46.n128_i8[8]);
  std::operator+<char>();
  NumOutputs = MIL::Matching::MatchView::GetNumOutputs(&v42);
  if (v47 >= 0)
    v40 = &v46;
  else
    v40 = (__n128 *)v46.n128_u64[0];
  if (v44 == v43)
    v41 = 0;
  else
    v41 = (uint64_t)v43;
  MIL::Transform::MatchContext::AddMultiOutputOperation(a2, (char *)v40, NumOutputs, v41, 0xCCCCCCCCCCCCCCCDLL * (v44 - v43), &__p);
  MIL::Transform::NewOperationOutputList::~NewOperationOutputList((MIL::Transform::NewOperationOutputList *)&__p);
  if (v47 < 0)
    operator delete((void *)v46.n128_u64[0]);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v48);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v49);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v50);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v59);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v60);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v61);
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v62);
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v63);
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v64);
  v46.n128_u64[0] = (unint64_t)&v43;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v46);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&v42);
}

void sub_1E056D93C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, __int16 *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  uint64_t v45;

  if (a45 < 0)
    operator delete(__p);
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)(v45 - 104));
  a17 = &a12;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target_type()
{
}

void `anonymous namespace'::GetConstantIntTensor(int a1@<W0>, const void **a2@<X1>, void (***a3)(MIL::MILContextImpl *__hidden this)@<X2>, uint64_t **a4@<X3>, _QWORD *a5@<X8>)
{
  size_t v10;
  void **v11;
  const void *v12;
  char *v13;
  _QWORD *v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  void *__p;
  void *v19;
  _DWORD *v20;
  void *v21;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  _BYTE v25[40];
  uint64_t v26[2];
  void *v27[2];
  char v28;
  void *v29[2];
  char v30;
  _QWORD v31[3];

  v31[2] = *MEMORY[0x1E0C80C00];
  if (*((char *)a2 + 23) >= 0)
    v10 = *((unsigned __int8 *)a2 + 23);
  else
    v10 = (size_t)a2[1];
  v11 = v27;
  std::string::basic_string[abi:ne180100]((uint64_t)v27, v10 + 7);
  if (v28 < 0)
    v11 = (void **)v27[0];
  if (v10)
  {
    if (*((char *)a2 + 23) >= 0)
      v12 = a2;
    else
      v12 = *a2;
    memmove(v11, v12, v10);
  }
  strcpy((char *)v11 + v10, "::const");
  if (v28 >= 0)
    v13 = (char *)v27;
  else
    v13 = (char *)v27[0];
  v26[0] = 0;
  v26[1] = 0;
  v14 = operator new(8uLL);
  v21 = v14;
  *v14 = 1;
  v22 = v14 + 1;
  v23 = v14 + 1;
  v15 = MIL::IRTensorValueType::Make(a3, 11, (MIL::MILContext ***)&v21);
  v16 = operator new(4uLL);
  __p = v16;
  *v16 = a1;
  v19 = v16 + 1;
  v20 = v16 + 1;
  MIL::IRTensorValueType::MakeInt32Value(v15, (uint64_t)&__p, &v24);
  std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100]<char const(&)[4],std::unique_ptr<MIL::IRTensorValue const>,0>(v29, "val", &v24);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v25, (unsigned __int8 *)v29, 1);
  MIL::Transform::MatchContext::AddOperation(a4, v13, v26, (uint64_t)v25, a5);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v25);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)v31);
  if (v30 < 0)
    operator delete(v29[0]);
  v17 = v24;
  v24 = 0;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  if (__p)
  {
    v19 = __p;
    operator delete(__p);
  }
  if (v21)
  {
    v22 = v21;
    operator delete(v21);
  }
  if (v28 < 0)
    operator delete(v27[0]);
}

void sub_1E056DEB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  uint64_t v29;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a17);
  std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::~pair(v29 - 112);
  if (a16)
    (*(void (**)(uint64_t))(*(_QWORD *)a16 + 8))(a16);
  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  if (a29 < 0)
    operator delete(a24);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__push_back_slow_path<std::pair<char const*,MIL::Transform::ArgumentDescription> const>(uint64_t *a1, _QWORD *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[2];
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x333333333333333)
    v9 = 0x666666666666666;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[40 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v15 = v11;
  v16 = &v10[40 * v9];
  *(_QWORD *)v11 = *a2;
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)(v11 + 8), (const MIL::Transform::ArgumentDescription *)(a2 + 1));
  v15 += 40;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__swap_out_circular_buffer(a1, v14);
  v12 = a1[1];
  std::__split_buffer<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const> &>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_1E056E044(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const> &>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>,std::reverse_iterator<std::pair<char const*,MIL::Transform::ArgumentDescription> const*>,std::reverse_iterator<std::pair<char const*,MIL::Transform::ArgumentDescription> const*>,std::reverse_iterator<std::pair<char const*,MIL::Transform::ArgumentDescription> const*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(40 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>,std::reverse_iterator<std::pair<char const*,MIL::Transform::ArgumentDescription> const*>,std::reverse_iterator<std::pair<char const*,MIL::Transform::ArgumentDescription> const*>,std::reverse_iterator<std::pair<char const*,MIL::Transform::ArgumentDescription> const*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t i;
  uint64_t v12;
  MIL::Transform::ArgumentDescription *v13;

  for (i = 48; ; i -= 40)
  {
    v12 = a3 + i;
    if (a3 + i - 48 == a5)
      break;
    *(_QWORD *)(a7 + i - 88) = *(_QWORD *)(v12 - 88);
    v13 = (MIL::Transform::ArgumentDescription *)(a7 + i - 80);
    MIL::Transform::ArgumentDescription::ArgumentDescription(v13, (const MIL::Transform::ArgumentDescription *)(v12 - 80));
  }
  return a6;
}

uint64_t std::__split_buffer<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const> &>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 40;
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)(i - 32));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

uint64_t std::string::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

char *std::vector<unsigned long long>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

_QWORD *std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100]<char const(&)[4],std::unique_ptr<MIL::IRTensorValue const>,0>(_QWORD *a1, char *a2, uint64_t *a3)
{
  _QWORD *v5;

  v5 = std::string::basic_string[abi:ne180100]<0>(a1, a2);
  std::shared_ptr<MIL::IRValue const>::shared_ptr[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>(v5 + 3, a3);
  return a1;
}

void sub_1E056E3D8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t *std::shared_ptr<MIL::IRValue const>::shared_ptr[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = *a2;
  *a1 = *a2;
  if (v4)
  {
    v5 = (_QWORD *)operator new();
    v6 = *a2;
    *v5 = &unk_1EA992A68;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  a1[1] = (uint64_t)v5;
  *a2 = 0;
  return a1;
}

void std::__shared_ptr_pointer<MIL::IRTensorValue const *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::IRTensorValue const *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IRTensorValue const *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

uint64_t std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    v5 = 40 * a3;
    do
    {
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRValue const>> const&>(a1, a2, (__int128 *)a2);
      a2 += 40;
      v5 -= 40;
    }
    while (v5);
  }
  return a1;
}

void sub_1E056E594(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 40;
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)(v4 - 32));
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA992AD8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA992AD8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1E0C023A0);
}

_QWORD *std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  std::string *v3;

  v2 = operator new(0x20uLL);
  *v2 = off_1EA992AD8;
  v3 = (std::string *)(v2 + 1);
  if (*(char *)(a1 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 8), *(_QWORD *)(a1 + 16));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 8);
    v2[3] = *(_QWORD *)(a1 + 24);
  }
  return v2;
}

void sub_1E056E704(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone(uint64_t a1, _QWORD *a2)
{
  std::string *v2;
  __int128 v3;

  *a2 = off_1EA992AD8;
  v2 = (std::string *)(a2 + 1);
  if (*(char *)(a1 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a1 + 8), *(_QWORD *)(a1 + 16));
  }
  else
  {
    v3 = *(_OWORD *)(a1 + 8);
    v2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 24);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::destroy(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
}

void std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::destroy_deallocate(void **__p)
{
  if (*((char *)__p + 31) < 0)
    operator delete(__p[1]);
  operator delete(__p);
}

void std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::operator()(uint64_t a1, MIL::Transform::MatchContext *a2, _QWORD *a3)
{
  uint64_t Operator;
  uint64_t *i;
  int **v7;
  int v8;
  int *v9;
  int v10;
  int v11;
  int *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t **v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  int v22;
  void (***MILContext)(MIL::MILContextImpl *__hidden);
  void (***v25)(MIL::MILContextImpl *__hidden);
  int v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  int v31;
  void (***v32)(MIL::MILContextImpl *__hidden);
  uint64_t Value;
  const void *v34;
  int v35;
  void (***v36)(MIL::MILContextImpl *__hidden);
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t n;
  uint64_t ii;
  _QWORD *v42;
  uint64_t v43;
  unint64_t NumOutputs;
  char *p_p_p;
  uint64_t v46;
  MIL::MatchingPrivate::MatchItem *v47;
  void *v48[2];
  char v49;
  _QWORD *v50;
  _QWORD *v51;
  unint64_t v52;
  __n128 v53[2];
  __n128 v54[2];
  __n128 v55[2];
  void *p_p;
  __n128 v57[2];
  __n128 v58[2];
  void *__p;
  _BYTE v60[15];
  char v61;
  const char *v62;
  _BYTE v63[32];
  const char *v64;
  _BYTE v65[32];
  __n128 v66[2];
  __n128 v67[2];
  __n128 v68[2];
  __n128 v69[2];
  __n128 v70[2];
  uint64_t v71[2];
  uint64_t v72[3];

  v72[2] = *MEMORY[0x1E0C80C00];
  MIL::Matching::MatchView::MatchView(&v47, a3);
  v50 = 0;
  v51 = 0;
  v52 = 0;
  Operator = MIL::Matching::MatchView::GetOperator(&v47);
  for (i = *(uint64_t **)((*(uint64_t (**)(uint64_t))(*(_QWORD *)Operator + 64))(Operator) + 16);
        i;
        i = (uint64_t *)*i)
  {
    v7 = (int **)(i + 2);
    v8 = *((char *)i + 39);
    if (v8 < 0)
    {
      if (i[3] != 7)
        goto LABEL_11;
      v9 = *v7;
    }
    else
    {
      v9 = (int *)(i + 2);
      if (v8 != 7)
        goto LABEL_11;
    }
    v10 = *v9;
    v11 = *(int *)((char *)v9 + 3);
    if (v10 != 1768189545 || v11 != 1936024425)
    {
LABEL_11:
      if (MIL::Matching::MatchView::GetArgumentCount(&v47, (const void **)i + 2))
      {
        v13 = (int *)(i + 2);
        if (*((char *)i + 39) < 0)
          v13 = *v7;
        MIL::Matching::MatchView::GetArgument(&v47, (uint64_t)(i + 2), (uint64_t *)v70);
        p_p = v13;
        MIL::Matching::ArgumentView::ArgumentView(v57, v70);
        __p = p_p;
        MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v60, (const MIL::Matching::ArgumentView *)v57);
        v14 = v51;
        if ((unint64_t)v51 >= v52)
        {
          v15 = std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__push_back_slow_path<std::pair<char const*,MIL::Transform::ArgumentDescription> const>((uint64_t *)&v50, &__p);
        }
        else
        {
          *v51 = __p;
          MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)(v14 + 1), (const MIL::Transform::ArgumentDescription *)v60);
          v15 = (uint64_t)(v14 + 5);
        }
        v51 = (_QWORD *)v15;
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)v60);
        MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v57);
        MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v70);
      }
    }
  }
  MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)&p_p, 1);
  __p = "validate_indices";
  MIL::Transform::ArgumentDescription::ArgumentDescription(v60, &p_p);
  v16 = v51;
  if ((unint64_t)v51 >= v52)
  {
    v17 = std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__push_back_slow_path<std::pair<char const*,MIL::Transform::ArgumentDescription> const>((uint64_t *)&v50, &__p);
  }
  else
  {
    *v51 = __p;
    MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)(v16 + 1), (const MIL::Transform::ArgumentDescription *)v60);
    v17 = (uint64_t)(v16 + 5);
  }
  v51 = (_QWORD *)v17;
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)v60);
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&p_p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "indices");
  MIL::Matching::MatchView::GetArgument(&v47, (uint64_t)&__p, v72);
  if (v61 < 0)
    operator delete(__p);
  v18 = (uint64_t **)(a1 + 8);
  v19 = *(char *)(a1 + 31);
  if (v19 < 0)
  {
    if (*(_QWORD *)(a1 + 16) != 9)
    {
LABEL_33:
      std::string::basic_string[abi:ne180100]<0>(&__p, "data");
      MIL::Matching::MatchView::GetArgument(&v47, (uint64_t)&__p, v71);
      goto LABEL_34;
    }
    v20 = *v18;
  }
  else
  {
    v20 = (uint64_t *)(a1 + 8);
    if (v19 != 9)
      goto LABEL_33;
  }
  v21 = *v20;
  v22 = *((unsigned __int8 *)v20 + 8);
  if (v21 != 0x6E5F726568746167 || v22 != 100)
    goto LABEL_33;
  std::string::basic_string[abi:ne180100]<0>(&__p, "x");
  MIL::Matching::MatchView::GetArgument(&v47, (uint64_t)&__p, v71);
LABEL_34:
  if (v61 < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "ios17");
  MILContext = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext(a2);
  if (v61 < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "ios17");
  v25 = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext(a2);
  if (v61 < 0)
    operator delete(__p);
  v26 = *(char *)(a1 + 31);
  if (v26 < 0)
  {
    if (*(_QWORD *)(a1 + 16) != 9)
    {
LABEL_49:
      v31 = 0;
      goto LABEL_50;
    }
    v27 = *v18;
  }
  else
  {
    v27 = (uint64_t *)(a1 + 8);
    if (v26 != 9)
      goto LABEL_49;
  }
  v28 = *v27;
  v29 = *((unsigned __int8 *)v27 + 8);
  if (v28 != 0x6E5F726568746167 || v29 != 100)
    goto LABEL_49;
  std::string::basic_string[abi:ne180100]<0>(v48, "batch_dims");
  if (MIL::Matching::MatchView::GetArgumentCount(&v47, (const void **)v48))
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, "batch_dims");
    MIL::Matching::MatchView::GetArgument(&v47, (uint64_t)&__p, (uint64_t *)v67);
    Value = MIL::Matching::ArgumentView::TryGetValue((MIL::Matching::ArgumentView *)v67);
    v34 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)Value + 40))(Value);
    v35 = MIL::IRValue::GetScalar<int>(v34);
    std::string::basic_string[abi:ne180100]<0>(&p_p, "ios17");
    v36 = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext(a2);
    if (v57[0].n128_i8[15] < 0)
      operator delete(p_p);
    MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v67);
    if (v61 < 0)
      operator delete(__p);
    goto LABEL_61;
  }
  v31 = 1;
LABEL_50:
  std::string::basic_string[abi:ne180100]<0>(&__p, "ios17");
  v32 = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext(a2);
  if (v61 < 0)
  {
    operator delete(__p);
    if (!v31)
      goto LABEL_63;
  }
  else if (!v31)
  {
    goto LABEL_63;
  }
LABEL_61:
  if (v49 < 0)
    operator delete(v48[0]);
LABEL_63:
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v60, (const MIL::Matching::ArgumentView *)v71);
  p_p = &__p;
  v57[0].n128_u64[0] = 1;
  MIL::Transform::MatchContext::AddOperation((uint64_t **)a2, "ios17::shape", (uint64_t *)&p_p, v67);
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)v60);
  p_p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v57, (const MIL::Matching::ArgumentView *)v72);
  v54[0].n128_u64[0] = (unint64_t)&p_p;
  v54[0].n128_u64[1] = 1;
  MIL::Transform::MatchContext::AddOperation((uint64_t **)a2, "ios17::shape", (uint64_t *)v54, v58);
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v60, v58);
  v62 = "begin";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v63, v70);
  v64 = "size";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v65, v69);
  v55[0].n128_u64[0] = (unint64_t)&__p;
  v55[0].n128_u64[1] = 3;
  MIL::Transform::MatchContext::AddOperation((uint64_t **)a2, "ios17::slice_by_size", (uint64_t *)v55, v66);
  for (j = 88; j != -32; j -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v60[j - 8]);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v58);
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)v57);
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v60, v67);
  v62 = "begin";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v63, v68);
  v64 = "size";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v65, v66);
  p_p = &__p;
  v57[0].n128_u64[0] = 3;
  MIL::Transform::MatchContext::AddOperation((uint64_t **)a2, "ios17::slice_by_size", (uint64_t *)&p_p, v58);
  for (k = 88; k != -32; k -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v60[k - 8]);
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v60, (const MIL::Matching::ArgumentView *)v72);
  v62 = "y";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v63, v58);
  p_p = &__p;
  v57[0].n128_u64[0] = 2;
  MIL::Transform::MatchContext::AddOperation((uint64_t **)a2, "ios17::add", (uint64_t *)&p_p, v55);
  for (m = 48; m != -32; m -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v60[m - 8]);
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v60, (const MIL::Matching::ArgumentView *)v72);
  v62 = "y";
  MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v63, 0);
  p_p = &__p;
  v57[0].n128_u64[0] = 2;
  MIL::Transform::MatchContext::AddOperation((uint64_t **)a2, "ios17::less", (uint64_t *)&p_p, v54);
  for (n = 48; n != -32; n -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v60[n - 8]);
  __p = "cond";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v60, v54);
  v62 = "a";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v63, v55);
  v64 = "b";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v65, (const MIL::Matching::ArgumentView *)v72);
  p_p = &__p;
  v57[0].n128_u64[0] = 3;
  MIL::Transform::MatchContext::AddOperation((uint64_t **)a2, "ios17::select", (uint64_t *)&p_p, v53);
  for (ii = 88; ii != -32; ii -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v60[ii - 8]);
  p_p = "indices";
  MIL::Transform::NewOperationOutput::NewOperationOutput(v57, v53);
  __p = p_p;
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v60, v57);
  v42 = v51;
  if ((unint64_t)v51 >= v52)
  {
    v43 = std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__push_back_slow_path<std::pair<char const*,MIL::Transform::ArgumentDescription> const>((uint64_t *)&v50, &__p);
  }
  else
  {
    *v51 = __p;
    MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)(v42 + 1), (const MIL::Transform::ArgumentDescription *)v60);
    v43 = (uint64_t)(v42 + 5);
  }
  v51 = (_QWORD *)v43;
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)v60);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v57);
  std::operator+<char>();
  NumOutputs = MIL::Matching::MatchView::GetNumOutputs(&v47);
  if (v57[0].n128_i8[15] >= 0)
    p_p_p = (char *)&p_p;
  else
    p_p_p = (char *)p_p;
  if (v51 == v50)
    v46 = 0;
  else
    v46 = (uint64_t)v50;
  MIL::Transform::MatchContext::AddMultiOutputOperation((uint64_t **)a2, p_p_p, NumOutputs, v46, 0xCCCCCCCCCCCCCCCDLL * (v51 - v50), &__p);
  MIL::Transform::NewOperationOutputList::~NewOperationOutputList((MIL::Transform::NewOperationOutputList *)&__p);
  if (v57[0].n128_i8[15] < 0)
    operator delete(p_p);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v53);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v54);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v55);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v58);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v66);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v67);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v68);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v69);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v70);
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v71);
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v72);
  p_p = &v50;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&p_p);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&v47);
}

void sub_1E056F0EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  uint64_t v61;

  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)(v61 - 248));
  if (a48 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)(v61 - 184));
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)(v61 - 152));
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)(v61 - 120));
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)(v61 - 104));
  a31 = &a16;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a31);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0,std::allocator<MIL::Conversion::MakeIos16ToIos17GatherScatterNdTransform(std::string const&)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target_type()
{
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *std::__function::__func<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA992B58;
  return result;
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA992B58;
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::operator()(uint64_t a1, MIL::Transform::MatchContext *a2, _QWORD *a3)
{
  const MIL::IRTensorValueType *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  void (***MILContext)(MIL::MILContextImpl *__hidden);
  unsigned int *Data;
  uint64_t v22;
  uint64_t v23;
  MIL::MILContext *v24;
  MIL::Conversion *v25;
  std::__shared_weak_count_vtbl *v26;
  std::__shared_weak_count *v27;
  MIL::Transform::MatchContext *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  char *v41;
  uint64_t v42;
  char *v43;
  MIL::Transform::MatchContext *v44;
  const MIL::IRTensorValueType *v45;
  char *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  uint64_t *v52;
  uint64_t v53;
  char *v54;
  char *v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  char *v60;
  char *v61;
  char *v62;
  uint64_t v63;
  void (***v64)(MIL::MILContextImpl *__hidden);
  uint64_t v65;
  int v66;
  MIL::MILContext *v67;
  MIL::Conversion *v68;
  std::__shared_weak_count_vtbl *v69;
  std::__shared_weak_count *v70;
  uint64_t i;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  std::__shared_weak_count *v75;
  unint64_t *v76;
  unint64_t v77;
  std::logic_error *exception;
  const MIL::IRTensorValueType *v79;
  MIL::MatchingPrivate::MatchItem *v80;
  uint64_t v81[2];
  void *v82;
  std::__shared_weak_count *v83;
  void *v84;
  char *v85;
  char *v86;
  void *v87;
  std::__shared_weak_count *v88;
  void *v89[3];
  void *__p;
  void *v91;
  uint64_t v92;
  uint64_t v93[5];
  MIL::IRValue *v94;
  std::__shared_weak_count *v95;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  MIL::Matching::MatchView::MatchView(&v80, a3);
  memset(v89, 0, sizeof(v89));
  std::string::basic_string[abi:ne180100]<0>(&__p, "indices");
  MIL::Matching::MatchView::GetAttribute(&v80, (unsigned __int8 *)&__p, &v94);
  v4 = (const MIL::IRTensorValueType *)MIL::IRValue::AsTensor(v94);
  v5 = v95;
  if (v95)
  {
    p_shared_owners = (unint64_t *)&v95->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (SHIBYTE(v92) < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "lut");
  MIL::Matching::MatchView::GetAttribute(&v80, (unsigned __int8 *)&__p, &v94);
  v8 = MIL::IRValue::AsTensor(v94);
  v9 = v95;
  if (v95)
  {
    v10 = (unint64_t *)&v95->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (SHIBYTE(v92) < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "shape");
  MIL::Matching::MatchView::GetAttribute(&v80, (unsigned __int8 *)&__p, &v94);
  v12 = (uint64_t *)MIL::IRValue::AsTensor(v94);
  v13 = v95;
  if (v95)
  {
    v14 = (unint64_t *)&v95->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (SHIBYTE(v92) < 0)
    operator delete(__p);
  v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
  v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 16))(v16);
  v18 = v17;
  if (v17 <= 15)
  {
    if (v17 == 2)
    {
      v19 = 21;
    }
    else
    {
      if (v17 != 4)
        goto LABEL_110;
      v19 = 19;
    }
  }
  else
  {
    switch(v17)
    {
      case 16:
        v19 = 20;
        break;
      case 64:
        v19 = 23;
        break;
      case 256:
        v19 = 14;
        break;
      default:
LABEL_110:
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Invalid lut size.");
        exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
        __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
    }
  }
  MILContext = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext(a2);
  Data = (unsigned int *)MIL::IRTensorValue::GetDataView<unsigned int>(v12);
  v22 = MIL::IRTensorValue::GetDataView<unsigned int>(v12);
  __p = 0;
  v91 = 0;
  v92 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((char *)&__p, Data, (unsigned int *)(v22 + 4 * v23), (v22 + 4 * v23 - (uint64_t)Data) >> 2);
  v24 = (MIL::MILContext *)MIL::IRTensorValueType::Make(MILContext, v19, (MIL::MILContext ***)&__p);
  if (__p)
  {
    v91 = __p;
    operator delete(__p);
  }
  v25 = (MIL::Conversion *)MIL::Transform::MatchContext::GetMILContext(a2);
  MIL::Conversion::CopyTensorValue(v25, v24, v4, &__p);
  v26 = (std::__shared_weak_count_vtbl *)__p;
  v87 = __p;
  v79 = (const MIL::IRTensorValueType *)v8;
  if (__p)
  {
    v27 = (std::__shared_weak_count *)operator new();
    v28 = a2;
    v27->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA992BC8;
    v27->__shared_owners_ = 0;
    v27->__shared_weak_owners_ = 0;
    v27[1].__vftable = v26;
  }
  else
  {
    v28 = a2;
    v27 = 0;
  }
  v29 = 0;
  v88 = v27;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  while (1)
  {
    v30 = (*(uint64_t (**)(uint64_t *))(*v12 + 32))(v12);
    v31 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v30 + 16))(v30);
    v33 = v85;
    v32 = v86;
    if (v29 >= v31)
      break;
    if (v85 >= v86)
    {
      v35 = (char *)v84;
      v36 = (v85 - (_BYTE *)v84) >> 3;
      v37 = v36 + 1;
      if ((unint64_t)(v36 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v38 = v86 - (_BYTE *)v84;
      if ((v86 - (_BYTE *)v84) >> 2 > v37)
        v37 = v38 >> 2;
      if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8)
        v39 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v39 = v37;
      if (v39)
      {
        v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v86, v39);
        v35 = (char *)v84;
        v33 = v85;
      }
      else
      {
        v40 = 0;
      }
      v41 = &v40[8 * v36];
      *(_QWORD *)v41 = 1;
      v34 = v41 + 8;
      while (v33 != v35)
      {
        v42 = *((_QWORD *)v33 - 1);
        v33 -= 8;
        *((_QWORD *)v41 - 1) = v42;
        v41 -= 8;
      }
      v84 = v41;
      v85 = v34;
      v86 = &v40[8 * v39];
      if (v35)
        operator delete(v35);
    }
    else
    {
      *(_QWORD *)v85 = 1;
      v34 = v33 + 8;
    }
    v85 = v34;
    ++v29;
  }
  if (v85 >= v86)
  {
    v46 = (char *)v84;
    v47 = (v85 - (_BYTE *)v84) >> 3;
    v48 = v47 + 1;
    v44 = v28;
    v45 = v79;
    if ((unint64_t)(v47 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v49 = v86 - (_BYTE *)v84;
    if ((v86 - (_BYTE *)v84) >> 2 > v48)
      v48 = v49 >> 2;
    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8)
      v50 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v50 = v48;
    if (v50)
    {
      v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v86, v50);
      v46 = (char *)v84;
      v33 = v85;
    }
    else
    {
      v51 = 0;
    }
    v52 = (uint64_t *)&v51[8 * v47];
    v32 = &v51[8 * v50];
    *v52 = v18;
    v43 = (char *)(v52 + 1);
    while (v33 != v46)
    {
      v53 = *((_QWORD *)v33 - 1);
      v33 -= 8;
      *--v52 = v53;
    }
    v84 = v52;
    v85 = v43;
    v86 = v32;
    if (v46)
    {
      operator delete(v46);
      v32 = v86;
    }
  }
  else
  {
    *(_QWORD *)v85 = v18;
    v43 = v33 + 8;
    v44 = v28;
    v45 = v79;
  }
  v85 = v43;
  if (v43 >= v32)
  {
    v55 = (char *)v84;
    v56 = (v43 - (_BYTE *)v84) >> 3;
    v57 = v56 + 1;
    if ((unint64_t)(v56 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v58 = v32 - (_BYTE *)v84;
    if (v58 >> 2 > v57)
      v57 = v58 >> 2;
    if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8)
      v59 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v59 = v57;
    if (v59)
    {
      v60 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v86, v59);
      v55 = (char *)v84;
      v43 = v85;
    }
    else
    {
      v60 = 0;
    }
    v61 = &v60[8 * v56];
    v62 = &v60[8 * v59];
    *(_QWORD *)v61 = 1;
    v54 = v61 + 8;
    while (v43 != v55)
    {
      v63 = *((_QWORD *)v43 - 1);
      v43 -= 8;
      *((_QWORD *)v61 - 1) = v63;
      v61 -= 8;
    }
    v84 = v61;
    v85 = v54;
    v86 = v62;
    if (v55)
      operator delete(v55);
  }
  else
  {
    *(_QWORD *)v43 = 1;
    v54 = v43 + 8;
  }
  v85 = v54;
  v64 = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext(v44);
  v65 = (*(uint64_t (**)(const MIL::IRTensorValueType *))(*(_QWORD *)v45 + 32))(v45);
  v66 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v65 + 88))(v65);
  v67 = (MIL::MILContext *)MIL::IRTensorValueType::Make(v64, v66, (MIL::MILContext ***)&v84);
  v68 = (MIL::Conversion *)MIL::Transform::MatchContext::GetMILContext(v44);
  MIL::Conversion::CopyTensorValue(v68, v67, v45, &__p);
  v69 = (std::__shared_weak_count_vtbl *)__p;
  v82 = __p;
  if (__p)
  {
    v70 = (std::__shared_weak_count *)operator new();
    v70->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA992BC8;
    v70->__shared_owners_ = 0;
    v70->__shared_weak_owners_ = 0;
    v70[1].__vftable = v69;
  }
  else
  {
    v70 = 0;
  }
  v83 = v70;
  std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[8],std::shared_ptr<MIL::IRValue const> &,0>(&__p, (uint64_t)"indices", (uint64_t *)&v87);
  std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[4],std::shared_ptr<MIL::IRValue const> &,0>(v93, (uint64_t)"lut", (uint64_t *)&v82);
  v81[0] = (uint64_t)&__p;
  v81[1] = 2;
  MIL::Transform::MatchContext::AddOperation((uint64_t **)v44, "ios18::constexpr_lut_to_dense", v81, &v94);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v94);
  for (i = 48; i != -32; i -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)((char *)&__p + i));
  v72 = v83;
  if (v83)
  {
    v73 = (unint64_t *)&v83->__shared_owners_;
    do
      v74 = __ldaxr(v73);
    while (__stlxr(v74 - 1, v73));
    if (!v74)
    {
      ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
      std::__shared_weak_count::__release_weak(v72);
    }
  }
  if (v84)
  {
    v85 = (char *)v84;
    operator delete(v84);
  }
  v75 = v88;
  if (v88)
  {
    v76 = (unint64_t *)&v88->__shared_owners_;
    do
      v77 = __ldaxr(v76);
    while (__stlxr(v77 - 1, v76));
    if (!v77)
    {
      ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
      std::__shared_weak_count::__release_weak(v75);
    }
  }
  __p = v89;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&v80);
}

void sub_1E056FD10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  a23 = &a20;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18LutToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target_type()
{
}

char *std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>(char *result, unsigned int *a2, unsigned int *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  unsigned int v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    v7 = (_QWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      *v7++ = v8;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1E056FFD0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<MIL::IRValue const *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::IRValue const *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IRValue const *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[8],std::shared_ptr<MIL::IRValue const> &,0>(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;

  *a1 = a2;
  v4 = a1 + 1;
  v5 = (std::__shared_weak_count *)a3[1];
  v12 = *a3;
  v13 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  MIL::Transform::ArgumentDescription::ArgumentDescription(v4, &v12);
  v8 = v13;
  if (v13)
  {
    v9 = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return a1;
}

void sub_1E05700F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[4],std::shared_ptr<MIL::IRValue const> &,0>(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;

  *a1 = a2;
  v4 = a1 + 1;
  v5 = (std::__shared_weak_count *)a3[1];
  v12 = *a3;
  v13 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  MIL::Transform::ArgumentDescription::ArgumentDescription(v4, &v12);
  v8 = v13;
  if (v13)
  {
    v9 = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return a1;
}

void sub_1E0570198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *std::__function::__func<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA992C38;
  return result;
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA992C38;
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::operator()(uint64_t a1, MIL::Transform::MatchContext *a2, _QWORD *a3)
{
  const MIL::IRTensorValueType *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  void (***MILContext)(MIL::MILContextImpl *__hidden);
  unsigned int *Data;
  uint64_t v14;
  uint64_t v15;
  MIL::MILContext *v16;
  MIL::Conversion *v17;
  std::__shared_weak_count_vtbl *v18;
  std::__shared_weak_count *v19;
  uint64_t i;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  MIL::MatchingPrivate::MatchItem *v27;
  void *v28[2];
  char v29;
  __int128 v30;
  uint64_t v31[2];
  void *v32;
  std::__shared_weak_count *v33;
  void *v34[3];
  void *__p;
  void *v36;
  uint64_t v37;
  uint64_t v38[5];
  MIL::IRValue *v39;
  std::__shared_weak_count *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  MIL::Matching::MatchView::MatchView(&v27, a3);
  memset(v34, 0, sizeof(v34));
  std::string::basic_string[abi:ne180100]<0>(&__p, "mask");
  MIL::Matching::MatchView::GetAttribute(&v27, (unsigned __int8 *)&__p, &v39);
  v4 = (const MIL::IRTensorValueType *)MIL::IRValue::AsTensor(v39);
  v5 = v40;
  if (v40)
  {
    p_shared_owners = (unint64_t *)&v40->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (SHIBYTE(v37) < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "shape");
  MIL::Matching::MatchView::GetAttribute(&v27, (unsigned __int8 *)&__p, &v39);
  v8 = (uint64_t *)MIL::IRValue::AsTensor(v39);
  v9 = v40;
  if (v40)
  {
    v10 = (unint64_t *)&v40->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (SHIBYTE(v37) < 0)
    operator delete(__p);
  MILContext = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext(a2);
  Data = (unsigned int *)MIL::IRTensorValue::GetDataView<unsigned int>(v8);
  v14 = MIL::IRTensorValue::GetDataView<unsigned int>(v8);
  __p = 0;
  v36 = 0;
  v37 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((char *)&__p, Data, (unsigned int *)(v14 + 4 * v15), (v14 + 4 * v15 - (uint64_t)Data) >> 2);
  v16 = (MIL::MILContext *)MIL::IRTensorValueType::Make(MILContext, 21, (MIL::MILContext ***)&__p);
  if (__p)
  {
    v36 = __p;
    operator delete(__p);
  }
  v17 = (MIL::Conversion *)MIL::Transform::MatchContext::GetMILContext(a2);
  MIL::Conversion::CopyTensorValue(v17, v16, v4, &__p);
  v18 = (std::__shared_weak_count_vtbl *)__p;
  v32 = __p;
  if (__p)
  {
    v19 = (std::__shared_weak_count *)operator new();
    v19->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA992BC8;
    v19->__shared_owners_ = 0;
    v19->__shared_weak_owners_ = 0;
    v19[1].__vftable = v18;
  }
  else
  {
    v19 = 0;
  }
  v33 = v19;
  std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[5],std::shared_ptr<MIL::IRValue const> &,0>(&__p, (uint64_t)"mask", (uint64_t *)&v32);
  std::string::basic_string[abi:ne180100]<0>(v28, "nonzero_data");
  MIL::Matching::MatchView::GetAttribute(&v27, (unsigned __int8 *)v28, &v30);
  std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[13],std::shared_ptr<MIL::IRValue const>,0>(v38, (uint64_t)"nonzero_data", &v30);
  v31[0] = (uint64_t)&__p;
  v31[1] = 2;
  MIL::Transform::MatchContext::AddOperation((uint64_t **)a2, "ios18::constexpr_sparse_to_dense", v31, &v39);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v39);
  for (i = 48; i != -32; i -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)((char *)&__p + i));
  v21 = (std::__shared_weak_count *)*((_QWORD *)&v30 + 1);
  if (*((_QWORD *)&v30 + 1))
  {
    v22 = (unint64_t *)(*((_QWORD *)&v30 + 1) + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  if (v29 < 0)
    operator delete(v28[0]);
  v24 = v33;
  if (v33)
  {
    v25 = (unint64_t *)&v33->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  __p = v34;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&v27);
}

void sub_1E0570544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,char *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;

  (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  a25 = &a22;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a25);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18SparseToDenseTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target_type()
{
}

_QWORD *std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[5],std::shared_ptr<MIL::IRValue const> &,0>(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;

  *a1 = a2;
  v4 = a1 + 1;
  v5 = (std::__shared_weak_count *)a3[1];
  v12 = *a3;
  v13 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  MIL::Transform::ArgumentDescription::ArgumentDescription(v4, &v12);
  v8 = v13;
  if (v13)
  {
    v9 = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return a1;
}

void sub_1E05707EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[13],std::shared_ptr<MIL::IRValue const>,0>(_QWORD *a1, uint64_t a2, __int128 *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v8;

  *a1 = a2;
  v8 = *a3;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  MIL::Transform::ArgumentDescription::ArgumentDescription(a1 + 1, &v8);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_1E0570878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *std::__function::__func<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA992CB8;
  return result;
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA992CB8;
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::operator()(uint64_t a1, uint64_t **a2, _QWORD *a3)
{
  uint64_t i;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  MIL::MatchingPrivate::MatchItem *v11;
  void *__p[2];
  char v13;
  __int128 v14;
  void *v15[2];
  char v16;
  __int128 v17;
  uint64_t v18[2];
  _QWORD v19[5];
  _QWORD v20[5];
  _QWORD v21[5];

  v21[4] = *MEMORY[0x1E0C80C00];
  MIL::Matching::MatchView::MatchView(&v11, a3);
  std::string::basic_string[abi:ne180100]<0>(v15, "source_val");
  MIL::Matching::MatchView::GetAttribute(&v11, (unsigned __int8 *)v15, &v17);
  std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[11],std::shared_ptr<MIL::IRValue const>,0>(v19, (uint64_t)"source_val", &v17);
  std::string::basic_string[abi:ne180100]<0>(__p, "output_dtype");
  MIL::Matching::MatchView::GetAttribute(&v11, (unsigned __int8 *)__p, &v14);
  std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[13],std::shared_ptr<MIL::IRValue const>,0>(v20, (uint64_t)"output_dtype", &v14);
  v18[0] = (uint64_t)v19;
  v18[1] = 2;
  MIL::Transform::MatchContext::AddOperation(a2, "ios18::constexpr_cast", v18, v21);
  for (i = 6; i != -4; i -= 5)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v19[i]);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
  if (*((_QWORD *)&v14 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (v13 < 0)
    operator delete(__p[0]);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if (v16 < 0)
    operator delete(v15[0]);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v21);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&v11);
}

void sub_1E0570A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,std::__shared_weak_count *a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;
  uint64_t i;
  std::__shared_weak_count *v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;

  for (i = 48; i != -32; i -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)(v28 + i));
  v31 = a17;
  if (a17)
  {
    p_shared_owners = (unint64_t *)&a17->__shared_owners_;
    do
      v33 = __ldaxr(p_shared_owners);
    while (__stlxr(v33 - 1, p_shared_owners));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  if (a15 < 0)
    operator delete(__p);
  v34 = a25;
  if (a25)
  {
    v35 = (unint64_t *)&a25->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  if (a23 < 0)
    operator delete(a18);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&a9);
  _Unwind_Resume(a1);
}

void sub_1E0570BD0()
{
  JUMPOUT(0x1E0570BC8);
}

uint64_t std::__function::__func<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ConstCastTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target_type()
{
}

_QWORD *std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[11],std::shared_ptr<MIL::IRValue const>,0>(_QWORD *a1, uint64_t a2, __int128 *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v8;

  *a1 = a2;
  v8 = *a3;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  MIL::Transform::ArgumentDescription::ArgumentDescription(a1 + 1, &v8);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_1E0570C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *std::__function::__func<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA992D38;
  return result;
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA992D38;
}

void std::__function::__func<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::operator()(uint64_t a1, MIL::Transform::MatchContext *a2, _QWORD *a3)
{
  const MIL::IRTensorValueType *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  const MIL::IRTensorValueType *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  MIL::IRTensorValueType *v21;
  uint64_t v22;
  char *v23;
  uint64_t i;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void (***MILContext)(MIL::MILContextImpl *__hidden);
  uint64_t v47;
  int v48;
  MIL::MILContext *v49;
  MIL::Conversion *v50;
  std::__shared_weak_count_vtbl *v51;
  std::__shared_weak_count *v52;
  void (***v53)(MIL::MILContextImpl *__hidden);
  uint64_t v54;
  int v55;
  MIL::MILContext *v56;
  MIL::Conversion *v57;
  std::__shared_weak_count_vtbl *v58;
  std::__shared_weak_count *v59;
  uint64_t j;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  MIL::MatchingPrivate::MatchItem *v70;
  void *v71[2];
  char v72;
  __int128 v73;
  uint64_t v74[2];
  void *v75;
  std::__shared_weak_count *v76;
  void *v77;
  std::__shared_weak_count *v78;
  void *v79;
  char *v80;
  char *v81;
  void *v82[3];
  void *__p[2];
  char v84;
  uint64_t v85[5];
  uint64_t v86[5];
  MIL::IRValue *v87;
  std::__shared_weak_count *v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  MIL::Matching::MatchView::MatchView(&v70, a3);
  memset(v82, 0, sizeof(v82));
  std::string::basic_string[abi:ne180100]<0>(__p, "zero_point");
  MIL::Matching::MatchView::GetAttribute(&v70, (unsigned __int8 *)__p, &v87);
  v4 = (const MIL::IRTensorValueType *)MIL::IRValue::AsTensor(v87);
  v5 = v88;
  if (v88)
  {
    p_shared_owners = (unint64_t *)&v88->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (v84 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "scale");
  MIL::Matching::MatchView::GetAttribute(&v70, (unsigned __int8 *)__p, &v87);
  v8 = (const MIL::IRTensorValueType *)MIL::IRValue::AsTensor(v87);
  v9 = v88;
  if (v88)
  {
    v10 = (unint64_t *)&v88->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v84 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "axis");
  MIL::Matching::MatchView::GetAttribute(&v70, (unsigned __int8 *)__p, &v87);
  v12 = (uint64_t *)MIL::IRValue::AsTensor(v87);
  v13 = v88;
  if (v88)
  {
    v14 = (unint64_t *)&v88->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v84 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "quantized_data");
  MIL::Matching::MatchView::GetAttribute(&v70, (unsigned __int8 *)__p, &v87);
  v16 = MIL::IRValue::AsTensor(v87);
  v17 = v88;
  if (v88)
  {
    v18 = (unint64_t *)&v88->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  if (v84 < 0)
    operator delete(__p[0]);
  v20 = *(int *)MIL::IRTensorValue::GetDataView<int>(v12);
  v21 = (MIL::IRTensorValueType *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 32))(v16);
  v22 = MIL::IRTensorValueType::Rank(v21);
  v79 = 0;
  v80 = 0;
  v81 = 0;
  if (v22 >= 1)
  {
    v23 = 0;
    for (i = 0; i != v22; ++i)
    {
      v25 = v23;
      if (i == v20)
      {
        v26 = (*(uint64_t (**)(const MIL::IRTensorValueType *))(*(_QWORD *)v8 + 32))(v8);
        if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v26 + 16))(v26) > 1)
        {
          v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 32))(v16);
          v28 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v27 + 96))(v27);
          v29 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*v28 + 8 * v20) + 16))(*(_QWORD *)(*v28 + 8 * v20));
          v30 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 48))(v29);
          v31 = v30;
          v32 = v80;
          if (v80 >= v81)
          {
            v34 = (char *)v79;
            v42 = (v80 - (_BYTE *)v79) >> 3;
            v43 = v42 + 1;
            if ((unint64_t)(v42 + 1) >> 61)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v44 = v81 - (_BYTE *)v79;
            if ((v81 - (_BYTE *)v79) >> 2 > v43)
              v43 = v44 >> 2;
            if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8)
              v38 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v38 = v43;
            if (v38)
            {
              v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v81, v38);
              v34 = (char *)v79;
              v32 = v80;
            }
            else
            {
              v39 = 0;
            }
            v40 = &v39[8 * v42];
            *(_QWORD *)v40 = v31;
            v23 = v40 + 8;
            while (v32 != v34)
            {
              v45 = *((_QWORD *)v32 - 1);
              v32 -= 8;
              *((_QWORD *)v40 - 1) = v45;
              v40 -= 8;
            }
LABEL_63:
            v79 = v40;
            v80 = v23;
            v81 = &v39[8 * v38];
            if (v34)
              operator delete(v34);
            goto LABEL_65;
          }
          *(_QWORD *)v80 = v30;
          v33 = v32 + 8;
          goto LABEL_38;
        }
        v25 = v80;
      }
      if (v25 >= v81)
      {
        v34 = (char *)v79;
        v35 = (v25 - (_BYTE *)v79) >> 3;
        v36 = v35 + 1;
        if ((unint64_t)(v35 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v37 = v81 - (_BYTE *)v79;
        if ((v81 - (_BYTE *)v79) >> 2 > v36)
          v36 = v37 >> 2;
        if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
          v38 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v38 = v36;
        if (v38)
        {
          v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v81, v38);
          v34 = (char *)v79;
          v25 = v80;
        }
        else
        {
          v39 = 0;
        }
        v40 = &v39[8 * v35];
        *(_QWORD *)v40 = 1;
        v23 = v40 + 8;
        while (v25 != v34)
        {
          v41 = *((_QWORD *)v25 - 1);
          v25 -= 8;
          *((_QWORD *)v40 - 1) = v41;
          v40 -= 8;
        }
        goto LABEL_63;
      }
      *(_QWORD *)v25 = 1;
      v33 = v25 + 8;
LABEL_38:
      v23 = v33;
LABEL_65:
      v80 = v23;
    }
  }
  MILContext = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext(a2);
  v47 = (*(uint64_t (**)(const MIL::IRTensorValueType *))(*(_QWORD *)v8 + 32))(v8);
  v48 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v47 + 88))(v47);
  v49 = (MIL::MILContext *)MIL::IRTensorValueType::Make(MILContext, v48, (MIL::MILContext ***)&v79);
  v50 = (MIL::Conversion *)MIL::Transform::MatchContext::GetMILContext(a2);
  MIL::Conversion::CopyTensorValue(v50, v49, v8, __p);
  v51 = (std::__shared_weak_count_vtbl *)__p[0];
  v77 = __p[0];
  if (__p[0])
  {
    v52 = (std::__shared_weak_count *)operator new();
    v52->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA992BC8;
    v52->__shared_owners_ = 0;
    v52->__shared_weak_owners_ = 0;
    v52[1].__vftable = v51;
  }
  else
  {
    v52 = 0;
  }
  v78 = v52;
  v53 = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext(a2);
  v54 = (*(uint64_t (**)(const MIL::IRTensorValueType *))(*(_QWORD *)v4 + 32))(v4);
  v55 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v54 + 88))(v54);
  v56 = (MIL::MILContext *)MIL::IRTensorValueType::Make(v53, v55, (MIL::MILContext ***)&v79);
  v57 = (MIL::Conversion *)MIL::Transform::MatchContext::GetMILContext(a2);
  MIL::Conversion::CopyTensorValue(v57, v56, v4, __p);
  v58 = (std::__shared_weak_count_vtbl *)__p[0];
  v75 = __p[0];
  if (__p[0])
  {
    v59 = (std::__shared_weak_count *)operator new();
    v59->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA992BC8;
    v59->__shared_owners_ = 0;
    v59->__shared_weak_owners_ = 0;
    v59[1].__vftable = v58;
  }
  else
  {
    v59 = 0;
  }
  v76 = v59;
  std::string::basic_string[abi:ne180100]<0>(v71, "quantized_data");
  MIL::Matching::MatchView::GetAttribute(&v70, (unsigned __int8 *)v71, &v73);
  std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[5],std::shared_ptr<MIL::IRValue const>,0>(__p, (uint64_t)"data", &v73);
  std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[6],std::shared_ptr<MIL::IRValue const> &,0>(v85, (uint64_t)"scale", (uint64_t *)&v77);
  std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[7],std::shared_ptr<MIL::IRValue const> &,0>(v86, (uint64_t)"offset", (uint64_t *)&v75);
  v74[0] = (uint64_t)__p;
  v74[1] = 3;
  MIL::Transform::MatchContext::AddOperation((uint64_t **)a2, "ios18::constexpr_blockwise_shift_scale", v74, &v87);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v87);
  for (j = 11; j != -4; j -= 5)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&__p[j]);
  v61 = (std::__shared_weak_count *)*((_QWORD *)&v73 + 1);
  if (*((_QWORD *)&v73 + 1))
  {
    v62 = (unint64_t *)(*((_QWORD *)&v73 + 1) + 8);
    do
      v63 = __ldaxr(v62);
    while (__stlxr(v63 - 1, v62));
    if (!v63)
    {
      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
      std::__shared_weak_count::__release_weak(v61);
    }
  }
  if (v72 < 0)
    operator delete(v71[0]);
  v64 = v76;
  if (v76)
  {
    v65 = (unint64_t *)&v76->__shared_owners_;
    do
      v66 = __ldaxr(v65);
    while (__stlxr(v66 - 1, v65));
    if (!v66)
    {
      ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
      std::__shared_weak_count::__release_weak(v64);
    }
  }
  v67 = v78;
  if (v78)
  {
    v68 = (unint64_t *)&v78->__shared_owners_;
    do
      v69 = __ldaxr(v68);
    while (__stlxr(v69 - 1, v68));
    if (!v69)
    {
      ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
      std::__shared_weak_count::__release_weak(v67);
    }
  }
  if (v79)
  {
    v80 = (char *)v79;
    operator delete(v79);
  }
  __p[0] = v82;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&v70);
}

void sub_1E0571420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,void *__p,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  uint64_t v38;
  std::__shared_weak_count *v40;
  unint64_t *p_shared_owners;
  unint64_t v42;

  (*(void (**)(uint64_t))(*(_QWORD *)v38 + 8))(v38);
  v40 = a26;
  if (a26)
  {
    p_shared_owners = (unint64_t *)&a26->__shared_owners_;
    do
      v42 = __ldaxr(p_shared_owners);
    while (__stlxr(v42 - 1, p_shared_owners));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  if (__p)
  {
    a28 = (uint64_t)__p;
    operator delete(__p);
  }
  a33 = &a30;
  std::vector<std::pair<char const*,MIL::Transform::ArgumentDescription> const,std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription> const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a33);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&a12);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos17ToIos18ShiftScaleTransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target_type()
{
}

_QWORD *std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[5],std::shared_ptr<MIL::IRValue const>,0>(_QWORD *a1, uint64_t a2, __int128 *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v8;

  *a1 = a2;
  v8 = *a3;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  MIL::Transform::ArgumentDescription::ArgumentDescription(a1 + 1, &v8);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_1E0571788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[6],std::shared_ptr<MIL::IRValue const> &,0>(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;

  *a1 = a2;
  v4 = a1 + 1;
  v5 = (std::__shared_weak_count *)a3[1];
  v12 = *a3;
  v13 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  MIL::Transform::ArgumentDescription::ArgumentDescription(v4, &v12);
  v8 = v13;
  if (v13)
  {
    v9 = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return a1;
}

void sub_1E0571828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::pair<char const*,MIL::Transform::ArgumentDescription>::pair[abi:ne180100]<char const(&)[7],std::shared_ptr<MIL::IRValue const> &,0>(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;

  *a1 = a2;
  v4 = a1 + 1;
  v5 = (std::__shared_weak_count *)a3[1];
  v12 = *a3;
  v13 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  MIL::Transform::ArgumentDescription::ArgumentDescription(v4, &v12);
  v8 = v13;
  if (v13)
  {
    v9 = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return a1;
}

void sub_1E05718C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__function::__func<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *std::__function::__func<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA992DB8;
  return result;
}

void std::__function::__func<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA992DB8;
}

void std::__function::__func<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::operator()(uint64_t a1, uint64_t **a2, _QWORD *a3)
{
  uint64_t Attributes;
  uint64_t i;
  MIL::IRValueType *Type;
  uint64_t v7;
  uint64_t v8;
  MIL::IRValueType *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  MIL::IRValueType *v14;
  uint64_t v15;
  int v16;
  void (***v17)(MIL::MILContextImpl *__hidden);
  _QWORD *v18;
  MIL::Bf16 *v19;
  float v20;
  __int16 v21;
  _WORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  void (***v27)(MIL::MILContextImpl *__hidden);
  void (***v28)(MIL::MILContextImpl *__hidden);
  uint64_t j;
  MIL::IRValueType *v30;
  uint64_t v31;
  int v32;
  __n128 v33;
  uint64_t k;
  void (***MILContext)(MIL::MILContextImpl *__hidden);
  _QWORD *v36;
  MIL::Fp16 *v37;
  float v38;
  __int16 v39;
  _WORD *v40;
  std::__shared_weak_count *v41;
  unint64_t *p_shared_owners;
  unint64_t v43;
  unint64_t v44;
  void (***v45)(MIL::MILContextImpl *__hidden);
  _QWORD *v46;
  uint64_t v47;
  float *v48;
  float v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t m;
  uint64_t ArgumentCount;
  uint64_t v56;
  MIL::IRValueType *v57;
  uint64_t v58;
  MIL::IRValueType *v59;
  uint64_t v60;
  uint64_t ii;
  uint64_t jj;
  uint64_t kk;
  uint64_t mm;
  uint64_t n;
  MIL::IRValueType *v66;
  uint64_t v67;
  MIL::Fp16 *v68;
  __int16 v69;
  MIL::Fp16 *v70;
  __int16 v71;
  uint64_t nn;
  uint64_t i1;
  uint64_t i2;
  uint64_t i3;
  uint64_t i4;
  uint64_t i5;
  MIL::MatchingPrivate::MatchItem *v78;
  __n128 *v79;
  uint64_t v80;
  __n128 *v81;
  uint64_t v82;
  _BYTE v83[16];
  uint64_t *v84;
  void **p_p;
  uint64_t v86;
  __n128 v87;
  _QWORD *v88;
  const char *v89;
  _BYTE v90[32];
  __n128 v91;
  char v92;
  __n128 v93;
  char v94;
  std::__shared_weak_count *v95;
  const char *v96;
  _BYTE v97[32];
  __n128 v98[2];
  void *__p;
  _BYTE v100[15];
  char v101;
  const char *v102;
  _BYTE v103[32];
  const char *v104;
  _BYTE v105[32];
  const char *v106;
  _BYTE v107[32];
  __n128 v108[2];
  uint64_t v109[2];
  uint64_t v110[2];
  uint64_t v111[2];
  __n128 *v112;
  uint64_t v113;
  __n128 v114[2];
  __n128 v115[2];
  __n128 v116;
  float *v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  MIL::Matching::MatchView::MatchView(&v78, a3);
  Attributes = MIL::Matching::MatchView::GetAttributes(&v78);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v83, Attributes);
  std::string::basic_string[abi:ne180100]<0>(&__p, "query");
  MIL::Matching::MatchView::GetArgument(&v78, (uint64_t)&__p, v111);
  if (v101 < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "key");
  MIL::Matching::MatchView::GetArgument(&v78, (uint64_t)&__p, v110);
  if (v101 < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "value");
  MIL::Matching::MatchView::GetArgument(&v78, (uint64_t)&__p, v109);
  if (v101 < 0)
    operator delete(__p);
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, (const MIL::Matching::ArgumentView *)v111);
  v102 = "y";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v103, (const MIL::Matching::ArgumentView *)v110);
  v104 = "transpose_x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v105, 0);
  v106 = "transpose_y";
  MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v107, 1);
  v93.n128_u64[0] = (unint64_t)&__p;
  v93.n128_u64[1] = 4;
  MIL::Transform::MatchContext::AddOperation(a2, "ios18::matmul", (uint64_t *)&v93, (uint64_t)v83, v108);
  for (i = 128; i != -32; i -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[i - 8]);
  Type = (MIL::IRValueType *)MIL::Matching::ArgumentView::GetType((MIL::Matching::ArgumentView *)v111);
  v7 = MIL::IRValueType::AsTensorType(Type);
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 96))(v7);
  if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v8 + 8) - 8) + 16))(*(_QWORD *)(*(_QWORD *)(v8 + 8) - 8)))
  {
    v9 = (MIL::IRValueType *)MIL::Matching::ArgumentView::GetType((MIL::Matching::ArgumentView *)v111);
    v10 = MIL::IRValueType::AsTensorType(v9);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 96))(v10);
    v12 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v11 + 8) - 8) + 16))(*(_QWORD *)(*(_QWORD *)(v11 + 8) - 8));
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 48))(v12);
    std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map<std::__hash_map_const_iterator<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *> *>>>((uint64_t)&__p, v84, 0);
    v14 = (MIL::IRValueType *)MIL::Matching::ArgumentView::GetType((MIL::Matching::ArgumentView *)v111);
    v15 = MIL::IRValueType::AsTensorType(v14);
    v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 88))(v15);
    if (v16 == 4)
    {
      MILContext = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext((MIL::Transform::MatchContext *)a2);
      v36 = operator new(8uLL);
      v87.n128_u64[0] = (unint64_t)v36;
      *v36 = 1;
      v87.n128_u64[1] = (unint64_t)(v36 + 1);
      v88 = v36 + 1;
      v37 = (MIL::Fp16 *)MIL::IRTensorValueType::Make(MILContext, 4, (MIL::MILContext ***)&v87);
      v38 = sqrt((double)v13);
      v39 = MIL::Fp16::FromFloat(v37, v38);
      v40 = operator new(2uLL);
      v116.n128_u64[0] = (unint64_t)v40;
      *v40 = v39;
      v116.n128_u64[1] = (unint64_t)(v40 + 1);
      v117 = (float *)(v40 + 1);
      MIL::IRTensorValueType::MakeFloat16Value((uint64_t)v37, (uint64_t)&v116, v115);
      std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100]<char const(&)[4],std::unique_ptr<MIL::IRTensorValue const>,0>(&v93, "val", (uint64_t *)v115);
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>>((uint64_t)&__p, (unsigned __int8 *)&v93, (__int128 *)&v93);
      v41 = v95;
      if (v95)
      {
        p_shared_owners = (unint64_t *)&v95->__shared_owners_;
        do
          v43 = __ldaxr(p_shared_owners);
        while (__stlxr(v43 - 1, p_shared_owners));
        if (!v43)
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }
      if (v94 < 0)
        operator delete((void *)v93.n128_u64[0]);
      v44 = v115[0].n128_u64[0];
      v115[0].n128_u64[0] = 0;
      if (v44)
        (*(void (**)(unint64_t))(*(_QWORD *)v44 + 8))(v44);
      if (v116.n128_u64[0])
      {
        v116.n128_u64[1] = v116.n128_u64[0];
        operator delete((void *)v116.n128_u64[0]);
      }
      if (v87.n128_u64[0])
      {
        v87.n128_u64[1] = v87.n128_u64[0];
        operator delete((void *)v87.n128_u64[0]);
      }
    }
    else if (v16 == 7)
    {
      v17 = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext((MIL::Transform::MatchContext *)a2);
      v18 = operator new(8uLL);
      v87.n128_u64[0] = (unint64_t)v18;
      *v18 = 1;
      v87.n128_u64[1] = (unint64_t)(v18 + 1);
      v88 = v18 + 1;
      v19 = (MIL::Bf16 *)MIL::IRTensorValueType::Make(v17, 7, (MIL::MILContext ***)&v87);
      v20 = sqrt((double)v13);
      v21 = MIL::Bf16::FromFloat(v19, v20);
      v22 = operator new(2uLL);
      v116.n128_u64[0] = (unint64_t)v22;
      *v22 = v21;
      v116.n128_u64[1] = (unint64_t)(v22 + 1);
      v117 = (float *)(v22 + 1);
      MIL::IRTensorValueType::MakeBFloat16Value((uint64_t)v19, (uint64_t)&v116, v115);
      std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100]<char const(&)[4],std::unique_ptr<MIL::IRTensorValue const>,0>(&v93, "val", (uint64_t *)v115);
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>>((uint64_t)&__p, (unsigned __int8 *)&v93, (__int128 *)&v93);
      v23 = v95;
      if (v95)
      {
        v24 = (unint64_t *)&v95->__shared_owners_;
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      if (v94 < 0)
        operator delete((void *)v93.n128_u64[0]);
      v26 = v115[0].n128_u64[0];
      v115[0].n128_u64[0] = 0;
      if (v26)
        (*(void (**)(unint64_t))(*(_QWORD *)v26 + 8))(v26);
      if (v116.n128_u64[0])
      {
        v116.n128_u64[1] = v116.n128_u64[0];
        operator delete((void *)v116.n128_u64[0]);
      }
      if (v87.n128_u64[0])
      {
        v87.n128_u64[1] = v87.n128_u64[0];
        operator delete((void *)v87.n128_u64[0]);
      }
    }
    else
    {
      v45 = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext((MIL::Transform::MatchContext *)a2);
      v46 = operator new(8uLL);
      v87.n128_u64[0] = (unint64_t)v46;
      *v46 = 1;
      v87.n128_u64[1] = (unint64_t)(v46 + 1);
      v88 = v46 + 1;
      v47 = MIL::IRTensorValueType::Make(v45, 5, (MIL::MILContext ***)&v87);
      v48 = (float *)operator new(4uLL);
      v49 = sqrt((double)v13);
      v116.n128_u64[0] = (unint64_t)v48;
      *v48 = v49;
      v116.n128_u64[1] = (unint64_t)(v48 + 1);
      v117 = v48 + 1;
      MIL::IRTensorValueType::MakeFloat32Value(v47, (uint64_t)&v116, v115);
      std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100]<char const(&)[4],std::unique_ptr<MIL::IRTensorValue const>,0>(&v93, "val", (uint64_t *)v115);
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>>((uint64_t)&__p, (unsigned __int8 *)&v93, (__int128 *)&v93);
      v50 = v95;
      if (v95)
      {
        v51 = (unint64_t *)&v95->__shared_owners_;
        do
          v52 = __ldaxr(v51);
        while (__stlxr(v52 - 1, v51));
        if (!v52)
        {
          ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
          std::__shared_weak_count::__release_weak(v50);
        }
      }
      if (v94 < 0)
        operator delete((void *)v93.n128_u64[0]);
      v53 = v115[0].n128_u64[0];
      v115[0].n128_u64[0] = 0;
      if (v53)
        (*(void (**)(unint64_t))(*(_QWORD *)v53 + 8))(v53);
      if (v116.n128_u64[0])
      {
        v116.n128_u64[1] = v116.n128_u64[0];
        operator delete((void *)v116.n128_u64[0]);
      }
      if (v87.n128_u64[0])
      {
        v87.n128_u64[1] = v87.n128_u64[0];
        operator delete((void *)v87.n128_u64[0]);
      }
    }
    v93 = 0uLL;
    MIL::Transform::MatchContext::AddOperation(a2, "ios18::const", (uint64_t *)&v93, (uint64_t)&__p, v98);
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&__p);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, "ios18");
    v27 = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext((MIL::Transform::MatchContext *)a2);
    if (v101 < 0)
      operator delete(__p);
    std::string::basic_string[abi:ne180100]<0>(&__p, "ios18");
    v28 = (void (***)(MIL::MILContextImpl *__hidden))MIL::Transform::MatchContext::GetMILContext((MIL::Transform::MatchContext *)a2);
    if (v101 < 0)
      operator delete(__p);
    v93.n128_u64[0] = (unint64_t)"x";
    MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)&v93.n128_i8[8], (const MIL::Matching::ArgumentView *)v111);
    v112 = &v93;
    v113 = 1;
    MIL::Transform::MatchContext::AddOperation(a2, "ios18::shape", (uint64_t *)&v112, v114);
    __p = "x";
    MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, v114);
    v102 = "begin";
    MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v103, &v87);
    v104 = "size";
    MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v105, &v116);
    v91.n128_u64[0] = (unint64_t)&__p;
    v91.n128_u64[1] = 3;
    MIL::Transform::MatchContext::AddOperation(a2, "ios18::slice_by_size", (uint64_t *)&v91, (uint64_t)v83, v115);
    for (j = 88; j != -32; j -= 40)
      MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[j - 8]);
    MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v114);
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v93.n128_i8[8]);
    v30 = (MIL::IRValueType *)MIL::Matching::ArgumentView::GetType((MIL::Matching::ArgumentView *)v111);
    v31 = MIL::IRValueType::AsTensorType(v30);
    v32 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v31 + 88))(v31);
    MIL::IRDataTypeToString(v32, &v91);
    __p = "x";
    v33 = MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, v115);
    v102 = "dtype";
    MIL::Transform::ArgumentDescription::ArgumentDescription(v103, &v91, v33);
    p_p = &__p;
    v86 = 2;
    MIL::Transform::MatchContext::AddOperation(a2, "ios18::cast", (uint64_t *)&p_p, (uint64_t)v83, v114);
    v93.n128_u64[0] = (unint64_t)"x";
    MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)&v93.n128_i8[8], v114);
    v112 = &v93;
    v113 = 1;
    MIL::Transform::MatchContext::AddOperation(a2, "ios18::sqrt", (uint64_t *)&v112, (uint64_t)v83, v98);
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v93.n128_i8[8]);
    MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v114);
    for (k = 48; k != -32; k -= 40)
      MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[k - 8]);
    if (v92 < 0)
      operator delete((void *)v91.n128_u64[0]);
    MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v115);
    MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v116);
    MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v87);
  }
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, v108);
  v102 = "y";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v103, v98);
  v93.n128_u64[0] = (unint64_t)&__p;
  v93.n128_u64[1] = 2;
  MIL::Transform::MatchContext::AddOperation(a2, "ios18::real_div", (uint64_t *)&v93, (uint64_t)v83, &v116);
  for (m = 48; m != -32; m -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[m - 8]);
  std::string::basic_string[abi:ne180100]<0>(&__p, "attn_mask");
  ArgumentCount = MIL::Matching::MatchView::GetArgumentCount(&v78, (const void **)&__p);
  v56 = ArgumentCount;
  if ((v101 & 0x80000000) == 0)
  {
    if (!ArgumentCount)
      goto LABEL_98;
LABEL_71:
    std::string::basic_string[abi:ne180100]<0>(&__p, "attn_mask");
    MIL::Matching::MatchView::GetArgument(&v78, (uint64_t)&__p, (uint64_t *)&v112);
    if (v101 < 0)
      operator delete(__p);
    v57 = (MIL::IRValueType *)MIL::Matching::ArgumentView::GetType((MIL::Matching::ArgumentView *)&v112);
    v58 = MIL::IRValueType::AsTensorType(v57);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v58 + 88))(v58) != 2)
    {
      __p = "x";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, &v116);
      v102 = "y";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v103, (const MIL::Matching::ArgumentView *)&v112);
      v87.n128_u64[0] = (unint64_t)&__p;
      v87.n128_u64[1] = 2;
      MIL::Transform::MatchContext::AddOperation(a2, "ios18::add", (uint64_t *)&v87, (uint64_t)v83, &v93);
      MIL::Transform::NewOperationOutput::operator=(&v116, &v93);
      MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v93);
      for (n = 48; n != -32; n -= 40)
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[n - 8]);
      goto LABEL_97;
    }
    v59 = (MIL::IRValueType *)MIL::Matching::ArgumentView::GetType((MIL::Matching::ArgumentView *)v111);
    v60 = MIL::IRValueType::AsTensorType(v59);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v60 + 88))(v60) == 5)
    {
      __p = "cond";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, (const MIL::Matching::ArgumentView *)&v112);
      v93.n128_u64[0] = (unint64_t)"ref_tensor";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)&v93.n128_i8[8], (const MIL::Matching::ArgumentView *)&v112);
      v96 = "value";
      MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v97, 1.0);
      v81 = &v93;
      v82 = 2;
      MIL::Transform::MatchContext::AddOperation(a2, "ios18::fill_like", (uint64_t *)&v81, (uint64_t)v83, v114);
      v102 = "a";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v103, v114);
      v87.n128_u64[0] = (unint64_t)"ref_tensor";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)&v87.n128_i8[8], (const MIL::Matching::ArgumentView *)&v112);
      v89 = "value";
      MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v90, -INFINITY);
      v79 = &v87;
      v80 = 2;
      MIL::Transform::MatchContext::AddOperation(a2, "ios18::fill_like", (uint64_t *)&v79, (uint64_t)v83, &v91);
      v104 = "b";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v105, &v91);
      p_p = &__p;
      v86 = 3;
      MIL::Transform::MatchContext::AddOperation(a2, "ios18::select", (uint64_t *)&p_p, (uint64_t)v83, v115);
      for (ii = 88; ii != -32; ii -= 40)
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[ii - 8]);
      MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v91);
      for (jj = 48; jj != -32; jj -= 40)
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)((char *)&v87 + jj));
      MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v114);
      for (kk = 48; kk != -32; kk -= 40)
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)((char *)&v93 + kk));
      __p = "x";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, &v116);
      v102 = "y";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v103, v115);
      v87.n128_u64[0] = (unint64_t)&__p;
      v87.n128_u64[1] = 2;
      MIL::Transform::MatchContext::AddOperation(a2, "ios18::add", (uint64_t *)&v87, (uint64_t)v83, &v93);
      MIL::Transform::NewOperationOutput::operator=(&v116, &v93);
      MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v93);
      for (mm = 48; mm != -32; mm -= 40)
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[mm - 8]);
    }
    else
    {
      v66 = (MIL::IRValueType *)MIL::Matching::ArgumentView::GetType((MIL::Matching::ArgumentView *)v111);
      v67 = MIL::IRValueType::AsTensorType(v66);
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v67 + 88))(v67) != 4)
      {
LABEL_97:
        MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)&v112);
        goto LABEL_98;
      }
      __p = "cond";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, (const MIL::Matching::ArgumentView *)&v112);
      v93.n128_u64[0] = (unint64_t)"ref_tensor";
      v68 = (MIL::Fp16 *)MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)&v93.n128_i8[8], (const MIL::Matching::ArgumentView *)&v112);
      v69 = MIL::Fp16::FromFloat(v68, 1.0);
      v96 = "value";
      MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v97, v69);
      v81 = &v93;
      v82 = 2;
      MIL::Transform::MatchContext::AddOperation(a2, "ios18::fill_like", (uint64_t *)&v81, (uint64_t)v83, v114);
      v102 = "a";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v103, v114);
      v87.n128_u64[0] = (unint64_t)"ref_tensor";
      v70 = (MIL::Fp16 *)MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)&v87.n128_i8[8], (const MIL::Matching::ArgumentView *)&v112);
      v71 = MIL::Fp16::FromFloat(v70, -INFINITY);
      v89 = "value";
      MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v90, v71);
      v79 = &v87;
      v80 = 2;
      MIL::Transform::MatchContext::AddOperation(a2, "ios18::fill_like", (uint64_t *)&v79, (uint64_t)v83, &v91);
      v104 = "b";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v105, &v91);
      p_p = &__p;
      v86 = 3;
      MIL::Transform::MatchContext::AddOperation(a2, "ios18::select", (uint64_t *)&p_p, (uint64_t)v83, v115);
      for (nn = 88; nn != -32; nn -= 40)
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[nn - 8]);
      MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v91);
      for (i1 = 48; i1 != -32; i1 -= 40)
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)((char *)&v87 + i1));
      MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v114);
      for (i2 = 48; i2 != -32; i2 -= 40)
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)((char *)&v93 + i2));
      __p = "x";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, &v116);
      v102 = "y";
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v103, v115);
      v87.n128_u64[0] = (unint64_t)&__p;
      v87.n128_u64[1] = 2;
      MIL::Transform::MatchContext::AddOperation(a2, "ios18::add", (uint64_t *)&v87, (uint64_t)v83, &v93);
      MIL::Transform::NewOperationOutput::operator=(&v116, &v93);
      MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v93);
      for (i3 = 48; i3 != -32; i3 -= 40)
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[i3 - 8]);
    }
    MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v115);
    goto LABEL_97;
  }
  operator delete(__p);
  if (v56)
    goto LABEL_71;
LABEL_98:
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, &v116);
  v102 = "axis";
  MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v103, -1);
  v87.n128_u64[0] = (unint64_t)&__p;
  v87.n128_u64[1] = 2;
  MIL::Transform::MatchContext::AddOperation(a2, "ios18::softmax", (uint64_t *)&v87, (uint64_t)v83, &v93);
  for (i4 = 48; i4 != -32; i4 -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[i4 - 8]);
  __p = "x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v100, &v93);
  v102 = "y";
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v103, (const MIL::Matching::ArgumentView *)v109);
  v104 = "transpose_x";
  MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v105, 0);
  v106 = "transpose_y";
  MIL::Transform::ArgumentDescription::ArgumentDescription((uint64_t)v107, 0);
  v115[0].n128_u64[0] = (unint64_t)&__p;
  v115[0].n128_u64[1] = 4;
  MIL::Transform::MatchContext::AddOperation(a2, "ios18::matmul", (uint64_t *)v115, (uint64_t)v83, &v87);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v87);
  for (i5 = 128; i5 != -32; i5 -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)&v100[i5 - 8]);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v93);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&v116);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v98);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)v108);
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v109);
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v110);
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)v111);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v83);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&v78);
}

void sub_1E0572908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a69;
  uint64_t v69;
  uint64_t i;

  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&__p);
  for (i = 48; i != -32; i -= 40)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)((char *)&a49 + i));
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)(v69 - 160));
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)(v69 - 208));
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)(v69 - 128));
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&a45);
  MIL::Transform::NewOperationOutput::~NewOperationOutput((MIL::Transform::NewOperationOutput *)&a69);
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)(v69 - 256));
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)(v69 - 240));
  MIL::Matching::ArgumentView::~ArgumentView((MIL::Matching::ArgumentView *)(v69 - 224));
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a14);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0,std::allocator<MIL::Conversion::MakeIos18DecompositionSDPATransform(void)::$_0>,void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)>::target_type()
{
}

uint64_t std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map<std::__hash_map_const_iterator<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *> *>>>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unsigned __int8 *v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a2 != a3)
  {
    v5 = (unsigned __int8 *)a2;
    do
    {
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRValue const>> const&>(a1, v5 + 16, (__int128 *)v5 + 1);
      v5 = *(unsigned __int8 **)v5;
    }
    while (v5 != (unsigned __int8 *)a3);
  }
  return a1;
}

void sub_1E05730D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__construct_node_hash<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1E0573354(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__construct_node_hash<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x38uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100]((std::string *)(v8 + 16), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1E05733C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t OUTLINED_FUNCTION_0()
{
  uint64_t v0;

  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v0 + 16))(v0);
}

void OUTLINED_FUNCTION_1(unint64_t *a1@<X8>)
{
  unint64_t v1;

  v1 = __ldaxr(a1);
  __stlxr(v1 - 1, a1);
}

void OUTLINED_FUNCTION_3()
{
  std::__shared_weak_count *v0;

  std::__shared_weak_count::__release_weak(v0);
}

_QWORD *MIL::Passes::FlattenBlockNamespace::FlattenBlockNamespace(MIL::Passes::FlattenBlockNamespace *this)
{
  _QWORD *result;

  result = MIL::Pass::Pass(this);
  *result = &off_1EA992E38;
  return result;
}

{
  _QWORD *result;

  result = MIL::Pass::Pass(this);
  *result = &off_1EA992E38;
  return result;
}

void MIL::Passes::FlattenBlockNamespace::~FlattenBlockNamespace(MIL::Passes::FlattenBlockNamespace *this)
{
  MIL::Pass::~Pass(this);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::Passes::FlattenBlockNamespace::Make@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v3;
  _QWORD *result;

  v3 = (_QWORD *)operator new();
  result = MIL::Pass::Pass(v3);
  *v3 = &off_1EA992E38;
  *a1 = v3;
  return result;
}

void sub_1E057352C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0x81C40B8603338);
  _Unwind_Resume(a1);
}

uint64_t MIL::Passes::FlattenBlockNamespace::Run(MIL::Passes::FlattenBlockNamespace *this, const MIL::IRBlock *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _OWORD *v7;
  _OWORD v8[2];
  int v9;
  _OWORD v10[2];
  int v11;
  _BYTE v12[24];
  _BYTE *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  memset(v10, 0, sizeof(v10));
  v11 = 1065353216;
  memset(v8, 0, sizeof(v8));
  v9 = 1065353216;
  v7 = v10;
  v3 = operator new(0x20uLL);
  *v3 = &off_1EA992EC8;
  v3[1] = v12;
  v3[2] = v8;
  v3[3] = &v7;
  v13 = v3;
  std::__function::__func<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1,std::allocator<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1>,std::unique_ptr<MIL::IRBlock> ()(MIL::IRBlock const&)>::operator()(v3, (uint64_t)a2);
  v4 = v13;
  if (v13 == v12)
  {
    v5 = 4;
    v4 = v12;
    goto LABEL_5;
  }
  if (v13)
  {
    v5 = 5;
LABEL_5:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v8);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v10);
}

void sub_1E057364C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v6 = *(_QWORD **)(v4 - 48);
  if (v6 == v3)
  {
    v7 = 4;
    v6 = (_QWORD *)(v4 - 72);
  }
  else
  {
    if (!v6)
      goto LABEL_6;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_6:
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)va);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t ***`anonymous namespace'::FindRedefinedValues(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 *i;
  char v7;
  uint64_t ***result;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;

  for (i = *(unsigned __int8 **)((*(uint64_t (**)(_QWORD *))(a1[8] + 32))(a1 + 8) + 16);
        i;
        i = *(unsigned __int8 **)i)
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a2, i + 16, (uint64_t)(i + 16));
    if ((v7 & 1) == 0)
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a3, i + 16, (uint64_t)(i + 16));
  }
  result = (uint64_t ***)(*(uint64_t (**)(_QWORD *))(*a1 + 56))(a1);
  v9 = **result;
  v10 = (*result)[1];
  while (v9 != v10)
  {
    result = (uint64_t ***)(*(uint64_t (**)(uint64_t))(*(_QWORD *)*v9 + 208))(*v9);
    v11 = **result;
    v12 = (*result)[1];
    while (v11 != v12)
    {
      v13 = *v11;
      v11 += 2;
    }
    v9 += 2;
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__construct_node_hash<std::string const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  ++*v7;
  return i;
}

void sub_1E05739CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__construct_node_hash<std::string const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;

  v7 = a1 + 16;
  v8 = operator new(0x28uLL);
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v9->__r_.__value_.__r.__words[2] = *(_QWORD *)(a3 + 16);
  }
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_1E0573A74(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 39) < 0)
      operator delete(__p[2]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(a1, *(void ***)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(int a1, void **__p)
{
  void **v2;
  void **v3;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0)
        operator delete(v2[2]);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1E0C023A0);
}

void std::__function::__func<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1,std::allocator<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1>,std::unique_ptr<MIL::IRBlock> ()(MIL::IRBlock const&)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1,std::allocator<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1>,std::unique_ptr<MIL::IRBlock> ()(MIL::IRBlock const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1EA992EC8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1,std::allocator<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1>,std::unique_ptr<MIL::IRBlock> ()(MIL::IRBlock const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA992EC8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1,std::allocator<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1>,std::unique_ptr<MIL::IRBlock> ()(MIL::IRBlock const&)>::operator()(_QWORD *a1, uint64_t a2)
{
  uint64_t ***v3;
  uint64_t *v4;
  uint64_t v5;
  _QWORD **v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  std::string::size_type v10;
  _QWORD *v11;
  std::string::size_type v12;
  std::string::size_type size;
  std::string::size_type v14;
  uint64_t v15;
  unint64_t v16;
  int64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  std::string::size_type *v21;
  _QWORD *v22;
  std::string::size_type v23;
  std::string::size_type v24;
  __int128 v25;
  int64x2_t v26;
  std::string::size_type v27;
  std::string::size_type v28;
  std::string::size_type v29;
  _QWORD *v30;
  std::string::size_type v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  std::string::size_type *v40;
  _QWORD *v41;
  _QWORD *v42;
  char *v43;
  __int128 v44;
  int64x2_t v45;
  char *v46;
  std::string::size_type v47;
  uint64_t *j;
  _QWORD *v49;
  uint64_t *v50;
  std::string *v51;
  std::string::size_type v52;
  std::string *v53;
  __int128 v54;
  unsigned int v55;
  std::string *v56;
  std::string::size_type v57;
  std::string *v58;
  void *v59;
  char v60;
  _QWORD *v61;
  uint64_t *i;
  void *__p[4];
  std::string v65;
  __int128 v66;
  void *v67;
  std::vector<std::pair<std::string, std::string>> v68;
  _QWORD *v69;
  int64x2_t v70;
  char *v71;
  std::string v72;
  std::string v73;
  _QWORD v74[5];

  v74[2] = *MEMORY[0x1E0C80C00];
  v70 = 0uLL;
  v71 = 0;
  v3 = (uint64_t ***)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 56))(a2);
  v4 = **v3;
  for (i = (*v3)[1]; v4 != i; v4 += 2)
  {
    v5 = *v4;
    memset(&v73, 0, sizeof(v73));
    v6 = (_QWORD **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 208))(v5);
    v7 = (_QWORD *)**v6;
    v8 = (_QWORD *)(*v6)[1];
    while (v7 != v8)
    {
      v9 = *(_QWORD *)(a1[1] + 24);
      if (!v9)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(std::string *__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v9 + 48))(&v72, v9, *v7);
      v10 = v72.__r_.__value_.__r.__words[0];
      if (v72.__r_.__value_.__r.__words[0])
      {
        v11 = (_QWORD *)operator new();
        v12 = v72.__r_.__value_.__r.__words[0];
        *v11 = &unk_1EA992F48;
        v11[1] = 0;
        v11[2] = 0;
        v11[3] = v12;
      }
      else
      {
        v11 = 0;
      }
      v72.__r_.__value_.__r.__words[0] = 0;
      size = v73.__r_.__value_.__l.__size_;
      if (v73.__r_.__value_.__l.__size_ >= v73.__r_.__value_.__r.__words[2])
      {
        v15 = (uint64_t)(v73.__r_.__value_.__l.__size_ - v73.__r_.__value_.__r.__words[0]) >> 4;
        v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 60)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v17 = v73.__r_.__value_.__r.__words[2] - v73.__r_.__value_.__r.__words[0];
        if ((uint64_t)(v73.__r_.__value_.__r.__words[2] - v73.__r_.__value_.__r.__words[0]) >> 3 > v16)
          v16 = v17 >> 3;
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0)
          v18 = 0xFFFFFFFFFFFFFFFLL;
        else
          v18 = v16;
        *((_QWORD *)&v66 + 1) = (char *)&v73.__r_.__value_.__l + 16;
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)&v73.__r_.__value_.__r.__words[2], v18);
        v21 = (std::string::size_type *)&v19[16 * v15];
        *v21 = v10;
        v21[1] = (std::string::size_type)v11;
        v22 = (_QWORD *)v73.__r_.__value_.__l.__size_;
        v23 = v73.__r_.__value_.__r.__words[0];
        if (v73.__r_.__value_.__l.__size_ == v73.__r_.__value_.__r.__words[0])
        {
          v26 = vdupq_n_s64(v73.__r_.__value_.__l.__size_);
          v24 = (std::string::size_type)&v19[16 * v15];
        }
        else
        {
          v24 = (std::string::size_type)&v19[16 * v15];
          do
          {
            v25 = *((_OWORD *)v22 - 1);
            v22 -= 2;
            *(_OWORD *)(v24 - 16) = v25;
            v24 -= 16;
            *v22 = 0;
            v22[1] = 0;
          }
          while (v22 != (_QWORD *)v23);
          v26 = *(int64x2_t *)&v73.__r_.__value_.__l.__data_;
        }
        v14 = (std::string::size_type)(v21 + 2);
        v73.__r_.__value_.__r.__words[0] = v24;
        v73.__r_.__value_.__l.__size_ = (std::string::size_type)(v21 + 2);
        *(int64x2_t *)&v65.__r_.__value_.__r.__words[1] = v26;
        v27 = v73.__r_.__value_.__r.__words[2];
        v73.__r_.__value_.__r.__words[2] = (std::string::size_type)&v19[16 * v20];
        *(_QWORD *)&v66 = v27;
        v65.__r_.__value_.__r.__words[0] = v26.i64[0];
        std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v65);
      }
      else
      {
        *(_QWORD *)v73.__r_.__value_.__l.__size_ = v10;
        *(_QWORD *)(size + 8) = v11;
        v14 = size + 16;
      }
      v73.__r_.__value_.__l.__size_ = v14;
      v28 = v72.__r_.__value_.__r.__words[0];
      v72.__r_.__value_.__r.__words[0] = 0;
      if (v28)
        (*(void (**)(std::string::size_type))(*(_QWORD *)v28 + 8))(v28);
      v7 += 2;
    }
    (*(void (**)(std::string *__return_ptr, uint64_t, std::string *))(*(_QWORD *)v5 + 40))(&v72, v5, &v73);
    v29 = v72.__r_.__value_.__r.__words[0];
    if (v72.__r_.__value_.__r.__words[0])
    {
      v30 = (_QWORD *)operator new();
      v31 = v72.__r_.__value_.__r.__words[0];
      *v30 = &unk_1EA992FA8;
      v30[1] = 0;
      v30[2] = 0;
      v30[3] = v31;
    }
    else
    {
      v30 = 0;
    }
    v72.__r_.__value_.__r.__words[0] = 0;
    v32 = v70.i64[1];
    if (v70.i64[1] >= (unint64_t)v71)
    {
      v34 = (v70.i64[1] - v70.i64[0]) >> 4;
      v35 = v34 + 1;
      if ((unint64_t)(v34 + 1) >> 60)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v36 = (uint64_t)&v71[-v70.i64[0]];
      if ((uint64_t)&v71[-v70.i64[0]] >> 3 > v35)
        v35 = v36 >> 3;
      if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF0)
        v37 = 0xFFFFFFFFFFFFFFFLL;
      else
        v37 = v35;
      *((_QWORD *)&v66 + 1) = &v71;
      v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)&v71, v37);
      v40 = (std::string::size_type *)&v38[16 * v34];
      *v40 = v29;
      v40[1] = (std::string::size_type)v30;
      v41 = (_QWORD *)v70.i64[1];
      v42 = (_QWORD *)v70.i64[0];
      if (v70.i64[1] == v70.i64[0])
      {
        v45 = vdupq_n_s64(v70.u64[1]);
        v43 = &v38[16 * v34];
      }
      else
      {
        v43 = &v38[16 * v34];
        do
        {
          v44 = *((_OWORD *)v41 - 1);
          v41 -= 2;
          *((_OWORD *)v43 - 1) = v44;
          v43 -= 16;
          *v41 = 0;
          v41[1] = 0;
        }
        while (v41 != v42);
        v45 = v70;
      }
      v33 = v40 + 2;
      v70.i64[0] = (uint64_t)v43;
      v70.i64[1] = (uint64_t)(v40 + 2);
      *(int64x2_t *)&v65.__r_.__value_.__r.__words[1] = v45;
      v46 = v71;
      v71 = &v38[16 * v39];
      *(_QWORD *)&v66 = v46;
      v65.__r_.__value_.__r.__words[0] = v45.i64[0];
      std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v65);
    }
    else
    {
      *(_QWORD *)v70.i64[1] = v29;
      *(_QWORD *)(v32 + 8) = v30;
      v33 = (_QWORD *)(v32 + 16);
    }
    v70.i64[1] = (uint64_t)v33;
    v47 = v72.__r_.__value_.__r.__words[0];
    v72.__r_.__value_.__r.__words[0] = 0;
    if (v47)
      (*(void (**)(std::string::size_type))(*(_QWORD *)v47 + 8))(v47);
    v65.__r_.__value_.__r.__words[0] = (std::string::size_type)&v73;
    std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v65);
  }
  (*(void (**)(_QWORD **__return_ptr, uint64_t, int64x2_t *))(*(_QWORD *)a2 + 112))(&v69, a2, &v70);
  memset(&v68, 0, sizeof(v68));
  for (j = *(uint64_t **)(a1[2] + 16); j; j = (uint64_t *)*j)
  {
    v49 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v69[8] + 32))(v69 + 8);
    if (std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v49, (unsigned __int8 *)j + 16))
    {
      v50 = (uint64_t *)a1[3];
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)j + 2, 95, (uint64_t)&v73);
      std::to_string(&v72, 0);
      if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v51 = &v72;
      else
        v51 = (std::string *)v72.__r_.__value_.__r.__words[0];
      if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v52 = HIBYTE(v72.__r_.__value_.__r.__words[2]);
      else
        v52 = v72.__r_.__value_.__l.__size_;
      v53 = std::string::append(&v73, (const std::string::value_type *)v51, v52);
      v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
      __p[2] = (void *)v53->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v54;
      v53->__r_.__value_.__l.__size_ = 0;
      v53->__r_.__value_.__r.__words[2] = 0;
      v53->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v72.__r_.__value_.__l.__data_);
      if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v73.__r_.__value_.__l.__data_);
      if (std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)*v50, (unsigned __int8 *)__p))
      {
        v55 = 1;
        do
        {
          std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)j + 2, 95, (uint64_t)&v73);
          std::to_string(&v72, v55);
          if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v56 = &v72;
          else
            v56 = (std::string *)v72.__r_.__value_.__r.__words[0];
          if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v57 = HIBYTE(v72.__r_.__value_.__r.__words[2]);
          else
            v57 = v72.__r_.__value_.__l.__size_;
          v58 = std::string::append(&v73, (const std::string::value_type *)v56, v57);
          v59 = (void *)v58->__r_.__value_.__r.__words[0];
          v74[0] = v58->__r_.__value_.__l.__size_;
          *(_QWORD *)((char *)v74 + 7) = *(std::string::size_type *)((char *)&v58->__r_.__value_.__r.__words[1] + 7);
          v60 = HIBYTE(v58->__r_.__value_.__r.__words[2]);
          v58->__r_.__value_.__l.__size_ = 0;
          v58->__r_.__value_.__r.__words[2] = 0;
          v58->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__p[2]) < 0)
            operator delete(__p[0]);
          __p[0] = v59;
          __p[1] = (void *)v74[0];
          *(void **)((char *)&__p[1] + 7) = *(void **)((char *)v74 + 7);
          HIBYTE(__p[2]) = v60;
          if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v72.__r_.__value_.__l.__data_);
          if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v73.__r_.__value_.__l.__data_);
          ++v55;
        }
        while (std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)*v50, (unsigned __int8 *)__p));
      }
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(*v50, (unsigned __int8 *)__p, (uint64_t)__p);
      if (*((char *)j + 39) < 0)
        std::string::__init_copy_ctor_external(&v65, (const std::string::value_type *)j[2], j[3]);
      else
        v65 = *(std::string *)(j + 2);
      v66 = *(_OWORD *)__p;
      v67 = __p[2];
      memset(__p, 0, 24);
      std::vector<std::pair<std::string,std::string>>::push_back[abi:ne180100](&v68, (__int128 *)&v65);
      if (SHIBYTE(v67) < 0)
        operator delete((void *)v66);
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v65.__r_.__value_.__l.__data_);
      if (SHIBYTE(__p[2]) < 0)
        operator delete(__p[0]);
    }
  }
  (*(void (**)(_QWORD *, std::vector<std::pair<std::string, std::string>> *))(*v69 + 120))(v69, &v68);
  v65.__r_.__value_.__r.__words[0] = (std::string::size_type)&v68;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v65);
  v61 = v69;
  v69 = 0;
  if (v61)
    (*(void (**)(_QWORD *))(*v61 + 8))(v61);
  v65.__r_.__value_.__r.__words[0] = (std::string::size_type)&v70;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v65);
}

void sub_1E0574278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  uint64_t v38;
  uint64_t v40;

  a22 = &a34;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a22);
  v40 = a37;
  a37 = 0;
  if (v40)
    (*(void (**)(uint64_t))(*(_QWORD *)v40 + 8))(v40);
  *(_QWORD *)(v38 - 168) = &a38;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v38 - 168));
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1,std::allocator<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1>,std::unique_ptr<MIL::IRBlock> ()(MIL::IRBlock const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1,std::allocator<MIL::Passes::FlattenBlockNamespace::Run(MIL::IRBlock const&)::$_1>,std::unique_ptr<MIL::IRBlock> ()(MIL::IRBlock const&)>::target_type()
{
}

void std::vector<std::pair<std::string,std::string>>::push_back[abi:ne180100](std::vector<std::pair<std::string, std::string>> *a1, __int128 *a2)
{
  std::allocator<std::pair<std::string, std::string>> *p_end_cap;
  std::pair<std::string, std::string> *v5;
  std::pair<std::string, std::string> *value;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  std::pair<std::string, std::string> *end;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  std::pair<std::string, std::string> *v15;
  std::pair<std::string, std::string> *v16;
  __int128 v17;
  __int128 v18;
  std::__split_buffer<std::pair<std::string, std::string>> __v;

  value = a1->__end_cap_.__value_;
  p_end_cap = (std::allocator<std::pair<std::string, std::string>> *)&a1->__end_cap_;
  v5 = value;
  v7 = *((_QWORD *)p_end_cap - 1);
  if (v7 >= (unint64_t)value)
  {
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (unint64_t)a1->__begin_) >> 4);
    v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v13 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)a1->__begin_) >> 4);
    if (2 * v13 > v12)
      v12 = 2 * v13;
    if (v13 >= 0x2AAAAAAAAAAAAAALL)
      v14 = 0x555555555555555;
    else
      v14 = v12;
    __v.__end_cap_.__value_ = p_end_cap;
    if (v14)
      v15 = (std::pair<std::string, std::string> *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::string>>>((uint64_t)p_end_cap, v14);
    else
      v15 = 0;
    v16 = v15 + v11;
    __v.__first_ = v15;
    __v.__begin_ = v16;
    __v.__end_cap_.__value_ = &v15[v14];
    v17 = *a2;
    v16->first.__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v16->first.__r_.__value_.__l.__data_ = v17;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v18 = *(__int128 *)((char *)a2 + 24);
    v16->second.__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v16->second.__r_.__value_.__l.__data_ = v18;
    *((_QWORD *)a2 + 4) = 0;
    *((_QWORD *)a2 + 5) = 0;
    *((_QWORD *)a2 + 3) = 0;
    __v.__end_ = v16 + 1;
    std::vector<std::pair<std::string,std::string>>::__swap_out_circular_buffer(a1, &__v);
    end = a1->__end_;
    std::__split_buffer<std::pair<std::string,std::string>>::~__split_buffer(&__v);
  }
  else
  {
    v8 = *a2;
    *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v7 = v8;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v9 = *(__int128 *)((char *)a2 + 24);
    *(_QWORD *)(v7 + 40) = *((_QWORD *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((_QWORD *)a2 + 4) = 0;
    *((_QWORD *)a2 + 5) = 0;
    *((_QWORD *)a2 + 3) = 0;
    end = (std::pair<std::string, std::string> *)(v7 + 48);
    a1->__end_ = (std::vector<std::pair<std::string, std::string>>::pointer)(v7 + 48);
  }
  a1->__end_ = end;
}

void sub_1E05745D0(_Unwind_Exception *a1, std::__split_buffer<std::pair<std::string, std::string>> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::pair<std::string,std::string>>::~__split_buffer((std::__split_buffer<std::pair<std::string, std::string>> *)&a10);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

uint64_t std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](i - 16);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__shared_ptr_pointer<MIL::IRBlock  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::IRBlock  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IRBlock  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

void std::__shared_ptr_pointer<MIL::IROperation  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::IROperation  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IROperation  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

void std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 **v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t v13;

  v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), (uint64_t)a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = *((_QWORD *)v11 + 1);
      if (v6 == v13)
      {
        if ((std::equal_to<std::string>::operator()[abi:ne180100](v12, v11 + 16, a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = *(unsigned __int8 **)v11;
    }
    while (v11);
  }
  return v11;
}

void std::vector<std::pair<std::string,std::string>>::__swap_out_circular_buffer(std::vector<std::pair<std::string, std::string>> *this, std::__split_buffer<std::pair<std::string, std::string>> *__v)
{
  std::pair<std::string, std::string> *v4;
  std::pair<std::string, std::string> *begin;
  std::pair<std::string, std::string> *end;
  std::pair<std::string, std::string> *value;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<std::string,std::string>>,std::reverse_iterator<std::pair<std::string,std::string>*>,std::reverse_iterator<std::pair<std::string,std::string>*>,std::reverse_iterator<std::pair<std::string,std::string>*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::string>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(48 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<std::string,std::string>>,std::reverse_iterator<std::pair<std::string,std::string>*>,std::reverse_iterator<std::pair<std::string,std::string>*>,std::reverse_iterator<std::pair<std::string,std::string>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 48);
      *(_QWORD *)(v9 - 32) = *(_QWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 48) = v10;
      *(_QWORD *)(a3 - 40) = 0;
      *(_QWORD *)(a3 - 32) = 0;
      *(_QWORD *)(a3 - 48) = 0;
      v11 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v11;
      v9 -= 48;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 48;
      a3 -= 48;
    }
    while (a3 != a5);
    *((_QWORD *)&v16 + 1) = v9;
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::string,std::string>>,std::reverse_iterator<std::pair<std::string,std::string>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::string,std::string>>,std::reverse_iterator<std::pair<std::string,std::string>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::string,std::string>>,std::reverse_iterator<std::pair<std::string,std::string>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::string,std::string>>,std::reverse_iterator<std::pair<std::string,std::string>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<std::pair<std::string,std::string>>::destroy[abi:ne180100](v3, v1);
      v1 += 48;
    }
    while (v1 != v2);
  }
}

void std::allocator<std::pair<std::string,std::string>>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 47) < 0)
    operator delete(*(void **)(a2 + 24));
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

void std::__split_buffer<std::pair<std::string,std::string>>::~__split_buffer(std::__split_buffer<std::pair<std::string, std::string>> *this)
{
  std::__split_buffer<std::pair<std::string,std::string>>::clear[abi:ne180100](this);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::__split_buffer<std::pair<std::string,std::string>>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 48;
    std::allocator<std::pair<std::string,std::string>>::destroy[abi:ne180100](v4, i - 48);
  }
}

uint64_t std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>@<X0>(const void **a1@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  size_t v5;
  uint64_t result;
  char *v7;
  const void *v8;
  char *v9;

  if (*((char *)a1 + 23) >= 0)
    v5 = *((unsigned __int8 *)a1 + 23);
  else
    v5 = (size_t)a1[1];
  result = std::string::basic_string[abi:ne180100](a3, v5 + 1);
  if (*(char *)(result + 23) >= 0)
    v7 = (char *)result;
  else
    v7 = *(char **)result;
  if (v5)
  {
    if (*((char *)a1 + 23) >= 0)
      v8 = a1;
    else
      v8 = *a1;
    result = (uint64_t)memmove(v7, v8, v5);
  }
  v9 = &v7[v5];
  *v9 = a2;
  v9[1] = 0;
  return result;
}

void std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::allocator<std::pair<std::string,std::string>>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *MIL::Pass::Pass(_QWORD *this)
{
  *this = &off_1EA993018;
  return this;
}

{
  *this = &off_1EA993018;
  return this;
}

void MIL::Pass::~Pass(MIL::Pass *this)
{
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::Pass::Run(MIL::Pass *this, const MIL::IRProgram *a2)
{
  uint64_t *i;
  uint64_t v5;
  unsigned __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  _OWORD v12[2];
  int v13;
  __int128 *v14;

  memset(v12, 0, sizeof(v12));
  v13 = 1065353216;
  for (i = *(uint64_t **)((*(uint64_t (**)(const MIL::IRProgram *))(*(_QWORD *)a2 + 72))(a2) + 16);
        i;
        i = (uint64_t *)*i)
  {
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)i[5] + 48))(i[5]);
    (*(void (**)(uint64_t *__return_ptr, MIL::Pass *, uint64_t))(*(_QWORD *)this + 24))(&v11, this, v5);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)i[5] + 192))(&v10, i[5], &v11);
    v14 = (__int128 *)(i + 2);
    v6 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v12, (unsigned __int8 *)i + 16, (uint64_t)&std::piecewise_construct, &v14);
    std::shared_ptr<MIL::IRFunction>::operator=[abi:ne180100]<MIL::IRFunction,std::default_delete<MIL::IRFunction>,void>((_QWORD *)v6 + 5, &v10);
    v7 = v10;
    v10 = 0;
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    v8 = v11;
    v11 = 0;
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  }
  (*(void (**)(const MIL::IRProgram *, _OWORD *))(*(_QWORD *)a2 + 88))(a2, v12);
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v12);
}

void sub_1E0574DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<MIL::IRFunction>::operator=[abi:ne180100]<MIL::IRFunction,std::default_delete<MIL::IRFunction>,void>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  if (*a2)
  {
    v5 = (_QWORD *)operator new();
    v6 = *a2;
    *v5 = &unk_1EA993060;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  *a2 = 0;
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void MIL::Pass::Run(MIL::Pass *this, const MIL::IRBlock *a2)
{
  uint64_t v4;
  _QWORD **v5;
  _QWORD *v6;
  _QWORD *i;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  _QWORD *v20;
  _QWORD *v21;
  char *v22;
  __int128 v23;
  int64x2_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  int64x2_t v28;
  char *v29;
  int64x2_t *v30;
  int64x2_t v31;
  char *v32;
  char **v33;

  v28 = 0uLL;
  v29 = 0;
  v4 = (*(uint64_t (**)(const MIL::IRBlock *))(*(_QWORD *)a2 + 56))(a2);
  std::vector<std::shared_ptr<MIL::IROperation>>::reserve((char **)&v28, (uint64_t)(*(_QWORD *)(*(_QWORD *)v4 + 8) - **(_QWORD **)v4) >> 4);
  v5 = (_QWORD **)(*(uint64_t (**)(const MIL::IRBlock *))(*(_QWORD *)a2 + 56))(a2);
  v6 = (_QWORD *)**v5;
  for (i = (_QWORD *)(*v5)[1]; v6 != i; v6 += 2)
  {
    (*(void (**)(uint64_t *__return_ptr, MIL::Pass *, _QWORD))(*(_QWORD *)this + 32))(&v27, this, *v6);
    v8 = v27;
    if (v27)
    {
      v9 = (_QWORD *)operator new();
      v10 = v27;
      *v9 = &unk_1EA992FA8;
      v9[1] = 0;
      v9[2] = 0;
      v9[3] = v10;
    }
    else
    {
      v9 = 0;
    }
    v27 = 0;
    v11 = v28.i64[1];
    if (v28.i64[1] >= (unint64_t)v29)
    {
      v13 = (v28.i64[1] - v28.i64[0]) >> 4;
      v14 = v13 + 1;
      if ((unint64_t)(v13 + 1) >> 60)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v15 = (uint64_t)&v29[-v28.i64[0]];
      if ((uint64_t)&v29[-v28.i64[0]] >> 3 > v14)
        v14 = v15 >> 3;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0)
        v16 = 0xFFFFFFFFFFFFFFFLL;
      else
        v16 = v14;
      v33 = &v29;
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)&v29, v16);
      v19 = &v17[16 * v13];
      *(_QWORD *)v19 = v8;
      *((_QWORD *)v19 + 1) = v9;
      v20 = (_QWORD *)v28.i64[1];
      v21 = (_QWORD *)v28.i64[0];
      if (v28.i64[1] == v28.i64[0])
      {
        v24 = vdupq_n_s64(v28.u64[1]);
        v22 = &v17[16 * v13];
      }
      else
      {
        v22 = &v17[16 * v13];
        do
        {
          v23 = *((_OWORD *)v20 - 1);
          v20 -= 2;
          *((_OWORD *)v22 - 1) = v23;
          v22 -= 16;
          *v20 = 0;
          v20[1] = 0;
        }
        while (v20 != v21);
        v24 = v28;
      }
      v12 = v19 + 16;
      v28.i64[0] = (uint64_t)v22;
      v28.i64[1] = (uint64_t)(v19 + 16);
      v31 = v24;
      v25 = v29;
      v29 = &v17[16 * v18];
      v32 = v25;
      v30 = (int64x2_t *)v24.i64[0];
      std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v30);
    }
    else
    {
      *(_QWORD *)v28.i64[1] = v8;
      *(_QWORD *)(v11 + 8) = v9;
      v12 = (_QWORD *)(v11 + 16);
    }
    v28.i64[1] = (uint64_t)v12;
    v26 = v27;
    v27 = 0;
    if (v26)
      (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
  }
  (*(void (**)(const MIL::IRBlock *, int64x2_t *))(*(_QWORD *)a2 + 112))(a2, &v28);
  v30 = &v28;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v30);
}

void sub_1E0575128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, char a13)
{
  a10 = (void **)&a13;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::shared_ptr<MIL::IROperation>>::reserve(char **a1, unint64_t a2)
{
  uint64_t result;
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  __int128 v11;
  int64x2_t v12;
  char *v13;
  uint64_t v14;
  int64x2_t v15;
  char *v16;
  uint64_t v17;

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v17 = result;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>(result, a2);
    v9 = *a1;
    v8 = a1[1];
    if (v8 == *a1)
    {
      v12 = vdupq_n_s64((unint64_t)v8);
      v10 = &v6[v5];
    }
    else
    {
      v10 = &v6[v5];
      do
      {
        v11 = *((_OWORD *)v8 - 1);
        v8 -= 16;
        *((_OWORD *)v10 - 1) = v11;
        v10 -= 16;
        *(_QWORD *)v8 = 0;
        *((_QWORD *)v8 + 1) = 0;
      }
      while (v8 != v9);
      v12 = *(int64x2_t *)a1;
    }
    *a1 = v10;
    a1[1] = &v6[v5];
    v15 = v12;
    v13 = a1[2];
    a1[2] = &v6[16 * v7];
    v16 = v13;
    v14 = v12.i64[0];
    return std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v14);
  }
  return result;
}

uint64_t MIL::Pass::Run(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_1E05754C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;
  __int128 *v10;
  __int128 v11;

  v7 = a1 + 16;
  v8 = operator new(0x38uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
  }
  else
  {
    v11 = *v10;
    v8[4] = *((_QWORD *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  v8[5] = 0;
  v8[6] = 0;
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_1E0575560(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<MIL::IRFunction  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::IRFunction  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IRFunction  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

void PassManagerImpl::~PassManagerImpl(PassManagerImpl *this)
{
  void **v1;

  v1 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<MIL::Pass>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v1;

  v1 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<MIL::Pass>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  v2 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<MIL::Pass>>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x1E0C023A0](this, 0xA1C4030951706);
}

_QWORD *MIL::PassManager::PassManager(_QWORD *this)
{
  *this = off_1EA9930C0;
  return this;
}

uint64_t *MIL::PassManager::Make@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v3;
  uint64_t v5;

  v3 = (_QWORD *)operator new();
  *v3 = off_1EA9930F0;
  v3[1] = 0;
  v3[2] = 0;
  v3[3] = 0;
  v5 = 0;
  *a1 = v3;
  return std::unique_ptr<PassManagerImpl>::reset[abi:ne180100](&v5, 0);
}

uint64_t PassManagerImpl::RegisterPass(_QWORD *a1, uint64_t *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  int64x2_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  int64x2_t v23;
  char *v24;
  uint64_t v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;

  v6 = a1[3];
  result = (uint64_t)(a1 + 3);
  v5 = v6;
  v7 = *(_QWORD **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v10 = (int64x2_t *)(result - 16);
    v11 = *(_QWORD *)(result - 16);
    v12 = ((uint64_t)v7 - v11) >> 3;
    if ((unint64_t)(v12 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v13 = v5 - v11;
    v14 = v13 >> 2;
    if (v13 >> 2 <= (unint64_t)(v12 + 1))
      v14 = v12 + 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
      v15 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v15 = v14;
    v28 = result;
    if (v15)
      v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(result, v15);
    else
      v16 = 0;
    v17 = &v16[8 * v12];
    v18 = &v16[8 * v15];
    v27 = v18;
    v19 = *a2;
    *a2 = 0;
    *(_QWORD *)v17 = v19;
    v9 = v17 + 8;
    v26.i64[1] = (uint64_t)(v17 + 8);
    v21 = (_QWORD *)a1[1];
    v20 = (_QWORD *)a1[2];
    if (v20 == v21)
    {
      v23 = vdupq_n_s64((unint64_t)v20);
    }
    else
    {
      do
      {
        v22 = *--v20;
        *v20 = 0;
        *((_QWORD *)v17 - 1) = v22;
        v17 -= 8;
      }
      while (v20 != v21);
      v23 = *v10;
      v9 = (_QWORD *)v26.i64[1];
      v18 = v27;
    }
    a1[1] = v17;
    a1[2] = v9;
    v26 = v23;
    v24 = (char *)a1[3];
    a1[3] = v18;
    v27 = v24;
    v25 = v23.i64[0];
    result = std::__split_buffer<std::unique_ptr<MIL::Pass>>::~__split_buffer((uint64_t)&v25);
  }
  else
  {
    v8 = *a2;
    *a2 = 0;
    *v7 = v8;
    v9 = v7 + 1;
  }
  a1[2] = v9;
  return result;
}

_QWORD *PassManagerImpl::RunPasses@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *result;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;

  result = (*(_QWORD *(**)(_QWORD *__return_ptr, uint64_t))(*(_QWORD *)a2 + 32))(a3, a2);
  v7 = *(_QWORD **)(a1 + 8);
  v6 = *(_QWORD **)(a1 + 16);
  while (v7 != v6)
  {
    (*(void (**)(_QWORD **__return_ptr, _QWORD, _QWORD))(*(_QWORD *)*v7 + 16))(&v9, *v7, *a3);
    v8 = v9;
    v9 = 0;
    result = (_QWORD *)*a3;
    *a3 = v8;
    if (result)
    {
      (*(void (**)(_QWORD *))(*result + 8))(result);
      result = v9;
      v9 = 0;
      if (result)
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
    }
    ++v7;
  }
  return result;
}

void sub_1E05758F4(_Unwind_Exception *exception_object)
{
  uint64_t *v1;
  uint64_t v3;

  v3 = *v1;
  *v1 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<std::unique_ptr<MIL::Pass>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<std::unique_ptr<MIL::Pass>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *std::unique_ptr<PassManagerImpl>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  void **v3;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = (void **)(v2 + 8);
    std::vector<std::unique_ptr<MIL::Pass>>::__destroy_vector::operator()[abi:ne180100](&v3);
    return (uint64_t *)MEMORY[0x1E0C023A0](v2, 0xA1C4030951706);
  }
  return result;
}

std::runtime_error *MIL::MILError::MILError(std::runtime_error *a1, const std::string *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)off_1EA993148;
  return result;
}

_QWORD *MIL::MILError::GetMessage@<X0>(MIL::MILError *this@<X0>, _QWORD *a2@<X8>)
{
  char *v3;

  v3 = (char *)(*(uint64_t (**)(MIL::MILError *))(*(_QWORD *)this + 16))(this);
  return std::string::basic_string[abi:ne180100]<0>(a2, v3);
}

__n128 MIL::MILErrorWithLocation::MILErrorWithLocation(std::runtime_error *a1, __n128 *a2, std::string *a3)
{
  std::runtime_error *v4;
  __n128 result;

  v4 = std::runtime_error::runtime_error(a1, a3);
  v4->__vftable = (std::runtime_error_vtbl *)&off_1EA993190;
  result = *a2;
  v4[1] = *(std::runtime_error *)a2;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  return result;
}

{
  std::runtime_error *v4;
  __n128 result;

  v4 = std::runtime_error::runtime_error(a1, a3);
  v4->__vftable = (std::runtime_error_vtbl *)&off_1EA993190;
  result = *a2;
  v4[1] = *(std::runtime_error *)a2;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  return result;
}

void MIL::MILErrorWithLocation::GetMessageWithLocation(MIL::MILErrorWithLocation *this@<X0>, std::string *a2@<X8>)
{
  std::string *v4;
  __int128 v5;
  void **v6;
  std::string::size_type v7;
  std::string *v8;
  void *__p[2];
  unsigned __int8 v10;
  std::string v11;
  std::string v12;

  (*(void (**)(std::string *__return_ptr))(**((_QWORD **)this + 2) + 24))(&v11);
  v4 = std::string::append(&v11, ": ");
  v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v12.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v12.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(void **__return_ptr, MIL::MILErrorWithLocation *))(*(_QWORD *)this + 24))(__p, this);
  if ((v10 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v10 & 0x80u) == 0)
    v7 = v10;
  else
    v7 = (std::string::size_type)__p[1];
  v8 = std::string::append(&v12, (const std::string::value_type *)v6, v7);
  *a2 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if ((char)v10 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v12.__r_.__value_.__l.__data_);
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v11.__r_.__value_.__l.__data_);
}

void sub_1E0575BFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::MILErrorWithLocation::GetLocation(MIL::MILErrorWithLocation *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t MIL::MILErrorWithLocation::GetLocationSharedPtr(MIL::MILErrorWithLocation *this)
{
  return (uint64_t)this + 16;
}

std::runtime_error *MIL::OutOfRangeError::OutOfRangeError(std::runtime_error *a1, std::runtime_error_vtbl **a2, std::string *a3)
{
  std::runtime_error_vtbl *v3;
  const char *v4;
  std::runtime_error *result;

  v3 = *a2;
  v4 = (const char *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  result = std::runtime_error::runtime_error(a1, a3);
  result[1].__vftable = v3;
  result[1].__imp_.__imp_ = v4;
  result->__vftable = (std::runtime_error_vtbl *)&off_1EA9931D8;
  return result;
}

void sub_1E0575C9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *MIL::OutOfRangeError::GetMessage@<X0>(MIL::OutOfRangeError *this@<X0>, _QWORD *a2@<X8>)
{
  char *v3;

  v3 = (char *)(*(uint64_t (**)(MIL::OutOfRangeError *))(*(_QWORD *)this + 16))(this);
  return std::string::basic_string[abi:ne180100]<0>(a2, v3);
}

std::runtime_error *MIL::InvalidArgumentError::InvalidArgumentError(std::runtime_error *a1, std::runtime_error_vtbl **a2, std::string *a3)
{
  std::runtime_error_vtbl *v3;
  const char *v4;
  std::runtime_error *result;

  v3 = *a2;
  v4 = (const char *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  result = std::runtime_error::runtime_error(a1, a3);
  result[1].__vftable = v3;
  result[1].__imp_.__imp_ = v4;
  result->__vftable = (std::runtime_error_vtbl *)&off_1EA993220;
  return result;
}

void sub_1E0575D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *MIL::InvalidArgumentError::GetMessage@<X0>(MIL::InvalidArgumentError *this@<X0>, _QWORD *a2@<X8>)
{
  char *v3;

  v3 = (char *)(*(uint64_t (**)(MIL::InvalidArgumentError *))(*(_QWORD *)this + 16))(this);
  return std::string::basic_string[abi:ne180100]<0>(a2, v3);
}

std::runtime_error *MIL::InvalidOperationError::InvalidOperationError(std::runtime_error *a1, std::runtime_error_vtbl **a2, std::string *a3)
{
  std::runtime_error_vtbl *v3;
  const char *v4;
  std::runtime_error *result;

  v3 = *a2;
  v4 = (const char *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  result = std::runtime_error::runtime_error(a1, a3);
  result[1].__vftable = v3;
  result[1].__imp_.__imp_ = v4;
  result->__vftable = (std::runtime_error_vtbl *)&off_1EA993268;
  return result;
}

void sub_1E0575DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *MIL::InvalidOperationError::GetMessage@<X0>(MIL::InvalidOperationError *this@<X0>, _QWORD *a2@<X8>)
{
  char *v3;

  v3 = (char *)(*(uint64_t (**)(MIL::InvalidOperationError *))(*(_QWORD *)this + 16))(this);
  return std::string::basic_string[abi:ne180100]<0>(a2, v3);
}

std::runtime_error *MIL::MILErrorWithResult::MILErrorWithResult(std::runtime_error *a1, const std::string *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)off_1EA9932B0;
  return result;
}

uint64_t MIL::MILErrorWithResult::GetMessageWithLocation(MIL::MILErrorWithResult *this)
{
  uint64_t v1;

  v1 = (*(uint64_t (**)(MIL::MILErrorWithResult *))(*(_QWORD *)this + 56))(this);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
}

uint64_t MIL::MILErrorWithResult::GetLocation(MIL::MILErrorWithResult *this)
{
  MIL::MILResult *v1;

  v1 = (MIL::MILResult *)(*(uint64_t (**)(MIL::MILErrorWithResult *))(*(_QWORD *)this + 56))(this);
  return MIL::MILResult::GetLocation(v1);
}

_QWORD *MIL::MILErrorWithResult::GetLocationSharedPtr(MIL::MILErrorWithResult *this)
{
  MIL::MILResult *v1;

  v1 = (MIL::MILResult *)(*(uint64_t (**)(MIL::MILErrorWithResult *))(*(_QWORD *)this + 56))(this);
  return MIL::MILResult::GetLocationSharedPtr(v1);
}

void MIL::MILErrorWithLocation::~MILErrorWithLocation(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1EA993190;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&this[1]);
  std::runtime_error::~runtime_error(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1EA993190;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&this[1]);
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1E0C023A0);
}

void MIL::OutOfRangeError::~OutOfRangeError(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1EA993190;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&this[1]);
  std::runtime_error::~runtime_error(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1EA993190;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&this[1]);
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1E0C023A0);
}

void MIL::InvalidArgumentError::~InvalidArgumentError(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1EA993190;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&this[1]);
  std::runtime_error::~runtime_error(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1EA993190;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&this[1]);
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1E0C023A0);
}

void MIL::InvalidOperationError::~InvalidOperationError(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1EA993190;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&this[1]);
  std::runtime_error::~runtime_error(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1EA993190;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&this[1]);
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::Bf16::FromFloat(MIL::Bf16 *this, float a2)
{
  unsigned int v2;

  v2 = (LODWORD(a2) + 0x8000) >> 16;
  if ((LODWORD(a2) & 0x1FFFF) == 0x8000)
    return HIWORD(LODWORD(a2));
  return v2;
}

_WORD *MIL::Bf16::SetFloat(_WORD *this, float a2)
{
  unsigned int v2;

  v2 = (LODWORD(a2) + 0x8000) >> 16;
  if ((LODWORD(a2) & 0x1FFFF) == 0x8000)
    v2 = HIWORD(LODWORD(a2));
  *this = v2;
  return this;
}

float MIL::Bf16::GetFloat(MIL::Bf16 *this)
{
  float result;

  LODWORD(result) = *(unsigned __int16 *)this << 16;
  return result;
}

float MIL::Fp8E5M2::GetFloat(MIL::Fp8E5M2 *this)
{
  unsigned int v1;
  unsigned int v2;
  int v3;
  float result;
  float v5;
  int v6;
  BOOL v7;

  v1 = *(unsigned __int8 *)this;
  v2 = (v1 << 24) & 0x80000000;
  v3 = v1 & 0x7C;
  if (v3 == 124)
  {
    LODWORD(result) = v2 | v1 & 3 | 0x7F800000;
  }
  else
  {
    LODWORD(v5) = ((((v1 & 3) << 21) & 0xF07FFFFF | (((v1 >> 2) & 0x1F) << 23)) + 939524096) | v2;
    if ((v1 & 0x7F) == 0)
      LODWORD(v5) = (v1 << 24) & 0x80000000;
    result = v5;
    v6 = v1 & 3;
    if (v3)
      v7 = 1;
    else
      v7 = v6 == 0;
    if (!v7)
      return COERCE_FLOAT((LODWORD(v5) + 0x800000) & 0x7F800000 | LODWORD(v5) & 0x807FFFFF)
           - COERCE_FLOAT((LODWORD(v5) + 0x800000) & 0x7F800000 | v2);
  }
  return result;
}

float MIL::Fp8E4M3FN::GetFloat(MIL::Fp8E4M3FN *this)
{
  unsigned int v1;
  unsigned int v2;
  int v3;
  float result;
  float v5;

  v1 = *(unsigned __int8 *)this;
  v2 = (v1 << 24) & 0x80000000;
  v3 = v1 & 7;
  if ((v1 & 0x7F) != 0)
  {
    if ((v1 & 0x7F) == 0x7F)
    {
      LODWORD(result) = v2 | v3 | 0x7F800000;
      return result;
    }
    LODWORD(v5) = ((((v1 & 7) << 20) & 0xF87FFFFF | (((v1 >> 3) & 0xF) << 23)) + 1006632960) | v2;
  }
  else
  {
    LODWORD(v5) = (v1 << 24) & 0x80000000;
  }
  if ((v1 & 0x78) != 0 || v3 == 0)
    return v5;
  else
    return COERCE_FLOAT((LODWORD(v5) + 0x800000) & 0x7F800000 | LODWORD(v5) & 0x807FFFFF)
         - COERCE_FLOAT((LODWORD(v5) + 0x800000) & 0x7F800000 | v2);
}

_BYTE *MIL::Fp8E5M2::SetFloat(_BYTE *this, float a2)
{
  unsigned int v2;
  std::runtime_error *exception;
  float v4;

  v4 = a2;
  *this = HIBYTE(a2) & 0x80;
  if (fabsf(a2) == INFINITY)
  {
    *this = HIBYTE(a2) & 0x80 | 0x7C;
    return this;
  }
  if (a2 != 0.0)
  {
    v2 = (LODWORD(a2) >> 23);
    if (v2 >= 0x8F)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::range_error::range_error[abi:ne180100](exception, "Fp8E5M2 SetFloat exponent overflow.");
    }
    else
    {
      if (v2 > 0x6E)
        return HandleFp32ToFp8ExponentMantissa<MIL::Fp8E5M2,MIL::Fp8E5M2::Cast>(this, &v4);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::range_error::range_error[abi:ne180100](exception, "Fp8E5M2 SetFloat exponent underflow.");
    }
    __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
  }
  return this;
}

void sub_1E05762BC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::runtime_error *std::range_error::range_error[abi:ne180100](std::runtime_error *a1, const char *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E0DE5008] + 16);
  return result;
}

_BYTE *HandleFp32ToFp8ExponentMantissa<MIL::Fp8E5M2,MIL::Fp8E5M2::Cast>(_BYTE *result, float *a2)
{
  float v2;
  unsigned int v3;
  std::runtime_error *exception;

  v2 = *a2;
  if ((*(_DWORD *)a2 & 0x7F800000u) < 0x38000001)
  {
    *a2 = v2 + COERCE_FLOAT(LODWORD(v2) & 0x80000000 | 0x38800000);
    LOBYTE(v3) = *result & 0x83;
  }
  else
  {
    v3 = *result & 0x83 | (4 * ((((LODWORD(v2) >> 21) + 64) >> 2) & 0x1F));
  }
  *result = v3;
  if ((*(_DWORD *)a2 & 0x1FFFFF) != 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "FP8 SetFloat requires rounding for the given value.");
    __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
  }
  *result = v3 & 0xFC | (*(_DWORD *)a2 >> 21) & 3;
  return result;
}

void sub_1E05763A8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_BYTE *MIL::Fp8E4M3FN::SetFloat(_BYTE *this, float a2)
{
  unsigned int v2;
  std::runtime_error *exception;
  float v4;

  v4 = a2;
  *this = HIBYTE(a2) & 0x80;
  if (fabsf(a2) == INFINITY)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "Fp8E4M3FN SetFloat infinity not supported.");
    goto LABEL_10;
  }
  if (a2 == 0.0)
    return this;
  v2 = (LODWORD(a2) >> 23);
  if (v2 >= 0x88)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "Fp8E4M3FN SetFloat exponent overflow.");
    goto LABEL_10;
  }
  if (v2 <= 0x75)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "Fp8E4M3FN SetFloat exponent underflow.");
LABEL_10:
    __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
  }
  return HandleFp32ToFp8ExponentMantissa<MIL::Fp8E4M3FN,MIL::Fp8E4M3FN::Cast>(this, &v4);
}

void sub_1E05764A4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_BYTE *HandleFp32ToFp8ExponentMantissa<MIL::Fp8E4M3FN,MIL::Fp8E4M3FN::Cast>(_BYTE *result, float *a2)
{
  float v2;
  unsigned int v3;
  std::runtime_error *exception;

  v2 = *a2;
  if ((*(_DWORD *)a2 & 0x7F800000u) < 0x3C000001)
  {
    *a2 = v2 + COERCE_FLOAT(LODWORD(v2) & 0x80000000 | 0x3C800000);
    LOBYTE(v3) = *result & 0x87;
  }
  else
  {
    v3 = *result & 0x87 | (8 * ((((LODWORD(v2) >> 20) + 64) >> 3) & 0xF));
  }
  *result = v3;
  if ((*(_DWORD *)a2 & 0xFFFFF) != 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "FP8 SetFloat requires rounding for the given value.");
    __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
  }
  *result = v3 & 0xF8 | (*(_DWORD *)a2 >> 20) & 7;
  return result;
}

void sub_1E0576570(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::Fp8E5M2::FromFloat(MIL::Fp8E5M2 *this, float a2)
{
  unsigned __int8 v3;

  v3 = 0;
  MIL::Fp8E5M2::SetFloat(&v3, a2);
  return v3;
}

uint64_t MIL::Fp8E4M3FN::FromFloat(MIL::Fp8E4M3FN *this, float a2)
{
  unsigned __int8 v3;

  v3 = 0;
  MIL::Fp8E4M3FN::SetFloat(&v3, a2);
  return v3;
}

BOOL MIL::Fp8E5M2::IsNaN(MIL::Fp8E5M2 *this)
{
  int v1;

  v1 = *(unsigned __int8 *)this;
  return (v1 & 3) != 0 && (~v1 & 0x7C) == 0;
}

BOOL MIL::Fp8E4M3FN::IsNaN(MIL::Fp8E4M3FN *this)
{
  return (~*(unsigned __int8 *)this & 0x7F) == 0;
}

uint64_t MIL::Fp16::FromFloat(MIL::Fp16 *this, float a2)
{
  return (2 * LODWORD(a2)) | (((unint64_t)LODWORD(a2) >> 31) << 15);
}

float MIL::Fp16::GetFloat(MIL::Fp16 *this)
{
  unsigned int v1;
  float v2;
  float result;

  v1 = *(__int16 *)this;
  v2 = COERCE_FLOAT(((v1 & 0x7FFF) << 13) | 0x70000000) * 1.9259e-34;
  if (((v1 >> 10) & 0x1F) == 0)
    v2 = COERCE_FLOAT(v1 & 0x7FFF | 0x3F000000) + -0.5;
  LODWORD(result) = v1 & 0x80000000 | LODWORD(v2);
  return result;
}

_WORD *MIL::Fp16::SetFloat(_WORD *this, float a2)
{
  *this = (2 * LOWORD(a2)) | ((unint64_t)LODWORD(a2) >> 31 << 15);
  return this;
}

_QWORD *MIL::IRArgument::IRArgument(_QWORD *this)
{
  *this = off_1EA993390;
  return this;
}

uint64_t *MIL::IRArgument::Make@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v6;

  v4 = operator new();
  *(_QWORD *)v4 = &off_1EA993420;
  *(_OWORD *)(v4 + 8) = *(_OWORD *)a1;
  *(_QWORD *)(v4 + 24) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(v4 + 32) = 0;
  v6 = 0;
  *a2 = v4;
}

uint64_t *std::unique_ptr<`anonymous namespace'::IRArgumentImpl>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::__variant_detail::__dtor<std::__variant_detail::__traits<std::string,std::shared_ptr<MIL::IRValue const>>,(std::__variant_detail::_Trait)1>::~__dtor(v2 + 8);
    MEMORY[0x1E0C023A0](v2, 0x10F3C4066A09554);
  }
  return a1;
}

uint64_t *MIL::IRArgument::Make@<X0>(__int128 *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v7;

  v4 = operator new();
  v5 = *a1;
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *(_QWORD *)v4 = &off_1EA993420;
  *(_OWORD *)(v4 + 8) = v5;
  *(_DWORD *)(v4 + 32) = 1;
  v7 = 0;
  *a2 = v4;
}

uint64_t MIL::IRArgument::GetName(MIL::IRArgument *this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = (*(uint64_t (**)(MIL::IRArgument *))(*(_QWORD *)this + 32))(this);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Argument is not a name");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05768E8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRArgument::GetValue(MIL::IRArgument *this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = (*(uint64_t (**)(MIL::IRArgument *))(*(_QWORD *)this + 40))(this);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Argument is not a value");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E0576954(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const MIL::Text::SerializerOptions *MIL::IRArgument::ToString(MIL::IRArgument *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Argument((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05769F4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

void MIL::IRTypedArgument::~IRTypedArgument(MIL::IRTypedArgument *this)
{
  *(_QWORD *)this = &off_1EA9933E0;
  std::unique_ptr<MIL::IRTypedArgument::IRTypedArgumentImpl>::reset[abi:ne180100]((uint64_t *)this + 1, 0);
}

{
  *(_QWORD *)this = &off_1EA9933E0;
  std::unique_ptr<MIL::IRTypedArgument::IRTypedArgumentImpl>::reset[abi:ne180100]((uint64_t *)this + 1, 0);
}

{
  *(_QWORD *)this = &off_1EA9933E0;
  std::unique_ptr<MIL::IRTypedArgument::IRTypedArgumentImpl>::reset[abi:ne180100]((uint64_t *)this + 1, 0);
  JUMPOUT(0x1E0C023A0);
}

MIL::IRTypedArgument *MIL::IRTypedArgument::IRTypedArgument(MIL::IRTypedArgument *this, const MIL::IRValueType *a2)
{
  uint64_t v4;

  *(_QWORD *)this = &off_1EA9933E0;
  v4 = operator new();
  *(_QWORD *)v4 = a2;
  *(_DWORD *)(v4 + 16) = 0;
  *((_QWORD *)this + 1) = v4;
  return this;
}

{
  uint64_t v4;

  *(_QWORD *)this = &off_1EA9933E0;
  v4 = operator new();
  *(_QWORD *)v4 = a2;
  *(_DWORD *)(v4 + 16) = 0;
  *((_QWORD *)this + 1) = v4;
  return this;
}

_QWORD *MIL::IRTypedArgument::IRTypedArgument(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  *a1 = &off_1EA9933E0;
  v4 = operator new();
  v6 = *a2;
  v5 = a2[1];
  if (v5)
  {
    v7 = (unint64_t *)(v5 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  *(_QWORD *)v4 = v6;
  *(_QWORD *)(v4 + 8) = v5;
  *(_DWORD *)(v4 + 16) = 1;
  a1[1] = v4;
  return a1;
}

BOOL MIL::IRTypedArgument::IsValueType(MIL::IRTypedArgument *this)
{
  return *(_DWORD *)(*((_QWORD *)this + 1) + 16) == 0;
}

BOOL MIL::IRTypedArgument::IsValue(MIL::IRTypedArgument *this)
{
  return *(_DWORD *)(*((_QWORD *)this + 1) + 16) == 1;
}

uint64_t MIL::IRTypedArgument::TryGetValue(MIL::IRTypedArgument::IRTypedArgumentImpl **this)
{
  return MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValue(this[1]);
}

uint64_t MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValue(MIL::IRTypedArgument::IRTypedArgumentImpl *this)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t v5;

  if (!this || *((_DWORD *)this + 4) != 1)
    return 0;
  v1 = *(_QWORD *)this;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return v1;
}

uint64_t MIL::IRTypedArgument::TryGetValueType(MIL::IRTypedArgument::IRTypedArgumentImpl **this)
{
  return MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValueType(this[1]);
}

uint64_t MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValueType(MIL::IRTypedArgument::IRTypedArgumentImpl *this)
{
  uint64_t Value;

  if (this && !*((_DWORD *)this + 4))
    return *(_QWORD *)this;
  Value = MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValue(this);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)Value + 32))(Value);
}

uint64_t MIL::IRTypedArgument::TryGetValueSharedPtr@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v2 = *(uint64_t **)(this + 8);
  if (v2 && *((_DWORD *)v2 + 4) == 1)
  {
    v4 = *v2;
    v3 = v2[1];
    *a2 = v4;
    a2[1] = v3;
    if (v3)
    {
      v5 = (unint64_t *)(v3 + 8);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return this;
}

uint64_t MIL::IRTypedArgument::Equals(MIL::IRTypedArgument::IRTypedArgumentImpl **this, const MIL::IRTypedArgument::IRTypedArgumentImpl **a2)
{
  return MIL::IRTypedArgument::IRTypedArgumentImpl::Equals(this[1], a2[1]);
}

uint64_t MIL::IRTypedArgument::IRTypedArgumentImpl::Equals(MIL::IRTypedArgument::IRTypedArgumentImpl *this, const MIL::IRTypedArgument::IRTypedArgumentImpl *a2)
{
  int v3;
  uint64_t Value;
  uint64_t v5;
  uint64_t ValueType;
  uint64_t v8;
  uint64_t v9;

  v3 = *((_DWORD *)a2 + 4);
  if (*((_DWORD *)this + 4))
  {
    if (v3 == 1)
    {
      Value = MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValue(this);
      v5 = MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValue(a2);
      return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)Value + 16))(Value, v5);
    }
    return 0;
  }
  if (v3)
    return 0;
  ValueType = MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValueType(this);
  if (*((_DWORD *)a2 + 4))
  {
    v8 = MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValue(a2);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
  }
  else
  {
    v9 = *(_QWORD *)a2;
  }
  return ValueType == v9;
}

uint64_t MIL::IRTypedArgument::Make@<X0>(MIL::IRTypedArgument *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v5;
  uint64_t result;

  v5 = (_QWORD *)operator new();
  *v5 = &off_1EA9933E0;
  result = operator new();
  *(_QWORD *)result = this;
  *(_DWORD *)(result + 16) = 0;
  v5[1] = result;
  *a2 = v5;
  return result;
}

void sub_1E0576E40(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void MIL::IRTypedArgument::Make(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;

  v4 = (_QWORD *)operator new();
  v5 = v4;
  v7 = *a1;
  v6 = (std::__shared_weak_count *)a1[1];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  *v4 = &off_1EA9933E0;
  v10 = operator new();
  if (v6)
  {
    v11 = (unint64_t *)&v6->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    *(_QWORD *)v10 = v7;
    *(_QWORD *)(v10 + 8) = v6;
    *(_DWORD *)(v10 + 16) = 1;
    v5[1] = v10;
    *a2 = v5;
    do
      v13 = __ldaxr(v11);
    while (__stlxr(v13 - 1, v11));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    *(_QWORD *)v10 = v7;
    *(_QWORD *)(v10 + 8) = 0;
    *(_DWORD *)(v10 + 16) = 1;
    v5[1] = v10;
    *a2 = v5;
  }
}

void sub_1E0576F60(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  uint64_t v2;

  if (v1)
    MIL::IRTypedArgument::Make(v1);
  MEMORY[0x1E0C023A0](v2, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedArgument::GetValueType(MIL::IRTypedArgument::IRTypedArgumentImpl **this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValueType(this[1]);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Argument is not a value type pointer");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E0576FE4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedArgument::GetValue(MIL::IRTypedArgument::IRTypedArgumentImpl **this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValue(this[1]);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Argument is not a value");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E057704C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const MIL::Text::SerializerOptions *MIL::IRTypedArgument::ToString(MIL::IRTypedArgument::IRTypedArgumentImpl **this)
{
  return MIL::IRTypedArgument::IRTypedArgumentImpl::ToString(this[1]);
}

const MIL::Text::SerializerOptions *MIL::IRTypedArgument::IRTypedArgumentImpl::ToString(MIL::IRTypedArgument::IRTypedArgumentImpl *this)
{
  uint64_t Value;
  const MIL::IRValue *v3;
  double v4;
  MIL::Text::BasicSerializer *v5;
  const MIL::Text::SerializerOptions *result;
  uint64_t ValueType;
  _BYTE v8[392];
  const MIL::Text::SerializerOptions *v9;

  Value = MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValue(this);
  if (Value)
  {
    v3 = (const MIL::IRValue *)Value;
    v4 = MIL::Text::SerializerOptions::Make((uint64_t *)&v9);
    (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v9 + 112))(v9, 4, v4);
    MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v8, v9);
    v5 = MIL::Text::BasicSerializer::Value((MIL::Text::BasicSerializer *)v8, v3);
    MIL::Text::BasicSerializer::GetOutput(v5);
    MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v8);
    result = v9;
    v9 = 0;
    if (result)
      return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    ValueType = MIL::IRTypedArgument::IRTypedArgumentImpl::TryGetValueType(this);
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)ValueType + 56))(ValueType);
  }
  return result;
}

void sub_1E0577128(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::IRArgumentImpl::~IRArgumentImpl(_anonymous_namespace_::IRArgumentImpl *this)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::string,std::shared_ptr<MIL::IRValue const>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)this + 8);
}

{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::string,std::shared_ptr<MIL::IRValue const>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)this + 8);
  JUMPOUT(0x1E0C023A0);
}

BOOL `anonymous namespace'::IRArgumentImpl::IsName(_anonymous_namespace_::IRArgumentImpl *this)
{
  return *((_DWORD *)this + 8) == 0;
}

BOOL `anonymous namespace'::IRArgumentImpl::IsValue(_anonymous_namespace_::IRArgumentImpl *this)
{
  return *((_DWORD *)this + 8) == 1;
}

uint64_t `anonymous namespace'::IRArgumentImpl::TryGetName(_anonymous_namespace_::IRArgumentImpl *this)
{
  uint64_t Value;
  uint64_t result;

  if (!*((_DWORD *)this + 8))
    return (uint64_t)this + 8;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)Value + 40))(Value);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 136))(result);
  return result;
}

uint64_t `anonymous namespace'::IRArgumentImpl::TryGetValue(_anonymous_namespace_::IRArgumentImpl *this)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t v5;

  if (*((_DWORD *)this + 8) != 1)
    return 0;
  v1 = *((_QWORD *)this + 1);
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return v1;
}

uint64_t `anonymous namespace'::IRArgumentImpl::TryGetValueSharedPtr@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  if (*(_DWORD *)(this + 32) == 1)
  {
    v2 = *(_QWORD *)(this + 16);
    *a2 = *(_QWORD *)(this + 8);
    a2[1] = v2;
    if (v2)
    {
      v3 = (unint64_t *)(v2 + 8);
      do
        v4 = __ldxr(v3);
      while (__stxr(v4 + 1, v3));
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return this;
}

uint64_t `anonymous namespace'::IRArgumentImpl::Equals(_anonymous_namespace_::IRArgumentImpl *this, const MIL::IRArgument *a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t Value;
  uint64_t v7;
  unsigned __int8 *Name;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned __int8 *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  BOOL v21;

  v4 = *(_QWORD *)a2;
  if (*((_DWORD *)this + 8))
  {
    result = (*(uint64_t (**)(const MIL::IRArgument *))(v4 + 24))(a2);
    if ((_DWORD)result)
    {
      v7 = (*(uint64_t (**)(const MIL::IRArgument *))(*(_QWORD *)a2 + 40))(a2);
      return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)Value + 16))(Value, v7);
    }
  }
  else
  {
    result = (*(uint64_t (**)(const MIL::IRArgument *))(v4 + 16))(a2);
    if ((_DWORD)result)
    {
      v9 = (*(uint64_t (**)(const MIL::IRArgument *))(*(_QWORD *)a2 + 32))(a2);
      v10 = Name[23];
      if ((v10 & 0x80u) == 0)
        v11 = Name[23];
      else
        v11 = *((_QWORD *)Name + 1);
      v12 = *(unsigned __int8 *)(v9 + 23);
      v13 = (char)v12;
      if ((v12 & 0x80u) != 0)
        v12 = *(_QWORD *)(v9 + 8);
      if (v11 == v12)
      {
        if (v13 >= 0)
          v14 = (unsigned __int8 *)v9;
        else
          v14 = *(unsigned __int8 **)v9;
        if ((v10 & 0x80) != 0)
        {
          return memcmp(*(const void **)Name, v14, *((_QWORD *)Name + 1)) == 0;
        }
        else if (Name[23])
        {
          v15 = v10 - 1;
          do
          {
            v17 = *Name++;
            v16 = v17;
            v19 = *v14++;
            v18 = v19;
            v21 = v15-- != 0;
            result = v16 == v18;
          }
          while (v16 == v18 && v21);
        }
        else
        {
          return 1;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<std::string,std::shared_ptr<MIL::IRValue const>>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_1EA993478[v2])(&v4, a1);
  *(_DWORD *)(a1 + 24) = -1;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_10shared_ptrIKN3MIL7IRValueEEEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSK_1EJSD_SI_EEEEEEDcSM_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_10shared_ptrIKN3MIL7IRValueEEEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSK_1EJSD_SI_EEEEEEDcSM_DpT0_(uint64_t a1, uint64_t a2)
{
  return std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a2);
}

uint64_t std::unique_ptr<MIL::IRTypedArgument::IRTypedArgumentImpl>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    std::__variant_detail::__dtor<std::__variant_detail::__traits<MIL::IRValueType const*,std::shared_ptr<MIL::IRValue const>>,(std::__variant_detail::_Trait)1>::~__dtor(result);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<MIL::IRValueType const*,std::shared_ptr<MIL::IRValue const>>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_1EA993488[v2])(&v4, a1);
  *(_DWORD *)(a1 + 16) = -1;
  return a1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJPKN3MIL11IRValueTypeENS_10shared_ptrIKNS8_7IRValueEEEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSH_1EJSB_SF_EEEEEEDcSJ_DpT0_(uint64_t a1, uint64_t a2)
{
  return std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a2);
}

void MIL::IRBlock::~IRBlock(MIL::IRBlock *this)
{
  MIL::IRCachedScope::~IRCachedScope((MIL::IRBlock *)((char *)this + 64));
  MIL::IRObject::~IRObject(this);
}

_QWORD *MIL::IRBlock::IRBlock(_QWORD *a1, __int128 *a2, uint64_t *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v8;

  v8 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  MIL::IRObject::IRObject(a1, (uint64_t)&v8, a3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  MIL::IRCachedScope::IRCachedScope((MIL::IRCachedScope *)(a1 + 8));
  *a1 = off_1EA9934A8;
  a1[8] = &unk_1EA993538;
  return a1;
}

void sub_1E05775D8(_Unwind_Exception *a1)
{
  MIL::IRObject *v1;

  MIL::IRObject::~IRObject(v1);
  _Unwind_Resume(a1);
}

void MIL::IRBlock::Make(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _anonymous_namespace_::IRBlockImpl **a5@<X8>)
{
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  _OWORD v8[2];
  int v9;
  __int128 v10;

  v10 = *(_OWORD *)a1;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 1065353216;
  MIL::IRBlock::Make(&v10, a2, a3, a4, (uint64_t *)v8, a5);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v8);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
  if (*((_QWORD *)&v10 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v10 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1E0577684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v9 - 32);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::IRBlockImpl **MIL::IRBlock::Make@<X0>(__int128 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, _anonymous_namespace_::IRBlockImpl **a6@<X8>)
{
  _anonymous_namespace_::IRBlockImpl *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _anonymous_namespace_::IRBlockImpl *v16;
  _anonymous_namespace_::IRBlockImpl *v18;
  __int128 v19;

  v12 = (_anonymous_namespace_::IRBlockImpl *)operator new();
  v19 = *a1;
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  v18 = v12;
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
  if (*((_QWORD *)&v19 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v18;
  v18 = 0;
  *a6 = v16;
}

void sub_1E0577780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  uint64_t v12;

  if (a12)
    MIL::IRTypedArgument::Make(a12);
  MEMORY[0x1E0C023A0](v12, 0x10E1C407CF303FALL);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::IRBlockImpl **std::unique_ptr<`anonymous namespace'::IRBlockImpl>::~unique_ptr[abi:ne180100](_anonymous_namespace_::IRBlockImpl **a1)
{
  _anonymous_namespace_::IRBlockImpl *v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    MEMORY[0x1E0C023A0]();
  }
  return a1;
}

const MIL::Text::SerializerOptions *MIL::IRBlock::ToString(MIL::IRBlock *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  const MIL::Text::SerializerOptions *result;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  _BYTE v10[392];
  const MIL::Text::SerializerOptions *v11;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v11);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v11 + 112))(v11, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v10, v11);
  v8 = 0;
  v9 = 0;
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Block((uint64_t)v10, this, &v8);
  MIL::Text::BasicSerializer::GetOutput(v3);
  v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v10);
  result = v11;
  v11 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05778C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;
  uint64_t v13;

  v13 = *(_QWORD *)(v11 - 40);
  *(_QWORD *)(v11 - 40) = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::IRBlockImpl::~IRBlockImpl(_anonymous_namespace_::IRBlockImpl *this)
{
  uint64_t v2;
  void **v3;

  v2 = *((_QWORD *)this + 30);
  *((_QWORD *)this + 30) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0x20C4093837F09);
  v3 = (void **)((char *)this + 216);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 192);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 168);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v3);
  MIL::IRCachedScope::~IRCachedScope((_anonymous_namespace_::IRBlockImpl *)((char *)this + 64));
  MIL::IRObject::~IRObject(this);
}

{
  JUMPOUT(0x1E0C023A0);
}

void `non-virtual thunk to'`anonymous namespace'::IRBlockImpl::~IRBlockImpl(_anonymous_namespace_::IRBlockImpl *this)
{
}

{
  JUMPOUT(0x1E0C023A0);
}

void std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

uint64_t `anonymous namespace'::IRBlockImpl::IRBlockImpl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  __int128 v14;

  v14 = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  MIL::IRBlock::IRBlock((_QWORD *)a1, &v14, a6);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
  if (*((_QWORD *)&v14 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  *(_QWORD *)a1 = &off_1EA9935D8;
  *(_QWORD *)(a1 + 64) = &unk_1EA993670;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 168) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 192) = *(_OWORD *)a4;
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a4 + 16);
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  return a1;
}

void sub_1E0577B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  MIL::IRObject *v4;
  MIL::IRCachedScope *v5;
  uint64_t v7;
  va_list va;

  va_start(va, a4);
  v7 = *((_QWORD *)v4 + 30);
  *((_QWORD *)v4 + 30) = 0;
  if (v7)
    MEMORY[0x1E0C023A0](v7, 0x20C4093837F09);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  MIL::IRCachedScope::~IRCachedScope(v5);
  MIL::IRObject::~IRObject(v4);
  _Unwind_Resume(a1);
}

_QWORD *`anonymous namespace'::IRBlockImpl::SetOperations(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = &off_1EA9936F0;
  v4[1] = a1;
  v4[2] = a2;
  v5 = v4;
  MIL::IRCachedScope::InvalidateAndCall(a1 + 64, (uint64_t)v4);
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1E0577C60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::IRBlockImpl::EqualsImpl(_anonymous_namespace_::IRBlockImpl *this, const MIL::IRObject *a2)
{
  const MIL::IRObject *v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 **v16;
  uint64_t v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  int v20;
  unsigned __int8 *v21;
  uint64_t **v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t result;

  if (*(void (***)(_anonymous_namespace_::IRBlockImpl *__hidden))a2 == &off_1EA9935D8)
    v2 = a2;
  else
    v2 = 0;
  if (*(void (***)(_anonymous_namespace_::IRBlockImpl *__hidden))a2 != &off_1EA9935D8)
    return 0;
  v5 = *((_QWORD *)this + 21);
  v6 = *((_QWORD *)this + 22);
  if (v6 - v5 != *((_QWORD *)a2 + 22) - *((_QWORD *)a2 + 21))
    return 0;
  if (v6 != v5)
  {
    v7 = 0;
    v8 = 0;
    while (MIL::IRNamedValueType::Equals(*(MIL::IRNamedValueType **)(v5 + v7), *(const MIL::IRNamedValueType **)(*((_QWORD *)a2 + 21) + v7)))
    {
      ++v8;
      v5 = *((_QWORD *)this + 21);
      v7 += 16;
      if (v8 >= (*((_QWORD *)this + 22) - v5) >> 4)
        goto LABEL_10;
    }
    return 0;
  }
LABEL_10:
  v10 = *((_QWORD *)this + 24);
  v9 = *((_QWORD *)this + 25);
  v11 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v10) >> 3);
  v12 = *((_QWORD *)v2 + 24);
  if (v11 != 0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)v2 + 25) - v12) >> 3))
    return 0;
  if (v9 != v10)
  {
    v13 = 0;
    if (v11 <= 1)
      v14 = 1;
    else
      v14 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v10) >> 3);
    do
    {
      v15 = (unsigned __int8 *)(v10 + 24 * v13);
      v16 = (unsigned __int8 **)(v12 + 24 * v13);
      v17 = v15[23];
      if ((v17 & 0x80u) == 0)
        v18 = (unsigned __int8 *)v15[23];
      else
        v18 = (unsigned __int8 *)*((_QWORD *)v15 + 1);
      v19 = (unsigned __int8 *)*((unsigned __int8 *)v16 + 23);
      v20 = (char)v19;
      if ((char)v19 < 0)
        v19 = v16[1];
      if (v18 != v19)
        return 0;
      if (v20 >= 0)
        v21 = (unsigned __int8 *)(v12 + 24 * v13);
      else
        v21 = *v16;
      if ((v17 & 0x80) != 0)
      {
        if (memcmp(*(const void **)v15, v21, *((_QWORD *)v15 + 1)))
          return 0;
      }
      else if (v15[23])
      {
        while (*v15 == *v21)
        {
          ++v15;
          ++v21;
          if (!--v17)
            goto LABEL_30;
        }
        return 0;
      }
LABEL_30:
      ;
    }
    while (++v13 != v14);
  }
  v22 = (uint64_t **)*((_QWORD *)this + 30);
  v23 = *((_QWORD *)v2 + 30);
  v24 = **v22;
  v25 = (*v22)[1];
  if (v25 - v24 != *(_QWORD *)(*(_QWORD *)v23 + 8) - **(_QWORD **)v23)
    return 0;
  if (v25 == v24)
    return 1;
  v26 = 0;
  v27 = 0;
  do
  {
    result = MIL::IRObject::Equals(*(MIL::IRObject **)(v24 + v26), *(const MIL::IRObject **)(**(_QWORD **)v23 + v26));
    if ((result & 1) == 0)
      break;
    ++v27;
    v24 = **v22;
    v26 += 16;
  }
  while (v27 < ((*v22)[1] - v24) >> 4);
  return result;
}

void `anonymous namespace'::IRBlockImpl::Copy(_anonymous_namespace_::IRBlockImpl *this@<X0>, _anonymous_namespace_::IRBlockImpl **a2@<X8>)
{
  const std::string *v2[3];
  const std::string **v3;

  memset(v2, 0, sizeof(v2));
  v3 = v2;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v3);
}

void sub_1E0577EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IRBlockImpl::GetInputs(_anonymous_namespace_::IRBlockImpl *this)
{
  return (uint64_t)this + 168;
}

_QWORD *`anonymous namespace'::IRBlockImpl::SetInputs(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = &off_1EA993780;
  v4[1] = a1;
  v4[2] = a2;
  v5 = v4;
  MIL::IRCachedScope::InvalidateAndCall(a1 + 64, (uint64_t)v4);
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1E0577FA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::IRBlockImpl::GetOperations(_anonymous_namespace_::IRBlockImpl *this)
{
  return *((_QWORD *)this + 30);
}

{
  MIL::IRCachedScope::DisableCache((_anonymous_namespace_::IRBlockImpl *)((char *)this + 64));
  return *((_QWORD *)this + 30);
}

uint64_t `anonymous namespace'::IRBlockImpl::GetOperationsSharedPtr(_anonymous_namespace_::IRBlockImpl *this)
{
  MIL::IRCachedScope::DisableCache((_anonymous_namespace_::IRBlockImpl *)((char *)this + 64));
  return (uint64_t)this + 216;
}

uint64_t `anonymous namespace'::IRBlockImpl::GetOutputs(_anonymous_namespace_::IRBlockImpl *this)
{
  return (uint64_t)this + 192;
}

_QWORD *`anonymous namespace'::IRBlockImpl::SetOutputs(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = &off_1EA993800;
  v4[1] = a1;
  v4[2] = a2;
  v5 = v4;
  MIL::IRCachedScope::InvalidateAndCall(a1 + 64, (uint64_t)v4);
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1E05780E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *`anonymous namespace'::IRBlockImpl::SetParent(_anonymous_namespace_::IRBlockImpl *this, const MIL::IRScope *a2)
{
  _QWORD *result;
  uint64_t v3;
  const MIL::IRScope *v4;
  _QWORD v5[3];
  _QWORD *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  v5[0] = &off_1EA993880;
  v5[1] = this;
  v5[2] = &v4;
  v6 = v5;
  MIL::IRCachedScope::InvalidateAndCall((uint64_t)this + 64, (uint64_t)v5);
  result = v6;
  if (v6 == v5)
  {
    v3 = 4;
    result = v5;
  }
  else
  {
    if (!v6)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1E05781C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_anonymous_namespace_::IRBlockImpl **`anonymous namespace'::IRBlockImpl::WithOperations@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _anonymous_namespace_::IRBlockImpl **a3@<X8>)
{
  uint64_t *LocationPtr;
  uint64_t Attributes;
  uint64_t v8;
  _anonymous_namespace_::IRBlockImpl *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _anonymous_namespace_::IRBlockImpl *v16;
  void **v18[5];
  std::string v19;
  _BYTE v20[24];
  _anonymous_namespace_::IRBlockImpl *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a1);
  memset(&v19, 0, sizeof(v19));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v19, *(__int128 **)(a1 + 192), *(__int128 **)(a1 + 200), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 200) - *(_QWORD *)(a1 + 192)) >> 3));
  Attributes = MIL::IRObject::GetAttributes((MIL::IRObject *)a1);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v18, Attributes);
  v8 = operator new();
  v9 = (_anonymous_namespace_::IRBlockImpl *)v8;
  v10 = (std::__shared_weak_count *)LocationPtr[1];
  v22 = *LocationPtr;
  v23 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v21 = v9;
  v13 = v23;
  if (v23)
  {
    v14 = (unint64_t *)&v23->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v18);
  v18[0] = (void **)&v19;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v18);
  v18[0] = (void **)v20;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](v18);
  v16 = v21;
  v21 = 0;
  *a3 = v16;
}

void sub_1E0578364(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void `anonymous namespace'::IRBlockImpl::WithRenames(uint64_t a1@<X0>, const std::string **a2@<X1>, _anonymous_namespace_::IRBlockImpl **a3@<X8>)
{
  const std::string *v6;
  const std::string *v7;
  MIL::IRNamedValueType **v8;
  MIL::IRNamedValueType **v9;
  unsigned __int8 *Name;
  uint64_t v11;
  uint64_t v12;
  std::string::size_type size;
  int v14;
  const std::string *v15;
  MIL::IRNamedValueType *v16;
  std::string::size_type i;
  std::string::size_type v18;
  uint64_t v19;
  uint64_t v20;
  std::string::size_type v21;
  int v22;
  const std::string *v23;
  uint64_t v24;
  std::string::size_type v25;
  std::string::size_type v26;
  const std::string *v27;
  const std::string *v28;
  uint64_t v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  int v32;
  const std::string *v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  _anonymous_namespace_::IRBlockImpl *v37;
  std::__shared_weak_count *v38;
  _anonymous_namespace_::IRBlockImpl *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char *v46;
  uint64_t v47;
  _anonymous_namespace_::IRBlockImpl **v48;
  _QWORD *v49;
  _QWORD *v50;
  char *v51;
  __int128 v52;
  int64x2_t v53;
  uint64_t v54;
  _anonymous_namespace_::IRBlockImpl *v55;
  _anonymous_namespace_::IRBlockImpl **LocationPtr;
  uint64_t Attributes;
  uint64_t v58;
  _anonymous_namespace_::IRBlockImpl *v59;
  std::__shared_weak_count *v60;
  unint64_t *p_shared_owners;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  _anonymous_namespace_::IRBlockImpl *v66;
  _anonymous_namespace_::IRBlockImpl **v67;
  const MIL::IRScope **j;
  int64x2_t v69;
  _QWORD v70[2];
  std::string v71;
  std::string v72;
  _QWORD v73[3];
  std::string *v74;
  int64x2_t v75;
  uint64_t v76;
  _QWORD *v77;
  _anonymous_namespace_::IRBlockImpl *v78;
  std::__shared_weak_count *v79;
  _anonymous_namespace_::IRBlockImpl *v80[2];

  memset(&v72, 0, sizeof(v72));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v72, *(__int128 **)(a1 + 192), *(__int128 **)(a1 + 200), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 200) - *(_QWORD *)(a1 + 192)) >> 3));
  v6 = *a2;
  v7 = a2[1];
LABEL_2:
  if (v6 != v7)
  {
    v8 = (MIL::IRNamedValueType **)v73[0];
    v9 = (MIL::IRNamedValueType **)v73[1];
    while (v8 != v9)
    {
      Name = (unsigned __int8 *)MIL::IRNamedValueType::GetName(*v8);
      v11 = Name[23];
      if ((v11 & 0x80u) == 0)
        v12 = Name[23];
      else
        v12 = *((_QWORD *)Name + 1);
      size = HIBYTE(v6->__r_.__value_.__r.__words[2]);
      v14 = (char)size;
      if ((size & 0x80u) != 0)
        size = v6->__r_.__value_.__l.__size_;
      if (v12 == size)
      {
        if (v14 >= 0)
          v15 = v6;
        else
          v15 = (const std::string *)v6->__r_.__value_.__r.__words[0];
        if ((v11 & 0x80) != 0)
        {
          if (memcmp(*(const void **)Name, v15, *((_QWORD *)Name + 1)))
            goto LABEL_25;
LABEL_20:
          v16 = *v8;
          if (SHIBYTE(v6[1].__r_.__value_.__r.__words[2]) < 0)
            std::string::__init_copy_ctor_external(&v71, v6[1].__r_.__value_.__l.__data_, v6[1].__r_.__value_.__l.__size_);
          else
            v71 = v6[1];
          MIL::IRNamedValueType::SetName((uint64_t)v16, (__n128 *)&v71);
          if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v71.__r_.__value_.__l.__data_);
          goto LABEL_25;
        }
        if (!Name[23])
          goto LABEL_20;
        while (*Name == v15->__r_.__value_.__s.__data_[0])
        {
          ++Name;
          v15 = (const std::string *)((char *)v15 + 1);
          if (!--v11)
            goto LABEL_20;
        }
      }
LABEL_25:
      v8 += 2;
    }
    v18 = v72.__r_.__value_.__l.__size_;
    for (i = v72.__r_.__value_.__r.__words[0]; ; i += 24)
    {
      if (i == v18)
      {
        v6 += 2;
        goto LABEL_2;
      }
      v19 = *(unsigned __int8 *)(i + 23);
      if ((v19 & 0x80u) == 0)
        v20 = *(unsigned __int8 *)(i + 23);
      else
        v20 = *(_QWORD *)(i + 8);
      v21 = HIBYTE(v6->__r_.__value_.__r.__words[2]);
      v22 = (char)v21;
      if ((v21 & 0x80u) != 0)
        v21 = v6->__r_.__value_.__l.__size_;
      if (v20 == v21)
      {
        if (v22 >= 0)
          v23 = v6;
        else
          v23 = (const std::string *)v6->__r_.__value_.__r.__words[0];
        if ((v19 & 0x80) != 0)
        {
          if (memcmp(*(const void **)i, v23, *(_QWORD *)(i + 8)))
            continue;
LABEL_44:
          std::string::operator=((std::string *)i, v6 + 1);
          continue;
        }
        if (!*(_BYTE *)(i + 23))
          goto LABEL_44;
        v24 = 0;
        while (*(unsigned __int8 *)(i + v24) == v23->__r_.__value_.__s.__data_[v24])
        {
          if (v19 == ++v24)
            goto LABEL_44;
        }
      }
    }
  }
  v26 = v72.__r_.__value_.__l.__size_;
  v25 = v72.__r_.__value_.__r.__words[0];
LABEL_48:
  if (v25 != v26)
  {
    v27 = *a2;
    v28 = a2[1];
    while (1)
    {
      if (v27 == v28)
      {
        v25 += 24;
        goto LABEL_48;
      }
      v29 = *(unsigned __int8 *)(v25 + 23);
      if ((v29 & 0x80u) == 0)
        v30 = (unsigned __int8 *)*(unsigned __int8 *)(v25 + 23);
      else
        v30 = *(unsigned __int8 **)(v25 + 8);
      v31 = (unsigned __int8 *)HIBYTE(v27->__r_.__value_.__r.__words[2]);
      v32 = (char)v31;
      if ((char)v31 < 0)
        v31 = (unsigned __int8 *)v27->__r_.__value_.__l.__size_;
      if (v30 == v31)
      {
        if (v32 >= 0)
          v33 = v27;
        else
          v33 = (const std::string *)v27->__r_.__value_.__r.__words[0];
        if ((v29 & 0x80) != 0)
        {
          if (memcmp(*(const void **)v25, v33, *(_QWORD *)(v25 + 8)))
            goto LABEL_68;
LABEL_67:
          std::string::operator=((std::string *)v25, v27 + 1);
          goto LABEL_68;
        }
        if (!*(_BYTE *)(v25 + 23))
          goto LABEL_67;
        v34 = 0;
        while (*(unsigned __int8 *)(v25 + v34) == v33->__r_.__value_.__s.__data_[v34])
        {
          if (v29 == ++v34)
            goto LABEL_67;
        }
      }
LABEL_68:
      v27 += 2;
    }
  }
  v67 = a3;
  v69 = 0uLL;
  v70[0] = 0;
  std::vector<std::shared_ptr<MIL::IROperation>>::reserve((char **)&v69, (uint64_t)(*(_QWORD *)(a1 + 224) - *(_QWORD *)(a1 + 216)) >> 4);
  v35 = *(_QWORD **)(a1 + 216);
  v36 = *(_QWORD **)(a1 + 224);
  for (j = (const MIL::IRScope **)a1; v35 != v36; v35 += 2)
  {
    (*(void (**)(_anonymous_namespace_::IRBlockImpl **__return_ptr, _QWORD, const std::string **))(*(_QWORD *)*v35 + 48))(v80, *v35, a2);
    v37 = v80[0];
    v78 = v80[0];
    if (v80[0])
    {
      v38 = (std::__shared_weak_count *)operator new();
      v39 = v80[0];
      v38->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA992FA8;
      v38->__shared_owners_ = 0;
      v38->__shared_weak_owners_ = 0;
      v38[1].__vftable = (std::__shared_weak_count_vtbl *)v39;
    }
    else
    {
      v38 = 0;
    }
    v79 = v38;
    v80[0] = 0;
    v40 = v69.i64[1];
    if (v69.i64[1] >= v70[0])
    {
      v42 = (v69.i64[1] - v69.i64[0]) >> 4;
      v43 = v42 + 1;
      if ((unint64_t)(v42 + 1) >> 60)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v44 = v70[0] - v69.i64[0];
      if ((v70[0] - v69.i64[0]) >> 3 > v43)
        v43 = v44 >> 3;
      if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF0)
        v45 = 0xFFFFFFFFFFFFFFFLL;
      else
        v45 = v43;
      v77 = v70;
      v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)v70, v45);
      v48 = (_anonymous_namespace_::IRBlockImpl **)&v46[16 * v42];
      *v48 = v37;
      v48[1] = (_anonymous_namespace_::IRBlockImpl *)v38;
      v78 = 0;
      v79 = 0;
      v49 = (_QWORD *)v69.i64[1];
      v50 = (_QWORD *)v69.i64[0];
      if (v69.i64[1] == v69.i64[0])
      {
        v53 = vdupq_n_s64(v69.u64[1]);
        v51 = &v46[16 * v42];
      }
      else
      {
        v51 = &v46[16 * v42];
        do
        {
          v52 = *((_OWORD *)v49 - 1);
          v49 -= 2;
          *((_OWORD *)v51 - 1) = v52;
          v51 -= 16;
          *v49 = 0;
          v49[1] = 0;
        }
        while (v49 != v50);
        v53 = v69;
      }
      v41 = v48 + 2;
      v69.i64[0] = (uint64_t)v51;
      v69.i64[1] = (uint64_t)(v48 + 2);
      v75 = v53;
      v54 = v70[0];
      v70[0] = &v46[16 * v47];
      v76 = v54;
      v74 = (std::string *)v53.i64[0];
      std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v74);
    }
    else
    {
      *(_QWORD *)v69.i64[1] = v37;
      *(_QWORD *)(v40 + 8) = v38;
      v41 = (_QWORD *)(v40 + 16);
    }
    v69.i64[1] = (uint64_t)v41;
    v55 = v80[0];
    v80[0] = 0;
    if (v55)
      (*(void (**)(_anonymous_namespace_::IRBlockImpl *))(*(_QWORD *)v55 + 8))(v55);
  }
  LocationPtr = (_anonymous_namespace_::IRBlockImpl **)MIL::IRObject::GetLocationPtr((MIL::IRObject *)j);
  Attributes = MIL::IRObject::GetAttributes((MIL::IRObject *)j);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)&v74, Attributes);
  v58 = operator new();
  v59 = (_anonymous_namespace_::IRBlockImpl *)v58;
  v60 = (std::__shared_weak_count *)LocationPtr[1];
  v78 = *LocationPtr;
  v79 = v60;
  if (v60)
  {
    p_shared_owners = (unint64_t *)&v60->__shared_owners_;
    do
      v62 = __ldxr(p_shared_owners);
    while (__stxr(v62 + 1, p_shared_owners));
  }
  v80[0] = v59;
  v63 = v79;
  if (v79)
  {
    v64 = (unint64_t *)&v79->__shared_owners_;
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&v74);
  v66 = v80[0];
  v80[0] = 0;
  *v67 = v66;
  v74 = (std::string *)&v69;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v74);
  v74 = &v72;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v74);
  v74 = (std::string *)v73;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v74);
}

void sub_1E0578930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char **a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char *a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  *(_QWORD *)(v27 - 96) = &a11;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v27 - 96));
  a11 = &a21;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a11);
  a21 = &a24;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IRBlockImpl::BuildScopeCache@<X0>(_anonymous_namespace_::IRBlockImpl *this@<X0>, _QWORD *a2@<X8>)
{
  MIL::IRNamedValueType **v4;
  MIL::IRNamedValueType **i;
  unsigned __int8 *Name;
  char v7;
  uint64_t v8;
  unsigned __int8 *v9;
  std::__shared_weak_count *size;
  unint64_t *v11;
  unint64_t v12;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  MIL::IRArgument **v20;
  MIL::IRArgument **v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD **v30;
  std::string::size_type v31;
  uint64_t v32;
  unint64_t v33;
  unsigned __int8 *v34;
  char v35;
  std::string::size_type v36;
  unsigned __int8 *v37;
  uint64_t v39;
  _QWORD *v40;
  std::string *v41;
  std::string::size_type v42;
  _QWORD *v43;
  _QWORD *v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  void *v49;
  _QWORD *LocationPtr;
  uint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  std::runtime_error *v54;
  std::runtime_error *exception;
  _QWORD *v56;
  std::string v57;
  char v58[24];
  __int128 v59;
  std::string v60;
  std::string v61;
  _OWORD v62[2];
  int v63;
  _OWORD v64[2];
  int v65;
  unsigned __int8 *v66;

  memset(v64, 0, sizeof(v64));
  v65 = 1065353216;
  memset(v62, 0, sizeof(v62));
  v63 = 1065353216;
  v4 = (MIL::IRNamedValueType **)*((_QWORD *)this + 21);
  for (i = (MIL::IRNamedValueType **)*((_QWORD *)this + 22); v4 != i; v4 += 2)
  {
    Name = (unsigned __int8 *)MIL::IRNamedValueType::GetName(*v4);
    v57.__r_.__value_.__r.__words[0] = 0;
    v57.__r_.__value_.__r.__words[0] = MIL::IRNamedValueType::GetType(*v4);
    std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::string const&,MIL::IRValueType const* const&>((uint64_t)v64, Name, (uint64_t)Name, &v57);
    if ((v7 & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::operator+<char>();
      std::runtime_error::runtime_error(exception, &v60);
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
    }
    v8 = *((_QWORD *)this + 20);
    if (v8)
    {
      (*(void (**)(std::string *__return_ptr, uint64_t, unsigned __int8 *, uint64_t))(*(_QWORD *)v8 + 56))(&v60, v8, Name, 1);
      if (v60.__r_.__value_.__r.__words[0])
      {
        v61.__r_.__value_.__r.__words[0] = (std::string::size_type)Name;
        v9 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v62, Name, (uint64_t)&std::piecewise_construct, (__int128 **)&v61);
        std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]((uint64_t)(v9 + 40), (__int128 *)&v60);
      }
    }
    else
    {
      *(_OWORD *)&v60.__r_.__value_.__l.__data_ = 0uLL;
    }
    size = (std::__shared_weak_count *)v60.__r_.__value_.__l.__size_;
    if (v60.__r_.__value_.__l.__size_)
    {
      v11 = (unint64_t *)(v60.__r_.__value_.__l.__size_ + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
    }
  }
  v56 = a2;
  v13 = (uint64_t **)**((_QWORD **)this + 30);
  v14 = *v13;
  v15 = v13[1];
  if (*v13 != v15)
  {
    do
    {
      v16 = *v14;
      v17 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)*v14 + 160))(*v14);
      v18 = v17 + 1;
      v19 = (_QWORD *)*v17;
      if ((_QWORD *)*v17 != v17 + 1)
      {
        do
        {
          v20 = (MIL::IRArgument **)v19[7];
          v21 = (MIL::IRArgument **)v19[8];
          while (v20 != v21)
          {
            if (((*(uint64_t (**)(MIL::IRArgument *))(*(_QWORD *)*v20 + 24))(*v20) & 1) == 0)
            {
              v22 = MIL::IRArgument::GetName(*v20);
              if (*(char *)(v22 + 23) < 0)
              {
                std::string::__init_copy_ctor_external(&v61, *(const std::string::value_type **)v22, *(_QWORD *)(v22 + 8));
              }
              else
              {
                v23 = *(_OWORD *)v22;
                v61.__r_.__value_.__r.__words[2] = *(_QWORD *)(v22 + 16);
                *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v23;
              }
              if (!std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v64, (unsigned __int8 *)&v61))
              {
                v24 = *((_QWORD *)this + 20);
                if (v24)
                {
                  if (!(*(uint64_t (**)(uint64_t, std::string *, uint64_t))(*(_QWORD *)v24 + 24))(v24, &v61, 1))
                  {
                    else
                      v39 = 305;
                    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v60);
                    v40 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v60, (uint64_t)"Input '", 7);
                    if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v41 = &v61;
                    else
                      v41 = (std::string *)v61.__r_.__value_.__r.__words[0];
                    if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v42 = HIBYTE(v61.__r_.__value_.__r.__words[2]);
                    else
                      v42 = v61.__r_.__value_.__l.__size_;
                    v43 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)v41, v42);
                    v44 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, (uint64_t)"' for parameter '", 17);
                    v45 = *((char *)v19 + 55);
                    if (v45 >= 0)
                      v46 = (uint64_t)(v19 + 4);
                    else
                      v46 = v19[4];
                    if (v45 >= 0)
                      v47 = *((unsigned __int8 *)v19 + 55);
                    else
                      v47 = v19[5];
                    v48 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, v46, v47);
                    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v48, (uint64_t)"' does not resolve. Operations are expected to be topologically sorted.", 71);
                    v49 = __cxa_allocate_exception(0x48uLL);
                    LocationPtr = (_QWORD *)MIL::IRObject::GetLocationPtr(this);
                    v51 = LocationPtr[1];
                    *(_QWORD *)&v59 = *LocationPtr;
                    *((_QWORD *)&v59 + 1) = v51;
                    if (v51)
                    {
                      v52 = (unint64_t *)(v51 + 8);
                      do
                        v53 = __ldxr(v52);
                      while (__stxr(v53 + 1, v52));
                    }
                    std::stringbuf::str();
                    MIL::ValidationError::ValidationError((uint64_t)v49, &v59, (uint64_t)v58, v39);
                  }
                }
              }
              if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v61.__r_.__value_.__l.__data_);
            }
            v20 += 2;
          }
          v25 = (_QWORD *)v19[1];
          if (v25)
          {
            do
            {
              v26 = v25;
              v25 = (_QWORD *)*v25;
            }
            while (v25);
          }
          else
          {
            do
            {
              v26 = (_QWORD *)v19[2];
              v27 = *v26 == (_QWORD)v19;
              v19 = v26;
            }
            while (!v27);
          }
          v19 = v26;
        }
        while (v26 != v18);
      }
      v28 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 72))(v16);
      v29 = v28;
      memset(&v60, 0, sizeof(v60));
      if (v28 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v28 + 104))(v28))
      {
        (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v29 + 248))(&v61, v29, v16);
        std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vdeallocate((void **)&v60.__r_.__value_.__l.__data_);
        v60 = v61;
        memset(&v61, 0, sizeof(v61));
        v57.__r_.__value_.__r.__words[0] = (std::string::size_type)&v61;
        std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v57);
      }
      v30 = (_QWORD **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 176))(v16);
      memset(&v61, 0, sizeof(v61));
      std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__init_with_size[abi:ne180100]<std::shared_ptr<MIL::IRNamedValueType>*,std::shared_ptr<MIL::IRNamedValueType>*>((char *)&v61, *v30, v30[1], ((char *)v30[1] - (char *)*v30) >> 4);
      v31 = v61.__r_.__value_.__r.__words[0];
      if (v61.__r_.__value_.__l.__size_ != v61.__r_.__value_.__r.__words[0])
      {
        v32 = 0;
        v33 = 0;
        do
        {
          v34 = (unsigned __int8 *)MIL::IRNamedValueType::GetName(*(MIL::IRNamedValueType **)(v31 + v32));
          v57.__r_.__value_.__r.__words[0] = MIL::IRNamedValueType::GetType(*(MIL::IRNamedValueType **)(v31 + v32));
          std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::string const&,MIL::IRValueType const*>((uint64_t)v64, v34, (uint64_t)v34, &v57);
          if ((v35 & 1) == 0)
          {
            v54 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            MIL::IRNamedValueType::GetName(*(MIL::IRNamedValueType **)(v31 + v32));
            std::operator+<char>();
            std::runtime_error::runtime_error(v54, &v57);
            __cxa_throw(v54, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
          }
          v36 = v60.__r_.__value_.__r.__words[0];
          if (v60.__r_.__value_.__r.__words[0] != v60.__r_.__value_.__l.__size_)
          {
            v66 = (unsigned __int8 *)MIL::IRNamedValueType::GetName(*(MIL::IRNamedValueType **)(v31 + v32));
            v37 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v62, v66, (uint64_t)&std::piecewise_construct, (__int128 **)&v66);
            std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]((_QWORD *)v37 + 5, (uint64_t *)(v36 + v32));
          }
          ++v33;
          v31 = v61.__r_.__value_.__r.__words[0];
          v32 += 16;
        }
        while (v33 < (uint64_t)(v61.__r_.__value_.__l.__size_ - v61.__r_.__value_.__r.__words[0]) >> 4);
      }
      v57.__r_.__value_.__r.__words[0] = (std::string::size_type)&v61;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v57);
      v61.__r_.__value_.__r.__words[0] = (std::string::size_type)&v60;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v61);
      v14 += 2;
    }
    while (v14 != v15);
  }
  MIL::IRMutableScope::Make(*((_QWORD *)this + 20), (uint64_t *)v64, (uint64_t *)v62, &v60);
  *v56 = v60.__r_.__value_.__r.__words[0];
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v62);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v64);
}

void sub_1E0578FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v30 - 192);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v30 - 144);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'`anonymous namespace'::IRBlockImpl::BuildScopeCache@<X0>(_anonymous_namespace_::IRBlockImpl *this@<X0>, _QWORD *a2@<X8>)
{
}

void std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOperations(std::vector<std::shared_ptr<MIL::IROperation>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IROperation>> &&>,void ()(void)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOperations(std::vector<std::shared_ptr<MIL::IROperation>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IROperation>> &&>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA9936F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOperations(std::vector<std::shared_ptr<MIL::IROperation>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IROperation>> &&>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA9936F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOperations(std::vector<std::shared_ptr<MIL::IROperation>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IROperation>> &&>,void ()(void)>::operator()(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t i;
  __int128 **v5;
  __int128 *v6;
  __int128 **v7;
  __int128 *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  MIL::IRArgument **v12;
  MIL::IRArgument **v13;
  unsigned __int8 *Name;
  MIL::Util *v15;
  const MIL::IROperator *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 *v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  __int128 v35;
  unsigned __int8 *v36;
  unsigned __int8 *v37;
  __int128 **v38;
  __int128 *v39;
  __int128 *v40;
  _QWORD *v41;
  uint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  uint64_t v46;
  __int128 *v47;
  char **v48;
  std::string v49;
  unsigned __int8 *v50;
  __int128 *v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  _OWORD v54[2];
  int v55;
  std::string *v56;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = v2[27];
  v48 = (char **)(v2 + 27);
  for (i = v2[28]; i != v3; i = std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](i - 16))
    ;
  v2[28] = v3;
  memset(v54, 0, sizeof(v54));
  v55 = 1065353216;
  v5 = *(__int128 ***)(a1 + 16);
  v6 = *v5;
  v8 = v5[1];
  v7 = v5 + 1;
  v47 = v8;
  if (v6 != v8)
  {
    v46 = a1;
    do
    {
      v9 = (_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)v6 + 160))(*(_QWORD *)v6);
      v11 = v9 + 1;
      v10 = (_QWORD *)*v9;
      if ((_QWORD *)*v9 != v9 + 1)
      {
        do
        {
          v12 = (MIL::IRArgument **)v10[7];
          v13 = (MIL::IRArgument **)v10[8];
          while (v12 != v13)
          {
            if ((*(unsigned int (**)(MIL::IRArgument *))(*(_QWORD *)*v12 + 16))(*v12))
            {
              Name = (unsigned __int8 *)MIL::IRArgument::GetName(*v12);
              if (std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v54, Name))
              {
                v15 = (MIL::Util *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)v6 + 64))(*(_QWORD *)v6);
                if (MIL::Util::IsConstexprOpTakingInputs(v15, v16))
                {
                  v17 = *(_QWORD *)v6;
                  v18 = MIL::IRArgument::GetName(*v12);
                  v50 = (unsigned __int8 *)MIL::IRArgument::GetName(*v12);
                  v19 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v54, v50, (uint64_t)&std::piecewise_construct, (__int128 **)&v50);
                  v20 = (std::__shared_weak_count *)*((_QWORD *)v19 + 6);
                  v52 = *((_QWORD *)v19 + 5);
                  v53 = v20;
                  if (v20)
                  {
                    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
                    do
                      v22 = __ldxr(p_shared_owners);
                    while (__stxr(v22 + 1, p_shared_owners));
                  }
                  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v17 + 248))(v17, v18, &v52);
                  v23 = v53;
                  if (v53)
                  {
                    v24 = (unint64_t *)&v53->__shared_owners_;
                    do
                      v25 = __ldaxr(v24);
                    while (__stlxr(v25 - 1, v24));
                    if (!v25)
                    {
                      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
                      std::__shared_weak_count::__release_weak(v23);
                    }
                  }
                }
              }
            }
            v12 += 2;
          }
          v26 = (_QWORD *)v10[1];
          if (v26)
          {
            do
            {
              v27 = v26;
              v26 = (_QWORD *)*v26;
            }
            while (v26);
          }
          else
          {
            do
            {
              v27 = (_QWORD *)v10[2];
              v28 = *v27 == (_QWORD)v10;
              v10 = v27;
            }
            while (!v28);
          }
          v10 = v27;
        }
        while (v27 != v11);
      }
      v29 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v6 + 72))(*(_QWORD *)v6);
      v30 = v29;
      if (v29 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v29 + 104))(v29))
      {
        (*(void (**)(unsigned __int8 **__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v30 + 248))(&v50, v30, *(_QWORD *)v6);
        if (v51 != (__int128 *)v50)
        {
          v31 = 0;
          v32 = 0;
          do
          {
            v33 = (_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)v6 + 176))(*(_QWORD *)v6);
            v34 = MIL::IRNamedValueType::GetName(*(MIL::IRNamedValueType **)(*v33 + v31));
            if (*(char *)(v34 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&v49, *(const std::string::value_type **)v34, *(_QWORD *)(v34 + 8));
            }
            else
            {
              v35 = *(_OWORD *)v34;
              v49.__r_.__value_.__r.__words[2] = *(_QWORD *)(v34 + 16);
              *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v35;
            }
            v36 = v50;
            v56 = &v49;
            v37 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v54, (unsigned __int8 *)&v49, (uint64_t)&std::piecewise_construct, (__int128 **)&v56);
            std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]((_QWORD *)v37 + 5, (uint64_t *)&v36[v31]);
            if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v49.__r_.__value_.__l.__data_);
            ++v32;
            v31 += 16;
          }
          while (v32 < ((char *)v51 - (char *)v50) >> 4);
        }
        v49.__r_.__value_.__r.__words[0] = (std::string::size_type)&v50;
        std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v49);
      }
      std::vector<std::shared_ptr<MIL::IROperation>>::push_back[abi:ne180100](v48, v6++);
    }
    while (v6 != v47);
    v38 = *(__int128 ***)(v46 + 16);
    v39 = *v38;
    v40 = v38[1];
    v7 = v38 + 1;
    v6 = v40;
    if (v40 != v39)
    {
      do
        std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)--v6);
      while (v6 != v39);
      v6 = v39;
    }
  }
  *v7 = v6;
  v41 = (_QWORD *)operator new();
  *v41 = v48;
  v42 = v2[30];
  v2[30] = v41;
  if (v42)
    MEMORY[0x1E0C023A0](v42, 0x20C4093837F09);
  v43 = (_QWORD *)v2[27];
  v44 = (_QWORD *)v2[28];
  while (v43 != v44)
  {
    (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*v43 + 112))(*v43, v2);
    v43 += 2;
  }
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v54);
}

void sub_1E05795A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a24);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOperations(std::vector<std::shared_ptr<MIL::IROperation>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IROperation>> &&>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOperations(std::vector<std::shared_ptr<MIL::IROperation>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IROperation>> &&>,void ()(void)>::target_type()
{
}

_QWORD *std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

uint64_t std::vector<std::shared_ptr<MIL::IROperation>>::push_back[abi:ne180100](char **a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;
  int64x2_t v29;
  char *v30;
  uint64_t v31;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v12 = (v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v14 = v5 - (_QWORD)*a1;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v31 = result;
    v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>(result, v15);
    v18 = &v16[16 * v12];
    v19 = *a2;
    *(_OWORD *)v18 = *a2;
    if (*((_QWORD *)&v19 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v23 = *a1;
    v22 = a1[1];
    if (v22 == *a1)
    {
      v26 = vdupq_n_s64((unint64_t)v22);
      v24 = &v16[16 * v12];
    }
    else
    {
      v24 = &v16[16 * v12];
      do
      {
        v25 = *((_OWORD *)v22 - 1);
        v22 -= 16;
        *((_OWORD *)v24 - 1) = v25;
        v24 -= 16;
        *(_QWORD *)v22 = 0;
        *((_QWORD *)v22 + 1) = 0;
      }
      while (v22 != v23);
      v26 = *(int64x2_t *)a1;
    }
    v11 = v18 + 16;
    *a1 = v24;
    a1[1] = v18 + 16;
    v29 = v26;
    v27 = a1[2];
    a1[2] = &v16[16 * v17];
    v30 = v27;
    v28 = v26.i64[0];
    result = std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v28);
  }
  else
  {
    *(_QWORD *)v7 = *(_QWORD *)a2;
    v8 = *((_QWORD *)a2 + 1);
    *((_QWORD *)v7 + 1) = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = v7 + 16;
  }
  a1[1] = v11;
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 **v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t v13;

  v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), (uint64_t)a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = *((_QWORD *)v11 + 1);
      if (v13 == v6)
      {
        if ((std::equal_to<std::string>::operator()[abi:ne180100](v12, v11 + 16, a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = *(unsigned __int8 **)v11;
    }
    while (v11);
  }
  return v11;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_1E0579BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;
  __int128 *v10;
  __int128 v11;

  v7 = a1 + 16;
  v8 = operator new(0x38uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
  }
  else
  {
    v11 = *v10;
    v8[4] = *((_QWORD *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  v8[5] = 0;
  v8[6] = 0;
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_1E0579C60(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::__function::__func<`anonymous namespace'::IRBlockImpl::SetInputs(std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&>,void ()(void)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRBlockImpl::SetInputs(std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA993780;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRBlockImpl::SetInputs(std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA993780;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRBlockImpl::SetInputs(std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  __n128 *v2;
  __n128 result;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(__n128 **)(a1 + 16);
  std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vdeallocate((void **)(v1 + 168));
  result = *v2;
  *(__n128 *)(v1 + 168) = *v2;
  *(_QWORD *)(v1 + 184) = v2[1].n128_u64[0];
  v2->n128_u64[0] = 0;
  v2->n128_u64[1] = 0;
  v2[1].n128_u64[0] = 0;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRBlockImpl::SetInputs(std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRBlockImpl::SetInputs(std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&)::{lambda(void)#1},std::allocator<std::vector<std::shared_ptr<MIL::IRNamedValueType>> &&>,void ()(void)>::target_type()
{
}

void std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vdeallocate(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        v3 = std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3 - 16);
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOutputs(std::vector<std::string> &&)::{lambda(void)#1},std::allocator<std::vector<std::string> &&>,void ()(void)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOutputs(std::vector<std::string> &&)::{lambda(void)#1},std::allocator<std::vector<std::string> &&>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA993800;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOutputs(std::vector<std::string> &&)::{lambda(void)#1},std::allocator<std::vector<std::string> &&>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA993800;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOutputs(std::vector<std::string> &&)::{lambda(void)#1},std::allocator<std::vector<std::string> &&>,void ()(void)>::operator()(uint64_t a1)
{
  std::vector<std::string> *v1;
  __n128 *v2;
  __n128 result;

  v1 = *(std::vector<std::string> **)(a1 + 8);
  v2 = *(__n128 **)(a1 + 16);
  std::vector<std::string>::__vdeallocate(v1 + 8);
  result = *v2;
  *(__n128 *)&v1[8].__begin_ = *v2;
  v1[8].__end_cap_.__value_ = (std::string *)v2[1].n128_u64[0];
  v2->n128_u64[0] = 0;
  v2->n128_u64[1] = 0;
  v2[1].n128_u64[0] = 0;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOutputs(std::vector<std::string> &&)::{lambda(void)#1},std::allocator<std::vector<std::string> &&>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRBlockImpl::SetOutputs(std::vector<std::string> &&)::{lambda(void)#1},std::allocator<std::vector<std::string> &&>,void ()(void)>::target_type()
{
}

void std::vector<std::string>::__vdeallocate(std::vector<std::string> *this)
{
  if (this->__begin_)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)this);
    operator delete(this->__begin_);
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
  }
}

void std::__function::__func<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1}>,void ()(void)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA993880;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA993880;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 160) = **(_QWORD **)(result + 16);
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1}>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRBlockImpl::SetParent(MIL::IRScope const*)::{lambda(void)#1}>,void ()(void)>::target_type()
{
}

void `anonymous namespace'::IRBlockImpl::CopyInputs(_anonymous_namespace_::IRBlockImpl *this@<X0>, uint64_t a2@<X8>)
{
  MIL::IRNamedValueType **v4;
  MIL::IRNamedValueType **i;
  uint64_t Name;
  __int128 v7;
  uint64_t Type;
  MIL::IRNamedValueType *v9;
  _QWORD *v10;
  MIL::IRNamedValueType *v11;
  unint64_t v12;
  MIL::IRNamedValueType **v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  MIL::IRNamedValueType **v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  uint64_t v27;
  void **v28;
  std::string __p;
  MIL::IRNamedValueType *v30;
  MIL::IRNamedValueType *v31;
  _QWORD *v32;
  uint64_t v33;
  int64x2_t v34;
  uint64_t v35;
  uint64_t v36;

  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  std::vector<std::shared_ptr<MIL::IROperation>>::reserve((char **)a2, (uint64_t)(*((_QWORD *)this + 22) - *((_QWORD *)this + 21)) >> 4);
  v4 = (MIL::IRNamedValueType **)*((_QWORD *)this + 21);
  for (i = (MIL::IRNamedValueType **)*((_QWORD *)this + 22); v4 != i; v4 += 2)
  {
    Name = MIL::IRNamedValueType::GetName(*v4);
    if (*(char *)(Name + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)Name, *(_QWORD *)(Name + 8));
    }
    else
    {
      v7 = *(_OWORD *)Name;
      __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(Name + 16);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v7;
    }
    Type = MIL::IRNamedValueType::GetType(*v4);
    MIL::IRNamedValueType::Make((uint64_t *)&__p, Type, (uint64_t *)&v30);
    v9 = v30;
    v31 = v30;
    if (v30)
    {
      v10 = (_QWORD *)operator new();
      v11 = v30;
      *v10 = &unk_1EA993900;
      v10[1] = 0;
      v10[2] = 0;
      v10[3] = v11;
    }
    else
    {
      v10 = 0;
    }
    v32 = v10;
    v30 = 0;
    v13 = *(MIL::IRNamedValueType ***)(a2 + 8);
    v12 = *(_QWORD *)(a2 + 16);
    if ((unint64_t)v13 >= v12)
    {
      v15 = ((uint64_t)v13 - *(_QWORD *)a2) >> 4;
      v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 60)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v17 = v12 - *(_QWORD *)a2;
      if (v17 >> 3 > v16)
        v16 = v17 >> 3;
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0)
        v18 = 0xFFFFFFFFFFFFFFFLL;
      else
        v18 = v16;
      v36 = a2 + 16;
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>(a2 + 16, v18);
      v21 = (MIL::IRNamedValueType **)&v19[16 * v15];
      *v21 = v9;
      v21[1] = (MIL::IRNamedValueType *)v10;
      v31 = 0;
      v32 = 0;
      v23 = *(char **)a2;
      v22 = *(char **)(a2 + 8);
      if (v22 == *(char **)a2)
      {
        v26 = vdupq_n_s64((unint64_t)v22);
        v24 = &v19[16 * v15];
      }
      else
      {
        v24 = &v19[16 * v15];
        do
        {
          v25 = *((_OWORD *)v22 - 1);
          v22 -= 16;
          *((_OWORD *)v24 - 1) = v25;
          v24 -= 16;
          *(_QWORD *)v22 = 0;
          *((_QWORD *)v22 + 1) = 0;
        }
        while (v22 != v23);
        v26 = *(int64x2_t *)a2;
      }
      v14 = v21 + 2;
      *(_QWORD *)a2 = v24;
      *(_QWORD *)(a2 + 8) = v21 + 2;
      v34 = v26;
      v27 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 16) = &v19[16 * v20];
      v35 = v27;
      v33 = v26.i64[0];
      std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v33);
    }
    else
    {
      *v13 = v9;
      v13[1] = (MIL::IRNamedValueType *)v10;
      v14 = v13 + 2;
    }
    *(_QWORD *)(a2 + 8) = v14;
    v28 = (void **)v30;
    v30 = 0;
    if (v28)
    {
      MIL::IRNamedValueType::~IRNamedValueType(v28);
      MEMORY[0x1E0C023A0]();
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1E057A1DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17)
{
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<MIL::IRNamedValueType  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

void **std::__shared_ptr_pointer<MIL::IRNamedValueType  *>::__on_zero_shared(uint64_t a1)
{
  void **result;

  result = *(void ***)(a1 + 24);
  if (result)
  {
    MIL::IRNamedValueType::~IRNamedValueType(result);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IRNamedValueType  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

void **std::unique_ptr<MIL::IRNamedValueType>::reset[abi:ne180100](void ***a1, void **a2)
{
  void **result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    MIL::IRNamedValueType::~IRNamedValueType(result);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

std::string *std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(std::string *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  std::string *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>((uint64_t)&v6->__r_.__value_.__r.__words[2], a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

void sub_1E057A374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<std::string>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(uint64_t a1, __int128 *a2, __int128 *a3, std::string *this)
{
  std::string *v4;
  __int128 *v6;
  __int128 v7;
  _QWORD v9[3];
  char v10;
  std::string *v11;
  std::string *v12;

  v4 = this;
  v11 = this;
  v12 = this;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
        v4 = v12;
      }
      else
      {
        v7 = *v6;
        v4->__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 2);
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      v6 = (__int128 *)((char *)v6 + 24);
      v12 = ++v4;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_1E057A4D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 1) < 0)
      operator delete(*(void **)(v1 - 24));
    v1 -= 24;
  }
}

uint64_t std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

uint64_t `anonymous namespace'::IRBlockImpl::LinearSearchOutputsForIdentifier(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3;
  MIL::IRNamedValueType **v4;
  MIL::IRNamedValueType **v5;
  unsigned __int8 *Name;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned __int8 *v11;

  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
  v4 = *(MIL::IRNamedValueType ***)v3;
  v5 = *(MIL::IRNamedValueType ***)(v3 + 8);
  while (v4 != v5)
  {
    Name = (unsigned __int8 *)MIL::IRNamedValueType::GetName(*v4);
    v7 = Name[23];
    if ((v7 & 0x80u) == 0)
      v8 = Name[23];
    else
      v8 = *((_QWORD *)Name + 1);
    v9 = a2[23];
    v10 = (char)v9;
    if ((v9 & 0x80u) != 0)
      v9 = *((_QWORD *)a2 + 1);
    if (v8 == v9)
    {
      if (v10 >= 0)
        v11 = a2;
      else
        v11 = *(unsigned __int8 **)a2;
      if ((v7 & 0x80) != 0)
      {
        if (!memcmp(*(const void **)Name, v11, *((_QWORD *)Name + 1)))
          return 1;
      }
      else
      {
        if (!Name[23])
          return 1;
        while (*Name == *v11)
        {
          ++Name;
          ++v11;
          if (!--v7)
            return 1;
        }
      }
    }
    v4 += 2;
  }
  return 0;
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x1E0DE4FE0];
  v3 = MEMORY[0x1E0DE4FE0] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x1E0DE4FE0] + 64;
  v4 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1E057A750(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1E0C022F8](v1);
  _Unwind_Resume(a1);
}

void MIL::ValidationError::~ValidationError(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1EA99F108;
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)&this[1]);
  std::runtime_error::~runtime_error(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1EA99F108;
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)&this[1]);
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F60];
  v3 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1E0C022F8](a1 + 112);
  return a1;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::string const&,MIL::IRValueType const* const&>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[3];

  v9 = (_QWORD *)(a1 + 24);
  v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__construct_node_hash<std::string const&,MIL::IRValueType const* const&>(a1, v11, a3, a4, (uint64_t)v27);
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    v20 = 1;
    if (v12 >= 3)
      v20 = (v12 & (v12 - 1)) != 0;
    v21 = v20 | (2 * v12);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v23);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v27[0] = *v24;
    *v24 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v27[0])
    {
      v25 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12)
          v25 %= v12;
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v27[0];
    }
  }
  i = (unsigned __int8 *)v27[0];
  ++*v9;
  return i;
}

void sub_1E057AA90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a13, __p);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__construct_node_hash<std::string const&,MIL::IRValueType const* const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  _QWORD *v10;
  std::string *v11;

  v9 = a1 + 16;
  v10 = operator new(0x30uLL);
  *(_QWORD *)(a5 + 8) = v9;
  *(_QWORD *)a5 = v10;
  *(_BYTE *)(a5 + 16) = 0;
  *v10 = 0;
  v10[1] = a2;
  v11 = (std::string *)(v10 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v10[4] = *(_QWORD *)(a3 + 16);
  }
  v10[5] = *a4;
  *(_BYTE *)(a5 + 16) = 1;
}

void sub_1E057AB4C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x1E0C0210C](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x1E0DE4A90]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x1E0C02118](v13);
  return a1;
}

void sub_1E057AC70(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  MEMORY[0x1E0C02118](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1E057AC50);
}

void sub_1E057ACB8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_1E057ADEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

char *std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__init_with_size[abi:ne180100]<std::shared_ptr<MIL::IRNamedValueType>*,std::shared_ptr<MIL::IRNamedValueType>*>(char *result, _QWORD *a2, _QWORD *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  if (a4)
  {
    v6 = result;
    result = std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vallocate[abi:ne180100](result, a4);
    v7 = (_QWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      *v7 = *a2;
      v8 = a2[1];
      v7[1] = v8;
      if (v8)
      {
        v9 = (unint64_t *)(v8 + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      a2 += 2;
      v7 += 2;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1E057AF3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::string const&,MIL::IRValueType const*>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[3];

  v9 = (_QWORD *)(a1 + 24);
  v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__construct_node_hash<std::string const&,MIL::IRValueType const*>(a1, v11, a3, a4, (uint64_t)v27);
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    v20 = 1;
    if (v12 >= 3)
      v20 = (v12 & (v12 - 1)) != 0;
    v21 = v20 | (2 * v12);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v23);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v27[0] = *v24;
    *v24 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v27[0])
    {
      v25 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12)
          v25 %= v12;
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v27[0];
    }
  }
  i = (unsigned __int8 *)v27[0];
  ++*v9;
  return i;
}

void sub_1E057B1F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a13, __p);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__construct_node_hash<std::string const&,MIL::IRValueType const*>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  _QWORD *v10;
  std::string *v11;

  v9 = a1 + 16;
  v10 = operator new(0x30uLL);
  *(_QWORD *)(a5 + 8) = v9;
  *(_QWORD *)a5 = v10;
  *(_BYTE *)(a5 + 16) = 0;
  *v10 = 0;
  v10[1] = a2;
  v11 = (std::string *)(v10 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v10[4] = *(_QWORD *)(a3 + 16);
  }
  v10[5] = *a4;
  *(_BYTE *)(a5 + 16) = 1;
}

void sub_1E057B2AC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRDataTypeToString@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  int *v5;

  v4 = 0;
  {
    v4 += 4;
    if (v4 == 92)
      return std::string::basic_string[abi:ne180100]<0>(a2, *((char **)v5 + 1));
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, *((char **)v5 + 1));
}

uint64_t MIL::StringToIRDataType(const void **a1, char a2)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  const void **v7;
  size_t v8;
  size_t v9;
  const void **v10;
  std::runtime_error *exception;
  std::string *v13;
  __int128 v14;
  std::string v15;
  std::string v16;

  v4 = 0;
  v5 = *((unsigned __int8 *)a1 + 23);
  v7 = (const void **)*a1;
  v6 = a1[1];
  do
  {
    v9 = v8;
    if ((v5 & 0x80) != 0)
    {
      if ((const void *)v8 != v6)
        goto LABEL_8;
      v10 = v7;
      if (v6 == (const void *)-1)
        std::string::__throw_out_of_range[abi:ne180100]();
    }
    else
    {
      v10 = a1;
      if (v9 != v5)
        goto LABEL_8;
    }
LABEL_8:
    v4 += 4;
  }
  while (v4 != 92);
  if ((a2 & 1) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v13 = std::string::append(&v15, " does not map to a data value type.");
    v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v16.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v16);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return 18;
}

void sub_1E057B450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

void *MIL::GetValidTensorDataTypes(MIL *this)
{
}

void *MIL::GetUnsupportedTensorDataTypes(MIL *this)
{
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("basic_string");
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
}

void sub_1E057B524(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
  return result;
}

BOOL MIL::IsFloat(int a1)
{
  uint64_t v1;
  int *v2;

  v1 = 0;
  {
    if (++v1 == 6)
  }
}

BOOL MIL::IsSignedInt(int a1)
{
  uint64_t v1;
  int *v2;

  v1 = 0;
  {
    if (++v1 == 5)
  }
}

BOOL MIL::IsUnsignedInt(int a1)
{
  uint64_t v1;
  int *v2;

  v1 = 0;
  v2 = (int *)"N3MIL10IRFunctionE";
  {
    if (++v1 == 9)
  }
}

void MIL::IRFunction::~IRFunction(MIL::IRFunction *this)
{
  MIL::IRCachedScope::~IRCachedScope((MIL::IRFunction *)((char *)this + 64));
  MIL::IRObject::~IRObject(this);
}

_QWORD *MIL::IRFunction::IRFunction(_QWORD *a1, __int128 *a2, uint64_t *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v8;

  v8 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  MIL::IRObject::IRObject(a1, (uint64_t)&v8, a3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  MIL::IRCachedScope::IRCachedScope((MIL::IRCachedScope *)(a1 + 8));
  *a1 = off_1EA993AD0;
  a1[8] = &unk_1EA993BD8;
  return a1;
}

void sub_1E057B6F0(_Unwind_Exception *a1)
{
  MIL::IRObject *v1;

  MIL::IRObject::~IRObject(v1);
  _Unwind_Resume(a1);
}

void MIL::IRFunction::Make(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, _QWORD *a5@<X8>)
{
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  _OWORD v8[2];
  int v9;
  void *__p[2];
  uint64_t v11;
  __int128 v12;

  v12 = *(_OWORD *)a1;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_OWORD *)__p = *(_OWORD *)a3;
  v11 = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 1065353216;
  MIL::IRFunction::Make(&v12, a2, (uint64_t)__p, a4, (uint64_t *)v8, a5);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v8);
  if (SHIBYTE(v11) < 0)
    operator delete(__p[0]);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1E057B7C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  if (a20 < 0)
    operator delete(__p);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v20 - 32);
  _Unwind_Resume(a1);
}

void MIL::IRFunction::Make(__int128 *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, _QWORD *a6@<X8>)
{
  uint64_t v12;
  std::string::size_type v13;
  uint64_t v14;
  void *v15;
  void *__p[2];
  std::string::size_type v17;
  uint64_t v18;
  uint64_t *v19;
  _QWORD *v20[2];
  std::string v21;

  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v21, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v21 = *(std::string *)a3;
  v20[0] = 0;
  v20[1] = 0;
  v19 = (uint64_t *)v20;
  *(_OWORD *)__p = *(_OWORD *)&v21.__r_.__value_.__l.__data_;
  v12 = *a4;
  *a4 = 0;
  v13 = v21.__r_.__value_.__r.__words[2];
  memset(&v21, 0, sizeof(v21));
  v17 = v13;
  v18 = v12;
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>(&v19, (const void **)__p, (__int128 *)__p);
  v14 = v18;
  v18 = 0;
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  if (SHIBYTE(v17) < 0)
    operator delete(__p[0]);
  v15 = __p[0];
  __p[0] = 0;
  *a6 = v15;
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy((uint64_t)&v19, v20[0]);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
}

void sub_1E057B918(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, _QWORD *a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy((uint64_t)&a14, a15);
  if (a22 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<`anonymous namespace'::IRFunctionImpl,std::shared_ptr<MIL::Location const>,std::map<std::string,MIL::IRValueType const*>,std::string,std::map<std::string,std::unique_ptr<MIL::IRBlock>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(__int128 *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  void *__p[2];
  uint64_t v17;
  __int128 v18;

  v12 = operator new();
  v18 = *a1;
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *(_OWORD *)__p = *(_OWORD *)a3;
  v17 = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  *a6 = v12;
  if (SHIBYTE(v17) < 0)
    operator delete(__p[0]);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
  if (*((_QWORD *)&v18 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E057BA74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  if (a14 < 0)
    operator delete(__p);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C402FF647B4);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::IRFunctionImpl **std::unique_ptr<`anonymous namespace'::IRFunctionImpl>::~unique_ptr[abi:ne180100](_anonymous_namespace_::IRFunctionImpl **a1)
{
  _anonymous_namespace_::IRFunctionImpl *v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    MEMORY[0x1E0C023A0]();
  }
  return a1;
}

void MIL::IRFunction::Make(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, _anonymous_namespace_::IRFunctionImpl **a5@<X8>)
{
  _anonymous_namespace_::IRFunctionImpl *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  _OWORD v10[2];
  int v11;
  void *__p[2];
  uint64_t v13;
  __int128 v14;
  _anonymous_namespace_::IRFunctionImpl *v15;

  v14 = *(_OWORD *)a1;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_OWORD *)__p = *(_OWORD *)a3;
  v13 = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  memset(v10, 0, sizeof(v10));
  v11 = 1065353216;
  v6 = v15;
  v15 = 0;
  *a5 = v6;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v10);
  if (SHIBYTE(v13) < 0)
    operator delete(__p[0]);
  v7 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
  if (*((_QWORD *)&v14 + 1))
  {
    v8 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_1E057BBC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  if (a20 < 0)
    operator delete(__p);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v20 - 48);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::IRFunctionImpl **MIL::IRFunction::Make@<X0>(__int128 *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t *a5@<X4>, _anonymous_namespace_::IRFunctionImpl **a6@<X8>)
{
  _anonymous_namespace_::IRFunctionImpl *v7;
  _anonymous_namespace_::IRFunctionImpl *v9;

  v7 = v9;
  v9 = 0;
  *a6 = v7;
}

const MIL::Text::SerializerOptions *MIL::IRFunction::ToString(MIL::IRFunction *this)
{
  double v2;
  uint64_t v3;
  MIL::IROpset *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  MIL::Text::BasicSerializer *v8;
  const MIL::Text::SerializerOptions *result;
  void *__p[2];
  char v11;
  MIL::IROpset *v12;
  std::__shared_weak_count *v13;
  const MIL::Text::SerializerOptions *v14;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v14);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v14 + 112))(v14, 4, v2);
  v3 = (*(uint64_t (**)(MIL::IRFunction *))(*(_QWORD *)this + 176))(this);
  if (v3)
  {
    (*(void (**)(MIL::IROpset **__return_ptr))(*(_QWORD *)v3 + 48))(&v12);
    v4 = v12;
    v5 = v13;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  else
  {
    v4 = 0;
  }
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)&v12, v14);
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  v8 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Function((uint64_t)&v12, (uint64_t)__p, this, v4);
  MIL::Text::BasicSerializer::GetOutput(v8);
  if (v11 < 0)
    operator delete(__p[0]);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)&v12);
  result = v14;
  v14 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E057BD50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  uint64_t v16;
  uint64_t v18;

  v18 = *(_QWORD *)(v16 - 56);
  *(_QWORD *)(v16 - 56) = 0;
  if (v18)
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>,0>(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>(uint64_t **a1, const void **a2, __int128 *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v9[3];
  uint64_t v10;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, &v10, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__construct_node<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, v10, v7, v9[0]);
    v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

_QWORD *std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!std::less<std::string>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::string>::operator()[abi:ne180100](v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

std::string *std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__construct_node<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *result;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>::pair[abi:ne180100]((std::string *)(v6 + 32), a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1E057BFB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

BOOL std::less<std::string>::operator()[abi:ne180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

std::string *std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>::pair[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v4;
  std::string::size_type v5;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  v5 = *((_QWORD *)a2 + 3);
  *((_QWORD *)a2 + 3) = 0;
  this[1].__r_.__value_.__r.__words[0] = v5;
  return this;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

void `anonymous namespace'::IRFunctionImpl::~IRFunctionImpl(_anonymous_namespace_::IRFunctionImpl *this)
{
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy((uint64_t)this + 232, *((_QWORD **)this + 30));
  if (*((char *)this + 231) < 0)
    operator delete(*((void **)this + 26));
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)this + 184, *((char **)this + 24));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 160);
  MIL::IRCachedScope::~IRCachedScope((_anonymous_namespace_::IRFunctionImpl *)((char *)this + 64));
  MIL::IRObject::~IRObject(this);
}

{
  JUMPOUT(0x1E0C023A0);
}

void `non-virtual thunk to'`anonymous namespace'::IRFunctionImpl::~IRFunctionImpl(_anonymous_namespace_::IRFunctionImpl *this)
{
}

{
  JUMPOUT(0x1E0C023A0);
}

void std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy(a1, *((_QWORD *)a2 + 1));
    if (a2[55] < 0)
      operator delete(*((void **)a2 + 4));
    operator delete(a2);
  }
}

uint64_t `anonymous namespace'::IRFunctionImpl::IRFunctionImpl(uint64_t a1, uint64_t a2, _QWORD *a3, __int128 *a4, _QWORD *a5, uint64_t *a6)
{
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 *v23;
  uint64_t v24;
  void *exception;
  _QWORD *LocationPtr;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::string *v31;
  __int128 v32;
  __int128 v33;
  std::string v34;
  __int128 v35;
  __int128 v36;
  std::string::size_type v37;
  __int128 *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v33 = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  MIL::IRFunction::IRFunction((_QWORD *)a1, &v33, a6);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
  if (*((_QWORD *)&v33 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  *(_QWORD *)a1 = &off_1EA993C78;
  *(_QWORD *)(a1 + 64) = &unk_1EA993D88;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = *a3;
  v13 = a3 + 1;
  v14 = a3[1];
  *(_QWORD *)(a1 + 192) = v14;
  v15 = a1 + 192;
  v16 = a3[2];
  *(_QWORD *)(a1 + 200) = v16;
  if (v16)
  {
    *(_QWORD *)(v14 + 16) = v15;
    *a3 = v13;
    *v13 = 0;
    a3[2] = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 184) = v15;
  }
  v17 = *a4;
  *(_QWORD *)(a1 + 224) = *((_QWORD *)a4 + 2);
  *(_OWORD *)(a1 + 208) = v17;
  *((_QWORD *)a4 + 1) = 0;
  *((_QWORD *)a4 + 2) = 0;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a1 + 232) = *a5;
  v18 = a5 + 1;
  v19 = a5[1];
  *(_QWORD *)(a1 + 240) = v19;
  v20 = a1 + 240;
  v21 = a5[2];
  *(_QWORD *)(a1 + 248) = v21;
  if (v21)
  {
    *(_QWORD *)(v19 + 16) = v20;
    *a5 = v18;
    *v18 = 0;
    a5[2] = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 232) = v20;
  }
  v22 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(a1 + 232, (const void **)(a1 + 208));
  if (v20 == v22)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    LocationPtr = (_QWORD *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a1);
    v28 = LocationPtr[1];
    *(_QWORD *)&v35 = *LocationPtr;
    *((_QWORD *)&v35 + 1) = v28;
    if (v28)
    {
      v29 = (unint64_t *)(v28 + 8);
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    std::operator+<char>();
    v31 = std::string::append(&v34, "' not in blocks.");
    v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
    v37 = v31->__r_.__value_.__r.__words[2];
    v36 = v32;
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    MIL::ValidationError::ValidationError((uint64_t)exception, &v35, (uint64_t)&v36, 203);
  }
  *(_QWORD *)(a1 + 256) = *(_QWORD *)(v22 + 56);
  *(_QWORD *)&v36 = &off_1EA993E08;
  *((_QWORD *)&v36 + 1) = a1;
  v38 = &v36;
  MIL::IRCachedScope::InvalidateAndCall(a1 + 64, (uint64_t)&v36);
  v23 = v38;
  if (v38 == &v36)
  {
    v24 = 4;
    v23 = &v36;
    goto LABEL_17;
  }
  if (v38)
  {
    v24 = 5;
LABEL_17:
    (*(void (**)(void))(*(_QWORD *)v23 + 8 * v24))();
  }
  return a1;
}

void sub_1E057C610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26)
{
  uint64_t v26;
  MIL::IRCachedScope *v27;
  uint64_t v28;
  uint64_t v29;
  void **v30;
  uint64_t v31;
  void *v32;
  int v33;
  std::__shared_weak_count **v34;
  int v36;
  std::__shared_weak_count *v37;
  unint64_t *p_shared_owners;
  unint64_t v39;

  if (a25 < 0)
    operator delete(__p);
  if (v36)
  {
    if (v36 != 1)
      goto LABEL_13;
  }
  else
  {
    operator delete(a12);
    v37 = a19;
    if (a19)
    {
      p_shared_owners = (unint64_t *)&a19->__shared_owners_;
      do
        v39 = __ldaxr(p_shared_owners);
      while (__stlxr(v39 - 1, p_shared_owners));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    if (!v33)
    {
LABEL_13:
      std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy(v31, *(_QWORD **)(v26 + 240));
      if (*(char *)(v26 + 231) < 0)
        operator delete(*v30);
      std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy(v29, *(char **)(v26 + 192));
      std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v28);
      MIL::IRCachedScope::~IRCachedScope(v27);
      MIL::IRObject::~IRObject((MIL::IRObject *)v26);
      _Unwind_Resume(a1);
    }
  }
  __cxa_free_exception(v32);
  goto LABEL_13;
}

void sub_1E057C790(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v11;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  JUMPOUT(0x1E057C788);
}

uint64_t `anonymous namespace'::IRFunctionImpl::EqualsImpl(_anonymous_namespace_::IRFunctionImpl *this, const MIL::IRObject *a2)
{
  const MIL::IRObject *v2;
  const void **v4;
  const void ***v5;
  char *v6;
  char *v7;
  uint64_t v8;
  const void **v9;
  const void ***v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  const void **v16;
  unsigned __int8 *v17;
  const void **v18;
  const void ***v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t result;
  const void **v24;
  const void ***v25;

  if (*(void (***)(_anonymous_namespace_::IRFunctionImpl *__hidden))a2 == &off_1EA993C78)
    v2 = a2;
  else
    v2 = 0;
  if (*(void (***)(_anonymous_namespace_::IRFunctionImpl *__hidden))a2 == &off_1EA993C78
    && *((_QWORD *)this + 25) == *((_QWORD *)a2 + 25))
  {
    v4 = (const void **)*((_QWORD *)this + 23);
    v5 = (const void ***)((char *)this + 192);
    if (v4 != (const void **)((char *)this + 192))
    {
      v6 = (char *)a2 + 184;
      v7 = (char *)a2 + 192;
      do
      {
        v8 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>((uint64_t)v6, v4 + 4);
        if (v7 == (char *)v8 || v4[7] != *(const void **)(v8 + 56))
          return 0;
        v9 = (const void **)v4[1];
        if (v9)
        {
          do
          {
            v10 = (const void ***)v9;
            v9 = (const void **)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            v10 = (const void ***)v4[2];
            v11 = *v10 == v4;
            v4 = (const void **)v10;
          }
          while (!v11);
        }
        v4 = (const void **)v10;
      }
      while (v10 != v5);
    }
    v12 = *((unsigned __int8 *)this + 231);
    if ((v12 & 0x80u) == 0)
      v13 = *((unsigned __int8 *)this + 231);
    else
      v13 = *((_QWORD *)this + 27);
    v14 = *((unsigned __int8 *)v2 + 231);
    v15 = (char)v14;
    if ((v14 & 0x80u) != 0)
      v14 = *((_QWORD *)v2 + 27);
    if (v13 == v14)
    {
      v16 = (const void **)((char *)this + 208);
      if (v15 >= 0)
        v17 = (unsigned __int8 *)v2 + 208;
      else
        v17 = (unsigned __int8 *)*((_QWORD *)v2 + 26);
      if ((v12 & 0x80) != 0)
      {
        if (memcmp(*v16, v17, *((_QWORD *)this + 27)))
          return 0;
      }
      else if (*((_BYTE *)this + 231))
      {
        while (*(unsigned __int8 *)v16 == *v17)
        {
          v16 = (const void **)((char *)v16 + 1);
          ++v17;
          if (!--v12)
            goto LABEL_31;
        }
        return 0;
      }
LABEL_31:
      if (*((_QWORD *)this + 31) == *((_QWORD *)v2 + 31))
      {
        v18 = (const void **)*((_QWORD *)this + 29);
        v19 = (const void ***)((char *)this + 240);
        if (v18 == (const void **)((char *)this + 240))
          return 1;
        v20 = (uint64_t)v2 + 232;
        v21 = (char *)v2 + 240;
        while (1)
        {
          v22 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(v20, v18 + 4);
          if (v21 == (char *)v22)
            break;
          result = MIL::IRObject::Equals((MIL::IRObject *)v18[7], *(const MIL::IRObject **)(v22 + 56));
          if ((_DWORD)result)
          {
            v24 = (const void **)v18[1];
            if (v24)
            {
              do
              {
                v25 = (const void ***)v24;
                v24 = (const void **)*v24;
              }
              while (v24);
            }
            else
            {
              do
              {
                v25 = (const void ***)v18[2];
                v11 = *v25 == v18;
                v18 = (const void **)v25;
              }
              while (!v11);
            }
            result = 1;
            v18 = (const void **)v25;
            if (v25 != v19)
              continue;
          }
          return result;
        }
      }
    }
  }
  return 0;
}

uint64_t `anonymous namespace'::IRFunctionImpl::SelectedSpecialization(_anonymous_namespace_::IRFunctionImpl *this)
{
  return (uint64_t)this + 208;
}

uint64_t `anonymous namespace'::IRFunctionImpl::GetBlock(_anonymous_namespace_::IRFunctionImpl *this)
{
  return *((_QWORD *)this + 32);
}

{
  MIL::IRCachedScope::DisableCache((_anonymous_namespace_::IRFunctionImpl *)((char *)this + 64));
  return *((_QWORD *)this + 32);
}

void `anonymous namespace'::IRFunctionImpl::SpecializationNames(_anonymous_namespace_::IRFunctionImpl *this@<X0>, char **a2@<X8>)
{
  char *v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  BOOL v20;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::vector<std::string const*>::reserve((void **)a2, *((_QWORD *)this + 31));
  v4 = (char *)*((_QWORD *)this + 29);
  v5 = (char *)this + 240;
  if (v4 != (char *)this + 240)
  {
    v6 = a2 + 2;
    v7 = a2[1];
    do
    {
      v8 = v4 + 32;
      if ((unint64_t)v7 >= *v6)
      {
        v9 = (v7 - *a2) >> 3;
        if ((unint64_t)(v9 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v10 = *v6 - (_QWORD)*a2;
        v11 = v10 >> 2;
        if (v10 >> 2 <= (unint64_t)(v9 + 1))
          v11 = v9 + 1;
        if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
          v12 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v12 = v11;
        if (v12)
          v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v12);
        else
          v13 = 0;
        v14 = &v13[8 * v9];
        *(_QWORD *)v14 = v8;
        v7 = v14 + 8;
        v16 = *a2;
        v15 = a2[1];
        if (v15 != *a2)
        {
          do
          {
            v17 = *((_QWORD *)v15 - 1);
            v15 -= 8;
            *((_QWORD *)v14 - 1) = v17;
            v14 -= 8;
          }
          while (v15 != v16);
          v15 = *a2;
        }
        *a2 = v14;
        a2[1] = v7;
        a2[2] = &v13[8 * v12];
        if (v15)
          operator delete(v15);
      }
      else
      {
        *(_QWORD *)v7 = v8;
        v7 += 8;
      }
      a2[1] = v7;
      v18 = (char *)*((_QWORD *)v4 + 1);
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = *(char **)v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (char *)*((_QWORD *)v4 + 2);
          v20 = *(_QWORD *)v19 == (_QWORD)v4;
          v4 = v19;
        }
        while (!v20);
      }
      v4 = v19;
    }
    while (v19 != v5);
  }
}

void sub_1E057CB60(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::IRFunctionImpl::TrySpecializationForName(uint64_t a1, const void **a2)
{
  uint64_t v3;

  v3 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(a1 + 232, a2);
  if (a1 + 240 == v3)
    return 0;
  else
    return *(_QWORD *)(v3 + 56);
}

uint64_t `anonymous namespace'::IRFunctionImpl::CopySpecializationForName@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t result;

  result = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(a1 + 232, a2);
  if (a1 + 240 != result)
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(result + 56) + 32))(*(_QWORD *)(result + 56));
  *a3 = 0;
  return result;
}

_QWORD *`anonymous namespace'::IRFunctionImpl::SetBlock(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = &off_1EA993E88;
  v4[1] = a1;
  v4[2] = a2;
  v5 = v4;
  MIL::IRCachedScope::InvalidateAndCall(a1 + 64, (uint64_t)v4);
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1E057CCB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::IRFunctionImpl::SetSpecialization(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  void **v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;
  void **v10;
  void *__p[2];
  uint64_t v12;
  void **v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  __p[0] = &off_1EA993F08;
  __p[1] = a3;
  v12 = a1;
  v13 = __p;
  MIL::IRCachedScope::InvalidateAndCall(a1 + 64, (uint64_t)__p);
  v6 = v13;
  if (v13 == __p)
  {
    v7 = 4;
    v6 = __p;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v7 = 5;
  }
  (*((void (**)(void))*v6 + v7))();
LABEL_6:
  *(_OWORD *)__p = *(_OWORD *)a2;
  v8 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v9 = (void **)*a3;
  *a3 = 0;
  v12 = v8;
  v13 = v9;
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>((uint64_t **)(a1 + 232), (const void **)__p, (__int128 *)__p);
  v10 = v13;
  v13 = 0;
  if (v10)
    (*((void (**)(void **))*v10 + 1))(v10);
  if (SHIBYTE(v12) < 0)
    operator delete(__p[0]);
}

void sub_1E057CDF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v13;

  v13 = a12;
  a12 = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  MIL::IRFunction::Make((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *`anonymous namespace'::IRFunctionImpl::UseSpecialization(uint64_t a1, std::string *a2)
{
  _QWORD *result;

  std::string::operator=((std::string *)(a1 + 208), a2);
  result = (_QWORD *)std::map<std::string,std::unique_ptr<MIL::IRBlock>>::at(a1 + 232, (const void **)&a2->__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 256) = *result;
  return result;
}

uint64_t `anonymous namespace'::IRFunctionImpl::RemoveSpecialization(uint64_t a1, const void **a2)
{
  const void **v2;
  uint64_t v4;
  const void *v5;
  const void *v6;
  int v7;
  const void **v8;
  std::runtime_error *exception;
  std::string *v10;
  __int128 v11;
  std::string v13;
  std::string v14;

  v2 = a2;
  v4 = *(unsigned __int8 *)(a1 + 231);
  if ((v4 & 0x80u) == 0)
    v5 = (const void *)*(unsigned __int8 *)(a1 + 231);
  else
    v5 = *(const void **)(a1 + 216);
  v6 = (const void *)*((unsigned __int8 *)a2 + 23);
  v7 = (char)v6;
  if ((char)v6 < 0)
    v6 = a2[1];
  if (v5 != v6)
    return std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__erase_unique<std::string>((uint64_t **)(a1 + 232), v2);
  v8 = (const void **)(a1 + 208);
  if (v7 < 0)
    a2 = (const void **)*a2;
  if ((v4 & 0x80) != 0)
  {
    if (memcmp(*v8, a2, *(_QWORD *)(a1 + 216)))
      return std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__erase_unique<std::string>((uint64_t **)(a1 + 232), v2);
LABEL_13:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v10 = std::string::append(&v13, "').");
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v14.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v14);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  if (!*(_BYTE *)(a1 + 231))
    goto LABEL_13;
  while (*(unsigned __int8 *)v8 == *(unsigned __int8 *)a2)
  {
    v8 = (const void **)((char *)v8 + 1);
    a2 = (const void **)((char *)a2 + 1);
    if (!--v4)
      goto LABEL_13;
  }
  return std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__erase_unique<std::string>((uint64_t **)(a1 + 232), v2);
}

void sub_1E057CFB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t `anonymous namespace'::IRFunctionImpl::GetSpecializations(_anonymous_namespace_::IRFunctionImpl *this)
{
  return (uint64_t)this + 232;
}

{
  MIL::IRCachedScope::DisableCache((_anonymous_namespace_::IRFunctionImpl *)((char *)this + 64));
  return (uint64_t)this + 232;
}

uint64_t `anonymous namespace'::IRFunctionImpl::GetInputs(_anonymous_namespace_::IRFunctionImpl *this)
{
  return (uint64_t)this + 184;
}

_QWORD *`anonymous namespace'::IRFunctionImpl::SetInputs(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = &off_1EA993F88;
  v4[1] = a1;
  v4[2] = a2;
  v5 = v4;
  MIL::IRCachedScope::InvalidateAndCall(a1 + 64, (uint64_t)v4);
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1E057D0EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::IRFunctionImpl::GetInputType(uint64_t a1, const void **a2)
{
  return *(_QWORD *)std::map<std::string,std::unique_ptr<MIL::IRBlock>>::at(a1 + 184, a2);
}

uint64_t `anonymous namespace'::IRFunctionImpl::TryGetInputType(uint64_t a1, const void **a2)
{
  uint64_t v3;

  v3 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(a1 + 184, a2);
  if (a1 + 192 == v3)
    return 0;
  else
    return *(_QWORD *)(v3 + 56);
}

void `anonymous namespace'::IRFunctionImpl::GetOutputTypes(_anonymous_namespace_::IRFunctionImpl *this@<X0>, void **a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  uint64_t v21;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = *((_QWORD *)this + 32);
  v4 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 88))(v3);
  v5 = *v4;
  v6 = v4[1];
  if (*v4 != v6)
  {
    v7 = v3 + 64;
    do
    {
      v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 16))(v7, v5, 1);
      v9 = v8;
      v11 = (uint64_t *)a2[1];
      v10 = (unint64_t)a2[2];
      if ((unint64_t)v11 >= v10)
      {
        v13 = ((char *)v11 - (_BYTE *)*a2) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v14 = v10 - (_QWORD)*a2;
        v15 = v14 >> 2;
        if (v14 >> 2 <= (unint64_t)(v13 + 1))
          v15 = v13 + 1;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v16 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v16 = v15;
        if (v16)
          v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a2 + 2), v16);
        else
          v17 = 0;
        v18 = (uint64_t *)&v17[8 * v13];
        *v18 = v9;
        v12 = v18 + 1;
        v20 = (char *)*a2;
        v19 = (char *)a2[1];
        if (v19 != *a2)
        {
          do
          {
            v21 = *((_QWORD *)v19 - 1);
            v19 -= 8;
            *--v18 = v21;
          }
          while (v19 != v20);
          v19 = (char *)*a2;
        }
        *a2 = v18;
        a2[1] = v12;
        a2[2] = &v17[8 * v16];
        if (v19)
          operator delete(v19);
      }
      else
      {
        *v11 = v8;
        v12 = v11 + 1;
      }
      a2[1] = v12;
      v5 += 24;
    }
    while (v5 != v6);
  }
}

void sub_1E057D2C8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::IRFunctionImpl::GetParentProgram(_anonymous_namespace_::IRFunctionImpl *this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = *((_QWORD *)this + 22);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot access non-existent parent of an IRFunction.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E057D33C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IRFunctionImpl::TryGetParentProgram(_anonymous_namespace_::IRFunctionImpl *this)
{
  return *((_QWORD *)this + 22);
}

_QWORD *`anonymous namespace'::IRFunctionImpl::SetParent(_anonymous_namespace_::IRFunctionImpl *this, const MIL::IRProgram *a2)
{
  _QWORD *result;
  uint64_t v3;
  const MIL::IRProgram *v4;
  _QWORD v5[3];
  _QWORD *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  v5[0] = &off_1EA994008;
  v5[1] = this;
  v5[2] = &v4;
  v6 = v5;
  MIL::IRCachedScope::InvalidateAndCall((uint64_t)this + 64, (uint64_t)v5);
  result = v6;
  if (v6 == v5)
  {
    v3 = 4;
    result = v5;
  }
  else
  {
    if (!v6)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1E057D3FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::IRFunctionImpl::WithBlock(uint64_t a1@<X0>, uint64_t *a2@<X1>, _anonymous_namespace_::IRFunctionImpl **a3@<X8>)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *LocationPtr;
  uint64_t Attributes;
  _anonymous_namespace_::IRFunctionImpl *v11;
  __int128 *v12[5];
  uint64_t v13[3];
  _anonymous_namespace_::IRFunctionImpl *v14;
  uint64_t *v15[3];

  v12[0] = (__int128 *)(a1 + 208);
  v6 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v15, (const void **)(a1 + 208), (uint64_t)&std::piecewise_construct, v12);
  v7 = *a2;
  *a2 = 0;
  v8 = v6[7];
  v6[7] = v7;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a1);
  std::map<std::string,MIL::IRValueType const*>::map[abi:ne180100](v13, (const void ***)(a1 + 184));
  Attributes = MIL::IRObject::GetAttributes((MIL::IRObject *)a1);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v12, Attributes);
  v11 = v14;
  v14 = 0;
  *a3 = v11;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v12);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)v13, (char *)v13[1]);
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy((uint64_t)v15, v15[1]);
}

void sub_1E057D538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, char *a15)
{
  uint64_t v15;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)&a14, a15);
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy(v15 - 56, *(_QWORD **)(v15 - 48));
  _Unwind_Resume(a1);
}

BOOL `anonymous namespace'::IRFunctionImpl::HasSpecialization(uint64_t a1, const void **a2)
{
  return a1 + 240 != std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(a1 + 232, a2);
}

uint64_t `anonymous namespace'::IRFunctionImpl::UsingSpecialization@<X0>(const void ***a1@<X0>, uint64_t a2@<X1>, _anonymous_namespace_::IRFunctionImpl **a3@<X8>)
{
  uint64_t *LocationPtr;
  uint64_t Attributes;
  _anonymous_namespace_::IRFunctionImpl *v8;
  uint64_t v10[5];
  _QWORD v11[3];
  uint64_t v12[3];
  _anonymous_namespace_::IRFunctionImpl *v13;

  LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a1);
  std::map<std::string,MIL::IRValueType const*>::map[abi:ne180100](v12, a1 + 23);
  Attributes = MIL::IRObject::GetAttributes((MIL::IRObject *)a1);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v10, Attributes);
  v8 = v13;
  v13 = 0;
  *a3 = v8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v10);
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy((uint64_t)v11, (_QWORD *)v11[1]);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)v12, (char *)v12[1]);
  return (*(uint64_t (**)(_anonymous_namespace_::IRFunctionImpl *, uint64_t))(*(_QWORD *)v8 + 96))(v8, a2);
}

void sub_1E057D678(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  *v1 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::IRFunctionImpl::WithNamedSpecialization(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, _anonymous_namespace_::IRFunctionImpl **a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *LocationPtr;
  uint64_t Attributes;
  _anonymous_namespace_::IRFunctionImpl *v13;
  void *__p[2];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17[3];
  _anonymous_namespace_::IRFunctionImpl *v18;
  uint64_t *v19[3];

  *(_OWORD *)__p = *(_OWORD *)a2;
  v8 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v9 = *a3;
  *a3 = 0;
  v15 = v8;
  v16 = v9;
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>(v19, (const void **)__p, (__int128 *)__p);
  v10 = v16;
  v16 = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  if (SHIBYTE(v15) < 0)
    operator delete(__p[0]);
  LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a1);
  std::map<std::string,MIL::IRValueType const*>::map[abi:ne180100](v17, (const void ***)(a1 + 184));
  Attributes = MIL::IRObject::GetAttributes((MIL::IRObject *)a1);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)__p, Attributes);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)__p);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)v17, (char *)v17[1]);
  v13 = v18;
  v18 = 0;
  *a4 = v13;
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy((uint64_t)v19, v19[1]);
}

void sub_1E057D7F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy(v9 - 56, *(_QWORD **)(v9 - 48));
  _Unwind_Resume(a1);
}

void `anonymous namespace'::IRFunctionImpl::WithRenames(uint64_t a1@<X0>, std::string **a2@<X1>, MIL::IRFunction **a3@<X8>)
{
  std::string *v6;
  std::string *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  BOOL v16;
  uint64_t *LocationPtr;
  uint64_t Attributes;
  uint64_t Attribute;
  uint64_t v20;
  std::__shared_weak_count *size;
  unint64_t *v22;
  unint64_t v23;
  __int128 v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  __int128 v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::string *v36;
  std::string *v37;
  char v38;
  void *v39;
  void *v40;
  _anonymous_namespace_::IRFunctionImpl *v41;
  uint64_t EnumeratedShapes;
  __int128 *i;
  uint64_t *v44;
  uint64_t **v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  MIL::Attributes::FlexibleShapeInfo *v49;
  std::runtime_error *exception;
  std::string __p;
  std::string v52;
  uint64_t v53[6];
  uint64_t v54;
  std::__shared_weak_count *v55;
  __int128 *v56;
  MIL::Attributes::FlexibleShapeInfo *v57;
  _anonymous_namespace_::IRFunctionImpl *v58;
  uint64_t *v59;
  _QWORD *v60[2];
  uint64_t *v61;
  char *v62;

  std::map<std::string,MIL::IRValueType const*>::map[abi:ne180100]((uint64_t *)&v61, (const void ***)(a1 + 184));
  v6 = *a2;
  v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      v8 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>((uint64_t)&v61, (const void **)&v6->__r_.__value_.__l.__data_);
      if (&v62 != (char **)v8)
      {
        v9 = *(_QWORD *)(v8 + 56);
        v52.__r_.__value_.__r.__words[0] = (std::string::size_type)&v6[1];
        std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(&v61, (const void **)&v6[1].__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, (__int128 **)&v52)[7] = v9;
        std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__erase_unique<std::string>(&v61, (const void **)&v6->__r_.__value_.__l.__data_);
      }
      v6 += 2;
    }
    while (v6 != v7);
  }
  v60[0] = 0;
  v60[1] = 0;
  v59 = (uint64_t *)v60;
  v10 = *(_QWORD **)(a1 + 232);
  if (v10 != (_QWORD *)(a1 + 240))
  {
    do
    {
      (*(void (**)(uint64_t *__return_ptr, _QWORD, std::string **))(*(_QWORD *)v10[7] + 120))(&v54, v10[7], a2);
      if (*((char *)v10 + 55) < 0)
        std::string::__init_copy_ctor_external(&v52, (const std::string::value_type *)v10[4], v10[5]);
      else
        v52 = *(std::string *)(v10 + 4);
      v11 = v54;
      v54 = 0;
      v53[0] = v11;
      std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>(&v59, (const void **)&v52.__r_.__value_.__l.__data_, (__int128 *)&v52);
      v12 = v53[0];
      v53[0] = 0;
      if (v12)
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
      if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v52.__r_.__value_.__l.__data_);
      v13 = v54;
      v54 = 0;
      if (v13)
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
      v14 = (_QWORD *)v10[1];
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v15 = (_QWORD *)v10[2];
          v16 = *v15 == (_QWORD)v10;
          v10 = v15;
        }
        while (!v16);
      }
      v10 = v15;
    }
    while (v15 != (_QWORD *)(a1 + 240));
  }
  LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a1);
  Attributes = MIL::IRObject::GetAttributes((MIL::IRObject *)a1);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)&v52, Attributes);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&v52);
  if (!*(_QWORD *)(a1 + 176))
  {
    std::string::basic_string[abi:ne180100]<0>(&v52, "FlexibleShapeInformation");
    Attribute = MIL::IRObject::TryGetAttribute(a1, (unsigned __int8 *)&v52);
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v52.__r_.__value_.__l.__data_);
    if (Attribute)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Cannot rename flexible shapes on a function with no parent program.");
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
    }
  }
  if (*a2 == a2[1] || (v20 = *(_QWORD *)(a1 + 176)) == 0)
  {
    v41 = v58;
    v58 = 0;
    *a3 = v41;
    goto LABEL_85;
  }
  (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v20 + 48))(&v52);
  MIL::Attributes::FlexibleShapeInfo::Make((void (***)(MIL::MILContextImpl *__hidden))v52.__r_.__value_.__l.__data_, v58, &v57);
  size = (std::__shared_weak_count *)v52.__r_.__value_.__l.__size_;
  if (v52.__r_.__value_.__l.__size_)
  {
    v22 = (unint64_t *)(v52.__r_.__value_.__l.__size_ + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }
  MIL::Attributes::FlexibleShapeInfo::TryGetDefaultShapes((_QWORD **)v57, &v52);
  v24 = *(_OWORD *)&v52.__r_.__value_.__l.__data_;
  if (!v52.__r_.__value_.__l.__size_)
    goto LABEL_36;
  v25 = (unint64_t *)(v52.__r_.__value_.__l.__size_ + 8);
  do
    v26 = __ldaxr(v25);
  while (__stlxr(v26 - 1, v25));
  if (!v26)
  {
    (*(void (**)(_QWORD))(**((_QWORD **)&v24 + 1) + 16))(*((_QWORD *)&v24 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v24 + 1));
    if (!(_QWORD)v24)
      goto LABEL_43;
  }
  else
  {
LABEL_36:
    if (!(_QWORD)v24)
      goto LABEL_43;
  }
  MIL::Attributes::FlexibleShapeInfo::TryGetDefaultShapes((_QWORD **)v57, &v54);
  std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>::unordered_map((uint64_t)&v52, v54);
  v27 = v55;
  if (v55)
  {
    p_shared_owners = (unint64_t *)&v55->__shared_owners_;
    do
      v29 = __ldaxr(p_shared_owners);
    while (__stlxr(v29 - 1, p_shared_owners));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  MIL::Attributes::FlexibleShapeInfo::SetDefaultShapes((uint64_t *)v57, (uint64_t *)&v52);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::~__hash_table((uint64_t)&v52);
LABEL_43:
  MIL::Attributes::FlexibleShapeInfo::TryGetRangeShapes((uint64_t)v57, &v52);
  v30 = *(_OWORD *)&v52.__r_.__value_.__l.__data_;
  if (!v52.__r_.__value_.__l.__size_)
    goto LABEL_47;
  v31 = (unint64_t *)(v52.__r_.__value_.__l.__size_ + 8);
  do
    v32 = __ldaxr(v31);
  while (__stlxr(v32 - 1, v31));
  if (!v32)
  {
    (*(void (**)(_QWORD))(**((_QWORD **)&v30 + 1) + 16))(*((_QWORD *)&v30 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v30 + 1));
    if ((_QWORD)v30)
    {
LABEL_48:
      MIL::Attributes::FlexibleShapeInfo::TryGetRangeShapes((uint64_t)v57, &v54);
      std::unordered_map<std::string,std::vector<std::pair<int,int>>>::unordered_map((uint64_t)&v52, v54);
      v33 = v55;
      if (v55)
      {
        v34 = (unint64_t *)&v55->__shared_owners_;
        do
          v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
      v36 = *a2;
      v37 = a2[1];
      while (v36 != v37)
      {
        std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__node_handle_extract[abi:ne180100]<std::__basic_node_handle<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::allocator<std::pair<std::string const,std::vector<MIL::IRDimension const*>>>,std::__map_node_handle_specifics>>(&v52, (unsigned __int8 *)v36, (uint64_t)&v54);
        if (v54)
        {
          std::string::operator=((std::string *)(v54 + 16), v36 + 1);
          if (v54)
          {
            std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__node_insert_unique(&v52, v54);
            if ((v38 & 1) != 0)
            {
              v39 = 0;
              if (BYTE1(v55))
                BYTE1(v55) = 0;
            }
            else
            {
              v39 = (void *)v54;
            }
            v54 = 0;
            if ((unsigned __int16)v55 >= 0x100u)
              BYTE1(v55) = 0;
            if (v39)
            {
              std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::IRDimension const*>>,0>((uint64_t)v39 + 16);
              operator delete(v39);
              v40 = (void *)v54;
              if (v54)
              {
                std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::IRDimension const*>>,0>(v54 + 16);
                operator delete(v40);
              }
            }
          }
        }
        v36 += 2;
      }
      MIL::Attributes::FlexibleShapeInfo::SetRangeShapes((uint64_t *)v57, (uint64_t *)&v52);
      std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::~__hash_table((uint64_t)&v52);
    }
  }
  else
  {
LABEL_47:
    if ((_QWORD)v30)
      goto LABEL_48;
  }
  EnumeratedShapes = MIL::Attributes::FlexibleShapeInfo::GetEnumeratedShapes(v57);
  std::unordered_map<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>::unordered_map((uint64_t)&v54, EnumeratedShapes);
  for (i = v56; i; i = *(__int128 **)i)
  {
    std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>::pair[abi:ne180100](&v52, i + 1);
    v44 = (uint64_t *)v57;
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&__p, v52.__r_.__value_.__l.__data_, v52.__r_.__value_.__l.__size_);
    else
      __p = v52;
    MIL::Attributes::FlexibleShapeInfo::AddEnumeratedShapes(v44, (uint64_t)&__p, v53);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::~__hash_table((uint64_t)v53);
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v52.__r_.__value_.__l.__data_);
  }
  v45 = (uint64_t **)v57;
  (*(void (**)(std::string *__return_ptr))(**(_QWORD **)(a1 + 176) + 48))(&v52);
  MIL::Attributes::FlexibleShapeInfo::Rewrite(v45, (void (***)(MIL::MILContextImpl *__hidden))v52.__r_.__value_.__l.__data_, v58, a3);
  v46 = (std::__shared_weak_count *)v52.__r_.__value_.__l.__size_;
  if (v52.__r_.__value_.__l.__size_)
  {
    v47 = (unint64_t *)(v52.__r_.__value_.__l.__size_ + 8);
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>>>::~__hash_table((uint64_t)&v54);
  v49 = v57;
  v57 = 0;
  if (v49)
  {
    MIL::Attributes::FlexibleShapeInfo::~FlexibleShapeInfo(v49);
    MEMORY[0x1E0C023A0]();
  }
LABEL_85:
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy((uint64_t)&v59, v60[0]);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)&v61, v62);
}

void sub_1E057DED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  void *v33;
  uint64_t v34;

  __cxa_free_exception(v33);
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy(v34 - 128, *(_QWORD **)(v34 - 120));
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy(v34 - 104, *(char **)(v34 - 96));
  _Unwind_Resume(a1);
}

void `anonymous namespace'::IRFunctionImpl::Copy(_anonymous_namespace_::IRFunctionImpl *this@<X0>, MIL::IRFunction **a2@<X8>)
{
  std::string *v2[3];
  std::string **v3;

  memset(v2, 0, sizeof(v2));
  v3 = v2;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v3);
}

void sub_1E057E0C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IRFunctionImpl::AlignSpecialization(_anonymous_namespace_::IRFunctionImpl *this)
{
  _QWORD ***v2;
  _QWORD *v3;
  _QWORD *v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  std::string::size_type v10;
  const void *v11;
  std::string *p_dst;
  unsigned __int8 *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  int v18;
  uint64_t *v19;
  int v20;
  int v21;
  uint64_t v22;
  std::string::size_type size;
  uint64_t v24;
  int v25;
  unsigned __int8 *v26;
  std::string *v27;
  uint64_t v28;
  char v29;
  void *v30;
  _QWORD ***v31;
  _QWORD *v32;
  _QWORD *i;
  uint64_t v34;
  uint64_t v35;
  const void *v36;
  uint64_t v37;
  size_t v38;
  std::string *v39;
  __int128 *v40;
  uint64_t v42;
  _anonymous_namespace_::IRFunctionImpl *v43;
  _BYTE v44[16];
  void *v45;
  std::string *v46;
  uint64_t v47;
  std::string __dst;
  __int128 v49;
  __int128 v50;
  int v51;

  v49 = 0u;
  v50 = 0u;
  v51 = 1065353216;
  MIL::IRCachedScope::DisableCache((_anonymous_namespace_::IRFunctionImpl *)((char *)this + 64));
  v42 = *((_QWORD *)this + 32);
  v43 = this;
  v2 = (_QWORD ***)(*(uint64_t (**)(void))(*(_QWORD *)v42 + 64))();
  v3 = **v2;
  v4 = (*v2)[1];
  if (v3 != v4)
  {
    v5 = (unsigned __int8 *)this + 208;
    while (1)
    {
      v6 = *v3;
      if ((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v3 + 232))(*v3))
        break;
      if (std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(&v49, v5))
      {
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)this + 208;
        v13 = std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v49, v5, (uint64_t)&std::piecewise_construct, (__int128 **)&__dst);
        v14 = *((_DWORD *)v13 + 10) + 1;
      }
      else
      {
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)this + 208;
        v13 = std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v49, v5, (uint64_t)&std::piecewise_construct, (__int128 **)&__dst);
        v14 = 1;
      }
      *((_DWORD *)v13 + 10) = v14;
LABEL_21:
      v3 += 2;
      if (v3 == v4)
        goto LABEL_22;
    }
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 232))(v6);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
    v10 = v9;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v11 = (const void *)v8;
    if (v9 >= 0x17)
    {
      v15 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v9 | 7) != 0x17)
        v15 = v9 | 7;
      v16 = v15 + 1;
      p_dst = (std::string *)operator new(v15 + 1);
      __dst.__r_.__value_.__l.__size_ = v10;
      __dst.__r_.__value_.__r.__words[2] = v16 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v9;
      p_dst = &__dst;
      if (!v9)
      {
LABEL_14:
        p_dst->__r_.__value_.__s.__data_[v10] = 0;
        if (std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(&v49, (unsigned __int8 *)&__dst))
        {
          v46 = &__dst;
          v17 = std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v49, (unsigned __int8 *)&__dst, (uint64_t)&std::piecewise_construct, (__int128 **)&v46);
          v18 = *((_DWORD *)v17 + 10) + 1;
        }
        else
        {
          v46 = &__dst;
          v17 = std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v49, (unsigned __int8 *)&__dst, (uint64_t)&std::piecewise_construct, (__int128 **)&v46);
          v18 = 1;
        }
        *((_DWORD *)v17 + 10) = v18;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__dst.__r_.__value_.__l.__data_);
        goto LABEL_21;
      }
    }
    memmove(p_dst, v11, v10);
    goto LABEL_14;
  }
LABEL_22:
  memset(&__dst, 0, sizeof(__dst));
  v19 = (uint64_t *)v50;
  if ((_QWORD)v50)
  {
    v20 = -1;
    do
    {
      v21 = *((_DWORD *)v19 + 10);
      if (v21 > v20)
      {
        std::string::operator=(&__dst, (const std::string *)(v19 + 2));
        v20 = v21;
      }
      v19 = (uint64_t *)*v19;
    }
    while (v19);
    if (v20 > 0)
    {
      v22 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      else
        size = __dst.__r_.__value_.__l.__size_;
      v24 = *((unsigned __int8 *)v43 + 231);
      v25 = (char)v24;
      if ((v24 & 0x80u) != 0)
        v24 = *((_QWORD *)v43 + 27);
      if (size == v24)
      {
        if (v25 >= 0)
          v26 = (unsigned __int8 *)v43 + 208;
        else
          v26 = (unsigned __int8 *)*((_QWORD *)v43 + 26);
        if ((*((_BYTE *)&__dst.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          if (!memcmp(__dst.__r_.__value_.__l.__data_, v26, __dst.__r_.__value_.__l.__size_))
            goto LABEL_63;
        }
        else
        {
          if (!*((_BYTE *)&__dst.__r_.__value_.__s + 23))
            goto LABEL_63;
          v27 = &__dst;
          while (v27->__r_.__value_.__s.__data_[0] == *v26)
          {
            v27 = (std::string *)((char *)v27 + 1);
            ++v26;
            if (!--v22)
              goto LABEL_63;
          }
        }
      }
      v28 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>((uint64_t)v43 + 232, (const void **)v43 + 26);
      if ((_anonymous_namespace_::IRFunctionImpl *)((char *)v43 + 240) == (_anonymous_namespace_::IRFunctionImpl *)v28)
      {
        v28 = 0;
        v29 = 0;
        v47 = 0;
      }
      else
      {
        std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__remove_node_pointer((uint64_t **)v43 + 29, (uint64_t *)v28);
        v29 = 1;
      }
      v46 = (std::string *)v28;
      BYTE1(v47) = v29;
      std::string::operator=((std::string *)(v28 + 32), &__dst);
      std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__node_handle_insert_unique[abi:ne180100]<std::__basic_node_handle<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::allocator<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>,std::__map_node_handle_specifics>,std::__insert_return_type<std::__map_iterator<std::__tree_iterator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>*,long>>,std::__basic_node_handle<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::allocator<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>,std::__map_node_handle_specifics>>>((uint64_t **)v43 + 29, (uint64_t *)&v46, (uint64_t)v44);
      v30 = v45;
      if (v45)
      {
        std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>,0>((uint64_t)v45 + 32);
        operator delete(v30);
        v45 = 0;
      }
      std::string::operator=((std::string *)((char *)v43 + 208), &__dst);
      v31 = (_QWORD ***)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v42 + 64))(v42);
      v32 = **v31;
      for (i = (*v31)[1]; v32 != i; v32 += 2)
      {
        v34 = *v32;
        if ((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v32 + 232))(*v32))
        {
          v35 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v34 + 232))(v34);
          v36 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v35 + 16))(v35);
          v38 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? HIBYTE(__dst.__r_.__value_.__r.__words[2])
              : __dst.__r_.__value_.__l.__size_;
          if (v37 == v38)
          {
            v39 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? &__dst
                : (std::string *)__dst.__r_.__value_.__r.__words[0];
            if (!memcmp(v36, v39, v38))
              (*(void (**)(uint64_t))(*(_QWORD *)v34 + 240))(v34);
          }
        }
      }
      v40 = (__int128 *)v46;
      if (v46)
      {
        std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>,0>((uint64_t)&v46[1].__r_.__value_.__l.__size_);
        operator delete(v40);
      }
    }
  }
LABEL_63:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v49);
}

void sub_1E057E518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  std::__basic_node_handle<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::allocator<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>,std::__map_node_handle_specifics>::~__basic_node_handle[abi:ne180100](&a16);
  if (a23 < 0)
    operator delete(__p);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a24);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IRFunctionImpl::BuildScopeCache@<X0>(_anonymous_namespace_::IRFunctionImpl *this@<X0>, _QWORD *a2@<X8>)
{
  unsigned __int8 *v4;
  char *v5;
  char v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  void *exception;
  _QWORD *LocationPtr;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::string *v18;
  __int128 v19;
  _BYTE v20[32];
  int v21;
  uint64_t v22;
  __int128 v23;
  std::string::size_type v24;
  __int128 v25;
  _OWORD v26[2];
  int v27;

  memset(v26, 0, sizeof(v26));
  v27 = 1065353216;
  v4 = (unsigned __int8 *)*((_QWORD *)this + 23);
  v5 = (char *)this + 192;
  if (v4 != (unsigned __int8 *)((char *)this + 192))
  {
    do
    {
      std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::string const&,MIL::IRValueType const* const&>((uint64_t)v26, v4 + 32, (uint64_t)(v4 + 32), (_QWORD *)v4 + 7);
      if (!v6)
      {
        exception = __cxa_allocate_exception(0x48uLL);
        LocationPtr = (_QWORD *)MIL::IRObject::GetLocationPtr(this);
        v15 = LocationPtr[1];
        *(_QWORD *)&v25 = *LocationPtr;
        *((_QWORD *)&v25 + 1) = v15;
        if (v15)
        {
          v16 = (unint64_t *)(v15 + 8);
          do
            v17 = __ldxr(v16);
          while (__stxr(v17 + 1, v16));
        }
        std::operator+<char>();
        v18 = std::string::append((std::string *)v20, "'");
        v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
        v24 = v18->__r_.__value_.__r.__words[2];
        v23 = v19;
        v18->__r_.__value_.__l.__size_ = 0;
        v18->__r_.__value_.__r.__words[2] = 0;
        v18->__r_.__value_.__r.__words[0] = 0;
        MIL::ValidationError::ValidationError((uint64_t)exception, &v25, (uint64_t)&v23, 205);
      }
      v7 = (unsigned __int8 *)*((_QWORD *)v4 + 1);
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (unsigned __int8 *)*((_QWORD *)v4 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != (unsigned __int8 *)v5);
  }
  v10 = *((_QWORD *)this + 22);
  if (v10)
    v11 = v10 + 64;
  else
    v11 = 0;
  memset(v20, 0, sizeof(v20));
  v21 = 1065353216;
  MIL::IRMutableScope::Make(v11, (uint64_t *)v26, (uint64_t *)v20, &v22);
  *a2 = v22;
  v22 = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v20);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v26);
}

void sub_1E057E714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,uint64_t a26,char a27)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'`anonymous namespace'::IRFunctionImpl::BuildScopeCache@<X0>(_anonymous_namespace_::IRFunctionImpl *this@<X0>, _QWORD *a2@<X8>)
{
}

uint64_t std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t *v8;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = a1 + 8;
  do
  {
    v7 = std::less<std::string>::operator()[abi:ne180100](v5, (const void **)(v3 + 32), a2);
    v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      v8 = (uint64_t *)v3;
      v6 = v3;
    }
    v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || std::less<std::string>::operator()[abi:ne180100](v5, a2, (const void **)(v6 + 32)))
    return v2;
  return v6;
}

void std::__function::__func<`anonymous namespace'::IRFunctionImpl::IRFunctionImpl(std::shared_ptr<MIL::Location const>,std::map<std::string,MIL::IRValueType const*> &&,std::string,std::map<std::string,std::unique_ptr<MIL::IRBlock>> &&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> &&)::{lambda(void)#2},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,void ()(void)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *std::__function::__func<`anonymous namespace'::IRFunctionImpl::IRFunctionImpl(std::shared_ptr<MIL::Location const>,std::map<std::string,MIL::IRValueType const*> &&,std::string,std::map<std::string,std::unique_ptr<MIL::IRBlock>> &&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> &&)::{lambda(void)#2},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA993E08;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRFunctionImpl::IRFunctionImpl(std::shared_ptr<MIL::Location const>,std::map<std::string,MIL::IRValueType const*> &&,std::string,std::map<std::string,std::unique_ptr<MIL::IRBlock>> &&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> &&)::{lambda(void)#2},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA993E08;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRFunctionImpl::IRFunctionImpl(std::shared_ptr<MIL::Location const>,std::map<std::string,MIL::IRValueType const*> &&,std::string,std::map<std::string,std::unique_ptr<MIL::IRBlock>> &&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> &&)::{lambda(void)#2},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  v1 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD **)(v1 + 232);
  v3 = (_QWORD *)(v1 + 240);
  if (v2 != (_QWORD *)(v1 + 240))
  {
    v4 = v1 + 64;
    do
    {
      result = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v2[7] + 104))(v2[7], v4);
      v5 = (_QWORD *)v2[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v2[2];
          v7 = *v6 == (_QWORD)v2;
          v2 = v6;
        }
        while (!v7);
      }
      v2 = v6;
    }
    while (v6 != v3);
  }
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRFunctionImpl::IRFunctionImpl(std::shared_ptr<MIL::Location const>,std::map<std::string,MIL::IRValueType const*> &&,std::string,std::map<std::string,std::unique_ptr<MIL::IRBlock>> &&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> &&)::{lambda(void)#2},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRFunctionImpl::IRFunctionImpl(std::shared_ptr<MIL::Location const>,std::map<std::string,MIL::IRValueType const*> &&,std::string,std::map<std::string,std::unique_ptr<MIL::IRBlock>> &&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> &&)::{lambda(void)#2},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,void ()(void)>::target_type()
{
}

void std::vector<std::string const*>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_QWORD *)v10 - 1);
        v10 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1}>,void ()(void)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA993E88;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA993E88;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  __int128 *v7;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(uint64_t **)(a1 + 16);
  *(_QWORD *)(v1 + 256) = *v2;
  v7 = (__int128 *)(v1 + 208);
  v3 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)(v1 + 232), (const void **)(v1 + 208), (uint64_t)&std::piecewise_construct, &v7);
  v4 = *v2;
  *v2 = 0;
  v5 = v3[7];
  v3[7] = v4;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 256) + 104))(*(_QWORD *)(v1 + 256), v1 + 64);
}

uint64_t std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1}>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetBlock(std::unique_ptr<MIL::IRBlock>)::{lambda(void)#1}>,void ()(void)>::target_type()
{
}

uint64_t *std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)v10);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

void std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    *((_QWORD *)v6 + 6) = *((_QWORD *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  *((_QWORD *)v6 + 7) = 0;
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_1E057EC8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetSpecialization(std::string,std::unique_ptr<MIL::IRBlock> &&)::{lambda(void)#1},std::allocator<std::unique_ptr<MIL::IRBlock> &&>,void ()(void)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetSpecialization(std::string,std::unique_ptr<MIL::IRBlock> &&)::{lambda(void)#1},std::allocator<std::unique_ptr<MIL::IRBlock> &&>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA993F08;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetSpecialization(std::string,std::unique_ptr<MIL::IRBlock> &&)::{lambda(void)#1},std::allocator<std::unique_ptr<MIL::IRBlock> &&>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA993F08;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetSpecialization(std::string,std::unique_ptr<MIL::IRBlock> &&)::{lambda(void)#1},std::allocator<std::unique_ptr<MIL::IRBlock> &&>,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(***(_QWORD ***)(a1 + 8) + 104))(**(_QWORD **)(a1 + 8), *(_QWORD *)(a1 + 16) + 64);
}

uint64_t std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetSpecialization(std::string,std::unique_ptr<MIL::IRBlock> &&)::{lambda(void)#1},std::allocator<std::unique_ptr<MIL::IRBlock> &&>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetSpecialization(std::string,std::unique_ptr<MIL::IRBlock> &&)::{lambda(void)#1},std::allocator<std::unique_ptr<MIL::IRBlock> &&>,void ()(void)>::target_type()
{
}

uint64_t std::map<std::string,std::unique_ptr<MIL::IRBlock>>::at(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>(a1, &v4, a2);
  if (!v2)
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  return v2 + 56;
}

uint64_t std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__erase_unique<std::string>(uint64_t **a1, const void **a2)
{
  uint64_t *v3;
  uint64_t *v4;

  v3 = (uint64_t *)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  v4 = v3;
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__remove_node_pointer(a1, v3);
  std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>,0>((uint64_t)(v4 + 4));
  operator delete(v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

void std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetInputs(std::map<std::string,MIL::IRValueType const*> &&)::{lambda(void)#1},std::allocator<std::map<std::string,MIL::IRValueType const*> &&>,void ()(void)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetInputs(std::map<std::string,MIL::IRValueType const*> &&)::{lambda(void)#1},std::allocator<std::map<std::string,MIL::IRValueType const*> &&>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA993F88;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetInputs(std::map<std::string,MIL::IRValueType const*> &&)::{lambda(void)#1},std::allocator<std::map<std::string,MIL::IRValueType const*> &&>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA993F88;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetInputs(std::map<std::string,MIL::IRValueType const*> &&)::{lambda(void)#1},std::allocator<std::map<std::string,MIL::IRValueType const*> &&>,void ()(void)>::operator()(uint64_t a1)
{
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__move_assign(*(_QWORD *)(a1 + 8) + 184, *(_QWORD **)(a1 + 16));
}

uint64_t std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetInputs(std::map<std::string,MIL::IRValueType const*> &&)::{lambda(void)#1},std::allocator<std::map<std::string,MIL::IRValueType const*> &&>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetInputs(std::map<std::string,MIL::IRValueType const*> &&)::{lambda(void)#1},std::allocator<std::map<std::string,MIL::IRValueType const*> &&>,void ()(void)>::target_type()
{
}

void std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__move_assign(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = (_QWORD *)(a1 + 8);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy(a1, *(char **)(a1 + 8));
  *(_QWORD *)a1 = *a2;
  v5 = a2 + 1;
  v6 = a2[1];
  *v4 = v6;
  v7 = a2[2];
  *(_QWORD *)(a1 + 16) = v7;
  if (v7)
  {
    *(_QWORD *)(v6 + 16) = v4;
    *a2 = v5;
    *v5 = 0;
    a2[2] = 0;
  }
  else
  {
    *(_QWORD *)a1 = v4;
  }
}

void std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1}>,void ()(void)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA994008;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA994008;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 176) = **(_QWORD **)(result + 16);
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1}>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1},std::allocator<`anonymous namespace'::IRFunctionImpl::SetParent(MIL::IRProgram const*)::{lambda(void)#1}>,void ()(void)>::target_type()
{
}

_QWORD *`anonymous namespace'::IRFunctionImpl::SpecializationsCopy@<X0>(_QWORD *this@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  _QWORD *v10;
  std::string v11;
  _QWORD *v12;

  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)a2 = a2 + 8;
  v3 = (_QWORD *)this[29];
  v4 = this + 30;
  if (v3 != this + 30)
  {
    do
    {
      (*(void (**)(_QWORD **__return_ptr))(*(_QWORD *)v3[7] + 32))(&v10);
      if (*((char *)v3 + 55) < 0)
        std::string::__init_copy_ctor_external(&v11, (const std::string::value_type *)v3[4], v3[5]);
      else
        v11 = *(std::string *)(v3 + 4);
      v5 = v10;
      v10 = 0;
      v12 = v5;
      std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>((uint64_t **)a2, (const void **)&v11.__r_.__value_.__l.__data_, (__int128 *)&v11);
      v6 = v12;
      v12 = 0;
      if (v6)
        (*(void (**)(_QWORD *))(*v6 + 8))(v6);
      if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v11.__r_.__value_.__l.__data_);
      this = v10;
      v10 = 0;
      if (this)
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
      v7 = (_QWORD *)v3[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v3[2];
          v9 = *v8 == (_QWORD)v3;
          v3 = v8;
        }
        while (!v9);
      }
      v3 = v8;
    }
    while (v8 != v4);
  }
  return this;
}

void sub_1E057F50C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  uint64_t v17;

  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::destroy(v17, *(_QWORD **)(v17 + 8));
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<`anonymous namespace'::IRFunctionImpl,std::shared_ptr<MIL::Location const> const&,std::map<std::string,MIL::IRValueType const*>,std::string const&,std::map<std::string,std::unique_ptr<MIL::IRBlock>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(uint64_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::string __p;
  uint64_t v20;
  std::__shared_weak_count *v21;

  v12 = operator new();
  v13 = (std::__shared_weak_count *)a1[1];
  v20 = *a1;
  v21 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    __p = *(std::string *)a3;
  *a6 = v12;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v16 = v21;
  if (v21)
  {
    v17 = (unint64_t *)&v21->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void sub_1E057F690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C402FF647B4);
  _Unwind_Resume(a1);
}

uint64_t *std::map<std::string,MIL::IRValueType const*>::map[abi:ne180100](uint64_t *a1, const void ***a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::map<std::string,MIL::IRValueType const*>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,MIL::IRValueType const*>,std::__tree_node<std::__value_type<std::string,MIL::IRValueType const*>,void *> *,long>>>(a1, *a2, a2 + 1);
  return a1;
}

void sub_1E057F710(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::map<std::string,MIL::IRValueType const*>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,MIL::IRValueType const*>,std::__tree_node<std::__value_type<std::string,MIL::IRValueType const*>,void *> *,long>>>(uint64_t *result, const void **a2, const void ***a3)
{
  const void **v4;
  uint64_t **v5;
  uint64_t *v6;
  const void **v7;
  const void ***v8;
  BOOL v9;

  if (a2 != (const void **)a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,MIL::IRValueType const*> const&>(v5, v6, v4 + 4, (uint64_t)(v4 + 4));
      v7 = (const void **)v4[1];
      if (v7)
      {
        do
        {
          v8 = (const void ***)v7;
          v7 = (const void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (const void ***)v4[2];
          v9 = *v8 == v4;
          v4 = (const void **)v8;
        }
        while (!v9);
      }
      v4 = (const void **)v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,MIL::IRValueType const*> const&>(uint64_t **a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;
  const void **v10;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__find_equal<std::string>(a1, a2, &v10, &v9, a3);
  result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__construct_node<std::pair<std::string const,MIL::IRValueType const*> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

const void **std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__find_equal<std::string>(_QWORD *a1, uint64_t *a2, const void ***a3, uint64_t *a4, const void **a5)
{
  const void **v9;
  const void **v11;
  const void **v12;
  uint64_t v13;
  const void **v14;
  const void **v15;
  uint64_t *v16;
  BOOL v17;
  const void **v18;

  v9 = (const void **)(a1 + 1);
  if (a1 + 1 == a2 || std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), a5, (const void **)a2 + 4))
  {
    if ((uint64_t *)*a1 == a2)
    {
      v12 = (const void **)a2;
LABEL_16:
      if (*a2)
      {
        *a3 = v12;
        return v12 + 1;
      }
      else
      {
        *a3 = (const void **)a2;
        return (const void **)a2;
      }
    }
    v11 = (const void **)*a2;
    if (*a2)
    {
      do
      {
        v12 = v11;
        v11 = (const void **)v11[1];
      }
      while (v11);
    }
    else
    {
      v16 = a2;
      do
      {
        v12 = (const void **)v16[2];
        v17 = *v12 == v16;
        v16 = (uint64_t *)v12;
      }
      while (v17);
    }
    if (std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), v12 + 4, a5))
      goto LABEL_16;
    return (const void **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
  }
  if (std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), (const void **)a2 + 4, a5))
  {
    a4 = a2 + 1;
    v13 = a2[1];
    if (v13)
    {
      v14 = (const void **)a2[1];
      do
      {
        v15 = v14;
        v14 = (const void **)*v14;
      }
      while (v14);
    }
    else
    {
      v18 = (const void **)a2;
      do
      {
        v15 = (const void **)v18[2];
        v17 = *v15 == v18;
        v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), a5, v15 + 4))
        return (const void **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
      v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = (const void **)a2;
    }
    return (const void **)a4;
  }
  *a3 = (const void **)a2;
  *a4 = (uint64_t)a2;
  return (const void **)a4;
}

void std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__construct_node<std::pair<std::string const,MIL::IRValueType const*> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  }
  *((_QWORD *)v6 + 7) = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_1E057FA4C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,MIL::IRValueType const*>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,MIL::IRValueType const*>,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0)
      operator delete(__p[4]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void `anonymous namespace'::RenameFlexibleShapeInfoMap<std::vector<MIL::IRDimension const*>>(std::string **a1, _QWORD *a2)
{
  std::string *v2;
  std::string *v3;
  char v5;
  void *v6;
  void *v7;
  uint64_t v8;
  unsigned __int16 v9;

  v2 = *a1;
  v3 = a1[1];
  if (*a1 != v3)
  {
    do
    {
      std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__node_handle_extract[abi:ne180100]<std::__basic_node_handle<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::allocator<std::pair<std::string const,std::vector<MIL::IRDimension const*>>>,std::__map_node_handle_specifics>>(a2, (unsigned __int8 *)v2, (uint64_t)&v8);
      if (v8)
      {
        std::string::operator=((std::string *)(v8 + 16), v2 + 1);
        if (v8)
        {
          std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__node_insert_unique(a2, v8);
          if ((v5 & 1) != 0)
          {
            v6 = 0;
            if (HIBYTE(v9))
              HIBYTE(v9) = 0;
          }
          else
          {
            v6 = (void *)v8;
          }
          v8 = 0;
          if (v9 >= 0x100u)
            HIBYTE(v9) = 0;
          if (v6)
          {
            std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::IRDimension const*>>,0>((uint64_t)v6 + 16);
            operator delete(v6);
            v7 = (void *)v8;
            if (v8)
            {
              std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::IRDimension const*>>,0>(v8 + 16);
              operator delete(v7);
            }
          }
        }
      }
      v2 += 2;
    }
    while (v2 != v3);
  }
}

void sub_1E057FB90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  std::__basic_node_handle<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::allocator<std::pair<std::string const,std::vector<MIL::IRDimension const*>>>,std::__map_node_handle_specifics>::~__basic_node_handle[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>::~pair(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::~__hash_table(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t *std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, &v9, a2);
  result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

void std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    *((_QWORD *)v6 + 6) = *((_QWORD *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  *((_QWORD *)v6 + 7) = 0;
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_1E057FCF8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,MIL::IRValueType const*>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__erase_unique<std::string>(uint64_t **a1, const void **a2)
{
  uint64_t v3;

  v3 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::erase(a1, v3);
  return 1;
}

uint64_t *std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::erase(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;

  v3 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__remove_node_pointer(a1, (uint64_t *)a2);
  if (*(char *)(a2 + 55) < 0)
    operator delete(*(void **)(a2 + 32));
  operator delete((void *)a2);
  return v3;
}

uint64_t std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned __int8 **)(a2 + 16); i; i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<MIL::IRDimension const*>> const&>(a1, i + 16, (__int128 *)i + 1);
  return a1;
}

void sub_1E057FDF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<MIL::IRDimension const*>> const&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__construct_node_hash<std::pair<std::string const,std::vector<MIL::IRDimension const*>> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1E0580074(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__construct_node_hash<std::pair<std::string const,std::vector<MIL::IRDimension const*>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x40uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<std::string const,std::vector<MIL::IRDimension const*>>::pair[abi:ne180100]((std::string *)(v8 + 16), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1E05800E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::vector<MIL::IRDimension const*>>::pair[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v4;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(this[1].__r_.__value_.__r.__words, *((const void **)a2 + 3), *((_QWORD *)a2 + 4), (uint64_t)(*((_QWORD *)a2 + 4) - *((_QWORD *)a2 + 3)) >> 3);
  return this;
}

void sub_1E0580168(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1E05801E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::IRDimension const*>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::IRDimension const*>>,0>(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::IRDimension const*>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__node_handle_extract[abi:ne180100]<std::__basic_node_handle<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::allocator<std::pair<std::string const,std::vector<MIL::IRDimension const*>>>,std::__map_node_handle_specifics>>(_QWORD *a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned __int8 *v5;
  uint64_t v6;
  char v7;
  _QWORD v8[3];

  v5 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(a1, a2);
  if (v5)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::remove(a1, v5, (uint64_t)v8);
    v6 = v8[0];
    v8[0] = 0;
    std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v8, 0);
    v7 = 1;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
  *(_QWORD *)a3 = v6;
  *(_BYTE *)(a3 + 9) = v7;
}

_QWORD *std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::remove@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__node_insert_unique(_QWORD *a1, uint64_t a2)
{
  _QWORD *v2;
  unsigned __int8 *v4;
  unint64_t v5;
  unsigned __int8 *v6;

  v2 = (_QWORD *)a2;
  v4 = (unsigned __int8 *)(a2 + 16);
  v5 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), a2 + 16);
  v2[1] = v5;
  v6 = std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__node_insert_unique_prepare[abi:ne180100]((uint64_t)a1, v5, v4);
  if (v6)
    return v6;
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__node_insert_unique_perform[abi:ne180100](a1, v2);
  return (unsigned __int8 *)v2;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__node_insert_unique_prepare[abi:ne180100](uint64_t a1, unint64_t a2, unsigned __int8 *a3)
{
  unint64_t v4;
  uint8x8_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 **v10;
  unsigned __int8 *i;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v4);
    v7.i16[0] = vaddlv_u8(v7);
    v8 = v7.u32[0];
    if (v7.u32[0] > 1uLL)
      v9 = v4 <= a2 ? a2 % v4 : a2;
    else
      v9 = (v4 - 1) & a2;
    v10 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v9);
    if (v10)
    {
      for (i = *v10; i; i = *(unsigned __int8 **)i)
      {
        v12 = *((_QWORD *)i + 1);
        if (v12 == a2)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a3) & 1) != 0)
            return i;
        }
        else
        {
          if (v8 > 1)
          {
            if (v12 >= v4)
              v12 %= v4;
          }
          else
          {
            v12 &= v4 - 1;
          }
          if (v12 != v9)
            break;
        }
      }
    }
  }
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v4 || (float)(v14 * (float)v4) < v13)
  {
    v15 = 1;
    if (v4 >= 3)
      v15 = (v4 & (v4 - 1)) != 0;
    v16 = v15 | (2 * v4);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v18);
  }
  return 0;
}

_QWORD *std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::__node_insert_unique_perform[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  _QWORD *v5;
  unint64_t v6;

  v2 = (int8x8_t)result[1];
  v3 = a2[1];
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(_QWORD *)&v2)
      v3 %= *(_QWORD *)&v2;
  }
  else
  {
    v3 &= *(_QWORD *)&v2 - 1;
  }
  v5 = *(_QWORD **)(*result + 8 * v3);
  if (v5)
  {
    *a2 = *v5;
LABEL_13:
    *v5 = a2;
    goto LABEL_14;
  }
  *a2 = result[2];
  result[2] = a2;
  *(_QWORD *)(*result + 8 * v3) = result + 2;
  if (*a2)
  {
    v6 = *(_QWORD *)(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v2)
        v6 %= *(_QWORD *)&v2;
    }
    else
    {
      v6 &= *(_QWORD *)&v2 - 1;
    }
    v5 = (_QWORD *)(*result + 8 * v6);
    goto LABEL_13;
  }
LABEL_14:
  ++result[3];
  return result;
}

void **std::__basic_node_handle<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::allocator<std::pair<std::string const,std::vector<MIL::IRDimension const*>>>,std::__map_node_handle_specifics>::~__basic_node_handle[abi:ne180100](void **a1)
{
  void *v2;

  v2 = *a1;
  if (*a1)
  {
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::IRDimension const*>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
    *a1 = 0;
  }
  return a1;
}

uint64_t std::unordered_map<std::string,std::vector<std::pair<int,int>>>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned __int8 **)(a2 + 16); i; i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<std::pair<int,int>>> const&>(a1, i + 16, (__int128 *)i + 1);
  return a1;
}

void sub_1E05807B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<std::pair<int,int>>> const&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>>>::__construct_node_hash<std::pair<std::string const,std::vector<std::pair<int,int>>> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1E0580A30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::pair<int,int>>>>>::__construct_node_hash<std::pair<std::string const,std::vector<std::pair<int,int>>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x40uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<std::string const,std::vector<std::pair<int,int>>>::pair[abi:ne180100]((std::string *)(v8 + 16), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1E0580AA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::vector<std::pair<int,int>>>::pair[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v4;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  std::vector<std::pair<int,int>>::__init_with_size[abi:ne180100]<std::pair<int,int>*,std::pair<int,int>*>((char *)&this[1], *((uint64_t **)a2 + 3), *((uint64_t **)a2 + 4), (uint64_t)(*((_QWORD *)a2 + 4) - *((_QWORD *)a2 + 3)) >> 3);
  return this;
}

void sub_1E0580B24(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<int,int>>::__init_with_size[abi:ne180100]<std::pair<int,int>*,std::pair<int,int>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    v7 = (_QWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      *v7++ = v8;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1E0580B94(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::unordered_map<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned __int8 **)(a2 + 16); i; i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>> const&>(a1, i + 16, (__int128 *)i + 1);
  return a1;
}

void sub_1E0580C0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>> const&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>>>::__construct_node_hash<std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1E0580E8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>>>::__construct_node_hash<std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x50uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>::pair[abi:ne180100]((std::string *)(v8 + 16), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1E0580F00(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,0>(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::~__hash_table(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

std::string *std::pair<std::string const,std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>>::pair[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v4;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  std::unordered_map<std::string,std::vector<MIL::IRDimension const*>>::unordered_map((uint64_t)&this[1], (uint64_t)a2 + 24);
  return this;
}

void sub_1E0581064(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

MIL::Attributes::FlexibleShapeInfo *std::unique_ptr<MIL::Attributes::FlexibleShapeInfo>::reset[abi:ne180100](MIL::Attributes::FlexibleShapeInfo **a1, MIL::Attributes::FlexibleShapeInfo *a2)
{
  MIL::Attributes::FlexibleShapeInfo *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    MIL::Attributes::FlexibleShapeInfo::~FlexibleShapeInfo(result);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  ++*v8;
  return i;
}

void sub_1E058132C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a13, __p);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *v9;
  __int128 *v10;
  __int128 v11;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x30uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  v9 = (std::string *)(v8 + 16);
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
  }
  else
  {
    v11 = *v10;
    *((_QWORD *)v8 + 4) = *((_QWORD *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  *((_DWORD *)v8 + 10) = 0;
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_1E05813DC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__node_handle_insert_unique[abi:ne180100]<std::__basic_node_handle<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::allocator<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>,std::__map_node_handle_specifics>,std::__insert_return_type<std::__map_iterator<std::__tree_iterator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>*,long>>,std::__basic_node_handle<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::allocator<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>,std::__map_node_handle_specifics>>>@<X0>(uint64_t **result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t **v3;
  uint64_t v5;
  unsigned int v7;
  uint64_t v8;

  v3 = result;
  v5 = *a2;
  if (!*a2)
  {
    *(_QWORD *)a3 = result + 1;
    *(_BYTE *)(a3 + 8) = 0;
LABEL_9:
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
    return result;
  }
  result = (uint64_t **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)result, &v8, (const void **)(v5 + 32));
  if (!*result)
  {
    result = (uint64_t **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(v3, v8, result, (uint64_t *)v5);
    *a2 = 0;
    if (*((_BYTE *)a2 + 9))
      *((_BYTE *)a2 + 9) = 0;
    *(_QWORD *)a3 = v5;
    *(_BYTE *)(a3 + 8) = 1;
    goto LABEL_9;
  }
  *(_QWORD *)a3 = *result;
  *(_BYTE *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = *a2;
  v7 = *((unsigned __int16 *)a2 + 4);
  *(_WORD *)(a3 + 24) = v7;
  *a2 = 0;
  if (v7 >= 0x100)
    *((_BYTE *)a2 + 9) = 0;
  return result;
}

void **std::__basic_node_handle<std::__tree_node<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,void *>,std::allocator<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>>,std::__map_node_handle_specifics>::~__basic_node_handle[abi:ne180100](void **a1)
{
  void *v2;

  v2 = *a1;
  if (*a1)
  {
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>,0>((uint64_t)v2 + 32);
    operator delete(v2);
    *a1 = 0;
  }
  return a1;
}

void OUTLINED_FUNCTION_0_0(void **a1)
{
  operator delete(*a1);
}

uint64_t MIL::GetDTypeForPixelFormat(int a1)
{
  uint64_t result;
  std::logic_error *exception;

  result = 14;
  if (a1 > 5)
  {
    if (a1 <= 0x3A)
    {
      if (((1 << a1) & 0x7803C000002C040) != 0)
        return 4;
      if (a1 == 41)
        return 15;
      if (((1 << a1) & 0x10000100000) != 0)
      {
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::invalid_argument::invalid_argument[abi:ne180100](exception, "Unsupported pixel format type.");
        __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
      }
    }
    if ((a1 - 90) >= 2)
    {
      if (a1 != 100)
        return result;
      return 4;
    }
    return 15;
  }
  if (a1 == 2)
    return 4;
  if (a1 == 3 || a1 == 5)
    return 5;
  return result;
}

void sub_1E05815E8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IsBiPlanar420Format(int a1)
{
  std::logic_error *exception;

  if ((a1 - 21) < 7 || (a1 - 70) < 2)
    return 1;
  if (a1 == 20 || a1 == 40)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Unsupported pixel format type.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  return 0;
}

void sub_1E0581678(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 MIL::GetShapeForPlane@<Q0>(void (***this)(MIL::MILContextImpl *__hidden this)@<X0>, MIL::MILContext *ChannelDimForFormat@<X4>, int a3@<W1>, MIL::IRDimension ***a4@<X2>, unsigned int a5@<W3>, _QWORD *a6@<X8>)
{
  uint64_t v11;
  MIL::IRDimension **v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  char *v23;
  __n128 result;
  std::logic_error *exception;
  __int128 v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;

  if (a3 != 100)
    ChannelDimForFormat = (MIL::MILContext *)MIL::GetChannelDimForFormat(a3, a5);
  v11 = MIL::IRConstantDimension::Make(this, ChannelDimForFormat);
  v12 = *a4;
  v13 = (uint64_t)a4[1];
  if (v13 - (_QWORD)*a4 != 16)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "ImageShape does not have exactly 2 dimensions.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  v14 = v11;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v27, v12, v13, 2uLL);
  v15 = MIL::IsBiPlanar420Format(a3) ^ 1;
  if (a5 != 1)
    LOBYTE(v15) = 1;
  if ((v15 & 1) == 0)
  {
    if ((*(uint64_t (**)(MIL::IRDimension *))(*(_QWORD *)**a4 + 16))(**a4))
    {
      v16 = MIL::IRDimension::AsConstant(**a4);
      v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 48))(v16);
      v18 = MIL::IRConstantDimension::Make(this, (MIL::MILContext *)(v17 >> 1));
      *v27 = v18;
    }
    if ((*(uint64_t (**)(MIL::IRDimension *))(*(_QWORD *)(*a4)[1] + 16))((*a4)[1]))
    {
      v19 = MIL::IRDimension::AsConstant((*a4)[1]);
      v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 48))(v19);
      v21 = MIL::IRConstantDimension::Make(this, (MIL::MILContext *)(v20 >> 1));
      v27[1] = v21;
    }
  }
  v22 = v27;
  v26 = *(_OWORD *)v27;
  a6[1] = 0;
  a6[2] = 0;
  *a6 = 0;
  v23 = (char *)operator new(0x18uLL);
  a6[1] = v23 + 24;
  a6[2] = v23 + 24;
  *(_QWORD *)v23 = v14;
  *(_OWORD *)(v23 + 8) = v26;
  *a6 = v23;
  v28 = v22;
  operator delete(v22);
  return result;
}

void sub_1E058182C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  void *v13;

  __cxa_free_exception(v13);
  _Unwind_Resume(a1);
}

BOOL MIL::SupportsMultiSlice(int a1)
{
  return a1 == 100;
}

uint64_t MIL::Util::GetRowAlignedStrides@<X0>(void (***a1)(MIL::MILContextImpl *__hidden this)@<X0>, int a2@<W1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, unint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v12;
  unint64_t v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  MIL::IRConstantPropertyImpl **v18;
  int ScalarDataType;
  MIL::IRConstantProperty *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  MIL::IRConstantProperty *v31;
  uint64_t Int64ScalarValue;
  MIL::IRDimension *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  std::logic_error *exception;
  std::string *v38;
  __int128 v39;
  std::string *v40;
  __int128 v41;
  std::logic_error *v42;
  std::string *v43;
  __int128 v44;
  std::logic_error *v45;
  std::string *v46;
  __int128 v47;
  std::string *v48;
  __int128 v49;
  std::runtime_error *v50;
  std::string *v51;
  __int128 v52;
  std::string *v53;
  __int128 v54;
  std::string v55;
  std::string v56;
  std::string v57;

  std::vector<MIL::IRProperty const*>::vector(a6, (a3[1] - *a3) >> 3);
  v12 = a3[1];
  if (v12 != *a3)
  {
    v13 = 0;
    v12 = *a3;
    while (1)
    {
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v12 + 8 * v13) + 24))(*(_QWORD *)(v12 + 8 * v13));
      if (result)
        break;
      ++v13;
      v12 = *a3;
      v15 = a3[1];
      if (v13 >= (v15 - *a3) >> 3)
        goto LABEL_7;
    }
    if (a6[1] != *a6)
    {
      v36 = 0;
      do
      {
        result = MIL::IRUnknownProperty::Make(a1, 0);
        *(_QWORD *)(*a6 + 8 * v36++) = result;
      }
      while (v36 < (a6[1] - *a6) >> 3);
    }
    return result;
  }
  v15 = a3[1];
LABEL_7:
  v16 = *a4;
  if (a4[1] != *a4)
  {
    v17 = 0;
    do
    {
      v18 = (MIL::IRConstantPropertyImpl **)MIL::IRProperty::AsConstant(*(MIL::IRProperty **)(v16 + 8 * v17));
      ScalarDataType = MIL::IRConstantProperty::GetScalarDataType(v18);
      if (ScalarDataType != 14)
      {
        if (ScalarDataType == 12)
        {
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::to_string(&v55, v17);
          v38 = std::string::insert(&v55, 0, "interleave_factor at index: ");
          v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
          v56.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v39;
          v38->__r_.__value_.__l.__size_ = 0;
          v38->__r_.__value_.__r.__words[2] = 0;
          v38->__r_.__value_.__r.__words[0] = 0;
          v40 = std::string::append(&v56, " is of type Int64. This interleave is not supproted. ");
          v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
          v57.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v41;
          v40->__r_.__value_.__l.__size_ = 0;
          v40->__r_.__value_.__r.__words[2] = 0;
          v40->__r_.__value_.__r.__words[0] = 0;
          std::logic_error::logic_error(exception, &v57);
          exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
          __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
        }
        v42 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::to_string(&v56, v17);
        v43 = std::string::insert(&v56, 0, "Unexpected types for interleave_factor at index: ");
        v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
        v57.__r_.__value_.__r.__words[2] = v43->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v44;
        v43->__r_.__value_.__l.__size_ = 0;
        v43->__r_.__value_.__r.__words[2] = 0;
        v43->__r_.__value_.__r.__words[0] = 0;
        std::logic_error::logic_error(v42, &v57);
        v42->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
        __cxa_throw(v42, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
      }
      v20 = (MIL::IRConstantProperty *)MIL::IRProperty::AsConstant(*(MIL::IRProperty **)(*a4 + 8 * v17));
      if (MIL::IRConstantProperty::GetUInt8ScalarValue(v20) != 1)
      {
        v45 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::to_string(&v55, v17);
        v46 = std::string::insert(&v55, 0, "interleave_factor at index: ");
        v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
        v56.__r_.__value_.__r.__words[2] = v46->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v47;
        v46->__r_.__value_.__l.__size_ = 0;
        v46->__r_.__value_.__r.__words[2] = 0;
        v46->__r_.__value_.__r.__words[0] = 0;
        v48 = std::string::append(&v56, " is not 1. This interleave is not supproted.");
        v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
        v57.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v49;
        v48->__r_.__value_.__l.__size_ = 0;
        v48->__r_.__value_.__r.__words[2] = 0;
        v48->__r_.__value_.__r.__words[0] = 0;
        std::logic_error::logic_error(v45, &v57);
        v45->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
        __cxa_throw(v45, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
      }
      ++v17;
      v16 = *a4;
    }
    while (v17 < (a4[1] - *a4) >> 3);
    v12 = *a3;
    v15 = a3[1];
  }
  if (v15 == v12)
    std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
  v21 = MIL::IRDimension::AsConstant(*(MIL::IRDimension **)(v15 - 8));
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 48))(v21);
  v22 = a2 - 2;
  if ((a2 - 2) >= 0x10 || ((0xF79Du >> v22) & 1) == 0)
  {
    v50 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    MIL::IRDataTypeToString(a2, &v55);
    v51 = std::string::insert(&v55, 0, "Unsupported MIL IRDataType (");
    v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
    v56.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v52;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    v53 = std::string::append(&v56, ")");
    v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
    v57.__r_.__value_.__r.__words[2] = v53->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v54;
    v53->__r_.__value_.__l.__size_ = 0;
    v53->__r_.__value_.__r.__words[2] = 0;
    v53->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v50, &v57);
    __cxa_throw(v50, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  v23 = *a6;
  v24 = a6[1] - *a6;
  if (v24)
  {
    v25 = 0;
    v26 = 0;
    v27 = (a5 + qword_1E0AFF5D0[v22] * result - 1) / a5 * a5 / qword_1E0AFF5D0[v22];
    v28 = v24 >> 3;
    while (1)
    {
      v29 = v28 + v25;
      if (!v25)
        break;
      v30 = v27;
      if (v29 + 1 == v28)
        goto LABEL_22;
      v31 = (MIL::IRConstantProperty *)MIL::IRProperty::AsConstant(*(MIL::IRProperty **)(v23 + 8 * v29));
      Int64ScalarValue = MIL::IRConstantProperty::GetInt64ScalarValue(v31);
      v33 = (MIL::IRDimension *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*a3 + 8 * v29) + 16))(*(_QWORD *)(*a3 + 8 * v29));
      v34 = MIL::IRDimension::AsConstant(v33);
      v35 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v34 + 48))(v34);
      result = MIL::IRConstantProperty::MakeInt64Scalar(a1, (MIL::MILContext *)(v35 * Int64ScalarValue));
LABEL_23:
      *(_QWORD *)(*a6 + 8 * (v29 - 1)) = result;
      ++v26;
      v23 = *a6;
      v28 = (a6[1] - *a6) >> 3;
      --v25;
      if (v26 >= v28)
        return result;
    }
    v30 = 1;
LABEL_22:
    result = MIL::IRConstantProperty::MakeInt64Scalar(a1, (MIL::MILContext *)v30);
    goto LABEL_23;
  }
  return result;
}

void sub_1E0581D30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;
  int v30;
  void *v32;

  if (a28 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v30 & 1) == 0)
    {
LABEL_10:
      v32 = *(void **)v28;
      if (*(_QWORD *)v28)
      {
        *(_QWORD *)(v28 + 8) = v32;
        operator delete(v32);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v30)
  {
    goto LABEL_10;
  }
  __cxa_free_exception(v29);
  goto LABEL_10;
}

_QWORD *std::vector<MIL::IRProperty const*>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned long long>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1E0581E98(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("vector");
}

void MIL::IRObject::~IRObject(MIL::IRObject *this)
{
  char *v1;

  *(_QWORD *)this = off_1EA994088;
  v1 = (char *)this + 8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 24);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)v1);
}

_QWORD *MIL::IRObject::IRObject(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  void *exception;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[3];
  uint64_t v10;
  _QWORD v11[2];

  *a1 = off_1EA994088;
  *(_OWORD *)(a1 + 1) = *(_OWORD *)a2;
  v4 = a1 + 1;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)(a1 + 3), a3);
  if (!*v4)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    MIL::UnknownLocation::Make(&v10);
    v11[0] = v10;
    if (v10)
    {
      v7 = (_QWORD *)operator new();
      v8 = v10;
      *v7 = &unk_1EA9940C8;
      v7[1] = 0;
      v7[2] = 0;
      v7[3] = v8;
    }
    else
    {
      v7 = 0;
    }
    v11[1] = v7;
    v10 = 0;
    std::string::basic_string[abi:ne180100]<0>(v9, "Location must be non-null");
    MIL::InvalidArgumentError::InvalidArgumentError(exception, v11, v9);
  }
  return a1;
}

void sub_1E0582020(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;
  uint64_t v17;
  void *v18;

  if (a15)
    (*(void (**)(uint64_t))(*(_QWORD *)a15 + 8))(a15);
  __cxa_free_exception(v18);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v17);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v16);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRObject::Equals(MIL::IRObject *this, const MIL::IRObject *a2)
{
  unsigned __int8 *v4;
  uint64_t result;

  if (this == a2)
    return 1;
  if (*((_QWORD *)this + 6) != *((_QWORD *)a2 + 6))
    return 0;
  v4 = (unsigned __int8 *)this + 40;
  while (1)
  {
    v4 = *(unsigned __int8 **)v4;
    if (!v4)
      break;
    result = MIL::IRObject::TryGetAttribute((uint64_t)a2, v4 + 16);
    if (!result)
      return result;
    if (((*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)v4 + 5) + 16))(*((_QWORD *)v4 + 5), result) & 1) == 0)
      return 0;
  }
  return (*(uint64_t (**)(MIL::IRObject *, const MIL::IRObject *))(*(_QWORD *)this + 24))(this, a2);
}

uint64_t MIL::IRObject::GetAttributes(MIL::IRObject *this)
{
  return (uint64_t)this + 24;
}

uint64_t MIL::IRObject::TryGetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;

  v2 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 24), a2);
  if (!v2)
    return 0;
  v3 = *((_QWORD *)v2 + 5);
  v4 = (std::__shared_weak_count *)*((_QWORD *)v2 + 6);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

uint64_t MIL::IRObject::GetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result;
  void *exception;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  std::string *v11;
  __int128 v12;
  std::string v13;
  __int128 v14;
  std::string::size_type v15;
  _QWORD v16[2];

  result = MIL::IRObject::TryGetAttribute(a1, a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    v5 = a1;
    v6 = exception;
    v8 = *(_QWORD *)(v5 + 8);
    v7 = *(_QWORD *)(v5 + 16);
    v16[0] = v8;
    v16[1] = v7;
    if (v7)
    {
      v9 = (unint64_t *)(v7 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    std::operator+<char>();
    v11 = std::string::append(&v13, "' does not exist.");
    v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v15 = v11->__r_.__value_.__r.__words[2];
    v14 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    MIL::OutOfRangeError::OutOfRangeError(v6, v16, &v14);
  }
  return result;
}

void sub_1E05822AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  char v22;
  uint64_t v23;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v23 - 48);
  if ((v22 & 1) != 0)
    __cxa_free_exception(v21);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRObject::GetLocationPtr(MIL::IRObject *this)
{
  return (uint64_t)this + 8;
}

unsigned __int8 *MIL::IRObject::TryGetAttributeSharedPtr@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 24), a2);
  if (result)
  {
    v5 = *((_QWORD *)result + 6);
    *a3 = *((_QWORD *)result + 5);
    a3[1] = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

BOOL MIL::IRObject::RemoveAttribute(uint64_t a1, unsigned __int8 *a2)
{
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>((_QWORD *)(a1 + 24), a2) != 0;
}

BOOL MIL::IRObject::SetAttribute(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  char v3;

  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::insert_or_assign[abi:ne180100]<std::shared_ptr<MIL::IRValue const>>(a1 + 24, a2, a3);
  return v3 != 0;
}

unsigned __int8 *std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::insert_or_assign[abi:ne180100]<std::shared_ptr<MIL::IRValue const>>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  char v6;

  v4 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::string,std::shared_ptr<MIL::IRValue const>>(a1, a2, (uint64_t)a2, (uint64_t)a3);
  v5 = v4;
  if (!v6)
    std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]((uint64_t)(v4 + 40), a3);
  return v5;
}

void MIL::IRObject::SetAttributes(uint64_t a1, uint64_t *a2)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__move_assign(a1 + 24, a2);
}

uint64_t MIL::IRObject::GetLocation(MIL::IRObject *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t MIL::IRObject::SetLocation(uint64_t a1, __int128 *a2)
{
  void *exception;
  _QWORD *v4;
  uint64_t v5;
  _QWORD v6[3];
  uint64_t v7;
  _QWORD v8[2];

  if (!*(_QWORD *)a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    MIL::UnknownLocation::Make(&v7);
    v8[0] = v7;
    if (v7)
    {
      v4 = (_QWORD *)operator new();
      v5 = v7;
      *v4 = &unk_1EA9940C8;
      v4[1] = 0;
      v4[2] = 0;
      v4[3] = v5;
    }
    else
    {
      v4 = 0;
    }
    v8[1] = v4;
    v7 = 0;
    std::string::basic_string[abi:ne180100]<0>(v6, "Location must be non-null");
    MIL::InvalidArgumentError::InvalidArgumentError(exception, v8, v6);
  }
  return std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100](a1 + 8, a2);
}

void sub_1E05824E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  void *v16;

  if (a15)
    (*(void (**)(uint64_t))(*(_QWORD *)a15 + 8))(a15);
  __cxa_free_exception(v16);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = *a2;
  *a2 = 0;
  *(_QWORD *)result = v2;
  *(_QWORD *)(result + 8) = a2[1];
  a2[1] = 0;
  v5 = a2[2];
  v3 = a2 + 2;
  v4 = v5;
  *(_QWORD *)(result + 16) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 16;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void std::__shared_ptr_pointer<MIL::UnknownLocation  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::UnknownLocation  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::UnknownLocation  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  unsigned __int8 *result;
  _BYTE v4[24];

  result = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::remove(a1, result, (uint64_t)v4);
    std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v4, 0);
    return (unsigned __int8 *)1;
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::string,std::shared_ptr<MIL::IRValue const>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  char *v18;
  float v19;
  float v20;
  _BOOL8 v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;
  _QWORD *v25;
  unint64_t v26;
  _QWORD v28[2];
  char v29;

  v9 = (_QWORD *)(a1 + 24);
  v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  v18 = (char *)operator new(0x38uLL);
  v28[0] = v18;
  v28[1] = a1 + 16;
  *(_QWORD *)v18 = 0;
  *((_QWORD *)v18 + 1) = v11;
  *((_OWORD *)v18 + 1) = *(_OWORD *)a3;
  *((_QWORD *)v18 + 4) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_OWORD *)(v18 + 40) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  v29 = 1;
  v19 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v20 = *(float *)(a1 + 32);
  if (!v12 || (float)(v20 * (float)v12) < v19)
  {
    v21 = 1;
    if (v12 >= 3)
      v21 = (v12 & (v12 - 1)) != 0;
    v22 = v21 | (2 * v12);
    v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23)
      v24 = v23;
    else
      v24 = v22;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v24);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v25 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v25)
  {
    *(_QWORD *)v28[0] = *v25;
    *v25 = v28[0];
  }
  else
  {
    *(_QWORD *)v28[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v28[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v28[0])
    {
      v26 = *(_QWORD *)(*(_QWORD *)v28[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v26 >= v12)
          v26 %= v12;
      }
      else
      {
        v26 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v26) = v28[0];
    }
  }
  i = (unsigned __int8 *)v28[0];
  v28[0] = 0;
  ++*v9;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v28, 0);
  return i;
}

void sub_1E0582934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::clear(a1);
  v4 = *a2;
  *a2 = 0;
  v5 = *(void **)a1;
  *(_QWORD *)a1 = v4;
  if (v5)
    operator delete(v5);
  v8 = a2[2];
  v7 = a2 + 2;
  v6 = v8;
  v9 = *(v7 - 1);
  *(_QWORD *)(a1 + 16) = v8;
  *(_QWORD *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  v10 = v7[1];
  *(_QWORD *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    v11 = *(_QWORD *)(v6 + 8);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v11 %= v12;
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v11) = a1 + 16;
    *v7 = 0;
    v7[1] = 0;
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void MIL::IROperation::~IROperation(MIL::IROperation *this)
{
  MIL::IRValueQueryable::~IRValueQueryable((MIL::IROperation *)((char *)this + 64));
  MIL::IRObject::~IRObject(this);
}

_QWORD *MIL::IROperation::IROperation(_QWORD *a1, __int128 *a2, uint64_t *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v8;

  v8 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  MIL::IRObject::IRObject(a1, (uint64_t)&v8, a3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  MIL::IRValueQueryable::IRValueQueryable(a1 + 8);
  *a1 = off_1EA994128;
  a1[8] = &unk_1EA994238;
  return a1;
}

void sub_1E0582B08(_Unwind_Exception *a1)
{
  MIL::IRObject *v1;

  MIL::IRObject::~IRObject(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IROperation::GetArgumentName(MIL::IRObject *a1)
{
  uint64_t result;
  void *exception;
  MIL::IRObject *v4;
  void *v5;
  _QWORD *LocationPtr;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::string *v10;
  __int128 v11;
  std::string v12;
  __int128 v13;
  std::string::size_type v14;
  _QWORD v15[2];

  result = (*(uint64_t (**)(MIL::IRObject *))(*(_QWORD *)a1 + 120))(a1);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    v4 = a1;
    v5 = exception;
    LocationPtr = (_QWORD *)MIL::IRObject::GetLocationPtr(v4);
    v7 = LocationPtr[1];
    v15[0] = *LocationPtr;
    v15[1] = v7;
    if (v7)
    {
      v8 = (unint64_t *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    std::operator+<char>();
    v10 = std::string::append(&v12, " does not exist.");
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v14 = v10->__r_.__value_.__r.__words[2];
    v13 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    MIL::OutOfRangeError::OutOfRangeError(v5, v15, &v13);
  }
  return result;
}

void sub_1E0582C14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;
  uint64_t v23;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v23 - 48);
    if ((v22 & 1) == 0)
      goto LABEL_8;
  }
  else
  {
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v23 - 48);
    if (!v22)
LABEL_8:
      _Unwind_Resume(a1);
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t MIL::IROperation::GetArgumentValue(uint64_t a1)
{
  uint64_t result;
  std::logic_error *exception;
  std::string *v3;
  __int128 v4;
  std::string v5;
  std::string v6;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1);
  if (!result)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v3 = std::string::append(&v5, " does not exist.");
    v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    v6.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v6.__r_.__value_.__l.__data_ = v4;
    v3->__r_.__value_.__l.__size_ = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
    v3->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(exception, &v6);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  return result;
}

void sub_1E0582D50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t MIL::IROperation::TryGetParameterValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v8;
  std::__shared_weak_count *v9;

  MIL::IROperation::TryGetParameterValueSharedPtr(a1, a2, a3, &v8);
  v3 = v8;
  v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

void MIL::IROperation::TryGetParameterValueSharedPtr(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  (*(void (**)(uint64_t *__return_ptr))(*a1 + 136))(&v13);
  if (v13)
  {
    v8 = v14;
    *a4 = v13;
    a4[1] = (uint64_t)v8;
    a4 = &v13;
LABEL_3:
    *a4 = 0;
    a4[1] = 0;
    goto LABEL_6;
  }
  v9 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t))(*a1 + 120))(a1, a2, a3);
  if (!v9)
    goto LABEL_3;
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(a1[8] + 56))(a1 + 8, v9, 1);
LABEL_6:
  v10 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_1E0582EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IROperation::GetParameterValue(MIL::IRObject *a1)
{
  uint64_t v2;
  uint64_t ArgumentName;
  __int128 v4;
  std::string __p;

  v2 = (*(uint64_t (**)(MIL::IRObject *))(*(_QWORD *)a1 + 128))(a1);
  if (!v2)
  {
    ArgumentName = MIL::IROperation::GetArgumentName(a1);
    if (*(char *)(ArgumentName + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)ArgumentName, *(_QWORD *)(ArgumentName + 8));
    }
    else
    {
      v4 = *(_OWORD *)ArgumentName;
      __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(ArgumentName + 16);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v4;
    }
    v2 = (*(uint64_t (**)(_QWORD *, std::string *, uint64_t))(*((_QWORD *)a1 + 8) + 40))((_QWORD *)a1 + 8, &__p, 1);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v2;
}

void sub_1E0582FAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IROperation::TryGetParameterType(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t result;

  v6 = (*(uint64_t (**)(_QWORD *))(*a1 + 128))(a1);
  if (v6)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 32))(v6);
  result = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t))(*a1 + 120))(a1, a2, a3);
  if (result)
    return (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t))(a1[8] + 24))(a1 + 8, result, 1);
  return result;
}

uint64_t MIL::IROperation::GetParameterType(MIL::IRObject *a1)
{
  uint64_t v2;
  uint64_t ArgumentName;
  __int128 v5;
  uint64_t v6;
  std::string __p;

  v2 = (*(uint64_t (**)(MIL::IRObject *))(*(_QWORD *)a1 + 128))(a1);
  if (v2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 32))(v2);
  ArgumentName = MIL::IROperation::GetArgumentName(a1);
  if (*(char *)(ArgumentName + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)ArgumentName, *(_QWORD *)(ArgumentName + 8));
  }
  else
  {
    v5 = *(_OWORD *)ArgumentName;
    __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(ArgumentName + 16);
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v5;
  }
  v6 = (*(uint64_t (**)(_QWORD *, std::string *, uint64_t))(*((_QWORD *)a1 + 8) + 16))((_QWORD *)a1 + 8, &__p, 1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v6;
}

void sub_1E0583124(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IROperation::TryGetOutputType(MIL::IROperation *this, unint64_t a2)
{
  _QWORD **v3;
  uint64_t Type;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;

  v3 = (_QWORD **)(*(uint64_t (**)(MIL::IROperation *))(*(_QWORD *)this + 176))(this);
  v7 = 0;
  v8 = 0;
  v6 = 0;
  std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__init_with_size[abi:ne180100]<std::shared_ptr<MIL::IRNamedValueType>*,std::shared_ptr<MIL::IRNamedValueType>*>((char *)&v6, *v3, v3[1], ((char *)v3[1] - (char *)*v3) >> 4);
  Type = 0;
  if (a2 < (v7 - v6) >> 4)
    Type = MIL::IRNamedValueType::GetType(*(MIL::IRNamedValueType **)(v6 + 16 * a2));
  v9 = (void **)&v6;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v9);
  return Type;
}

void sub_1E05831CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t MIL::IROperation::GetOutputType(MIL::IROperation *this, unint64_t a2)
{
  uint64_t result;
  void *exception;
  _QWORD *LocationPtr;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  unint64_t v14;
  std::string *v15;
  std::string::size_type size;
  std::string *v17;
  __int128 v18;
  std::string *v19;
  __int128 v20;
  std::string v21;
  std::string v22;
  std::string v23;
  std::string v24;
  std::string v25;
  __int128 v26;
  std::string::size_type v27;
  _QWORD v28[2];

  result = MIL::IROperation::TryGetOutputType(this, a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    LocationPtr = (_QWORD *)MIL::IRObject::GetLocationPtr(this);
    v7 = LocationPtr[1];
    v28[0] = *LocationPtr;
    v28[1] = v7;
    if (v7)
    {
      v8 = (unint64_t *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    std::to_string(&v22, a2);
    v10 = std::string::insert(&v22, 0, "Output ");
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v23.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    v12 = std::string::append(&v23, " does not exist in a block with ");
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v24.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    v14 = (*(uint64_t (**)(MIL::IROperation *))(*(_QWORD *)this + 192))(this);
    std::to_string(&v21, v14);
    if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = &v21;
    else
      v15 = (std::string *)v21.__r_.__value_.__r.__words[0];
    if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v21.__r_.__value_.__r.__words[2]);
    else
      size = v21.__r_.__value_.__l.__size_;
    v17 = std::string::append(&v24, (const std::string::value_type *)v15, size);
    v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    v19 = std::string::append(&v25, " outputs.");
    v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v27 = v19->__r_.__value_.__r.__words[2];
    v26 = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    MIL::OutOfRangeError::OutOfRangeError(exception, v28, &v26);
  }
  return result;
}

void sub_1E0583364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  int v40;
  void *v41;
  uint64_t v42;

  if (*(char *)(v42 - 57) < 0)
    operator delete(*(void **)(v42 - 80));
  if (a40 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  if (a33 < 0)
    operator delete(a28);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
  {
    operator delete(a15);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v42 - 48);
    if ((v40 & 1) == 0)
      goto LABEL_16;
  }
  else
  {
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v42 - 48);
    if (!v40)
LABEL_16:
      _Unwind_Resume(a1);
  }
  __cxa_free_exception(v41);
  goto LABEL_16;
}

BOOL MIL::IROperation::IsParameterSet(uint64_t a1, const void **a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
  v5 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(v4, a2);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1) + 8 != v5;
}

_anonymous_namespace_::IROperationImpl **MIL::IROperation::Make@<X0>(__int128 *a1@<X0>, __int128 *a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t a6@<X5>, _anonymous_namespace_::IROperationImpl **a7@<X8>)
{
  _anonymous_namespace_::IROperationImpl *v8;
  _anonymous_namespace_::IROperationImpl *v10;

  v8 = v10;
  v10 = 0;
  *a7 = v8;
}

void std::make_unique[abi:ne180100]<`anonymous namespace'::IROperationImpl,std::shared_ptr<MIL::Location const>,std::shared_ptr<MIL::IROperator const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>,std::map<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::vector<std::shared_ptr<MIL::IRNamedValueType>>,std::vector<std::shared_ptr<MIL::IRBlock>>,decltype(nullptr)>(__int128 *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v14;
  __int128 v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  __int128 v22;
  __int128 v23;

  v14 = operator new();
  v15 = *a1;
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  v22 = *a2;
  v23 = v15;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  *a7 = v14;
  v16 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
  if (*((_QWORD *)&v22 + 1))
  {
    v17 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
  if (*((_QWORD *)&v23 + 1))
  {
    v20 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_1E0583620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  MEMORY[0x1E0C023A0](v11, 0x10E1C40E9C383C0);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::IROperationImpl **std::unique_ptr<`anonymous namespace'::IROperationImpl>::~unique_ptr[abi:ne180100](_anonymous_namespace_::IROperationImpl **a1)
{
  _anonymous_namespace_::IROperationImpl *v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    MEMORY[0x1E0C023A0]();
  }
  return a1;
}

_anonymous_namespace_::IROperationImpl **MIL::IROperation::Make@<X0>(__int128 *a1@<X0>, __int128 *a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, _anonymous_namespace_::IROperationImpl **a8@<X8>)
{
  _anonymous_namespace_::IROperationImpl *v16;
  __int128 v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  _anonymous_namespace_::IROperationImpl *v24;
  _anonymous_namespace_::IROperationImpl *v26;
  __int128 v27;
  __int128 v28;

  v16 = (_anonymous_namespace_::IROperationImpl *)operator new();
  v17 = *a1;
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  v27 = *a2;
  v28 = v17;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v26 = v16;
  v18 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
  if (*((_QWORD *)&v27 + 1))
  {
    v19 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = (std::__shared_weak_count *)*((_QWORD *)&v28 + 1);
  if (*((_QWORD *)&v28 + 1))
  {
    v22 = (unint64_t *)(*((_QWORD *)&v28 + 1) + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = v26;
  v26 = 0;
  *a8 = v24;
}

void sub_1E05837D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  uint64_t v12;
  std::__shared_weak_count **v13;

  if (a12)
    MIL::IROperation::Make(a12);
  MIL::IROperation::Make(v13);
  MEMORY[0x1E0C023A0](v12, 0x10E1C40E9C383C0);
  _Unwind_Resume(a1);
}

void MIL::IROperation::Make(__int128 *a1@<X0>, __int128 *a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t a6@<X5>, std::string::size_type *a7@<X8>)
{
  __int128 *v7;
  __int128 *v8;
  __int128 *v9;
  __int128 v10;
  void **v11;
  _QWORD *v12;
  void **v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  void ***v22;
  _QWORD *v23;
  _QWORD *v24;
  char *v25;
  __int128 v26;
  int64x2_t v27;
  uint64_t v28;
  void **v29;
  __int128 *v30;
  __int128 *v31;
  BOOL v32;
  std::string::size_type v33;
  __int128 *v40;
  std::string v41;
  _QWORD v42[3];
  void *__p[2];
  uint64_t v44;
  void **v45;
  void **v46;
  _QWORD *v47;
  int64x2_t v48;
  _QWORD v49[2];
  uint64_t *v50;
  _QWORD *v51[3];

  v51[0] = 0;
  v51[1] = 0;
  v50 = (uint64_t *)v51;
  v7 = (__int128 *)*a3;
  v40 = (__int128 *)(a3 + 1);
  if ((_QWORD *)*a3 != a3 + 1)
  {
    do
    {
      v48 = 0uLL;
      v49[0] = 0;
      v8 = (__int128 *)*((_QWORD *)v7 + 7);
      v9 = (__int128 *)*((_QWORD *)v7 + 8);
      while (v8 != v9)
      {
        v10 = *v8;
        v44 = *((_QWORD *)v8 + 2);
        *(_OWORD *)__p = v10;
        *((_QWORD *)v8 + 1) = 0;
        *((_QWORD *)v8 + 2) = 0;
        *(_QWORD *)v8 = 0;
        MIL::IRArgument::Make((uint64_t)__p, (uint64_t *)&v45);
        v11 = v45;
        v46 = v45;
        if (v45)
        {
          v12 = (_QWORD *)operator new();
          v13 = v45;
          *v12 = &unk_1EA9942C8;
          v12[1] = 0;
          v12[2] = 0;
          v12[3] = v13;
        }
        else
        {
          v12 = 0;
        }
        v47 = v12;
        v45 = 0;
        v14 = v48.i64[1];
        if (v48.i64[1] >= v49[0])
        {
          v16 = (v48.i64[1] - v48.i64[0]) >> 4;
          v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 60)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v18 = v49[0] - v48.i64[0];
          if ((v49[0] - v48.i64[0]) >> 3 > v17)
            v17 = v18 >> 3;
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0)
            v19 = 0xFFFFFFFFFFFFFFFLL;
          else
            v19 = v17;
          v42[1] = v49;
          v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)v49, v19);
          v22 = (void ***)&v20[16 * v16];
          *v22 = v11;
          v22[1] = (void **)v12;
          v46 = 0;
          v47 = 0;
          v23 = (_QWORD *)v48.i64[1];
          v24 = (_QWORD *)v48.i64[0];
          if (v48.i64[1] == v48.i64[0])
          {
            v27 = vdupq_n_s64(v48.u64[1]);
            v25 = &v20[16 * v16];
          }
          else
          {
            v25 = &v20[16 * v16];
            do
            {
              v26 = *((_OWORD *)v23 - 1);
              v23 -= 2;
              *((_OWORD *)v25 - 1) = v26;
              v25 -= 16;
              *v23 = 0;
              v23[1] = 0;
            }
            while (v23 != v24);
            v27 = v48;
          }
          v15 = v22 + 2;
          v48.i64[0] = (uint64_t)v25;
          v48.i64[1] = (uint64_t)(v22 + 2);
          *(int64x2_t *)&v41.__r_.__value_.__r.__words[1] = v27;
          v28 = v49[0];
          v49[0] = &v20[16 * v21];
          v42[0] = v28;
          v41.__r_.__value_.__r.__words[0] = v27.i64[0];
          std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v41);
        }
        else
        {
          *(_QWORD *)v48.i64[1] = v11;
          *(_QWORD *)(v14 + 8) = v12;
          v15 = (_QWORD *)(v14 + 16);
        }
        v48.i64[1] = (uint64_t)v15;
        v29 = v45;
        v45 = 0;
        if (v29)
          (*((void (**)(void **))*v29 + 1))(v29);
        if (SHIBYTE(v44) < 0)
          operator delete(__p[0]);
        v8 = (__int128 *)((char *)v8 + 24);
      }
      std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>::pair[abi:ne180100]<std::string const&,std::vector<std::shared_ptr<MIL::IRArgument>>,0>(&v41, v7 + 2, (uint64_t)&v48);
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>>(&v50, (const void **)&v41.__r_.__value_.__l.__data_, (__int128 *)&v41);
      v46 = (void **)v42;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v46);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
      v41.__r_.__value_.__r.__words[0] = (std::string::size_type)&v48;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v41);
      v30 = (__int128 *)*((_QWORD *)v7 + 1);
      if (v30)
      {
        do
        {
          v31 = v30;
          v30 = *(__int128 **)v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          v31 = (__int128 *)*((_QWORD *)v7 + 2);
          v32 = *(_QWORD *)v31 == (_QWORD)v7;
          v7 = v31;
        }
        while (!v32);
      }
      v7 = v31;
    }
    while (v31 != v40);
  }
  v33 = v41.__r_.__value_.__r.__words[0];
  v41.__r_.__value_.__r.__words[0] = 0;
  *a7 = v33;
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v50, v51[0]);
}

void sub_1E0583AE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30)
{
  uint64_t v30;

  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(v30 - 112, *(_QWORD **)(v30 - 104));
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>::~pair(uint64_t a1)
{
  void **v3;

  v3 = (void **)(a1 + 24);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

const MIL::Text::SerializerOptions *MIL::IROperation::ToString(MIL::IROperation *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  const MIL::Text::SerializerOptions *result;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  _BYTE v10[392];
  const MIL::Text::SerializerOptions *v11;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v11);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v11 + 112))(v11, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v10, v11);
  v8 = 0;
  v9 = 0;
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Op((uint64_t)v10, this, &v8);
  MIL::Text::BasicSerializer::GetOutput(v3);
  v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v10);
  result = v11;
  v11 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E0583C84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;
  uint64_t v13;

  v13 = *(_QWORD *)(v11 - 40);
  *(_QWORD *)(v11 - 40) = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  _Unwind_Resume(exception_object);
}

std::string *std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>::pair[abi:ne180100]<std::string const&,std::vector<std::shared_ptr<MIL::IRArgument>>,0>(std::string *this, __int128 *a2, uint64_t a3)
{
  __int128 v5;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = *(_OWORD *)a3;
  this[1].__r_.__value_.__r.__words[2] = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  return this;
}

void std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>,0>(uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 24);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::__shared_ptr_pointer<MIL::IRArgument  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::IRArgument  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IRArgument  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

void `anonymous namespace'::IROperationImpl::~IROperationImpl(_anonymous_namespace_::IROperationImpl *this)
{
  uint64_t v2;
  void **v3;

  v2 = *((_QWORD *)this + 21);
  *((_QWORD *)this + 21) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0x60C4044C4A2DFLL);
  v3 = (void **)((char *)this + 144);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 120);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)this + 96, *((_QWORD **)this + 13));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 80);
  MIL::IRValueQueryable::~IRValueQueryable((_anonymous_namespace_::IROperationImpl *)((char *)this + 64));
  MIL::IRObject::~IRObject(this);
}

{
  JUMPOUT(0x1E0C023A0);
}

void `non-virtual thunk to'`anonymous namespace'::IROperationImpl::~IROperationImpl(_anonymous_namespace_::IROperationImpl *this)
{
}

{
  JUMPOUT(0x1E0C023A0);
}

uint64_t `anonymous namespace'::IROperationImpl::IROperationImpl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v26;

  v26 = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  MIL::IROperation::IROperation((_QWORD *)a1, &v26, a4);
  v14 = (std::__shared_weak_count *)*((_QWORD *)&v26 + 1);
  if (*((_QWORD *)&v26 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  *(_QWORD *)a1 = &off_1EA994328;
  *(_QWORD *)(a1 + 64) = &unk_1EA994470;
  *(_QWORD *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)a3;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 96) = *a5;
  v17 = a5 + 1;
  v18 = a5[1];
  *(_QWORD *)(a1 + 104) = v18;
  v19 = a1 + 104;
  v20 = a5[2];
  *(_QWORD *)(a1 + 112) = v20;
  if (v20)
  {
    *(_QWORD *)(v18 + 16) = v19;
    *a5 = v17;
    *v17 = 0;
    a5[2] = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 96) = v19;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 120) = *(_OWORD *)a6;
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a6 + 16);
  *(_QWORD *)a6 = 0;
  *(_QWORD *)(a6 + 8) = 0;
  *(_QWORD *)(a6 + 16) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = a8;
  v21 = *(_QWORD **)(a1 + 144);
  v22 = *(_QWORD **)(a1 + 152);
  if (v21 != v22)
  {
    v23 = *(_QWORD *)(a1 + 72);
    if (v23)
      v24 = v23 + 64;
    else
      v24 = 0;
    do
    {
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v21 + 104))(*v21, v24);
      v21 += 2;
    }
    while (v21 != v22);
  }
  return a1;
}

void sub_1E058406C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12)
{
  unint64_t *p_shared_owners;
  unint64_t v14;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::IROperationImpl::SetBlocks(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a1 + 144;
  std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vdeallocate((void **)(a1 + 144));
  *(_OWORD *)(a1 + 144) = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v5 = (_QWORD *)operator new();
  *v5 = v4;
  result = *(_QWORD *)(a1 + 168);
  *(_QWORD *)(a1 + 168) = v5;
  if (result)
    result = MEMORY[0x1E0C023A0](result, 0x60C4044C4A2DFLL);
  v7 = *(uint64_t **)(a1 + 144);
  v8 = *(uint64_t **)(a1 + 152);
  while (v7 != v8)
  {
    v10 = *v7;
    v7 += 2;
    v9 = v10;
    v11 = *(_QWORD *)(a1 + 72);
    if (v11)
      v12 = v11 + 64;
    else
      v12 = 0;
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 104))(v9, v12);
  }
  return result;
}

_QWORD *`anonymous namespace'::IROperationImpl::SetParent(_QWORD *this, const MIL::IRBlock *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  char *v4;
  uint64_t v5;

  this[9] = a2;
  v2 = (uint64_t *)this[18];
  v3 = (uint64_t *)this[19];
  if (v2 != v3)
  {
    if (a2)
      v4 = (char *)a2 + 64;
    else
      v4 = 0;
    do
    {
      v5 = *v2;
      v2 += 2;
      this = (_QWORD *)(*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v5 + 104))(v5, v4);
    }
    while (v2 != v3);
  }
  return this;
}

void `anonymous namespace'::IROperationImpl::PopulateDefaultValues(_anonymous_namespace_::IROperationImpl *this)
{
  uint64_t v2;
  uint64_t v3;
  const void **i;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  __int128 v14;
  uint64_t v15;
  __int128 *v16;
  uint64_t v17[2];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 72))(v2);
    if (v3)
    {
      for (i = *(const void ***)(v3 + 16); i; i = (const void **)*i)
      {
        v5 = (*(uint64_t (**)(_anonymous_namespace_::IROperationImpl *))(*(_QWORD *)this + 160))(this);
        v6 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(v5, i + 2);
        if ((*(uint64_t (**)(_anonymous_namespace_::IROperationImpl *))(*(_QWORD *)this + 160))(this) + 8 == v6
          && (*(unsigned int (**)(const void *))(*(_QWORD *)i[5] + 80))(i[5]))
        {
          (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)i[5] + 104))(&v14);
          MIL::IRArgument::Make(&v14, &v15);
          v17[0] = v15;
          if (v15)
          {
            v7 = (_QWORD *)operator new();
            v8 = v15;
            *v7 = &unk_1EA9942C8;
            v7[1] = 0;
            v7[2] = 0;
            v7[3] = v8;
          }
          else
          {
            v7 = 0;
          }
          v17[1] = (uint64_t)v7;
          v15 = 0;
          v16 = (__int128 *)(i + 2);
          v9 = std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)this + 12, i + 2, (uint64_t)&std::piecewise_construct, &v16);
          std::vector<std::shared_ptr<MIL::IRArgument>>::__assign_with_size[abi:ne180100]<std::shared_ptr<MIL::IRArgument> const*,std::shared_ptr<MIL::IRArgument> const*>((uint64_t)(v9 + 7), v17, &v18, 1uLL);
          std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)v17);
          v10 = v15;
          v15 = 0;
          if (v10)
            (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
          v11 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
          if (*((_QWORD *)&v14 + 1))
          {
            v12 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
            do
              v13 = __ldaxr(v12);
            while (__stlxr(v13 - 1, v12));
            if (!v13)
            {
              ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
              std::__shared_weak_count::__release_weak(v11);
            }
          }
        }
      }
    }
  }
}

void sub_1E0584414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v12;

  v12 = a11;
  a11 = 0;
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL `anonymous namespace'::IROperationImpl::EqualsImpl(_anonymous_namespace_::IROperationImpl **this, const MIL::IRObject *a2)
{
  const MIL::IRObject *v2;
  unsigned __int8 *OperatorName;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned __int8 *v11;
  _anonymous_namespace_::IROperationImpl *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _anonymous_namespace_::IROperationImpl *v19;
  _anonymous_namespace_::IROperationImpl *v20;
  BOOL v21;
  _anonymous_namespace_::IROperationImpl *v22;
  _anonymous_namespace_::IROperationImpl *v23;
  uint64_t v24;
  unint64_t v25;
  _anonymous_namespace_::IROperationImpl *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;

  if (*(void (***)(_anonymous_namespace_::IROperationImpl *__hidden))a2 == &off_1EA994328)
    v2 = a2;
  else
    v2 = 0;
  if (*(void (***)(_anonymous_namespace_::IROperationImpl *__hidden))a2 != &off_1EA994328)
    return 0;
  v7 = OperatorName[23];
  if ((v7 & 0x80u) == 0)
    v8 = OperatorName[23];
  else
    v8 = *((_QWORD *)OperatorName + 1);
  v9 = *(unsigned __int8 *)(v6 + 23);
  v10 = (char)v9;
  if ((v9 & 0x80u) != 0)
    v9 = *(_QWORD *)(v6 + 8);
  if (v8 != v9)
    return 0;
  if (v10 >= 0)
    v11 = (unsigned __int8 *)v6;
  else
    v11 = *(unsigned __int8 **)v6;
  if ((v7 & 0x80) != 0)
  {
    if (memcmp(*(const void **)OperatorName, v11, *((_QWORD *)OperatorName + 1)))
      return 0;
  }
  else if (OperatorName[23])
  {
    while (*OperatorName == *v11)
    {
      ++OperatorName;
      ++v11;
      if (!--v7)
        goto LABEL_20;
    }
    return 0;
  }
LABEL_20:
  if (this[14] == *((_anonymous_namespace_::IROperationImpl **)v2 + 14))
  {
    v12 = this[12];
    if (v12 == (_anonymous_namespace_::IROperationImpl *)(this + 13))
    {
LABEL_34:
      v22 = this[15];
      v23 = this[16];
      if (v23 - v22 == *((_QWORD *)v2 + 16) - *((_QWORD *)v2 + 15))
      {
        if (v23 == v22)
        {
LABEL_39:
          v26 = this[21];
          v27 = *((_QWORD *)v2 + 21);
          v28 = **(_QWORD **)v26;
          v29 = *(_QWORD *)(*(_QWORD *)v26 + 8);
          if (v29 - v28 == *(_QWORD *)(*(_QWORD *)v27 + 8) - **(_QWORD **)v27)
          {
            if (v29 == v28)
              return this[22] == *((_anonymous_namespace_::IROperationImpl **)v2 + 22);
            v30 = 0;
            v31 = 0;
            while ((MIL::IRObject::Equals(*(MIL::IRObject **)(v28 + v30), *(const MIL::IRObject **)(**(_QWORD **)v27 + v30)) & 1) != 0)
            {
              ++v31;
              v28 = **(_QWORD **)v26;
              v30 += 16;
              if (v31 >= (*(_QWORD *)(*(_QWORD *)v26 + 8) - v28) >> 4)
                return this[22] == *((_anonymous_namespace_::IROperationImpl **)v2 + 22);
            }
          }
        }
        else
        {
          v24 = 0;
          v25 = 0;
          while (MIL::IRNamedValueType::Equals(*(MIL::IRNamedValueType **)((char *)v22 + v24), *(const MIL::IRNamedValueType **)(*((_QWORD *)v2 + 15) + v24)))
          {
            ++v25;
            v22 = this[15];
            v24 += 16;
            if (v25 >= (this[16] - v22) >> 4)
              goto LABEL_39;
          }
        }
      }
    }
    else
    {
      while (1)
      {
        v13 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>((uint64_t)v2 + 96, (const void **)v12 + 4);
        if ((const MIL::IRObject *)((char *)v2 + 104) == (const MIL::IRObject *)v13)
          break;
        v14 = v13;
        v15 = *((_QWORD *)v12 + 7);
        v16 = *((_QWORD *)v12 + 8);
        if (v16 - v15 != *(_QWORD *)(v13 + 64) - *(_QWORD *)(v13 + 56))
          break;
        if (v16 != v15)
        {
          v17 = 0;
          v18 = 0;
          while (((*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v15 + v17) + 56))(*(_QWORD *)(v15 + v17), *(_QWORD *)(*(_QWORD *)(v14 + 56) + v17)) & 1) != 0)
          {
            ++v18;
            v15 = *((_QWORD *)v12 + 7);
            v17 += 16;
            if (v18 >= (*((_QWORD *)v12 + 8) - v15) >> 4)
              goto LABEL_28;
          }
          return 0;
        }
LABEL_28:
        v19 = (_anonymous_namespace_::IROperationImpl *)*((_QWORD *)v12 + 1);
        if (v19)
        {
          do
          {
            v20 = v19;
            v19 = *(_anonymous_namespace_::IROperationImpl **)v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            v20 = (_anonymous_namespace_::IROperationImpl *)*((_QWORD *)v12 + 2);
            v21 = *(_QWORD *)v20 == (_QWORD)v12;
            v12 = v20;
          }
          while (!v21);
        }
        v12 = v20;
        if (v20 == (_anonymous_namespace_::IROperationImpl *)(this + 13))
          goto LABEL_34;
      }
    }
  }
  return 0;
}

void `anonymous namespace'::IROperationImpl::Copy(_anonymous_namespace_::IROperationImpl *this@<X0>, MIL::IRNamedValueType **a2@<X8>)
{
  uint64_t v2[3];
  void **v3;

  memset(v2, 0, sizeof(v2));
  v3 = (void **)v2;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void sub_1E058474C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::IROperationImpl **`anonymous namespace'::IROperationImpl::WithBlocks@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _anonymous_namespace_::IROperationImpl **a3@<X8>)
{
  uint64_t *LocationPtr;
  uint64_t Attributes;
  _anonymous_namespace_::IROperationImpl *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD v14[3];
  uint64_t v15[3];
  uint64_t v16[5];
  _anonymous_namespace_::IROperationImpl *v17;
  void **v18;

  LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a1);
  Attributes = MIL::IRObject::GetAttributes((MIL::IRObject *)a1);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v16, Attributes);
  std::map<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>::map[abi:ne180100](v15, (const void ***)(a1 + 96));
  memset(v14, 0, sizeof(v14));
  std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__init_with_size[abi:ne180100]<std::shared_ptr<MIL::IRNamedValueType>*,std::shared_ptr<MIL::IRNamedValueType>*>((char *)v14, *(_QWORD **)(a1 + 120), *(_QWORD **)(a1 + 128), (uint64_t)(*(_QWORD *)(a1 + 128) - *(_QWORD *)(a1 + 120)) >> 4);
  v18 = (void **)v14;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v18);
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)v15, (_QWORD *)v15[1]);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v16);
  v8 = v17;
  v9 = *(_QWORD *)(a1 + 72);
  *((_QWORD *)v17 + 9) = v9;
  v10 = (_QWORD *)*((_QWORD *)v8 + 18);
  v11 = (_QWORD *)*((_QWORD *)v8 + 19);
  if (v10 != v11)
  {
    if (v9)
      v12 = v9 + 64;
    else
      v12 = 0;
    do
    {
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v10 + 104))(*v10, v12);
      v10 += 2;
    }
    while (v10 != v11);
    v8 = v17;
  }
  v17 = 0;
  *a3 = v8;
}

void sub_1E0584888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  va_list va;
  _QWORD *v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD *);
  v11 = va_arg(va1, _QWORD);
  *(_QWORD *)(v6 - 56) = v5;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v6 - 56));
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)va, v10);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va1);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::IROperationImpl::WithRenames(uint64_t *a1@<X0>, uint64_t *a2@<X1>, MIL::IRNamedValueType **a3@<X8>)
{
  uint64_t *v3;
  MIL::IRArgument **i;
  MIL::IRArgument **v5;
  uint64_t *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t Name;
  __int128 v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  _QWORD *v27;
  _QWORD *v28;
  char *v29;
  __int128 v30;
  int64x2_t v31;
  unint64_t v32;
  uint64_t *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  uint64_t v41;
  char *v42;
  _QWORD *v43;
  _QWORD *v44;
  char *v45;
  __int128 v46;
  int64x2_t v47;
  uint64_t v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t *v56;
  BOOL v57;
  uint64_t *v58;
  MIL::IRArgument **v59;
  MIL::IRArgument **v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  unsigned __int8 *v68;
  uint64_t v69;
  __int128 *v70;
  uint64_t *v71;
  uint64_t *v72;
  MIL::IRNamedValueType **v73;
  MIL::IRNamedValueType **j;
  uint64_t v75;
  __int128 v76;
  uint64_t Type;
  MIL::IRNamedValueType *v78;
  MIL::IRNamedValueType *v79;
  MIL::IRNamedValueType *v80;
  uint64_t v81;
  _QWORD *v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  char *v87;
  uint64_t v88;
  MIL::IRNamedValueType **v89;
  _QWORD *v90;
  _QWORD *v91;
  char *v92;
  __int128 v93;
  int64x2_t v94;
  uint64_t v95;
  void **v96;
  uint64_t v97;
  uint64_t v98;
  MIL::IRNamedValueType **v99;
  MIL::IRNamedValueType **v100;
  unsigned __int8 *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  unsigned __int8 *v106;
  MIL::IRNamedValueType *v107;
  _QWORD *v108;
  _QWORD *k;
  MIL::IRNamedValueType *v110;
  _QWORD *v111;
  MIL::IRNamedValueType *v112;
  uint64_t v113;
  _QWORD *v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  char *v119;
  uint64_t v120;
  MIL::IRNamedValueType **v121;
  _QWORD *v122;
  _QWORD *v123;
  char *v124;
  __int128 v125;
  int64x2_t v126;
  uint64_t v127;
  MIL::IRNamedValueType *v128;
  uint64_t *LocationPtr;
  uint64_t Attributes;
  MIL::IRNamedValueType *v131;
  uint64_t v132;
  _QWORD *v133;
  _QWORD *v134;
  uint64_t v135;
  uint64_t *v138;
  MIL::IRNamedValueType *v140;
  MIL::IRNamedValueType *v141;
  _QWORD *v142;
  int64x2_t v143;
  _QWORD v144[2];
  std::string v145;
  std::string v146;
  int64x2_t v147;
  _QWORD v148[2];
  std::string v149;
  std::string v150;
  __int128 v151;
  uint64_t *v152;
  _QWORD *v153[2];
  int64x2_t *v154;
  int64x2_t v155;
  uint64_t v156;
  _QWORD *v157;

  v153[0] = 0;
  v153[1] = 0;
  v152 = (uint64_t *)v153;
  v3 = (uint64_t *)a1[12];
  v138 = a1 + 13;
  if (v3 != a1 + 13)
  {
    do
    {
      v5 = (MIL::IRArgument **)v3[7];
      for (i = (MIL::IRArgument **)v3[8]; v5 != i; v5 += 2)
      {
        if ((*(unsigned int (**)(MIL::IRArgument *))(*(_QWORD *)*v5 + 24))(*v5))
        {
          v154 = (int64x2_t *)(v3 + 4);
          v6 = std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(&v152, (const void **)v3 + 4, (uint64_t)&std::piecewise_construct, (__int128 **)&v154);
          (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)*v5 + 48))(&v151);
          MIL::IRArgument::Make(&v151, v143.i64);
          v7 = v143.i64[0];
          v147.i64[0] = v143.i64[0];
          if (v143.i64[0])
          {
            v8 = (_QWORD *)operator new();
            v9 = v143.i64[0];
            *v8 = &unk_1EA9942C8;
            v8[1] = 0;
            v8[2] = 0;
            v8[3] = v9;
          }
          else
          {
            v8 = 0;
          }
          v147.i64[1] = (uint64_t)v8;
          v143.i64[0] = 0;
          v16 = v6[9];
          v17 = (uint64_t *)v6[8];
          if ((unint64_t)v17 >= v16)
          {
            v19 = v6[7];
            v20 = ((uint64_t)v17 - v19) >> 4;
            v21 = v20 + 1;
            if ((unint64_t)(v20 + 1) >> 60)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v22 = v16 - v19;
            if (v22 >> 3 > v21)
              v21 = v22 >> 3;
            if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0)
              v23 = 0xFFFFFFFFFFFFFFFLL;
            else
              v23 = v21;
            v157 = v6 + 9;
            v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)(v6 + 9), v23);
            v26 = &v24[16 * v20];
            *(_QWORD *)v26 = v7;
            *((_QWORD *)v26 + 1) = v8;
            v147 = 0uLL;
            v28 = (_QWORD *)v6[7];
            v27 = (_QWORD *)v6[8];
            if (v27 == v28)
            {
              v31 = vdupq_n_s64((unint64_t)v27);
              v29 = &v24[16 * v20];
            }
            else
            {
              v29 = &v24[16 * v20];
              do
              {
                v30 = *((_OWORD *)v27 - 1);
                v27 -= 2;
                *((_OWORD *)v29 - 1) = v30;
                v29 -= 16;
                *v27 = 0;
                v27[1] = 0;
              }
              while (v27 != v28);
              v31 = *(int64x2_t *)(v6 + 7);
            }
            v18 = v26 + 16;
            v6[7] = (uint64_t)v29;
            v6[8] = (uint64_t)(v26 + 16);
            v155 = v31;
            v48 = v6[9];
            v6[9] = (uint64_t)&v24[16 * v25];
            v156 = v48;
            v154 = (int64x2_t *)v31.i64[0];
            std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v154);
          }
          else
          {
            *v17 = v7;
            v17[1] = (uint64_t)v8;
            v18 = v17 + 2;
            v147 = 0uLL;
          }
          v6[8] = (uint64_t)v18;
          v49 = v143.i64[0];
          v143.i64[0] = 0;
          if (v49)
            (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
          v50 = (std::__shared_weak_count *)*((_QWORD *)&v151 + 1);
          if (*((_QWORD *)&v151 + 1))
          {
            v51 = (unint64_t *)(*((_QWORD *)&v151 + 1) + 8);
            do
              v52 = __ldaxr(v51);
            while (__stlxr(v52 - 1, v51));
            if (!v52)
            {
              ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
              std::__shared_weak_count::__release_weak(v50);
            }
          }
        }
        else
        {
          v154 = (int64x2_t *)(v3 + 4);
          v10 = std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(&v152, (const void **)v3 + 4, (uint64_t)&std::piecewise_construct, (__int128 **)&v154);
          Name = MIL::IRArgument::GetName(*v5);
          if (*(char *)(Name + 23) < 0)
          {
            std::string::__init_copy_ctor_external(&v150, *(const std::string::value_type **)Name, *(_QWORD *)(Name + 8));
          }
          else
          {
            v12 = *(_OWORD *)Name;
            v150.__r_.__value_.__r.__words[2] = *(_QWORD *)(Name + 16);
            *(_OWORD *)&v150.__r_.__value_.__l.__data_ = v12;
          }
          MIL::IRArgument::Make((uint64_t)&v150, v143.i64);
          v13 = v143.i64[0];
          v147.i64[0] = v143.i64[0];
          if (v143.i64[0])
          {
            v14 = (_QWORD *)operator new();
            v15 = v143.i64[0];
            *v14 = &unk_1EA9942C8;
            v14[1] = 0;
            v14[2] = 0;
            v14[3] = v15;
          }
          else
          {
            v14 = 0;
          }
          v147.i64[1] = (uint64_t)v14;
          v143.i64[0] = 0;
          v32 = v10[9];
          v33 = (uint64_t *)v10[8];
          if ((unint64_t)v33 >= v32)
          {
            v35 = v10[7];
            v36 = ((uint64_t)v33 - v35) >> 4;
            v37 = v36 + 1;
            if ((unint64_t)(v36 + 1) >> 60)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v38 = v32 - v35;
            if (v38 >> 3 > v37)
              v37 = v38 >> 3;
            if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF0)
              v39 = 0xFFFFFFFFFFFFFFFLL;
            else
              v39 = v37;
            v157 = v10 + 9;
            v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)(v10 + 9), v39);
            v42 = &v40[16 * v36];
            *(_QWORD *)v42 = v13;
            *((_QWORD *)v42 + 1) = v14;
            v147 = 0uLL;
            v44 = (_QWORD *)v10[7];
            v43 = (_QWORD *)v10[8];
            if (v43 == v44)
            {
              v47 = vdupq_n_s64((unint64_t)v43);
              v45 = &v40[16 * v36];
            }
            else
            {
              v45 = &v40[16 * v36];
              do
              {
                v46 = *((_OWORD *)v43 - 1);
                v43 -= 2;
                *((_OWORD *)v45 - 1) = v46;
                v45 -= 16;
                *v43 = 0;
                v43[1] = 0;
              }
              while (v43 != v44);
              v47 = *(int64x2_t *)(v10 + 7);
            }
            v34 = v42 + 16;
            v10[7] = (uint64_t)v45;
            v10[8] = (uint64_t)(v42 + 16);
            v155 = v47;
            v53 = v10[9];
            v10[9] = (uint64_t)&v40[16 * v41];
            v156 = v53;
            v154 = (int64x2_t *)v47.i64[0];
            std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v154);
          }
          else
          {
            *v33 = v13;
            v33[1] = (uint64_t)v14;
            v34 = v33 + 2;
          }
          v10[8] = (uint64_t)v34;
          v54 = v143.i64[0];
          v143.i64[0] = 0;
          if (v54)
            (*(void (**)(uint64_t))(*(_QWORD *)v54 + 8))(v54);
          if (SHIBYTE(v150.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v150.__r_.__value_.__l.__data_);
        }
      }
      v55 = (uint64_t *)v3[1];
      if (v55)
      {
        do
        {
          v56 = v55;
          v55 = (uint64_t *)*v55;
        }
        while (v55);
      }
      else
      {
        do
        {
          v56 = (uint64_t *)v3[2];
          v57 = *v56 == (_QWORD)v3;
          v3 = v56;
        }
        while (!v57);
      }
      v3 = v56;
    }
    while (v56 != v138);
    v58 = v152;
    if (v152 != (uint64_t *)v153)
    {
      do
      {
        v60 = (MIL::IRArgument **)v58[7];
        v59 = (MIL::IRArgument **)v58[8];
        while (v60 != v59)
        {
          if (((*(uint64_t (**)(MIL::IRArgument *))(*(_QWORD *)*v60 + 24))(*v60) & 1) == 0)
          {
            v61 = *a2;
            v62 = a2[1];
            while (v61 != v62)
            {
              v63 = MIL::IRArgument::GetName(*v60);
              v64 = *(unsigned __int8 *)(v61 + 23);
              if ((v64 & 0x80u) == 0)
                v65 = *(unsigned __int8 *)(v61 + 23);
              else
                v65 = *(_QWORD *)(v61 + 8);
              v66 = *(unsigned __int8 *)(v63 + 23);
              v67 = (char)v66;
              if ((v66 & 0x80u) != 0)
                v66 = *(_QWORD *)(v63 + 8);
              if (v65 == v66)
              {
                if (v67 >= 0)
                  v68 = (unsigned __int8 *)v63;
                else
                  v68 = *(unsigned __int8 **)v63;
                if ((v64 & 0x80) != 0)
                {
                  if (!memcmp(*(const void **)v61, v68, *(_QWORD *)(v61 + 8)))
                  {
LABEL_82:
                    if (*(char *)(v61 + 47) < 0)
                      std::string::__init_copy_ctor_external(&v149, *(const std::string::value_type **)(v61 + 24), *(_QWORD *)(v61 + 32));
                    else
                      v149 = *(std::string *)(v61 + 24);
                    MIL::IRArgument::Make((uint64_t)&v149, (uint64_t *)&v154);
                    std::shared_ptr<MIL::IRArgument>::operator=[abi:ne180100]<MIL::IRArgument,std::default_delete<MIL::IRArgument>,void>(v60, (uint64_t *)&v154);
                    v70 = (__int128 *)v154;
                    v154 = 0;
                    if (v70)
                      (*(void (**)(__int128 *))(*(_QWORD *)v70 + 8))(v70);
                    if (SHIBYTE(v149.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v149.__r_.__value_.__l.__data_);
                    break;
                  }
                }
                else
                {
                  if (!*(_BYTE *)(v61 + 23))
                    goto LABEL_82;
                  v69 = 0;
                  while (*(unsigned __int8 *)(v61 + v69) == v68[v69])
                  {
                    if (v64 == ++v69)
                      goto LABEL_82;
                  }
                }
              }
              v61 += 48;
            }
          }
          v60 += 2;
        }
        v71 = (uint64_t *)v58[1];
        if (v71)
        {
          do
          {
            v72 = v71;
            v71 = (uint64_t *)*v71;
          }
          while (v71);
        }
        else
        {
          do
          {
            v72 = (uint64_t *)v58[2];
            v57 = *v72 == (_QWORD)v58;
            v58 = v72;
          }
          while (!v57);
        }
        v58 = v72;
      }
      while (v72 != (uint64_t *)v153);
    }
  }
  v147 = 0uLL;
  v148[0] = 0;
  std::vector<std::shared_ptr<MIL::IROperation>>::reserve((char **)&v147, (a1[16] - a1[15]) >> 4);
  v73 = (MIL::IRNamedValueType **)a1[15];
  for (j = (MIL::IRNamedValueType **)a1[16]; v73 != j; v73 += 2)
  {
    v75 = MIL::IRNamedValueType::GetName(*v73);
    if (*(char *)(v75 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v146, *(const std::string::value_type **)v75, *(_QWORD *)(v75 + 8));
    }
    else
    {
      v76 = *(_OWORD *)v75;
      v146.__r_.__value_.__r.__words[2] = *(_QWORD *)(v75 + 16);
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v76;
    }
    Type = MIL::IRNamedValueType::GetType(*v73);
    MIL::IRNamedValueType::Make((uint64_t *)&v146, Type, (uint64_t *)&v141);
    v78 = v141;
    v143.i64[0] = (uint64_t)v141;
    if (v141)
    {
      v79 = (MIL::IRNamedValueType *)operator new();
      v80 = v141;
      *(_QWORD *)v79 = &unk_1EA993900;
      *((_QWORD *)v79 + 1) = 0;
      *((_QWORD *)v79 + 2) = 0;
      *((_QWORD *)v79 + 3) = v80;
    }
    else
    {
      v79 = 0;
    }
    v143.i64[1] = (uint64_t)v79;
    v141 = 0;
    v81 = v147.i64[1];
    if (v147.i64[1] >= v148[0])
    {
      v83 = (v147.i64[1] - v147.i64[0]) >> 4;
      v84 = v83 + 1;
      if ((unint64_t)(v83 + 1) >> 60)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v85 = v148[0] - v147.i64[0];
      if ((v148[0] - v147.i64[0]) >> 3 > v84)
        v84 = v85 >> 3;
      if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFF0)
        v86 = 0xFFFFFFFFFFFFFFFLL;
      else
        v86 = v84;
      v157 = v148;
      v87 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)v148, v86);
      v89 = (MIL::IRNamedValueType **)&v87[16 * v83];
      *v89 = v78;
      v89[1] = v79;
      v143 = 0uLL;
      v90 = (_QWORD *)v147.i64[1];
      v91 = (_QWORD *)v147.i64[0];
      if (v147.i64[1] == v147.i64[0])
      {
        v94 = vdupq_n_s64(v147.u64[1]);
        v92 = &v87[16 * v83];
      }
      else
      {
        v92 = &v87[16 * v83];
        do
        {
          v93 = *((_OWORD *)v90 - 1);
          v90 -= 2;
          *((_OWORD *)v92 - 1) = v93;
          v92 -= 16;
          *v90 = 0;
          v90[1] = 0;
        }
        while (v90 != v91);
        v94 = v147;
      }
      v82 = v89 + 2;
      v147.i64[0] = (uint64_t)v92;
      v147.i64[1] = (uint64_t)(v89 + 2);
      v155 = v94;
      v95 = v148[0];
      v148[0] = &v87[16 * v88];
      v156 = v95;
      v154 = (int64x2_t *)v94.i64[0];
      std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v154);
    }
    else
    {
      *(_QWORD *)v147.i64[1] = v78;
      *(_QWORD *)(v81 + 8) = v79;
      v82 = (_QWORD *)(v81 + 16);
    }
    v147.i64[1] = (uint64_t)v82;
    v96 = (void **)v141;
    v141 = 0;
    if (v96)
    {
      MIL::IRNamedValueType::~IRNamedValueType(v96);
      MEMORY[0x1E0C023A0]();
    }
    if (SHIBYTE(v146.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v146.__r_.__value_.__l.__data_);
  }
  v97 = *a2;
  v98 = a2[1];
  while (v97 != v98)
  {
    v100 = (MIL::IRNamedValueType **)v147.i64[1];
    v99 = (MIL::IRNamedValueType **)v147.i64[0];
    if (v147.i64[0] != v147.i64[1])
    {
      while (1)
      {
        v101 = (unsigned __int8 *)MIL::IRNamedValueType::GetName(*v99);
        v102 = v101[23];
        if ((v102 & 0x80u) == 0)
          v103 = v101[23];
        else
          v103 = *((_QWORD *)v101 + 1);
        v104 = *(unsigned __int8 *)(v97 + 23);
        v105 = (char)v104;
        if ((v104 & 0x80u) != 0)
          v104 = *(_QWORD *)(v97 + 8);
        if (v103 != v104)
          goto LABEL_145;
        v106 = v105 >= 0 ? (unsigned __int8 *)v97 : *(unsigned __int8 **)v97;
        if ((v102 & 0x80) == 0)
          break;
        if (!memcmp(*(const void **)v101, v106, *((_QWORD *)v101 + 1)))
          goto LABEL_140;
LABEL_145:
        v99 += 2;
        if (v99 == v100)
          goto LABEL_146;
      }
      if (v101[23])
      {
        while (*v101 == *v106)
        {
          ++v101;
          ++v106;
          if (!--v102)
            goto LABEL_140;
        }
        goto LABEL_145;
      }
LABEL_140:
      v107 = *v99;
      if (*(char *)(v97 + 47) < 0)
        std::string::__init_copy_ctor_external(&v145, *(const std::string::value_type **)(v97 + 24), *(_QWORD *)(v97 + 32));
      else
        v145 = *(std::string *)(v97 + 24);
      MIL::IRNamedValueType::SetName((uint64_t)v107, (__n128 *)&v145);
      if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v145.__r_.__value_.__l.__data_);
      goto LABEL_145;
    }
LABEL_146:
    v97 += 48;
  }
  v143 = 0uLL;
  v144[0] = 0;
  v108 = (_QWORD *)a1[18];
  for (k = (_QWORD *)a1[19]; v108 != k; v108 += 2)
  {
    (*(void (**)(MIL::IRNamedValueType **__return_ptr, _QWORD, uint64_t *))(*(_QWORD *)*v108 + 120))(&v140, *v108, a2);
    v110 = v140;
    v141 = v140;
    if (v140)
    {
      v111 = (_QWORD *)operator new();
      v112 = v140;
      *v111 = &unk_1EA992F48;
      v111[1] = 0;
      v111[2] = 0;
      v111[3] = v112;
    }
    else
    {
      v111 = 0;
    }
    v142 = v111;
    v140 = 0;
    v113 = v143.i64[1];
    if (v143.i64[1] >= v144[0])
    {
      v115 = (v143.i64[1] - v143.i64[0]) >> 4;
      v116 = v115 + 1;
      if ((unint64_t)(v115 + 1) >> 60)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v117 = v144[0] - v143.i64[0];
      if ((v144[0] - v143.i64[0]) >> 3 > v116)
        v116 = v117 >> 3;
      if ((unint64_t)v117 >= 0x7FFFFFFFFFFFFFF0)
        v118 = 0xFFFFFFFFFFFFFFFLL;
      else
        v118 = v116;
      v157 = v144;
      v119 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)v144, v118);
      v121 = (MIL::IRNamedValueType **)&v119[16 * v115];
      *v121 = v110;
      v121[1] = (MIL::IRNamedValueType *)v111;
      v141 = 0;
      v142 = 0;
      v122 = (_QWORD *)v143.i64[1];
      v123 = (_QWORD *)v143.i64[0];
      if (v143.i64[1] == v143.i64[0])
      {
        v126 = vdupq_n_s64(v143.u64[1]);
        v124 = &v119[16 * v115];
      }
      else
      {
        v124 = &v119[16 * v115];
        do
        {
          v125 = *((_OWORD *)v122 - 1);
          v122 -= 2;
          *((_OWORD *)v124 - 1) = v125;
          v124 -= 16;
          *v122 = 0;
          v122[1] = 0;
        }
        while (v122 != v123);
        v126 = v143;
      }
      v114 = v121 + 2;
      v143.i64[0] = (uint64_t)v124;
      v143.i64[1] = (uint64_t)(v121 + 2);
      v155 = v126;
      v127 = v144[0];
      v144[0] = &v119[16 * v120];
      v156 = v127;
      v154 = (int64x2_t *)v126.i64[0];
      std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v154);
    }
    else
    {
      *(_QWORD *)v143.i64[1] = v110;
      *(_QWORD *)(v113 + 8) = v111;
      v114 = (_QWORD *)(v113 + 16);
    }
    v143.i64[1] = (uint64_t)v114;
    v128 = v140;
    v140 = 0;
    if (v128)
      (*(void (**)(MIL::IRNamedValueType *))(*(_QWORD *)v128 + 8))(v128);
  }
  LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a1);
  Attributes = MIL::IRObject::GetAttributes((MIL::IRObject *)a1);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)&v154, Attributes);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&v154);
  v131 = v141;
  v132 = a1[9];
  *((_QWORD *)v141 + 9) = v132;
  v133 = (_QWORD *)*((_QWORD *)v131 + 18);
  v134 = (_QWORD *)*((_QWORD *)v131 + 19);
  if (v133 != v134)
  {
    if (v132)
      v135 = v132 + 64;
    else
      v135 = 0;
    do
    {
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v133 + 104))(*v133, v135);
      v133 += 2;
    }
    while (v133 != v134);
    v131 = v141;
  }
  v141 = 0;
  *a3 = v131;
  v154 = &v143;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v154);
  v154 = &v147;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v154);
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v152, v153[0]);
}

void sub_1E05853E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char **a17, uint64_t a18, char *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  uint64_t v46;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v46 - 136);
  a17 = &a19;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  a19 = &a37;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(v46 - 160, *(_QWORD **)(v46 - 152));
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IROperationImpl::GetOperatorName(_anonymous_namespace_::IROperationImpl *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  std::runtime_error *exception;

  v1 = *((_QWORD *)this + 10);
  if (!v1)
    goto LABEL_6;
  v2 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v1 + 16))(*((_QWORD *)this + 10));
  v3 = *(unsigned __int8 *)(v2 + 23);
  if ((v3 & 0x80u) != 0)
    v3 = *(_QWORD *)(v2 + 8);
  if (!v3)
  {
LABEL_6:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Operation has no definition or definition has no name.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
}

void sub_1E0585640(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IROperationImpl::GetOperator(_anonymous_namespace_::IROperationImpl *this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = *((_QWORD *)this + 10);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Operator has not been defined.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05856A4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IROperationImpl::TryGetOperator(_anonymous_namespace_::IROperationImpl *this)
{
  return *((_QWORD *)this + 10);
}

uint64_t `anonymous namespace'::IROperationImpl::TryGetOperatorSharedPtr@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 88);
  *a2 = *(_QWORD *)(this + 80);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t `anonymous namespace'::IROperationImpl::SetOperator(uint64_t a1, __int128 *a2)
{
  return std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100](a1 + 80, a2);
}

uint64_t `anonymous namespace'::IROperationImpl::GetParentBlock(_anonymous_namespace_::IROperationImpl *this)
{
  uint64_t result;
  void *exception;
  _QWORD *LocationPtr;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  _QWORD v8[3];
  _QWORD v9[2];

  result = *((_QWORD *)this + 9);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    LocationPtr = (_QWORD *)MIL::IRObject::GetLocationPtr(this);
    v5 = LocationPtr[1];
    v9[0] = *LocationPtr;
    v9[1] = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
    std::string::basic_string[abi:ne180100]<0>(v8, "Cannot access non-existent parent of an IROperation.");
    MIL::InvalidOperationError::InvalidOperationError(exception, v9, v8);
  }
  return result;
}

void sub_1E0585798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  void *v16;
  int v17;

  if (a15 < 0)
  {
    operator delete(__p);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
    if ((v17 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else
  {
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
    if (!v17)
      goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t `anonymous namespace'::IROperationImpl::TryGetParentBlock(_anonymous_namespace_::IROperationImpl *this)
{
  return *((_QWORD *)this + 9);
}

uint64_t `anonymous namespace'::IROperationImpl::TryGetArgumentName(uint64_t a1, const void **a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
  v7 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(v6, a2);
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1) + 8 == v7)
    return 0;
  v8 = a1 + 96;
  v9 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(v8, a2);
  if (a3 >= (unint64_t)((uint64_t)(*(_QWORD *)(v9 + 64) - *(_QWORD *)(v9 + 56)) >> 4))
    return 0;
  v10 = *(_QWORD *)(*(_QWORD *)(std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(v8, a2)+ 56)+ 16 * a3);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 32))(v10);
}

uint64_t `anonymous namespace'::IROperationImpl::TryGetArgumentValue(uint64_t a1, const void **a2, unsigned int a3)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v8;
  std::__shared_weak_count *v9;

  v3 = v8;
  v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

uint64_t `anonymous namespace'::IROperationImpl::TryGetArgumentValueSharedPtr@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, unsigned int a3@<W2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;

  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
  v9 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(v8, a2);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
  if (result + 8 == v9
    || (v11 = a1 + 96,
        result = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(v11, a2), a3 >= (unint64_t)((uint64_t)(*(_QWORD *)(result + 64) - *(_QWORD *)(result + 56)) >> 4)))
  {
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    v12 = *(_QWORD *)(*(_QWORD *)(std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>(v11, a2)+ 56)+ 16 * a3);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 48))(v12);
  }
  return result;
}

uint64_t `anonymous namespace'::IROperationImpl::GetNumSetParameters(_anonymous_namespace_::IROperationImpl *this)
{
  return *((_QWORD *)this + 14);
}

uint64_t `anonymous namespace'::IROperationImpl::GetNumArguments(MIL::IRObject *a1, const void **a2)
{
  uint64_t v3;
  void *exception;
  MIL::IRObject *v6;
  void *v7;
  _QWORD *LocationPtr;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::string *v12;
  __int128 v13;
  std::string v14;
  __int128 v15;
  std::string::size_type v16;
  _QWORD v17[2];

  v3 = std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>((uint64_t)a1 + 96, a2);
  if ((MIL::IRObject *)((char *)a1 + 104) == (MIL::IRObject *)v3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    v6 = a1;
    v7 = exception;
    LocationPtr = (_QWORD *)MIL::IRObject::GetLocationPtr(v6);
    v9 = LocationPtr[1];
    v17[0] = *LocationPtr;
    v17[1] = v9;
    if (v9)
    {
      v10 = (unint64_t *)(v9 + 8);
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    std::operator+<char>();
    v12 = std::string::append(&v14, " does not exist.");
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v16 = v12->__r_.__value_.__r.__words[2];
    v15 = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    MIL::OutOfRangeError::OutOfRangeError(v7, v17, &v15);
  }
  return (*(_QWORD *)(v3 + 64) - *(_QWORD *)(v3 + 56)) >> 4;
}

void sub_1E0585AE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;
  uint64_t v23;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v23 - 48);
    if ((v22 & 1) == 0)
      goto LABEL_8;
  }
  else
  {
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v23 - 48);
    if (!v22)
LABEL_8:
      _Unwind_Resume(a1);
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t `anonymous namespace'::IROperationImpl::GetArgumentMapping(_anonymous_namespace_::IROperationImpl *this)
{
  return (uint64_t)this + 96;
}

void `anonymous namespace'::IROperationImpl::SetArgumentMapping(_anonymous_namespace_::IROperationImpl *a1, _QWORD *a2)
{
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__move_assign((uint64_t)a1 + 96, a2);
}

uint64_t `anonymous namespace'::IROperationImpl::GetOutputs(_anonymous_namespace_::IROperationImpl *this)
{
  return (uint64_t)this + 120;
}

__n128 `anonymous namespace'::IROperationImpl::SetOutputs(uint64_t a1, __n128 *a2)
{
  __n128 result;

  std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vdeallocate((void **)(a1 + 120));
  result = *a2;
  *(__n128 *)(a1 + 120) = *a2;
  *(_QWORD *)(a1 + 136) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

uint64_t `anonymous namespace'::IROperationImpl::GetNumOutputs(_anonymous_namespace_::IROperationImpl *this)
{
  return (uint64_t)(*((_QWORD *)this + 16) - *((_QWORD *)this + 15)) >> 4;
}

void `anonymous namespace'::IROperationImpl::GetOutputNames(_anonymous_namespace_::IROperationImpl *this@<X0>, std::vector<std::string> *a2@<X8>)
{
  MIL::IRNamedValueType **v4;
  MIL::IRNamedValueType **v5;
  __int128 *Name;
  std::string *end;
  uint64_t v8;

  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  std::vector<std::string>::reserve(a2, (uint64_t)(*((_QWORD *)this + 16) - *((_QWORD *)this + 15)) >> 4);
  v5 = (MIL::IRNamedValueType **)*((_QWORD *)this + 15);
  v4 = (MIL::IRNamedValueType **)*((_QWORD *)this + 16);
  while (v5 != v4)
  {
    Name = (__int128 *)MIL::IRNamedValueType::GetName(*v5);
    end = a2->__end_;
    if (end >= a2->__end_cap_.__value_)
    {
      v8 = std::vector<std::string>::__push_back_slow_path<std::string const&>((uint64_t *)a2, Name);
    }
    else
    {
      std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)a2, Name);
      v8 = (uint64_t)&end[1];
    }
    a2->__end_ = (std::vector<std::string>::pointer)v8;
    v5 += 2;
  }
}

void sub_1E0585C74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IROperationImpl::GetBlocks(_anonymous_namespace_::IROperationImpl *this)
{
  return *((_QWORD *)this + 21);
}

uint64_t `anonymous namespace'::IROperationImpl::GetBlocksShared(_anonymous_namespace_::IROperationImpl *this)
{
  return (uint64_t)this + 144;
}

uint64_t `anonymous namespace'::IROperationImpl::GetOpsetSpecification(_anonymous_namespace_::IROperationImpl *this)
{
  return *((_QWORD *)this + 22);
}

uint64_t `anonymous namespace'::IROperationImpl::ClearOpsetSpecification(uint64_t this)
{
  *(_QWORD *)(this + 176) = 0;
  return this;
}

uint64_t `anonymous namespace'::IROperationImpl::UpdateInput(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v7;
  unint64_t v8;
  MIL::IRArgument **v9;
  unsigned __int8 *Name;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unsigned __int8 *v15;
  _QWORD *v16;
  _QWORD *v17;
  BOOL v18;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;

  v3 = *(_QWORD **)(a1 + 96);
  v4 = (_QWORD *)(a1 + 104);
  if (v3 == (_QWORD *)(a1 + 104))
    return 0;
  while (1)
  {
    v7 = v3[7];
    if (v3[8] != v7)
      break;
LABEL_21:
    v16 = (_QWORD *)v3[1];
    if (v16)
    {
      do
      {
        v17 = v16;
        v16 = (_QWORD *)*v16;
      }
      while (v16);
    }
    else
    {
      do
      {
        v17 = (_QWORD *)v3[2];
        v18 = *v17 == (_QWORD)v3;
        v3 = v17;
      }
      while (!v18);
    }
    v3 = v17;
    if (v17 == v4)
      return 0;
  }
  v8 = 0;
  while (1)
  {
    v9 = (MIL::IRArgument **)(v7 + 16 * v8);
    if (!(*(unsigned int (**)(MIL::IRArgument *))(*(_QWORD *)*v9 + 16))(*v9))
      goto LABEL_20;
    Name = (unsigned __int8 *)MIL::IRArgument::GetName(*v9);
    v11 = Name[23];
    if ((v11 & 0x80u) == 0)
      v12 = Name[23];
    else
      v12 = *((_QWORD *)Name + 1);
    v13 = *(unsigned __int8 *)(a2 + 23);
    v14 = (char)v13;
    if ((v13 & 0x80u) != 0)
      v13 = *(_QWORD *)(a2 + 8);
    if (v12 != v13)
      goto LABEL_20;
    v15 = v14 >= 0 ? (unsigned __int8 *)a2 : *(unsigned __int8 **)a2;
    if ((v11 & 0x80) != 0)
      break;
    if (!Name[23])
      goto LABEL_28;
    while (*Name == *v15)
    {
      ++Name;
      ++v15;
      if (!--v11)
        goto LABEL_28;
    }
LABEL_20:
    ++v8;
    v7 = v3[7];
    if (v8 >= (v3[8] - v7) >> 4)
      goto LABEL_21;
  }
  if (memcmp(*(const void **)Name, v15, *((_QWORD *)Name + 1)))
    goto LABEL_20;
LABEL_28:
  v20 = a3[1];
  *(_QWORD *)&v31 = *a3;
  *((_QWORD *)&v31 + 1) = v20;
  if (v20)
  {
    v21 = (unint64_t *)(v20 + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  MIL::IRArgument::Make(&v31, &v32);
  v33 = v32;
  if (v32)
  {
    v23 = (std::__shared_weak_count *)operator new();
    v24 = v32;
    v23->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA9942C8;
    v23->__shared_owners_ = 0;
    v23->__shared_weak_owners_ = 0;
    v23[1].__vftable = (std::__shared_weak_count_vtbl *)v24;
  }
  else
  {
    v23 = 0;
  }
  v34 = v23;
  v32 = 0;
  v25 = (std::__shared_weak_count *)*((_QWORD *)&v31 + 1);
  if (*((_QWORD *)&v31 + 1))
  {
    v26 = (unint64_t *)(*((_QWORD *)&v31 + 1) + 8);
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]((_QWORD *)(v3[7] + 16 * v8), &v33);
  v28 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      v30 = __ldaxr(p_shared_owners);
    while (__stlxr(v30 - 1, p_shared_owners));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  return 1;
}

void sub_1E0585EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  uint64_t v13;

  v13 = a12;
  a12 = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IROperationImpl::GetType(MIL::IRObject *a1)
{
  uint64_t v2;
  void *exception;
  _QWORD *LocationPtr;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD v9[3];
  _QWORD v10[2];

  v2 = *((_QWORD *)a1 + 9);
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    LocationPtr = (_QWORD *)MIL::IRObject::GetLocationPtr(a1);
    v6 = LocationPtr[1];
    v10[0] = *LocationPtr;
    v10[1] = v6;
    if (v6)
    {
      v7 = (unint64_t *)(v6 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    std::string::basic_string[abi:ne180100]<0>(v9, "Cannot query for a type when the parent block/scope is not set.");
    MIL::InvalidOperationError::InvalidOperationError(exception, v10, v9);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v2 + 64) + 16))(v2 + 64);
}

void sub_1E0585FD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  void *v16;
  int v17;

  if (a15 < 0)
  {
    operator delete(__p);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
    if ((v17 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else
  {
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
    if (!v17)
      goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t `anonymous namespace'::IROperationImpl::TryGetType(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 72);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result + 64) + 24))(result + 64);
  return result;
}

uint64_t `anonymous namespace'::IROperationImpl::GetTypes(_anonymous_namespace_::IROperationImpl *this)
{
  uint64_t v2;
  void *exception;
  _QWORD *LocationPtr;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD v9[3];
  _QWORD v10[2];

  v2 = *((_QWORD *)this + 9);
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    LocationPtr = (_QWORD *)MIL::IRObject::GetLocationPtr(this);
    v6 = LocationPtr[1];
    v10[0] = *LocationPtr;
    v10[1] = v6;
    if (v6)
    {
      v7 = (unint64_t *)(v6 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    std::string::basic_string[abi:ne180100]<0>(v9, "Cannot query for a list of types in scope when the parent block/scope is not set.");
    MIL::InvalidOperationError::InvalidOperationError(exception, v10, v9);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v2 + 64) + 32))(v2 + 64);
}

void sub_1E05860F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  void *v16;
  int v17;

  if (a15 < 0)
  {
    operator delete(__p);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
    if ((v17 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else
  {
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
    if (!v17)
      goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t `anonymous namespace'::IROperationImpl::GetValue(MIL::IRObject *a1)
{
  uint64_t v2;
  void *exception;
  _QWORD *LocationPtr;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD v9[3];
  _QWORD v10[2];

  v2 = *((_QWORD *)a1 + 9);
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    LocationPtr = (_QWORD *)MIL::IRObject::GetLocationPtr(a1);
    v6 = LocationPtr[1];
    v10[0] = *LocationPtr;
    v10[1] = v6;
    if (v6)
    {
      v7 = (unint64_t *)(v6 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    std::string::basic_string[abi:ne180100]<0>(v9, "Cannot query for a value when the parent block/scope is not set.");
    MIL::InvalidOperationError::InvalidOperationError(exception, v10, v9);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v2 + 64) + 40))(v2 + 64);
}

void sub_1E0586204(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  void *v16;
  int v17;

  if (a15 < 0)
  {
    operator delete(__p);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
    if ((v17 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else
  {
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
    if (!v17)
      goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t `anonymous namespace'::IROperationImpl::TryGetValue(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 72);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result + 64) + 48))(result + 64);
  return result;
}

uint64_t `anonymous namespace'::IROperationImpl::TryGetValueSharedPtr@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 72);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result + 64) + 56))(result + 64);
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t `anonymous namespace'::IROperationImpl::GetValues(_anonymous_namespace_::IROperationImpl *this)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)this + 9) + 64) + 64))(*((_QWORD *)this + 9) + 64);
}

uint64_t `non-virtual thunk to'`anonymous namespace'::IROperationImpl::GetType(uint64_t a1)
{
}

uint64_t `non-virtual thunk to'`anonymous namespace'::IROperationImpl::TryGetType(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result + 64) + 24))(result + 64);
  return result;
}

uint64_t `non-virtual thunk to'`anonymous namespace'::IROperationImpl::GetTypes(_anonymous_namespace_::IROperationImpl *this)
{
}

uint64_t `non-virtual thunk to'`anonymous namespace'::IROperationImpl::GetValue(uint64_t a1)
{
}

uint64_t `non-virtual thunk to'`anonymous namespace'::IROperationImpl::TryGetValue(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result + 64) + 48))(result + 64);
  return result;
}

uint64_t `non-virtual thunk to'`anonymous namespace'::IROperationImpl::TryGetValueSharedPtr@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result + 64) + 56))(result + 64);
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t `non-virtual thunk to'`anonymous namespace'::IROperationImpl::GetValues(_anonymous_namespace_::IROperationImpl *this)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)this + 1) + 64) + 64))(*((_QWORD *)this + 1) + 64);
}

uint64_t *std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)v10);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

void std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  std::string *v7;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = operator new(0x50uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 4);
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    v6[6] = *((_QWORD *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  v6[9] = 0;
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_1E0586460(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

uint64_t std::vector<std::shared_ptr<MIL::IRArgument>>::__assign_with_size[abi:ne180100]<std::shared_ptr<MIL::IRArgument> const*,std::shared_ptr<MIL::IRArgument> const*>(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t *v6;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t result;
  uint64_t *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t *v23;

  v6 = a2;
  v8 = *(uint64_t **)a1;
  if (a4 > (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4)
  {
    std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vdeallocate((void **)a1);
    if (a4 >> 60)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v9 = *(_QWORD *)(a1 + 16) - *(_QWORD *)a1;
    v10 = v9 >> 3;
    if (v9 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = (uint64_t)std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vallocate[abi:ne180100]((_QWORD *)a1, v11);
    v13 = *(uint64_t **)(a1 + 8);
    while (v6 != a3)
    {
      v14 = v6[1];
      *v13 = *v6;
      v13[1] = v14;
      if (v14)
      {
        v15 = (unint64_t *)(v14 + 8);
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
      v6 += 2;
      v13 += 2;
    }
LABEL_25:
    *(_QWORD *)(a1 + 8) = v13;
    return result;
  }
  result = *(_QWORD *)(a1 + 8);
  v17 = (result - (uint64_t)v8) >> 4;
  if (v17 < a4)
  {
    v18 = &a2[2 * v17];
    if ((uint64_t *)result != v8)
    {
      v19 = 16 * v17;
      do
      {
        result = (uint64_t)std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100](v8, v6);
        v6 += 2;
        v8 += 2;
        v19 -= 16;
      }
      while (v19);
      v8 = *(uint64_t **)(a1 + 8);
    }
    v13 = v8;
    if (v18 != a3)
    {
      v13 = v8;
      do
      {
        v20 = v18[1];
        *v13 = *v18;
        v13[1] = v20;
        if (v20)
        {
          v21 = (unint64_t *)(v20 + 8);
          do
            v22 = __ldxr(v21);
          while (__stxr(v22 + 1, v21));
        }
        v18 += 2;
        v13 += 2;
      }
      while (v18 != a3);
    }
    goto LABEL_25;
  }
  if (a2 == a3)
  {
    v23 = v8;
  }
  else
  {
    v23 = v8;
    do
    {
      std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100](v8, v6);
      v6 += 2;
      v8 += 2;
      v23 += 2;
    }
    while (v6 != a3);
    result = *(_QWORD *)(a1 + 8);
  }
  while ((uint64_t *)result != v23)
    result = std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](result - 16);
  *(_QWORD *)(a1 + 8) = v23;
  return result;
}

void std::make_unique[abi:ne180100]<`anonymous namespace'::IROperationImpl,std::shared_ptr<MIL::Location const> const&,std::shared_ptr<MIL::IROperator const> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>,std::map<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::vector<std::shared_ptr<MIL::IRNamedValueType>>,std::vector<std::shared_ptr<MIL::IRBlock>>,MIL::IROpset const* const&>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;

  v16 = operator new();
  v17 = v16;
  v18 = (std::__shared_weak_count *)a1[1];
  v32 = *a1;
  v33 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldxr(p_shared_owners);
    while (__stxr(v20 + 1, p_shared_owners));
  }
  v21 = (std::__shared_weak_count *)a2[1];
  v30 = *a2;
  v31 = v21;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  *a8 = v17;
  v24 = v31;
  if (v31)
  {
    v25 = (unint64_t *)&v31->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v27 = v33;
  if (v33)
  {
    v28 = (unint64_t *)&v33->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
}

void sub_1E05867DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  MEMORY[0x1E0C023A0](v11, 0x10E1C40E9C383C0);
  _Unwind_Resume(a1);
}

uint64_t *std::map<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>::map[abi:ne180100](uint64_t *a1, const void ***a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::map<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *> *,long>>>(a1, *a2, a2 + 1);
  return a1;
}

void sub_1E058684C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::map<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *> *,long>>>(uint64_t *result, const void **a2, const void ***a3)
{
  const void **v4;
  uint64_t **v5;
  uint64_t *v6;
  const void **v7;
  const void ***v8;
  BOOL v9;

  if (a2 != (const void **)a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>(v5, v6, v4 + 4, (__int128 *)v4 + 2);
      v7 = (const void **)v4[1];
      if (v7)
      {
        do
        {
          v8 = (const void ***)v7;
          v7 = (const void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (const void ***)v4[2];
          v9 = *v8 == v4;
          v4 = (const void **)v8;
        }
        while (!v9);
      }
      v4 = (const void **)v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>(uint64_t **a1, uint64_t *a2, const void **a3, __int128 *a4)
{
  const void **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;
  const void **v12;

  v6 = std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__find_equal<std::string>(a1, a2, &v12, &v11, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__construct_node<std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t)a1, a4, (uint64_t)v10);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, (uint64_t)v12, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

std::string *std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__construct_node<std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *result;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x50uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>::pair[abi:ne180100]((std::string *)(v6 + 32), a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1E05869CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>::pair[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v4;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  std::vector<std::shared_ptr<MIL::IRArgument>>::__init_with_size[abi:ne180100]<std::shared_ptr<MIL::IRArgument>*,std::shared_ptr<MIL::IRArgument>*>((char *)&this[1], *((_QWORD **)a2 + 3), *((_QWORD **)a2 + 4), (uint64_t)(*((_QWORD *)a2 + 4) - *((_QWORD *)a2 + 3)) >> 4);
  return this;
}

{
  __int128 v4;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = *(__int128 *)((char *)a2 + 24);
  this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 5) = 0;
  return this;
}

void sub_1E0586A4C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

char *std::vector<std::shared_ptr<MIL::IRArgument>>::__init_with_size[abi:ne180100]<std::shared_ptr<MIL::IRArgument>*,std::shared_ptr<MIL::IRArgument>*>(char *result, _QWORD *a2, _QWORD *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  if (a4)
  {
    v6 = result;
    result = std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vallocate[abi:ne180100](result, a4);
    v7 = (_QWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      *v7 = *a2;
      v8 = a2[1];
      v7[1] = v8;
      if (v8)
      {
        v9 = (unint64_t *)(v8 + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      a2 += 2;
      v7 += 2;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1E0586AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<MIL::IRArgument>::operator=[abi:ne180100]<MIL::IRArgument,std::default_delete<MIL::IRArgument>,void>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  if (*a2)
  {
    v5 = (_QWORD *)operator new();
    v6 = *a2;
    *v5 = &unk_1EA9942C8;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  *a2 = 0;
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__move_assign(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = (_QWORD *)(a1 + 8);
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(a1, *(_QWORD **)(a1 + 8));
  *(_QWORD *)a1 = *a2;
  v5 = a2 + 1;
  v6 = a2[1];
  *v4 = v6;
  v7 = a2[2];
  *(_QWORD *)(a1 + 16) = v7;
  if (v7)
  {
    *(_QWORD *)(v6 + 16) = v4;
    *a2 = v5;
    *v5 = 0;
    a2[2] = 0;
  }
  else
  {
    *(_QWORD *)a1 = v4;
  }
}

void std::vector<std::string>::reserve(std::vector<std::string> *this, std::vector<std::string>::size_type __n)
{
  std::__compressed_pair<std::string *> *p_end_cap;
  std::string *value;
  int64_t v5;
  uint64_t v6;
  std::__split_buffer<std::string> __v;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)this->__begin_) >> 3) < __n)
  {
    if (__n >= 0xAAAAAAAAAAAAAABLL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    __v.__end_cap_.__value_ = (std::allocator<std::string> *)p_end_cap;
    __v.__first_ = (std::__split_buffer<std::string>::pointer)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)p_end_cap, __n);
    __v.__begin_ = (std::__split_buffer<std::string>::pointer)((char *)__v.__first_ + v5);
    __v.__end_ = (std::__split_buffer<std::string>::pointer)((char *)__v.__first_ + v5);
    __v.__end_cap_.__value_ = &__v.__first_[v6];
    std::vector<std::string>::__swap_out_circular_buffer(this, &__v);
    std::__split_buffer<std::string>::~__split_buffer(&__v);
  }
}

void sub_1E0586CB8(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::string *v4;
  std::string *begin;
  std::string *end;
  std::string *value;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  __int128 v4;

  v3 = *(_QWORD *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(*(std::string **)(a1 + 8), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    *(_QWORD *)(v3 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v3 = v4;
  }
  *(_QWORD *)(a1 + 8) = v3 + 24;
}

void sub_1E0586F30(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::string>::__push_back_slow_path<std::string const&>(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::string *v10;
  std::__split_buffer<std::string>::pointer end;
  __int128 v12;
  uint64_t v13;
  std::__split_buffer<std::string> __v;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
  if (v9)
    v10 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  else
    v10 = 0;
  end = v10 + v4;
  __v.__first_ = v10;
  __v.__begin_ = end;
  __v.__end_ = end;
  __v.__end_cap_.__value_ = &v10[v9];
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(end, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    end = __v.__end_;
  }
  else
  {
    v12 = *a2;
    end->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v12;
  }
  __v.__end_ = end + 1;
  std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a1, &__v);
  v13 = a1[1];
  std::__split_buffer<std::string>::~__split_buffer(&__v);
  return v13;
}

void sub_1E0587044(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>>(uint64_t **a1, const void **a2, __int128 *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v9[3];
  uint64_t v10;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, &v10, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__construct_node<std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, v10, v7, v9[0]);
    v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

std::string *std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__construct_node<std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>>@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *result;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x50uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>::pair[abi:ne180100]((std::string *)(v6 + 32), a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1E0587138(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_0_1(std::__shared_weak_count *this)
{
  std::__shared_weak_count::__release_weak(this);
}

void IRParameterImpl::~IRParameterImpl(IRParameterImpl *this)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 32);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 32);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 32);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRParameter::IRParameter(_QWORD *this)
{
  *this = off_1EA9944E0;
  return this;
}

uint64_t *MIL::IRParameter::Make@<X0>(__n128 *a1@<X0>, char a2@<W1>, char a3@<W2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  __n128 v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v15;
  __n128 v16;

  v8 = operator new();
  v16 = *a1;
  a1->n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  v9 = IRParameterImpl::IRParameterImpl(v8, &v16, a2, a3, 0);
  v15 = v8;
  v10 = (std::__shared_weak_count *)v16.n128_u64[1];
  if (v16.n128_u64[1])
  {
    v11 = (unint64_t *)(v16.n128_u64[1] + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v10->__on_zero_shared)(v10, v9);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v15;
  v15 = 0;
  *a4 = v13;
  return std::unique_ptr<IRParameterImpl>::reset[abi:ne180100](&v15, 0);
}

void sub_1E0587350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  uint64_t v12;

  if (a12)
    MIL::IRParameter::Make(a12);
  MEMORY[0x1E0C023A0](v12, 0x10E1C403F0BF65ALL);
  _Unwind_Resume(a1);
}

uint64_t *MIL::IRParameter::Make@<X0>(__n128 *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  __n128 v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v11;
  __n128 v12;

  v4 = operator new();
  v12 = *a1;
  a1->n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  v5 = IRParameterImpl::IRParameterImpl(v4, &v12, 0, 0, 0);
  v11 = v4;
  v6 = (std::__shared_weak_count *)v12.n128_u64[1];
  if (v12.n128_u64[1])
  {
    v7 = (unint64_t *)(v12.n128_u64[1] + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v6->__on_zero_shared)(v6, v5);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = v11;
  v11 = 0;
  *a2 = v9;
  return std::unique_ptr<IRParameterImpl>::reset[abi:ne180100](&v11, 0);
}

void sub_1E0587440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  uint64_t v12;

  if (a12)
    MIL::IRParameter::Make(a12);
  MEMORY[0x1E0C023A0](v12, 0x10E1C403F0BF65ALL);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRParameter::MakeTypeSet@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD v4[2];

  v4[0] = a1;
  v4[1] = a2;
  return std::allocate_shared[abi:ne180100]<std::unordered_set<MIL::IRValueType const*>,std::allocator<std::unordered_set<MIL::IRValueType const*>>,std::initializer_list<MIL::IRValueType const*> &,void>((uint64_t)v4, a3);
}

void MIL::IRMemoryEffect::~IRMemoryEffect(MIL::IRMemoryEffect *this)
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRMemoryEffect::IRMemoryEffect(_QWORD *this)
{
  *this = &off_1EA994568;
  return this;
}

{
  *this = &off_1EA994568;
  return this;
}

void *MIL::IRMemoryEffect::TryAsStateReadEffect(void *this)
{
  if (this)
  return this;
}

void *MIL::IRMemoryEffect::AsStateReadEffect(MIL::IRMemoryEffect *this)
{
  void *result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  if (!this
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

void *MIL::IRMemoryEffect::TryAsStateWriteEffect(void *this)
{
  if (this)
  return this;
}

void *MIL::IRMemoryEffect::AsStateWriteEffect(MIL::IRMemoryEffect *this)
{
  void *result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  if (!this
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

void MIL::IRStateReadEffect::~IRStateReadEffect(MIL::IRStateReadEffect *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA994598;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0xC400A2AC0F1);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA994598;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0xC400A2AC0F1);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA994598;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0xC400A2AC0F1);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRStateReadEffect::IRStateReadEffect(_QWORD *this)
{
  *this = &off_1EA994598;
  this[1] = 0;
  return this;
}

{
  *this = &off_1EA994598;
  this[1] = 0;
  return this;
}

_QWORD *MIL::IRStateReadEffect::IRStateReadEffect(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA994598;
  result[1] = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA994598;
  result[1] = v2;
  return result;
}

_QWORD *MIL::IRStateReadEffect::Make@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v3;
  _QWORD *result;

  v3 = operator new();
  result = (_QWORD *)operator new();
  *result = &off_1EA994598;
  result[1] = v3;
  *a1 = result;
  return result;
}

void sub_1E058773C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xC400A2AC0F1);
  _Unwind_Resume(a1);
}

void MIL::IRStateWriteEffect::~IRStateWriteEffect(MIL::IRStateWriteEffect *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA9945B8;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0xC400A2AC0F1);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA9945B8;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0xC400A2AC0F1);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA9945B8;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0xC400A2AC0F1);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRStateWriteEffect::IRStateWriteEffect(_QWORD *this)
{
  *this = &off_1EA9945B8;
  this[1] = 0;
  return this;
}

{
  *this = &off_1EA9945B8;
  this[1] = 0;
  return this;
}

_QWORD *MIL::IRStateWriteEffect::IRStateWriteEffect(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA9945B8;
  result[1] = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA9945B8;
  result[1] = v2;
  return result;
}

_QWORD *MIL::IRStateWriteEffect::Make@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v3;
  _QWORD *result;

  v3 = operator new();
  result = (_QWORD *)operator new();
  *result = &off_1EA9945B8;
  result[1] = v3;
  *a1 = result;
  return result;
}

void sub_1E05878E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xC400A2AC0F1);
  _Unwind_Resume(a1);
}

void IROperatorImpl::~IROperatorImpl(IROperatorImpl *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  IROperatorImpl *v6;
  uint64_t v7;
  IROperatorImpl *v8;
  uint64_t v9;
  IROperatorImpl *v10;
  uint64_t v11;
  IROperatorImpl *v12;
  uint64_t v13;
  IROperatorImpl *v14;
  uint64_t v15;
  IROperatorImpl *v16;
  uint64_t v17;
  void **v18;

  v2 = (char *)this + 336;
  v3 = (char *)*((_QWORD *)this + 45);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  v5 = *((_QWORD *)this + 41);
  *((_QWORD *)this + 41) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = (IROperatorImpl *)*((_QWORD *)this + 40);
  if (v6 == (IROperatorImpl *)((char *)this + 296))
  {
    v7 = 4;
    v6 = (IROperatorImpl *)((char *)this + 296);
  }
  else
  {
    if (!v6)
      goto LABEL_13;
    v7 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v6 + 8 * v7))();
LABEL_13:
  v8 = (IROperatorImpl *)*((_QWORD *)this + 36);
  if (v8 == (IROperatorImpl *)((char *)this + 264))
  {
    v9 = 4;
    v8 = (IROperatorImpl *)((char *)this + 264);
  }
  else
  {
    if (!v8)
      goto LABEL_18;
    v9 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v8 + 8 * v9))();
LABEL_18:
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 248);
  v10 = (IROperatorImpl *)*((_QWORD *)this + 30);
  if (v10 == (IROperatorImpl *)((char *)this + 216))
  {
    v11 = 4;
    v10 = (IROperatorImpl *)((char *)this + 216);
  }
  else
  {
    if (!v10)
      goto LABEL_23;
    v11 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v10 + 8 * v11))();
LABEL_23:
  v12 = (IROperatorImpl *)*((_QWORD *)this + 26);
  if (v12 == (IROperatorImpl *)((char *)this + 184))
  {
    v13 = 4;
    v12 = (IROperatorImpl *)((char *)this + 184);
  }
  else
  {
    if (!v12)
      goto LABEL_28;
    v13 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v12 + 8 * v13))();
LABEL_28:
  v14 = (IROperatorImpl *)*((_QWORD *)this + 22);
  if (v14 == (IROperatorImpl *)((char *)this + 152))
  {
    v15 = 4;
    v14 = (IROperatorImpl *)((char *)this + 152);
  }
  else
  {
    if (!v14)
      goto LABEL_33;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_33:
  v16 = (IROperatorImpl *)*((_QWORD *)this + 18);
  if (v16 == (IROperatorImpl *)((char *)this + 120))
  {
    v17 = 4;
    v16 = (IROperatorImpl *)((char *)this + 120);
  }
  else
  {
    if (!v16)
      goto LABEL_38;
    v17 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v16 + 8 * v17))();
LABEL_38:
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 104);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 88);
  v18 = (void **)((char *)this + 64);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v18);
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  IROperatorImpl::~IROperatorImpl(this);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IROperator::IROperator(_QWORD *this)
{
  *this = off_1EA9945D8;
  return this;
}

void MIL::IROperator::Make(__int128 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, _QWORD *a9@<X8>, uint64_t a10)
{
  __int128 v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  void *__p[2];
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _BYTE v37[24];
  _BYTE *v38;
  _BYTE v39[24];
  _BYTE *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v15 = *a1;
  v31 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  *(_QWORD *)a1 = 0;
  v29 = *(_OWORD *)a6;
  *(_OWORD *)__p = v15;
  *(_QWORD *)a6 = 0;
  *(_QWORD *)(a6 + 8) = 0;
  v28 = *(_OWORD *)a7;
  *(_QWORD *)a7 = 0;
  *(_QWORD *)(a7 + 8) = 0;
  v27 = 0;
  std::__function::__value_func<MIL::ValidationResult ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v39, a8);
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v37, a10);
  v35 = a3;
  v36 = a2;
  v33 = a5;
  v34 = a4;
  std::make_unique[abi:ne180100]<IROperatorImpl,std::string,unsigned long long &,unsigned long long &,unsigned long long &,unsigned long long &,std::shared_ptr<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>,std::shared_ptr<std::vector<std::shared_ptr<MIL::IRParameter>>>,std::unique_ptr<MIL::IRMemoryEffect>,std::function<MIL::ValidationResult ()(MIL::IROperation const&)>,std::function<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>>((__int128 *)__p, &v36, &v35, &v34, &v33, &v29, &v28, &v27, &v32, (uint64_t)v39, (uint64_t)v37);
  *a9 = v32;
  v16 = v38;
  if (v38 == v37)
  {
    v17 = 4;
    v16 = v37;
  }
  else
  {
    if (!v38)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_6:
  v18 = v40;
  if (v40 == v39)
  {
    v19 = 4;
    v18 = v39;
  }
  else
  {
    if (!v40)
      goto LABEL_11;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_11:
  v20 = v27;
  v27 = 0;
  if (v20)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
  v21 = (std::__shared_weak_count *)*((_QWORD *)&v28 + 1);
  if (*((_QWORD *)&v28 + 1))
  {
    v22 = (unint64_t *)(*((_QWORD *)&v28 + 1) + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = (std::__shared_weak_count *)*((_QWORD *)&v29 + 1);
  if (*((_QWORD *)&v29 + 1))
  {
    v25 = (unint64_t *)(*((_QWORD *)&v29 + 1) + 8);
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  if (SHIBYTE(v31) < 0)
    operator delete(__p[0]);
}

void sub_1E0587D14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,char *a32)
{
  char *v32;
  uint64_t v33;
  char *v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;

  v35 = a32;
  if (a32 == v32)
  {
    v36 = 4;
    v35 = &a29;
  }
  else
  {
    if (!a32)
      goto LABEL_6;
    v36 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v35 + 8 * v36))();
LABEL_6:
  v37 = *(_QWORD **)(v33 - 96);
  if (v37 == (_QWORD *)(v33 - 120))
  {
    v38 = 4;
    v37 = (_QWORD *)(v33 - 120);
  }
  else
  {
    if (!v37)
      goto LABEL_11;
    v38 = 5;
  }
  (*(void (**)(void))(*v37 + 8 * v38))();
LABEL_11:
  if (a12)
    (*(void (**)(uint64_t))(*(_QWORD *)a12 + 8))(a12);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  if (a22 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void MIL::IROperator::Make(__int128 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, __int128 *a6@<X5>, __int128 *a7@<X6>, uint64_t *a8@<X7>, _QWORD *a9@<X8>, uint64_t a10, uint64_t a11)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v15 = a3;
  v16 = a2;
  v13 = a5;
  v14 = a4;
  std::make_unique[abi:ne180100]<IROperatorImpl,std::string,unsigned long long &,unsigned long long &,unsigned long long &,unsigned long long &,std::shared_ptr<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>,std::shared_ptr<std::vector<std::shared_ptr<MIL::IRParameter>>>,std::unique_ptr<MIL::IRMemoryEffect>,std::function<MIL::ValidationResult ()(MIL::IROperation const&)>,std::function<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>>(a1, &v16, &v15, &v14, &v13, a6, a7, a8, &v12, a10, a11);
  *a9 = v12;
}

void std::make_unique[abi:ne180100]<IROperatorImpl,std::string,unsigned long long &,unsigned long long &,unsigned long long &,unsigned long long &,std::shared_ptr<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>,std::shared_ptr<std::vector<std::shared_ptr<MIL::IRParameter>>>,std::unique_ptr<MIL::IRMemoryEffect>,std::function<MIL::ValidationResult ()(MIL::IROperation const&)>,std::function<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>>(__int128 *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, __int128 *a6@<X5>, __int128 *a7@<X6>, uint64_t *a8@<X7>, uint64_t *a9@<X8>, uint64_t a10, uint64_t a11)
{
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  void *__p[2];
  uint64_t v42;
  _BYTE v43[24];
  _BYTE *v44;
  _BYTE v45[24];
  _BYTE *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v19 = operator new();
  v20 = *a1;
  v42 = *((_QWORD *)a1 + 2);
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  v21 = *a2;
  v22 = *a3;
  v23 = *a4;
  v24 = *a5;
  v40 = *a6;
  *(_OWORD *)__p = v20;
  *(_QWORD *)a6 = 0;
  *((_QWORD *)a6 + 1) = 0;
  v39 = *a7;
  *(_QWORD *)a7 = 0;
  *((_QWORD *)a7 + 1) = 0;
  v25 = *a8;
  *a8 = 0;
  v38 = v25;
  std::__function::__value_func<MIL::ValidationResult ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v45, a10);
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v43, a11);
  IROperatorImpl::IROperatorImpl(v19, (__int128 *)__p, v21, v22, v23, v24, (uint64_t)&v40, (uint64_t)&v39, &v38, (uint64_t)v45, (uint64_t)v43);
  *a9 = v19;
  v26 = v44;
  if (v44 == v43)
  {
    v27 = 4;
    v26 = v43;
  }
  else
  {
    if (!v44)
      goto LABEL_6;
    v27 = 5;
  }
  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_6:
  v28 = v46;
  if (v46 == v45)
  {
    v29 = 4;
    v28 = v45;
  }
  else
  {
    if (!v46)
      goto LABEL_11;
    v29 = 5;
  }
  (*(void (**)(void))(*v28 + 8 * v29))();
LABEL_11:
  v30 = v38;
  v38 = 0;
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  v31 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
  if (*((_QWORD *)&v39 + 1))
  {
    v32 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = (std::__shared_weak_count *)*((_QWORD *)&v40 + 1);
  if (*((_QWORD *)&v40 + 1))
  {
    v35 = (unint64_t *)(*((_QWORD *)&v40 + 1) + 8);
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  if (SHIBYTE(v42) < 0)
    operator delete(__p[0]);
}

void MIL::IROperator::Make(__int128 *a1@<X0>, __int128 *a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _QWORD *a6@<X8>)
{
  __int128 v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  void *__p[2];
  uint64_t v24;
  _BYTE v25[24];
  _BYTE *v26;
  _BYTE v27[24];
  _BYTE *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v24 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  *(_QWORD *)a1 = 0;
  v22 = *a2;
  *(_OWORD *)__p = v8;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v21 = *a3;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  v20 = 0;
  std::__function::__value_func<MIL::ValidationResult ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v27, a4);
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v25, a5);
  MIL::IROperator::Make((__int128 *)__p, (uint64_t *)&v22, (char ***)&v21, &v20, (uint64_t)v27, (uint64_t)v25, a6);
  v9 = v26;
  if (v26 == v25)
  {
    v10 = 4;
    v9 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_6;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_6:
  v11 = v28;
  if (v28 == v27)
  {
    v12 = 4;
    v11 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_11;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_11:
  v13 = v20;
  v20 = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  v14 = (std::__shared_weak_count *)*((_QWORD *)&v21 + 1);
  if (*((_QWORD *)&v21 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v21 + 1) + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
  if (*((_QWORD *)&v22 + 1))
  {
    v18 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  if (SHIBYTE(v24) < 0)
    operator delete(__p[0]);
}

void sub_1E0588210(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,char *a24)
{
  char *v24;
  uint64_t v25;
  char *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;

  v27 = a24;
  if (a24 == v24)
  {
    v28 = 4;
    v27 = &a21;
  }
  else
  {
    if (!a24)
      goto LABEL_6;
    v28 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v27 + 8 * v28))();
LABEL_6:
  v29 = *(_QWORD **)(v25 - 48);
  if (v29 == (_QWORD *)(v25 - 72))
  {
    v30 = 4;
    v29 = (_QWORD *)(v25 - 72);
  }
  else
  {
    if (!v29)
      goto LABEL_11;
    v30 = 5;
  }
  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_11:
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void MIL::IROperator::Make(__int128 *a1@<X0>, uint64_t *a2@<X1>, char ***a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _QWORD *a7@<X8>)
{
  uint64_t v12;
  uint64_t **v13;
  uint64_t v14;
  uint64_t v15;
  char **v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  void *__p[2];
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _BYTE v50[24];
  _BYTE *v51;
  _BYTE v52[24];
  _BYTE *v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v12 = *a2;
  if (*a2)
  {
    v13 = *(uint64_t ***)(v12 + 16);
    if (v13)
    {
      v14 = 0;
      do
      {
        v14 += (*(unsigned int (**)(uint64_t *))(*v13[5] + 40))(v13[5]) ^ 1;
        v13 = (uint64_t **)*v13;
      }
      while (v13);
    }
    else
    {
      v14 = 0;
    }
    v15 = *(_QWORD *)(v12 + 24);
  }
  else
  {
    v14 = 0;
    v15 = -1;
  }
  v16 = *a3;
  if (*a3)
  {
    v37 = v15;
    v17 = a5;
    v18 = *v16;
    v19 = v16[1];
    if (*v16 == v19)
    {
      v20 = 0;
      v22 = *v16;
    }
    else
    {
      v20 = 0;
      do
      {
        v21 = *(_QWORD *)v18;
        v18 += 16;
        v20 += (*(unsigned int (**)(uint64_t))(*(_QWORD *)v21 + 40))(v21) ^ 1;
      }
      while (v18 != v19);
      v18 = *v16;
      v22 = v16[1];
    }
    v23 = (v22 - v18) >> 4;
    a5 = v17;
    v15 = v37;
  }
  else
  {
    v20 = 0;
    v23 = -1;
  }
  v24 = *a1;
  v44 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  *(_QWORD *)a1 = 0;
  v42 = *(_OWORD *)a2;
  *(_OWORD *)__p = v24;
  *a2 = 0;
  a2[1] = 0;
  v41 = *(_OWORD *)a3;
  *a3 = 0;
  a3[1] = 0;
  v25 = *a4;
  *a4 = 0;
  v40 = v25;
  std::__function::__value_func<MIL::ValidationResult ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v52, a5);
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v50, a6);
  v48 = v15;
  v49 = v14;
  v46 = v23;
  v47 = v20;
  std::make_unique[abi:ne180100]<IROperatorImpl,std::string,unsigned long long &,unsigned long long &,unsigned long long &,unsigned long long &,std::shared_ptr<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>,std::shared_ptr<std::vector<std::shared_ptr<MIL::IRParameter>>>,std::unique_ptr<MIL::IRMemoryEffect>,std::function<MIL::ValidationResult ()(MIL::IROperation const&)>,std::function<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>>((__int128 *)__p, &v49, &v48, &v47, &v46, &v42, &v41, &v40, &v45, (uint64_t)v52, (uint64_t)v50);
  *a7 = v45;
  v26 = v51;
  if (v51 == v50)
  {
    v27 = 4;
    v26 = v50;
  }
  else
  {
    if (!v51)
      goto LABEL_22;
    v27 = 5;
  }
  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_22:
  v28 = v53;
  if (v53 == v52)
  {
    v29 = 4;
    v28 = v52;
  }
  else
  {
    if (!v53)
      goto LABEL_27;
    v29 = 5;
  }
  (*(void (**)(void))(*v28 + 8 * v29))();
LABEL_27:
  v30 = v40;
  v40 = 0;
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  v31 = (std::__shared_weak_count *)*((_QWORD *)&v41 + 1);
  if (*((_QWORD *)&v41 + 1))
  {
    v32 = (unint64_t *)(*((_QWORD *)&v41 + 1) + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
  if (*((_QWORD *)&v42 + 1))
  {
    v35 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  if (SHIBYTE(v44) < 0)
    operator delete(__p[0]);
}

void sub_1E0588574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char *a33)
{
  char *v33;
  uint64_t v34;
  char *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;

  v36 = a33;
  if (a33 == v33)
  {
    v37 = 4;
    v36 = &a30;
  }
  else
  {
    if (!a33)
      goto LABEL_6;
    v37 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v36 + 8 * v37))();
LABEL_6:
  v38 = *(_QWORD **)(v34 - 104);
  if (v38 == (_QWORD *)(v34 - 128))
  {
    v39 = 4;
    v38 = (_QWORD *)(v34 - 128);
  }
  else
  {
    if (!v38)
      goto LABEL_11;
    v39 = 5;
  }
  (*(void (**)(void))(*v38 + 8 * v39))();
LABEL_11:
  if (a14)
    (*(void (**)(uint64_t))(*(_QWORD *)a14 + 8))(a14);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  if (a24 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IROperator::MakeParameterMap@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD v4[2];

  v4[0] = a1;
  v4[1] = a2;
  return std::allocate_shared[abi:ne180100]<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>,std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>,std::initializer_list<std::pair<std::string const,std::shared_ptr<MIL::IRParameter>>> &,void>((uint64_t)v4, a3);
}

_QWORD *MIL::IROperator::MakeParameterVec@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD v4[2];

  v4[0] = a1;
  v4[1] = a2;
  return std::allocate_shared[abi:ne180100]<std::vector<std::shared_ptr<MIL::IRParameter>>,std::allocator<std::vector<std::shared_ptr<MIL::IRParameter>>>,std::initializer_list<std::shared_ptr<MIL::IRParameter>> &,void>((uint64_t)v4, a3);
}

uint64_t IRParameterImpl::GetValidTypes(IRParameterImpl *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t IRParameterImpl::IsConst(IRParameterImpl *this)
{
  return *((unsigned __int8 *)this + 24);
}

uint64_t IRParameterImpl::SetConst(uint64_t this, char a2)
{
  *(_BYTE *)(this + 24) = a2;
  return this;
}

uint64_t IRParameterImpl::IsOptional(IRParameterImpl *this)
{
  return *((unsigned __int8 *)this + 25);
}

void IRParameterImpl::SetOptional(IRParameterImpl *this, char a2)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  __int128 v5;

  *((_BYTE *)this + 25) = a2;
  if ((a2 & 1) == 0)
  {
    v5 = 0uLL;
    std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]((uint64_t)this + 32, &v5);
    v2 = (std::__shared_weak_count *)*((_QWORD *)&v5 + 1);
    if (*((_QWORD *)&v5 + 1))
    {
      v3 = (unint64_t *)(*((_QWORD *)&v5 + 1) + 8);
      do
        v4 = __ldaxr(v3);
      while (__stlxr(v4 - 1, v3));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
  }
}

uint64_t IRParameterImpl::IsVariadic(IRParameterImpl *this)
{
  return *((unsigned __int8 *)this + 26);
}

uint64_t IRParameterImpl::SetVariadic(uint64_t this, char a2)
{
  *(_BYTE *)(this + 26) = a2;
  return this;
}

BOOL IRParameterImpl::IsValidType(IRParameterImpl *this, const MIL::IRValueType *a2, const MIL::IRValueType *a3)
{
  uint64_t v4;

  v4 = *((_QWORD *)this + 1) + 16;
  do
    v4 = *(_QWORD *)v4;
  while (v4 && !MIL::IsEqualOrStrongerType(*(MIL **)(v4 + 16), a2, a3));
  return v4 != 0;
}

BOOL IRParameterImpl::HasDefaultValue(IRParameterImpl *this)
{
  return *((_QWORD *)this + 4) != 0;
}

uint64_t IRParameterImpl::GetDefaultValue(IRParameterImpl *this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = *((_QWORD *)this + 4);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Default value has not been set.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05887A8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t IRParameterImpl::TryGetDefaultValue(IRParameterImpl *this)
{
  return *((_QWORD *)this + 4);
}

uint64_t IRParameterImpl::TryGetDefaultValueSharedPtr@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 40);
  *a2 = *(_QWORD *)(this + 32);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t IRParameterImpl::SetDefaultValue(uint64_t a1, __int128 *a2)
{
  const MIL::IRValueType *v4;
  const MIL::IRValueType *v5;
  uint64_t v6;
  std::runtime_error *exception;

  if (!*(_BYTE *)(a1 + 25))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot set a default value for a non-optional IRParameter.");
LABEL_7:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  v5 = (const MIL::IRValueType *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)a2 + 32))(*(_QWORD *)a2);
  v6 = *(_QWORD *)(a1 + 8) + 16;
  do
  {
    v6 = *(_QWORD *)v6;
    if (!v6)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Default value does not have a permitted type for this IRParameter.");
      goto LABEL_7;
    }
  }
  while ((MIL::IsEqualOrStrongerType(*(MIL **)(v6 + 16), v5, v4) & 1) == 0);
  return std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100](a1 + 32, a2);
}

void sub_1E05888A0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t IROperatorImpl::GetName(IROperatorImpl *this)
{
  return (uint64_t)this + 8;
}

uint64_t IROperatorImpl::GetMinInputs(IROperatorImpl *this)
{
  return *((_QWORD *)this + 4);
}

uint64_t IROperatorImpl::GetMaxInputs(IROperatorImpl *this)
{
  return *((_QWORD *)this + 5);
}

uint64_t IROperatorImpl::GetMinOutputs(IROperatorImpl *this)
{
  return *((_QWORD *)this + 6);
}

uint64_t IROperatorImpl::GetMaxOutputs(IROperatorImpl *this)
{
  return *((_QWORD *)this + 7);
}

uint64_t IROperatorImpl::AddConstraints(uint64_t a1, uint64_t a2)
{
  return std::vector<std::shared_ptr<MIL::Validation::Constraints const>>::push_back[abi:ne180100]((char **)(a1 + 64), a2);
}

uint64_t IROperatorImpl::GetParameters(IROperatorImpl *this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = *((_QWORD *)this + 11);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Operator parameters have not been defined.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E0588938(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t IROperatorImpl::TryGetParameters(IROperatorImpl *this)
{
  return *((_QWORD *)this + 11);
}

uint64_t IROperatorImpl::GetOutputs(IROperatorImpl *this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = *((_QWORD *)this + 13);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Operator outputs have not been defined.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05889A4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t IROperatorImpl::TryGetOutputs(IROperatorImpl *this)
{
  return *((_QWORD *)this + 13);
}

void IROperatorImpl::Validate(IROperatorImpl *this@<X0>, const MIL::IROperation *a2@<X1>, MIL::ValidationResult *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  MIL::IRArgument **v11;
  MIL::IRArgument **v12;
  uint64_t Name;
  __int128 v14;
  _QWORD *v15;
  _QWORD *v16;
  BOOL v17;
  uint64_t v18;
  std::runtime_error *exception;
  std::string __p;
  unsigned __int8 *v21[3];
  void **v22[6];
  int v23;

  IROperatorImpl::ValidateInputs(this, a2, (MIL::ValidationResult *)v22);
  if (((*((uint64_t (**)(void ***))v22[0] + 2))(v22) & 1) != 0
    && (MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v22),
        IROperatorImpl::ValidateOutputs(this, a2, (MIL::ValidationResult *)v22),
        ((*((uint64_t (**)(void ***))v22[0] + 2))(v22) & 1) != 0)
    && (MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v22),
        IROperatorImpl::ValidateAttributes(this, a2, (MIL::ValidationResult *)v22),
        ((*((uint64_t (**)(void ***))v22[0] + 2))(v22) & 1) != 0))
  {
    MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v22);
    v6 = (_QWORD *)*((_QWORD *)this + 8);
    v7 = (_QWORD *)*((_QWORD *)this + 9);
    while (v6 != v7)
    {
      (*(void (**)(void ***__return_ptr, _QWORD, const MIL::IROperation *))(*(_QWORD *)*v6 + 16))(v22, *v6, a2);
      if (((*((uint64_t (**)(void ***))v22[0] + 2))(v22) & 1) == 0)
        goto LABEL_29;
      MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v22);
      v6 += 2;
    }
    (*(void (**)(unsigned __int8 **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(v21, a2);
    std::unordered_set<std::string>::unordered_set<std::__wrap_iter<std::string*>>((uint64_t)v22, v21[0], v21[1]);
    v8 = (_QWORD *)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
    v9 = v8 + 1;
    v10 = (_QWORD *)*v8;
    if ((_QWORD *)*v8 != v8 + 1)
    {
      do
      {
        v11 = (MIL::IRArgument **)v10[7];
        v12 = (MIL::IRArgument **)v10[8];
        while (v11 != v12)
        {
          if (((*(uint64_t (**)(MIL::IRArgument *))(*(_QWORD *)*v11 + 24))(*v11) & 1) == 0)
          {
            Name = MIL::IRArgument::GetName(*v11);
            if (*(char *)(Name + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)Name, *(_QWORD *)(Name + 8));
            }
            else
            {
              v14 = *(_OWORD *)Name;
              __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(Name + 16);
              *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v14;
            }
            if (std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v22, (unsigned __int8 *)&__p))
            {
              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(exception, "Operator argument and output names must not be the same.");
              __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
            }
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
          }
          v11 += 2;
        }
        v15 = (_QWORD *)v10[1];
        if (v15)
        {
          do
          {
            v16 = v15;
            v15 = (_QWORD *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            v16 = (_QWORD *)v10[2];
            v17 = *v16 == (_QWORD)v10;
            v10 = v16;
          }
          while (!v17);
        }
        v10 = v16;
      }
      while (v16 != v9);
    }
    v18 = *((_QWORD *)this + 18);
    if (v18)
      (*(void (**)(uint64_t, const MIL::IROperation *))(*(_QWORD *)v18 + 48))(v18, a2);
    else
      MIL::ValidationResult::ValidationResult(a3);
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v22);
    v22[0] = (void **)v21;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v22);
  }
  else
  {
LABEL_29:
    MIL::MILResult::MILResult((std::string *)a3, (uint64_t)v22);
    *(_QWORD *)a3 = &off_1EA99F170;
    *((_DWORD *)a3 + 12) = v23;
    MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v22);
  }
}

void sub_1E0588C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)&a19);
  _Unwind_Resume(a1);
}

BOOL IROperatorImpl::DefinesConstant(IROperatorImpl *this)
{
  return *((_QWORD *)this + 22) || *((_QWORD *)this + 45) != 0;
}

uint64_t IROperatorImpl::GetConstant@<X0>(IROperatorImpl *this@<X0>, const MIL::IROperation *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t result;

  result = *((_QWORD *)this + 22);
  if (result)
    return (*(uint64_t (**)(uint64_t, const MIL::IROperation *))(*(_QWORD *)result + 48))(result, a2);
  *a3 = 0;
  a3[1] = 0;
  return result;
}

_QWORD *IROperatorImpl::GetCallee@<X0>(IROperatorImpl *this@<X0>, const MIL::IROperation *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  v3 = *((_QWORD *)this + 26);
  if (v3)
    return (_QWORD *)(*(uint64_t (**)(uint64_t, const MIL::IROperation *))(*(_QWORD *)v3 + 48))(v3, a2);
  else
    return std::string::basic_string[abi:ne180100]<0>(a3, "");
}

BOOL IROperatorImpl::IsCall(IROperatorImpl *this)
{
  return *((_QWORD *)this + 26) != 0;
}

_QWORD *IROperatorImpl::SetGetCalleeFunction(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<std::string ()(MIL::IROperation const&)>::operator=[abi:ne180100]((_QWORD *)(a1 + 184), a2);
}

_QWORD *IROperatorImpl::SetGetConstantFunction(uint64_t a1, uint64_t a2)
{
  return std::function<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::operator=((_QWORD *)(a1 + 152), a2);
}

_QWORD *IROperatorImpl::SetSetConstantFunction(_QWORD *a1, uint64_t a2)
{
  std::runtime_error *exception;

  if (!a1[22] && !a1[45])
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot add SetConstantFunction to an IROperator that does not define a constant.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return std::__function::__value_func<std::string ()(MIL::IROperation const&)>::operator=[abi:ne180100](a1 + 27, a2);
}

void sub_1E0588E00(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void IROperatorImpl::SetConstant(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  std::runtime_error *exception;
  __int128 v8;

  if (!*(_QWORD *)(a1 + 240))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "No SetConstantFunction is defined for this IROperator.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  v8 = *a3;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  v3 = *(_QWORD *)(a1 + 240);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t, __int128 *))(*(_QWORD *)v3 + 48))(v3, a2, &v8);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1E0588ED4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t IROperatorImpl::GetAttributes(IROperatorImpl *this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = *((_QWORD *)this + 31);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Operator attributes have not been defined.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E0588F48(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t IROperatorImpl::TryGetAttributes(IROperatorImpl *this)
{
  return *((_QWORD *)this + 31);
}

uint64_t IROperatorImpl::SetAttributes(uint64_t a1, __int128 *a2)
{
  return std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100](a1 + 248, a2);
}

void IROperatorImpl::InferOutputValueTypes(_QWORD *a1, uint64_t a2, uint64_t *a3, _QWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::string *v19;
  __int128 v20;
  std::string *p_p;
  std::string::size_type size;
  std::runtime_error *exception;
  void *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  void (**v27)(MIL::ValidationResult *__hidden);
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  int v31;
  std::string v32;
  std::string __p;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  int v38;

  if (!a1[36])
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v34);
    std::operator+<char>();
    v19 = std::string::append(&v32, " ValueTypeInferenceFunction has not been defined.");
    v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v32.__r_.__value_.__l.__data_);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &__p);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  IROperatorImpl::ValidateInputs(a1, a3, a4, (MIL::ValidationResult *)&v34);
  if (!MIL::ValidationResult::IsGood((MIL::ValidationResult *)&v34))
  {
    v24 = __cxa_allocate_exception(0x48uLL);
    v28 = v35;
    v35 = 0uLL;
    v29 = v36;
    v30 = v37;
    v36 = 0uLL;
    v37 = 0;
    v27 = &off_1EA99F170;
    v31 = v38;
    MIL::ValidationError::ValidationError(v24, &v27);
  }
  v12 = a3[1];
  v25 = *a3;
  v26 = (std::__shared_weak_count *)v12;
  if (v12)
  {
    v13 = (unint64_t *)(v12 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = a1[36];
  if (!v15)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t, uint64_t *, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v15 + 48))(v15, a2, &v25, a4, a5, a6);
  v16 = v26;
  if (v26)
  {
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)&v34);
}

void sub_1E05891C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
  void *v30;
  int v31;

  if (a29 < 0)
  {
    operator delete(__p);
    if ((v31 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a30);
      _Unwind_Resume(a1);
    }
  }
  else if (!v31)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v30);
  goto LABEL_6;
}

_QWORD *IROperatorImpl::SetValueTypeInferenceFunction(uint64_t a1, uint64_t a2)
{
  return std::function<std::vector<MIL::IRValueType const*> ()(std::shared_ptr<MIL::MILContext> const&,std::shared_ptr<MIL::Location const>,std::unordered_map<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&,std::vector<std::vector<MIL::IRValueType const*>> const&)>::operator=((_QWORD *)(a1 + 264), a2);
}

uint64_t IROperatorImpl::InferOutputValues(_QWORD *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t *i;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  std::string::size_type size;
  std::string::size_type v17;
  uint64_t v18;
  unint64_t v19;
  int64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  _QWORD *v25;
  std::string::size_type v26;
  std::string::size_type v27;
  __int128 v28;
  int64x2_t v29;
  std::string::size_type v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *p_shared_owners;
  unint64_t v34;
  std::string *v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::string *v44;
  __int128 v45;
  void **v46;
  uint64_t v47;
  std::runtime_error *exception;
  void *v49;
  uint64_t v57;
  std::__shared_weak_count *v58;
  void (**v59)(MIL::ValidationResult *__hidden);
  int64x2_t v60;
  __int128 v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  std::__shared_weak_count *v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  void *__p[2];
  __int128 v70;
  int v71;
  std::string v72;
  std::string *v73;
  int64x2_t v74;
  __int128 v75;
  uint64_t v76;
  int v77;

  if (!a1[40])
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v73);
    std::operator+<char>();
    v44 = std::string::append(&v72, " ValueInferenceFunction has not been defined.");
    v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    *(_QWORD *)&v70 = *((_QWORD *)&v44->__r_.__value_.__l + 2);
    *(_OWORD *)__p = v45;
    v44->__r_.__value_.__l.__size_ = 0;
    v44->__r_.__value_.__r.__words[2] = 0;
    v44->__r_.__value_.__r.__words[0] = 0;
    if ((SBYTE7(v70) & 0x80u) == 0)
      v46 = __p;
    else
      v46 = (void **)__p[0];
    if ((SBYTE7(v70) & 0x80u) == 0)
      v47 = BYTE7(v70);
    else
      v47 = (uint64_t)__p[1];
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v73, (uint64_t)v46, v47);
    if (SBYTE7(v70) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v72.__r_.__value_.__l.__data_);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, (const std::string *)__p);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  *(_OWORD *)__p = 0u;
  v70 = 0u;
  v71 = 1065353216;
  for (i = *(uint64_t **)(a4 + 16); i; i = (uint64_t *)*i)
  {
    memset(&v72, 0, sizeof(v72));
    v8 = (uint64_t *)i[5];
    v9 = (uint64_t *)i[6];
    while (v8 != v9)
    {
      v10 = v8[1];
      v64 = *v8;
      v65 = (std::__shared_weak_count *)v10;
      if (v10)
      {
        v11 = (unint64_t *)(v10 + 8);
        do
          v12 = __ldxr(v11);
        while (__stxr(v12 + 1, v11));
      }
      MIL::IRTypedArgument::Make(&v64, &v66);
      v13 = v66;
      v67 = v66;
      if (v66)
      {
        v14 = (_QWORD *)operator new();
        v15 = v66;
        *v14 = &unk_1EA994910;
        v14[1] = 0;
        v14[2] = 0;
        v14[3] = v15;
      }
      else
      {
        v14 = 0;
      }
      v68 = v14;
      v66 = 0;
      size = v72.__r_.__value_.__l.__size_;
      if (v72.__r_.__value_.__l.__size_ >= v72.__r_.__value_.__r.__words[2])
      {
        v18 = (uint64_t)(v72.__r_.__value_.__l.__size_ - v72.__r_.__value_.__r.__words[0]) >> 4;
        v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 60)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v20 = v72.__r_.__value_.__r.__words[2] - v72.__r_.__value_.__r.__words[0];
        if ((uint64_t)(v72.__r_.__value_.__r.__words[2] - v72.__r_.__value_.__r.__words[0]) >> 3 > v19)
          v19 = v20 >> 3;
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0)
          v21 = 0xFFFFFFFFFFFFFFFLL;
        else
          v21 = v19;
        *((_QWORD *)&v75 + 1) = (char *)&v72.__r_.__value_.__l + 16;
        v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)&v72.__r_.__value_.__r.__words[2], v21);
        v24 = &v22[16 * v18];
        *(_QWORD *)v24 = v13;
        *((_QWORD *)v24 + 1) = v14;
        v67 = 0;
        v68 = 0;
        v25 = (_QWORD *)v72.__r_.__value_.__l.__size_;
        v26 = v72.__r_.__value_.__r.__words[0];
        if (v72.__r_.__value_.__l.__size_ == v72.__r_.__value_.__r.__words[0])
        {
          v29 = vdupq_n_s64(v72.__r_.__value_.__l.__size_);
          v27 = (std::string::size_type)&v22[16 * v18];
        }
        else
        {
          v27 = (std::string::size_type)&v22[16 * v18];
          do
          {
            v28 = *((_OWORD *)v25 - 1);
            v25 -= 2;
            *(_OWORD *)(v27 - 16) = v28;
            v27 -= 16;
            *v25 = 0;
            v25[1] = 0;
          }
          while (v25 != (_QWORD *)v26);
          v29 = *(int64x2_t *)&v72.__r_.__value_.__l.__data_;
        }
        v17 = (std::string::size_type)(v24 + 16);
        v72.__r_.__value_.__r.__words[0] = v27;
        v72.__r_.__value_.__l.__size_ = (std::string::size_type)(v24 + 16);
        v74 = v29;
        v30 = v72.__r_.__value_.__r.__words[2];
        v72.__r_.__value_.__r.__words[2] = (std::string::size_type)&v22[16 * v23];
        *(_QWORD *)&v75 = v30;
        v73 = (std::string *)v29.i64[0];
        std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v73);
      }
      else
      {
        *(_QWORD *)v72.__r_.__value_.__l.__size_ = v13;
        *(_QWORD *)(size + 8) = v14;
        v17 = size + 16;
        v67 = 0;
        v68 = 0;
      }
      v72.__r_.__value_.__l.__size_ = v17;
      v31 = v66;
      v66 = 0;
      if (v31)
        (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
      v32 = v65;
      if (v65)
      {
        p_shared_owners = (unint64_t *)&v65->__shared_owners_;
        do
          v34 = __ldaxr(p_shared_owners);
        while (__stlxr(v34 - 1, p_shared_owners));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
      }
      v8 += 2;
    }
    v73 = (std::string *)(i + 2);
    v35 = (std::string *)(std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)__p, (unsigned __int8 *)i + 16, (uint64_t)&std::piecewise_construct, (__int128 **)&v73)+ 40);
    if (v35 != &v72)
      std::vector<std::shared_ptr<MIL::IRArgument>>::__assign_with_size[abi:ne180100]<std::shared_ptr<MIL::IRArgument> const*,std::shared_ptr<MIL::IRArgument> const*>((uint64_t)v35, (uint64_t *)v72.__r_.__value_.__l.__data_, (uint64_t *)v72.__r_.__value_.__l.__size_, (uint64_t)(v72.__r_.__value_.__l.__size_ - v72.__r_.__value_.__r.__words[0]) >> 4);
    v73 = &v72;
    std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v73);
  }
  IROperatorImpl::ValidateInputs(a1, a3, __p, (MIL::ValidationResult *)&v73);
  if (!MIL::ValidationResult::IsGood((MIL::ValidationResult *)&v73))
  {
    v49 = __cxa_allocate_exception(0x48uLL);
    v60 = v74;
    v74 = 0uLL;
    v61 = v75;
    v62 = v76;
    v75 = 0uLL;
    v76 = 0;
    v59 = &off_1EA99F170;
    v63 = v77;
    MIL::ValidationError::ValidationError(v49, &v59);
  }
  v36 = a3[1];
  v57 = *a3;
  v58 = (std::__shared_weak_count *)v36;
  if (v36)
  {
    v37 = (unint64_t *)(v36 + 8);
    do
      v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
  }
  LODWORD(v72.__r_.__value_.__l.__data_) = a7;
  v39 = a1[40];
  if (!v39)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, std::string *))(*(_QWORD *)v39 + 48))(v39, a2, &v57, a4, a5, a6, &v72);
  v40 = v58;
  if (v58)
  {
    v41 = (unint64_t *)&v58->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)&v73);
  return std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table((uint64_t)__p);
}

void sub_1E058973C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46)
{
  void *v46;
  int v47;

  if (a36 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a46);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

_QWORD *IROperatorImpl::SetValueInferenceFunction(uint64_t a1, uint64_t a2)
{
  return std::function<std::vector<std::shared_ptr<MIL::IRValue const>> ()(std::shared_ptr<MIL::MILContext> const&,std::shared_ptr<MIL::Location const>,std::unordered_map<std::string,std::vector<std::shared_ptr<MIL::IRValue const>>> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&,std::vector<std::shared_ptr<MIL::IRBlock>> const&,int)>::operator=((_QWORD *)(a1 + 296), a2);
}

BOOL IROperatorImpl::HasValueInferenceFunction(IROperatorImpl *this)
{
  return *((_QWORD *)this + 40) != 0;
}

BOOL IROperatorImpl::HasValueTypeInferenceFunction(IROperatorImpl *this)
{
  return *((_QWORD *)this + 36) != 0;
}

uint64_t IROperatorImpl::GetMemoryEffect(IROperatorImpl *this)
{
  return *((_QWORD *)this + 41);
}

uint64_t IROperatorImpl::GetConstants@<X0>(IROperatorImpl *this@<X0>, const MIL::IROperation *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  std::string::size_type v7;
  unint64_t *v8;
  unint64_t v9;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  std::string::size_type size;
  std::runtime_error *exception;
  std::string __p;
  _QWORD *v17;
  char v18;
  std::string v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 22);
  v5 = *((_QWORD *)this + 45);
  if (!v4)
  {
    if (!v5)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v17);
      std::operator+<char>();
      v11 = std::string::append(&__p, " GetConstantFunction or GetConstantsFunction has not been defined.");
      v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      v19.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v13 = &v19;
      else
        v13 = (std::string *)v19.__r_.__value_.__r.__words[0];
      if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v19.__r_.__value_.__r.__words[2]);
      else
        size = v19.__r_.__value_.__l.__size_;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, (uint64_t)v13, size);
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v19.__r_.__value_.__l.__data_);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::runtime_error::runtime_error(exception, &v19);
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
    }
    return (*(uint64_t (**)(uint64_t, const MIL::IROperation *))(*(_QWORD *)v5 + 48))(v5, a2);
  }
  if (v5)
    return (*(uint64_t (**)(uint64_t, const MIL::IROperation *))(*(_QWORD *)v5 + 48))(v5, a2);
  (*(void (**)(std::string *__return_ptr, uint64_t, const MIL::IROperation *))(*(_QWORD *)v4 + 48))(&v19, v4, a2);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v17 = a3;
  v18 = 0;
  v6 = operator new(0x10uLL);
  *a3 = v6;
  a3[1] = v6;
  a3[2] = v6 + 2;
  v7 = v19.__r_.__value_.__l.__size_;
  *v6 = v19.__r_.__value_.__r.__words[0];
  v6[1] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  a3[1] = v6 + 2;
  return std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&v19);
}

void sub_1E0589A78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  void *v15;
  int v16;
  uint64_t v17;

  if (*(char *)(v17 - 41) < 0)
  {
    operator delete(*(void **)(v17 - 64));
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

_QWORD *IROperatorImpl::SetGetConstantsFunction(uint64_t a1, uint64_t a2)
{
  return std::function<std::vector<std::shared_ptr<MIL::IRValue const>> ()(MIL::IROperation const&)>::operator=((_QWORD *)(a1 + 336), a2);
}

uint64_t std::vector<std::shared_ptr<MIL::Validation::Constraints const>>::push_back[abi:ne180100](char **a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  int64x2_t v20;
  char *v21;
  uint64_t v22;
  int64x2_t v23;
  char *v24;
  uint64_t v25;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v9 = (v7 - *a1) >> 4;
    if ((unint64_t)(v9 + 1) >> 60)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - (_QWORD)*a1;
    v11 = v10 >> 3;
    if (v10 >> 3 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    v25 = result;
    v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>(result, v12);
    v15 = &v13[16 * v9];
    *(_OWORD *)v15 = *(_OWORD *)a2;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    v17 = *a1;
    v16 = a1[1];
    if (v16 == *a1)
    {
      v20 = vdupq_n_s64((unint64_t)v16);
      v18 = &v13[16 * v9];
    }
    else
    {
      v18 = &v13[16 * v9];
      do
      {
        v19 = *((_OWORD *)v16 - 1);
        v16 -= 16;
        *((_OWORD *)v18 - 1) = v19;
        v18 -= 16;
        *(_QWORD *)v16 = 0;
        *((_QWORD *)v16 + 1) = 0;
      }
      while (v16 != v17);
      v20 = *(int64x2_t *)a1;
    }
    v8 = v15 + 16;
    *a1 = v18;
    a1[1] = v15 + 16;
    v23 = v20;
    v21 = a1[2];
    a1[2] = &v13[16 * v14];
    v24 = v21;
    v22 = v20.i64[0];
    result = std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    *(_OWORD *)v7 = *(_OWORD *)a2;
    v8 = v7 + 16;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
  a1[1] = v8;
  return result;
}

void IROperatorImpl::ValidateInputs(IROperatorImpl *this@<X0>, const MIL::IROperation *a2@<X1>, MIL::ValidationResult *a3@<X8>)
{
  uint64_t *LocationPtr;
  _QWORD v7[6];
  int v8;
  _OWORD v9[2];
  int v10;
  _BYTE v11[56];

  MIL::ValidationResult::ValidationResult((MIL::ValidationResult *)v11);
  memset(v9, 0, sizeof(v9));
  v10 = 1065353216;
  MIL::Validation::OpToTypeInferenceParams(a2, (uint64_t)v9, (MIL::ValidationResult *)v7);
  if (((*(uint64_t (**)(_QWORD *))(v7[0] + 16))(v7) & 1) != 0)
  {
    MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v7);
    LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(a2);
    MIL::IRObject::GetAttributes(a2);
    IROperatorImpl::ValidateInputs(this, LocationPtr, v9, a3);
  }
  else
  {
    MIL::MILResult::MILResult((std::string *)a3, (uint64_t)v7);
    *(_QWORD *)a3 = &off_1EA99F170;
    *((_DWORD *)a3 + 12) = v8;
    MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v7);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table((uint64_t)v9);
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v11);
}

void sub_1E0589D08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table((uint64_t)va);
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)(v9 - 88));
  _Unwind_Resume(a1);
}

uint64_t IROperatorImpl::ValidateOutputs@<X0>(IROperatorImpl *this@<X0>, const MIL::IROperation *a2@<X1>, MIL::ValidationResult *a3@<X8>)
{
  std::string *v6;
  __int128 v7;
  std::string *v8;
  std::string::size_type size;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  std::string::size_type v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  unint64_t v20;
  std::string *v21;
  std::string::size_type v22;
  std::string *v23;
  std::string::value_type *v24;
  std::string::size_type v25;
  int v26;
  uint64_t *LocationPtr;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t i;
  uint64_t OutputType;
  uint64_t v38;
  std::string::size_type j;
  std::string::size_type v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t v50;
  std::string *v51;
  std::string::size_type v52;
  _QWORD *v53;
  _QWORD *v54;
  std::string *v55;
  std::string::size_type v56;
  _QWORD *v57;
  uint64_t *v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t *v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  uint64_t *v72;
  std::__shared_weak_count *v73;
  unint64_t *v74;
  unint64_t v75;
  std::string *v76;
  __int128 v77;
  unint64_t *v78;
  void *v80[2];
  std::string::size_type v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  void *v84[2];
  char v85;
  uint64_t v86;
  std::__shared_weak_count *v87;
  void *__p;
  char v89;
  uint64_t v90;
  std::__shared_weak_count *v91;
  std::string v92;
  void *v93;
  char v94;
  uint64_t v95;
  std::string v96;
  uint64_t v97;
  std::__shared_weak_count *v98;
  std::string v99;
  std::string v100;
  std::string v101;
  std::string v102;
  std::string v103;
  std::string v104;
  std::string v105;
  std::string v106;
  _DWORD v107[2];
  _OWORD v108[2];
  int v109;

  memset(v108, 0, sizeof(v108));
  v109 = 1065353216;
  if ((unint64_t)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) < *((_QWORD *)this + 6)
    || (unint64_t)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) > *((_QWORD *)this + 7))
  {
    (*(void (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
    std::operator+<char>();
    v6 = std::string::append(&v102, " number of outputs must be within the range (inclusive): ");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v103.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v103.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v101, *((_QWORD *)this + 6));
    if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v8 = &v101;
    else
      v8 = (std::string *)v101.__r_.__value_.__r.__words[0];
    if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v101.__r_.__value_.__r.__words[2]);
    else
      size = v101.__r_.__value_.__l.__size_;
    v10 = std::string::append(&v103, (const std::string::value_type *)v8, size);
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v104.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v104.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    v12 = std::string::append(&v104, " : ");
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v105.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v105.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v100, *((_QWORD *)this + 7));
    if ((v100.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v14 = &v100;
    else
      v14 = (std::string *)v100.__r_.__value_.__r.__words[0];
    if ((v100.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = HIBYTE(v100.__r_.__value_.__r.__words[2]);
    else
      v15 = v100.__r_.__value_.__l.__size_;
    v16 = std::string::append(&v105, (const std::string::value_type *)v14, v15);
    v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v106.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v106.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    v18 = std::string::append(&v106, ". Provided ");
    v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v92.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v92.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    v20 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2);
    std::to_string(&v99, v20);
    if ((v99.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v21 = &v99;
    else
      v21 = (std::string *)v99.__r_.__value_.__r.__words[0];
    if ((v99.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v22 = HIBYTE(v99.__r_.__value_.__r.__words[2]);
    else
      v22 = v99.__r_.__value_.__l.__size_;
    v23 = std::string::append(&v92, (const std::string::value_type *)v21, v22);
    v24 = (std::string::value_type *)v23->__r_.__value_.__r.__words[0];
    v25 = v23->__r_.__value_.__l.__size_;
    v107[0] = v23->__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v107 + 3) = *(_DWORD *)((char *)&v23->__r_.__value_.__r.__words[2] + 3);
    v26 = SHIBYTE(v23->__r_.__value_.__r.__words[2]);
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v99.__r_.__value_.__l.__data_);
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v92.__r_.__value_.__l.__data_);
    if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v106.__r_.__value_.__l.__data_);
    if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v100.__r_.__value_.__l.__data_);
    if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v105.__r_.__value_.__l.__data_);
    if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v104.__r_.__value_.__l.__data_);
    if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v101.__r_.__value_.__l.__data_);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v102.__r_.__value_.__l.__data_);
    LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(a2);
    v28 = (std::__shared_weak_count *)LocationPtr[1];
    v97 = *LocationPtr;
    v98 = v28;
    if (v28)
    {
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v30 = __ldxr(p_shared_owners);
      while (__stxr(v30 + 1, p_shared_owners));
    }
    if (v26 < 0)
    {
      std::string::__init_copy_ctor_external(&v96, v24, v25);
    }
    else
    {
      v96.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
      v96.__r_.__value_.__l.__size_ = v25;
      LODWORD(v96.__r_.__value_.__r.__words[2]) = v107[0];
      *(_DWORD *)((char *)&v96.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v107 + 3);
      *((_BYTE *)&v96.__r_.__value_.__s + 23) = v26;
    }
    MIL::ValidationResult::ValidationResult(a3, &v97, 310, &v96);
    if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v96.__r_.__value_.__l.__data_);
    v31 = v98;
    if (!v98)
      goto LABEL_51;
    v32 = (unint64_t *)&v98->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
      if ((v26 & 0x80000000) == 0)
        return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v108);
    }
    else
    {
LABEL_51:
      if ((v26 & 0x80000000) == 0)
        return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v108);
    }
    operator delete(v24);
    return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v108);
  }
  v34 = (_QWORD *)*((_QWORD *)this + 13);
  if (v34)
  {
    v35 = 0;
    for (i = 0; i < (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2); ++i)
    {
      OutputType = MIL::IROperation::GetOutputType(a2, i);
      if (i >= (uint64_t)(v34[1] - *v34) >> 4)
        std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
      v38 = OutputType;
      if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(*v34 + v35) + 72))(*(_QWORD *)(*v34 + v35), OutputType) & 1) == 0)
      {
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v92);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v92, (uint64_t)"Output '", 8);
        v41 = (_QWORD *)std::ostream::operator<<();
        v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)"' has incorrect type for operator '", 35);
        v43 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
        v44 = *(char *)(v43 + 23);
        if (v44 >= 0)
          v45 = v43;
        else
          v45 = *(_QWORD *)v43;
        if (v44 >= 0)
          v46 = *(unsigned __int8 *)(v43 + 23);
        else
          v46 = *(_QWORD *)(v43 + 8);
        v47 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, v45, v46);
        v48 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v47, (uint64_t)"'. Expected ", 12);
        if (i >= (uint64_t)(v34[1] - *v34) >> 4)
          std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
        v49 = v48;
        v50 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*v34 + v35) + 16))(*(_QWORD *)(*v34 + v35));
        if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v51 = &v106;
        else
          v51 = (std::string *)v106.__r_.__value_.__r.__words[0];
        if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v52 = HIBYTE(v106.__r_.__value_.__r.__words[2]);
        else
          v52 = v106.__r_.__value_.__l.__size_;
        v53 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v49, (uint64_t)v51, v52);
        v54 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v53, (uint64_t)"; got ", 6);
        (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)v38 + 56))(&v105, v38);
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v55 = &v105;
        else
          v55 = (std::string *)v105.__r_.__value_.__r.__words[0];
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v56 = HIBYTE(v105.__r_.__value_.__r.__words[2]);
        else
          v56 = v105.__r_.__value_.__l.__size_;
        v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v54, (uint64_t)v55, v56);
        v104.__r_.__value_.__s.__data_[0] = 46;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)&v104, 1);
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v105.__r_.__value_.__l.__data_);
        if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v106.__r_.__value_.__l.__data_);
        v58 = (uint64_t *)MIL::IRObject::GetLocationPtr(a2);
        v59 = (std::__shared_weak_count *)v58[1];
        v90 = *v58;
        v91 = v59;
        if (v59)
        {
          v60 = (unint64_t *)&v59->__shared_owners_;
          do
            v61 = __ldxr(v60);
          while (__stxr(v61 + 1, v60));
        }
        std::stringbuf::str();
        MIL::ValidationResult::ValidationResult(a3, &v90, 313, &__p);
        if (v89 < 0)
          operator delete(__p);
        v62 = v91;
        if (v91)
        {
          v63 = (unint64_t *)&v91->__shared_owners_;
          do
            v64 = __ldaxr(v63);
          while (__stlxr(v64 - 1, v63));
          if (!v64)
          {
            ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
            std::__shared_weak_count::__release_weak(v62);
          }
        }
        v92.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0DE4F60];
        *(std::string::size_type *)((char *)v92.__r_.__value_.__r.__words
                                  + *(_QWORD *)(v92.__r_.__value_.__r.__words[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
        v92.__r_.__value_.__l.__size_ = MEMORY[0x1E0DE4FB8] + 16;
        if (v94 < 0)
          operator delete(v93);
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        MEMORY[0x1E0C022F8](&v95);
        return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v108);
      }
      v35 += 16;
    }
  }
  (*(void (**)(std::string *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&v92, a2);
  v40 = v92.__r_.__value_.__l.__size_;
  for (j = v92.__r_.__value_.__r.__words[0]; ; j += 24)
  {
    if (j == v40)
    {
      v106.__r_.__value_.__r.__words[0] = (std::string::size_type)&v92;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v106);
      MIL::ValidationResult::ValidationResult(a3);
      return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v108);
    }
    if (*(char *)(j + 23) < 0)
      break;
    if (!*(_BYTE *)(j + 23))
      goto LABEL_106;
LABEL_67:
    if (std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v108, (unsigned __int8 *)j))
    {
      v72 = (uint64_t *)MIL::IRObject::GetLocationPtr(a2);
      v73 = (std::__shared_weak_count *)v72[1];
      v82 = *v72;
      v83 = v73;
      if (v73)
      {
        v74 = (unint64_t *)&v73->__shared_owners_;
        do
          v75 = __ldxr(v74);
        while (__stxr(v75 + 1, v74));
      }
      std::operator+<char>();
      v76 = std::string::append(&v106, "' as both an input and an output.");
      v77 = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
      v81 = v76->__r_.__value_.__r.__words[2];
      *(_OWORD *)v80 = v77;
      v76->__r_.__value_.__l.__size_ = 0;
      v76->__r_.__value_.__r.__words[2] = 0;
      v76->__r_.__value_.__r.__words[0] = 0;
      MIL::ValidationResult::ValidationResult(a3, &v82, 303, v80);
      if (SHIBYTE(v81) < 0)
        operator delete(v80[0]);
      if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v106.__r_.__value_.__l.__data_);
      v69 = v83;
      if (v83)
      {
        v78 = (unint64_t *)&v83->__shared_owners_;
        do
          v71 = __ldaxr(v78);
        while (__stlxr(v71 - 1, v78));
LABEL_125:
        if (!v71)
        {
          ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
          std::__shared_weak_count::__release_weak(v69);
        }
        goto LABEL_127;
      }
      goto LABEL_127;
    }
  }
  if (*(_QWORD *)(j + 8))
    goto LABEL_67;
LABEL_106:
  v65 = (uint64_t *)MIL::IRObject::GetLocationPtr(a2);
  v66 = (std::__shared_weak_count *)v65[1];
  v86 = *v65;
  v87 = v66;
  if (v66)
  {
    v67 = (unint64_t *)&v66->__shared_owners_;
    do
      v68 = __ldxr(v67);
    while (__stxr(v68 + 1, v67));
  }
  std::string::basic_string[abi:ne180100]<0>(v84, "Operation output names must be non-empty.");
  MIL::ValidationResult::ValidationResult(a3, &v86, 311, v84);
  if (v85 < 0)
    operator delete(v84[0]);
  v69 = v87;
  if (v87)
  {
    v70 = (unint64_t *)&v87->__shared_owners_;
    do
      v71 = __ldaxr(v70);
    while (__stlxr(v71 - 1, v70));
    goto LABEL_125;
  }
LABEL_127:
  v106.__r_.__value_.__r.__words[0] = (std::string::size_type)&v92;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v106);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v108);
}

void sub_1E058A554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  uint64_t v28;

  if (a14 < 0)
    operator delete(__p);
  if (*(char *)(v28 - 121) < 0)
    operator delete(*(void **)(v28 - 144));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  *(_QWORD *)(v28 - 144) = &a28;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v28 - 144));
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v28 - 112);
  _Unwind_Resume(a1);
}

void IROperatorImpl::ValidateAttributes(IROperatorImpl *this@<X0>, const MIL::IROperation *a2@<X1>, MIL::ValidationResult *a3@<X8>)
{
  unsigned __int8 *v6;
  _QWORD *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t *LocationPtr;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::string *v17;
  __int128 v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  void **v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  void **v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t *v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  _QWORD *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t *v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t *v64;
  void *v65;
  char v66;
  uint64_t v67;
  std::__shared_weak_count *v68;
  void *v69;
  char v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  void *__p[2];
  unsigned __int8 v74;
  void *v75[2];
  unsigned __int8 v76;
  std::string v77;
  void *v78;
  char v79;
  uint64_t v80;
  __int128 v81;
  std::string::size_type v82;
  uint64_t v83;
  std::__shared_weak_count *v84;
  char v85;

  v6 = *(unsigned __int8 **)(MIL::IRObject::GetAttributes(a2) + 16);
  if (v6)
  {
    while (1)
    {
      if (!*((_QWORD *)v6 + 5))
      {
        LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(a2);
        v14 = (std::__shared_weak_count *)LocationPtr[1];
        v83 = *LocationPtr;
        v84 = v14;
        if (v14)
        {
          p_shared_owners = (unint64_t *)&v14->__shared_owners_;
          do
            v16 = __ldxr(p_shared_owners);
          while (__stxr(v16 + 1, p_shared_owners));
        }
        std::operator+<char>();
        v17 = std::string::append(&v77, "'.");
        v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
        v82 = v17->__r_.__value_.__r.__words[2];
        v81 = v18;
        v17->__r_.__value_.__l.__size_ = 0;
        v17->__r_.__value_.__r.__words[2] = 0;
        v17->__r_.__value_.__r.__words[0] = 0;
        MIL::ValidationResult::ValidationResult(a3, &v83, 307, &v81);
        if (SHIBYTE(v82) < 0)
          operator delete((void *)v81);
        if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v77.__r_.__value_.__l.__data_);
        v19 = v84;
        if (v84)
        {
          v20 = (unint64_t *)&v84->__shared_owners_;
          do
            v21 = __ldaxr(v20);
          while (__stlxr(v21 - 1, v20));
          if (!v21)
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
        }
        return;
      }
      v7 = (_QWORD *)*((_QWORD *)this + 31);
      if (v7)
      {
        v8 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v7, v6 + 16);
        if (v8)
        {
          v9 = *((_QWORD *)v8 + 5);
          v10 = (*(uint64_t (**)(uint64_t))(**((_QWORD **)v6 + 5) + 32))(*((_QWORD *)v6 + 5));
          if (((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 72))(v9, v10) & 1) == 0)
            break;
        }
      }
      v6 = *(unsigned __int8 **)v6;
      if (!v6)
        goto LABEL_7;
    }
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v77);
    v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v77, (uint64_t)"Attribute '", 11);
    v23 = (char)v6[39];
    if (v23 >= 0)
      v24 = (uint64_t)(v6 + 16);
    else
      v24 = *((_QWORD *)v6 + 2);
    if (v23 >= 0)
      v25 = v6[39];
    else
      v25 = *((_QWORD *)v6 + 3);
    v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
    v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' has incorrect type for operator '", 35);
    v28 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
    v29 = *(char *)(v28 + 23);
    if (v29 >= 0)
      v30 = v28;
    else
      v30 = *(_QWORD *)v28;
    if (v29 >= 0)
      v31 = *(unsigned __int8 *)(v28 + 23);
    else
      v31 = *(_QWORD *)(v28 + 8);
    v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v30, v31);
    v33 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"'. Expected ", 12);
    v34 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
    if ((v76 & 0x80u) == 0)
      v35 = v75;
    else
      v35 = (void **)v75[0];
    if ((v76 & 0x80u) == 0)
      v36 = v76;
    else
      v36 = (uint64_t)v75[1];
    v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)v35, v36);
    v38 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)"; got ", 6);
    (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v10 + 56))(__p, v10);
    if ((v74 & 0x80u) == 0)
      v39 = __p;
    else
      v39 = (void **)__p[0];
    if ((v74 & 0x80u) == 0)
      v40 = v74;
    else
      v40 = (uint64_t)__p[1];
    v41 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)v39, v40);
    v85 = 46;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)&v85, 1);
    if ((char)v74 < 0)
      operator delete(__p[0]);
    if ((char)v76 < 0)
      operator delete(v75[0]);
    v42 = (uint64_t *)MIL::IRObject::GetLocationPtr(a2);
    v43 = (std::__shared_weak_count *)v42[1];
    v71 = *v42;
    v72 = v43;
    if (v43)
    {
      v44 = (unint64_t *)&v43->__shared_owners_;
      do
        v45 = __ldxr(v44);
      while (__stxr(v45 + 1, v44));
    }
    std::stringbuf::str();
    MIL::ValidationResult::ValidationResult(a3, &v71, 306, &v69);
    if (v70 < 0)
      operator delete(v69);
    v46 = v72;
    if (v72)
    {
      v47 = (unint64_t *)&v72->__shared_owners_;
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      goto LABEL_82;
    }
  }
  else
  {
LABEL_7:
    v11 = *((_QWORD *)this + 31);
    if (!v11 || (v12 = *(unsigned __int8 **)(v11 + 16)) == 0)
    {
LABEL_12:
      MIL::ValidationResult::ValidationResult(a3);
      return;
    }
    while (((*(uint64_t (**)(uint64_t))(**((_QWORD **)v12 + 5) + 40))(*((_QWORD *)v12 + 5)) & 1) != 0
         || MIL::IRObject::TryGetAttribute((uint64_t)a2, v12 + 16))
    {
      v12 = *(unsigned __int8 **)v12;
      if (!v12)
        goto LABEL_12;
    }
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v77);
    v49 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v77, (uint64_t)"Required attribute '", 20);
    v50 = (char)v12[39];
    if (v50 >= 0)
      v51 = (uint64_t)(v12 + 16);
    else
      v51 = *((_QWORD *)v12 + 2);
    if (v50 >= 0)
      v52 = v12[39];
    else
      v52 = *((_QWORD *)v12 + 3);
    v53 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v49, v51, v52);
    v54 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v53, (uint64_t)"' missing for operator '", 24);
    v55 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
    v56 = *(char *)(v55 + 23);
    if (v56 >= 0)
      v57 = v55;
    else
      v57 = *(_QWORD *)v55;
    if (v56 >= 0)
      v58 = *(unsigned __int8 *)(v55 + 23);
    else
      v58 = *(_QWORD *)(v55 + 8);
    v59 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v54, v57, v58);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"'.", 2);
    v60 = (uint64_t *)MIL::IRObject::GetLocationPtr(a2);
    v61 = (std::__shared_weak_count *)v60[1];
    v67 = *v60;
    v68 = v61;
    if (v61)
    {
      v62 = (unint64_t *)&v61->__shared_owners_;
      do
        v63 = __ldxr(v62);
      while (__stxr(v63 + 1, v62));
    }
    std::stringbuf::str();
    MIL::ValidationResult::ValidationResult(a3, &v67, 321, &v65);
    if (v66 < 0)
      operator delete(v65);
    v46 = v68;
    if (v68)
    {
      v64 = (unint64_t *)&v68->__shared_owners_;
      do
        v48 = __ldaxr(v64);
      while (__stlxr(v48 - 1, v64));
LABEL_82:
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
  }
  v77.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0DE4F60];
  *(std::string::size_type *)((char *)v77.__r_.__value_.__r.__words + *(_QWORD *)(v77.__r_.__value_.__r.__words[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v77.__r_.__value_.__l.__size_ = MEMORY[0x1E0DE4FB8] + 16;
  if (v79 < 0)
    operator delete(v78);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1E0C022F8](&v80);
}

void sub_1E058ACAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a15 < 0)
    operator delete(__p);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  std::ostringstream::~ostringstream((uint64_t)&a38);
  _Unwind_Resume(a1);
}

void IROperatorImpl::ValidateInputs(_QWORD *a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X2>, MIL::ValidationResult *a4@<X8>)
{
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  char v19;
  std::string::size_type size;
  MIL::IRTypedArgument **v21;
  char v22;
  _BOOL4 IsValueType;
  unsigned int (*v24)(void);
  uint64_t ValueType;
  uint64_t Value;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  std::string *v35;
  __int128 v36;
  std::string *v37;
  std::string::size_type v38;
  std::string *v39;
  __int128 v40;
  std::string *v41;
  __int128 v42;
  std::string *v43;
  std::string::size_type v44;
  std::string *v45;
  __int128 v46;
  std::string *v47;
  __int128 v48;
  std::string *v49;
  std::string::size_type v50;
  std::string *v51;
  std::string::value_type *v52;
  std::string::size_type v53;
  int v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  std::string *v64;
  __int128 v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  _QWORD *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  _QWORD *v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  _QWORD *v82;
  uint64_t v83;
  std::string *v84;
  std::string::size_type v85;
  _QWORD *v86;
  _QWORD *v87;
  std::string *v88;
  std::string::size_type v89;
  _QWORD *v90;
  std::__shared_weak_count *v91;
  unint64_t *v92;
  unint64_t v93;
  std::__shared_weak_count *v94;
  unint64_t *v95;
  unint64_t v96;
  std::__shared_weak_count *v97;
  unint64_t *v98;
  unint64_t v99;
  std::string *v100;
  __int128 v101;
  unint64_t *v102;
  std::__shared_weak_count *v103;
  unint64_t *v104;
  unint64_t v105;
  std::string *v106;
  __int128 v107;
  std::string *v108;
  std::string::size_type v109;
  std::string *v110;
  __int128 v111;
  std::string *v112;
  __int128 v113;
  unint64_t *v114;
  std::__shared_weak_count *v115;
  unint64_t *v116;
  unint64_t v117;
  std::string *v118;
  __int128 v119;
  unint64_t *v120;
  std::string v121;
  uint64_t v122;
  std::__shared_weak_count *v123;
  std::string v124;
  std::string v125;
  std::string v126;
  std::string v127;
  _DWORD v128[2];
  void *v129;
  char v130;
  uint64_t v131;
  std::__shared_weak_count *v132;
  std::string __p[3];
  void *v134;
  char v135;
  uint64_t v136;
  __int128 v137;
  std::string::size_type v138;
  uint64_t v139;
  std::__shared_weak_count *v140;
  __int128 v141;
  std::string::size_type v142;
  uint64_t v143;
  std::__shared_weak_count *v144;
  std::string v145;
  std::string v146;
  std::string v147;
  __int128 v148;
  std::string::size_type v149;
  uint64_t v150;
  std::__shared_weak_count *v151;
  std::string v152;
  __int128 v153;
  std::string::size_type v154;
  uint64_t v155;
  std::__shared_weak_count *v156;
  void *v157[2];
  char v158;
  uint64_t v159;
  std::__shared_weak_count *v160;

  std::string::basic_string[abi:ne180100]<0>(__p, "");
  v8 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a3, (unsigned __int8 *)__p);
  v9 = v8;
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p[0].__r_.__value_.__l.__data_);
    if (v9)
    {
LABEL_3:
      v10 = (std::__shared_weak_count *)a2[1];
      v159 = *a2;
      v160 = v10;
      if (v10)
      {
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v12 = __ldxr(p_shared_owners);
        while (__stxr(v12 + 1, p_shared_owners));
      }
      std::string::basic_string[abi:ne180100]<0>(v157, "Operation parameter names must be non-empty.");
      MIL::ValidationResult::ValidationResult(a4, &v159, 316, v157);
      if (v158 < 0)
        operator delete(v157[0]);
      v13 = v160;
      if (v160)
      {
        v14 = (unint64_t *)&v160->__shared_owners_;
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
LABEL_11:
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
      return;
    }
  }
  else if (v8)
  {
    goto LABEL_3;
  }
  v16 = a1[11];
  if (v16 && (v17 = *(unsigned __int8 **)(v16 + 16)) != 0)
  {
    while (1)
    {
      v18 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a3, v17 + 16);
      if (v18)
      {
        memset(&v152, 0, sizeof(v152));
        std::vector<std::shared_ptr<MIL::IRTypedArgument>>::__init_with_size[abi:ne180100]<std::shared_ptr<MIL::IRTypedArgument>*,std::shared_ptr<MIL::IRTypedArgument>*>((char *)&v152, *((_QWORD **)v18 + 5), *((_QWORD **)v18 + 6), (uint64_t)(*((_QWORD *)v18 + 6) - *((_QWORD *)v18 + 5)) >> 4);
        v19 = (*(uint64_t (**)(uint64_t))(**((_QWORD **)v17 + 5) + 56))(*((_QWORD *)v17 + 5));
        size = v152.__r_.__value_.__l.__size_;
        v21 = (MIL::IRTypedArgument **)v152.__r_.__value_.__r.__words[0];
        if (v152.__r_.__value_.__l.__size_ - v152.__r_.__value_.__r.__words[0] == 16)
          v22 = 1;
        else
          v22 = v19;
        if ((v22 & 1) != 0)
        {
          while (1)
          {
            if (v21 == (MIL::IRTypedArgument **)size)
            {
              __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v152;
              std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
              goto LABEL_37;
            }
            IsValueType = MIL::IRTypedArgument::IsValueType(*v21);
            v24 = *(unsigned int (**)(void))(**((_QWORD **)v17 + 5) + 24);
            if (IsValueType)
            {
              if (v24())
              {
                v97 = (std::__shared_weak_count *)a2[1];
                v143 = *a2;
                v144 = v97;
                if (v97)
                {
                  v98 = (unint64_t *)&v97->__shared_owners_;
                  do
                    v99 = __ldxr(v98);
                  while (__stxr(v99 + 1, v98));
                }
                std::operator+<char>();
                v100 = std::string::append(__p, "' must be const");
                v101 = *(_OWORD *)&v100->__r_.__value_.__l.__data_;
                v142 = v100->__r_.__value_.__r.__words[2];
                v141 = v101;
                v100->__r_.__value_.__l.__size_ = 0;
                v100->__r_.__value_.__r.__words[2] = 0;
                v100->__r_.__value_.__r.__words[0] = 0;
                MIL::ValidationResult::ValidationResult(a4, &v143, 302, &v141);
                if (SHIBYTE(v142) < 0)
                  operator delete((void *)v141);
                if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p[0].__r_.__value_.__l.__data_);
                v66 = v144;
                if (v144)
                {
                  v102 = (unint64_t *)&v144->__shared_owners_;
                  do
                    v68 = __ldaxr(v102);
                  while (__stlxr(v68 - 1, v102));
                  goto LABEL_177;
                }
                goto LABEL_179;
              }
              ValueType = MIL::IRTypedArgument::GetValueType((MIL::IRTypedArgument::IRTypedArgumentImpl **)*v21);
            }
            else
            {
              if (v24())
              {
                Value = MIL::IRTypedArgument::GetValue((MIL::IRTypedArgument::IRTypedArgumentImpl **)*v21);
                v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)Value + 32))(Value);
                v28 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
                if (v28)
                {
                  v29 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 96))(v28);
                  v30 = *(_QWORD **)v29;
                  v31 = *(_QWORD **)(v29 + 8);
                  while (v30 != v31)
                  {
                    if (!(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v30 + 16))(*v30))
                    {
                      v61 = (std::__shared_weak_count *)a2[1];
                      v139 = *a2;
                      v140 = v61;
                      if (v61)
                      {
                        v62 = (unint64_t *)&v61->__shared_owners_;
                        do
                          v63 = __ldxr(v62);
                        while (__stxr(v63 + 1, v62));
                      }
                      std::operator+<char>();
                      v64 = std::string::append(__p, "' must be constant");
                      v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
                      v138 = v64->__r_.__value_.__r.__words[2];
                      v137 = v65;
                      v64->__r_.__value_.__l.__size_ = 0;
                      v64->__r_.__value_.__r.__words[2] = 0;
                      v64->__r_.__value_.__r.__words[0] = 0;
                      MIL::ValidationResult::ValidationResult(a4, &v139, 302, &v137);
                      if (SHIBYTE(v138) < 0)
                        operator delete((void *)v137);
                      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
                        operator delete(__p[0].__r_.__value_.__l.__data_);
                      v66 = v140;
                      if (v140)
                      {
                        v67 = (unint64_t *)&v140->__shared_owners_;
                        do
                          v68 = __ldaxr(v67);
                        while (__stlxr(v68 - 1, v67));
                        goto LABEL_177;
                      }
                      goto LABEL_179;
                    }
                    ++v30;
                  }
                }
              }
              v32 = MIL::IRTypedArgument::GetValue((MIL::IRTypedArgument::IRTypedArgumentImpl **)*v21);
              ValueType = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v32 + 32))(v32);
            }
            v33 = ValueType;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(**((_QWORD **)v17 + 5) + 72))(*((_QWORD *)v17 + 5), ValueType) & 1) == 0)
            {
              std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)__p);
              v69 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__p, (uint64_t)"Param '", 7);
              v70 = (char)v17[39];
              if (v70 >= 0)
                v71 = (uint64_t)(v17 + 16);
              else
                v71 = *((_QWORD *)v17 + 2);
              if (v70 >= 0)
                v72 = v17[39];
              else
                v72 = *((_QWORD *)v17 + 3);
              v73 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v69, v71, v72);
              v74 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)"' has incorrect type for operator '", 35);
              v77 = a1[1];
              v76 = a1 + 1;
              v75 = v77;
              v78 = *((char *)v76 + 23);
              if (v78 >= 0)
                v79 = (uint64_t)v76;
              else
                v79 = v75;
              if (v78 >= 0)
                v80 = *((unsigned __int8 *)v76 + 23);
              else
                v80 = v76[1];
              v81 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v74, v79, v80);
              v82 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v81, (uint64_t)"'. Expected ", 12);
              v83 = (*(uint64_t (**)(uint64_t))(**((_QWORD **)v17 + 5) + 16))(*((_QWORD *)v17 + 5));
              if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v84 = &v147;
              else
                v84 = (std::string *)v147.__r_.__value_.__r.__words[0];
              if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v85 = HIBYTE(v147.__r_.__value_.__r.__words[2]);
              else
                v85 = v147.__r_.__value_.__l.__size_;
              v86 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v82, (uint64_t)v84, v85);
              v87 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v86, (uint64_t)"; got ",
                      6);
              (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)v33 + 56))(&v146, v33);
              if ((v146.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v88 = &v146;
              else
                v88 = (std::string *)v146.__r_.__value_.__r.__words[0];
              if ((v146.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v89 = HIBYTE(v146.__r_.__value_.__r.__words[2]);
              else
                v89 = v146.__r_.__value_.__l.__size_;
              v90 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v87, (uint64_t)v88, v89);
              v145.__r_.__value_.__s.__data_[0] = 46;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v90, (uint64_t)&v145, 1);
              if (SHIBYTE(v146.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v146.__r_.__value_.__l.__data_);
              if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v147.__r_.__value_.__l.__data_);
              v91 = (std::__shared_weak_count *)a2[1];
              v131 = *a2;
              v132 = v91;
              if (v91)
              {
                v92 = (unint64_t *)&v91->__shared_owners_;
                do
                  v93 = __ldxr(v92);
                while (__stxr(v93 + 1, v92));
              }
              std::stringbuf::str();
              MIL::ValidationResult::ValidationResult(a4, &v131, 304, &v129);
              if (v130 < 0)
                operator delete(v129);
              v94 = v132;
              if (v132)
              {
                v95 = (unint64_t *)&v132->__shared_owners_;
                do
                  v96 = __ldaxr(v95);
                while (__stlxr(v96 - 1, v95));
                if (!v96)
                {
                  ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
                  std::__shared_weak_count::__release_weak(v94);
                }
              }
              __p[0].__r_.__value_.__r.__words[0] = *MEMORY[0x1E0DE4F60];
              *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words
                                        + *(_QWORD *)(__p[0].__r_.__value_.__r.__words[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
              __p[0].__r_.__value_.__l.__size_ = MEMORY[0x1E0DE4FB8] + 16;
              if (v135 < 0)
                operator delete(v134);
              std::streambuf::~streambuf();
              std::ostream::~ostream();
              MEMORY[0x1E0C022F8](&v136);
              goto LABEL_179;
            }
            v21 += 2;
          }
        }
        v103 = (std::__shared_weak_count *)a2[1];
        v150 = *a2;
        v151 = v103;
        if (v103)
        {
          v104 = (unint64_t *)&v103->__shared_owners_;
          do
            v105 = __ldxr(v104);
          while (__stxr(v105 + 1, v104));
        }
        std::operator+<char>();
        v106 = std::string::append(&v146, "' has ");
        v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
        v147.__r_.__value_.__r.__words[2] = v106->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v147.__r_.__value_.__l.__data_ = v107;
        v106->__r_.__value_.__l.__size_ = 0;
        v106->__r_.__value_.__r.__words[2] = 0;
        v106->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v145, (uint64_t)(v152.__r_.__value_.__l.__size_ - v152.__r_.__value_.__r.__words[0]) >> 4);
        if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v108 = &v145;
        else
          v108 = (std::string *)v145.__r_.__value_.__r.__words[0];
        if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v109 = HIBYTE(v145.__r_.__value_.__r.__words[2]);
        else
          v109 = v145.__r_.__value_.__l.__size_;
        v110 = std::string::append(&v147, (const std::string::value_type *)v108, v109);
        v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
        __p[0].__r_.__value_.__r.__words[2] = v110->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = v111;
        v110->__r_.__value_.__l.__size_ = 0;
        v110->__r_.__value_.__r.__words[2] = 0;
        v110->__r_.__value_.__r.__words[0] = 0;
        v112 = std::string::append(__p, " args bound to it, but is not declared variadic. Non-variadic params must have exactly 1 arg binding.");
        v113 = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
        v149 = v112->__r_.__value_.__r.__words[2];
        v148 = v113;
        v112->__r_.__value_.__l.__size_ = 0;
        v112->__r_.__value_.__r.__words[2] = 0;
        v112->__r_.__value_.__r.__words[0] = 0;
        MIL::ValidationResult::ValidationResult(a4, &v150, 320, &v148);
        if (SHIBYTE(v149) < 0)
          operator delete((void *)v148);
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p[0].__r_.__value_.__l.__data_);
        if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v145.__r_.__value_.__l.__data_);
        if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v147.__r_.__value_.__l.__data_);
        if (SHIBYTE(v146.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v146.__r_.__value_.__l.__data_);
        v66 = v151;
        if (v151)
        {
          v114 = (unint64_t *)&v151->__shared_owners_;
          do
            v68 = __ldaxr(v114);
          while (__stlxr(v68 - 1, v114));
LABEL_177:
          if (!v68)
          {
            ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
            std::__shared_weak_count::__release_weak(v66);
          }
        }
LABEL_179:
        __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v152;
        std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
        return;
      }
      if (((*(uint64_t (**)(uint64_t))(**((_QWORD **)v17 + 5) + 40))(*((_QWORD *)v17 + 5)) & 1) == 0)
        break;
LABEL_37:
      v17 = *(unsigned __int8 **)v17;
      if (!v17)
        goto LABEL_38;
    }
    v115 = (std::__shared_weak_count *)a2[1];
    v155 = *a2;
    v156 = v115;
    if (v115)
    {
      v116 = (unint64_t *)&v115->__shared_owners_;
      do
        v117 = __ldxr(v116);
      while (__stxr(v117 + 1, v116));
    }
    std::operator+<char>();
    v118 = std::string::append(__p, "' is missing");
    v119 = *(_OWORD *)&v118->__r_.__value_.__l.__data_;
    v154 = v118->__r_.__value_.__r.__words[2];
    v153 = v119;
    v118->__r_.__value_.__l.__size_ = 0;
    v118->__r_.__value_.__r.__words[2] = 0;
    v118->__r_.__value_.__r.__words[0] = 0;
    MIL::ValidationResult::ValidationResult(a4, &v155, 317, &v153);
    if (SHIBYTE(v154) < 0)
      operator delete((void *)v153);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__r_.__value_.__l.__data_);
    v13 = v156;
    if (v156)
    {
      v120 = (unint64_t *)&v156->__shared_owners_;
      do
        v15 = __ldaxr(v120);
      while (__stlxr(v15 - 1, v120));
      goto LABEL_11;
    }
  }
  else
  {
LABEL_38:
    v34 = a3[3];
    if (v34 >= a1[4] && v34 <= a1[5])
    {
      MIL::ValidationResult::ValidationResult(a4);
    }
    else
    {
      std::operator+<char>();
      v35 = std::string::append(&v127, "' number of inputs must be within the range (inclusive): ");
      v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
      v145.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v145.__r_.__value_.__l.__data_ = v36;
      v35->__r_.__value_.__l.__size_ = 0;
      v35->__r_.__value_.__r.__words[2] = 0;
      v35->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v126, a1[4]);
      if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v37 = &v126;
      else
        v37 = (std::string *)v126.__r_.__value_.__r.__words[0];
      if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v38 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
      else
        v38 = v126.__r_.__value_.__l.__size_;
      v39 = std::string::append(&v145, (const std::string::value_type *)v37, v38);
      v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
      v146.__r_.__value_.__r.__words[2] = v39->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v40;
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      v41 = std::string::append(&v146, " : ");
      v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
      v147.__r_.__value_.__r.__words[2] = v41->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v147.__r_.__value_.__l.__data_ = v42;
      v41->__r_.__value_.__l.__size_ = 0;
      v41->__r_.__value_.__r.__words[2] = 0;
      v41->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v125, a1[5]);
      if ((v125.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v43 = &v125;
      else
        v43 = (std::string *)v125.__r_.__value_.__r.__words[0];
      if ((v125.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v44 = HIBYTE(v125.__r_.__value_.__r.__words[2]);
      else
        v44 = v125.__r_.__value_.__l.__size_;
      v45 = std::string::append(&v147, (const std::string::value_type *)v43, v44);
      v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
      v152.__r_.__value_.__r.__words[2] = v45->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v152.__r_.__value_.__l.__data_ = v46;
      v45->__r_.__value_.__l.__size_ = 0;
      v45->__r_.__value_.__r.__words[2] = 0;
      v45->__r_.__value_.__r.__words[0] = 0;
      v47 = std::string::append(&v152, ". Provided ");
      v48 = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
      __p[0].__r_.__value_.__r.__words[2] = v47->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = v48;
      v47->__r_.__value_.__l.__size_ = 0;
      v47->__r_.__value_.__r.__words[2] = 0;
      v47->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v124, a3[3]);
      if ((v124.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v49 = &v124;
      else
        v49 = (std::string *)v124.__r_.__value_.__r.__words[0];
      if ((v124.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v50 = HIBYTE(v124.__r_.__value_.__r.__words[2]);
      else
        v50 = v124.__r_.__value_.__l.__size_;
      v51 = std::string::append(__p, (const std::string::value_type *)v49, v50);
      v52 = (std::string::value_type *)v51->__r_.__value_.__r.__words[0];
      v53 = v51->__r_.__value_.__l.__size_;
      v128[0] = v51->__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v128 + 3) = *(_DWORD *)((char *)&v51->__r_.__value_.__r.__words[2] + 3);
      v54 = SHIBYTE(v51->__r_.__value_.__r.__words[2]);
      v51->__r_.__value_.__l.__size_ = 0;
      v51->__r_.__value_.__r.__words[2] = 0;
      v51->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v124.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v124.__r_.__value_.__l.__data_);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__r_.__value_.__l.__data_);
      if (SHIBYTE(v152.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v152.__r_.__value_.__l.__data_);
      if (SHIBYTE(v125.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v125.__r_.__value_.__l.__data_);
      if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v147.__r_.__value_.__l.__data_);
      if (SHIBYTE(v146.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v146.__r_.__value_.__l.__data_);
      if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v126.__r_.__value_.__l.__data_);
      if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v145.__r_.__value_.__l.__data_);
      if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v127.__r_.__value_.__l.__data_);
      v55 = (std::__shared_weak_count *)a2[1];
      v122 = *a2;
      v123 = v55;
      if (v55)
      {
        v56 = (unint64_t *)&v55->__shared_owners_;
        do
          v57 = __ldxr(v56);
        while (__stxr(v57 + 1, v56));
      }
      if (v54 < 0)
      {
        std::string::__init_copy_ctor_external(&v121, v52, v53);
      }
      else
      {
        v121.__r_.__value_.__r.__words[0] = (std::string::size_type)v52;
        v121.__r_.__value_.__l.__size_ = v53;
        LODWORD(v121.__r_.__value_.__r.__words[2]) = v128[0];
        *(_DWORD *)((char *)&v121.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v128 + 3);
        *((_BYTE *)&v121.__r_.__value_.__s + 23) = v54;
      }
      MIL::ValidationResult::ValidationResult(a4, &v122, 314, &v121);
      if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v121.__r_.__value_.__l.__data_);
      v58 = v123;
      if (v123)
      {
        v59 = (unint64_t *)&v123->__shared_owners_;
        do
          v60 = __ldaxr(v59);
        while (__stlxr(v60 - 1, v59));
        if (!v60)
        {
          ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
          std::__shared_weak_count::__release_weak(v58);
        }
      }
      if (v54 < 0)
        operator delete(v52);
    }
  }
}

void sub_1E058B8BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  uint64_t v38;

  if (*(char *)(v38 - 153) < 0)
    operator delete(*(void **)(v38 - 176));
  if (a38 < 0)
    operator delete(__p);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v38 - 152);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::FormatTypeSet(uint64_t a1)
{
  uint64_t **v2;
  char v3;
  _QWORD *v4;
  void **v5;
  uint64_t v6;
  void *__p[2];
  unsigned __int8 v9;
  _QWORD v10[11];
  char v11;
  uint64_t v12;

  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v10);
  LOBYTE(__p[0]) = 123;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)__p, 1);
  v2 = *(uint64_t ***)(a1 + 16);
  if (v2)
  {
    v3 = 1;
    do
    {
      if ((v3 & 1) == 0)
      {
        LOBYTE(__p[0]) = 44;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)__p, 1);
      }
      LOBYTE(__p[0]) = 32;
      v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)__p, 1);
      (*(void (**)(void **__return_ptr))(*v2[2] + 56))(__p);
      if ((v9 & 0x80u) == 0)
        v5 = __p;
      else
        v5 = (void **)__p[0];
      if ((v9 & 0x80u) == 0)
        v6 = v9;
      else
        v6 = (uint64_t)__p[1];
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v5, v6);
      if ((char)v9 < 0)
        operator delete(__p[0]);
      v3 = 0;
      v2 = (uint64_t **)*v2;
    }
    while (v2);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" }", 2);
  std::stringbuf::str();
  v10[0] = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)v10 + *(_QWORD *)(v10[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v10[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v11 < 0)
    operator delete((void *)v10[9]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E0C022F8](&v12);
}

void sub_1E058BD60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  std::ostringstream::~ostringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

char *std::vector<std::shared_ptr<MIL::IRTypedArgument>>::__init_with_size[abi:ne180100]<std::shared_ptr<MIL::IRTypedArgument>*,std::shared_ptr<MIL::IRTypedArgument>*>(char *result, _QWORD *a2, _QWORD *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  if (a4)
  {
    v6 = result;
    result = std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vallocate[abi:ne180100](result, a4);
    v7 = (_QWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      *v7 = *a2;
      v8 = a2[1];
      v7[1] = v8;
      if (v8)
      {
        v9 = (unint64_t *)(v8 + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      a2 += 2;
      v7 += 2;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1E058BE24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

std::string *MIL::MILResult::MILResult(std::string *a1, uint64_t a2)
{
  std::string::size_type v3;
  unint64_t *v4;
  unint64_t v5;
  std::string *v6;
  __int128 v7;

  a1->__r_.__value_.__r.__words[0] = (std::string::size_type)off_1EA99BF68;
  v3 = *(_QWORD *)(a2 + 16);
  a1->__r_.__value_.__l.__size_ = *(_QWORD *)(a2 + 8);
  a1->__r_.__value_.__r.__words[2] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = a1 + 1;
  if (*(char *)(a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 24), *(_QWORD *)(a2 + 32));
  }
  else
  {
    v7 = *(_OWORD *)(a2 + 24);
    a1[1].__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 40);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return a1;
}

void sub_1E058BF34(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t ***`anonymous namespace'::GetInputNames(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  MIL::IRArgument **v7;
  MIL::IRArgument **v8;
  unsigned __int8 *Name;
  _QWORD *v10;
  _QWORD *v11;
  BOOL v12;
  uint64_t ***result;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;

  v4 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
  v5 = v4 + 1;
  v6 = (_QWORD *)*v4;
  if ((_QWORD *)*v4 != v4 + 1)
  {
    do
    {
      v7 = (MIL::IRArgument **)v6[7];
      v8 = (MIL::IRArgument **)v6[8];
      while (v7 != v8)
      {
        if ((*(unsigned int (**)(MIL::IRArgument *))(*(_QWORD *)*v7 + 16))(*v7))
        {
          Name = (unsigned __int8 *)MIL::IRArgument::GetName(*v7);
          std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a2, Name, (uint64_t)Name);
        }
        v7 += 2;
      }
      v10 = (_QWORD *)v6[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v11 = (_QWORD *)v6[2];
          v12 = *v11 == (_QWORD)v6;
          v6 = v11;
        }
        while (!v12);
      }
      v6 = v11;
    }
    while (v11 != v5);
  }
  result = (uint64_t ***)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 208))(a1);
  v14 = **result;
  v15 = (*result)[1];
  while (v14 != v15)
  {
    result = (uint64_t ***)(*(uint64_t (**)(uint64_t))(*(_QWORD *)*v14 + 56))(*v14);
    v16 = **result;
    v17 = (*result)[1];
    while (v16 != v17)
    {
      v18 = *v16;
      v16 += 2;
    }
    v14 += 2;
  }
  return result;
}

uint64_t std::unordered_set<std::string>::unordered_set<std::__wrap_iter<std::string*>>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a2 != a3)
  {
    v5 = a2;
    do
    {
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a1, v5, (uint64_t)v5);
      v5 += 24;
    }
    while (v5 != a3);
  }
  return a1;
}

void sub_1E058C0C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__value_func<std::string ()(MIL::IROperation const&)>::operator=[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (_QWORD *)a1[3];
  a1[3] = 0;
  if (v4 == a1)
  {
    v5 = 4;
    v4 = a1;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  v6 = *(_QWORD *)(a2 + 24);
  if (v6)
  {
    if (v6 == a2)
    {
      a1[3] = a1;
      (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v6;
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

_QWORD *std::function<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

uint64_t std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

_QWORD *std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1E058C3D0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::function<std::vector<MIL::IRValueType const*> ()(std::shared_ptr<MIL::MILContext> const&,std::shared_ptr<MIL::Location const>,std::unordered_map<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&,std::vector<std::vector<MIL::IRValueType const*>> const&)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::vector<MIL::IRValueType const*> ()(std::shared_ptr<MIL::MILContext> const&,std::shared_ptr<MIL::Location const>,std::unordered_map<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&,std::vector<std::vector<MIL::IRValueType const*>> const&)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::__function::__value_func<std::vector<MIL::IRValueType const*> ()(std::shared_ptr<MIL::MILContext> const&,std::shared_ptr<MIL::Location const>,std::unordered_map<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&,std::vector<std::vector<MIL::IRValueType const*>> const&)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1E058C5DC(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void std::__shared_ptr_pointer<MIL::IRTypedArgument  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::IRTypedArgument  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IRTypedArgument  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_1E058C8E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;
  __int128 *v10;
  __int128 v11;

  v7 = a1 + 16;
  v8 = operator new(0x40uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
  }
  else
  {
    v11 = *v10;
    v8[4] = *((_QWORD *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  v8[5] = 0;
  v8[6] = 0;
  v8[7] = 0;
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_1E058C988(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

_QWORD *std::function<std::vector<std::shared_ptr<MIL::IRValue const>> ()(std::shared_ptr<MIL::MILContext> const&,std::shared_ptr<MIL::Location const>,std::unordered_map<std::string,std::vector<std::shared_ptr<MIL::IRValue const>>> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&,std::vector<std::shared_ptr<MIL::IRBlock>> const&,int)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::vector<std::shared_ptr<MIL::IRValue const>> ()(std::shared_ptr<MIL::MILContext> const&,std::shared_ptr<MIL::Location const>,std::unordered_map<std::string,std::vector<std::shared_ptr<MIL::IRValue const>>> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&,std::vector<std::shared_ptr<MIL::IRBlock>> const&,int)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::__function::__value_func<std::vector<std::shared_ptr<MIL::IRValue const>> ()(std::shared_ptr<MIL::MILContext> const&,std::shared_ptr<MIL::Location const>,std::unordered_map<std::string,std::vector<std::shared_ptr<MIL::IRValue const>>> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&,std::vector<std::shared_ptr<MIL::IRBlock>> const&,int)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1E058CBE4(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::function<std::vector<std::shared_ptr<MIL::IRValue const>> ()(MIL::IROperation const&)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::vector<std::shared_ptr<MIL::IRValue const>> ()(MIL::IROperation const&)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::__function::__value_func<std::vector<std::shared_ptr<MIL::IRValue const>> ()(MIL::IROperation const&)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1E058CDF0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

__n128 IRParameterImpl::IRParameterImpl(uint64_t a1, __n128 *a2, char a3, char a4, char a5)
{
  __n128 result;
  std::logic_error *exception;

  result = *a2;
  *(__n128 *)(a1 + 8) = *a2;
  *(_QWORD *)a1 = &off_1EA9946F0;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 24) = a3;
  *(_BYTE *)(a1 + 25) = a4;
  *(_BYTE *)(a1 + 26) = a5;
  *(_QWORD *)(a1 + 40) = 0;
  if (!*(_QWORD *)(a1 + 8))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "validTypeSet cannot be null");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  return result;
}

void sub_1E058CEA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a10);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<IRParameterImpl>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 + 32);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 + 8);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

_QWORD *std::allocate_shared[abi:ne180100]<std::unordered_set<MIL::IRValueType const*>,std::allocator<std::unordered_set<MIL::IRValueType const*>>,std::initializer_list<MIL::IRValueType const*> &,void>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x40uLL);
  result = std::__shared_ptr_emplace<std::unordered_set<MIL::IRValueType const*>>::__shared_ptr_emplace[abi:ne180100]<std::initializer_list<MIL::IRValueType const*> &,std::allocator<std::unordered_set<MIL::IRValueType const*>>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1E058CF64(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<std::unordered_set<MIL::IRValueType const*>>::__shared_ptr_emplace[abi:ne180100]<std::initializer_list<MIL::IRValueType const*> &,std::allocator<std::unordered_set<MIL::IRValueType const*>>,0>(_QWORD *a1, uint64_t a2)
{
  a1[2] = 0;
  *a1 = &unk_1EA994970;
  a1[1] = 0;
  std::unordered_set<MIL::IRValueType const*>::unordered_set((uint64_t)(a1 + 3), *(_QWORD **)a2, *(_QWORD *)(a2 + 8));
  return a1;
}

void sub_1E058CFB8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::unordered_set<MIL::IRValueType const*>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA994970;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::unordered_set<MIL::IRValueType const*>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA994970;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_emplace<std::unordered_set<MIL::IRValueType const*>>::__on_zero_shared(uint64_t a1)
{
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(a1 + 24);
}

uint64_t std::unordered_set<MIL::IRValueType const*>::unordered_set(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    v5 = 8 * a3;
    do
    {
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::__emplace_unique_key_args<MIL::IRValueType const*,MIL::IRValueType const* const&>(a1, a2, a2);
      ++a2;
      v5 -= 8;
    }
    while (v5);
  }
  return a1;
}

void sub_1E058D080(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::__emplace_unique_key_args<MIL::IRValueType const*,MIL::IRValueType const* const&>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_38:
    *v21 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1E058D2D0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t std::__function::__value_func<MIL::ValidationResult ()(MIL::IROperation const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t IROperatorImpl::IROperatorImpl(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t a11)
{
  __int128 v12;
  uint64_t v13;

  *(_QWORD *)a1 = &off_1EA9947D0;
  v12 = *a2;
  *(_QWORD *)(a1 + 24) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(a1 + 8) = v12;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = a4;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = a6;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 88) = *(_OWORD *)a7;
  *(_QWORD *)a7 = 0;
  *(_QWORD *)(a7 + 8) = 0;
  *(_OWORD *)(a1 + 104) = *(_OWORD *)a8;
  *(_QWORD *)a8 = 0;
  *(_QWORD *)(a8 + 8) = 0;
  std::__function::__value_func<MIL::ValidationResult ()(MIL::IROperation const&)>::__value_func[abi:ne180100](a1 + 120, a10);
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100](a1 + 152, a11);
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  v13 = *a9;
  *a9 = 0;
  *(_QWORD *)(a1 + 328) = v13;
  *(_QWORD *)(a1 + 360) = 0;
  return a1;
}

_QWORD *std::allocate_shared[abi:ne180100]<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>,std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>,std::initializer_list<std::pair<std::string const,std::shared_ptr<MIL::IRParameter>>> &,void>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x40uLL);
  result = std::__shared_ptr_emplace<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>::__shared_ptr_emplace[abi:ne180100]<std::initializer_list<std::pair<std::string const,std::shared_ptr<MIL::IRParameter>>> &,std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1E058D4F0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>::__shared_ptr_emplace[abi:ne180100]<std::initializer_list<std::pair<std::string const,std::shared_ptr<MIL::IRParameter>>> &,std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>,0>(_QWORD *a1, uint64_t a2)
{
  a1[2] = 0;
  *a1 = &unk_1EA9949C0;
  a1[1] = 0;
  std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>::unordered_map((uint64_t)(a1 + 3), *(unsigned __int8 **)a2, *(_QWORD *)(a2 + 8));
  return a1;
}

void sub_1E058D544(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA9949C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA9949C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_emplace<std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>>::__on_zero_shared(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 24);
}

uint64_t std::unordered_map<std::string,std::shared_ptr<MIL::IRParameter>>::unordered_map(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    v5 = 40 * a3;
    do
    {
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRParameter>> const&>(a1, a2, (__int128 *)a2);
      a2 += 40;
      v5 -= 40;
    }
    while (v5);
  }
  return a1;
}

void sub_1E058D610(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRParameter>> const&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>>>::__construct_node_hash<std::pair<std::string const,std::shared_ptr<MIL::IRParameter>> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1E058D88C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRParameter>>>>::__construct_node_hash<std::pair<std::string const,std::shared_ptr<MIL::IRParameter>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x38uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100]((std::string *)(v8 + 16), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1E058D900(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

_QWORD *std::allocate_shared[abi:ne180100]<std::vector<std::shared_ptr<MIL::IRParameter>>,std::allocator<std::vector<std::shared_ptr<MIL::IRParameter>>>,std::initializer_list<std::shared_ptr<MIL::IRParameter>> &,void>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x30uLL);
  result = std::__shared_ptr_emplace<std::vector<std::shared_ptr<MIL::IRParameter>>>::__shared_ptr_emplace[abi:ne180100]<std::initializer_list<std::shared_ptr<MIL::IRParameter>> &,std::allocator<std::vector<std::shared_ptr<MIL::IRParameter>>>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1E058D95C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<std::vector<std::shared_ptr<MIL::IRParameter>>>::__shared_ptr_emplace[abi:ne180100]<std::initializer_list<std::shared_ptr<MIL::IRParameter>> &,std::allocator<std::vector<std::shared_ptr<MIL::IRParameter>>>,0>(_QWORD *a1, uint64_t a2)
{
  char v4;

  a1[2] = 0;
  *a1 = &unk_1EA994A10;
  a1[1] = 0;
  std::allocator<std::vector<std::shared_ptr<MIL::IRParameter>>>::construct[abi:ne180100]<std::vector<std::shared_ptr<MIL::IRParameter>>,std::initializer_list<std::shared_ptr<MIL::IRParameter>> &>((uint64_t)&v4, a1 + 3, a2);
  return a1;
}

void sub_1E058D9BC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<MIL::IRParameter>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA994A10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<MIL::IRParameter>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA994A10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<MIL::IRParameter>>>::__on_zero_shared(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 24);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

char *std::allocator<std::vector<std::shared_ptr<MIL::IRParameter>>>::construct[abi:ne180100]<std::vector<std::shared_ptr<MIL::IRParameter>>,std::initializer_list<std::shared_ptr<MIL::IRParameter>> &>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v4;
  char *result;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  v4 = *(_QWORD **)a3;
  v3 = *(_QWORD *)(a3 + 8);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (v3)
  {
    result = std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vallocate[abi:ne180100](a2, v3);
    v7 = &v4[2 * v3];
    v8 = (_QWORD *)a2[1];
    do
    {
      *v8 = *v4;
      v9 = v4[1];
      v8[1] = v9;
      if (v9)
      {
        v10 = (unint64_t *)(v9 + 8);
        do
          v11 = __ldxr(v10);
        while (__stxr(v11 + 1, v10));
      }
      v4 += 2;
      v8 += 2;
    }
    while (v4 != v7);
    a2[1] = v8;
  }
  return result;
}

void sub_1E058DAD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void MIL::IROpset::~IROpset(MIL::IROpset *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1EA994A60;
  v3 = *((_QWORD *)this + 1);
  v1 = (_QWORD *)((char *)this + 8);
  v2 = v3;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)v1, v2);
}

void MIL::IROpset::RegisterOp(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  const void *v6;
  void *v7;
  void **v8;
  uint64_t v9;
  uint64_t v10;
  void *__dst[2];
  unint64_t v12;

  v3 = a1[1];
  v4 = (*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = (const void *)v4;
  v7 = (void *)v5;
  if (v5 >= 0x17)
  {
    v9 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v9 = v5 | 7;
    v10 = v9 + 1;
    v8 = (void **)operator new(v9 + 1);
    __dst[1] = v7;
    v12 = v10 | 0x8000000000000000;
    __dst[0] = v8;
    goto LABEL_8;
  }
  HIBYTE(v12) = v5;
  v8 = __dst;
  if (v5)
LABEL_8:
    memmove(v8, v6, (size_t)v7);
  *((_BYTE *)v7 + (_QWORD)v8) = 0;
  MIL::IROpsetImpl::RegisterOp(v3, (uint64_t)__dst, a2);
  if (SHIBYTE(v12) < 0)
    operator delete(__dst[0]);
}

void sub_1E058DC08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IROpsetImpl::RegisterOp(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  __int128 v7;
  char v8;
  char v9;
  std::runtime_error *exception;
  std::string *v11;
  __int128 v12;
  int v13;
  const std::string::value_type *v14;
  std::string::size_type v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  std::runtime_error *v20;
  std::string *v21;
  __int128 v22;
  int v23;
  const std::string::value_type *v24;
  std::string::size_type v25;
  std::string *v26;
  __int128 v27;
  std::string *v28;
  __int128 v29;
  std::string v30;
  std::string v31;
  std::string v32;
  std::string v33;
  std::string v34;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a3 + 16))(*a3);
  if (*(char *)(v6 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v34, *(const std::string::value_type **)v6, *(_QWORD *)(v6 + 8));
  }
  else
  {
    v7 = *(_OWORD *)v6;
    v34.__r_.__value_.__r.__words[2] = *(_QWORD *)(v6 + 16);
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v7;
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__emplace_unique_key_args<std::string,std::string&,std::shared_ptr<MIL::IROperator const>>(a1, (unsigned __int8 *)&v34, (__int128 *)&v34, (uint64_t)a3);
  if (!v8)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v11 = std::string::append(&v30, "' in opset '");
    v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    v13 = *(char *)(a2 + 23);
    if (v13 >= 0)
      v14 = (const std::string::value_type *)a2;
    else
      v14 = *(const std::string::value_type **)a2;
    if (v13 >= 0)
      v15 = *(unsigned __int8 *)(a2 + 23);
    else
      v15 = *(_QWORD *)(a2 + 8);
    v16 = std::string::append(&v31, v14, v15);
    v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    v18 = std::string::append(&v32, "'.");
    v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v33.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v33);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::string&,std::string&>(a1 + 80, (unsigned __int8 *)&v34, (__int128 *)&v34, (__int128 *)&v34);
  if (!v9)
  {
    v20 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v21 = std::string::append(&v30, "' in opset '");
    v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    v23 = *(char *)(a2 + 23);
    if (v23 >= 0)
      v24 = (const std::string::value_type *)a2;
    else
      v24 = *(const std::string::value_type **)a2;
    if (v23 >= 0)
      v25 = *(unsigned __int8 *)(a2 + 23);
    else
      v25 = *(_QWORD *)(a2 + 8);
    v26 = std::string::append(&v31, v24, v25);
    v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v27;
    v26->__r_.__value_.__l.__size_ = 0;
    v26->__r_.__value_.__r.__words[2] = 0;
    v26->__r_.__value_.__r.__words[0] = 0;
    v28 = std::string::append(&v32, "'.");
    v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v33.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v20, &v33);
    __cxa_throw(v20, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
}

void sub_1E058DE90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  void *v35;
  int v36;
  uint64_t v37;

  if (a35 < 0)
    operator delete(__p);
  if (a28 < 0)
    operator delete(a23);
  if (a21 < 0)
    operator delete(a16);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v36 & 1) == 0)
    {
LABEL_12:
      if (*(char *)(v37 - 41) < 0)
        operator delete(*(void **)(v37 - 64));
      _Unwind_Resume(a1);
    }
  }
  else if (!v36)
  {
    goto LABEL_12;
  }
  __cxa_free_exception(v35);
  goto LABEL_12;
}

uint64_t MIL::IROpset::GetOperator(_QWORD *a1, unsigned __int8 *a2)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  const void *v6;
  void *v7;
  void **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t Operator;
  void *__dst[2];
  unint64_t v14;

  v3 = (_QWORD *)a1[1];
  v4 = (*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = (const void *)v4;
  v7 = (void *)v5;
  if (v5 >= 0x17)
  {
    v9 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v9 = v5 | 7;
    v10 = v9 + 1;
    v8 = (void **)operator new(v9 + 1);
    __dst[1] = v7;
    v14 = v10 | 0x8000000000000000;
    __dst[0] = v8;
    goto LABEL_8;
  }
  HIBYTE(v14) = v5;
  v8 = __dst;
  if (v5)
LABEL_8:
    memmove(v8, v6, (size_t)v7);
  *((_BYTE *)v7 + (_QWORD)v8) = 0;
  Operator = MIL::IROpsetImpl::GetOperator(v3, (uint64_t)__dst, a2);
  if (SHIBYTE(v14) < 0)
    operator delete(__dst[0]);
  return Operator;
}

void sub_1E058E038(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IROpsetImpl::GetOperator(_QWORD *a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t result;
  std::runtime_error *exception;
  std::string *v6;
  __int128 v7;
  int v8;
  const std::string::value_type *v9;
  std::string::size_type v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  std::string v15;
  std::string v16;
  std::string v17;
  std::string v18;

  result = MIL::IROpsetImpl::TryGetOperator(a1, a3);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v6 = std::string::append(&v15, "' has been registered in opset '");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v16.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    v8 = *(char *)(a2 + 23);
    if (v8 >= 0)
      v9 = (const std::string::value_type *)a2;
    else
      v9 = *(const std::string::value_type **)a2;
    if (v8 >= 0)
      v10 = *(unsigned __int8 *)(a2 + 23);
    else
      v10 = *(_QWORD *)(a2 + 8);
    v11 = std::string::append(&v16, v9, v10);
    v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v17.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    v13 = std::string::append(&v17, "'.");
    v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v18.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v18);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E058E168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  int v29;
  uint64_t v30;

  if (*(char *)(v30 - 41) < 0)
    operator delete(*(void **)(v30 - 64));
  if (a28 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v29 & 1) == 0)
LABEL_12:
      _Unwind_Resume(a1);
  }
  else if (!v29)
  {
    goto LABEL_12;
  }
  __cxa_free_exception(v28);
  goto LABEL_12;
}

unsigned __int8 *MIL::IROpset::TryGetOperatorSharedPtr@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  return MIL::IROpsetImpl::TryGetOperatorSharedPtr(*(_QWORD **)(a1 + 8), a2, a3);
}

unsigned __int8 *MIL::IROpsetImpl::TryGetOperatorSharedPtr@<X0>(_QWORD *a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  __int128 *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 *v15;

  result = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(a1, a2);
  if (result)
  {
    v7 = *((_QWORD *)result + 6);
    *a3 = *((_QWORD *)result + 5);
    a3[1] = v7;
    if (v7)
    {
      v8 = (unint64_t *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
  }
  else
  {
    result = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a1 + 5, a2);
    if (result)
    {
      v10 = *((_QWORD *)result + 8);
      if (!v10)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(__int128 **__return_ptr))(*(_QWORD *)v10 + 48))(&v15);
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<MIL::IROperator>>((uint64_t)a1, a2, (__int128 *)a2, (uint64_t *)&v15);
      v11 = v15;
      v15 = 0;
      if (v11)
        (*(void (**)(__int128 *))(*(_QWORD *)v11 + 8))(v11);
      v15 = (__int128 *)a2;
      result = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a2, (uint64_t)&std::piecewise_construct, &v15);
      v12 = *((_QWORD *)result + 6);
      *a3 = *((_QWORD *)result + 5);
      a3[1] = v12;
      if (v12)
      {
        v13 = (unint64_t *)(v12 + 8);
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
    }
    else
    {
      *a3 = 0;
      a3[1] = 0;
    }
  }
  return result;
}

void sub_1E058E308(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IROpset::TryGetOperator(uint64_t a1, unsigned __int8 *a2)
{
  return MIL::IROpsetImpl::TryGetOperator(*(_QWORD **)(a1 + 8), a2);
}

uint64_t MIL::IROpsetImpl::TryGetOperator(_QWORD *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v7;
  std::__shared_weak_count *v8;

  MIL::IROpsetImpl::TryGetOperatorSharedPtr(a1, a2, &v7);
  v2 = v7;
  v3 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return v2;
}

uint64_t MIL::IROpset::GetOperatorDescription(_QWORD *a1, unsigned __int8 *a2)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  const void *v6;
  void *v7;
  void **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t Operator;
  void *__dst[2];
  unint64_t v14;

  v3 = (_QWORD *)a1[1];
  v4 = (*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = (const void *)v4;
  v7 = (void *)v5;
  if (v5 >= 0x17)
  {
    v9 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v9 = v5 | 7;
    v10 = v9 + 1;
    v8 = (void **)operator new(v9 + 1);
    __dst[1] = v7;
    v14 = v10 | 0x8000000000000000;
    __dst[0] = v8;
    goto LABEL_8;
  }
  HIBYTE(v14) = v5;
  v8 = __dst;
  if (v5)
LABEL_8:
    memmove(v8, v6, (size_t)v7);
  *((_BYTE *)v7 + (_QWORD)v8) = 0;
  Operator = MIL::IROpsetImpl::GetOperator(v3, (uint64_t)__dst, a2);
  if (SHIBYTE(v14) < 0)
    operator delete(__dst[0]);
  return Operator;
}

void sub_1E058E478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IROpset::GetOperatorDescription(MIL::IROpset *this, const MIL::IROperation *a2)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  const void *v6;
  void *v7;
  void **v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t Operator;
  void *__dst[2];
  unint64_t v15;

  v3 = (_QWORD *)*((_QWORD *)this + 1);
  v4 = (*(uint64_t (**)(MIL::IROpset *))(*(_QWORD *)this + 16))(this);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = (const void *)v4;
  v7 = (void *)v5;
  if (v5 >= 0x17)
  {
    v9 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v9 = v5 | 7;
    v10 = v9 + 1;
    v8 = (void **)operator new(v9 + 1);
    __dst[1] = v7;
    v15 = v10 | 0x8000000000000000;
    __dst[0] = v8;
    goto LABEL_8;
  }
  HIBYTE(v15) = v5;
  v8 = __dst;
  if (v5)
LABEL_8:
    memmove(v8, v6, (size_t)v7);
  *((_BYTE *)v7 + (_QWORD)v8) = 0;
  v11 = (unsigned __int8 *)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
  Operator = MIL::IROpsetImpl::GetOperator(v3, (uint64_t)__dst, v11);
  if (SHIBYTE(v15) < 0)
    operator delete(__dst[0]);
  return Operator;
}

void sub_1E058E584(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IROpset::TryGetOperatorDescription(uint64_t a1, unsigned __int8 *a2)
{
  return MIL::IROpsetImpl::TryGetOperator(*(_QWORD **)(a1 + 8), a2);
}

uint64_t MIL::IROpset::TryGetOperatorDescription(MIL::IROpset *this, const MIL::IROperation *a2)
{
  _QWORD *v2;
  unsigned __int8 *v3;

  v2 = (_QWORD *)*((_QWORD *)this + 1);
  v3 = (unsigned __int8 *)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
  return MIL::IROpsetImpl::TryGetOperator(v2, v3);
}

unsigned __int8 *MIL::IROpset::TryGetOperatorDescriptionSharedPtr@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  return MIL::IROpsetImpl::TryGetOperatorSharedPtr(*(_QWORD **)(a1 + 8), a2, a3);
}

unsigned __int8 *MIL::IROpset::TryGetOperatorDescriptionSharedPtr@<X0>(MIL::IROpset *this@<X0>, const MIL::IROperation *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v4;
  unsigned __int8 *v5;

  v4 = (_QWORD *)*((_QWORD *)this + 1);
  v5 = (unsigned __int8 *)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
  return MIL::IROpsetImpl::TryGetOperatorSharedPtr(v4, v5, a3);
}

unsigned __int8 *MIL::IROpset::GetNamedOperatorMap(MIL::IROpset *this)
{
  unsigned __int8 *v1;

  v1 = (unsigned __int8 *)*((_QWORD *)this + 1);
  MIL::IROpsetImpl::AlignData(v1);
  return v1;
}

uint64_t MIL::IROpset::GetReversedOperatorNamesMap@<X0>(MIL::IROpset *this@<X0>, uint64_t a2@<X8>)
{
  return std::unordered_map<std::string,std::string>::unordered_map(a2, *((_QWORD *)this + 1) + 80);
}

uint64_t MIL::IROpset::GetRawNamedOperatorMap(MIL::IROpset *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t MIL::IROpset::GetNamedOperatorConstructorMap(MIL::IROpset *this)
{
  return *((_QWORD *)this + 1) + 40;
}

MIL::IROpset *MIL::IROpset::IROpset(MIL::IROpset *this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  _OWORD v8[2];
  int v9;
  _OWORD v10[2];
  int v11;
  _OWORD v12[2];
  int v13;

  *((_QWORD *)this + 1) = 0;
  v2 = (uint64_t *)((char *)this + 8);
  *(_QWORD *)this = off_1EA994A60;
  memset(v12, 0, sizeof(v12));
  v13 = 1065353216;
  memset(v10, 0, sizeof(v10));
  v11 = 1065353216;
  memset(v8, 0, sizeof(v8));
  v9 = 1065353216;
  std::make_unique[abi:ne180100]<MIL::IROpsetImpl,std::unordered_map<std::string,std::shared_ptr<MIL::IROperator const>> &,std::unordered_map<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>> &,std::unordered_map<std::string,std::string> &>((uint64_t)v12, (uint64_t)v10, (uint64_t)v8, &v7);
  v3 = v7;
  v7 = 0;
  v4 = *v2;
  *v2 = v3;
  if (v4)
  {
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)v2, v4);
    v5 = v7;
    v7 = 0;
    if (v5)
      std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)&v7, v5);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v8);
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table((uint64_t)v10);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v12);
  return this;
}

void sub_1E058E724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)va);
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table((uint64_t)va1);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v4 - 64);
  v6 = *v3;
  *v3 = 0;
  if (v6)
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)v3, v6);
  _Unwind_Resume(a1);
}

uint64_t std::make_unique[abi:ne180100]<MIL::IROpsetImpl,std::unordered_map<std::string,std::shared_ptr<MIL::IROperator const>> &,std::unordered_map<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>> &,std::unordered_map<std::string,std::string> &>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v10[5];
  uint64_t v11[5];
  uint64_t v12[5];

  v8 = operator new();
  std::unordered_map<std::string,std::shared_ptr<MIL::IROperator const>>::unordered_map((uint64_t)v12, a1);
  std::unordered_map<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>::unordered_map((uint64_t)v11, a2);
  std::unordered_map<std::string,std::string>::unordered_map((uint64_t)v10, a3);
  MIL::IROpsetImpl::IROpsetImpl(v8, v12, v11, v10);
  *a4 = v8;
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v10);
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table((uint64_t)v11);
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v12);
}

void sub_1E058E80C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table((uint64_t)va);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va1);
  MEMORY[0x1E0C023A0](v7, 0x10A0C4011E33DBCLL);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IROpset::IROpset(_QWORD *a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  __int128 *v6;
  char v7;
  char v8;
  std::runtime_error *exception;
  uint64_t v10;
  std::string::size_type v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  std::string v20;
  std::string v21;
  std::string v22;
  void *__p;
  char v24;
  _OWORD v25[2];
  int v26;
  _OWORD v27[2];
  int v28;

  *a1 = off_1EA994A60;
  a1[1] = 0;
  v4 = a1 + 1;
  memset(v27, 0, sizeof(v27));
  v28 = 1065353216;
  v26 = 1065353216;
  v5 = a2 + 16;
  memset(v25, 0, sizeof(v25));
  while (1)
  {
    v5 = *(_QWORD *)v5;
    if (!v5)
      break;
    v6 = (__int128 *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 40) + 16))(*(_QWORD *)(v5 + 40));
    std::pair<std::string,std::string>::pair[abi:ne180100]<true,0>(&v22, v6, (__int128 *)(v5 + 16));
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::string>>((uint64_t)v25, (unsigned __int8 *)&v22, (uint64_t)&v22);
    v8 = v7;
    if (v24 < 0)
      operator delete(__p);
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v22.__r_.__value_.__l.__data_);
    if (!v8)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      v10 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 40) + 16))(*(_QWORD *)(v5 + 40));
      if (*(char *)(v10 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)v10, *(_QWORD *)(v10 + 8));
      }
      else
      {
        v15 = *(_OWORD *)v10;
        v20.__r_.__value_.__r.__words[2] = *(_QWORD *)(v10 + 16);
        *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v15;
      }
      v16 = std::string::insert(&v20, 0, "Duplicate operator name '");
      v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      v21.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      v18 = std::string::append(&v21, ".");
      v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      v22.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(exception, &v22);
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
    }
  }
  std::make_unique[abi:ne180100]<MIL::IROpsetImpl,std::unordered_map<std::string,std::shared_ptr<MIL::IROperator const>> &,std::unordered_map<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>> &,std::unordered_map<std::string,std::string> &>(a2, (uint64_t)v27, (uint64_t)v25, (uint64_t *)&v22);
  v11 = v22.__r_.__value_.__r.__words[0];
  v22.__r_.__value_.__r.__words[0] = 0;
  v12 = *v4;
  *v4 = v11;
  if (v12)
  {
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)v4, v12);
    v13 = v22.__r_.__value_.__r.__words[0];
    v22.__r_.__value_.__r.__words[0] = 0;
    if (v13)
      std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)&v22, v13);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v25);
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table((uint64_t)v27);
  return a1;
}

void sub_1E058EA3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t *v32;
  uint64_t v33;
  uint64_t v35;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a32);
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table(v33 - 96);
  v35 = *v32;
  *v32 = 0;
  if (v35)
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)v32, v35);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string,std::string>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *MIL::IROpset::IROpset(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  _OWORD v10[2];
  int v11;

  a1[1] = 0;
  v4 = a1 + 1;
  *a1 = off_1EA994A60;
  memset(v10, 0, sizeof(v10));
  v11 = 1065353216;
  std::make_unique[abi:ne180100]<MIL::IROpsetImpl,std::unordered_map<std::string,std::shared_ptr<MIL::IROperator const>> &,std::unordered_map<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>> &,std::unordered_map<std::string,std::string> &>((uint64_t)v10, a2, a3, &v9);
  v5 = v9;
  v9 = 0;
  v6 = *v4;
  *v4 = v5;
  if (v6)
  {
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)v4, v6);
    v7 = v9;
    v9 = 0;
    if (v7)
      std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)&v9, v7);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v10);
  return a1;
}

void sub_1E058EBC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t *v3;
  uint64_t v5;
  va_list va;

  va_start(va, a3);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va);
  v5 = *v3;
  *v3 = 0;
  if (v5)
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)v3, v5);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IROpset::IROpset(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  *a1 = off_1EA994A60;
  a1[1] = 0;
  v5 = a1 + 1;
  std::make_unique[abi:ne180100]<MIL::IROpsetImpl,std::unordered_map<std::string,std::shared_ptr<MIL::IROperator const>> &,std::unordered_map<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>> &,std::unordered_map<std::string,std::string> &>(a2, a3, a4, &v10);
  v6 = v10;
  v10 = 0;
  v7 = *v5;
  *v5 = v6;
  if (v7)
  {
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)v5, v7);
    v8 = v10;
    v10 = 0;
    if (v8)
      std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)&v10, v8);
  }
  return a1;
}

void sub_1E058EC70(_Unwind_Exception *exception_object)
{
  uint64_t *v1;
  uint64_t v3;

  v3 = *v1;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)v1, v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IROpset::MakeSupplementedOpset@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  _QWORD v20[2];
  _QWORD v21[2];
  int v22;
  _BYTE v23[40];
  _BYTE v24[40];
  _BYTE v25[40];
  _BYTE v26[40];
  _BYTE v27[40];

  v7 = *(_QWORD *)(a2 + 8);
  std::unordered_map<std::string,std::string>::unordered_map((uint64_t)&v15, v7 + 80);
  v8 = operator new();
  std::unordered_map<std::string,std::shared_ptr<MIL::IROperator const>>::unordered_map((uint64_t)v24, v7);
  std::unordered_map<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>::unordered_map((uint64_t)v23, v7 + 40);
  v9 = v15;
  v10 = v16;
  v15 = 0;
  v16 = 0;
  v20[0] = v9;
  v20[1] = v10;
  v21[0] = v17;
  v21[1] = v18;
  v22 = v19;
  if (v18)
  {
    v11 = *(_QWORD *)(v17 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v11 >= v10)
        v11 %= v10;
    }
    else
    {
      v11 &= v10 - 1;
    }
    *(_QWORD *)(v9 + 8 * v11) = v21;
    v17 = 0;
    v18 = 0;
  }
  std::unordered_map<std::string,std::shared_ptr<MIL::IROperator const>>::unordered_map((uint64_t)v27, (uint64_t)v24);
  std::unordered_map<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>::unordered_map((uint64_t)v26, (uint64_t)v23);
  std::unordered_map<std::string,std::string>::unordered_map((uint64_t)v25, (uint64_t)v20);
  MIL::IROpset::IROpset((_QWORD *)v8, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v25);
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table((uint64_t)v26);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v27);
  *(_QWORD *)v8 = off_1EA994AF8;
  *(_OWORD *)(v8 + 16) = *(_OWORD *)a1;
  *(_QWORD *)(v8 + 32) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v12 = *(_QWORD **)a3;
  v13 = *(_QWORD **)(a3 + 8);
  if (*(_QWORD **)a3 != v13)
  {
    do
    {
      MIL::IROpset::RegisterOp((_QWORD *)v8, v12);
      v12 += 2;
    }
    while (v12 != v13);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v20);
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table((uint64_t)v23);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v24);
  *a4 = v8;
  return std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&v15);
}

void sub_1E058EE30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  uint64_t v30;
  uint64_t v31;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a30);
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table(v31 - 128);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v31 - 88);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a15);
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table((uint64_t)&a20);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a25);
  MEMORY[0x1E0C023A0](v30, 0x10B3C40E7C412B7);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a10);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__emplace_unique_key_args<std::string,std::string&,std::shared_ptr<MIL::IROperator const>>(uint64_t a1, unsigned __int8 *a2, __int128 *a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[3];

  v9 = (_QWORD *)(a1 + 24);
  v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__construct_node_hash<std::string&,std::shared_ptr<MIL::IROperator const>>(a1, v11, a3, a4, (uint64_t)v27);
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    v20 = 1;
    if (v12 >= 3)
      v20 = (v12 & (v12 - 1)) != 0;
    v21 = v20 | (2 * v12);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v23);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v27[0] = *v24;
    *v24 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v27[0])
    {
      v25 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12)
          v25 %= v12;
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v27[0];
    }
  }
  i = (unsigned __int8 *)v27[0];
  v27[0] = 0;
  ++*v9;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v27, 0);
  return i;
}

void sub_1E058F164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__construct_node_hash<std::string&,std::shared_ptr<MIL::IROperator const>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  char *v10;
  std::string *result;

  v9 = a1 + 16;
  v10 = (char *)operator new(0x38uLL);
  *(_QWORD *)a5 = v10;
  *(_QWORD *)(a5 + 8) = v9;
  *(_BYTE *)(a5 + 16) = 0;
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = a2;
  result = std::pair<std::string const,std::shared_ptr<MIL::IROperator const>>::pair[abi:ne180100]<std::string&,std::shared_ptr<MIL::IROperator const>,0>((std::string *)(v10 + 16), a3, a4);
  *(_BYTE *)(a5 + 16) = 1;
  return result;
}

void sub_1E058F1E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::shared_ptr<MIL::IROperator const>>::pair[abi:ne180100]<std::string&,std::shared_ptr<MIL::IROperator const>,0>(std::string *this, __int128 *a2, uint64_t a3)
{
  __int128 v5;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = *(_OWORD *)a3;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  return this;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::string&,std::string&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3, __int128 *a4)
{
  unint64_t v4;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[3];

  v9 = (_QWORD *)(a1 + 24);
  v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__construct_node_hash<std::string&,std::string&>(a1, v11, a3, a4, (uint64_t)v27);
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    v20 = 1;
    if (v12 >= 3)
      v20 = (v12 & (v12 - 1)) != 0;
    v21 = v20 | (2 * v12);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v23);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v27[0] = *v24;
    *v24 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v27[0])
    {
      v25 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12)
          v25 %= v12;
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v27[0];
    }
  }
  i = (unsigned __int8 *)v27[0];
  v27[0] = 0;
  ++*v9;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v27, 0);
  return i;
}

void sub_1E058F4CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__construct_node_hash<std::string&,std::string&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, __int128 *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  char *v10;
  std::string *result;

  v9 = a1 + 16;
  v10 = (char *)operator new(0x40uLL);
  *(_QWORD *)a5 = v10;
  *(_QWORD *)(a5 + 8) = v9;
  *(_BYTE *)(a5 + 16) = 0;
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = a2;
  result = std::pair<std::string const,std::string>::pair[abi:ne180100]<std::string&,std::string&,0>((std::string *)(v10 + 16), a3, a4);
  *(_BYTE *)(a5 + 16) = 1;
  return result;
}

void sub_1E058F550(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::string>::pair[abi:ne180100]<std::string&,std::string&,0>(std::string *this, __int128 *a2, __int128 *a3)
{
  __int128 v5;
  std::string *v6;
  __int128 v7;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  v6 = this + 1;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v7 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return this;
}

void sub_1E058F5E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<MIL::IROperator>>(uint64_t a1, unsigned __int8 *a2, __int128 *a3, uint64_t *a4)
{
  unint64_t v4;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[3];

  v9 = (_QWORD *)(a1 + 24);
  v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__construct_node_hash<std::string const&,std::unique_ptr<MIL::IROperator>>(a1, v11, a3, a4, (uint64_t)v27);
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    v20 = 1;
    if (v12 >= 3)
      v20 = (v12 & (v12 - 1)) != 0;
    v21 = v20 | (2 * v12);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v23);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v27[0] = *v24;
    *v24 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v27[0])
    {
      v25 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12)
          v25 %= v12;
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v27[0];
    }
  }
  i = (unsigned __int8 *)v27[0];
  v27[0] = 0;
  ++*v9;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v27, 0);
  return i;
}

void sub_1E058F8F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__construct_node_hash<std::string const&,std::unique_ptr<MIL::IROperator>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  char *v10;
  std::string *result;

  v9 = a1 + 16;
  v10 = (char *)operator new(0x38uLL);
  *(_QWORD *)a5 = v10;
  *(_QWORD *)(a5 + 8) = v9;
  *(_BYTE *)(a5 + 16) = 0;
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = a2;
  result = std::pair<std::string const,std::shared_ptr<MIL::IROperator const>>::pair[abi:ne180100]<std::string const&,std::unique_ptr<MIL::IROperator>,0>((std::string *)(v10 + 16), a3, a4);
  *(_BYTE *)(a5 + 16) = 1;
  return result;
}

void sub_1E058F978(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::shared_ptr<MIL::IROperator const>>::pair[abi:ne180100]<std::string const&,std::unique_ptr<MIL::IROperator>,0>(std::string *this, __int128 *a2, uint64_t *a3)
{
  __int128 v5;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  std::shared_ptr<MIL::IROperator const>::shared_ptr[abi:ne180100]<MIL::IROperator,std::default_delete<MIL::IROperator>,void>((uint64_t *)&this[1], a3);
  return this;
}

void sub_1E058F9EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t *std::shared_ptr<MIL::IROperator const>::shared_ptr[abi:ne180100]<MIL::IROperator,std::default_delete<MIL::IROperator>,void>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = *a2;
  *a1 = *a2;
  if (v4)
  {
    v5 = (_QWORD *)operator new();
    v6 = *a2;
    *v5 = &unk_1EA994A98;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  a1[1] = (uint64_t)v5;
  *a2 = 0;
  return a1;
}

void std::__shared_ptr_pointer<MIL::IROperator  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::IROperator  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IROperator  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_1E058FD78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;
  __int128 *v10;
  __int128 v11;

  v7 = a1 + 16;
  v8 = operator new(0x38uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
  }
  else
  {
    v11 = *v10;
    v8[4] = *((_QWORD *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  v8[5] = 0;
  v8[6] = 0;
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_1E058FE14(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

unsigned __int8 *MIL::IROpsetImpl::AlignData(unsigned __int8 *this)
{
  uint64_t v1;
  unsigned __int8 *i;
  uint64_t v3;
  unsigned __int8 *v4;

  if (!this[120])
  {
    v1 = (uint64_t)this;
    for (i = (unsigned __int8 *)*((_QWORD *)this + 7); i; i = *(unsigned __int8 **)i)
    {
      this = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((_QWORD *)v1, i + 16);
      if (!this)
      {
        v3 = *((_QWORD *)i + 8);
        if (!v3)
          std::__throw_bad_function_call[abi:ne180100]();
        (*(void (**)(unsigned __int8 **__return_ptr))(*(_QWORD *)v3 + 48))(&v4);
        std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<MIL::IROperator>>(v1, i + 16, (__int128 *)i + 1, (uint64_t *)&v4);
        this = v4;
        v4 = 0;
        if (this)
          this = (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *))(*(_QWORD *)this + 8))(this);
      }
    }
    *(_BYTE *)(v1 + 120) = 1;
  }
  return this;
}

void sub_1E058FED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t std::unordered_map<std::string,std::string>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned __int8 **)(a2 + 16); i; i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::string> const&>(a1, i + 16, (__int128 *)i + 1);
  return a1;
}

void sub_1E058FF54(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::string> const&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__construct_node_hash<std::pair<std::string const,std::string> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1E05901D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__construct_node_hash<std::pair<std::string const,std::string> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x40uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<std::string const,std::string>::pair[abi:ne180100]((std::string *)(v8 + 16), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1E0590248(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::string>::pair[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v4;
  std::string *v5;
  __int128 v6;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  v5 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v6 = *(__int128 *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  return this;
}

void sub_1E05902D8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(a2 + 80);
    std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table(a2 + 40);
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a2);
    JUMPOUT(0x1E0C023A0);
  }
}

std::string *std::pair<std::string,std::string>::pair[abi:ne180100]<true,0>(std::string *this, __int128 *a2, __int128 *a3)
{
  __int128 v5;
  std::string *v6;
  __int128 v7;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  v6 = this + 1;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v7 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return this;
}

void sub_1E059042C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,0>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 24);
  v3 = *(_QWORD **)(a1 + 48);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::unordered_map<std::string,std::shared_ptr<MIL::IROperator const>>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned __int8 **)(a2 + 16); i; i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IROperator const>> const&>(a1, i + 16, (__int128 *)i + 1);
  return a1;
}

void sub_1E059057C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IROperator const>> const&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__construct_node_hash<std::pair<std::string const,std::shared_ptr<MIL::IROperator const>> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1E05907FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IROperator const>>>>::__construct_node_hash<std::pair<std::string const,std::shared_ptr<MIL::IROperator const>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x38uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100]((std::string *)(v8 + 16), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1E0590870(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned __int8 **)(a2 + 16); i; i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::function<std::unique_ptr<MIL::IROperator> ()(void)>> const&>(a1, i + 16, (__int128 *)i + 1);
  return a1;
}

void sub_1E05908E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::function<std::unique_ptr<MIL::IROperator> ()(void)>> const&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::__construct_node_hash<std::pair<std::string const,std::function<std::unique_ptr<MIL::IROperator> ()(void)>> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1E0590B64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>>>::__construct_node_hash<std::pair<std::string const,std::function<std::unique_ptr<MIL::IROperator> ()(void)>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x48uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<std::string const,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>::pair[abi:ne180100]((std::string *)(v8 + 16), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1E0590BD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>::pair[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v4;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  std::__function::__value_func<std::shared_ptr<MIL::IRValue const> ()(MIL::IROperation const&)>::__value_func[abi:ne180100]((uint64_t)&this[1], (uint64_t)a2 + 24);
  return this;
}

void sub_1E0590C48(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<std::unique_ptr<MIL::IROperator> ()(void)>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

uint64_t MIL::IROpsetImpl::IROpsetImpl(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7;

  v7 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1, a2);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(v7 + 40, a3);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 80, a4);
  *(_BYTE *)(a1 + 120) = 0;
  return a1;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::string>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  char *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[2];
  char v27;

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  v16 = (char *)operator new(0x40uLL);
  v26[0] = v16;
  v26[1] = a1 + 16;
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = v9;
  *((_OWORD *)v16 + 1) = *(_OWORD *)a3;
  *((_QWORD *)v16 + 4) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_OWORD *)(v16 + 40) = *(_OWORD *)(a3 + 24);
  *((_QWORD *)v16 + 7) = *(_QWORD *)(a3 + 40);
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  v27 = 1;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    v19 = 1;
    if (v10 >= 3)
      v19 = (v10 & (v10 - 1)) != 0;
    v20 = v19 | (2 * v10);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v24 >= v10)
          v24 %= v10;
      }
      else
      {
        v24 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_1E0590F8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::SupplementedOpset::~SupplementedOpset(void **this)
{
  uint64_t v2;

  *this = off_1EA994AF8;
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
  *this = off_1EA994A60;
  v2 = (uint64_t)this[1];
  this[1] = 0;
  if (v2)
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)(this + 1), v2);
}

{
  uint64_t v2;

  *this = off_1EA994AF8;
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
  *this = off_1EA994A60;
  v2 = (uint64_t)this[1];
  this[1] = 0;
  if (v2)
    std::default_delete<MIL::IROpsetImpl>::operator()[abi:ne180100]((uint64_t)(this + 1), v2);
  JUMPOUT(0x1E0C023A0);
}

uint64_t `anonymous namespace'::SupplementedOpset::GetName(_anonymous_namespace_::SupplementedOpset *this)
{
  if (*((char *)this + 39) < 0)
    return *((_QWORD *)this + 2);
  else
    return (uint64_t)this + 16;
}

BOOL MIL::IsValidIRPixelFormatType(int a1)
{
  return a1 != 20;
}

uint64_t MIL::IsValidIRPixelFormatTypeString(unsigned __int8 *a1)
{
  MIL::StringToIRPixelFormatType(a1);
  return 1;
}

void sub_1E05910B0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1E05910A8);
}

uint64_t MIL::StringToIRPixelFormatType(unsigned __int8 *a1)
{
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  std::logic_error *exception;
  std::string *v7;
  __int128 v8;
  std::string v9;
  _QWORD v10[5];
  std::string v11;
  int v12;
  _QWORD v13[3];
  int v14;
  _QWORD v15[3];
  int v16;
  _QWORD v17[3];
  int v18;
  _QWORD v19[3];
  int v20;
  _QWORD v21[3];
  int v22;
  _QWORD v23[3];
  int v24;
  _QWORD v25[3];
  int v26;
  _QWORD v27[3];
  int v28;
  _QWORD v29[3];
  int v30;
  _QWORD v31[3];
  int v32;
  _QWORD v33[3];
  int v34;
  _QWORD v35[3];
  int v36;
  _QWORD v37[3];
  int v38;
  _QWORD v39[3];
  int v40;
  _QWORD v41[3];
  int v42;
  _QWORD v43[3];
  int v44;
  _QWORD v45[3];
  int v46;
  _QWORD v47[3];
  int v48;
  _QWORD v49[3];
  int v50;
  _QWORD v51[3];
  int v52;
  _QWORD v53[3];
  int v54;
  _QWORD v55[3];
  int v56;
  _QWORD v57[3];
  int v58;
  _QWORD v59[3];
  int v60;
  _QWORD v61[3];
  int v62;
  _QWORD v63[3];
  int v64;
  _QWORD v65[3];
  int v66;
  _QWORD v67[3];
  int v68;
  _QWORD v69[3];
  int v70;
  _QWORD v71[3];
  int v72;
  _QWORD v73[3];
  int v74;
  _QWORD v75[3];
  int v76;
  _QWORD v77[3];
  int v78;
  _QWORD v79[3];
  int v80;
  _QWORD v81[3];
  int v82;
  _QWORD v83[3];
  int v84;
  _QWORD v85[3];
  int v86;
  _QWORD v87[3];
  int v88;
  _QWORD v89[3];
  int v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  std::string::basic_string[abi:ne180100]<0>(&v11, "FMT_OneComponent8");
  v12 = 1;
  std::string::basic_string[abi:ne180100]<0>(v13, "FMT_OneComponent16Half");
  v14 = 2;
  std::string::basic_string[abi:ne180100]<0>(v15, "FMT_OneComponent32Float");
  v16 = 3;
  std::string::basic_string[abi:ne180100]<0>(v17, "FMT_TwoComponent8");
  v18 = 4;
  std::string::basic_string[abi:ne180100]<0>(v19, "FMT_TwoComponent16Half");
  v20 = 6;
  std::string::basic_string[abi:ne180100]<0>(v21, "FMT_TwoComponent32Float");
  v22 = 5;
  std::string::basic_string[abi:ne180100]<0>(v23, "FMT_32ARGB");
  v24 = 11;
  std::string::basic_string[abi:ne180100]<0>(v25, "FMT_32BGRA");
  v26 = 12;
  std::string::basic_string[abi:ne180100]<0>(v27, "FMT_32RGBA");
  v28 = 13;
  std::string::basic_string[abi:ne180100]<0>(v29, "FMT_64RGBAHalf");
  v30 = 14;
  std::string::basic_string[abi:ne180100]<0>(v31, "FMT_DisparityFloat16");
  v32 = 15;
  std::string::basic_string[abi:ne180100]<0>(v33, "FMT_DepthFloat16");
  v34 = 17;
  std::string::basic_string[abi:ne180100]<0>(v35, "any");
  v36 = 20;
  std::string::basic_string[abi:ne180100]<0>(v37, "FMT_420YpCbCr8BiPlanarVideoRange");
  v38 = 21;
  std::string::basic_string[abi:ne180100]<0>(v39, "FMT_420YpCbCr8BiPlanarFullRange");
  v40 = 22;
  std::string::basic_string[abi:ne180100]<0>(v41, "FMT_420YpCbCr10BiPlanarVideoRange");
  v42 = 23;
  std::string::basic_string[abi:ne180100]<0>(v43, "FMT_420YpCbCr10BiPlanarFullRange");
  v44 = 24;
  std::string::basic_string[abi:ne180100]<0>(v45, "FMT_420YpCbCr10PackedBiPlanarVideoRange");
  v46 = 25;
  std::string::basic_string[abi:ne180100]<0>(v47, "FMT_420YpCbCr10PackedBiPlanarFullRange");
  v48 = 26;
  std::string::basic_string[abi:ne180100]<0>(v49, "FMT_420YpCbCr10PackedBiPlanarWideRange");
  v50 = 27;
  std::string::basic_string[abi:ne180100]<0>(v51, "FMT_444YpCbCr8BiPlanarVideoRange");
  v52 = 28;
  std::string::basic_string[abi:ne180100]<0>(v53, "FMT_444YpCbCr8BiPlanarFullRange");
  v54 = 29;
  std::string::basic_string[abi:ne180100]<0>(v55, "FMT_AGX_OneComponent16");
  v56 = 41;
  std::string::basic_string[abi:ne180100]<0>(v57, "FMT_AGX_OneComponent16Half");
  v58 = 42;
  std::string::basic_string[abi:ne180100]<0>(v59, "FMT_Lossy75_OneComponent16Half");
  v60 = 43;
  std::string::basic_string[abi:ne180100]<0>(v61, "FMT_Lossy62_OneComponent16Half");
  v62 = 44;
  std::string::basic_string[abi:ne180100]<0>(v63, "FMT_Lossy50_OneComponent16Half");
  v64 = 45;
  std::string::basic_string[abi:ne180100]<0>(v65, "FMT_AGX_32BGRA");
  v66 = 51;
  std::string::basic_string[abi:ne180100]<0>(v67, "FMT_Lossy75_32BGRA");
  v68 = 52;
  std::string::basic_string[abi:ne180100]<0>(v69, "FMT_Lossy62_32BGRA");
  v70 = 53;
  std::string::basic_string[abi:ne180100]<0>(v71, "FMT_Lossy50_32BGRA");
  v72 = 54;
  std::string::basic_string[abi:ne180100]<0>(v73, "FMT_AGX_64RGBAHalf");
  v74 = 55;
  std::string::basic_string[abi:ne180100]<0>(v75, "FMT_Lossy75_64RGBAHalf");
  v76 = 56;
  std::string::basic_string[abi:ne180100]<0>(v77, "FMT_Lossy62_64RGBAHalf");
  v78 = 57;
  std::string::basic_string[abi:ne180100]<0>(v79, "FMT_Lossy50_64RGBAHalf");
  v80 = 58;
  std::string::basic_string[abi:ne180100]<0>(v81, "FMT_Lossless_420YpCbCr8BiPlanarVideoRange");
  v82 = 70;
  std::string::basic_string[abi:ne180100]<0>(v83, "FMT_Lossless_420YpCbCr8BiPlanarFullRange");
  v84 = 71;
  std::string::basic_string[abi:ne180100]<0>(v85, "FMT_12RLSB_12G12BMSB");
  v86 = 90;
  std::string::basic_string[abi:ne180100]<0>(v87, "FMT_OneComponent12LSB");
  v88 = 91;
  std::string::basic_string[abi:ne180100]<0>(v89, "FMT_MultiSlice_Lossless_OneComponent16Half");
  v90 = 100;
  std::unordered_map<std::string,MIL::IRPixelFormatType>::unordered_map((uint64_t)v10, (unsigned __int8 *)&v11, 40);
  v2 = 160;
  do
  {
    if (SHIBYTE(v10[v2 + 3]) < 0)
      operator delete((void *)v10[v2 + 1]);
    v2 -= 4;
  }
  while (v2 * 8);
  v3 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v10, a1);
  if (!v3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v7 = std::string::append(&v9, " does not map to a pixel format type.");
    v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v11.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v11.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(exception, &v11);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  v4 = *((unsigned int *)v3 + 10);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v10);
  return v4;
}

void sub_1E05916A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;
  int v26;

  if (a25 < 0)
    operator delete(__p);
  if (a14 < 0)
  {
    operator delete(a9);
    if ((v26 & 1) == 0)
    {
LABEL_8:
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v26)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v25);
  goto LABEL_8;
}

void sub_1E05917F8()
{
  JUMPOUT(0x1E05917F0);
}

_QWORD *MIL::IRPixelFormatTypeToString@<X0>(unsigned int a1@<W0>, _QWORD *a2@<X8>)
{
  char *v3;
  std::logic_error *exception;
  std::logic_error *v6;
  std::string *v7;
  __int128 v8;
  std::string v9;
  std::string v10;

  v3 = "FMT_OneComponent8";
  switch(a1)
  {
    case 1u:
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 2u:
      v3 = "FMT_OneComponent16Half";
      break;
    case 3u:
      v3 = "FMT_OneComponent32Float";
      break;
    case 4u:
      v3 = "FMT_TwoComponent8";
      break;
    case 5u:
      v3 = "FMT_TwoComponent32Float";
      break;
    case 6u:
      v3 = "FMT_TwoComponent16Half";
      break;
    case 0xBu:
      v3 = "FMT_32ARGB";
      break;
    case 0xCu:
      v3 = "FMT_32BGRA";
      break;
    case 0xDu:
      v3 = "FMT_32RGBA";
      break;
    case 0xEu:
      v3 = "FMT_64RGBAHalf";
      break;
    case 0xFu:
      v3 = "FMT_DisparityFloat16";
      break;
    case 0x11u:
      v3 = "FMT_DepthFloat16";
      break;
    case 0x14u:
      v3 = "any";
      break;
    case 0x15u:
      v3 = "FMT_420YpCbCr8BiPlanarVideoRange";
      break;
    case 0x16u:
      v3 = "FMT_420YpCbCr8BiPlanarFullRange";
      break;
    case 0x17u:
      v3 = "FMT_420YpCbCr10BiPlanarVideoRange";
      break;
    case 0x18u:
      v3 = "FMT_420YpCbCr10BiPlanarFullRange";
      break;
    case 0x19u:
      v3 = "FMT_420YpCbCr10PackedBiPlanarVideoRange";
      break;
    case 0x1Au:
      v3 = "FMT_420YpCbCr10PackedBiPlanarFullRange";
      break;
    case 0x1Bu:
      v3 = "FMT_420YpCbCr10PackedBiPlanarWideRange";
      break;
    case 0x1Cu:
      v3 = "FMT_444YpCbCr8BiPlanarVideoRange";
      break;
    case 0x1Du:
      v3 = "FMT_444YpCbCr8BiPlanarFullRange";
      break;
    case 0x28u:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "Unsupported format: Count");
      __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
    case 0x29u:
      v3 = "FMT_AGX_OneComponent16";
      break;
    case 0x2Au:
      v3 = "FMT_AGX_OneComponent16Half";
      break;
    case 0x2Bu:
      v3 = "FMT_Lossy75_OneComponent16Half";
      break;
    case 0x2Cu:
      v3 = "FMT_Lossy62_OneComponent16Half";
      break;
    case 0x2Du:
      v3 = "FMT_Lossy50_OneComponent16Half";
      break;
    case 0x33u:
      v3 = "FMT_AGX_32BGRA";
      break;
    case 0x34u:
      v3 = "FMT_Lossy75_32BGRA";
      break;
    case 0x35u:
      v3 = "FMT_Lossy62_32BGRA";
      break;
    case 0x36u:
      v3 = "FMT_Lossy50_32BGRA";
      break;
    case 0x37u:
      v3 = "FMT_AGX_64RGBAHalf";
      break;
    case 0x38u:
      v3 = "FMT_Lossy75_64RGBAHalf";
      break;
    case 0x39u:
      v3 = "FMT_Lossy62_64RGBAHalf";
      break;
    case 0x3Au:
      v3 = "FMT_Lossy50_64RGBAHalf";
      break;
    case 0x46u:
      v3 = "FMT_Lossless_420YpCbCr8BiPlanarVideoRange";
      break;
    case 0x47u:
      v3 = "FMT_Lossless_420YpCbCr8BiPlanarFullRange";
      break;
    case 0x5Au:
      v3 = "FMT_12RLSB_12G12BMSB";
      break;
    case 0x5Bu:
      v3 = "FMT_OneComponent12LSB";
      break;
    case 0x64u:
      v3 = "FMT_MultiSlice_Lossless_OneComponent16Half";
      break;
    default:
      v6 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::to_string(&v9, a1);
      v7 = std::string::insert(&v9, 0, "Unsupported format: ");
      v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v10.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v10.__r_.__value_.__l.__data_ = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      std::logic_error::logic_error(v6, &v10);
      v6->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
      __cxa_throw(v6, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, v3);
}

void sub_1E0591AE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t MIL::GetNumPlanesForFormat(int a1)
{
  uint64_t result;
  std::logic_error *exception;

  if ((a1 - 21) < 9)
    return 2;
  result = 1;
  if (a1 > 89)
  {
    if (a1 != 90)
      return result;
    return 2;
  }
  if ((a1 - 70) < 2)
    return 2;
  if (a1 == 20 || a1 == 40)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Unsupported pixel format type.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  return result;
}

void sub_1E0591BD4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::GetChannelDimForFormat(int a1, unsigned int a2)
{
  uint64_t result;
  std::logic_error *exception;
  std::logic_error *v6;
  unsigned int v7;
  std::logic_error *v8;
  std::string *v9;
  __int128 v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  std::string::size_type v14;
  std::string *v15;
  __int128 v16;
  std::logic_error *v17;
  unsigned int v18;
  std::logic_error *v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  std::string::size_type size;
  std::string *v26;
  __int128 v27;
  std::logic_error *v28;
  unsigned int v29;
  std::logic_error *v30;
  std::string *v31;
  __int128 v32;
  std::string *v33;
  __int128 v34;
  std::string *v35;
  std::string::size_type v36;
  std::string *v37;
  __int128 v38;
  std::logic_error *v39;
  unsigned int v40;
  std::logic_error *v41;
  std::string *v42;
  __int128 v43;
  std::string *v44;
  __int128 v45;
  std::string *v46;
  std::string::size_type v47;
  std::string *v48;
  __int128 v49;
  std::string v50;
  std::string v51;
  std::string v52;
  std::string v53;
  std::string v54;

  result = MIL::SupportsMultiSlice(a1);
  if ((_DWORD)result)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Channel dim for multislice is defined via numSlices.");
LABEL_15:
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  switch(a1)
  {
    case 1:
    case 2:
    case 3:
    case 15:
    case 17:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 91:
    case 100:
      if (a2)
      {
        v17 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        v18 = a1;
        v19 = v17;
        MIL::IRPixelFormatTypeToString(v18, &v51);
        v20 = std::string::insert(&v51, 0, "Plane index exceeds number of planes of ");
        v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
        v52.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v21;
        v20->__r_.__value_.__l.__size_ = 0;
        v20->__r_.__value_.__r.__words[2] = 0;
        v20->__r_.__value_.__r.__words[0] = 0;
        v22 = std::string::append(&v52, ": ");
        v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
        v53.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v23;
        v22->__r_.__value_.__l.__size_ = 0;
        v22->__r_.__value_.__r.__words[2] = 0;
        v22->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v50, a2);
        if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v24 = &v50;
        else
          v24 = (std::string *)v50.__r_.__value_.__r.__words[0];
        if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(v50.__r_.__value_.__r.__words[2]);
        else
          size = v50.__r_.__value_.__l.__size_;
        v26 = std::string::append(&v53, (const std::string::value_type *)v24, size);
        v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
        v54.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v27;
        v26->__r_.__value_.__l.__size_ = 0;
        v26->__r_.__value_.__r.__words[2] = 0;
        v26->__r_.__value_.__r.__words[0] = 0;
        std::logic_error::logic_error(v19, &v54);
        v19->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
        __cxa_throw(v19, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
      }
      return 1;
    case 4:
    case 5:
    case 6:
      if (a2)
      {
        v39 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        v40 = a1;
        v41 = v39;
        MIL::IRPixelFormatTypeToString(v40, &v51);
        v42 = std::string::insert(&v51, 0, "Plane index exceeds number of planes of ");
        v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
        v52.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v43;
        v42->__r_.__value_.__l.__size_ = 0;
        v42->__r_.__value_.__r.__words[2] = 0;
        v42->__r_.__value_.__r.__words[0] = 0;
        v44 = std::string::append(&v52, ": ");
        v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
        v53.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v45;
        v44->__r_.__value_.__l.__size_ = 0;
        v44->__r_.__value_.__r.__words[2] = 0;
        v44->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v50, a2);
        if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v46 = &v50;
        else
          v46 = (std::string *)v50.__r_.__value_.__r.__words[0];
        if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v47 = HIBYTE(v50.__r_.__value_.__r.__words[2]);
        else
          v47 = v50.__r_.__value_.__l.__size_;
        v48 = std::string::append(&v53, (const std::string::value_type *)v46, v47);
        v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
        v54.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v49;
        v48->__r_.__value_.__l.__size_ = 0;
        v48->__r_.__value_.__r.__words[2] = 0;
        v48->__r_.__value_.__r.__words[0] = 0;
        std::logic_error::logic_error(v41, &v54);
        v41->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
        __cxa_throw(v41, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
      }
      return 2;
    case 11:
    case 12:
    case 13:
    case 14:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
      if (a2)
      {
        v6 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        v7 = a1;
        v8 = v6;
        MIL::IRPixelFormatTypeToString(v7, &v51);
        v9 = std::string::insert(&v51, 0, "Plane index exceeds number of planes of ");
        v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
        v52.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v10;
        v9->__r_.__value_.__l.__size_ = 0;
        v9->__r_.__value_.__r.__words[2] = 0;
        v9->__r_.__value_.__r.__words[0] = 0;
        v11 = std::string::append(&v52, ": ");
        v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
        v53.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v12;
        v11->__r_.__value_.__l.__size_ = 0;
        v11->__r_.__value_.__r.__words[2] = 0;
        v11->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v50, a2);
        if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v13 = &v50;
        else
          v13 = (std::string *)v50.__r_.__value_.__r.__words[0];
        if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v14 = HIBYTE(v50.__r_.__value_.__r.__words[2]);
        else
          v14 = v50.__r_.__value_.__l.__size_;
        v15 = std::string::append(&v53, (const std::string::value_type *)v13, v14);
        v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
        v54.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v16;
        v15->__r_.__value_.__l.__size_ = 0;
        v15->__r_.__value_.__r.__words[2] = 0;
        v15->__r_.__value_.__r.__words[0] = 0;
        std::logic_error::logic_error(v8, &v54);
        v8->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
        __cxa_throw(v8, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
      }
      return 4;
    case 20:
    case 40:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "Unsupported pixel format type.");
      goto LABEL_15;
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 70:
    case 71:
    case 90:
      if (a2 >= 2)
      {
        v28 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        v29 = a1;
        v30 = v28;
        MIL::IRPixelFormatTypeToString(v29, &v51);
        v31 = std::string::insert(&v51, 0, "Plane index exceeds number of planes of ");
        v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
        v52.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v32;
        v31->__r_.__value_.__l.__size_ = 0;
        v31->__r_.__value_.__r.__words[2] = 0;
        v31->__r_.__value_.__r.__words[0] = 0;
        v33 = std::string::append(&v52, ": ");
        v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
        v53.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v34;
        v33->__r_.__value_.__l.__size_ = 0;
        v33->__r_.__value_.__r.__words[2] = 0;
        v33->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v50, a2);
        if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v35 = &v50;
        else
          v35 = (std::string *)v50.__r_.__value_.__r.__words[0];
        if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v36 = HIBYTE(v50.__r_.__value_.__r.__words[2]);
        else
          v36 = v50.__r_.__value_.__l.__size_;
        v37 = std::string::append(&v53, (const std::string::value_type *)v35, v36);
        v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
        v54.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v38;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        v37->__r_.__value_.__r.__words[0] = 0;
        std::logic_error::logic_error(v30, &v54);
        v30->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
        __cxa_throw(v30, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
      }
      if (a2)
        return 2;
      else
        return 1;
    default:
      return result;
  }
}

void sub_1E05920A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  void *v33;
  int v34;
  uint64_t v35;

  if (*(char *)(v35 - 41) < 0)
    operator delete(*(void **)(v35 - 64));
  if (a14 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
  {
    operator delete(a15);
    if ((v34 & 1) == 0)
LABEL_14:
      _Unwind_Resume(a1);
  }
  else if (!v34)
  {
    goto LABEL_14;
  }
  __cxa_free_exception(v33);
  goto LABEL_14;
}

uint64_t std::unordered_map<std::string,MIL::IRPixelFormatType>::unordered_map(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    v5 = 32 * a3;
    do
    {
      std::__hash_table<std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRPixelFormatType>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,MIL::IRPixelFormatType> const&>(a1, a2, (uint64_t)a2);
      a2 += 32;
      v5 -= 32;
    }
    while (v5);
  }
  return a1;
}

void sub_1E059220C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRPixelFormatType>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,MIL::IRPixelFormatType> const&>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRPixelFormatType>>>::__construct_node_hash<std::pair<std::string const,MIL::IRPixelFormatType> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  ++*v7;
  return i;
}

void sub_1E0592478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRPixelFormatType>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRPixelFormatType>>>::__construct_node_hash<std::pair<std::string const,MIL::IRPixelFormatType> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *v9;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x30uLL);
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  v9 = (std::string *)(v8 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((_QWORD *)v8 + 4) = *(_QWORD *)(a3 + 16);
  }
  *((_DWORD *)v8 + 10) = *(_DWORD *)(a3 + 24);
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_1E0592528(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void MIL::IRProgram::~IRProgram(MIL::IRProgram *this)
{
  MIL::IRCachedScope::~IRCachedScope((MIL::IRProgram *)((char *)this + 64));
  MIL::IRObject::~IRObject(this);
}

_QWORD *MIL::IRProgram::IRProgram(_QWORD *a1, __int128 *a2, uint64_t *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v8;

  v8 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  MIL::IRObject::IRObject(a1, (uint64_t)&v8, a3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  MIL::IRCachedScope::IRCachedScope((MIL::IRCachedScope *)(a1 + 8));
  *a1 = off_1EA994B38;
  a1[8] = &unk_1EA994BC0;
  return a1;
}

void sub_1E059260C(_Unwind_Exception *a1)
{
  MIL::IRObject *v1;

  MIL::IRObject::~IRObject(v1);
  _Unwind_Resume(a1);
}

void MIL::IRProgram::Make(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _anonymous_namespace_::IRProgramImpl **a4@<X8>)
{
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  _OWORD v10[2];
  int v11;
  __int128 v12;
  __int128 v13;

  v13 = *(_OWORD *)a1;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v12 = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  memset(v10, 0, sizeof(v10));
  v11 = 1065353216;
  MIL::IRProgram::Make(&v13, &v12, a3, (uint64_t *)v10, a4);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v10);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  v7 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
  if (*((_QWORD *)&v13 + 1))
  {
    v8 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_1E0592700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v15 - 32);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::IRProgramImpl **MIL::IRProgram::Make@<X0>(__int128 *a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, _anonymous_namespace_::IRProgramImpl **a5@<X8>)
{
  _anonymous_namespace_::IRProgramImpl *v10;
  __int128 v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  _anonymous_namespace_::IRProgramImpl *v18;
  _anonymous_namespace_::IRProgramImpl *v20;
  __int128 v21;
  __int128 v22;

  v10 = (_anonymous_namespace_::IRProgramImpl *)operator new();
  v11 = *a1;
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  v21 = *a2;
  v22 = v11;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v20 = v10;
  v12 = (std::__shared_weak_count *)*((_QWORD *)&v21 + 1);
  if (*((_QWORD *)&v21 + 1))
  {
    v13 = (unint64_t *)(*((_QWORD *)&v21 + 1) + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
  if (*((_QWORD *)&v22 + 1))
  {
    v16 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v20;
  v20 = 0;
  *a5 = v18;
}

void sub_1E0592844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  uint64_t v12;
  std::__shared_weak_count **v13;

  if (a12)
    MIL::IROperation::Make(a12);
  MIL::IROperation::Make(v13);
  MEMORY[0x1E0C023A0](v12, 0x10E1C4016CA2BE9);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::IRProgramImpl **std::unique_ptr<`anonymous namespace'::IRProgramImpl>::~unique_ptr[abi:ne180100](_anonymous_namespace_::IRProgramImpl **a1)
{
  _anonymous_namespace_::IRProgramImpl *v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    MEMORY[0x1E0C023A0]();
  }
  return a1;
}

uint64_t MIL::IRProgram::GetFunction(uint64_t a1)
{
  uint64_t result;
  std::logic_error *exception;
  std::string *v3;
  __int128 v4;
  std::string v5;
  std::string v6;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  if (!result)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v3 = std::string::append(&v5, "' does not exist.");
    v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    v6.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v6.__r_.__value_.__l.__data_ = v4;
    v3->__r_.__value_.__l.__size_ = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
    v3->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(exception, &v6);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  return result;
}

void sub_1E0592984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

MIL::IRProgram *MIL::IRProgram::ToString(MIL::IRProgram *this)
{
  double v2;
  const MIL::Text::SerializerOptions *v3;
  MIL::IRProgram *result;
  MIL::IRProgram *v5;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v5);
  (*(void (**)(MIL::IRProgram *, uint64_t, double))(*(_QWORD *)v5 + 112))(v5, 4, v2);
  MIL::Text::Serialize(this, v5, v3);
  result = v5;
  v5 = 0;
  if (result)
    return (MIL::IRProgram *)(*(uint64_t (**)(MIL::IRProgram *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E0592A50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::IRProgramImpl::~IRProgramImpl(_anonymous_namespace_::IRProgramImpl *this)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 176);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 160);
  MIL::IRCachedScope::~IRCachedScope((_anonymous_namespace_::IRProgramImpl *)((char *)this + 64));
  MIL::IRObject::~IRObject(this);
}

{
  JUMPOUT(0x1E0C023A0);
}

void `non-virtual thunk to'`anonymous namespace'::IRProgramImpl::~IRProgramImpl(_anonymous_namespace_::IRProgramImpl *this)
{
}

{
  JUMPOUT(0x1E0C023A0);
}

uint64_t `anonymous namespace'::IRProgramImpl::IRProgramImpl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  __int128 v12;

  v12 = *(_OWORD *)a3;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  MIL::IRProgram::IRProgram((_QWORD *)a1, &v12, a5);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  *(_QWORD *)a1 = &off_1EA994C60;
  *(_QWORD *)(a1 + 64) = &unk_1EA994CF0;
  *(_OWORD *)(a1 + 160) = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_DWORD *)(a1 + 208) = 1065353216;
  return a1;
}

void sub_1E0592B90(_Unwind_Exception *a1)
{
  MIL::IRObject *v1;
  uint64_t v2;
  MIL::IRCachedScope *v3;
  uint64_t v4;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v4);
  MIL::IRCachedScope::~IRCachedScope(v3);
  MIL::IRObject::~IRObject(v1);
  _Unwind_Resume(a1);
}

_QWORD *`anonymous namespace'::IRProgramImpl::SetFunctions(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = &off_1EA994D70;
  v4[1] = a1;
  v4[2] = a2;
  v5 = v4;
  MIL::IRCachedScope::InvalidateAndCall(a1 + 64, (uint64_t)v4);
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1E0592C98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

BOOL `anonymous namespace'::IRProgramImpl::EqualsImpl(_anonymous_namespace_::IRProgramImpl *this, const MIL::IRObject *a2)
{
  _QWORD *v2;
  char *v3;
  _BOOL8 v4;
  unsigned __int8 *v5;

  if (*(void (***)(_anonymous_namespace_::IRProgramImpl *__hidden))a2 != &off_1EA994C60
    || *((_QWORD *)this + 25) != *((_QWORD *)a2 + 25))
  {
    return 0;
  }
  v2 = (_QWORD *)((char *)a2 + 176);
  v3 = (char *)this + 192;
  do
  {
    v3 = *(char **)v3;
    v4 = v3 == 0;
    if (!v3)
      break;
    v5 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v2, (unsigned __int8 *)v3 + 16);
    if (!v5)
      break;
  }
  while ((MIL::IRObject::Equals(*((MIL::IRObject **)v3 + 5), *((const MIL::IRObject **)v5 + 5)) & 1) != 0);
  return v4;
}

void `anonymous namespace'::IRProgramImpl::Copy(_anonymous_namespace_::IRProgramImpl *this@<X0>, _anonymous_namespace_::IRProgramImpl **a2@<X8>)
{
  _QWORD v2[3];
  void **v3;

  memset(v2, 0, sizeof(v2));
  v3 = (void **)v2;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void sub_1E0592DC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IRProgramImpl::GetContext(_anonymous_namespace_::IRProgramImpl *this)
{
  return *((_QWORD *)this + 20);
}

uint64_t `anonymous namespace'::IRProgramImpl::GetContextSharedPtr@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 168);
  *a2 = *(_QWORD *)(this + 160);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t `anonymous namespace'::IRProgramImpl::TryGetFunction(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;

  v2 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 176), a2);
  if (!v2)
    return 0;
  v3 = *((_QWORD *)v2 + 5);
  v4 = (std::__shared_weak_count *)*((_QWORD *)v2 + 6);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

unsigned __int8 *`anonymous namespace'::IRProgramImpl::TryGetFunctionSharedPtr@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 176), a2);
  if (result)
  {
    v5 = *((_QWORD *)result + 6);
    *a3 = *((_QWORD *)result + 5);
    a3[1] = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

uint64_t `anonymous namespace'::IRProgramImpl::GetFunctions(_anonymous_namespace_::IRProgramImpl *this)
{
  return (uint64_t)this + 176;
}

uint64_t `anonymous namespace'::IRProgramImpl::WithFunctions@<X0>(MIL::IRObject *a1@<X0>, uint64_t a2@<X1>, _anonymous_namespace_::IRProgramImpl **a3@<X8>)
{
  uint64_t *v6;
  uint64_t *LocationPtr;
  uint64_t Attributes;
  _anonymous_namespace_::IRProgramImpl *v9;
  uint64_t v11[5];
  _anonymous_namespace_::IRProgramImpl *v12;

  v6 = (uint64_t *)((char *)a1 + 160);
  LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(a1);
  Attributes = MIL::IRObject::GetAttributes(a1);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v11, Attributes);
  v9 = v12;
  v12 = 0;
  *a3 = v9;
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v11);
}

void sub_1E0592F6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IRProgramImpl::WithRenames@<X0>(MIL::IRObject *this@<X0>, uint64_t a2@<X1>, _anonymous_namespace_::IRProgramImpl **a3@<X8>)
{
  unsigned __int8 *i;
  uint64_t v7;
  uint64_t *LocationPtr;
  uint64_t Attributes;
  _anonymous_namespace_::IRProgramImpl *v10;
  uint64_t v12[5];
  _anonymous_namespace_::IRProgramImpl *v13;
  _OWORD v14[2];
  int v15;

  memset(v14, 0, sizeof(v14));
  v15 = 1065353216;
  for (i = (unsigned __int8 *)*((_QWORD *)this + 24); i; i = *(unsigned __int8 **)i)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(**((_QWORD **)i + 5) + 224))(v12, *((_QWORD *)i + 5), a2);
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<MIL::IRFunction>>((uint64_t)v14, i + 16, (__int128 *)i + 1, v12);
    v7 = v12[0];
    v12[0] = 0;
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
  LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(this);
  Attributes = MIL::IRObject::GetAttributes(this);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v12, Attributes);
  v10 = v13;
  v13 = 0;
  *a3 = v10;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v12);
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v14);
}

void sub_1E0593074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IRProgramImpl::Convert(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 160) + 48))(*(_QWORD *)(a1 + 160), a1, a2);
}

uint64_t `anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(_anonymous_namespace_::IRProgramImpl *this)
{
  uint64_t (***v2)();
  uint64_t v3;
  uint64_t (***v4)();
  uint64_t v5;
  uint64_t (***v6)();
  uint64_t v7;
  unsigned int v9;
  uint64_t (**v10)();
  unsigned int *v11;
  unsigned int *v12;
  uint64_t (***v13)();
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v9 = 1;
  v10 = &off_1EA994DF0;
  v11 = &v9;
  v13 = &v10;
  MIL::Util::Walk((uint64_t)this, (uint64_t)&v10);
  v2 = v13;
  if (v13 == &v10)
  {
    v3 = 4;
    v2 = &v10;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v3 = 5;
  }
  (*v2)[v3]();
LABEL_6:
  v10 = &off_1EA994E80;
  v11 = (unsigned int *)this;
  v12 = &v9;
  v13 = &v10;
  MIL::Util::Walk((uint64_t)this, (uint64_t)&v10);
  v4 = v13;
  if (v13 == &v10)
  {
    v5 = 4;
    v4 = &v10;
  }
  else
  {
    if (!v13)
      goto LABEL_11;
    v5 = 5;
  }
  (*v4)[v5]();
LABEL_11:
  v10 = &off_1EA994F10;
  v11 = (unsigned int *)this;
  v12 = &v9;
  v13 = &v10;
  MIL::Util::Walk((uint64_t)this, (uint64_t)&v10);
  v6 = v13;
  if (v13 == &v10)
  {
    v7 = 4;
    v6 = &v10;
    goto LABEL_15;
  }
  if (v13)
  {
    v7 = 5;
LABEL_15:
    (*v6)[v7]();
  }
  return v9;
}

void sub_1E0593220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::IRProgramImpl::BuildScopeCache@<X0>(_QWORD *a1@<X8>)
{
  _OWORD v4[2];
  int v5;
  _OWORD v6[2];
  int v7;
  uint64_t v8;

  memset(v6, 0, sizeof(v6));
  v7 = 1065353216;
  memset(v4, 0, sizeof(v4));
  v5 = 1065353216;
  MIL::IRMutableScope::Make((uint64_t *)v6, (uint64_t *)v4, &v8);
  *a1 = v8;
  v8 = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v4);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v6);
}

void sub_1E05932C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void std::__function::__func<`anonymous namespace'::IRProgramImpl::SetFunctions(std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&)::{lambda(void)#1},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&>,void ()(void)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRProgramImpl::SetFunctions(std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&)::{lambda(void)#1},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA994D70;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRProgramImpl::SetFunctions(std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&)::{lambda(void)#1},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA994D70;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<`anonymous namespace'::IRProgramImpl::SetFunctions(std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&)::{lambda(void)#1},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t **i;

  v1 = *(_QWORD *)(a1 + 8);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__move_assign(v1 + 176, *(uint64_t **)(a1 + 16));
  for (i = *(uint64_t ***)(v1 + 192); i; i = (uint64_t **)*i)
    (*(void (**)(uint64_t *, uint64_t))(*i[5] + 184))(i[5], v1);
}

uint64_t std::__function::__func<`anonymous namespace'::IRProgramImpl::SetFunctions(std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&)::{lambda(void)#1},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRProgramImpl::SetFunctions(std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&)::{lambda(void)#1},std::allocator<std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>> &&>,void ()(void)>::target_type()
{
}

void std::make_unique[abi:ne180100]<`anonymous namespace'::IRProgramImpl,std::shared_ptr<MIL::MILContext> const&,std::shared_ptr<MIL::Location const> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRFunction>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;

  v10 = operator new();
  v11 = v10;
  v12 = (std::__shared_weak_count *)a1[1];
  v26 = *a1;
  v27 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v15 = (std::__shared_weak_count *)a2[1];
  v24 = *a2;
  v25 = v15;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  *a5 = v11;
  v18 = v25;
  if (v25)
  {
    v19 = (unint64_t *)&v25->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v27;
  if (v27)
  {
    v22 = (unint64_t *)&v27->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void sub_1E0593550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  MEMORY[0x1E0C023A0](v11, 0x10E1C4016CA2BE9);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<MIL::IRFunction>>(uint64_t a1, unsigned __int8 *a2, __int128 *a3, uint64_t *a4)
{
  unint64_t v4;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[3];

  v9 = (_QWORD *)(a1 + 24);
  v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>>>::__construct_node_hash<std::string const&,std::unique_ptr<MIL::IRFunction>>(a1, v11, a3, a4, (uint64_t)v27);
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    v20 = 1;
    if (v12 >= 3)
      v20 = (v12 & (v12 - 1)) != 0;
    v21 = v20 | (2 * v12);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v23);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v27[0] = *v24;
    *v24 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v27[0])
    {
      v25 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12)
          v25 %= v12;
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v27[0];
    }
  }
  i = (unsigned __int8 *)v27[0];
  v27[0] = 0;
  ++*v9;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v27, 0);
  return i;
}

void sub_1E05937F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRFunction>>>>::__construct_node_hash<std::string const&,std::unique_ptr<MIL::IRFunction>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  char *v10;
  std::string *result;

  v9 = a1 + 16;
  v10 = (char *)operator new(0x38uLL);
  *(_QWORD *)a5 = v10;
  *(_QWORD *)(a5 + 8) = v9;
  *(_BYTE *)(a5 + 16) = 0;
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = a2;
  result = std::pair<std::string const,std::shared_ptr<MIL::IRFunction>>::pair[abi:ne180100]<std::string const&,std::unique_ptr<MIL::IRFunction>,0>((std::string *)(v10 + 16), a3, a4);
  *(_BYTE *)(a5 + 16) = 1;
  return result;
}

void sub_1E0593878(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::shared_ptr<MIL::IRFunction>>::pair[abi:ne180100]<std::string const&,std::unique_ptr<MIL::IRFunction>,0>(std::string *this, __int128 *a2, uint64_t *a3)
{
  __int128 v5;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  std::shared_ptr<MIL::IRFunction>::shared_ptr[abi:ne180100]<MIL::IRFunction,std::default_delete<MIL::IRFunction>,void>((uint64_t *)&this[1], a3);
  return this;
}

void sub_1E05938EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t *std::shared_ptr<MIL::IRFunction>::shared_ptr[abi:ne180100]<MIL::IRFunction,std::default_delete<MIL::IRFunction>,void>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = *a2;
  *a1 = *a2;
  if (v4)
  {
    v5 = (_QWORD *)operator new();
    v6 = *a2;
    *v5 = &unk_1EA993060;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  a1[1] = (uint64_t)v5;
  *a2 = 0;
  return a1;
}

void std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1}>,BOOL ()(MIL::IROperation const&)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1}>,BOOL ()(MIL::IROperation const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA994DF0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1}>,BOOL ()(MIL::IROperation const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA994DF0;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1}>,BOOL ()(MIL::IROperation const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int *v4;
  int v5;

  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 232))(a2);
  if (v3)
  {
    v4 = *(int **)(a1 + 8);
    v5 = *v4;
    if (*v4 <= 3)
      v5 = 3;
    *v4 = v5;
  }
  return v3 == 0;
}

uint64_t std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1}>,BOOL ()(MIL::IROperation const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IROperation const&)#1}>,BOOL ()(MIL::IROperation const&)>::target_type()
{
}

void std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1}>,BOOL ()(MIL::IRFunction const&)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1}>,BOOL ()(MIL::IRFunction const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA994E80;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1}>,BOOL ()(MIL::IRFunction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA994E80;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1}>,BOOL ()(MIL::IRFunction const&)>::operator()(uint64_t a1, uint64_t a2)
{
  int v3;
  int *v4;
  int v5;

  v4 = *(int **)(a1 + 16);
  v5 = *v4;
  if (*v4 <= v3)
    v5 = v3;
  *v4 = v5;
  return 1;
}

uint64_t std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1}>,BOOL ()(MIL::IRFunction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRFunction const&)#1}>,BOOL ()(MIL::IRFunction const&)>::target_type()
{
}

uint64_t `anonymous namespace'::IRProgramImpl::MinimumRequiredSyntaxForScope(_anonymous_namespace_::IRProgramImpl *this, const MIL::IRCachedScope *a2)
{
  uint64_t **v2;
  uint64_t v3;
  void *v4;
  void *v5;

  v2 = *(uint64_t ***)((*(uint64_t (**)(_anonymous_namespace_::IRProgramImpl *, const MIL::IRCachedScope *))(*(_QWORD *)this + 32))(this, a2)+ 16);
  if (!v2)
    return 1;
  v3 = 1;
  do
  {
    if (MIL::IRValueType::TryCastAsStateType(v2[5]))
    {
      v3 = 4;
    }
    else
    {
      v4 = MIL::IRValueType::TryCastAsMemoryLayoutType(v2[5]);
      if (v4)
      {
        v5 = v4;
        if (MIL::IRMemoryLayoutValueType::TryAsPixelBufferType(v4)
          || MIL::IRMemoryLayoutValueType::TryAsCircularBufferType(v5)
          || MIL::IRMemoryLayoutValueType::TryAsTensorBufferType(v5))
        {
          if ((int)v3 <= 3)
            v3 = 3;
          else
            v3 = v3;
        }
      }
    }
    v2 = (uint64_t **)*v2;
  }
  while (v2);
  return v3;
}

void std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1}>,BOOL ()(MIL::IRBlock const&)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

__n128 std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1}>,BOOL ()(MIL::IRBlock const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA994F10;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1}>,BOOL ()(MIL::IRBlock const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA994F10;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1}>,BOOL ()(MIL::IRBlock const&)>::operator()(uint64_t a1, uint64_t a2)
{
  int v3;
  int *v4;
  int v5;

  v4 = *(int **)(a1 + 16);
  v5 = *v4;
  if (*v4 <= v3)
    v5 = v3;
  *v4 = v5;
  return 1;
}

uint64_t std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1}>,BOOL ()(MIL::IRBlock const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1},std::allocator<`anonymous namespace'::IRProgramImpl::GetMinimumRequiredSyntaxVersion(void)::{lambda(MIL::IRBlock const&)#1}>,BOOL ()(MIL::IRBlock const&)>::target_type()
{
}

_QWORD *MIL::IRScope::IRScope(MIL::IRScope *this)
{
  _QWORD *result;

  result = MIL::IRValueQueryable::IRValueQueryable(this);
  *result = off_1EA994FA0;
  return result;
}

void MIL::IRCachedScope::~IRCachedScope(MIL::IRCachedScope *this)
{
  char *v2;

  *(_QWORD *)this = off_1EA995000;
  v2 = (char *)this + 8;
  std::mutex::~mutex((std::mutex *)((char *)this + 24));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  MIL::IRValueQueryable::~IRValueQueryable(this);
}

double MIL::IRCachedScope::IRCachedScope(MIL::IRCachedScope *this)
{
  _QWORD *v1;
  double result;

  v1 = MIL::IRValueQueryable::IRValueQueryable(this);
  *v1 = off_1EA995000;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 850045863;
  result = 0.0;
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  *((_OWORD *)v1 + 4) = 0u;
  v1[10] = 0;
  *((_BYTE *)v1 + 88) = 1;
  return result;
}

void MIL::IRCachedScope::DisableCache(MIL::IRCachedScope *this)
{
  std::mutex *v2;

  v2 = (std::mutex *)((char *)this + 24);
  std::mutex::lock((std::mutex *)((char *)this + 24));
  std::shared_ptr<MIL::IRScope const>::reset[abi:ne180100]((_QWORD *)this + 1);
  atomic_store(0, (unsigned __int8 *)this + 88);
  std::mutex::unlock(v2);
}

void std::shared_ptr<MIL::IRScope const>::reset[abi:ne180100](_QWORD *a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t MIL::IRCachedScope::IsCacheEnabled(MIL::IRCachedScope *this)
{
  std::mutex *v2;
  unsigned __int8 v3;
  uint64_t v4;

  v2 = (std::mutex *)((char *)this + 24);
  std::mutex::lock((std::mutex *)((char *)this + 24));
  v3 = atomic_load((unsigned __int8 *)this + 88);
  v4 = v3 & 1;
  std::mutex::unlock(v2);
  return v4;
}

void MIL::IRCachedScope::InvalidateAndCall(uint64_t a1, uint64_t a2)
{
  std::mutex *v4;
  uint64_t v5;

  v4 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  std::shared_ptr<MIL::IRScope const>::reset[abi:ne180100]((_QWORD *)(a1 + 8));
  v5 = *(_QWORD *)(a2 + 24);
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
  std::mutex::unlock(v4);
}

void sub_1E0593EE8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCachedScope::GetParent(MIL::IRCachedScope *this)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v6;
  std::__shared_weak_count *v7;

  MIL::IRCachedScope::GetScope(this, &v6);
  v1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 72))(v6);
  v2 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return v1;
}

void sub_1E0593F74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void MIL::IRCachedScope::GetScope(MIL::IRCachedScope *this@<X0>, _QWORD *a2@<X8>)
{
  unsigned __int8 v4;
  std::mutex *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  unsigned __int8 v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;

  v4 = atomic_load((unsigned __int8 *)this + 88);
  if ((v4 & 1) == 0)
  {
    v5 = (std::mutex *)((char *)this + 24);
    std::mutex::lock((std::mutex *)((char *)this + 24));
    (*(void (**)(uint64_t *__return_ptr, MIL::IRCachedScope *))(*(_QWORD *)this + 80))(&v21, this);
    std::shared_ptr<MIL::IRScope const>::operator=[abi:ne180100]<MIL::IRScope const,std::default_delete<MIL::IRScope const>,void>((_QWORD *)this + 1, &v21);
    v6 = v21;
    v21 = 0;
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    v7 = *((_QWORD *)this + 2);
    *a2 = *((_QWORD *)this + 1);
    a2[1] = v7;
    if (v7)
    {
      v8 = (unint64_t *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
LABEL_7:
    std::mutex::unlock(v5);
    return;
  }
  v11 = (uint64_t *)((char *)this + 8);
  v10 = *((_QWORD *)this + 1);
  if (!v10)
  {
    v5 = (std::mutex *)((char *)this + 24);
    std::mutex::lock((std::mutex *)((char *)this + 24));
    v12 = atomic_load((unsigned __int8 *)this + 88);
    if ((v12 & 1) == 0)
    {
      (*(void (**)(uint64_t *__return_ptr, MIL::IRCachedScope *))(*(_QWORD *)this + 80))(&v21, this);
      std::shared_ptr<MIL::IRScope const>::operator=[abi:ne180100]<MIL::IRScope const,std::default_delete<MIL::IRScope const>,void>((_QWORD *)this + 1, &v21);
      v13 = v21;
      v21 = 0;
      if (v13)
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
      v14 = *((_QWORD *)this + 2);
      *a2 = *((_QWORD *)this + 1);
      a2[1] = v14;
      if (v14)
      {
        v15 = (unint64_t *)(v14 + 8);
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
      goto LABEL_7;
    }
    if (!*v11)
    {
      (*(void (**)(uint64_t *__return_ptr, MIL::IRCachedScope *))(*(_QWORD *)this + 80))(&v21, this);
      std::shared_ptr<MIL::IRScope const>::operator=[abi:ne180100]<MIL::IRScope const,std::default_delete<MIL::IRScope const>,void>((_QWORD *)this + 1, &v21);
      v17 = v21;
      v21 = 0;
      if (v17)
        (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
    }
    std::mutex::unlock((std::mutex *)((char *)this + 24));
    v10 = *v11;
  }
  v18 = *((_QWORD *)this + 2);
  *a2 = v10;
  a2[1] = v18;
  if (v18)
  {
    v19 = (unint64_t *)(v18 + 8);
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
}

void sub_1E0594120(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::mutex *v10;

  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  std::mutex::unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCachedScope::GetType(MIL::IRCachedScope *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v10;
  std::__shared_weak_count *v11;

  MIL::IRCachedScope::GetScope(a1, &v10);
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 16))(v10, a2, a3);
  v6 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v5;
}

void sub_1E05941EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCachedScope::TryGetType(MIL::IRCachedScope *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v10;
  std::__shared_weak_count *v11;

  MIL::IRCachedScope::GetScope(a1, &v10);
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 24))(v10, a2, a3);
  v6 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v5;
}

void sub_1E0594288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCachedScope::GetTypes(MIL::IRCachedScope *this)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v6;
  std::__shared_weak_count *v7;

  MIL::IRCachedScope::GetScope(this, &v6);
  v1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 32))(v6);
  v2 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return v1;
}

void sub_1E0594314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCachedScope::GetValue(MIL::IRCachedScope *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v10;
  std::__shared_weak_count *v11;

  MIL::IRCachedScope::GetScope(a1, &v10);
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 40))(v10, a2, a3);
  v6 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v5;
}

void sub_1E05943B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCachedScope::TryGetValue(MIL::IRCachedScope *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v10;
  std::__shared_weak_count *v11;

  MIL::IRCachedScope::GetScope(a1, &v10);
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 48))(v10, a2, a3);
  v6 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v5;
}

void sub_1E059444C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void MIL::IRCachedScope::TryGetValueSharedPtr(MIL::IRCachedScope *a1, uint64_t a2, uint64_t a3)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  MIL::IRCachedScope::GetScope(a1, &v8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 56))(v8, a2, a3);
  v5 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1E0594500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCachedScope::GetValues(MIL::IRCachedScope *this)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v6;
  std::__shared_weak_count *v7;

  MIL::IRCachedScope::GetScope(this, &v6);
  v1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 64))(v6);
  v2 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return v1;
}

void sub_1E059458C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<MIL::IRScope const>::operator=[abi:ne180100]<MIL::IRScope const,std::default_delete<MIL::IRScope const>,void>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  if (*a2)
  {
    v5 = (_QWORD *)operator new();
    v6 = *a2;
    *v5 = &unk_1EA995138;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  *a2 = 0;
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

_QWORD *MIL::IRMutableScope::IRMutableScope(MIL::IRMutableScope *this)
{
  _QWORD *result;

  result = MIL::IRValueQueryable::IRValueQueryable(this);
  *result = off_1EA995068;
  return result;
}

_QWORD *MIL::IRMutableScope::Make@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  *a4 = v8;
  return result;
}

void sub_1E05946E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0x10E1C40EC1D54C1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRMutableScope::Make@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  *a3 = v6;
  return result;
}

void sub_1E0594760(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0x10E1C40EC1D54C1);
  _Unwind_Resume(a1);
}

double MIL::IRMutableScope::Make@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v3;
  double result;

  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  MIL::IRValueQueryable::IRValueQueryable((_QWORD *)v3);
  *(_QWORD *)v3 = &off_1EA995198;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_DWORD *)(v3 + 48) = 1065353216;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_DWORD *)(v3 + 88) = 1065353216;
  *a1 = v3;
  return result;
}

void sub_1E05947FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0x10E1C40EC1D54C1);
  _Unwind_Resume(a1);
}

MIL::IRValueQueryable *std::default_delete<`anonymous namespace'::IRScopeImpl>::operator()[abi:ne180100](MIL::IRValueQueryable *result)
{
  MIL::IRValueQueryable *v1;

  if (result)
  {
    v1 = result;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)result + 56);
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v1 + 16);
    MIL::IRValueQueryable::~IRValueQueryable(v1);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

void `anonymous namespace'::IRScopeImpl::~IRScopeImpl(_anonymous_namespace_::IRScopeImpl *this)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 56);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)this + 16);
  MIL::IRValueQueryable::~IRValueQueryable(this);
}

{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 56);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)this + 16);
  MIL::IRValueQueryable::~IRValueQueryable(this);
  JUMPOUT(0x1E0C023A0);
}

void std::__shared_ptr_pointer<MIL::IRScope const *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::IRScope const *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IRScope const *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *`anonymous namespace'::IRScopeImpl::IRScopeImpl(_QWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  _QWORD *v8;

  v8 = MIL::IRValueQueryable::IRValueQueryable(a1);
  *v8 = &off_1EA995198;
  v8[1] = a2;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)(v8 + 2), a3);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)(a1 + 7), a4);
  return a1;
}

uint64_t `anonymous namespace'::IRScopeImpl::GetType(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t result;
  void *exception;
  _QWORD *v5;
  uint64_t v6;
  std::string v7;
  std::string v8;
  uint64_t v9;
  _QWORD v10[2];

  if (!result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    MIL::UnknownLocation::Make(&v9);
    v10[0] = v9;
    if (v9)
    {
      v5 = (_QWORD *)operator new();
      v6 = v9;
      *v5 = &unk_1EA9940C8;
      v5[1] = 0;
      v5[2] = 0;
      v5[3] = v6;
    }
    else
    {
      v5 = 0;
    }
    v10[1] = v5;
    v9 = 0;
    std::operator+<char>();
    std::string::push_back(&v7, 46);
    v8 = v7;
    memset(&v7, 0, sizeof(v7));
    MIL::OutOfRangeError::OutOfRangeError(exception, v10, &v8);
  }
  return result;
}

void sub_1E0594AB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22)
{
  void *v22;
  int v23;
  uint64_t v24;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v24 - 48);
  if (a22)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a22 + 8))(a22);
    if ((v23 & 1) == 0)
      goto LABEL_10;
  }
  else if (!v23)
  {
LABEL_10:
    _Unwind_Resume(a1);
  }
  __cxa_free_exception(v22);
  goto LABEL_10;
}

uint64_t `anonymous namespace'::IRScopeImpl::TryGetType(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unsigned __int8 *v6;
  uint64_t result;

  v6 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 16), a2);
  if (v6)
  {
    if ((a3 & 1) != 0 || *(_QWORD *)(a1 + 8))
      return *((_QWORD *)v6 + 5);
    else
      return 0;
  }
  else
  {
    result = *(_QWORD *)(a1 + 8);
    if (result)
      return (*(uint64_t (**)(uint64_t, unsigned __int8 *, uint64_t))(*(_QWORD *)result + 24))(result, a2, a3);
  }
  return result;
}

uint64_t `anonymous namespace'::IRScopeImpl::GetTypes(_anonymous_namespace_::IRScopeImpl *this)
{
  return (uint64_t)this + 16;
}

uint64_t `anonymous namespace'::IRScopeImpl::GetValue(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t result;
  void *exception;
  _QWORD *v5;
  uint64_t v6;
  std::string v7;
  std::string v8;
  uint64_t v9;
  _QWORD v10[2];

  if (!result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    MIL::UnknownLocation::Make(&v9);
    v10[0] = v9;
    if (v9)
    {
      v5 = (_QWORD *)operator new();
      v6 = v9;
      *v5 = &unk_1EA9940C8;
      v5[1] = 0;
      v5[2] = 0;
      v5[3] = v6;
    }
    else
    {
      v5 = 0;
    }
    v10[1] = v5;
    v9 = 0;
    std::operator+<char>();
    std::string::push_back(&v7, 46);
    v8 = v7;
    memset(&v7, 0, sizeof(v7));
    MIL::OutOfRangeError::OutOfRangeError(exception, v10, &v8);
  }
  return result;
}

void sub_1E0594CD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22)
{
  void *v22;
  int v23;
  uint64_t v24;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v24 - 48);
  if (a22)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a22 + 8))(a22);
    if ((v23 & 1) == 0)
      goto LABEL_10;
  }
  else if (!v23)
  {
LABEL_10:
    _Unwind_Resume(a1);
  }
  __cxa_free_exception(v22);
  goto LABEL_10;
}

uint64_t `anonymous namespace'::IRScopeImpl::TryGetValue(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v8;
  std::__shared_weak_count *v9;

  v3 = v8;
  v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

unsigned __int8 *`anonymous namespace'::IRScopeImpl::TryGetValueSharedPtr@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  unsigned __int8 *result;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  result = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 56), a2);
  if (!result)
  {
    result = *(unsigned __int8 **)(a1 + 8);
    if (result)
      return (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(*(_QWORD *)result + 56))(result, a2, a3);
    goto LABEL_10;
  }
  if ((a3 & 1) == 0 && !*(_QWORD *)(a1 + 8))
  {
LABEL_10:
    *a4 = 0;
    a4[1] = 0;
    return result;
  }
  v9 = *((_QWORD *)result + 6);
  *a4 = *((_QWORD *)result + 5);
  a4[1] = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  return result;
}

uint64_t `anonymous namespace'::IRScopeImpl::GetValues(_anonymous_namespace_::IRScopeImpl *this)
{
  return (uint64_t)this + 56;
}

uint64_t `anonymous namespace'::IRScopeImpl::GetParent(_anonymous_namespace_::IRScopeImpl *this)
{
  return *((_QWORD *)this + 1);
}

BOOL `anonymous namespace'::IRScopeImpl::SetType(uint64_t a1, unsigned __int8 *a2, uint64_t a3, char a4)
{
  uint64_t v7;
  unsigned __int8 *v8;
  _BOOL8 v9;
  void *exception;
  _QWORD *v12;
  uint64_t v13;
  std::string *v14;
  __int128 v15;
  std::string v16;
  __int128 v17;
  std::string::size_type v18;
  uint64_t v19;
  _QWORD v20[2];

  v7 = a1 + 16;
  v8 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 16), a2);
  if (v8 && (a4 & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    MIL::UnknownLocation::Make(&v19);
    v20[0] = v19;
    if (v19)
    {
      v12 = (_QWORD *)operator new();
      v13 = v19;
      *v12 = &unk_1EA9940C8;
      v12[1] = 0;
      v12[2] = 0;
      v12[3] = v13;
    }
    else
    {
      v12 = 0;
    }
    v20[1] = v12;
    v19 = 0;
    std::operator+<char>();
    v14 = std::string::append(&v16, "' already exists in scope.");
    v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v18 = v14->__r_.__value_.__r.__words[2];
    v17 = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    MIL::InvalidOperationError::InvalidOperationError(exception, v20, &v17);
  }
  v9 = v8 == 0;
  v16.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
  *((_QWORD *)std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v7, a2, (uint64_t)&std::piecewise_construct, (__int128 **)&v16)+ 5) = a3;
  return v9;
}

void sub_1E0594FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22)
{
  void *v22;
  int v23;
  uint64_t v24;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v24 - 48);
  if (a22)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a22 + 8))(a22);
    if ((v23 & 1) == 0)
      goto LABEL_10;
  }
  else if (!v23)
  {
LABEL_10:
    _Unwind_Resume(a1);
  }
  __cxa_free_exception(v22);
  goto LABEL_10;
}

BOOL `anonymous namespace'::IRScopeImpl::SetValue(uint64_t a1, unsigned __int8 *a2, __int128 *a3, char a4)
{
  uint64_t v7;
  unsigned __int8 *v8;
  _BOOL8 v9;
  unsigned __int8 *v10;
  void *exception;
  _QWORD *v13;
  uint64_t v14;
  std::string *v15;
  __int128 v16;
  std::string v17;
  __int128 v18;
  std::string::size_type v19;
  uint64_t v20;
  _QWORD v21[2];

  v7 = a1 + 56;
  v8 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 56), a2);
  if (v8 && (a4 & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    MIL::UnknownLocation::Make(&v20);
    v21[0] = v20;
    if (v20)
    {
      v13 = (_QWORD *)operator new();
      v14 = v20;
      *v13 = &unk_1EA9940C8;
      v13[1] = 0;
      v13[2] = 0;
      v13[3] = v14;
    }
    else
    {
      v13 = 0;
    }
    v21[1] = v13;
    v20 = 0;
    std::operator+<char>();
    v15 = std::string::append(&v17, "' already found in scope.");
    v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v19 = v15->__r_.__value_.__r.__words[2];
    v18 = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    MIL::InvalidOperationError::InvalidOperationError(exception, v21, &v18);
  }
  v9 = v8 == 0;
  v17.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
  v10 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v7, a2, (uint64_t)&std::piecewise_construct, (__int128 **)&v17);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]((uint64_t)(v10 + 40), a3);
  return v9;
}

void sub_1E05951C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22)
{
  void *v22;
  int v23;
  uint64_t v24;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v24 - 48);
  if (a22)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a22 + 8))(a22);
    if ((v23 & 1) == 0)
      goto LABEL_10;
  }
  else if (!v23)
  {
LABEL_10:
    _Unwind_Resume(a1);
  }
  __cxa_free_exception(v22);
  goto LABEL_10;
}

uint64_t `anonymous namespace'::IRScopeImpl::WithRenames@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  _QWORD *v14;
  _QWORD *v15;
  __int128 *v17[5];
  uint64_t v18[5];
  __int128 *v19;

  std::unordered_map<std::string,MIL::IRValueType const*>::unordered_map((uint64_t)v18, a1 + 16);
  v6 = *a2;
  v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      v8 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v18, (unsigned __int8 *)v6);
      if (v8)
      {
        v9 = *((_QWORD *)v8 + 5);
        v17[0] = (__int128 *)(v6 + 24);
        *((_QWORD *)std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v18, (unsigned __int8 *)(v6 + 24), (uint64_t)&std::piecewise_construct, v17)+ 5) = v9;
        std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__erase_unique<std::string>(v18, (unsigned __int8 *)v6);
      }
      v6 += 48;
    }
    while (v6 != v7);
  }
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v17, a1 + 56);
  v10 = *a2;
  v11 = a2[1];
  if (*a2 != v11)
  {
    do
    {
      v12 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v17, (unsigned __int8 *)v10);
      if (v12)
      {
        v19 = (__int128 *)(v10 + 24);
        v13 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v17, (unsigned __int8 *)(v10 + 24), (uint64_t)&std::piecewise_construct, &v19);
        std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]((_QWORD *)v13 + 5, (uint64_t *)v12 + 5);
        std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>(v17, (unsigned __int8 *)v10);
      }
      v10 += 48;
    }
    while (v10 != v11);
  }
  v14 = (_QWORD *)operator new();
  *a3 = v14;
  v15 = (_QWORD *)operator new();
  *v15 = &off_1EA995238;
  v15[1] = 0;
  v15[2] = 0;
  v15[3] = v14;
  a3[1] = v15;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v17);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v18);
}

void sub_1E05953F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  MIL::IRValueQueryable *v14;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a14);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IRScopeImpl::SetParent(uint64_t this, const MIL::IRScope *a2)
{
  *(_QWORD *)(this + 8) = a2;
  return this;
}

unsigned __int8 *`anonymous namespace'::IRScopeImpl::RemoveTypeAndValue(uint64_t a1, unsigned __int8 *a2)
{
  std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__erase_unique<std::string>((_QWORD *)(a1 + 16), a2);
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>((_QWORD *)(a1 + 56), a2);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  ++*v8;
  return i;
}

void sub_1E05956F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a13, __p);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;
  __int128 *v10;
  __int128 v11;

  v7 = a1 + 16;
  v8 = operator new(0x30uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
  }
  else
  {
    v11 = *v10;
    v8[4] = *((_QWORD *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  v8[5] = 0;
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_1E05957A4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<std::string,MIL::IRValueType const*>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned __int8 **)(a2 + 16); i; i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,MIL::IRValueType const*> const&>(a1, i + 16, (uint64_t)(i + 16));
  return a1;
}

void sub_1E059581C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,MIL::IRValueType const*> const&>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__construct_node_hash<std::pair<std::string const,MIL::IRValueType const*> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  ++*v7;
  return i;
}

void sub_1E0595A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__construct_node_hash<std::pair<std::string const,MIL::IRValueType const*> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;

  v7 = a1 + 16;
  v8 = operator new(0x30uLL);
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v8[4] = *(_QWORD *)(a3 + 16);
  }
  v8[5] = *(_QWORD *)(a3 + 24);
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_1E0595B3C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__erase_unique<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  uint64_t *result;

  result = (uint64_t *)std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  void **v3;
  void *__p;
  uint64_t v6;

  v2 = *a2;
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::remove(a1, a2, (uint64_t)&__p);
  v3 = (void **)__p;
  __p = 0;
  if (v3)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  return v2;
}

void std::__shared_ptr_pointer<`anonymous namespace'::IRScopeImpl  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

MIL::IRValueQueryable *std::__shared_ptr_pointer<`anonymous namespace'::IRScopeImpl  *>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<`anonymous namespace'::IRScopeImpl  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_QWORD *MIL::IRValue::IRValue(_QWORD *this)
{
  *this = off_1EA995298;
  return this;
}

uint64_t MIL::IRValue::TryAsTensor(MIL::IRValue *this)
{
  return 0;
}

uint64_t MIL::IRValue::AsTensor(MIL::IRValue *this)
{
  uint64_t result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  result = (*(uint64_t (**)(MIL::IRValue *))(*(_QWORD *)this + 40))(this);
  if (!result)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

uint64_t MIL::IRValue::TryAsList(MIL::IRValue *this)
{
  return 0;
}

uint64_t MIL::IRValue::AsList(MIL::IRValue *this)
{
  uint64_t result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  result = (*(uint64_t (**)(MIL::IRValue *))(*(_QWORD *)this + 48))(this);
  if (!result)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

uint64_t MIL::IRValue::TryAsTuple(MIL::IRValue *this)
{
  return 0;
}

uint64_t MIL::IRValue::AsTuple(MIL::IRValue *this)
{
  uint64_t result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  result = (*(uint64_t (**)(MIL::IRValue *))(*(_QWORD *)this + 56))(this);
  if (!result)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

uint64_t MIL::IRValue::TryAsDictionary(MIL::IRValue *this)
{
  return 0;
}

uint64_t MIL::IRValue::AsDictionary(MIL::IRValue *this)
{
  uint64_t result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  result = (*(uint64_t (**)(MIL::IRValue *))(*(_QWORD *)this + 64))(this);
  if (!result)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

uint64_t `anonymous namespace'::TryGetScalarHelper<BOOL>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<BOOL>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<unsigned char>(void *lpsrc)
{
  void *v2;
  uint64_t result;

  if (lpsrc)
  {
    if (v2)
      return MIL::IRTypedTensorValue<BOOL>::TryGetScalarValue((uint64_t)v2);
  }
  if (!result)
  return result;
}

uint64_t `anonymous namespace'::TryGetScalarHelper<unsigned short>(void *lpsrc)
{
  void *v2;
  uint64_t result;

  if (lpsrc)
  {
    if (v2)
      return MIL::IRTypedTensorValue<MIL::Bf16>::TryGetScalarValue((uint64_t)v2);
  }
  if (!result)
  return result;
}

uint64_t `anonymous namespace'::TryGetScalarHelper<unsigned int>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<float>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<unsigned long long>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<double>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<signed char>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<BOOL>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<short>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<MIL::Bf16>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<int>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<float>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<long long>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<double>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<MIL::Fp8E5M2>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<BOOL>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<MIL::Fp8E4M3FN>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<BOOL>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<MIL::Bf16>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<MIL::Bf16>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<MIL::Fp16>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<MIL::Bf16>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<float>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<float>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<double>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<double>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::TryGetScalarHelper<std::string>(const void *a1)
{
  void *v1;

  if (a1
  {
    return MIL::IRTypedTensorValue<std::string>::TryGetScalarValue((uint64_t)v1);
  }
  else
  {
    return 0;
  }
}

uint64_t MIL::IRValue::GetScalar<BOOL>(const void *a1)
{
  unsigned __int8 *Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *Scalar;
}

uint64_t MIL::IRValue::GetScalar<unsigned char>(void *a1)
{
  unsigned __int8 *Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *Scalar;
}

uint64_t MIL::IRValue::GetScalar<unsigned short>(void *a1)
{
  unsigned __int16 *Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *Scalar;
}

uint64_t MIL::IRValue::GetScalar<unsigned int>(const void *a1)
{
  unsigned int *Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *Scalar;
}

uint64_t MIL::IRValue::GetScalar<unsigned long long>(const void *a1)
{
  uint64_t Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *(_QWORD *)Scalar;
}

uint64_t MIL::IRValue::GetScalar<signed char>(const void *a1)
{
  char *Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *Scalar;
}

uint64_t MIL::IRValue::GetScalar<short>(const void *a1)
{
  __int16 *Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *Scalar;
}

uint64_t MIL::IRValue::GetScalar<int>(const void *a1)
{
  unsigned int *Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *Scalar;
}

uint64_t MIL::IRValue::GetScalar<long long>(const void *a1)
{
  uint64_t Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *(_QWORD *)Scalar;
}

uint64_t MIL::IRValue::GetScalar<MIL::Fp8E5M2>(const void *a1)
{
  unsigned __int8 *v1;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!v1)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *v1;
}

uint64_t MIL::IRValue::GetScalar<MIL::Fp8E4M3FN>(const void *a1)
{
  unsigned __int8 *v1;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!v1)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *v1;
}

uint64_t MIL::IRValue::GetScalar<MIL::Bf16>(const void *a1)
{
  unsigned __int16 *v1;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!v1)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *v1;
}

uint64_t MIL::IRValue::GetScalar<MIL::Fp16>(const void *a1)
{
  unsigned __int16 *v1;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!v1)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *v1;
}

float MIL::IRValue::GetScalar<float>(const void *a1)
{
  uint64_t Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *(float *)Scalar;
}

double MIL::IRValue::GetScalar<double>(const void *a1)
{
  uint64_t Scalar;
  std::bad_cast *exception;
  std::bad_cast *v4;

  if (!Scalar)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return *(double *)Scalar;
}

void MIL::IRValue::GetScalar<std::string>(const void *a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v3;
  __int128 v4;
  std::bad_cast *exception;
  std::bad_cast *v6;

  if (!v3)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v6 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v6, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  if (*(char *)(v3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)v3, *(_QWORD *)(v3 + 8));
  }
  else
  {
    v4 = *(_OWORD *)v3;
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(v3 + 16);
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v4;
  }
}

_QWORD *MIL::IRTensorValue::IRTensorValue(_QWORD *this)
{
  *this = off_1EA9952F8;
  return this;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<BOOL>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if (v3)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

void `anonymous namespace'::TryGetDataViewHelper<unsigned char>(void *lpsrc@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  _BYTE v15[8];
  uint64_t v16;
  uint64_t v17;
  _BYTE v18[8];
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[8];
  uint64_t v22;
  uint64_t v23;
  _BYTE v24[8];
  uint64_t v25;
  uint64_t v26;
  _BYTE v27[8];
  uint64_t v28;
  unint64_t v29;
  _BYTE v30[8];
  uint64_t v31;
  uint64_t v32;
  _BYTE v33[8];
  uint64_t v34;
  unint64_t v35;
  _BYTE v36[8];
  uint64_t v37;
  unint64_t v38;
  _BYTE v39[8];
  uint64_t v40;
  unint64_t v41;

  if (!lpsrc
  {
    if (v39[0])
    {
      v8 = v40;
      v9 = v41;
LABEL_9:
      v11 = ((v9 >> 1) & 0x1FFFFFFFFFFFFFFFLL) + (v9 & 1);
      v10 = v11 == 0;
LABEL_10:
      if (v10)
        v8 = 0;
      *(_BYTE *)a2 = 1;
LABEL_23:
      *(_QWORD *)(a2 + 8) = v8;
      *(_QWORD *)(a2 + 16) = v11;
      return;
    }
    if (v36[0])
    {
      v8 = v37;
      v12 = v38;
LABEL_15:
      v13 = v12 >> 3;
      v14 = (v12 & 7) == 0;
      goto LABEL_18;
    }
    if (v33[0])
    {
      v8 = v34;
      v13 = (v35 >> 2) & 0x1FFFFFFFFFFFFFFFLL;
      v14 = (v35 & 3) == 0;
    }
    else
    {
      if (v30[0])
      {
        v8 = v31;
        v12 = 3 * v32;
        goto LABEL_15;
      }
      if (v27[0])
      {
        v8 = v28;
        v9 = v29;
        goto LABEL_9;
      }
      if (!v24[0])
      {
        if (v21[0])
        {
          v8 = v22;
          v11 = v23;
        }
        else
        {
          if (v18[0])
          {
            v8 = v19;
            v11 = v20;
          }
          else
          {
            if (!v15[0])
            {
              *(_QWORD *)(a2 + 8) = 0;
              *(_QWORD *)(a2 + 16) = 0;
              *(_BYTE *)a2 = 0;
              return;
            }
            v8 = v16;
            v11 = v17;
          }
        }
        v10 = v11 == 0;
        goto LABEL_10;
      }
      v8 = v25;
      v13 = ((unint64_t)(3 * v26) >> 2) & 0x1FFFFFFFFFFFFFFFLL;
      v14 = ((6 * v26) & 6) == 0;
    }
LABEL_18:
    if (v14)
      v11 = v13;
    else
      v11 = v13 + 1;
    *(_BYTE *)a2 = 1;
    if (!v11)
      v8 = 0;
    goto LABEL_23;
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(v4[2]);
  *(_BYTE *)a2 = 1;
  if (v6)
    v7 = View;
  else
    v7 = 0;
  *(_QWORD *)(a2 + 8) = v7;
  *(_QWORD *)(a2 + 16) = v6;
}

uint64_t `anonymous namespace'::TryGetDataViewHelper<unsigned short>@<X0>(uint64_t *lpsrc@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v11[8];
  uint64_t v12;
  uint64_t v13;
  _BYTE v14[8];
  uint64_t v15;
  uint64_t v16;

  if (lpsrc
  {
    result = MIL::IRValueContiguousData<BOOL>::GetView(v4[2]);
    *(_BYTE *)a2 = 1;
    if ((v6 & 0x7FFFFFFFFFFFFFFFLL) != 0)
      v7 = result;
    else
      v7 = 0;
    *(_QWORD *)(a2 + 8) = v7;
    *(_QWORD *)(a2 + 16) = v6 & 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    if (v14[0])
    {
      v8 = v15;
      v9 = v16;
    }
    else
    {
      if (!v11[0])
      {
        *(_QWORD *)(a2 + 8) = 0;
        *(_QWORD *)(a2 + 16) = 0;
        *(_BYTE *)a2 = 0;
        return result;
      }
      v8 = v12;
      v9 = v13;
    }
    v10 = v9 & 0x7FFFFFFFFFFFFFFFLL;
    if (!v10)
      v8 = 0;
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v8;
    *(_QWORD *)(a2 + 16) = v10;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<unsigned int>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if ((v3 & 0x3FFFFFFFFFFFFFFFLL) != 0)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3 & 0x3FFFFFFFFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<unsigned long long>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if ((v3 & 0x1FFFFFFFFFFFFFFFLL) != 0)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3 & 0x1FFFFFFFFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<signed char>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if (v3)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<short>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if ((v3 & 0x7FFFFFFFFFFFFFFFLL) != 0)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3 & 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<int>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if ((v3 & 0x3FFFFFFFFFFFFFFFLL) != 0)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3 & 0x3FFFFFFFFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<long long>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if ((v3 & 0x1FFFFFFFFFFFFFFFLL) != 0)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3 & 0x1FFFFFFFFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<MIL::Fp8E5M2>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if (v3)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<MIL::Fp8E4M3FN>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if (v3)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<MIL::Bf16>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if ((v3 & 0x7FFFFFFFFFFFFFFFLL) != 0)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3 & 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<MIL::Fp16>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if ((v3 & 0x7FFFFFFFFFFFFFFFLL) != 0)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3 & 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<float>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if ((v3 & 0x3FFFFFFFFFFFFFFFLL) != 0)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3 & 0x3FFFFFFFFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<double>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if ((v3 & 0x1FFFFFFFFFFFFFFFLL) != 0)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v3 & 0x1FFFFFFFFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t *`anonymous namespace'::TryGetDataViewHelper<std::string>@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t *v4;

  if (result
  {
    result = (uint64_t *)MIL::IRValueContiguousData<BOOL>::GetView(result[2]);
    *(_BYTE *)a2 = 1;
    if ((unint64_t)(24 * v3) >= 0x18)
      v4 = result;
    else
      v4 = 0;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = 24 * v3 / 0x18uLL;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

void `anonymous namespace'::TryGetDataViewHelper<MIL::Int4>(const void *a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1
  {
    v4 = v3;
    View = MIL::IRValueContiguousData<BOOL>::GetView(v3[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4[1] + 16))(v4[1]);
    MIL::Util::CastToBitSpan<MIL::Int4 const,unsigned char const,true>(View, v7, v8);
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v9;
    *(_QWORD *)(a2 + 16) = v10;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
}

void `anonymous namespace'::TryGetDataViewHelper<MIL::UInt6>(const void *a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1
  {
    v4 = v3;
    View = MIL::IRValueContiguousData<BOOL>::GetView(v3[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4[1] + 16))(v4[1]);
    MIL::Util::CastToBitSpan<MIL::UInt6 const,unsigned char const,true>(View, v7, v8);
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v9;
    *(_QWORD *)(a2 + 16) = v10;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
}

void `anonymous namespace'::TryGetDataViewHelper<MIL::UInt4>(const void *a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1
  {
    v4 = v3;
    View = MIL::IRValueContiguousData<BOOL>::GetView(v3[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4[1] + 16))(v4[1]);
    MIL::Util::CastToBitSpan<MIL::UInt4 const,unsigned char const,true>(View, v7, v8);
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v9;
    *(_QWORD *)(a2 + 16) = v10;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
}

void `anonymous namespace'::TryGetDataViewHelper<MIL::UInt3>(const void *a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1
  {
    v4 = v3;
    View = MIL::IRValueContiguousData<BOOL>::GetView(v3[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4[1] + 16))(v4[1]);
    MIL::Util::CastToBitSpan<MIL::UInt3 const,unsigned char const,true>(View, v7, v8);
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v9;
    *(_QWORD *)(a2 + 16) = v10;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
}

void `anonymous namespace'::TryGetDataViewHelper<MIL::UInt2>(const void *a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1
  {
    v4 = v3;
    View = MIL::IRValueContiguousData<BOOL>::GetView(v3[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4[1] + 16))(v4[1]);
    MIL::Util::CastToBitSpan<MIL::UInt2 const,unsigned char const,true>(View, v7, v8);
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v9;
    *(_QWORD *)(a2 + 16) = v10;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
}

void `anonymous namespace'::TryGetDataViewHelper<MIL::UInt1>(const void *a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1
  {
    v4 = v3;
    View = MIL::IRValueContiguousData<BOOL>::GetView(v3[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4[1] + 16))(v4[1]);
    MIL::Util::CastToBitSpan<MIL::UInt1 const,unsigned char const,true>(View, v7, v8);
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v9;
    *(_QWORD *)(a2 + 16) = v10;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
}

uint64_t MIL::IRTensorValue::GetDataView<BOOL>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<unsigned char>(void *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<unsigned short>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<unsigned int>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<unsigned long long>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<signed char>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<short>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<int>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<long long>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<MIL::Fp8E5M2>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<MIL::Fp8E4M3FN>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<MIL::Bf16>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<MIL::Fp16>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<float>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<double>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<std::string>(uint64_t *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<MIL::Int4>(const void *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<MIL::UInt6>(const void *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<MIL::UInt4>(const void *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<MIL::UInt3>(const void *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<MIL::UInt2>(const void *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

uint64_t MIL::IRTensorValue::GetDataView<MIL::UInt1>(const void *a1)
{
  std::bad_cast *exception;
  std::bad_cast *v3;
  _BYTE v4[8];
  uint64_t v5;

  if (!v4[0])
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return v5;
}

void MIL::IRTypedTensorValue<MIL::Int4>::GetValues(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::Int4 const,unsigned char const,true>(View, v4, v5);
}

void MIL::Util::CastToBitSpan<MIL::Int4 const,unsigned char const,true>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::logic_error *exception;

  if (a2 != vcvtpd_u64_f64((double)(unint64_t)(4 * a3) * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "BitSpanCast to sub-byte type span has invalid number of elements. Sub-byte span with NumElements requires exactly Span<uint8_t>.Size() bytes.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
}

void sub_1E05978C4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::IRTypedTensorValue<MIL::UInt6>::GetValues(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt6 const,unsigned char const,true>(View, v4, v5);
}

void MIL::Util::CastToBitSpan<MIL::UInt6 const,unsigned char const,true>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::logic_error *exception;

  if (a2 != vcvtpd_u64_f64((double)(unint64_t)(6 * a3) * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "BitSpanCast to sub-byte type span has invalid number of elements. Sub-byte span with NumElements requires exactly Span<uint8_t>.Size() bytes.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
}

void sub_1E059799C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::IRTypedTensorValue<MIL::UInt4>::GetValues(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt4 const,unsigned char const,true>(View, v4, v5);
}

void MIL::Util::CastToBitSpan<MIL::UInt4 const,unsigned char const,true>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::logic_error *exception;

  if (a2 != vcvtpd_u64_f64((double)(unint64_t)(4 * a3) * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "BitSpanCast to sub-byte type span has invalid number of elements. Sub-byte span with NumElements requires exactly Span<uint8_t>.Size() bytes.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
}

void sub_1E0597A70(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::IRTypedTensorValue<MIL::UInt3>::GetValues(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt3 const,unsigned char const,true>(View, v4, v5);
}

void MIL::Util::CastToBitSpan<MIL::UInt3 const,unsigned char const,true>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::logic_error *exception;

  if (a2 != vcvtpd_u64_f64((double)(unint64_t)(3 * a3) * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "BitSpanCast to sub-byte type span has invalid number of elements. Sub-byte span with NumElements requires exactly Span<uint8_t>.Size() bytes.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
}

void sub_1E0597B44(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::IRTypedTensorValue<MIL::UInt2>::GetValues(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt2 const,unsigned char const,true>(View, v4, v5);
}

void MIL::Util::CastToBitSpan<MIL::UInt2 const,unsigned char const,true>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::logic_error *exception;

  if (a2 != vcvtpd_u64_f64((double)(unint64_t)(2 * a3) * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "BitSpanCast to sub-byte type span has invalid number of elements. Sub-byte span with NumElements requires exactly Span<uint8_t>.Size() bytes.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
}

void sub_1E0597C18(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::IRTypedTensorValue<MIL::UInt1>::GetValues(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt1 const,unsigned char const,true>(View, v4, v5);
}

void MIL::Util::CastToBitSpan<MIL::UInt1 const,unsigned char const,true>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  std::logic_error *exception;

  if (a2 != vcvtpd_u64_f64((double)a3 * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "BitSpanCast to sub-byte type span has invalid number of elements. Sub-byte span with NumElements requires exactly Span<uint8_t>.Size() bytes.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
}

void sub_1E0597CE8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::GetHash(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = HIDWORD(v1);
  v3 = 0x9DDFEA08EB382D69 * (((8 * v1) + 8) ^ HIDWORD(v1));
  return GetHashForSubByte<MIL::Int4>(a1, 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) >> 47)));
}

uint64_t GetHashForSubByte<MIL::Int4>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t View;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t i;
  unint64_t *v12;
  char v14;
  _QWORD v15[2];
  char v16;
  uint64_t v17;

  v2 = a2;
  v17 = a2;
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v6 = v5;
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::Int4 const,unsigned char const,true>(View, v6, v7);
  v15[0] = v9;
  v15[1] = v8;
  if (v8)
  {
    v10 = v8;
    for (i = 0; i != v10; ++i)
    {
      v14 = MIL::Util::Span<MIL::Int4 const,18446744073709551615ul>::ValueAt(v15, i);
      v12 = (unint64_t *)std::hash<MIL::Int4>::operator()((uint64_t)&v16, &v14);
      MIL::Util::HashCombine(&v17, v12);
    }
    return v17;
  }
  return v2;
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::GetHash(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = HIDWORD(v1);
  v3 = 0x9DDFEA08EB382D69 * (((8 * v1) + 8) ^ HIDWORD(v1));
  return GetHashForSubByte<MIL::UInt6>(a1, 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) >> 47)));
}

uint64_t GetHashForSubByte<MIL::UInt6>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t View;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t i;
  unint64_t *v12;
  unsigned __int8 v14;
  _QWORD v15[2];
  char v16;
  uint64_t v17;

  v2 = a2;
  v17 = a2;
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v6 = v5;
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt6 const,unsigned char const,true>(View, v6, v7);
  v15[0] = v9;
  v15[1] = v8;
  if (v8)
  {
    v10 = v8;
    for (i = 0; i != v10; ++i)
    {
      v14 = MIL::Util::Span<MIL::UInt6 const,18446744073709551615ul>::ValueAt(v15, i);
      v12 = (unint64_t *)std::hash<MIL::UInt6>::operator()((uint64_t)&v16, &v14);
      MIL::Util::HashCombine(&v17, v12);
    }
    return v17;
  }
  return v2;
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::GetHash(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = HIDWORD(v1);
  v3 = 0x9DDFEA08EB382D69 * (((8 * v1) + 8) ^ HIDWORD(v1));
  return GetHashForSubByte<MIL::UInt4>(a1, 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) >> 47)));
}

uint64_t GetHashForSubByte<MIL::UInt4>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t View;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t i;
  unint64_t *v12;
  unsigned __int8 v14;
  _QWORD v15[2];
  char v16;
  uint64_t v17;

  v2 = a2;
  v17 = a2;
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v6 = v5;
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt4 const,unsigned char const,true>(View, v6, v7);
  v15[0] = v9;
  v15[1] = v8;
  if (v8)
  {
    v10 = v8;
    for (i = 0; i != v10; ++i)
    {
      v14 = MIL::Util::Span<MIL::UInt4 const,18446744073709551615ul>::ValueAt(v15, i);
      v12 = (unint64_t *)std::hash<MIL::UInt4>::operator()((uint64_t)&v16, &v14);
      MIL::Util::HashCombine(&v17, v12);
    }
    return v17;
  }
  return v2;
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::GetHash(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = HIDWORD(v1);
  v3 = 0x9DDFEA08EB382D69 * (((8 * v1) + 8) ^ HIDWORD(v1));
  return GetHashForSubByte<MIL::UInt3>(a1, 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) >> 47)));
}

uint64_t GetHashForSubByte<MIL::UInt3>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t View;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t i;
  unint64_t *v12;
  unsigned __int8 v14;
  _QWORD v15[2];
  char v16;
  uint64_t v17;

  v2 = a2;
  v17 = a2;
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v6 = v5;
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt3 const,unsigned char const,true>(View, v6, v7);
  v15[0] = v9;
  v15[1] = v8;
  if (v8)
  {
    v10 = v8;
    for (i = 0; i != v10; ++i)
    {
      v14 = MIL::Util::Span<MIL::UInt3 const,18446744073709551615ul>::ValueAt(v15, i);
      v12 = (unint64_t *)std::hash<MIL::UInt3>::operator()((uint64_t)&v16, &v14);
      MIL::Util::HashCombine(&v17, v12);
    }
    return v17;
  }
  return v2;
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::GetHash(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = HIDWORD(v1);
  v3 = 0x9DDFEA08EB382D69 * (((8 * v1) + 8) ^ HIDWORD(v1));
  return GetHashForSubByte<MIL::UInt2>(a1, 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) >> 47)));
}

uint64_t GetHashForSubByte<MIL::UInt2>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t View;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t i;
  unint64_t *v12;
  unsigned __int8 v14;
  _QWORD v15[2];
  char v16;
  uint64_t v17;

  v2 = a2;
  v17 = a2;
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v6 = v5;
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt2 const,unsigned char const,true>(View, v6, v7);
  v15[0] = v9;
  v15[1] = v8;
  if (v8)
  {
    v10 = v8;
    for (i = 0; i != v10; ++i)
    {
      v14 = MIL::Util::Span<MIL::UInt2 const,18446744073709551615ul>::ValueAt(v15, i);
      v12 = (unint64_t *)std::hash<MIL::UInt2>::operator()((uint64_t)&v16, &v14);
      MIL::Util::HashCombine(&v17, v12);
    }
    return v17;
  }
  return v2;
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::GetHash(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = HIDWORD(v1);
  v3 = 0x9DDFEA08EB382D69 * (((8 * v1) + 8) ^ HIDWORD(v1));
  return GetHashForSubByte<MIL::UInt1>(a1, 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69 * (v2 ^ (v3 >> 47) ^ v3)) >> 47)));
}

uint64_t GetHashForSubByte<MIL::UInt1>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t View;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t i;
  unint64_t *v12;
  unsigned __int8 v14;
  _QWORD v15[2];
  char v16;
  uint64_t v17;

  v2 = a2;
  v17 = a2;
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v6 = v5;
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt1 const,unsigned char const,true>(View, v6, v7);
  v15[0] = v9;
  v15[1] = v8;
  if (v8)
  {
    v10 = v8;
    for (i = 0; i != v10; ++i)
    {
      v14 = MIL::Util::Span<MIL::UInt1 const,18446744073709551615ul>::ValueAt(v15, i);
      v12 = (unint64_t *)std::hash<MIL::UInt1>::operator()((uint64_t)&v16, &v14);
      MIL::Util::HashCombine(&v17, v12);
    }
    return v17;
  }
  return v2;
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::TryGetScalarValue()
{
  return 0;
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  unint64_t v7;
  _BYTE *v8;
  std::bad_cast *exception;
  std::bad_cast *v11;
  unsigned __int8 v12;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v11 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v11, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::Int4 const,unsigned char const,true>(View, v4, v5);
  if (((v7 >> 1) & 0x1FFFFFFFFFFFFFFFLL) + (v7 & 1))
    v8 = v6;
  else
    v8 = 0;
  MIL::Int4::Int4((MIL::Int4 *)&v12, *v8 & 0xF);
  return v12;
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  std::bad_cast *exception;
  std::bad_cast *v12;
  unsigned __int8 v13;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v12 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v12, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt6 const,unsigned char const,true>(View, v4, v5);
  if (((6 * v7) & 6) != 0)
    v8 = -1;
  else
    v8 = 0;
  if (v8 == (unint64_t)(6 * v7) >> 3)
    v9 = 0;
  else
    v9 = v6;
  MIL::UInt6::UInt6((MIL::UInt6 *)&v13, *v9 & 0x3F);
  return v13;
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  unint64_t v7;
  _BYTE *v8;
  std::bad_cast *exception;
  std::bad_cast *v11;
  unsigned __int8 v12;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v11 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v11, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt4 const,unsigned char const,true>(View, v4, v5);
  if (((v7 >> 1) & 0x1FFFFFFFFFFFFFFFLL) + (v7 & 1))
    v8 = v6;
  else
    v8 = 0;
  MIL::UInt4::UInt4((MIL::UInt4 *)&v12, *v8 & 0xF);
  return v12;
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  std::bad_cast *exception;
  std::bad_cast *v12;
  unsigned __int8 v13;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v12 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v12, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt3 const,unsigned char const,true>(View, v4, v5);
  if (((3 * v7) & 7) != 0)
    v8 = -1;
  else
    v8 = 0;
  if (v8 == (unint64_t)(3 * v7) >> 3)
    v9 = 0;
  else
    v9 = v6;
  MIL::UInt3::UInt3((MIL::UInt3 *)&v13, *v9 & 7);
  return v13;
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  unint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  std::bad_cast *exception;
  std::bad_cast *v12;
  unsigned __int8 v13;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v12 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v12, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt2 const,unsigned char const,true>(View, v4, v5);
  if ((v7 & 3) != 0)
    v8 = -1;
  else
    v8 = 0;
  if (((v7 >> 2) & 0x1FFFFFFFFFFFFFFFLL) == v8)
    v9 = 0;
  else
    v9 = v6;
  MIL::UInt2::UInt2((MIL::UInt2 *)&v13, *v9 & 3);
  return v13;
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  _BYTE *v6;
  unint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  std::bad_cast *exception;
  std::bad_cast *v12;
  unsigned __int8 v13;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v12 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v12, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  MIL::Util::CastToBitSpan<MIL::UInt1 const,unsigned char const,true>(View, v4, v5);
  if ((v7 & 7) != 0)
    v8 = -1;
  else
    v8 = 0;
  if (v8 == v7 >> 3)
    v9 = 0;
  else
    v9 = v6;
  MIL::UInt1::UInt1((MIL::UInt1 *)&v13, *v9 & 1);
  return v13;
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<BOOL>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<BOOL>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E0598844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995398;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E0598934(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E0598A08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E0598ADC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E0598BAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<BOOL>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  unint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6;
  v8 = v6 ? (unsigned __int8 *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = v10 ? (unsigned __int8 *)v9 : 0;
  if (v7 != v10)
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E0598DC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<BOOL>::GetValues(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if (!v2)
    return 0;
  return result;
}

uint64_t MIL::IRTypedTensorValue<BOOL>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<BOOL>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if (v7)
    v8 = (unsigned __int8 *)View;
  else
    v8 = 0;
  if (v7)
  {
    v9 = v7;
    do
    {
      v10 = *v8++;
      MIL::Util::HashCombine(&v12, (unint64_t *)v10);
      --v9;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<BOOL>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<BOOL>::TryGetScalarValue(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
    return 0;
  result = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if (!v3)
    return 0;
  return result;
}

uint64_t MIL::IRTypedTensorValue<BOOL>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  unsigned __int8 *v4;
  std::bad_cast *exception;
  std::bad_cast *v7;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v7 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v7, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if (v3)
    v4 = (unsigned __int8 *)View;
  else
    v4 = 0;
  return *v4;
}

uint64_t MIL::IRTypedTensorValue<BOOL>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<BOOL>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<BOOL>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E0598FB0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<BOOL>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<BOOL>::GetStorage(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<BOOL>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<BOOL>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E0599068(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<BOOL>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<BOOL>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<BOOL>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<std::string>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<std::string>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<std::string>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<std::string>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<std::string>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<std::string>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<std::string>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E05991EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<std::string>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995478;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05992DC(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E05993B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<std::string>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<std::string>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<std::string>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<std::string>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<std::string>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E0599484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E0599554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<std::string>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  void *__p[2];
  unsigned __int8 v25;
  void *__s1;
  size_t __n;
  unsigned __int8 v28;

  if (a1 == lpsrc)
    return 1;
  if (result)
  {
    v4 = result;
    if (a1[1] != *(_QWORD *)(result + 8))
      return 0;
    View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
    v7 = 24 * v6 / 0x18uLL;
    v8 = (unint64_t)(24 * v6) >= 0x18 ? View : 0;
    v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
    v11 = (unint64_t)(24 * v10) >= 0x18 ? v9 : 0;
    if (v7 != 24 * v10 / 0x18uLL)
      return 0;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
    v12 = v28;
    if ((v28 & 0x80u) == 0)
      v13 = v28;
    else
      v13 = __n;
    v14 = v25;
    v15 = (char)v25;
    if ((v25 & 0x80u) != 0)
      v14 = (unint64_t)__p[1];
    if (v13 == v14)
    {
      if ((v25 & 0x80u) == 0)
        v16 = __p;
      else
        v16 = (void **)__p[0];
      if ((char)v28 < 0)
      {
        v22 = memcmp(__s1, v16, __n) != 0;
      }
      else if (v28)
      {
        v17 = v28 - 1;
        p_s1 = &__s1;
        do
        {
          v20 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          v19 = v20;
          v21 = *(unsigned __int8 *)v16;
          v16 = (void **)((char *)v16 + 1);
          v22 = v19 != v21;
        }
        while (v19 == v21 && v17-- != 0);
      }
      else
      {
        v22 = 0;
      }
    }
    else
    {
      v22 = 1;
    }
    if (v15 < 0)
    {
      operator delete(__p[0]);
      if ((v28 & 0x80) == 0)
      {
LABEL_35:
        if (v22)
          return 0;
        return CompareValues<std::string>(v8, v7, v11);
      }
    }
    else if ((v12 & 0x80) == 0)
    {
      goto LABEL_35;
    }
    operator delete(__s1);
    if (v22)
      return 0;
    return CompareValues<std::string>(v8, v7, v11);
  }
  return result;
}

void sub_1E0599764(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<std::string>::GetValues(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((unint64_t)(24 * v2) < 0x18)
    return 0;
  return result;
}

uint64_t MIL::IRTypedTensorValue<std::string>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

BOOL CompareValues<std::string>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  BOOL v6;
  uint64_t i;
  unsigned __int8 *v8;
  unsigned __int8 **v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  int v13;
  unsigned __int8 *v14;

  if (a2)
  {
    v6 = 0;
    for (i = 0; i != a2; v6 = ++i >= a2)
    {
      v8 = (unsigned __int8 *)(a1 + 24 * i);
      v9 = (unsigned __int8 **)(a3 + 24 * i);
      v10 = v8[23];
      if ((v10 & 0x80u) == 0)
        v11 = (unsigned __int8 *)v8[23];
      else
        v11 = (unsigned __int8 *)*((_QWORD *)v8 + 1);
      v12 = (unsigned __int8 *)*((unsigned __int8 *)v9 + 23);
      v13 = (char)v12;
      if ((char)v12 < 0)
        v12 = v9[1];
      if (v11 != v12)
        break;
      if (v13 >= 0)
        v14 = (unsigned __int8 *)(a3 + 24 * i);
      else
        v14 = *v9;
      if ((v10 & 0x80) != 0)
      {
        if (memcmp(*(const void **)v8, v14, *((_QWORD *)v8 + 1)))
          return v6;
      }
      else if (v8[23])
      {
        while (*v8 == *v14)
        {
          ++v8;
          ++v14;
          if (!--v10)
            goto LABEL_18;
        }
        return v6;
      }
LABEL_18:
      ;
    }
  }
  else
  {
    return 1;
  }
  return v6;
}

unint64_t MIL::IRTypedTensorValue<std::string>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  char v12;
  unint64_t v13;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v13 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((unint64_t)(24 * v7) >= 0x18)
    v8 = View;
  else
    v8 = 0;
  if ((unint64_t)(24 * v7) >= 0x18)
  {
    v9 = 24 * (24 * v7 / 0x18uLL);
    do
    {
      v10 = (unint64_t *)std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)&v12, v8);
      MIL::Util::HashCombine(&v13, v10);
      v8 += 24;
      v9 -= 24;
    }
    while (v9);
    return v13;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<std::string>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<std::string>::TryGetScalarValue(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
    return 0;
  result = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((unint64_t)(24 * v3) < 0x18)
    return 0;
  return result;
}

void MIL::IRTypedTensorValue<std::string>::GetScalarValue(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t View;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  std::bad_cast *exception;
  std::bad_cast *v9;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v9 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v9, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((unint64_t)(24 * v5) >= 0x18)
    v6 = View;
  else
    v6 = 0;
  if (*(char *)(v6 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)v6, *(_QWORD *)(v6 + 8));
  }
  else
  {
    v7 = *(_OWORD *)v6;
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(v6 + 16);
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v7;
  }
}

uint64_t MIL::IRTypedTensorValue<std::string>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<std::string>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<std::string>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E0599AA4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<std::string>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<std::string>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<std::string>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E0599B54(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<std::string>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<std::string>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<std::string>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<MIL::Bf16>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Bf16>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<MIL::Bf16>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::Bf16>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<MIL::Bf16>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::Bf16>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E0599CD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Bf16>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995530;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 7)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E0599DC8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E0599E9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Bf16>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<MIL::Bf16>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::Bf16>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<MIL::Bf16>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::Bf16>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E0599F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059A040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6 & 0x7FFFFFFFFFFFFFFFLL;
  v8 = (v6 & 0x7FFFFFFFFFFFFFFFLL) != 0 ? (unsigned __int16 *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = (v10 & 0x7FFFFFFFFFFFFFFFLL) != 0 ? (unsigned __int16 *)v9 : 0;
  if (v7 != (v10 & 0x7FFFFFFFFFFFFFFFLL))
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E059A254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::GetValues(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v2 & 0x7FFFFFFFFFFFFFFFLL) == 0)
    return 0;
  return result;
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<MIL::Bf16>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v8 = (unsigned __int16 *)View;
  else
    v8 = 0;
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 2 * v7;
    do
    {
      v10 = *v8++;
      MIL::Util::HashCombine(&v12, (unint64_t *)v10);
      v9 -= 2;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::TryGetScalarValue(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
    return 0;
  result = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v3 & 0x7FFFFFFFFFFFFFFFLL) == 0)
    return 0;
  return result;
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  unsigned __int16 *v4;
  std::bad_cast *exception;
  std::bad_cast *v7;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v7 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v7, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v3 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v4 = (unsigned __int16 *)View;
  else
    v4 = 0;
  return *v4;
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E059A438(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<MIL::Bf16>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<MIL::Bf16>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E059A4E8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Bf16>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<MIL::Fp16>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Fp16>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<MIL::Fp16>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::Fp16>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<MIL::Fp16>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::Fp16>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E059A66C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Fp16>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA9955E8;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E059A75C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E059A830(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Fp16>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<MIL::Fp16>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::Fp16>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<MIL::Fp16>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::Fp16>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E059A904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059A9D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6 & 0x7FFFFFFFFFFFFFFFLL;
  v8 = (v6 & 0x7FFFFFFFFFFFFFFFLL) != 0 ? (unsigned __int16 *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = (v10 & 0x7FFFFFFFFFFFFFFFLL) != 0 ? (unsigned __int16 *)v9 : 0;
  if (v7 != (v10 & 0x7FFFFFFFFFFFFFFFLL))
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E059ABE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<MIL::Fp16>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v8 = (unsigned __int16 *)View;
  else
    v8 = 0;
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 2 * v7;
    do
    {
      v10 = *v8++;
      MIL::Util::HashCombine(&v12, (unint64_t *)v10);
      v9 -= 2;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E059AD10(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<MIL::Fp16>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<MIL::Fp16>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E059ADC0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp16>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<MIL::Fp8E5M2>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Fp8E5M2>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<MIL::Fp8E5M2>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::Fp8E5M2>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<MIL::Fp8E5M2>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::Fp8E5M2>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E059AF44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Fp8E5M2>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA9956A0;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 25)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E059B034(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E059B108(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Fp8E5M2>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<MIL::Fp8E5M2>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::Fp8E5M2>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<MIL::Fp8E5M2>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::Fp8E5M2>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E059B1DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059B2AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  void *__p[2];
  unsigned __int8 v25;
  void *__s1;
  size_t __n;
  unsigned __int8 v28;

  if (a1 == lpsrc)
    return 1;
  if (result)
  {
    v4 = result;
    if (a1[1] != *(_QWORD *)(result + 8))
      return 0;
    View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
    v7 = v6;
    v8 = v6 ? View : 0;
    v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
    v11 = v10 ? v9 : 0;
    if (v7 != v10)
      return 0;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
    v12 = v28;
    if ((v28 & 0x80u) == 0)
      v13 = v28;
    else
      v13 = __n;
    v14 = v25;
    v15 = (char)v25;
    if ((v25 & 0x80u) != 0)
      v14 = (unint64_t)__p[1];
    if (v13 == v14)
    {
      if ((v25 & 0x80u) == 0)
        v16 = __p;
      else
        v16 = (void **)__p[0];
      if ((char)v28 < 0)
      {
        v22 = memcmp(__s1, v16, __n) != 0;
      }
      else if (v28)
      {
        v17 = v28 - 1;
        p_s1 = &__s1;
        do
        {
          v20 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          v19 = v20;
          v21 = *(unsigned __int8 *)v16;
          v16 = (void **)((char *)v16 + 1);
          v22 = v19 != v21;
        }
        while (v19 == v21 && v17-- != 0);
      }
      else
      {
        v22 = 0;
      }
    }
    else
    {
      v22 = 1;
    }
    if (v15 < 0)
    {
      operator delete(__p[0]);
      if ((v28 & 0x80) == 0)
      {
LABEL_35:
        if (v22)
          return 0;
        return CompareValues<MIL::Fp8E5M2>(v8, v7, v11);
      }
    }
    else if ((v12 & 0x80) == 0)
    {
      goto LABEL_35;
    }
    operator delete(__s1);
    if (v22)
      return 0;
    return CompareValues<MIL::Fp8E5M2>(v8, v7, v11);
  }
  return result;
}

void sub_1E059B4A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

BOOL CompareValues<MIL::Fp8E5M2>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  BOOL v6;
  unint64_t i;
  _BYTE *v8;

  if (a2)
  {
    v6 = 0;
    for (i = 0; i != a2; v6 = i >= a2)
    {
      v8 = (_BYTE *)(a3 + i);
      if (((*(_BYTE *)(a1 + i) & 0x7F) != 0 || (*v8 & 0x7F) != 0)
        && (MIL::Fp8E5M2::IsNaN((MIL::Fp8E5M2 *)(a1 + i)) && MIL::Fp8E5M2::IsNaN((MIL::Fp8E5M2 *)(a3 + i))
         || *(unsigned __int8 *)(a1 + i) != *v8))
      {
        break;
      }
      ++i;
    }
  }
  else
  {
    return 1;
  }
  return v6;
}

unint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if (v7)
    v8 = (unsigned __int8 *)View;
  else
    v8 = 0;
  if (v7)
  {
    v9 = v7;
    do
    {
      v10 = *v8++;
      MIL::Util::HashCombine(&v12, (unint64_t *)v10);
      --v9;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E059B684(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<MIL::Fp8E5M2>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<MIL::Fp8E5M2>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E059B734(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E5M2>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<MIL::Fp8E4M3FN>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<MIL::Fp8E4M3FN>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E059B8B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995758;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 24)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E059B9A8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E059BA7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<MIL::Fp8E4M3FN>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<MIL::Fp8E4M3FN>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E059BB50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059BC20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  void *__p[2];
  unsigned __int8 v25;
  void *__s1;
  size_t __n;
  unsigned __int8 v28;

  if (a1 == lpsrc)
    return 1;
  if (result)
  {
    v4 = result;
    if (a1[1] != *(_QWORD *)(result + 8))
      return 0;
    View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
    v7 = v6;
    v8 = v6 ? View : 0;
    v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
    v11 = v10 ? v9 : 0;
    if (v7 != v10)
      return 0;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
    v12 = v28;
    if ((v28 & 0x80u) == 0)
      v13 = v28;
    else
      v13 = __n;
    v14 = v25;
    v15 = (char)v25;
    if ((v25 & 0x80u) != 0)
      v14 = (unint64_t)__p[1];
    if (v13 == v14)
    {
      if ((v25 & 0x80u) == 0)
        v16 = __p;
      else
        v16 = (void **)__p[0];
      if ((char)v28 < 0)
      {
        v22 = memcmp(__s1, v16, __n) != 0;
      }
      else if (v28)
      {
        v17 = v28 - 1;
        p_s1 = &__s1;
        do
        {
          v20 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          v19 = v20;
          v21 = *(unsigned __int8 *)v16;
          v16 = (void **)((char *)v16 + 1);
          v22 = v19 != v21;
        }
        while (v19 == v21 && v17-- != 0);
      }
      else
      {
        v22 = 0;
      }
    }
    else
    {
      v22 = 1;
    }
    if (v15 < 0)
    {
      operator delete(__p[0]);
      if ((v28 & 0x80) == 0)
      {
LABEL_35:
        if (v22)
          return 0;
        return CompareValues<MIL::Fp8E4M3FN>(v8, v7, v11);
      }
    }
    else if ((v12 & 0x80) == 0)
    {
      goto LABEL_35;
    }
    operator delete(__s1);
    if (v22)
      return 0;
    return CompareValues<MIL::Fp8E4M3FN>(v8, v7, v11);
  }
  return result;
}

void sub_1E059BE14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

BOOL CompareValues<MIL::Fp8E4M3FN>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  BOOL v6;
  unint64_t i;
  _BYTE *v8;

  if (a2)
  {
    v6 = 0;
    for (i = 0; i != a2; v6 = i >= a2)
    {
      v8 = (_BYTE *)(a3 + i);
      if (((*(_BYTE *)(a1 + i) & 0x7F) != 0 || (*v8 & 0x7F) != 0)
        && (MIL::Fp8E4M3FN::IsNaN((MIL::Fp8E4M3FN *)(a1 + i)) && MIL::Fp8E4M3FN::IsNaN((MIL::Fp8E4M3FN *)(a3 + i))
         || *(unsigned __int8 *)(a1 + i) != *v8))
      {
        break;
      }
      ++i;
    }
  }
  else
  {
    return 1;
  }
  return v6;
}

unint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if (v7)
    v8 = (unsigned __int8 *)View;
  else
    v8 = 0;
  if (v7)
  {
    v9 = v7;
    do
    {
      v10 = *v8++;
      MIL::Util::HashCombine(&v12, (unint64_t *)v10);
      --v9;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E059BFF8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<MIL::Fp8E4M3FN>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E059C0A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<float>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<float>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<float>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<float>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<float>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<float>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<float>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E059C22C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<float>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995810;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E059C31C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E059C3F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<float>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<float>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<float>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<float>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<float>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E059C4C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059C594(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<float>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  float v26;
  float v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6 & 0x3FFFFFFFFFFFFFFFLL;
  v8 = (v6 & 0x3FFFFFFFFFFFFFFFLL) != 0 ? (float *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = (v10 & 0x3FFFFFFFFFFFFFFFLL) != 0 ? (float *)v9 : 0;
  if (v7 != (v10 & 0x3FFFFFFFFFFFFFFFLL))
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E059C7A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<float>::GetValues(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v2 & 0x3FFFFFFFFFFFFFFFLL) == 0)
    return 0;
  return result;
}

uint64_t MIL::IRTypedTensorValue<float>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<float>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float v10;
  unint64_t *v11;
  unint64_t *v12;
  unint64_t v14;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v14 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((v7 & 0x3FFFFFFFFFFFFFFFLL) != 0)
    v8 = (float *)View;
  else
    v8 = 0;
  if ((v7 & 0x3FFFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 4 * v7;
    do
    {
      v10 = *v8++;
      v11 = (unint64_t *)LODWORD(v10);
      if (v10 == 0.0)
        v12 = 0;
      else
        v12 = v11;
      MIL::Util::HashCombine(&v14, v12);
      v9 -= 4;
    }
    while (v9);
    return v14;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<float>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<float>::TryGetScalarValue(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
    return 0;
  result = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v3 & 0x3FFFFFFFFFFFFFFFLL) == 0)
    return 0;
  return result;
}

float MIL::IRTypedTensorValue<float>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  std::bad_cast *exception;
  std::bad_cast *v7;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v7 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v7, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v3 & 0x3FFFFFFFFFFFFFFFLL) != 0)
    v4 = View;
  else
    v4 = 0;
  return *(float *)v4;
}

uint64_t MIL::IRTypedTensorValue<float>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<float>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<float>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E059C998(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<float>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<float>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<float>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E059CA48(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<float>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<float>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<float>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<double>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<double>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<double>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<double>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<double>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<double>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<double>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E059CBCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<double>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA9958C8;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 6)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E059CCBC(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E059CD90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<double>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<double>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<double>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<double>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<double>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E059CE64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059CF34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<double>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  double *v8;
  uint64_t v9;
  uint64_t v10;
  double *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  double v26;
  double v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6 & 0x1FFFFFFFFFFFFFFFLL;
  v8 = (v6 & 0x1FFFFFFFFFFFFFFFLL) != 0 ? (double *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = (v10 & 0x1FFFFFFFFFFFFFFFLL) != 0 ? (double *)v9 : 0;
  if (v7 != (v10 & 0x1FFFFFFFFFFFFFFFLL))
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E059D148(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<double>::GetValues(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v2 & 0x1FFFFFFFFFFFFFFFLL) == 0)
    return 0;
  return result;
}

uint64_t MIL::IRTypedTensorValue<double>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<double>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  double *v8;
  uint64_t v9;
  double v10;
  double v11;
  unint64_t *v12;
  unint64_t v14;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v14 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((v7 & 0x1FFFFFFFFFFFFFFFLL) != 0)
    v8 = (double *)View;
  else
    v8 = 0;
  if ((v7 & 0x1FFFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 8 * v7;
    do
    {
      v10 = *v8++;
      v11 = v10;
      if (v10 == 0.0)
        v12 = 0;
      else
        v12 = *(unint64_t **)&v11;
      MIL::Util::HashCombine(&v14, v12);
      v9 -= 8;
    }
    while (v9);
    return v14;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<double>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<double>::TryGetScalarValue(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
    return 0;
  result = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v3 & 0x1FFFFFFFFFFFFFFFLL) == 0)
    return 0;
  return result;
}

double MIL::IRTypedTensorValue<double>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  std::bad_cast *exception;
  std::bad_cast *v7;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v7 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v7, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v3 & 0x1FFFFFFFFFFFFFFFLL) != 0)
    v4 = View;
  else
    v4 = 0;
  return *(double *)v4;
}

uint64_t MIL::IRTypedTensorValue<double>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<double>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<double>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E059D338(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<double>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<double>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<double>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E059D3E8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<double>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<double>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<double>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<MIL::Int4>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Int4>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::Int4>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::Int4>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E059D56C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Int4>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995980;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 13)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E059D65C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E059D730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::Int4>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::Int4>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::Int4>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E059D804(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059D8D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unsigned __int8 v20;
  size_t v21;
  unint64_t v22;
  int v23;
  void **v24;
  uint64_t v25;
  void **p_s1;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  void *__p[2];
  unsigned __int8 v33;
  void *__s1;
  size_t __n;
  unsigned __int8 v36;

  if (a1 == lpsrc)
    return 1;
  if (result)
  {
    v4 = result;
    if (a1[1] != *(_QWORD *)(result + 8))
      return 0;
    View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[1] + 16))(a1[1]);
    MIL::Util::CastToBitSpan<MIL::Int4 const,unsigned char const,true>(View, v7, v8);
    v10 = v9;
    v12 = v11;
    v13 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
    v15 = v14;
    v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 8) + 16))(*(_QWORD *)(v4 + 8));
    MIL::Util::CastToBitSpan<MIL::Int4 const,unsigned char const,true>(v13, v15, v16);
    if (v12 != v18)
      return 0;
    v19 = v17;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
    v20 = v36;
    if ((v36 & 0x80u) == 0)
      v21 = v36;
    else
      v21 = __n;
    v22 = v33;
    v23 = (char)v33;
    if ((v33 & 0x80u) != 0)
      v22 = (unint64_t)__p[1];
    if (v21 == v22)
    {
      if ((v33 & 0x80u) == 0)
        v24 = __p;
      else
        v24 = (void **)__p[0];
      if ((char)v36 < 0)
      {
        v30 = memcmp(__s1, v24, __n) != 0;
      }
      else if (v36)
      {
        v25 = v36 - 1;
        p_s1 = &__s1;
        do
        {
          v28 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          v27 = v28;
          v29 = *(unsigned __int8 *)v24;
          v24 = (void **)((char *)v24 + 1);
          v30 = v27 != v29;
        }
        while (v27 == v29 && v25-- != 0);
      }
      else
      {
        v30 = 0;
      }
    }
    else
    {
      v30 = 1;
    }
    if (v23 < 0)
    {
      operator delete(__p[0]);
      if ((v36 & 0x80) == 0)
      {
LABEL_29:
        if (v30)
          return 0;
        return CompareSubByteValues<MIL::Int4>(v10, v12, v19);
      }
    }
    else if ((v20 & 0x80) == 0)
    {
      goto LABEL_29;
    }
    operator delete(__s1);
    if (v30)
      return 0;
    return CompareSubByteValues<MIL::Int4>(v10, v12, v19);
  }
  return result;
}

void sub_1E059DB10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E059DBA0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<MIL::Int4>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<MIL::Int4>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E059DC50(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::Int4>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<signed char>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<signed char>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<signed char>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<signed char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<signed char>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<signed char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<signed char>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E059DDD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<signed char>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995A38;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 9)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E059DEC4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E059DF98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<signed char>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<signed char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<signed char>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<signed char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<signed char>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E059E06C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059E13C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<signed char>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  unint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6;
  v8 = v6 ? (unsigned __int8 *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = v10 ? (unsigned __int8 *)v9 : 0;
  if (v7 != v10)
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E059E354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<signed char>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<signed char>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if (v7)
    v8 = (char *)View;
  else
    v8 = 0;
  if (v7)
  {
    v9 = v7;
    do
    {
      v10 = (unint64_t *)*v8++;
      MIL::Util::HashCombine(&v12, v10);
      --v9;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<signed char>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<signed char>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  char *v4;
  std::bad_cast *exception;
  std::bad_cast *v7;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v7 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v7, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if (v3)
    v4 = (char *)View;
  else
    v4 = 0;
  return *v4;
}

uint64_t MIL::IRTypedTensorValue<signed char>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<signed char>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<signed char>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E059E4E0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<signed char>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<signed char>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<signed char>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E059E590(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<signed char>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<signed char>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<signed char>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<short>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<short>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<short>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<short>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<short>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<short>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<short>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E059E714(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<short>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995AF0;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E059E804(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E059E8D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<short>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<short>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<short>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<short>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<short>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E059E9AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059EA7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<short>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6 & 0x7FFFFFFFFFFFFFFFLL;
  v8 = (v6 & 0x7FFFFFFFFFFFFFFFLL) != 0 ? (unsigned __int16 *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = (v10 & 0x7FFFFFFFFFFFFFFFLL) != 0 ? (unsigned __int16 *)v9 : 0;
  if (v7 != (v10 & 0x7FFFFFFFFFFFFFFFLL))
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E059EC90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<short>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<short>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  __int16 *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v8 = (__int16 *)View;
  else
    v8 = 0;
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 2 * v7;
    do
    {
      v10 = (unint64_t *)*v8++;
      MIL::Util::HashCombine(&v12, v10);
      v9 -= 2;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<short>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<short>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  __int16 *v4;
  std::bad_cast *exception;
  std::bad_cast *v7;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v7 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v7, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v3 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v4 = (__int16 *)View;
  else
    v4 = 0;
  return *v4;
}

uint64_t MIL::IRTypedTensorValue<short>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<short>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<short>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E059EE14(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<short>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<short>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<short>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E059EEC4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<short>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<short>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<short>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<int>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<int>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<int>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<int>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<int>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<int>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<int>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E059F048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<int>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995BA8;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 11)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E059F138(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E059F20C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<int>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<int>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<int>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<int>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<int>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E059F2E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059F3B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<int>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6 & 0x3FFFFFFFFFFFFFFFLL;
  v8 = (v6 & 0x3FFFFFFFFFFFFFFFLL) != 0 ? (_DWORD *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = (v10 & 0x3FFFFFFFFFFFFFFFLL) != 0 ? (_DWORD *)v9 : 0;
  if (v7 != (v10 & 0x3FFFFFFFFFFFFFFFLL))
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E059F5C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<int>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<int>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((v7 & 0x3FFFFFFFFFFFFFFFLL) != 0)
    v8 = (int *)View;
  else
    v8 = 0;
  if ((v7 & 0x3FFFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 4 * v7;
    do
    {
      v10 = (unint64_t *)*v8++;
      MIL::Util::HashCombine(&v12, v10);
      v9 -= 4;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<int>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<int>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  unsigned int *v4;
  std::bad_cast *exception;
  std::bad_cast *v7;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v7 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v7, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v3 & 0x3FFFFFFFFFFFFFFFLL) != 0)
    v4 = (unsigned int *)View;
  else
    v4 = 0;
  return *v4;
}

uint64_t MIL::IRTypedTensorValue<int>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<int>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<int>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E059F748(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<int>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<int>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<int>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E059F7F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<int>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<int>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<int>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<long long>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<long long>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<long long>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<long long>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<long long>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<long long>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<long long>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E059F97C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<long long>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995C60;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E059FA6C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E059FB40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<long long>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<long long>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<long long>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<long long>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<long long>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E059FC14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E059FCE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<long long>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6 & 0x1FFFFFFFFFFFFFFFLL;
  v8 = (v6 & 0x1FFFFFFFFFFFFFFFLL) != 0 ? (_QWORD *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = (v10 & 0x1FFFFFFFFFFFFFFFLL) != 0 ? (_QWORD *)v9 : 0;
  if (v7 != (v10 & 0x1FFFFFFFFFFFFFFFLL))
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E059FEF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<long long>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<long long>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  unint64_t **v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((v7 & 0x1FFFFFFFFFFFFFFFLL) != 0)
    v8 = (unint64_t **)View;
  else
    v8 = 0;
  if ((v7 & 0x1FFFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 8 * v7;
    do
    {
      v10 = *v8++;
      MIL::Util::HashCombine(&v12, v10);
      v9 -= 8;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<long long>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<long long>::GetScalarValue(uint64_t a1)
{
  uint64_t View;
  uint64_t v3;
  uint64_t v4;
  std::bad_cast *exception;
  std::bad_cast *v7;

  if (!MIL::IRTensorValueType::IsScalar(*(MIL::IRTensorValueType **)(a1 + 8)))
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v7 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v7, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  View = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(a1 + 16));
  if ((v3 & 0x1FFFFFFFFFFFFFFFLL) != 0)
    v4 = View;
  else
    v4 = 0;
  return *(_QWORD *)v4;
}

uint64_t MIL::IRTypedTensorValue<long long>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<long long>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<long long>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05A007C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<long long>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<long long>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<long long>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A012C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<long long>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<long long>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<long long>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<MIL::UInt1>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt1>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::UInt1>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::UInt1>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E05A02B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt1>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995D18;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 21)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05A03A0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E05A0474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt1>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::UInt1>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::UInt1>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E05A0548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E05A0618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unsigned __int8 v20;
  size_t v21;
  unint64_t v22;
  int v23;
  void **v24;
  uint64_t v25;
  void **p_s1;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  void *__p[2];
  unsigned __int8 v33;
  void *__s1;
  size_t __n;
  unsigned __int8 v36;

  if (a1 == lpsrc)
    return 1;
  if (result)
  {
    v4 = result;
    if (a1[1] != *(_QWORD *)(result + 8))
      return 0;
    View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[1] + 16))(a1[1]);
    MIL::Util::CastToBitSpan<MIL::UInt1 const,unsigned char const,true>(View, v7, v8);
    v10 = v9;
    v12 = v11;
    v13 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
    v15 = v14;
    v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 8) + 16))(*(_QWORD *)(v4 + 8));
    MIL::Util::CastToBitSpan<MIL::UInt1 const,unsigned char const,true>(v13, v15, v16);
    if (v12 != v18)
      return 0;
    v19 = v17;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
    v20 = v36;
    if ((v36 & 0x80u) == 0)
      v21 = v36;
    else
      v21 = __n;
    v22 = v33;
    v23 = (char)v33;
    if ((v33 & 0x80u) != 0)
      v22 = (unint64_t)__p[1];
    if (v21 == v22)
    {
      if ((v33 & 0x80u) == 0)
        v24 = __p;
      else
        v24 = (void **)__p[0];
      if ((char)v36 < 0)
      {
        v30 = memcmp(__s1, v24, __n) != 0;
      }
      else if (v36)
      {
        v25 = v36 - 1;
        p_s1 = &__s1;
        do
        {
          v28 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          v27 = v28;
          v29 = *(unsigned __int8 *)v24;
          v24 = (void **)((char *)v24 + 1);
          v30 = v27 != v29;
        }
        while (v27 == v29 && v25-- != 0);
      }
      else
      {
        v30 = 0;
      }
    }
    else
    {
      v30 = 1;
    }
    if (v23 < 0)
    {
      operator delete(__p[0]);
      if ((v36 & 0x80) == 0)
      {
LABEL_29:
        if (v30)
          return 0;
        return CompareSubByteValues<MIL::UInt1>(v10, v12, v19);
      }
    }
    else if ((v20 & 0x80) == 0)
    {
      goto LABEL_29;
    }
    operator delete(__s1);
    if (v30)
      return 0;
    return CompareSubByteValues<MIL::UInt1>(v10, v12, v19);
  }
  return result;
}

void sub_1E05A0854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05A08E4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<MIL::UInt1>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<MIL::UInt1>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A0994(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt1>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<MIL::UInt2>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt2>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::UInt2>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::UInt2>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E05A0B18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt2>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995DD0;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 19)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05A0C08(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E05A0CDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt2>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::UInt2>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::UInt2>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E05A0DB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E05A0E80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unsigned __int8 v20;
  size_t v21;
  unint64_t v22;
  int v23;
  void **v24;
  uint64_t v25;
  void **p_s1;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  void *__p[2];
  unsigned __int8 v33;
  void *__s1;
  size_t __n;
  unsigned __int8 v36;

  if (a1 == lpsrc)
    return 1;
  if (result)
  {
    v4 = result;
    if (a1[1] != *(_QWORD *)(result + 8))
      return 0;
    View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[1] + 16))(a1[1]);
    MIL::Util::CastToBitSpan<MIL::UInt2 const,unsigned char const,true>(View, v7, v8);
    v10 = v9;
    v12 = v11;
    v13 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
    v15 = v14;
    v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 8) + 16))(*(_QWORD *)(v4 + 8));
    MIL::Util::CastToBitSpan<MIL::UInt2 const,unsigned char const,true>(v13, v15, v16);
    if (v12 != v18)
      return 0;
    v19 = v17;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
    v20 = v36;
    if ((v36 & 0x80u) == 0)
      v21 = v36;
    else
      v21 = __n;
    v22 = v33;
    v23 = (char)v33;
    if ((v33 & 0x80u) != 0)
      v22 = (unint64_t)__p[1];
    if (v21 == v22)
    {
      if ((v33 & 0x80u) == 0)
        v24 = __p;
      else
        v24 = (void **)__p[0];
      if ((char)v36 < 0)
      {
        v30 = memcmp(__s1, v24, __n) != 0;
      }
      else if (v36)
      {
        v25 = v36 - 1;
        p_s1 = &__s1;
        do
        {
          v28 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          v27 = v28;
          v29 = *(unsigned __int8 *)v24;
          v24 = (void **)((char *)v24 + 1);
          v30 = v27 != v29;
        }
        while (v27 == v29 && v25-- != 0);
      }
      else
      {
        v30 = 0;
      }
    }
    else
    {
      v30 = 1;
    }
    if (v23 < 0)
    {
      operator delete(__p[0]);
      if ((v36 & 0x80) == 0)
      {
LABEL_29:
        if (v30)
          return 0;
        return CompareSubByteValues<MIL::UInt2>(v10, v12, v19);
      }
    }
    else if ((v20 & 0x80) == 0)
    {
      goto LABEL_29;
    }
    operator delete(__s1);
    if (v30)
      return 0;
    return CompareSubByteValues<MIL::UInt2>(v10, v12, v19);
  }
  return result;
}

void sub_1E05A10BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05A114C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<MIL::UInt2>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<MIL::UInt2>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A11FC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt2>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<MIL::UInt3>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt3>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::UInt3>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::UInt3>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E05A1380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt3>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995E88;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05A1470(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E05A1544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt3>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::UInt3>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::UInt3>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E05A1618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E05A16E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unsigned __int8 v20;
  size_t v21;
  unint64_t v22;
  int v23;
  void **v24;
  uint64_t v25;
  void **p_s1;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  void *__p[2];
  unsigned __int8 v33;
  void *__s1;
  size_t __n;
  unsigned __int8 v36;

  if (a1 == lpsrc)
    return 1;
  if (result)
  {
    v4 = result;
    if (a1[1] != *(_QWORD *)(result + 8))
      return 0;
    View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[1] + 16))(a1[1]);
    MIL::Util::CastToBitSpan<MIL::UInt3 const,unsigned char const,true>(View, v7, v8);
    v10 = v9;
    v12 = v11;
    v13 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
    v15 = v14;
    v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 8) + 16))(*(_QWORD *)(v4 + 8));
    MIL::Util::CastToBitSpan<MIL::UInt3 const,unsigned char const,true>(v13, v15, v16);
    if (v12 != v18)
      return 0;
    v19 = v17;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
    v20 = v36;
    if ((v36 & 0x80u) == 0)
      v21 = v36;
    else
      v21 = __n;
    v22 = v33;
    v23 = (char)v33;
    if ((v33 & 0x80u) != 0)
      v22 = (unint64_t)__p[1];
    if (v21 == v22)
    {
      if ((v33 & 0x80u) == 0)
        v24 = __p;
      else
        v24 = (void **)__p[0];
      if ((char)v36 < 0)
      {
        v30 = memcmp(__s1, v24, __n) != 0;
      }
      else if (v36)
      {
        v25 = v36 - 1;
        p_s1 = &__s1;
        do
        {
          v28 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          v27 = v28;
          v29 = *(unsigned __int8 *)v24;
          v24 = (void **)((char *)v24 + 1);
          v30 = v27 != v29;
        }
        while (v27 == v29 && v25-- != 0);
      }
      else
      {
        v30 = 0;
      }
    }
    else
    {
      v30 = 1;
    }
    if (v23 < 0)
    {
      operator delete(__p[0]);
      if ((v36 & 0x80) == 0)
      {
LABEL_29:
        if (v30)
          return 0;
        return CompareSubByteValues<MIL::UInt3>(v10, v12, v19);
      }
    }
    else if ((v20 & 0x80) == 0)
    {
      goto LABEL_29;
    }
    operator delete(__s1);
    if (v30)
      return 0;
    return CompareSubByteValues<MIL::UInt3>(v10, v12, v19);
  }
  return result;
}

void sub_1E05A1924(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05A19B4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<MIL::UInt3>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<MIL::UInt3>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A1A64(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt3>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<MIL::UInt4>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt4>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::UInt4>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::UInt4>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E05A1BE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt4>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995F40;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 20)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05A1CD8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E05A1DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt4>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::UInt4>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::UInt4>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E05A1E80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E05A1F50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unsigned __int8 v20;
  size_t v21;
  unint64_t v22;
  int v23;
  void **v24;
  uint64_t v25;
  void **p_s1;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  void *__p[2];
  unsigned __int8 v33;
  void *__s1;
  size_t __n;
  unsigned __int8 v36;

  if (a1 == lpsrc)
    return 1;
  if (result)
  {
    v4 = result;
    if (a1[1] != *(_QWORD *)(result + 8))
      return 0;
    View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[1] + 16))(a1[1]);
    MIL::Util::CastToBitSpan<MIL::UInt4 const,unsigned char const,true>(View, v7, v8);
    v10 = v9;
    v12 = v11;
    v13 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
    v15 = v14;
    v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 8) + 16))(*(_QWORD *)(v4 + 8));
    MIL::Util::CastToBitSpan<MIL::UInt4 const,unsigned char const,true>(v13, v15, v16);
    if (v12 != v18)
      return 0;
    v19 = v17;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
    v20 = v36;
    if ((v36 & 0x80u) == 0)
      v21 = v36;
    else
      v21 = __n;
    v22 = v33;
    v23 = (char)v33;
    if ((v33 & 0x80u) != 0)
      v22 = (unint64_t)__p[1];
    if (v21 == v22)
    {
      if ((v33 & 0x80u) == 0)
        v24 = __p;
      else
        v24 = (void **)__p[0];
      if ((char)v36 < 0)
      {
        v30 = memcmp(__s1, v24, __n) != 0;
      }
      else if (v36)
      {
        v25 = v36 - 1;
        p_s1 = &__s1;
        do
        {
          v28 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          v27 = v28;
          v29 = *(unsigned __int8 *)v24;
          v24 = (void **)((char *)v24 + 1);
          v30 = v27 != v29;
        }
        while (v27 == v29 && v25-- != 0);
      }
      else
      {
        v30 = 0;
      }
    }
    else
    {
      v30 = 1;
    }
    if (v23 < 0)
    {
      operator delete(__p[0]);
      if ((v36 & 0x80) == 0)
      {
LABEL_29:
        if (v30)
          return 0;
        return CompareSubByteValues<MIL::UInt4>(v10, v12, v19);
      }
    }
    else if ((v20 & 0x80) == 0)
    {
      goto LABEL_29;
    }
    operator delete(__s1);
    if (v30)
      return 0;
    return CompareSubByteValues<MIL::UInt4>(v10, v12, v19);
  }
  return result;
}

void sub_1E05A218C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05A221C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<MIL::UInt4>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<MIL::UInt4>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A22CC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt4>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<MIL::UInt6>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt6>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::UInt6>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<MIL::UInt6>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E05A2450(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt6>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA995FF8;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 23)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05A2540(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E05A2614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<MIL::UInt6>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::UInt6>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<MIL::UInt6>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E05A26E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E05A27B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unsigned __int8 v20;
  size_t v21;
  unint64_t v22;
  int v23;
  void **v24;
  uint64_t v25;
  void **p_s1;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  void *__p[2];
  unsigned __int8 v33;
  void *__s1;
  size_t __n;
  unsigned __int8 v36;

  if (a1 == lpsrc)
    return 1;
  if (result)
  {
    v4 = result;
    if (a1[1] != *(_QWORD *)(result + 8))
      return 0;
    View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[1] + 16))(a1[1]);
    MIL::Util::CastToBitSpan<MIL::UInt6 const,unsigned char const,true>(View, v7, v8);
    v10 = v9;
    v12 = v11;
    v13 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
    v15 = v14;
    v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 8) + 16))(*(_QWORD *)(v4 + 8));
    MIL::Util::CastToBitSpan<MIL::UInt6 const,unsigned char const,true>(v13, v15, v16);
    if (v12 != v18)
      return 0;
    v19 = v17;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
    v20 = v36;
    if ((v36 & 0x80u) == 0)
      v21 = v36;
    else
      v21 = __n;
    v22 = v33;
    v23 = (char)v33;
    if ((v33 & 0x80u) != 0)
      v22 = (unint64_t)__p[1];
    if (v21 == v22)
    {
      if ((v33 & 0x80u) == 0)
        v24 = __p;
      else
        v24 = (void **)__p[0];
      if ((char)v36 < 0)
      {
        v30 = memcmp(__s1, v24, __n) != 0;
      }
      else if (v36)
      {
        v25 = v36 - 1;
        p_s1 = &__s1;
        do
        {
          v28 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          v27 = v28;
          v29 = *(unsigned __int8 *)v24;
          v24 = (void **)((char *)v24 + 1);
          v30 = v27 != v29;
        }
        while (v27 == v29 && v25-- != 0);
      }
      else
      {
        v30 = 0;
      }
    }
    else
    {
      v30 = 1;
    }
    if (v23 < 0)
    {
      operator delete(__p[0]);
      if ((v36 & 0x80) == 0)
      {
LABEL_29:
        if (v30)
          return 0;
        return CompareSubByteValues<MIL::UInt6>(v10, v12, v19);
      }
    }
    else if ((v20 & 0x80) == 0)
    {
      goto LABEL_29;
    }
    operator delete(__s1);
    if (v30)
      return 0;
    return CompareSubByteValues<MIL::UInt6>(v10, v12, v19);
  }
  return result;
}

void sub_1E05A29F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05A2A84(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<MIL::UInt6>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<MIL::UInt6>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A2B34(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<MIL::UInt6>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<unsigned char>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<unsigned char>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<unsigned char>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<unsigned char>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E05A2CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<unsigned char>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA9960B0;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 14)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05A2DA8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E05A2E7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<unsigned char>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<unsigned char>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned char>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<unsigned char>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E05A2F50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E05A3020(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  unint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6;
  v8 = v6 ? (unsigned __int8 *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = v10 ? (unsigned __int8 *)v9 : 0;
  if (v7 != v10)
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E05A3238(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<unsigned char>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if (v7)
    v8 = (unsigned __int8 *)View;
  else
    v8 = 0;
  if (v7)
  {
    v9 = v7;
    do
    {
      v10 = *v8++;
      MIL::Util::HashCombine(&v12, (unint64_t *)v10);
      --v9;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05A3368(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<unsigned char>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<unsigned char>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A3418(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned char>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<unsigned short>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<unsigned short>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned short>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<unsigned short>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned short>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<unsigned short>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E05A359C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<unsigned short>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA996168;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 15)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05A368C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E05A3760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<unsigned short>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned short>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<unsigned short>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned short>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<unsigned short>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E05A3834(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E05A3904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6 & 0x7FFFFFFFFFFFFFFFLL;
  v8 = (v6 & 0x7FFFFFFFFFFFFFFFLL) != 0 ? (unsigned __int16 *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = (v10 & 0x7FFFFFFFFFFFFFFFLL) != 0 ? (unsigned __int16 *)v9 : 0;
  if (v7 != (v10 & 0x7FFFFFFFFFFFFFFFLL))
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E05A3B18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<unsigned short>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  unsigned __int16 *v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v8 = (unsigned __int16 *)View;
  else
    v8 = 0;
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 2 * v7;
    do
    {
      v10 = *v8++;
      MIL::Util::HashCombine(&v12, (unint64_t *)v10);
      v9 -= 2;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05A3C40(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<unsigned short>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<unsigned short>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A3CF0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned short>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<unsigned int>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<unsigned int>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned int>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<unsigned int>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned int>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<unsigned int>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E05A3E74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<unsigned int>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA996220;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 16)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05A3F64(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E05A4038(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<unsigned int>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned int>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<unsigned int>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned int>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<unsigned int>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E05A410C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E05A41DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6 & 0x3FFFFFFFFFFFFFFFLL;
  v8 = (v6 & 0x3FFFFFFFFFFFFFFFLL) != 0 ? (_DWORD *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = (v10 & 0x3FFFFFFFFFFFFFFFLL) != 0 ? (_DWORD *)v9 : 0;
  if (v7 != (v10 & 0x3FFFFFFFFFFFFFFFLL))
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E05A43F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<unsigned int>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((v7 & 0x3FFFFFFFFFFFFFFFLL) != 0)
    v8 = (unsigned int *)View;
  else
    v8 = 0;
  if ((v7 & 0x3FFFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 4 * v7;
    do
    {
      v10 = *v8++;
      MIL::Util::HashCombine(&v12, (unint64_t *)v10);
      v9 -= 4;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05A4518(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<unsigned int>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<unsigned int>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A45C8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned int>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void MIL::IRTypedTensorValue<unsigned long long>::~IRTypedTensorValue(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTypedTensorValue<unsigned long long>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned long long>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<unsigned long long>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v8 = operator new();
  MIL::IRValueUnownedData<unsigned long long>::IRValueUnownedData(v8, a2, a3, a4);
  v11 = v8;
  MIL::IRTypedTensorValue<unsigned long long>::IRTypedTensorValue(a1, a2, &v11);
  v9 = v11;
  v11 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return a1;
}

void sub_1E05A474C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<unsigned long long>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  *a1 = &off_1EA9962D8;
  a1[1] = a2;
  v4 = *a3;
  *a3 = 0;
  a1[2] = v4;
  v5 = a1[1];
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5) != 17)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05A483C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  __cxa_free_exception(v2);
  v4 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void sub_1E05A4910(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTypedTensorValue<unsigned long long>::IRTypedTensorValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned long long>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<unsigned long long>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v6 = operator new();
  MIL::IRValueVectorData<unsigned long long>::IRValueVectorData(v6, a2, a3);
  v9 = v6;
  MIL::IRTypedTensorValue<unsigned long long>::IRTypedTensorValue(a1, a2, &v9);
  v7 = v9;
  v9 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_1E05A49E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void sub_1E05A4AB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::Equals(_QWORD *a1, _QWORD *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t View;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unsigned __int8 v12;
  size_t v13;
  unint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  void **p_s1;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *__p[2];
  unsigned __int8 v29;
  void *__s1;
  size_t __n;
  unsigned __int8 v32;

  if (a1 == lpsrc)
    return 1;
  if (!result)
    return result;
  v4 = result;
  if (a1[1] != *(_QWORD *)(result + 8))
    return 0;
  View = MIL::IRValueContiguousData<BOOL>::GetView(a1[2]);
  v7 = v6 & 0x1FFFFFFFFFFFFFFFLL;
  v8 = (v6 & 0x1FFFFFFFFFFFFFFFLL) != 0 ? (_QWORD *)View : 0;
  v9 = MIL::IRValueContiguousData<BOOL>::GetView(*(_QWORD *)(v4 + 16));
  v11 = (v10 & 0x1FFFFFFFFFFFFFFFLL) != 0 ? (_QWORD *)v9 : 0;
  if (v7 != (v10 & 0x1FFFFFFFFFFFFFFFLL))
    return 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1[2] + 40))(&__s1);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v4 + 16) + 40))(__p);
  v12 = v32;
  if ((v32 & 0x80u) == 0)
    v13 = v32;
  else
    v13 = __n;
  v14 = v29;
  v15 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v14 = (unint64_t)__p[1];
  if (v13 == v14)
  {
    if ((v29 & 0x80u) == 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    if ((char)v32 < 0)
    {
      v22 = memcmp(__s1, v16, __n) != 0;
    }
    else if (v32)
    {
      v17 = v32 - 1;
      p_s1 = &__s1;
      do
      {
        v20 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        v19 = v20;
        v21 = *(unsigned __int8 *)v16;
        v16 = (void **)((char *)v16 + 1);
        v22 = v19 != v21;
      }
      while (v19 == v21 && v17-- != 0);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 1;
  }
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if ((v32 & 0x80) == 0)
    {
LABEL_34:
      if (v22)
        return 0;
      goto LABEL_38;
    }
  }
  else if ((v12 & 0x80) == 0)
  {
    goto LABEL_34;
  }
  operator delete(__s1);
  if (v22)
    return 0;
LABEL_38:
  if (!v7)
    return 1;
  if (*v8 != *v11)
    return 0;
  v24 = 1;
  do
  {
    v25 = v24;
    if (v7 == v24)
      break;
    v26 = v8[v24];
    v27 = v11[v24++];
  }
  while (v26 == v27);
  return v25 >= v7;
}

void sub_1E05A4CC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::GetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

unint64_t MIL::IRTypedTensorValue<unsigned long long>::GetHash(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t View;
  uint64_t v7;
  unint64_t **v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = HIDWORD(v2);
  v4 = 0x9DDFEA08EB382D69 * (((8 * v2) + 8) ^ HIDWORD(v2));
  v5 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  v12 = v5;
  View = MIL::IRValueContiguousData<BOOL>::GetView(v1);
  if ((v7 & 0x1FFFFFFFFFFFFFFFLL) != 0)
    v8 = (unint64_t **)View;
  else
    v8 = 0;
  if ((v7 & 0x1FFFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 8 * v7;
    do
    {
      v10 = *v8++;
      MIL::Util::HashCombine(&v12, v10);
      v9 -= 8;
    }
    while (v9);
    return v12;
  }
  return v5;
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::GetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::UsesFileStorage(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::IsFileStorage(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::TryGetFileProperties(uint64_t a1)
{
  return MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::GetFileProperties(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;

  result = MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(*(_QWORD *)(a1 + 16));
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "file properties not available for in-memory tensors");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05A4DF0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::UsesUnownedMemory(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

const MIL::Text::SerializerOptions *MIL::IRTypedTensorValue<unsigned long long>::ToString(MIL::IRTensorValue *a1)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::Val<unsigned long long>((uint64_t)v5, a1);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A4EA0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::UsesEncryptedFileStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::UsesConstexprOutput(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t MIL::IRTypedTensorValue<unsigned long long>::TryGetConstExprOutputName(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

void MIL::IRTupleValue::~IRTupleValue(MIL::IRTupleValue *this)
{
  void **v1;

  v1 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v1;

  v1 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  v2 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x1E0C023A0](this, 0xE1C406427F484);
}

_QWORD *MIL::IRTupleValue::IRTupleValue(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t i;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  MIL *v10;
  uint64_t v11;
  const MIL::IRValueType *v12;
  const MIL::IRValueType *v13;
  unint64_t v15;
  std::runtime_error *v16;
  std::string *v17;
  __int128 v18;
  std::string *v19;
  __int128 v20;
  std::string *v21;
  std::string::size_type v22;
  std::string *v23;
  __int128 v24;
  std::string *v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  const std::string::value_type *v29;
  std::string::size_type v30;
  std::string *v31;
  __int128 v32;
  std::runtime_error *exception;
  _QWORD *v34;
  std::string *v35;
  __int128 v36;
  std::string *v37;
  __int128 v38;
  std::string *v39;
  std::string::size_type size;
  std::string *v41;
  __int128 v42;
  std::string *v43;
  __int128 v44;
  std::runtime_error *v45;
  _QWORD v46[2];
  unsigned __int8 v47;
  std::string v48;
  std::string v49;
  std::string v50;
  std::string v51;
  std::string v52;
  std::string v53;
  std::string v54;

  *a1 = off_1EA996390;
  a1[1] = a2;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  *((_OWORD *)a1 + 1) = *(_OWORD *)a3;
  a1[4] = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v4 = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[1] + 64))(a1[1]);
  if ((uint64_t)(v4[1] - *v4) >> 3 != (uint64_t)(a1[3] - a1[2]) >> 4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v34 = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[1] + 64))(a1[1]);
    std::to_string(&v50, (uint64_t)(v34[1] - *v34) >> 3);
    v35 = std::string::insert(&v50, 0, "Cannot create a tuple value with ");
    v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    v37 = std::string::append(&v51, " types from ");
    v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v38;
    v37->__r_.__value_.__l.__size_ = 0;
    v37->__r_.__value_.__r.__words[2] = 0;
    v37->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v49, (uint64_t)(a1[3] - a1[2]) >> 4);
    if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v39 = &v49;
    else
      v39 = (std::string *)v49.__r_.__value_.__r.__words[0];
    if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v49.__r_.__value_.__r.__words[2]);
    else
      size = v49.__r_.__value_.__l.__size_;
    v41 = std::string::append(&v52, (const std::string::value_type *)v39, size);
    v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__r.__words[2] = v41->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v42;
    v41->__r_.__value_.__l.__size_ = 0;
    v41->__r_.__value_.__r.__words[2] = 0;
    v41->__r_.__value_.__r.__words[0] = 0;
    v43 = std::string::append(&v53, " values.");
    v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
    v54.__r_.__value_.__r.__words[2] = v43->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v44;
    v43->__r_.__value_.__l.__size_ = 0;
    v43->__r_.__value_.__r.__words[2] = 0;
    v43->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v54);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  v5 = 0;
  for (i = 0; ; ++i)
  {
    v7 = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[1] + 64))(a1[1]);
    v8 = v7[1] - *v7;
    v9 = a1[1];
    if (i >= v8 >> 3)
      break;
    v10 = *(MIL **)(*(_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 64))(v9) + 8 * i);
    v11 = a1[2];
    if (a1[3] == v11)
      v11 = 0;
    v12 = (const MIL::IRValueType *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v11 + v5) + 32))(*(_QWORD *)(v11 + v5));
    if ((MIL::IsEqualOrStrongerType(v10, v12, v13) & 1) == 0)
    {
      v15 = i;
      v16 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      (*(void (**)(std::string *__return_ptr))(*(_QWORD *)a1[1] + 56))(&v49);
      v17 = std::string::insert(&v49, 0, "Cannot create a tuple of type ");
      v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
      v50.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v18;
      v17->__r_.__value_.__l.__size_ = 0;
      v17->__r_.__value_.__r.__words[2] = 0;
      v17->__r_.__value_.__r.__words[0] = 0;
      v19 = std::string::append(&v50, " from value at index ");
      v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
      v51.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v20;
      v19->__r_.__value_.__l.__size_ = 0;
      v19->__r_.__value_.__r.__words[2] = 0;
      v19->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v48, v15);
      if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v21 = &v48;
      else
        v21 = (std::string *)v48.__r_.__value_.__r.__words[0];
      if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v22 = HIBYTE(v48.__r_.__value_.__r.__words[2]);
      else
        v22 = v48.__r_.__value_.__l.__size_;
      v23 = std::string::append(&v51, (const std::string::value_type *)v21, v22);
      v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      v52.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      v25 = std::string::append(&v52, " of incompatible type ");
      v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      v53.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      v27 = a1[2];
      if (a1[3] == v27)
        v27 = 0;
      v28 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v27 + v5) + 32))(*(_QWORD *)(v27 + v5));
      (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)v28 + 56))(v46);
      if ((v47 & 0x80u) == 0)
        v29 = (const std::string::value_type *)v46;
      else
        v29 = (const std::string::value_type *)v46[0];
      if ((v47 & 0x80u) == 0)
        v30 = v47;
      else
        v30 = v46[1];
      v31 = std::string::append(&v53, v29, v30);
      v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
      v54.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v32;
      v31->__r_.__value_.__l.__size_ = 0;
      v31->__r_.__value_.__r.__words[2] = 0;
      v31->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(v16, &v54);
      __cxa_throw(v16, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
    }
    v5 += 16;
  }
  if (!v9)
  {
    v45 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v45, "Type cannot be null");
    __cxa_throw(v45, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return a1;
}

void sub_1E05A53CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  void *v47;
  int v48;
  uint64_t v49;
  uint64_t v50;

  if (*(char *)(v50 - 73) < 0)
    operator delete(*(void **)(v50 - 96));
  if (*(char *)(v50 - 105) < 0)
    operator delete(*(void **)(v50 - 128));
  if (a27 < 0)
    operator delete(__p);
  if (a47 < 0)
    operator delete(a42);
  if (a40 < 0)
    operator delete(a35);
  if (a33 < 0)
  {
    operator delete(a28);
    if ((v48 & 1) == 0)
    {
LABEL_16:
      *(_QWORD *)(v50 - 96) = v49;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v50 - 96));
      _Unwind_Resume(a1);
    }
  }
  else if (!v48)
  {
    goto LABEL_16;
  }
  __cxa_free_exception(v47);
  goto LABEL_16;
}

uint64_t MIL::IRTupleValue::GetType(MIL::IRTupleValue *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t MIL::IRTupleValue::GetValues(MIL::IRTupleValue *this)
{
  if (*((_QWORD *)this + 3) == *((_QWORD *)this + 2))
    return 0;
  else
    return *((_QWORD *)this + 2);
}

uint64_t MIL::IRTupleValue::Equals(MIL::IRTupleValue *this, const MIL::IRValue *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  if (this == a2)
    return 1;
  result = (*(uint64_t (**)(const MIL::IRValue *))(*(_QWORD *)a2 + 56))(a2);
  if (!result)
    return result;
  v4 = result;
  if (*((_QWORD *)this + 1) != *(_QWORD *)(result + 8))
    return 0;
  v5 = *((_QWORD *)this + 2);
  if (*((_QWORD *)this + 3) == v5)
    return 1;
  v6 = 0;
  v7 = 0;
  do
  {
    v8 = *(_QWORD *)(v4 + 16);
    if (v7 >= (*(_QWORD *)(v4 + 24) - v8) >> 4)
      std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
    result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v5 + v6) + 16))(*(_QWORD *)(v5 + v6), *(_QWORD *)(v8 + v6));
    if ((result & 1) == 0)
      break;
    ++v7;
    v5 = *((_QWORD *)this + 2);
    v6 += 16;
  }
  while (v7 < (*((_QWORD *)this + 3) - v5) >> 4);
  return result;
}

uint64_t MIL::IRTupleValue::GetHash(MIL::IRTupleValue *this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  unint64_t *v4;
  uint64_t v6;

  v6 = 0;
  v1 = (uint64_t *)*((_QWORD *)this + 2);
  v2 = (uint64_t *)*((_QWORD *)this + 3);
  if (v1 == v2)
    return 0;
  do
  {
    v3 = *v1;
    v1 += 2;
    v4 = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    MIL::Util::HashCombine(&v6, v4);
  }
  while (v1 != v2);
  return v6;
}

const MIL::Text::SerializerOptions *MIL::IRTupleValue::ToString(MIL::IRTupleValue *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Val((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A5798(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

void MIL::IRListValue::~IRListValue(MIL::IRListValue *this)
{
  void **v1;

  v1 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v1;

  v1 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  v2 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x1E0C023A0](this, 0xE1C406427F484);
}

uint64_t MIL::IRListValue::IRListValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  MIL *v12;
  _QWORD *v13;
  const MIL::IRValueType *v14;
  const MIL::IRValueType *v15;
  std::runtime_error *v17;
  MIL *v18;
  std::runtime_error *v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  uint64_t v24;
  std::string *v25;
  std::string::size_type v26;
  std::string *v27;
  __int128 v28;
  std::runtime_error *exception;
  std::runtime_error *v30;
  unint64_t v31;
  std::string *v32;
  __int128 v33;
  std::string *v34;
  __int128 v35;
  std::string *v36;
  std::string::size_type size;
  std::string *v38;
  __int128 v39;
  std::string v40;
  std::string v41;
  std::string v42;
  std::string v43;
  std::string v44;

  *(_QWORD *)a1 = off_1EA9963F0;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v4 = *(_QWORD *)(a1 + 8);
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Type cannot be null");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 24);
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4) != (v6 - v5) >> 4)
  {
    v30 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v31 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
    std::to_string(&v41, v31);
    v32 = std::string::insert(&v41, 0, "Cannot create a list of length");
    v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v42.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    v34 = std::string::append(&v42, " from a value list of length ");
    v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
    v43.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v35;
    v34->__r_.__value_.__l.__size_ = 0;
    v34->__r_.__value_.__r.__words[2] = 0;
    v34->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v40, (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 4);
    if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v36 = &v40;
    else
      v36 = (std::string *)v40.__r_.__value_.__r.__words[0];
    if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
    else
      size = v40.__r_.__value_.__l.__size_;
    v38 = std::string::append(&v43, (const std::string::value_type *)v36, size);
    v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    v44.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v30, &v44);
    __cxa_throw(v30, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  v7 = MIL::IRValueType::AsListType(*(MIL::IRValueType **)(a1 + 8));
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 64))(v7);
  v9 = *(_QWORD **)(a1 + 16);
  v10 = *(_QWORD *)(a1 + 24) - (_QWORD)v9;
  if (v10)
    v11 = *(_QWORD *)(a1 + 16);
  else
    v11 = 0;
  if (v10)
  {
    v12 = (MIL *)v8;
    v13 = (_QWORD *)(v11 + v10);
    do
    {
      v14 = (const MIL::IRValueType *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v9 + 32))(*v9);
      if ((MIL::IsEqualOrStrongerType(v12, v14, v15) & 1) == 0)
      {
        v17 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        v18 = v12;
        v19 = v17;
        (*(void (**)(std::string *__return_ptr, MIL *))(*(_QWORD *)v18 + 56))(&v41, v18);
        v20 = std::string::insert(&v41, 0, "Cannot initialize list value of element type ");
        v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
        v42.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v21;
        v20->__r_.__value_.__l.__size_ = 0;
        v20->__r_.__value_.__r.__words[2] = 0;
        v20->__r_.__value_.__r.__words[0] = 0;
        v22 = std::string::append(&v42, " from value with incompatible element type ");
        v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
        v43.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v23;
        v22->__r_.__value_.__l.__size_ = 0;
        v22->__r_.__value_.__r.__words[2] = 0;
        v22->__r_.__value_.__r.__words[0] = 0;
        v24 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v9 + 32))(*v9);
        (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v24 + 56))(&v40);
        if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v25 = &v40;
        else
          v25 = (std::string *)v40.__r_.__value_.__r.__words[0];
        if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
        else
          v26 = v40.__r_.__value_.__l.__size_;
        v27 = std::string::append(&v43, (const std::string::value_type *)v25, v26);
        v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
        v44.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v28;
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        std::runtime_error::runtime_error(v19, &v44);
        __cxa_throw(v19, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
      }
      v9 += 2;
    }
    while (v9 != v13);
  }
  return a1;
}

void sub_1E05A5BA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  void *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;

  if (*(char *)(v36 - 57) < 0)
    operator delete(*(void **)(v36 - 80));
  if (a14 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
  {
    operator delete(a15);
    if ((v35 & 1) == 0)
    {
LABEL_14:
      *(_QWORD *)(v36 - 80) = v34;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v36 - 80));
      _Unwind_Resume(a1);
    }
  }
  else if (!v35)
  {
    goto LABEL_14;
  }
  __cxa_free_exception(v33);
  goto LABEL_14;
}

uint64_t MIL::IRListValue::GetValues(MIL::IRListValue *this)
{
  if (*((_QWORD *)this + 3) == *((_QWORD *)this + 2))
    return 0;
  else
    return *((_QWORD *)this + 2);
}

uint64_t MIL::IRListValue::GetType(MIL::IRListValue *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t MIL::IRListValue::GetElementType(MIL::IRValueType **this)
{
  uint64_t v1;

  v1 = MIL::IRValueType::AsListType(this[1]);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 64))(v1);
}

uint64_t MIL::IRListValue::Equals(MIL::IRListValue *this, const MIL::IRValue *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  if (this == a2)
    return 1;
  result = (*(uint64_t (**)(const MIL::IRValue *))(*(_QWORD *)a2 + 48))(a2);
  if (result)
  {
    v4 = result;
    if (*((_QWORD *)this + 1) == *(_QWORD *)(result + 8)
      && (v5 = *((_QWORD *)this + 2),
          v6 = *((_QWORD *)this + 3),
          v6 - v5 == *(_QWORD *)(result + 24) - *(_QWORD *)(result + 16)))
    {
      if (v6 == v5)
      {
        return 1;
      }
      else
      {
        v7 = 0;
        v8 = 0;
        do
        {
          result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v5 + v7) + 16))(*(_QWORD *)(v5 + v7), *(_QWORD *)(*(_QWORD *)(v4 + 16) + v7));
          if ((result & 1) == 0)
            break;
          ++v8;
          v5 = *((_QWORD *)this + 2);
          v7 += 16;
        }
        while (v8 < (*((_QWORD *)this + 3) - v5) >> 4);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t MIL::IRListValue::GetHash(MIL::IRListValue *this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  unint64_t *v4;
  uint64_t v6;

  v6 = 0;
  v1 = (uint64_t *)*((_QWORD *)this + 2);
  v2 = (uint64_t *)*((_QWORD *)this + 3);
  if (v1 == v2)
    return 0;
  do
  {
    v3 = *v1;
    v1 += 2;
    v4 = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    MIL::Util::HashCombine(&v6, v4);
  }
  while (v1 != v2);
  return v6;
}

const MIL::Text::SerializerOptions *MIL::IRListValue::ToString(MIL::IRListValue *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Val((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A5E88(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

void MIL::IRDictionaryValue::~IRDictionaryValue(MIL::IRDictionaryValue *this)
{
  std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 8);
}

{
  std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 8);
}

{
  std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 8);
  JUMPOUT(0x1E0C023A0);
}

BOOL MIL::IRDictionaryValue::Equals(MIL::IRDictionaryValue *this, const MIL::IRValue *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const MIL::IRValue **v7;
  _BOOL8 v8;
  char v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v14;
  std::__shared_weak_count *v15;

  if (this == a2)
    return 1;
  v3 = (*(uint64_t (**)(const MIL::IRValue *))(*(_QWORD *)a2 + 64))(a2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 6) + 64))(*((_QWORD *)this + 6));
  v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 6) + 72))(*((_QWORD *)this + 6));
  if (v5 != (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 48) + 64))(*(_QWORD *)(v4 + 48))
    || v6 != (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 48) + 72))(*(_QWORD *)(v4 + 48))
    || *((_QWORD *)this + 4) != *(_QWORD *)(v4 + 32))
  {
    return 0;
  }
  v7 = (const MIL::IRValue **)((char *)this + 24);
  do
  {
    v7 = (const MIL::IRValue **)*v7;
    v8 = v7 == 0;
    if (!v7)
      break;
    MIL::IRDictionaryValue::TryGetValueForKey((MIL::IRDictionaryValue *)v4, v7[2], &v14);
    if (!v14)
    {
      std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&v14);
      return 0;
    }
    v9 = (*(uint64_t (**)(const MIL::IRValue *))(*(_QWORD *)v7[4] + 16))(v7[4]);
    v10 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  while ((v9 & 1) != 0);
  return v8;
}

void sub_1E05A60A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void MIL::IRDictionaryValue::TryGetValueForKey(MIL::IRDictionaryValue *this@<X0>, const MIL::IRValue *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v4;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  char v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;

  v4 = (_QWORD *)*((_QWORD *)this + 3);
  if (v4)
  {
    while (1)
    {
      v6 = (std::__shared_weak_count *)v4[3];
      v20 = v6;
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
      }
      v9 = (std::__shared_weak_count *)v4[5];
      if (v9)
      {
        v10 = (unint64_t *)&v9->__shared_owners_;
        do
          v11 = __ldxr(v10);
        while (__stxr(v11 + 1, v10));
      }
      v12 = (*(uint64_t (**)(const MIL::IRValue *))(*(_QWORD *)a2 + 16))(a2);
      if (v9)
      {
        v13 = (unint64_t *)&v9->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      if (v20)
      {
        v15 = (unint64_t *)&v20->__shared_owners_;
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      if ((v12 & 1) != 0)
        break;
      v4 = (_QWORD *)*v4;
      if (!v4)
        goto LABEL_20;
    }
    v17 = v4[5];
    *a3 = v4[4];
    a3[1] = v17;
    if (v17)
    {
      v18 = (unint64_t *)(v17 + 8);
      do
        v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
    }
  }
  else
  {
LABEL_20:
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_1E05A61F0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v9;
  uint64_t v10;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v10);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    *v9 = 0;
    v9[1] = 0;
    __cxa_end_catch();
    JUMPOUT(0x1E05A61D8);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRDictionaryValue::GetHash(MIL::IRDictionaryValue *this)
{
  uint64_t **v1;
  unint64_t *v2;
  unint64_t *v3;
  uint64_t v5;

  v5 = 0;
  v1 = (uint64_t **)*((_QWORD *)this + 3);
  if (!v1)
    return 0;
  do
  {
    v2 = (unint64_t *)(*(uint64_t (**)(uint64_t *))(*v1[2] + 24))(v1[2]);
    MIL::Util::HashCombine(&v5, v2);
    v3 = (unint64_t *)(*(uint64_t (**)(uint64_t *))(*v1[4] + 24))(v1[4]);
    MIL::Util::HashCombine(&v5, v3);
    v1 = (uint64_t **)*v1;
  }
  while (v1);
  return v5;
}

uint64_t MIL::IRDictionaryValue::GetType(MIL::IRDictionaryValue *this)
{
  return *((_QWORD *)this + 6);
}

void MIL::IRDictionaryValue::GetValueForKey(MIL::IRDictionaryValue *this@<X0>, const MIL::IRValue *a2@<X1>, _QWORD *a3@<X8>)
{
  std::runtime_error *exception;

  MIL::IRDictionaryValue::TryGetValueForKey(this, a2, a3);
  if (!*a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested key not present in IRDictionaryValue.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
}

void sub_1E05A630C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRDictionaryValue::Size(MIL::IRDictionaryValue *this)
{
  return *((_QWORD *)this + 4);
}

uint64_t MIL::IRDictionaryValue::begin(MIL::IRDictionaryValue *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t MIL::IRDictionaryValue::end(MIL::IRDictionaryValue *this)
{
  return 0;
}

const MIL::Text::SerializerOptions *MIL::IRDictionaryValue::ToString(MIL::IRDictionaryValue *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Val((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05A63D4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRDictionaryValue::IRDictionaryValue(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v5;
  MIL *v6;
  const MIL::IRValueType *v7;
  const MIL::IRValueType *v8;
  MIL *v9;
  const MIL::IRValueType *v10;
  const MIL::IRValueType *v11;
  std::runtime_error *v12;
  uint64_t v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  uint64_t v18;
  const std::string::value_type *v19;
  std::string::size_type v20;
  std::string *v21;
  __int128 v22;
  std::runtime_error *exception;
  uint64_t v25;
  std::string *v26;
  __int128 v27;
  std::string *v28;
  __int128 v29;
  uint64_t v30;
  const std::string::value_type *v31;
  std::string::size_type v32;
  std::string *v33;
  __int128 v34;
  const std::string::value_type *v35;
  std::string::size_type v36;
  unsigned __int8 v37;
  std::string v38;
  std::string v39;
  std::string v40;
  std::string v41;

  *a1 = &off_1EA996450;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)(a1 + 1), a3);
  a1[6] = a2;
  v5 = a1 + 3;
  while (1)
  {
    v5 = (_QWORD *)*v5;
    if (!v5)
      break;
    v6 = (MIL *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[6] + 64))(a1[6]);
    v7 = (const MIL::IRValueType *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v5[2] + 32))(v5[2]);
    if ((MIL::IsEqualOrStrongerType(v6, v7, v8) & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      v25 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[6] + 64))(a1[6]);
      (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v25 + 56))(&v38);
      v26 = std::string::insert(&v38, 0, "Cannot initialize dict key of type ");
      v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v27;
      v26->__r_.__value_.__l.__size_ = 0;
      v26->__r_.__value_.__r.__words[2] = 0;
      v26->__r_.__value_.__r.__words[0] = 0;
      v28 = std::string::append(&v39, " from value with incompatible type ");
      v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v29;
      v28->__r_.__value_.__l.__size_ = 0;
      v28->__r_.__value_.__r.__words[2] = 0;
      v28->__r_.__value_.__r.__words[0] = 0;
      v30 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v5[2] + 32))(v5[2]);
      (*(void (**)(const std::string::value_type **__return_ptr))(*(_QWORD *)v30 + 56))(&v35);
      if ((v37 & 0x80u) == 0)
        v31 = (const std::string::value_type *)&v35;
      else
        v31 = v35;
      if ((v37 & 0x80u) == 0)
        v32 = v37;
      else
        v32 = v36;
      v33 = std::string::append(&v40, v31, v32);
      v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
      v41.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v34;
      v33->__r_.__value_.__l.__size_ = 0;
      v33->__r_.__value_.__r.__words[2] = 0;
      v33->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(exception, &v41);
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
    }
    v9 = (MIL *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[6] + 72))(a1[6]);
    v10 = (const MIL::IRValueType *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v5[4] + 32))(v5[4]);
    if ((MIL::IsEqualOrStrongerType(v9, v10, v11) & 1) == 0)
    {
      v12 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      v13 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[6] + 72))(a1[6]);
      (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v13 + 56))(&v38);
      v14 = std::string::insert(&v38, 0, "Cannot initialize dict value of type ");
      v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      v16 = std::string::append(&v39, " from value with incompatible type ");
      v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      v18 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v5[4] + 32))(v5[4]);
      (*(void (**)(const std::string::value_type **__return_ptr))(*(_QWORD *)v18 + 56))(&v35);
      if ((v37 & 0x80u) == 0)
        v19 = (const std::string::value_type *)&v35;
      else
        v19 = v35;
      if ((v37 & 0x80u) == 0)
        v20 = v37;
      else
        v20 = v36;
      v21 = std::string::append(&v40, v19, v20);
      v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
      v41.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v22;
      v21->__r_.__value_.__l.__size_ = 0;
      v21->__r_.__value_.__r.__words[2] = 0;
      v21->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(v12, &v41);
      __cxa_throw(v12, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
    }
  }
  return a1;
}

void sub_1E05A66EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;
  void *v34;
  int v35;
  uint64_t v36;

  if (*(char *)(v36 - 41) < 0)
    operator delete(*(void **)(v36 - 64));
  if (a14 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
  {
    operator delete(a15);
    if ((v35 & 1) == 0)
    {
LABEL_14:
      std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v33);
      _Unwind_Resume(a1);
    }
  }
  else if (!v35)
  {
    goto LABEL_14;
  }
  __cxa_free_exception(v34);
  goto LABEL_14;
}

uint64_t MIL::Util::Span<MIL::Int4 const,18446744073709551615ul>::ValueAt(_QWORD *a1, unint64_t a2)
{
  unsigned int v2;
  std::logic_error *exception;
  unsigned __int8 v5;

  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  v2 = ((15 << ((4 * a2) & 4)) & *(unsigned __int8 *)(*a1 + ((a2 >> 1) & 0x1FFFFFFFFFFFFFFFLL))) >> ((4 * a2) & 4);
  if ((v2 & 8) != 0)
    LOBYTE(v2) = v2 | 0xF0;
  MIL::Int4::Int4((MIL::Int4 *)&v5, v2);
  return v5;
}

void sub_1E05A6868(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::Util::Span<MIL::UInt6 const,18446744073709551615ul>::ValueAt(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  unsigned __int8 *v3;
  unsigned int v4;
  uint64_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  int64x2_t v10;
  int64x2_t v11;
  int64x2_t v12;
  int64x2_t v13;
  int64x2_t v14;
  int64x2_t v15;
  int64x2_t v16;
  int8x16_t v17;
  int64x2_t v18;
  uint32x4_t v19;
  uint64x2_t v20;
  int32x4_t v21;
  int64x2_t v22;
  int8x16_t v23;
  uint64x2_t v24;
  uint64x2_t v25;
  uint64x2_t v26;
  uint64x2_t v27;
  uint64x2_t v28;
  uint64x2_t v29;
  uint64x2_t v30;
  uint64x2_t v31;
  int8x16_t v32;
  std::logic_error *exception;
  unsigned __int8 v35;

  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  v2 = (6 * a2) & 6;
  v3 = (unsigned __int8 *)(*a1 + ((6 * a2) >> 3));
  v4 = ((63 << v2) & *v3) >> v2;
  if (v2 >= 3)
  {
    v5 = ((_BYTE)v2 + 13) & 0x10;
    v6 = (int32x4_t)xmmword_1E0B00290;
    v7 = (int32x4_t)xmmword_1E0B002A0;
    v8 = (int32x4_t)xmmword_1E0B002B0;
    v9 = (int32x4_t)xmmword_1E0B002C0;
    v10 = (int64x2_t)xmmword_1E0B002D0;
    v11 = (int64x2_t)xmmword_1E0B002E0;
    v12 = (int64x2_t)xmmword_1E0B002F0;
    v13 = (int64x2_t)xmmword_1E0B00300;
    v14 = (int64x2_t)xmmword_1E0B00310;
    v15 = (int64x2_t)xmmword_1E0B00320;
    v16 = (int64x2_t)xmmword_1E0B00330;
    v17 = 0uLL;
    v18 = (int64x2_t)xmmword_1E0B00340;
    v19.i64[0] = 0x100000001;
    v19.i64[1] = 0x100000001;
    v20 = (uint64x2_t)vdupq_n_s64(v2 - 3);
    v21.i64[0] = 0x1000000010;
    v21.i64[1] = 0x1000000010;
    v22 = vdupq_n_s64(0x10uLL);
    do
    {
      v23 = v17;
      v24 = (uint64x2_t)v10;
      v25 = (uint64x2_t)v11;
      v26 = (uint64x2_t)v12;
      v27 = (uint64x2_t)v13;
      v28 = (uint64x2_t)v14;
      v29 = (uint64x2_t)v15;
      v17 = vorrq_s8(v17, vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vshlq_u32(v19, (uint32x4_t)v9), (int16x8_t)vshlq_u32(v19, (uint32x4_t)v8)), (int8x16_t)vuzp1q_s16((int16x8_t)vshlq_u32(v19, (uint32x4_t)v7), (int16x8_t)vshlq_u32(v19, (uint32x4_t)v6))));
      v30 = (uint64x2_t)v16;
      v15 = vaddq_s64(v15, v22);
      v31 = (uint64x2_t)v18;
      v16 = vaddq_s64(v16, v22);
      v18 = vaddq_s64(v18, v22);
      v14 = vaddq_s64(v14, v22);
      v13 = vaddq_s64(v13, v22);
      v12 = vaddq_s64(v12, v22);
      v11 = vaddq_s64(v11, v22);
      v10 = vaddq_s64(v10, v22);
      v9 = vaddq_s32(v9, v21);
      v8 = vaddq_s32(v8, v21);
      v7 = vaddq_s32(v7, v21);
      v6 = vaddq_s32(v6, v21);
      v5 -= 16;
    }
    while (v5);
    v32 = vbslq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v31, v20), (int32x4_t)vcgtq_u64(v30, v20)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v29, v20), (int32x4_t)vcgtq_u64(v28, v20))), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v27, v20), (int32x4_t)vcgtq_u64(v26, v20)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v25, v20), (int32x4_t)vcgtq_u64(v24, v20)))), v23, v17);
    *(int8x8_t *)v32.i8 = vorr_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
    v4 |= ((v32.i32[0] | v32.i32[1] | ((unint64_t)(v32.i64[0] | HIDWORD(v32.i64[0])) >> 16) | ((v32.i32[0] | v32.i32[1] | ((unint64_t)(v32.i64[0] | HIDWORD(v32.i64[0])) >> 16)) >> 8)) & v3[1]) << (8 - v2);
  }
  MIL::UInt6::UInt6((MIL::UInt6 *)&v35, v4);
  return v35;
}

void sub_1E05A6A90(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::Util::Span<MIL::UInt4 const,18446744073709551615ul>::ValueAt(_QWORD *a1, unint64_t a2)
{
  std::logic_error *exception;
  unsigned __int8 v4;

  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  MIL::UInt4::UInt4((MIL::UInt4 *)&v4, ((15 << ((4 * a2) & 4)) & *(unsigned __int8 *)(*a1 + ((a2 >> 1) & 0x1FFFFFFFFFFFFFFFLL))) >> ((4 * a2) & 4));
  return v4;
}

void sub_1E05A6B30(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::Util::Span<MIL::UInt3 const,18446744073709551615ul>::ValueAt(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  unsigned __int8 *v3;
  unsigned int v4;
  uint64_t v5;
  int32x2_t v6;
  int8x8_t v7;
  uint64x2_t v8;
  int64x2_t v9;
  int64x2_t v10;
  int8x8_t v11;
  uint64x2_t v12;
  int8x8_t v13;
  std::logic_error *exception;
  unsigned __int8 v16;

  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  v2 = (3 * a2) & 7;
  v3 = (unsigned __int8 *)(*a1 + ((3 * a2) >> 3));
  v4 = ((7 << v2) & *v3) >> v2;
  if (v2 >= 6)
  {
    v5 = v2 - ((3 * (_BYTE)a2) & 1) - 4;
    v6 = (int32x2_t)0x100000000;
    v7 = 0;
    v8 = (uint64x2_t)vdupq_n_s64(v2 - 6);
    v9 = (int64x2_t)xmmword_1E0B00340;
    v10 = vdupq_n_s64(2uLL);
    do
    {
      v11 = v7;
      v12 = (uint64x2_t)v9;
      v7 = vorr_s8(v7, (int8x8_t)vshl_u32((uint32x2_t)0x100000001, (uint32x2_t)v6));
      v9 = vaddq_s64(v9, v10);
      v6 = vadd_s32(v6, (int32x2_t)0x200000002);
      v5 -= 2;
    }
    while (v5);
    v13 = vbsl_s8((int8x8_t)vmovn_s64((int64x2_t)vcgtq_u64(v12, v8)), v11, v7);
    v4 |= ((v13.i32[0] | v13.i32[1]) & v3[1]) << (8 - v2);
  }
  MIL::UInt3::UInt3((MIL::UInt3 *)&v16, v4);
  return v16;
}

void sub_1E05A6C60(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::Util::Span<MIL::UInt2 const,18446744073709551615ul>::ValueAt(_QWORD *a1, unint64_t a2)
{
  std::logic_error *exception;
  unsigned __int8 v4;

  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  MIL::UInt2::UInt2((MIL::UInt2 *)&v4, ((3 << ((2 * a2) & 6)) & *(unsigned __int8 *)(*a1 + ((a2 >> 2) & 0x1FFFFFFFFFFFFFFFLL))) >> ((2 * a2) & 6));
  return v4;
}

void sub_1E05A6D00(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::Util::Span<MIL::UInt1 const,18446744073709551615ul>::ValueAt(_QWORD *a1, unint64_t a2)
{
  std::logic_error *exception;
  unsigned __int8 v4;

  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  MIL::UInt1::UInt1((MIL::UInt1 *)&v4, ((1 << (a2 & 7)) & *(unsigned __int8 *)(*a1 + (a2 >> 3))) >> (a2 & 7));
  return v4;
}

void sub_1E05A6D9C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL CompareSubByteValues<MIL::Int4>(unsigned __int8 *a1, unint64_t a2, unsigned __int8 *a3)
{
  char v4;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _BOOL8 result;

  v4 = a2;
  v6 = (a2 >> 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v6)
  {
    v7 = a1;
    v8 = a3;
    v9 = (a2 >> 1) & 0x1FFFFFFFFFFFFFFFLL;
    while (!MIL::operator!=(v7, v8))
    {
      ++v8;
      ++v7;
      if (!--v9)
        goto LABEL_5;
    }
    return 0;
  }
  else
  {
LABEL_5:
    v10 = 0;
    v11 = v4 & 1;
    do
    {
      result = v10 >= v11;
      if (v10 >= v11)
        break;
      v10 = 1;
    }
    while (((a3[v6] ^ a1[v6]) & 0xF) == 0);
  }
  return result;
}

BOOL CompareSubByteValues<MIL::UInt1>(unsigned __int8 *a1, unint64_t a2, unsigned __int8 *a3)
{
  char v4;
  unint64_t v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;

  v4 = a2;
  v6 = a2 >> 3;
  if (a2 >= 8)
  {
    if (v6 <= 1)
      v7 = 1;
    else
      v7 = a2 >> 3;
    v8 = a1;
    v9 = a3;
    while (!MIL::operator!=(v8, v9))
    {
      ++v9;
      ++v8;
      if (!--v7)
        goto LABEL_8;
    }
    return 0;
  }
LABEL_8:
  v10 = v4 & 7;
  if ((v4 & 7) == 0)
    return 1;
  v11 = a3[v6] ^ a1[v6];
  if ((v11 & 1) != 0)
    return 0;
  v12 = 1;
  do
  {
    v13 = v12;
    if (v10 == v12)
      break;
    ++v12;
  }
  while (((v11 >> v13) & 1) == 0);
  return v13 >= v10;
}

BOOL CompareSubByteValues<MIL::UInt2>(unsigned __int8 *a1, unint64_t a2, unsigned __int8 *a3)
{
  char v4;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;

  v4 = a2;
  v6 = (a2 >> 2) & 0x1FFFFFFFFFFFFFFFLL;
  if (v6)
  {
    v7 = a1;
    v8 = a3;
    v9 = (a2 >> 2) & 0x1FFFFFFFFFFFFFFFLL;
    while (!MIL::operator!=(v7, v8))
    {
      ++v8;
      ++v7;
      if (!--v9)
        goto LABEL_5;
    }
    return 0;
  }
LABEL_5:
  v10 = v4 & 3;
  if ((v4 & 3) == 0)
    return 1;
  v11 = a3[v6] ^ a1[v6];
  if ((v11 & 3) != 0)
    return 0;
  v13 = 2;
  v14 = 1;
  do
  {
    v15 = v14;
    if (v10 == v14)
      break;
    ++v14;
    v16 = v11 >> v13;
    v13 += 2;
  }
  while ((v16 & 3) == 0);
  return v15 >= v10;
}

BOOL CompareSubByteValues<MIL::UInt3>(unsigned __int8 *a1, uint64_t a2, unsigned __int8 *a3)
{
  char v5;
  unint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;

  v5 = 3 * a2;
  v6 = (unint64_t)(3 * a2) >> 3;
  if ((unint64_t)(3 * a2) >= 8)
  {
    if (v6 <= 1)
      v7 = 1;
    else
      v7 = (unint64_t)(3 * a2) >> 3;
    v8 = a1;
    v9 = a3;
    while (!MIL::operator!=(v8, v9))
    {
      ++v9;
      ++v8;
      if (!--v7)
        goto LABEL_8;
    }
    return 0;
  }
LABEL_8:
  if ((v5 & 7u) < 3)
    return 1;
  v11 = (v5 & 7u) / 3;
  v12 = a3[v6] ^ a1[v6];
  if (v11 <= 1)
    v13 = 1;
  else
    v13 = (v5 & 7u) / 3;
  if ((v12 & 7) != 0)
    return 0;
  v14 = 3;
  v15 = 1;
  do
  {
    v16 = v15;
    if (v13 == v15)
      break;
    ++v15;
    v17 = v12 >> v14;
    v14 += 3;
  }
  while ((v17 & 7) == 0);
  return v16 >= v11;
}

BOOL CompareSubByteValues<MIL::UInt4>(unsigned __int8 *a1, unint64_t a2, unsigned __int8 *a3)
{
  char v4;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _BOOL8 result;

  v4 = a2;
  v6 = (a2 >> 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v6)
  {
    v7 = a1;
    v8 = a3;
    v9 = (a2 >> 1) & 0x1FFFFFFFFFFFFFFFLL;
    while (!MIL::operator!=(v7, v8))
    {
      ++v8;
      ++v7;
      if (!--v9)
        goto LABEL_5;
    }
    return 0;
  }
  else
  {
LABEL_5:
    v10 = 0;
    v11 = v4 & 1;
    do
    {
      result = v10 >= v11;
      if (v10 >= v11)
        break;
      v10 = 1;
    }
    while (((a3[v6] ^ a1[v6]) & 0xF) == 0);
  }
  return result;
}

BOOL CompareSubByteValues<MIL::UInt6>(unsigned __int8 *a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v5;
  unint64_t v6;
  _BOOL4 v7;
  unint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;

  v5 = (6 * a2) & 6;
  v6 = ((unint64_t)(3 * a2) >> 2) & 0x1FFFFFFFFFFFFFFFLL;
  v7 = v5 == 6;
  if ((unint64_t)(6 * a2) < 8)
  {
LABEL_8:
    if (v5 == 6)
      v7 = ((a3[v6] ^ a1[v6]) & 0x3F) != 0;
    return !v7;
  }
  else
  {
    if (v6 <= 1)
      v8 = 1;
    else
      v8 = ((unint64_t)(3 * a2) >> 2) & 0x1FFFFFFFFFFFFFFFLL;
    v9 = a1;
    v10 = a3;
    while (!MIL::operator!=(v9, v10))
    {
      ++v10;
      ++v9;
      if (!--v8)
        goto LABEL_8;
    }
    return 0;
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)(v2 + 4));
      std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t MIL::IRValueContiguousData<BOOL>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9964F8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<BOOL>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA9964F8;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<BOOL>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA9964F8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<BOOL>::IsFileStorage(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 48);
}

uint64_t MIL::IRValueContiguousData<BOOL>::TryGetFileProperties(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 48))
    return a1 + 8;
  else
    return 0;
}

uint64_t MIL::IRValueContiguousData<BOOL>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<BOOL>::GetView(uint64_t a1)
{
  unsigned __int8 *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 v5;

  v2 = (unsigned __int8 *)(a1 + 56);
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  v5 = atomic_load(v2);
  if ((v5 & 1) == 0)
  {
    atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  }
  return v4;
}

unint64_t MIL::IRValueContiguousData<BOOL>::OnDataReady(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return result;
}

uint64_t MIL::IRValueContiguousData<BOOL>::GetByteView(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(a1);
  if (!v2)
    return 0;
  return result;
}

uint64_t MIL::IRValueContiguousData<BOOL>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<BOOL>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<BOOL>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<BOOL>::TryGetConstExprOutputName()
{
  return 0;
}

unint64_t MIL::`anonymous namespace'::ValidateType(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unint64_t result;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  std::runtime_error *exception;

  if (!(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1))
    goto LABEL_4;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 88))(v4);
  if (v5 > 0x19)
    goto LABEL_22;
  if (((1 << v5) & 0x303DEFC) != 0)
  {
LABEL_4:
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    if (result == a2)
      return result;
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Tensor storage and type have different number of elements");
LABEL_21:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  if (((1 << v5) & 0xF82000) == 0)
  {
LABEL_22:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Invalid data type in IsSubByteSizedDataType");
    goto LABEL_21;
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (result)
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    switch((*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 88))(v7))
    {
      case 0xDu:
      case 0x14u:
        v8 = 2 * a2;
        v9 = v8 - 1;
        goto LABEL_17;
      case 0x13u:
        v8 = 4 * a2;
        v9 = v8 - 3;
        goto LABEL_17;
      case 0x15u:
        v8 = 8 * a2;
        v9 = v8 - 7;
        goto LABEL_17;
      case 0x16u:
        v10 = 8 * a2;
        v8 = 8 * a2 / 3uLL;
        v11 = v8 - 3;
        v12 = v10 >= 9;
        goto LABEL_14;
      case 0x17u:
        v13 = 8 * a2;
        v8 = 8 * a2 / 6uLL;
        v11 = v8 - 2;
        v12 = v13 >= 0xC;
LABEL_14:
        if (v12)
          v9 = v11;
        else
          v9 = 0;
LABEL_17:
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
        if (result <= v8 && result >= v9)
          return result;
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Sub Byte tensor storage and type have different number of elements");
        break;
      default:
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Cannot validate tensor storage for unknown sub-byte-sized data");
        goto LABEL_21;
    }
    goto LABEL_21;
  }
  return result;
}

void sub_1E05A7650(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueContiguousData<std::string>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996548;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<std::string>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996548;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<std::string>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996548;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<std::string>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<std::string>::GetByteView(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(a1);
  if (!(24 * v2))
    return 0;
  return result;
}

uint64_t MIL::IRValueContiguousData<std::string>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<std::string>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<std::string>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<std::string>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Bf16>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996598;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::Bf16>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996598;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::Bf16>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996598;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::Bf16>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Bf16>::GetByteView(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(a1);
  if (!(2 * v2))
    return 0;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::Bf16>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Bf16>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<MIL::Bf16>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<MIL::Bf16>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp16>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9965E8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp16>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA9965E8;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp16>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA9965E8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp16>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp16>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp16>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<MIL::Fp16>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<MIL::Fp16>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E5M2>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996638;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E5M2>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996638;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E5M2>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996638;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E5M2>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E5M2>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E5M2>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<MIL::Fp8E5M2>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E5M2>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E4M3FN>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996688;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E4M3FN>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996688;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E4M3FN>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996688;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E4M3FN>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E4M3FN>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E4M3FN>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<MIL::Fp8E4M3FN>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<MIL::Fp8E4M3FN>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<float>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9966D8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<float>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA9966D8;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<float>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA9966D8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<float>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<float>::GetByteView(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(a1);
  if (!(4 * v2))
    return 0;
  return result;
}

uint64_t MIL::IRValueContiguousData<float>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<float>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<float>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<float>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<double>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996728;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<double>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996728;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<double>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996728;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<double>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<double>::GetByteView(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(a1);
  if (!(8 * v2))
    return 0;
  return result;
}

uint64_t MIL::IRValueContiguousData<double>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<double>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<double>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<double>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Int4>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996778;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::Int4>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996778;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::Int4>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996778;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::Int4>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Int4>::GetByteView(uint64_t a1)
{
  uint64_t result;
  unint64_t v2;

  result = MIL::IRValueContiguousData<BOOL>::GetView(a1);
  if (!(((v2 >> 1) & 0x1FFFFFFFFFFFFFFFLL) + (v2 & 1)))
    return 0;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::Int4>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::Int4>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<MIL::Int4>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<MIL::Int4>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<signed char>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9967C8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<signed char>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA9967C8;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<signed char>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA9967C8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<signed char>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<signed char>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<signed char>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<signed char>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<signed char>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<short>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996818;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<short>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996818;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<short>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996818;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<short>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<short>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<short>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<short>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<short>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<int>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996868;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<int>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996868;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<int>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996868;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<int>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<int>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<int>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<int>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<int>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<long long>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9968B8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<long long>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA9968B8;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<long long>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA9968B8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<long long>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<long long>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<long long>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<long long>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<long long>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt1>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996908;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt1>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996908;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt1>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996908;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt1>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt1>::GetByteView(uint64_t a1)
{
  uint64_t result;
  unint64_t v2;
  uint64_t v3;

  result = MIL::IRValueContiguousData<BOOL>::GetView(a1);
  if ((v2 & 7) != 0)
    v3 = (v2 >> 3) + 1;
  else
    v3 = v2 >> 3;
  if (!v3)
    return 0;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt1>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt1>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<MIL::UInt1>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<MIL::UInt1>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt2>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996958;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt2>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996958;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt2>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996958;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt2>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt2>::GetByteView(uint64_t a1)
{
  uint64_t result;
  unint64_t v2;
  uint64_t v3;

  result = MIL::IRValueContiguousData<BOOL>::GetView(a1);
  if ((v2 & 3) != 0)
    v3 = ((v2 >> 2) & 0x1FFFFFFFFFFFFFFFLL) + 1;
  else
    v3 = (v2 >> 2) & 0x1FFFFFFFFFFFFFFFLL;
  if (!v3)
    return 0;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt2>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt2>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<MIL::UInt2>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<MIL::UInt2>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt3>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9969A8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt3>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA9969A8;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt3>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA9969A8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt3>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt3>::GetByteView(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  unint64_t v3;

  result = MIL::IRValueContiguousData<BOOL>::GetView(a1);
  if (((3 * v2) & 7) != 0)
    v3 = ((unint64_t)(3 * v2) >> 3) + 1;
  else
    v3 = (unint64_t)(3 * v2) >> 3;
  if (!v3)
    return 0;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt3>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt3>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<MIL::UInt3>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<MIL::UInt3>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt4>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9969F8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt4>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA9969F8;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt4>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA9969F8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt4>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt4>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt4>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<MIL::UInt4>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<MIL::UInt4>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt6>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996A48;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt6>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996A48;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt6>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996A48;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt6>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt6>::GetByteView(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  unint64_t v3;

  result = MIL::IRValueContiguousData<BOOL>::GetView(a1);
  if (((6 * v2) & 6) != 0)
    v3 = (((unint64_t)(3 * v2) >> 2) & 0x1FFFFFFFFFFFFFFFLL) + 1;
  else
    v3 = ((unint64_t)(3 * v2) >> 2) & 0x1FFFFFFFFFFFFFFFLL;
  if (!v3)
    return 0;
  return result;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt6>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<MIL::UInt6>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<MIL::UInt6>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<MIL::UInt6>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned char>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996A98;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<unsigned char>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996A98;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<unsigned char>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996A98;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<unsigned char>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned char>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned char>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<unsigned char>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<unsigned char>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned short>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996AE8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<unsigned short>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996AE8;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<unsigned short>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996AE8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<unsigned short>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned short>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned short>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<unsigned short>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<unsigned short>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned int>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996B38;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<unsigned int>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996B38;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<unsigned int>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996B38;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<unsigned int>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned int>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned int>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<unsigned int>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<unsigned int>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned long long>::~IRValueContiguousData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996B88;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

uint64_t MIL::IRValueContiguousData<unsigned long long>::IRValueContiguousData(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1EA996B88;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t MIL::IRValueContiguousData<unsigned long long>::IRValueContiguousData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = off_1EA996B88;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t MIL::IRValueContiguousData<unsigned long long>::IsUnownedMemory()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned long long>::UsesEncryptedFileStorage()
{
  return 0;
}

uint64_t MIL::IRValueContiguousData<unsigned long long>::IsConstexprOutput()
{
  return 0;
}

_QWORD *MIL::IRValueContiguousData<unsigned long long>::GetConstExprOutputName@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

uint64_t MIL::IRValueContiguousData<unsigned long long>::TryGetConstExprOutputName()
{
  return 0;
}

uint64_t MIL::IRValueVectorData<unsigned char>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996BD8;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA996A98;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<unsigned char>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<unsigned char>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<unsigned char>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996BD8;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A8A34(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA996A98;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<unsigned char>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<unsigned short>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996C28;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA996AE8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<unsigned short>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<unsigned short>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<unsigned short>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996C28;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A8B94(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA996AE8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<unsigned short>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<unsigned int>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996C78;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA996B38;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<unsigned int>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<unsigned int>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<unsigned int>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996C78;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A8CF8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA996B38;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<unsigned int>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<unsigned long long>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996CC8;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA996B88;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<unsigned long long>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<unsigned long long>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<unsigned long long>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996CC8;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A8E5C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA996B88;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<unsigned long long>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<signed char>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996D18;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA9967C8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<signed char>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<signed char>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<signed char>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996D18;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A8FBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA9967C8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<signed char>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<short>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996D68;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA996818;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<short>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<short>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<short>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996D68;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A911C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA996818;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<short>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<int>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996DB8;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA996868;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<int>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<int>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<int>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996DB8;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A9280(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA996868;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<int>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<long long>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996E08;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA9968B8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<long long>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<long long>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<long long>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996E08;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A93E4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA9968B8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<long long>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<MIL::Bf16>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996E58;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA996598;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<MIL::Bf16>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<MIL::Bf16>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<MIL::Bf16>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996E58;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A9548(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA996598;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<MIL::Bf16>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<MIL::Fp16>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996EA8;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA9965E8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<MIL::Fp16>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<MIL::Fp16>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<MIL::Fp16>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996EA8;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A96AC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA9965E8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<MIL::Fp16>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<MIL::Fp8E4M3FN>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996EF8;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA996688;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<MIL::Fp8E4M3FN>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<MIL::Fp8E4M3FN>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<MIL::Fp8E4M3FN>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996EF8;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A980C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA996688;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<MIL::Fp8E4M3FN>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<MIL::Fp8E5M2>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996F48;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA996638;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<MIL::Fp8E5M2>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<MIL::Fp8E5M2>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<MIL::Fp8E5M2>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996F48;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A9968(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA996638;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<MIL::Fp8E5M2>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<float>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996F98;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA9966D8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<float>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<float>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<float>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996F98;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A9AC8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA9966D8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<float>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<double>::~IRValueVectorData(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1EA996FE8;
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1EA996728;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<double>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<double>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<double>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA996FE8;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A9C2C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v6;
    operator delete(v6);
  }
  *(_QWORD *)v1 = off_1EA996728;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueVectorData<double>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueVectorData<std::string>::~IRValueVectorData(uint64_t a1)
{
  void **v3;

  *(_QWORD *)a1 = &off_1EA997038;
  v3 = (void **)(a1 + 72);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  *(_QWORD *)a1 = off_1EA996548;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueVectorData<std::string>::~IRValueVectorData(uint64_t a1)
{
  MIL::IRValueVectorData<std::string>::~IRValueVectorData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueVectorData<std::string>::IRValueVectorData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997038;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A9DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  uint64_t v11;
  void **v12;
  void **v13;

  v13 = v12;
  a10 = v13;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a10);
  *(_QWORD *)v10 = off_1EA996548;
  if (*(_BYTE *)(v10 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v11);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueVectorData<std::string>::GetViewImpl(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 80) == *(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<BOOL>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9964F8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<BOOL>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9964F8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<BOOL>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997088;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05A9EF4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA9964F8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<BOOL>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<BOOL>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<std::string>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996548;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<std::string>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996548;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<std::string>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA9970D8;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AA020(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996548;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<std::string>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<std::string>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<MIL::Bf16>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996598;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<MIL::Bf16>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996598;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<MIL::Bf16>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997128;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AA14C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996598;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<MIL::Bf16>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<MIL::Bf16>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<MIL::Fp16>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9965E8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<MIL::Fp16>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9965E8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<MIL::Fp16>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997178;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AA278(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA9965E8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<MIL::Fp16>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<MIL::Fp16>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<MIL::Fp8E5M2>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996638;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<MIL::Fp8E5M2>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996638;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<MIL::Fp8E5M2>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA9971C8;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AA3A4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996638;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<MIL::Fp8E5M2>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<MIL::Fp8E5M2>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<MIL::Fp8E4M3FN>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996688;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<MIL::Fp8E4M3FN>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996688;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<MIL::Fp8E4M3FN>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997218;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AA4D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996688;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<MIL::Fp8E4M3FN>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<MIL::Fp8E4M3FN>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<float>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9966D8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<float>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9966D8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<float>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997268;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AA5FC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA9966D8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<float>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<float>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<double>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996728;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<double>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996728;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<double>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA9972B8;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AA728(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996728;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<double>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<double>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<MIL::Int4>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996778;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<MIL::Int4>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996778;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<MIL::Int4>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997308;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AA854(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996778;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<MIL::Int4>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<MIL::Int4>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<signed char>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9967C8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<signed char>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9967C8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<signed char>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997358;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AA980(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA9967C8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<signed char>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<signed char>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<short>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996818;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<short>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996818;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<short>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA9973A8;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AAAAC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996818;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<short>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<short>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<int>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996868;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<int>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996868;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<int>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA9973F8;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AABD8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996868;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<int>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<int>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<long long>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9968B8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<long long>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9968B8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<long long>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997448;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AAD04(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA9968B8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<long long>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<long long>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt1>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996908;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<MIL::UInt1>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996908;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt1>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997498;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AAE30(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996908;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt1>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<MIL::UInt1>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt2>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996958;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<MIL::UInt2>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996958;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt2>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA9974E8;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AAF5C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996958;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt2>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<MIL::UInt2>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt3>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9969A8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<MIL::UInt3>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9969A8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt3>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997538;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AB088(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA9969A8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt3>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<MIL::UInt3>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt4>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9969F8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<MIL::UInt4>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA9969F8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt4>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997588;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AB1B4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA9969F8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt4>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<MIL::UInt4>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt6>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996A48;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<MIL::UInt6>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996A48;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt6>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA9975D8;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AB2E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996A48;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<MIL::UInt6>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<MIL::UInt6>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<unsigned char>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996A98;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<unsigned char>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996A98;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<unsigned char>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997628;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AB40C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996A98;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<unsigned char>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<unsigned char>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<unsigned short>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996AE8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<unsigned short>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996AE8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<unsigned short>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997678;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AB538(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996AE8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<unsigned short>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<unsigned short>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<unsigned int>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996B38;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<unsigned int>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996B38;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<unsigned int>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA9976C8;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AB664(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996B38;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<unsigned int>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<unsigned int>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueUnownedData<unsigned long long>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996B88;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueUnownedData<unsigned long long>::~IRValueUnownedData(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA996B88;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueUnownedData<unsigned long long>::IRValueUnownedData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = &off_1EA997718;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  atomic_store(1u, (unsigned __int8 *)(a1 + 56));
  return a1;
}

void sub_1E05AB790(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1EA996B88;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueUnownedData<unsigned long long>::IsUnownedMemory()
{
  return 1;
}

uint64_t MIL::IRValueUnownedData<unsigned long long>::GetViewImpl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t MIL::IRValueLegacyStorageData<float>::~IRValueLegacyStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997768;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA9966D8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueLegacyStorageData<float>::~IRValueLegacyStorageData(uint64_t a1)
{
  MIL::IRValueLegacyStorageData<float>::~IRValueLegacyStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueLegacyStorageData<float>::IRValueLegacyStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  std::string::size_type size;
  int v15;
  std::string *p_p;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  BOOL v23;
  BOOL v24;
  const char *v25;
  std::logic_error *exception;
  void (*v28)(void *);
  struct type_info *v29;
  void *v30[2];
  char v31;
  std::string __p;

  *(_QWORD *)a1 = off_1EA9966D8;
  v7 = (_QWORD *)(a1 + 8);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997768;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "identifier");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v8;
  UnknownLocationImpl::~UnknownLocationImpl(*(UnknownLocationImpl **)(a1 + 72));
  v10 = v9;
  std::string::basic_string[abi:ne180100]<0>(v30, "path");
  v11 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v7, (unsigned __int8 *)v30);
  if (!v11)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v11 + 5), &__p);
  v12 = v10[23];
  if ((v12 & 0x80u) == 0)
    v13 = v10[23];
  else
    v13 = *((_QWORD *)v10 + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v15 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v13 != size)
  {
    v24 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_28;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v12 & 0x80) != 0)
  {
    v24 = memcmp(*(const void **)v10, p_p, *((_QWORD *)v10 + 1)) == 0;
    if ((v15 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_28;
  }
  if (!v10[23])
  {
    v24 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_28:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v17 = v12 - 1;
  do
  {
    v19 = *v10++;
    v18 = v19;
    v21 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v20 = v21;
    v23 = v17-- != 0;
    v24 = v18 == v20;
  }
  while (v18 == v20 && v23);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_28;
LABEL_22:
  if (v31 < 0)
    operator delete(v30[0]);
  if (!v24)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v28 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v29 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_36;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v28 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v29 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_36:
    __cxa_throw(exception, v29, v28);
  }
  UnknownLocationImpl::~UnknownLocationImpl(*(UnknownLocationImpl **)(a1 + 72));
  return a1;
}

void sub_1E05ABA84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::`anonymous namespace'::ValidateAndExtractProperty<unsigned long long>(unsigned __int8 *a1, _QWORD *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  std::runtime_error *exception;
  std::runtime_error *v6;
  std::string v7;

  v2 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a2, a1);
  if (!v2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    std::runtime_error::runtime_error(exception, &v7);
    exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E0DE5008] + 16);
    __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
  }
  v3 = MIL::IRValue::TryGetScalar<unsigned long long>(*((_QWORD *)v2 + 5));
  if (!v3)
  {
    v6 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    std::runtime_error::runtime_error(v6, &v7);
    __cxa_throw(v6, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return *(_QWORD *)v3;
}

void sub_1E05ABBF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  char v16;

  if (a15 < 0)
    operator delete(__p);
  if ((v16 & 1) != 0)
    __cxa_free_exception(v15);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::`anonymous namespace'::EnsureFileExists(const char *a1)
{
  uint64_t result;
  std::runtime_error *exception;
  std::string v3;
  stat v4;

  if (a1[23] < 0)
    a1 = *(const char **)a1;
  result = stat(a1, &v4);
  if ((_DWORD)result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    std::runtime_error::runtime_error(exception, &v3);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05ABCC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void MIL::IRValueLegacyStorageData<float>::GetFilename(uint64_t a1)
{
  UnknownLocationImpl::~UnknownLocationImpl(*(UnknownLocationImpl **)(a1 + 72));
}

uint64_t MIL::IRValueLegacyStorageData<float>::GetIdentifier(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t MIL::IRValueLegacyStorageData<float>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::LegacyStorageReader::IsEncrypted(*(MIL::Blob::MMapFileReader ***)(a1 + 72));
}

unint64_t MIL::IRValueLegacyStorageData<float>::GetViewImpl(uint64_t a1)
{
  return MIL::Blob::LegacyStorageReader::GetDataView<float>(*(MIL::Blob::MMapFileReader ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

uint64_t MIL::IRValueLegacyStorageData<MIL::Fp16>::~IRValueLegacyStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA9977B8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA9965E8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueLegacyStorageData<MIL::Fp16>::~IRValueLegacyStorageData(uint64_t a1)
{
  MIL::IRValueLegacyStorageData<MIL::Fp16>::~IRValueLegacyStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueLegacyStorageData<MIL::Fp16>::IRValueLegacyStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  std::string::size_type size;
  int v15;
  std::string *p_p;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  BOOL v23;
  BOOL v24;
  const char *v25;
  std::logic_error *exception;
  void (*v28)(void *);
  struct type_info *v29;
  void *v30[2];
  char v31;
  std::string __p;

  *(_QWORD *)a1 = off_1EA9965E8;
  v7 = (_QWORD *)(a1 + 8);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA9977B8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "identifier");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v8;
  UnknownLocationImpl::~UnknownLocationImpl(*(UnknownLocationImpl **)(a1 + 72));
  v10 = v9;
  std::string::basic_string[abi:ne180100]<0>(v30, "path");
  v11 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v7, (unsigned __int8 *)v30);
  if (!v11)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v11 + 5), &__p);
  v12 = v10[23];
  if ((v12 & 0x80u) == 0)
    v13 = v10[23];
  else
    v13 = *((_QWORD *)v10 + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v15 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v13 != size)
  {
    v24 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_28;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v12 & 0x80) != 0)
  {
    v24 = memcmp(*(const void **)v10, p_p, *((_QWORD *)v10 + 1)) == 0;
    if ((v15 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_28;
  }
  if (!v10[23])
  {
    v24 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_28:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v17 = v12 - 1;
  do
  {
    v19 = *v10++;
    v18 = v19;
    v21 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v20 = v21;
    v23 = v17-- != 0;
    v24 = v18 == v20;
  }
  while (v18 == v20 && v23);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_28;
LABEL_22:
  if (v31 < 0)
    operator delete(v30[0]);
  if (!v24)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v28 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v29 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_36;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v28 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v29 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_36:
    __cxa_throw(exception, v29, v28);
  }
  UnknownLocationImpl::~UnknownLocationImpl(*(UnknownLocationImpl **)(a1 + 72));
  return a1;
}

void sub_1E05ABFD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueLegacyStorageData<MIL::Fp16>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::LegacyStorageReader::IsEncrypted(*(MIL::Blob::MMapFileReader ***)(a1 + 72));
}

unint64_t MIL::IRValueLegacyStorageData<MIL::Fp16>::GetViewImpl(uint64_t a1)
{
  return MIL::Blob::LegacyStorageReader::GetDataView<MIL::Fp16>(*(MIL::Blob::MMapFileReader ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

uint64_t MIL::IRValueStorageData<MIL::Int4>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997808;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996778;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<MIL::Int4>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<MIL::Int4>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<MIL::Int4>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996778;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997808;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AC328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::Int4>::GetFilename(uint64_t a1)
{
  return MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<MIL::Int4>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

void MIL::IRValueStorageData<MIL::Int4>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  MIL::Blob::StorageReader::GetDataView<MIL::Int4>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AC408(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<signed char>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997858;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA9967C8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<signed char>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<signed char>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<signed char>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA9967C8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997858;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AC6E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<signed char>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<signed char>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::Blob::StorageReader::GetDataView<signed char>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AC7B8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<unsigned char>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA9978A8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996A98;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<unsigned char>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<unsigned char>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<unsigned char>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996A98;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA9978A8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05ACA90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<unsigned char>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<float>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA9978F8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA9966D8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<float>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<float>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<float>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA9966D8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA9978F8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05ACDD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<float>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<float>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::Blob::StorageReader::GetDataView<float>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05ACEA8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::Fp16>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997948;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA9965E8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<MIL::Fp16>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<MIL::Fp16>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<MIL::Fp16>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA9965E8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997948;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AD180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::Fp16>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<MIL::Fp16>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::Blob::StorageReader::GetDataView<MIL::Fp16>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AD258(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::Fp8E4M3FN>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997998;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996688;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<MIL::Fp8E4M3FN>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<MIL::Fp8E4M3FN>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<MIL::Fp8E4M3FN>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996688;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997998;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AD530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::Fp8E4M3FN>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<MIL::Fp8E4M3FN>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::Blob::StorageReader::GetDataView<MIL::Fp8E4M3FN>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AD608(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::Fp8E5M2>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA9979E8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996638;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<MIL::Fp8E5M2>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<MIL::Fp8E5M2>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<MIL::Fp8E5M2>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996638;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA9979E8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AD8E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::Fp8E5M2>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<MIL::Fp8E5M2>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::Blob::StorageReader::GetDataView<MIL::Fp8E5M2>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AD9B8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::Bf16>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997A38;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996598;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<MIL::Bf16>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<MIL::Bf16>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<MIL::Bf16>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996598;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997A38;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05ADC90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::Bf16>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<MIL::Bf16>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::Blob::StorageReader::GetDataView<MIL::Bf16>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05ADD68(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<short>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997A88;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996818;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<short>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<short>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<short>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996818;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997A88;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AE040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<short>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<short>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::Blob::StorageReader::GetDataView<short>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AE118(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::UInt1>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997AD8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996908;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<MIL::UInt1>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<MIL::UInt1>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<MIL::UInt1>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996908;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997AD8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AE3F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::UInt1>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

void MIL::IRValueStorageData<MIL::UInt1>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  MIL::Blob::StorageReader::GetDataView<MIL::UInt1>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AE4C8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::UInt2>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997B28;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996958;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<MIL::UInt2>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<MIL::UInt2>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<MIL::UInt2>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996958;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997B28;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AE7A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::UInt2>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

void MIL::IRValueStorageData<MIL::UInt2>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  MIL::Blob::StorageReader::GetDataView<MIL::UInt2>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AE878(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::UInt4>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997B78;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA9969F8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<MIL::UInt4>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<MIL::UInt4>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<MIL::UInt4>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA9969F8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997B78;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AEB50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<MIL::UInt4>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

void MIL::IRValueStorageData<MIL::UInt4>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  MIL::Blob::StorageReader::GetDataView<MIL::UInt4>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AEC28(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<unsigned short>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997BC8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996AE8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<unsigned short>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<unsigned short>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<unsigned short>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996AE8;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997BC8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AEF00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<unsigned short>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<unsigned short>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::Blob::StorageReader::GetDataView<unsigned short>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AEFD8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<int>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997C18;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996868;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<int>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<int>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<int>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996868;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997C18;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AF2B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<int>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<int>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::Blob::StorageReader::GetDataView<int>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AF388(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<unsigned int>::~IRValueStorageData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997C68;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996B38;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueStorageData<unsigned int>::~IRValueStorageData(uint64_t a1)
{
  MIL::IRValueStorageData<unsigned int>::~IRValueStorageData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueStorageData<unsigned int>::IRValueStorageData(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned __int8 *Filename;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  std::string::size_type size;
  int v16;
  std::string *p_p;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v24;
  BOOL v25;
  const char *v26;
  std::logic_error *exception;
  void (*v29)(void *);
  struct type_info *v30;
  void *v31[2];
  char v32;
  std::string __p;

  v9 = (_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = off_1EA996B38;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 8, a3);
  *(_BYTE *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)a1 = &off_1EA997C68;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "offset");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)(a1 + 88) = v10;
  *(_BYTE *)(a1 + 96) = a5;
  Filename = (unsigned __int8 *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  std::string::basic_string[abi:ne180100]<0>(v31, "path");
  v12 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v9, (unsigned __int8 *)v31);
  if (!v12)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v12 + 5), &__p);
  v13 = Filename[23];
  if ((v13 & 0x80u) == 0)
    v14 = Filename[23];
  else
    v14 = *((_QWORD *)Filename + 1);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v16 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (v14 != size)
  {
    v25 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((v13 & 0x80) != 0)
  {
    v25 = memcmp(*(const void **)Filename, p_p, *((_QWORD *)Filename + 1)) == 0;
    if ((v16 & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_30;
  }
  if (!Filename[23])
  {
    v25 = 1;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }
  v18 = v13 - 1;
  do
  {
    v20 = *Filename++;
    v19 = v20;
    v22 = p_p->__r_.__value_.__s.__data_[0];
    p_p = (std::string *)((char *)p_p + 1);
    v21 = v22;
    v24 = v18-- != 0;
    v25 = v19 == v21;
  }
  while (v19 == v21 && v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_30;
LABEL_22:
  if (v32 < 0)
    operator delete(v31[0]);
  if (!v25)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Storage and properties have different filenames.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE42A0];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E70];
    goto LABEL_38;
  }
  if (*(_QWORD *)(a1 + 32) != 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error((std::runtime_error *)exception, "Too many file properties provided.");
    v29 = (void (*)(void *))MEMORY[0x1E0DE4338];
    v30 = (struct type_info *)MEMORY[0x1E0DE4E80];
LABEL_38:
    __cxa_throw(exception, v30, v29);
  }
  if (!*(_BYTE *)(a1 + 96))
  {
    v26 = (const char *)MIL::Blob::StorageReader::GetFilename(*(MIL::Blob::StorageReader **)(a1 + 72));
  }
  return a1;
}

void sub_1E05AF660(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;

  __cxa_free_exception(v23);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v22);
  *(_QWORD *)v21 = v24;
  if (*(_BYTE *)(v21 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v20);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueStorageData<unsigned int>::UsesEncryptedFileStorage(uint64_t a1)
{
  return MIL::Blob::StorageReader::IsEncrypted(*(MIL::Blob::StorageReader **)(a1 + 72));
}

uint64_t MIL::IRValueStorageData<unsigned int>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::Blob::StorageReader::GetDataView<unsigned int>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
}

void sub_1E05AF738(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<signed char>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997CB8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA9967C8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<signed char>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<signed char>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<signed char>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997CB8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05AF860(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA9967C8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

void MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  __int128 v5;

  (*(void (**)(__int128 *__return_ptr, _QWORD, _QWORD))(**(_QWORD **)(a1 + 72) + 32))(&v5, *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 88));
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100](a1 + 120, &v5);
  v2 = (std::__shared_weak_count *)*((_QWORD *)&v5 + 1);
  if (*((_QWORD *)&v5 + 1))
  {
    v3 = (unint64_t *)(*((_QWORD *)&v5 + 1) + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

uint64_t MIL::IRValueConstExprOutputData<signed char>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<signed char>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<signed char>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<signed char>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<signed char>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<unsigned char>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997D08;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996A98;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<unsigned char>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<unsigned char>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned char>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997D08;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05AFA94(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996A98;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned char>::GetViewImpl(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(void **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<unsigned char>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned char>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<unsigned char>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<unsigned char>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<float>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997D58;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA9966D8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<float>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<float>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<float>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997D58;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05AFC48(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA9966D8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<float>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<float>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<float>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<float>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<float>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<double>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997DA8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996728;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<double>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<double>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<double>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997DA8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05AFDFC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996728;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<double>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<double>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<double>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<double>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<double>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp16>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997DF8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA9965E8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<MIL::Fp16>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<MIL::Fp16>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp16>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997DF8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05AFFB0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA9965E8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp16>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<MIL::Fp16>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp16>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<MIL::Fp16>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp16>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp8E4M3FN>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997E48;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996688;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<MIL::Fp8E4M3FN>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<MIL::Fp8E4M3FN>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp8E4M3FN>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997E48;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05B0164(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996688;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp8E4M3FN>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<MIL::Fp8E4M3FN>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp8E4M3FN>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<MIL::Fp8E4M3FN>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp8E4M3FN>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp8E5M2>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997E98;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996638;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<MIL::Fp8E5M2>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<MIL::Fp8E5M2>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp8E5M2>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997E98;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05B0318(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996638;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp8E5M2>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<MIL::Fp8E5M2>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp8E5M2>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<MIL::Fp8E5M2>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Fp8E5M2>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Bf16>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997EE8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996598;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<MIL::Bf16>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<MIL::Bf16>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Bf16>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997EE8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05B04CC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996598;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Bf16>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<MIL::Bf16>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Bf16>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<MIL::Bf16>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<MIL::Bf16>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<short>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997F38;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996818;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<short>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<short>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<short>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997F38;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05B0680(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996818;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<short>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<short>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<short>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<short>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<short>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<unsigned short>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997F88;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996AE8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<unsigned short>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<unsigned short>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned short>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997F88;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05B0834(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996AE8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned short>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<unsigned short>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned short>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<unsigned short>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<unsigned short>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<int>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA997FD8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996868;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<int>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<int>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<int>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA997FD8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05B09E8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996868;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<int>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<int>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<int>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<int>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<int>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<unsigned int>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA998028;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996B38;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<unsigned int>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<unsigned int>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned int>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA998028;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05B0B9C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996B38;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned int>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<unsigned int>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned int>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<unsigned int>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<unsigned int>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<long long>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA998078;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA9968B8;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<long long>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<long long>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<long long>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA998078;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05B0D50(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA9968B8;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<long long>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<long long>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<long long>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<long long>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<long long>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<unsigned long long>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA9980C8;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996B88;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<unsigned long long>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<unsigned long long>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned long long>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA9980C8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05B0F04(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996B88;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned long long>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<unsigned long long>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<unsigned long long>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<unsigned long long>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<unsigned long long>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

uint64_t MIL::IRValueConstExprOutputData<std::string>::~IRValueConstExprOutputData(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA998118;
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 120);
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 72);
  *(_QWORD *)a1 = off_1EA996548;
  if (*(_BYTE *)(a1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 8);
  return a1;
}

void MIL::IRValueConstExprOutputData<std::string>::~IRValueConstExprOutputData(uint64_t a1)
{
  MIL::IRValueConstExprOutputData<std::string>::~IRValueConstExprOutputData(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::IRValueConstExprOutputData<std::string>::IRValueConstExprOutputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  std::string *v6;
  __int128 v7;

  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &off_1EA998118;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)a3;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  v6 = (std::string *)(a1 + 96);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v7 = *a5;
    v6->__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_1E05B10B8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  *(_QWORD *)v1 = off_1EA996548;
  if (*(_BYTE *)(v1 + 48))
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRValueConstExprOutputData<std::string>::GetViewImpl(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 120);
  if (!v2)
  {
    MIL::IRValueConstExprOutputData<signed char>::EvaluateConstExpr(a1);
    v2 = *(uint64_t **)(a1 + 120);
  }
  return MIL::IRTensorValue::GetDataView<std::string>(v2);
}

uint64_t MIL::IRValueConstExprOutputData<std::string>::IsConstexprOutput()
{
  return 1;
}

void MIL::IRValueConstExprOutputData<std::string>::GetConstExprOutputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 112);
  }
}

uint64_t MIL::IRValueConstExprOutputData<std::string>::TryGetConstExprOutputName(uint64_t a1)
{
  return a1 + 96;
}

void MIL::IRValueStorageData<unsigned char>::GetViewImpl(uint64_t a1)
{
  std::runtime_error *exception;

  if (*(_BYTE *)(a1 + 96))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "This program was parsed specifying ignoreWeightFile, cannot fetch the data value.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  switch(MIL::Blob::StorageReader::GetDataType(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88)))
  {
    case 8u:
      MIL::Blob::StorageReader::GetDataView<MIL::Int4>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
      break;
    case 9u:
      MIL::Blob::StorageReader::GetDataView<MIL::UInt1>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
      break;
    case 0xAu:
      MIL::Blob::StorageReader::GetDataView<MIL::UInt2>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
      break;
    case 0xBu:
      MIL::Blob::StorageReader::GetDataView<MIL::UInt4>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
      break;
    case 0xCu:
      MIL::Blob::StorageReader::GetDataView<MIL::UInt3>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
      break;
    case 0xDu:
      MIL::Blob::StorageReader::GetDataView<MIL::UInt6>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
      break;
    default:
      MIL::Blob::StorageReader::GetDataView<unsigned char>(*(MIL::Blob::StorageReader::Impl ***)(a1 + 72), *(_QWORD *)(a1 + 88));
      break;
  }
}

void sub_1E05B1294(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRValueQueryable::IRValueQueryable(_QWORD *this)
{
  *this = off_1EA998940;
  return this;
}

_QWORD *MIL::IRDimension::IRDimension(_QWORD *this)
{
  *this = off_1EA9989A8;
  return this;
}

uint64_t MIL::IRDimension::AsConstant(MIL::IRDimension *this)
{
  uint64_t result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  result = (*(uint64_t (**)(MIL::IRDimension *))(*(_QWORD *)this + 16))(this);
  if (!result)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

uint64_t MIL::IRDimension::TryAsConstant(MIL::IRDimension *this)
{
  return 0;
}

uint64_t MIL::IRDimension::AsUnknown(MIL::IRDimension *this)
{
  uint64_t result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  result = (*(uint64_t (**)(MIL::IRDimension *))(*(_QWORD *)this + 24))(this);
  if (!result)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

uint64_t MIL::IRDimension::TryAsUnknown(MIL::IRDimension *this)
{
  return 0;
}

uint64_t MIL::IRDimension::IsVariadic(MIL::IRDimension *this)
{
  return 0;
}

const MIL::Text::SerializerOptions *MIL::IRConstantDimension::ToString(MIL::IRConstantDimension *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Dimension((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05B1408(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRConstantDimension::IRConstantDimension(_QWORD *this)
{
  *this = off_1EA9989E8;
  return this;
}

_QWORD *MIL::IRConstantDimension::Make@<X0>(MIL::IRConstantDimension *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  *result = &off_1EA998FB0;
  result[1] = this;
  *a2 = result;
  return result;
}

void MIL::IRUnknownDimension::~IRUnknownDimension(MIL::IRUnknownDimension *this)
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRUnknownDimension::IRUnknownDimension(_QWORD *this)
{
  *this = &off_1EA998A30;
  return this;
}

{
  *this = &off_1EA998A30;
  return this;
}

uint64_t MIL::IRUnknownDimension::Make@<X0>(MIL::IRUnknownDimension *this@<X0>, _QWORD *a2@<X8>)
{
  char v2;
  uint64_t result;

  v2 = (char)this;
  result = operator new();
  *(_QWORD *)result = &off_1EA999010;
  *(_BYTE *)(result + 8) = v2;
  *a2 = result;
  return result;
}

const MIL::Text::SerializerOptions *MIL::IRUnknownDimension::ToString(MIL::IRUnknownDimension *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Dimension((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05B15BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

void MIL::IRProperty::~IRProperty(MIL::IRProperty *this)
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRProperty::IRProperty(_QWORD *this)
{
  *this = &off_1EA998A70;
  return this;
}

{
  *this = &off_1EA998A70;
  return this;
}

void *MIL::IRProperty::AsConstant(MIL::IRProperty *this)
{
  void *result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  if (!this
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

void *MIL::IRProperty::TryAsConstant(void *this)
{
  if (this)
  return this;
}

void *MIL::IRProperty::AsUnknown(MIL::IRProperty *this)
{
  void *result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  if (!this
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

void *MIL::IRProperty::TryAsUnknown(void *this)
{
  if (this)
  return this;
}

const MIL::Text::SerializerOptions *MIL::IRProperty::ToString(MIL::IRProperty *this)
{
  MIL::IRConstantPropertyImpl **v2;
  MIL::IRUnknownProperty *v4;
  std::runtime_error *exception;

  if (!this)
    goto LABEL_6;
  if (v2)
    return MIL::IRConstantProperty::ToString(v2);
  if (!v4)
  {
LABEL_6:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Property type is not supported.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return MIL::IRUnknownProperty::ToString(v4);
}

void sub_1E05B17B4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const MIL::Text::SerializerOptions *MIL::IRConstantProperty::ToString(MIL::IRConstantPropertyImpl **this)
{
  double v2;
  int ScalarDataType;
  MIL::Text::BasicSerializer *v4;
  MIL::Text::BasicSerializer *v5;
  MIL::Text::BasicSerializer *v6;
  const MIL::Text::SerializerOptions *result;
  std::runtime_error *exception;
  _BYTE v9[392];
  const MIL::Text::SerializerOptions *v10;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v10);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v10 + 112))(v10, 4, v2);
  ScalarDataType = MIL::IRConstantPropertyImpl::GetScalarDataType(this[1]);
  switch(ScalarDataType)
  {
    case 12:
      MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v9, v10);
      v6 = MIL::Text::BasicSerializer::PropertyItem<long long>((MIL::Text::BasicSerializer *)v9, (MIL::IRProperty *)this);
      MIL::Text::BasicSerializer::GetOutput(v6);
      break;
    case 14:
      MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v9, v10);
      v5 = MIL::Text::BasicSerializer::PropertyItem<unsigned char>((MIL::Text::BasicSerializer *)v9, (MIL::IRProperty *)this);
      MIL::Text::BasicSerializer::GetOutput(v5);
      break;
    case 17:
      MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v9, v10);
      v4 = (MIL::Text::BasicSerializer *)MIL::Text::BasicSerializer::PropertyItem<unsigned long long>((uint64_t)v9, (MIL::IRConstantProperty *)this);
      MIL::Text::BasicSerializer::GetOutput(v4);
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Unsupported IRConstantProperty dtype for string conversion");
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v9);
  result = v10;
  v10 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05B18F0(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v4;

  __cxa_free_exception(v1);
  v4 = *(_QWORD *)(v2 - 40);
  *(_QWORD *)(v2 - 40) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

const MIL::Text::SerializerOptions *MIL::IRUnknownProperty::ToString(MIL::IRUnknownProperty *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::PropertyItem((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05B19D8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRConstantPropertyImpl::GetScalarDataType(MIL::IRConstantPropertyImpl *this)
{
  uint64_t v1;
  std::runtime_error *exception;

  v1 = *((int *)this + 2);
  if (v1 >= 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Found no property storage for this property.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return dword_1E0B01954[v1];
}

void sub_1E05B1A70(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRConstantPropertyImpl::GetValue<long long>(_DWORD *a1)
{
  std::logic_error *exception;

  if (!a1 || a1[2])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Requested datatype int64_t is unexpected here.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  return *(_QWORD *)a1;
}

void sub_1E05B1ADC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRConstantPropertyImpl::GetValue<unsigned char>(_DWORD *a1)
{
  std::logic_error *exception;

  if (!a1 || a1[2] != 1)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Requested datatype uint8_t is unexpected here.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  return *(_QWORD *)a1;
}

void sub_1E05B1B4C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRConstantPropertyImpl::GetValue<unsigned long long>(_DWORD *a1)
{
  std::logic_error *exception;

  if (!a1 || a1[2] != 2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Requested datatype uint64_t is unexpected here.");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  return *(_QWORD *)a1;
}

void sub_1E05B1BBC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRConstantProperty::IRConstantProperty(_QWORD *this)
{
  *this = &off_1EA998AA0;
  this[1] = 0;
  return this;
}

{
  *this = &off_1EA998AA0;
  this[1] = 0;
  return this;
}

void MIL::IRConstantProperty::~IRConstantProperty(MIL::IRConstantPropertyImpl **this)
{
  *this = (MIL::IRConstantPropertyImpl *)&off_1EA998AA0;
  std::unique_ptr<MIL::IRConstantPropertyImpl>::reset[abi:ne180100](this + 1, 0);
}

{
  *this = (MIL::IRConstantPropertyImpl *)&off_1EA998AA0;
  std::unique_ptr<MIL::IRConstantPropertyImpl>::reset[abi:ne180100](this + 1, 0);
}

{
  *this = (MIL::IRConstantPropertyImpl *)&off_1EA998AA0;
  std::unique_ptr<MIL::IRConstantPropertyImpl>::reset[abi:ne180100](this + 1, 0);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRConstantProperty::IRConstantProperty(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998AA0;
  result[1] = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998AA0;
  result[1] = v2;
  return result;
}

_QWORD *MIL::IRConstantProperty::Make<long long>@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *result;

  v4 = operator new();
  v5 = *a1;
  v6 = (_QWORD *)operator new();
  *v6 = v5;
  *(_QWORD *)v4 = v6;
  *(_DWORD *)(v4 + 8) = 0;
  result = (_QWORD *)operator new();
  *result = &off_1EA998AA0;
  result[1] = v4;
  *a2 = result;
  return result;
}

{
  return __ZN3MIL18IRConstantProperty4MakeIxEENSt3__110unique_ptrIKS0_NS2_14default_deleteIS4_EEEEOT_(a1, a2);
}

void sub_1E05B1D6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<MIL::IRConstantPropertyImpl>::reset[abi:ne180100]((MIL::IRConstantPropertyImpl **)va, 0);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRConstantProperty::Make<unsigned char>@<X0>(_BYTE *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _BYTE *v5;
  _QWORD *result;

  v4 = operator new();
  LOBYTE(a1) = *a1;
  v5 = (_BYTE *)operator new();
  *v5 = (_BYTE)a1;
  *(_QWORD *)v4 = v5;
  *(_DWORD *)(v4 + 8) = 1;
  result = (_QWORD *)operator new();
  *result = &off_1EA998AA0;
  result[1] = v4;
  *a2 = result;
  return result;
}

{
  return __ZN3MIL18IRConstantProperty4MakeIhEENSt3__110unique_ptrIKS0_NS2_14default_deleteIS4_EEEEOT_(a1, a2);
}

void sub_1E05B1E48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<MIL::IRConstantPropertyImpl>::reset[abi:ne180100]((MIL::IRConstantPropertyImpl **)va, 0);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRConstantProperty::Make<unsigned long long>@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *result;

  v4 = operator new();
  v5 = *a1;
  v6 = (_QWORD *)operator new();
  *v6 = v5;
  *(_QWORD *)v4 = v6;
  *(_DWORD *)(v4 + 8) = 2;
  result = (_QWORD *)operator new();
  *result = &off_1EA998AA0;
  result[1] = v4;
  *a2 = result;
  return result;
}

{
  return __ZN3MIL18IRConstantProperty4MakeIyEENSt3__110unique_ptrIKS0_NS2_14default_deleteIS4_EEEEOT_(a1, a2);
}

void sub_1E05B1F24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<MIL::IRConstantPropertyImpl>::reset[abi:ne180100]((MIL::IRConstantPropertyImpl **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRConstantProperty::GetScalarDataType(MIL::IRConstantPropertyImpl **this)
{
  return MIL::IRConstantPropertyImpl::GetScalarDataType(this[1]);
}

uint64_t MIL::IRConstantProperty::GetInt64ScalarValue(MIL::IRConstantProperty *this)
{
  return *(_QWORD *)MIL::IRConstantPropertyImpl::GetValue<long long>(*((_DWORD **)this + 1));
}

uint64_t MIL::IRConstantProperty::GetUInt8ScalarValue(MIL::IRConstantProperty *this)
{
  return *(unsigned __int8 *)MIL::IRConstantPropertyImpl::GetValue<unsigned char>(*((_DWORD **)this + 1));
}

uint64_t MIL::IRConstantProperty::GetUInt64ScalarValue(MIL::IRConstantProperty *this)
{
  return *(_QWORD *)MIL::IRConstantPropertyImpl::GetValue<unsigned long long>(*((_DWORD **)this + 1));
}

_QWORD *MIL::IRUnknownProperty::IRUnknownProperty(_QWORD *this)
{
  *this = &off_1EA998AC0;
  this[1] = 0;
  return this;
}

{
  *this = &off_1EA998AC0;
  this[1] = 0;
  return this;
}

void MIL::IRUnknownProperty::~IRUnknownProperty(MIL::IRUnknownProperty *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA998AC0;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0x1000C4077774924);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA998AC0;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0x1000C4077774924);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA998AC0;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0x1000C4077774924);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRUnknownProperty::IRUnknownProperty(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998AC0;
  result[1] = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998AC0;
  result[1] = v2;
  return result;
}

_QWORD *MIL::IRUnknownProperty::Make@<X0>(MIL::IRUnknownProperty *this@<X0>, _QWORD *a2@<X8>)
{
  char v2;
  _BYTE *v4;
  _QWORD *result;

  v2 = (char)this;
  v4 = (_BYTE *)operator new();
  *v4 = v2;
  result = (_QWORD *)operator new();
  *result = &off_1EA998AC0;
  result[1] = v4;
  *a2 = result;
  return result;
}

void sub_1E05B2160(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0x1000C4077774924);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRUnknownProperty::IsVariadic(MIL::IRUnknownProperty *this)
{
  return **((unsigned __int8 **)this + 1);
}

_QWORD *MIL::IRValueType::IRValueType(_QWORD *this)
{
  *this = off_1EA998AE0;
  return this;
}

uint64_t MIL::IRValueType::TryAsTensorType(MIL::IRValueType *this)
{
  return 0;
}

uint64_t MIL::IRValueType::AsTensorType(MIL::IRValueType *this)
{
  uint64_t result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  result = (*(uint64_t (**)(MIL::IRValueType *))(*(_QWORD *)this + 24))(this);
  if (!result)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

uint64_t MIL::IRValueType::TryAsListType(MIL::IRValueType *this)
{
  return 0;
}

uint64_t MIL::IRValueType::AsListType(MIL::IRValueType *this)
{
  uint64_t result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  result = (*(uint64_t (**)(MIL::IRValueType *))(*(_QWORD *)this + 32))(this);
  if (!result)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

uint64_t MIL::IRValueType::TryAsTupleType(MIL::IRValueType *this)
{
  return 0;
}

uint64_t MIL::IRValueType::AsTupleType(MIL::IRValueType *this)
{
  uint64_t result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  result = (*(uint64_t (**)(MIL::IRValueType *))(*(_QWORD *)this + 40))(this);
  if (!result)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

uint64_t MIL::IRValueType::TryAsDictionaryType(MIL::IRValueType *this)
{
  return 0;
}

uint64_t MIL::IRValueType::AsDictionaryType(MIL::IRValueType *this)
{
  uint64_t result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  result = (*(uint64_t (**)(MIL::IRValueType *))(*(_QWORD *)this + 48))(this);
  if (!result)
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

void *MIL::IRValueType::TryCastAsMemoryLayoutType(void *this)
{
  if (this)
  return this;
}

void *MIL::IRValueType::AsMemoryLayoutType(MIL::IRValueType *this)
{
  void *result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  if (!this
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

void *MIL::IRValueType::TryCastAsStateType(void *this)
{
  if (this)
  return this;
}

void *MIL::IRValueType::AsStateType(MIL::IRValueType *this)
{
  void *result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  if (!this
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

_QWORD *MIL::IRTensorValueType::IRTensorValueType(_QWORD *this)
{
  *this = off_1EA998B40;
  return this;
}

const MIL::Text::SerializerOptions *MIL::IRTensorValueType::ToString(MIL::IRTensorValueType *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Type((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05B2458(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTensorValueType::Make@<X0>(int a1@<W0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t result;

  v8 = operator new();
  *(_OWORD *)(v8 + 16) = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)v8 = &off_1EA999080;
  *(_DWORD *)(v8 + 8) = a1;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(v8 + 32, a3);
  *(_BYTE *)(v8 + 72) = result;
  *a4 = v8;
  return result;
}

void sub_1E05B2524(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v3);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2);
  MEMORY[0x1E0C023A0](v1, 0x10A1C40CDCF1773);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t a3)
{
  uint64_t v3;
  _OWORD v5[2];
  int v6;

  memset(v5, 0, sizeof(v5));
  v6 = 1065353216;
  v3 = MIL::IRTensorValueType::MakeWithShape(a1, a2, a3, (uint64_t *)v5);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v5);
  return v3;
}

void sub_1E05B25A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v14;
  std::__shared_weak_count *v15;

  v8 = operator new();
  *(_OWORD *)v8 = *(_OWORD *)a3;
  *(_QWORD *)(v8 + 16) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  std::shared_ptr<std::vector<MIL::IRDimension const*>>::shared_ptr[abi:ne180100]<std::vector<MIL::IRDimension const*>,void>(&v14, v8);
  v9 = MIL::IRTensorValueType::MakeWithShape(a1, a2, &v14, a4);
  v10 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return v9;
}

void sub_1E05B267C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorValueType::Make(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, MIL::MILContext ***a3)
{
  MIL::MILContext **v6;
  MIL::MILContext **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  void *__p;
  uint64_t *v23;
  uint64_t *v24;

  __p = 0;
  v23 = 0;
  v24 = 0;
  std::vector<std::string const*>::reserve(&__p, a3[1] - *a3);
  v6 = *a3;
  v7 = a3[1];
  if (*a3 != v7)
  {
    do
    {
      v8 = MIL::IRConstantDimension::Make(a1, *v6);
      v9 = v8;
      v10 = v23;
      if (v23 >= v24)
      {
        v12 = ((char *)v23 - (_BYTE *)__p) >> 3;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v13 = ((char *)v24 - (_BYTE *)__p) >> 2;
        if (v13 <= v12 + 1)
          v13 = v12 + 1;
        if ((unint64_t)((char *)v24 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v13;
        if (v14)
          v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v24, v14);
        else
          v15 = 0;
        v16 = (uint64_t *)&v15[8 * v12];
        *v16 = v9;
        v11 = v16 + 1;
        v18 = (char *)__p;
        v17 = (char *)v23;
        if (v23 != __p)
        {
          do
          {
            v19 = *((_QWORD *)v17 - 1);
            v17 -= 8;
            *--v16 = v19;
          }
          while (v17 != v18);
          v17 = (char *)__p;
        }
        __p = v16;
        v23 = v11;
        v24 = (uint64_t *)&v15[8 * v14];
        if (v17)
          operator delete(v17);
      }
      else
      {
        *v23 = v8;
        v11 = v10 + 1;
      }
      v23 = v11;
      ++v6;
    }
    while (v6 != v7);
  }
  v20 = MIL::IRTensorValueType::MakeWithShape(a1, a2, (uint64_t)&__p);
  if (__p)
  {
    v23 = (uint64_t *)__p;
    operator delete(__p);
  }
  return v20;
}

void sub_1E05B2804(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTensorValueType::MakeScalar(void (***a1)(MIL::MILContextImpl *__hidden this), int a2)
{
  uint64_t v2;
  void *__p[3];

  memset(__p, 0, sizeof(__p));
  v2 = MIL::IRTensorValueType::MakeWithShape(a1, a2, (uint64_t)__p);
  if (__p[0])
    operator delete(__p[0]);
  return v2;
}

void sub_1E05B286C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTensorValueType::MakeBFloat16Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::Bf16>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B28DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

void MIL::IRTensorValueType::MakeBFloat16Value(uint64_t a1@<X0>, float **a2@<X1>, _QWORD *a3@<X8>)
{
  MIL::Bf16 *v6;
  float *v7;
  float *v8;
  _WORD *v9;
  void *__p[3];

  v6 = (MIL::Bf16 *)std::vector<MIL::Bf16>::vector(__p, a2[1] - *a2);
  v8 = *a2;
  v7 = a2[1];
  if (v8 != v7)
  {
    v9 = __p[0];
    do
    {
      v6 = (MIL::Bf16 *)MIL::Bf16::FromFloat(v6, *v8);
      *v9++ = (_WORD)v6;
      ++v8;
    }
    while (v8 != v7);
  }
  MIL::IRTensorValueType::MakeBFloat16Value(a1, (uint64_t)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1E05B2998(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeFloat8E5M2Value(uint64_t a1@<X0>, float **a2@<X1>, _QWORD *a3@<X8>)
{
  MIL::Fp8E5M2 *v6;
  float *v7;
  float *v8;
  _BYTE *v9;
  void *__p[3];

  v6 = (MIL::Fp8E5M2 *)std::vector<MIL::Fp8E5M2>::vector(__p, a2[1] - *a2);
  v8 = *a2;
  v7 = a2[1];
  if (v8 != v7)
  {
    v9 = __p[0];
    do
    {
      v6 = (MIL::Fp8E5M2 *)MIL::Fp8E5M2::FromFloat(v6, *v8);
      *v9++ = (_BYTE)v6;
      ++v8;
    }
    while (v8 != v7);
  }
  MIL::IRTensorValueType::MakeFloat8E5M2Value(a1, (uint64_t)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1E05B2A50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTensorValueType::MakeFloat8E5M2Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::Fp8E5M2>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B2AC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

void MIL::IRTensorValueType::MakeFloat8E4M3FNValue(uint64_t a1@<X0>, float **a2@<X1>, _QWORD *a3@<X8>)
{
  MIL::Fp8E4M3FN *v6;
  float *v7;
  float *v8;
  _BYTE *v9;
  void *__p[3];

  v6 = (MIL::Fp8E4M3FN *)std::vector<MIL::Fp8E4M3FN>::vector(__p, a2[1] - *a2);
  v8 = *a2;
  v7 = a2[1];
  if (v8 != v7)
  {
    v9 = __p[0];
    do
    {
      v6 = (MIL::Fp8E4M3FN *)MIL::Fp8E4M3FN::FromFloat(v6, *v8);
      *v9++ = (_BYTE)v6;
      ++v8;
    }
    while (v8 != v7);
  }
  MIL::IRTensorValueType::MakeFloat8E4M3FNValue(a1, (uint64_t)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1E05B2B84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTensorValueType::MakeFloat8E4M3FNValue@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B2BFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeFloat16Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::Fp16>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B2C78(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

void MIL::IRTensorValueType::MakeFloat16Value(uint64_t a1@<X0>, float **a2@<X1>, _QWORD *a3@<X8>)
{
  MIL::Fp16 *v6;
  float *v7;
  float *v8;
  _WORD *v9;
  void *__p[3];

  v6 = (MIL::Fp16 *)std::vector<MIL::Fp16>::vector(__p, a2[1] - *a2);
  v8 = *a2;
  v7 = a2[1];
  if (v8 != v7)
  {
    v9 = __p[0];
    do
    {
      v6 = (MIL::Fp16 *)MIL::Fp16::FromFloat(v6, *v8);
      *v9++ = (_WORD)v6;
      ++v8;
    }
    while (v8 != v7);
  }
  MIL::IRTensorValueType::MakeFloat16Value(a1, (uint64_t)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1E05B2D34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTensorValueType::MakeFloat32Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<float>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B2DAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeFloat64Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<double>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B2E28(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeBoolValue@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B2EA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

void MIL::IRTensorValueType::MakeBoolValue(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  size_t v5;
  _QWORD *v6;
  _QWORD *v7;
  void *__p;
  void *v9;
  uint64_t v10;

  v6 = *(_QWORD **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v9 = 0;
  v10 = 0;
  __p = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,true,0ul>,std::__bit_iterator<std::vector<BOOL>,true,0ul>>(&__p, v6, 0, &v6[v5 >> 6], v5 & 0x3F, v5);
  v7 = (_QWORD *)operator new();
  MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue(v7, a1, (uint64_t)&__p);
  *a3 = v7;
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
}

void sub_1E05B2F5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v11;

  MEMORY[0x1E0C023A0](v11, 0xE1C40243CB742);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeInt4Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::Int4>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B2FF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt6Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::UInt6>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B306C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt4Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::UInt4>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B30E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt3Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::UInt3>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B3164(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt2Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::UInt2>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B31E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt1Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::UInt1>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B325C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt8Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<unsigned char>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B32D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt16Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<unsigned short>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B3354(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt32Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<unsigned int>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B33D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt64Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<unsigned long long>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B344C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeInt8Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<signed char>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B34C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeInt16Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<short>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B3544(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeInt32Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<int>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B35C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeInt64Value@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<long long>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B363C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeStringValue@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<std::string>::IRTypedTensorValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05B36B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeBoolValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  if (a3)
    v7 = a2;
  else
    v7 = 0;
  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue(v8, a1, v7, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B3748(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt8ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<unsigned char>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B37D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt16ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<unsigned short>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B3860(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt32ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<unsigned int>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B38EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt64ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<unsigned long long>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B3978(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeInt4ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *result;
  std::runtime_error *exception;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1) != 13)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  v8 = ((a3 >> 1) & 0x1FFFFFFFFFFFFFFFLL) + (a3 & 1);
  if (v8)
    v9 = a2;
  else
    v9 = 0;
  v10 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::Int4>::IRTypedTensorValue(v10, a1, v9, v8);
  *a4 = v10;
  return result;
}

void sub_1E05B3A58(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt6ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *result;
  std::runtime_error *exception;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1) != 23)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  if (((6 * a3) & 6) != 0)
    v8 = (((unint64_t)(3 * a3) >> 2) & 0x1FFFFFFFFFFFFFFFLL) + 1;
  else
    v8 = ((unint64_t)(3 * a3) >> 2) & 0x1FFFFFFFFFFFFFFFLL;
  if (v8)
    v9 = a2;
  else
    v9 = 0;
  v10 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::UInt6>::IRTypedTensorValue(v10, a1, v9, v8);
  *a4 = v10;
  return result;
}

void sub_1E05B3B54(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt4ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *result;
  std::runtime_error *exception;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1) != 20)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  v8 = ((a3 >> 1) & 0x1FFFFFFFFFFFFFFFLL) + (a3 & 1);
  if (v8)
    v9 = a2;
  else
    v9 = 0;
  v10 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::UInt4>::IRTypedTensorValue(v10, a1, v9, v8);
  *a4 = v10;
  return result;
}

void sub_1E05B3C44(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt3ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *result;
  std::runtime_error *exception;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1) != 22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  if (((3 * a3) & 7) != 0)
    v8 = ((unint64_t)(3 * a3) >> 3) + 1;
  else
    v8 = (unint64_t)(3 * a3) >> 3;
  if (v8)
    v9 = a2;
  else
    v9 = 0;
  v10 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::UInt3>::IRTypedTensorValue(v10, a1, v9, v8);
  *a4 = v10;
  return result;
}

void sub_1E05B3D3C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt2ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *result;
  std::runtime_error *exception;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1) != 19)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  if ((a3 & 3) != 0)
    v8 = ((a3 >> 2) & 0x1FFFFFFFFFFFFFFFLL) + 1;
  else
    v8 = (a3 >> 2) & 0x1FFFFFFFFFFFFFFFLL;
  if (v8)
    v9 = a2;
  else
    v9 = 0;
  v10 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::UInt2>::IRTypedTensorValue(v10, a1, v9, v8);
  *a4 = v10;
  return result;
}

void sub_1E05B3E30(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeUInt1ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *result;
  std::runtime_error *exception;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1) != 21)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot initialize tensor value from value with wrong type.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  if ((a3 & 7) != 0)
    v8 = (a3 >> 3) + 1;
  else
    v8 = a3 >> 3;
  if (v8)
    v9 = a2;
  else
    v9 = 0;
  v10 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::UInt1>::IRTypedTensorValue(v10, a1, v9, v8);
  *a4 = v10;
  return result;
}

void sub_1E05B3F24(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeInt8ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<signed char>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B3FC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeInt16ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<short>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B404C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeInt32ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<int>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B40D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeInt64ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<long long>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B4164(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeStringValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<std::string>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B41F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeFloat8E5M2ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::Fp8E5M2>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B427C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeFloat8E4M3FNValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::Fp8E4M3FN>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B4308(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeBFloat16ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::Bf16>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B4394(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeFloat16ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<MIL::Fp16>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B4420(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeFloat32ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<float>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B44AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorValueType::MakeFloat64ValueWithUnownedMemory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = (_QWORD *)operator new();
  result = MIL::IRTypedTensorValue<double>::IRTypedTensorValue(v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1E05B4538(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

void MIL::IRTensorValueType::MakeValueFromFileProperties(std::string::size_type a1, uint64_t a2, _QWORD *a3)
{
  MIL::IRTensorValueType::MakeValueFromFileProperties(a1, a2, a3, 0);
}

void MIL::IRTensorValueType::MakeValueFromFileProperties(std::string::size_type a1, uint64_t a2, _QWORD *a3, char a4)
{
  unsigned __int8 *v6;
  char *v8;
  BOOL v9;
  std::string *v10;
  int v11;
  std::runtime_error *v12;
  std::runtime_error *exception;
  std::string v14;
  char v15;
  std::string __p;

  v15 = a4;
  std::string::basic_string[abi:ne180100]<0>(&__p, "type");
  v6 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(a3, (unsigned __int8 *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (!v6)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "File type property missing");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  MIL::IRValue::GetScalar<std::string>(*((const void **)v6 + 5), &v14);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
  {
    if (v14.__r_.__value_.__l.__size_ != 8)
    {
      if (v14.__r_.__value_.__l.__size_ != 14
        || (*(_QWORD *)v14.__r_.__value_.__l.__data_ == 0x4C4259434147454CLL
          ? (v9 = *(_QWORD *)(v14.__r_.__value_.__r.__words[0] + 6) == 0x454C4946424F4C42)
          : (v9 = 0),
            !v9))
      {
LABEL_26:
        v12 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::operator+<char>();
        std::runtime_error::runtime_error(v12, &__p);
        __cxa_throw(v12, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
      }
LABEL_12:
      v8 = (char *)&loc_1E05B464C
         + 4 * word_1E0B01368[(*(unsigned int (**)(std::string::size_type))(*(_QWORD *)a1 + 88))(a1) - 2];
      __asm { BR              X10 }
    }
    v10 = (std::string *)v14.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (HIBYTE(v14.__r_.__value_.__r.__words[2]) != 8)
    {
      if (HIBYTE(v14.__r_.__value_.__r.__words[2]) != 14)
        goto LABEL_26;
      if (v14.__r_.__value_.__r.__words[0] != 0x4C4259434147454CLL
        || *(std::string::size_type *)((char *)v14.__r_.__value_.__r.__words + 6) != 0x454C4946424F4C42)
      {
        goto LABEL_26;
      }
      goto LABEL_12;
    }
    v10 = &v14;
  }
  if (v10->__r_.__value_.__r.__words[0] != 0x454C4946424F4C42)
    goto LABEL_26;
  v11 = (*(uint64_t (**)(std::string::size_type))(*(_QWORD *)a1 + 88))(a1);
  __p.__r_.__value_.__r.__words[0] = a1;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
}

void sub_1E05B4A20()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "cannot dispatch on type");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B4A54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(19, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B4B20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(20, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B4BEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(21, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B4CB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(22, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B4D84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(23, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B4E50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(24, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B4F1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(25, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B4FE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(2, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B50B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(3, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B5180(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(6, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B524C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(7, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B5318(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(9, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B53E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(10, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B54B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(11, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B557C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(12, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B5648(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(13, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B5714(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(14, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B57E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(15, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B58AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(16, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B5978(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, std::string *a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,_QWORD *a24,size_t a25,int a26,__int16 a27,char a28,unsigned __int8 a29)
{
  std::runtime_error *exception;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;

  MIL::IRDataTypeToString(17, &a24);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a29 & 0x80u) == 0)
    v30 = a29;
  else
    v30 = a25;
  v31 = &a18;
  std::string::basic_string[abi:ne180100]((uint64_t)&a18, v30 + 58);
  if (a23 < 0)
    v31 = a18;
  if (v30)
  {
    if ((a29 & 0x80u) == 0)
      v32 = &a24;
    else
      v32 = a24;
    memmove(v31, v32, v30);
  }
  strcpy((char *)v31 + v30, " is not a supported data type for legacy blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a18);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B5A74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  void *v29;
  int v30;

  if (a23 < 0)
  {
    operator delete(__p);
    if ((v30 & 1) == 0)
    {
LABEL_6:
      if (a29 < 0)
        operator delete(a24);
      if (a14 < 0)
        operator delete(a9);
      _Unwind_Resume(a1);
    }
  }
  else if (!v30)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v29);
  goto LABEL_6;
}

void MIL::Util::DispatchToCppType<std::unique_ptr<MIL::IRTensorValue const>,`anonymous namespace'::MakeValueHelper_Blob,MIL::IRTensorValueType const*,MIL::MILContext &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>,BOOL &>(int a1)
{
  __asm { BR              X10 }
}

void sub_1E05B5D94(int a1, uint64_t *a2, int a3, int a4, unsigned __int8 *a5, int a6, int a7, int a8, __int128 a9, __int128 __p, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  uint64_t *v28;
  _QWORD *v29;
  void (***v30)(MIL::MILContextImpl *__hidden);
  uint64_t v31;
  int v32;
  unsigned __int8 *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  __int128 v43;
  __int128 v44;
  char v45;
  std::string v46[3];

  v31 = *a2;
  v32 = *a5;
  std::string::basic_string[abi:ne180100]<0>(&v44, "path");
  v33 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v29, (unsigned __int8 *)&v44);
  if (!v33)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  MIL::IRValue::GetScalar<std::string>(*((const void **)v33 + 5), v46);
  if (v45 < 0)
    operator delete((void *)v44);
  if (*v30 != &off_1EA999688)
    __cxa_bad_cast();
  MIL::MILContextImpl::GetOrCreateStorageReader((uint64_t)v30, (unsigned __int8 *)v46, (std::string::size_type *)&v43);
  v34 = operator new();
  v44 = v43;
  v43 = 0uLL;
  ((void (*)(uint64_t, uint64_t, _QWORD *, __int128 *, BOOL))MIL::IRValueStorageData<MIL::Fp16>::IRValueStorageData)(v34, v31, v29, &v44, v32 != 0);
  v35 = (std::__shared_weak_count *)*((_QWORD *)&v44 + 1);
  if (*((_QWORD *)&v44 + 1))
  {
    v36 = (unint64_t *)(*((_QWORD *)&v44 + 1) + 8);
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = operator new();
  *(_QWORD *)&v44 = v34;
  ((void (*)(uint64_t, uint64_t, __int128 *))MIL::IRTypedTensorValue<MIL::Fp16>::IRTypedTensorValue)(v38, v31, &v44);
  v39 = v44;
  *(_QWORD *)&v44 = 0;
  if (v39)
    (*(void (**)(uint64_t))(*(_QWORD *)v39 + 8))(v39);
  *v28 = v38;
  v40 = (std::__shared_weak_count *)*((_QWORD *)&v43 + 1);
  if (*((_QWORD *)&v43 + 1))
  {
    v41 = (unint64_t *)(*((_QWORD *)&v43 + 1) + 8);
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  if (SHIBYTE(v46[0].__r_.__value_.__r.__words[2]) < 0)
    operator delete(v46[0].__r_.__value_.__l.__data_);
}

void sub_1E05B7578(uint64_t a1, uint64_t a2, std::string *a3, uint64_t a4, uint64_t a5, int a6, __int16 a7, char a8, char a9, uint64_t a10, _QWORD *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, _QWORD *a17, size_t a18, int a19, __int16 a20,char a21,unsigned __int8 a22)
{
  std::runtime_error *exception;
  size_t v23;
  _QWORD *v24;
  _QWORD *v25;

  MIL::IRDataTypeToString(2, &a17);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a22 & 0x80u) == 0)
    v23 = a22;
  else
    v23 = a18;
  v24 = &a11;
  std::string::basic_string[abi:ne180100]((uint64_t)&a11, v23 + 51);
  if (a16 < 0)
    v24 = a11;
  if (v23)
  {
    if ((a22 & 0x80u) == 0)
      v25 = &a17;
    else
      v25 = a17;
    memmove(v24, v25, v23);
  }
  strcpy((char *)v24 + v23, " is not a supported data type for blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a11);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B7648(uint64_t a1, uint64_t a2, std::string *a3, uint64_t a4, uint64_t a5, int a6, __int16 a7, char a8, char a9, uint64_t a10, _QWORD *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, _QWORD *a17, size_t a18, int a19, __int16 a20,char a21,unsigned __int8 a22)
{
  std::runtime_error *exception;
  size_t v23;
  _QWORD *v24;
  _QWORD *v25;

  MIL::IRDataTypeToString(3, &a17);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a22 & 0x80u) == 0)
    v23 = a22;
  else
    v23 = a18;
  v24 = &a11;
  std::string::basic_string[abi:ne180100]((uint64_t)&a11, v23 + 51);
  if (a16 < 0)
    v24 = a11;
  if (v23)
  {
    if ((a22 & 0x80u) == 0)
      v25 = &a17;
    else
      v25 = a17;
    memmove(v24, v25, v23);
  }
  strcpy((char *)v24 + v23, " is not a supported data type for blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a11);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B7718(uint64_t a1, uint64_t a2, std::string *a3, uint64_t a4, uint64_t a5, int a6, __int16 a7, char a8, char a9, uint64_t a10, _QWORD *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, _QWORD *a17, size_t a18, int a19, __int16 a20,char a21,unsigned __int8 a22)
{
  std::runtime_error *exception;
  size_t v23;
  _QWORD *v24;
  _QWORD *v25;

  MIL::IRDataTypeToString(6, &a17);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a22 & 0x80u) == 0)
    v23 = a22;
  else
    v23 = a18;
  v24 = &a11;
  std::string::basic_string[abi:ne180100]((uint64_t)&a11, v23 + 51);
  if (a16 < 0)
    v24 = a11;
  if (v23)
  {
    if ((a22 & 0x80u) == 0)
      v25 = &a17;
    else
      v25 = a17;
    memmove(v24, v25, v23);
  }
  strcpy((char *)v24 + v23, " is not a supported data type for blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a11);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B77E8(uint64_t a1, uint64_t a2, std::string *a3, uint64_t a4, uint64_t a5, int a6, __int16 a7, char a8, char a9, uint64_t a10, _QWORD *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, _QWORD *a17, size_t a18, int a19, __int16 a20,char a21,unsigned __int8 a22)
{
  std::runtime_error *exception;
  size_t v23;
  _QWORD *v24;
  _QWORD *v25;

  MIL::IRDataTypeToString(12, &a17);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a22 & 0x80u) == 0)
    v23 = a22;
  else
    v23 = a18;
  v24 = &a11;
  std::string::basic_string[abi:ne180100]((uint64_t)&a11, v23 + 51);
  if (a16 < 0)
    v24 = a11;
  if (v23)
  {
    if ((a22 & 0x80u) == 0)
      v25 = &a17;
    else
      v25 = a17;
    memmove(v24, v25, v23);
  }
  strcpy((char *)v24 + v23, " is not a supported data type for blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a11);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B78B8(uint64_t a1, uint64_t a2, std::string *a3, uint64_t a4, uint64_t a5, int a6, __int16 a7, char a8, char a9, uint64_t a10, _QWORD *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, _QWORD *a17, size_t a18, int a19, __int16 a20,char a21,unsigned __int8 a22)
{
  std::runtime_error *exception;
  size_t v23;
  _QWORD *v24;
  _QWORD *v25;

  MIL::IRDataTypeToString(17, &a17);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  if ((a22 & 0x80u) == 0)
    v23 = a22;
  else
    v23 = a18;
  v24 = &a11;
  std::string::basic_string[abi:ne180100]((uint64_t)&a11, v23 + 51);
  if (a16 < 0)
    v24 = a11;
  if (v23)
  {
    if ((a22 & 0x80u) == 0)
      v25 = &a17;
    else
      v25 = a17;
    memmove(v24, v25, v23);
  }
  strcpy((char *)v24 + v23, " is not a supported data type for blob file values.");
  std::runtime_error::runtime_error(exception, (const std::string *)&a11);
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B7988()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "cannot dispatch on type");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05B79B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorValueType::MakeValueFromLegacyBlobFile(std::string::size_type a1, void (***a2)(MIL::MILContextImpl *__hidden this), uint64_t a3, const MIL::IRTensorValueType *a4)
{
  _anonymous_namespace_ *Scalar;
  unsigned __int8 *v9;
  uint64_t v10;
  _anonymous_namespace_ *v11;
  unsigned __int8 *v12;
  uint64_t v13;
  MIL::IRTensorValueType *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  std::string v18;
  void *__p[2];
  char v20;
  void *v21[2];
  char v22;
  uint64_t v23;
  _OWORD v24[2];
  int v25;
  void **v26;

  memset(v24, 0, sizeof(v24));
  v25 = 1065353216;
  Scalar = (_anonymous_namespace_ *)MIL::IRTensorValueType::MakeScalar(a2, 3);
  std::string::basic_string[abi:ne180100]<0>(v21, "LEGACYBLOBFILE");
  MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)v21, &v23);
  std::string::basic_string[abi:ne180100]<0>(__p, "type");
  v26 = __p;
  v9 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)v24, (unsigned __int8 *)__p, (uint64_t)&std::piecewise_construct, (__int128 **)&v26);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>((_QWORD *)v9 + 5, &v23);
  if (v20 < 0)
    operator delete(__p[0]);
  v10 = v23;
  v23 = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  if (v22 < 0)
    operator delete(v21[0]);
  v11 = (_anonymous_namespace_ *)MIL::IRTensorValueType::MakeScalar(a2, 3);
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v18, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v18 = *(std::string *)a3;
  MIL::IRTensorValueType::MakeStringValue(v11, (const MIL::IRTensorValueType *)&v18, &v23);
  std::string::basic_string[abi:ne180100]<0>(__p, "path");
  v26 = __p;
  v12 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)v24, (unsigned __int8 *)__p, (uint64_t)&std::piecewise_construct, (__int128 **)&v26);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>((_QWORD *)v12 + 5, &v23);
  if (v20 < 0)
    operator delete(__p[0]);
  v13 = v23;
  v23 = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
  v14 = (MIL::IRTensorValueType *)MIL::IRTensorValueType::MakeScalar(a2, 17);
  MIL::IRTensorValueType::MakeUInt64Value(v14, a4, &v23);
  std::string::basic_string[abi:ne180100]<0>(__p, "identifier");
  v26 = __p;
  v15 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)v24, (unsigned __int8 *)__p, (uint64_t)&std::piecewise_construct, (__int128 **)&v26);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>((_QWORD *)v15 + 5, &v23);
  if (v20 < 0)
    operator delete(__p[0]);
  v16 = v23;
  v23 = 0;
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  MIL::IRTensorValueType::MakeValueFromFileProperties(a1, (uint64_t)a2, v24, 0);
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v24);
}

void sub_1E05B87E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,char a28)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a28);
  _Unwind_Resume(a1);
}

void MIL::IRTensorValueType::MakeStringValue(_anonymous_namespace_ *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  std::string *v6;
  std::string *v7;
  std::string *v8;
  std::string **v9;
  char v10;
  void *__p[2];
  uint64_t v12;
  __int128 v13;

  *(_QWORD *)&v13 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)__p = *(_OWORD *)a2;
  v12 = *((_QWORD *)a2 + 2);
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  v7 = 0;
  v8 = 0;
  v6 = 0;
  v9 = &v6;
  v10 = 0;
  v6 = (std::string *)operator new(0x18uLL);
  v7 = v6;
  v8 = v6 + 1;
  v7 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((uint64_t)&v8, (__int128 *)__p, &v13, v6);
  MIL::IRTensorValueType::MakeStringValue((uint64_t)a1, (uint64_t)&v6, a3);
  v9 = &v6;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v9);
  if (SHIBYTE(v12) < 0)
    operator delete(__p[0]);
}

void sub_1E05B89CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  if (*a2)
  {
    v5 = (_QWORD *)operator new();
    v6 = *a2;
    *v5 = &unk_1EA992A68;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  *a2 = 0;
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void MIL::IRTensorValueType::MakeUInt64Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  void *__p;
  void *v8;
  _QWORD *v9;

  v6 = operator new(8uLL);
  __p = v6;
  *v6 = a2;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeUInt64Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05B8B20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTensorValueType::MakeValueFromBlobFile(std::string::size_type a1, void (***a2)(MIL::MILContextImpl *__hidden this), uint64_t a3, const MIL::IRTensorValueType *a4)
{
  return MIL::IRTensorValueType::MakeValueFromBlobFile(a1, a2, a3, a4, 0);
}

uint64_t MIL::IRTensorValueType::MakeValueFromBlobFile(std::string::size_type a1, void (***a2)(MIL::MILContextImpl *__hidden this), uint64_t a3, const MIL::IRTensorValueType *a4, char a5)
{
  _anonymous_namespace_ *Scalar;
  unsigned __int8 *v11;
  uint64_t v12;
  _anonymous_namespace_ *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  MIL::IRTensorValueType *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  std::string v20;
  void *__p[2];
  char v22;
  void *v23[2];
  char v24;
  uint64_t v25;
  _OWORD v26[2];
  int v27;
  void **v28;

  memset(v26, 0, sizeof(v26));
  v27 = 1065353216;
  Scalar = (_anonymous_namespace_ *)MIL::IRTensorValueType::MakeScalar(a2, 3);
  std::string::basic_string[abi:ne180100]<0>(v23, "BLOBFILE");
  MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)v23, &v25);
  std::string::basic_string[abi:ne180100]<0>(__p, "type");
  v28 = __p;
  v11 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)v26, (unsigned __int8 *)__p, (uint64_t)&std::piecewise_construct, (__int128 **)&v28);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>((_QWORD *)v11 + 5, &v25);
  if (v22 < 0)
    operator delete(__p[0]);
  v12 = v25;
  v25 = 0;
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  if (v24 < 0)
    operator delete(v23[0]);
  v13 = (_anonymous_namespace_ *)MIL::IRTensorValueType::MakeScalar(a2, 3);
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v20 = *(std::string *)a3;
  MIL::IRTensorValueType::MakeStringValue(v13, (const MIL::IRTensorValueType *)&v20, &v25);
  std::string::basic_string[abi:ne180100]<0>(__p, "path");
  v28 = __p;
  v14 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)v26, (unsigned __int8 *)__p, (uint64_t)&std::piecewise_construct, (__int128 **)&v28);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>((_QWORD *)v14 + 5, &v25);
  if (v22 < 0)
    operator delete(__p[0]);
  v15 = v25;
  v25 = 0;
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v20.__r_.__value_.__l.__data_);
  v16 = (MIL::IRTensorValueType *)MIL::IRTensorValueType::MakeScalar(a2, 17);
  MIL::IRTensorValueType::MakeUInt64Value(v16, a4, &v25);
  std::string::basic_string[abi:ne180100]<0>(__p, "offset");
  v28 = __p;
  v17 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)v26, (unsigned __int8 *)__p, (uint64_t)&std::piecewise_construct, (__int128 **)&v28);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>((_QWORD *)v17 + 5, &v25);
  if (v22 < 0)
    operator delete(__p[0]);
  v18 = v25;
  v25 = 0;
  if (v18)
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
  MIL::IRTensorValueType::MakeValueFromFileProperties(a1, (uint64_t)a2, v26, a5);
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v26);
}

void sub_1E05B8DAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,char a28)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a28);
  _Unwind_Resume(a1);
}

std::__shared_weak_count_vtbl *MIL::IRTensorValueType::MakeValueFromConstExprEvaluation(uint64_t a1, std::__shared_weak_count_vtbl **a2)
{
  std::__shared_weak_count_vtbl *v3;
  std::__shared_weak_count_vtbl *result;
  void *__p[2];
  char v6;
  std::__shared_weak_count_vtbl *v7;

  v3 = *a2;
  *a2 = 0;
  v7 = v3;
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  MIL::IRTensorValueType::MakeValueFromConstExprEvaluation(a1, &v7, (uint64_t)__p);
  if (v6 < 0)
    operator delete(__p[0]);
  result = v7;
  if (v7)
    return (std::__shared_weak_count_vtbl *)(*((uint64_t (**)(std::__shared_weak_count_vtbl *))v7->~__shared_weak_count
                                             + 1))(v7);
  return result;
}

void sub_1E05B8F24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0)
    operator delete(__p);
  if (a15)
    (*(void (**)(uint64_t))(*(_QWORD *)a15 + 8))(a15);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeValueFromConstExprEvaluation(uint64_t a1, std::__shared_weak_count_vtbl **a2, uint64_t a3)
{
  std::__shared_weak_count *v6;
  std::__shared_weak_count_vtbl *v7;
  int v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::string __p;
  std::__shared_weak_count *v14;
  uint64_t v15;
  uint64_t v16;

  if (*a2)
  {
    v6 = (std::__shared_weak_count *)operator new();
    v7 = *a2;
    v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA999190;
    v6->__shared_owners_ = 0;
    v6->__shared_weak_owners_ = 0;
    v6[1].__vftable = v7;
  }
  else
  {
    v6 = 0;
  }
  v14 = v6;
  *a2 = 0;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    __p = *(std::string *)a3;
  v16 = 0;
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
  v15 = a1;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v9 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_1E05B9084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void MIL::IRTensorValueType::MakeValueFromConstExprEvaluation(uint64_t a1)
{
  int v1;

  v1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
}

void MIL::Util::DispatchToCppType<std::unique_ptr<MIL::IRTensorValue const>,`anonymous namespace'::MakeValueHelper_ConstExpr,MIL::IRTensorValueType const*,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(int a1)
{
  __asm { BR              X10 }
}

void sub_1E05B9148(int a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5, int a6, int a7, int a8, __int128 __p, uint64_t a10, uint64_t a11, __int128 a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::string v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;

  v24 = *a2;
  v35 = *(_OWORD *)a3;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v25 = *a4;
  if (*(char *)(a5 + 23) < 0)
    std::string::__init_copy_ctor_external(&v34, *(const std::string::value_type **)a5, *(_QWORD *)(a5 + 8));
  else
    v34 = *(std::string *)a5;
  *(_QWORD *)(v23 - 48) = v24;
  v37 = v25;
  std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<unsigned char>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>((uint64_t *)(v23 - 48), &v35, &v37, (uint64_t)&v34, &v36);
  v26 = operator new();
  v27 = *(_QWORD *)(v23 - 48);
  v28 = v36;
  v36 = 0;
  *(_QWORD *)(v23 - 40) = v28;
  ((void (*)(uint64_t, uint64_t, uint64_t))MIL::IRTypedTensorValue<BOOL>::IRTypedTensorValue)(v26, v27, v23 - 40);
  v29 = *(_QWORD *)(v23 - 40);
  *(_QWORD *)(v23 - 40) = 0;
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
  *v22 = v26;
  v30 = v36;
  v36 = 0;
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
  v31 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
  if (*((_QWORD *)&v35 + 1))
  {
    v32 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
}

void sub_1E05BA66C()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "cannot dispatch on type");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
}

void sub_1E05BA6A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void MIL::IRTensorValueType::MakeFloat8E5M2Value(_anonymous_namespace_ *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeFloat8E5M2Value((uint64_t)a1, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BA8F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *`anonymous namespace'::ValidateScalarType(_anonymous_namespace_ *this, const MIL::IRTensorValueType *a2)
{
  _QWORD *result;
  std::runtime_error *exception;

  result = (_QWORD *)(*(uint64_t (**)(_anonymous_namespace_ *, const MIL::IRTensorValueType *))(*(_QWORD *)this + 96))(this, a2);
  if (*result != result[1])
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot create scalar tensor value from non-scalar type.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05BA96C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::IRTensorValueType::MakeFloat8E4M3FNValue(_anonymous_namespace_ *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeFloat8E4M3FNValue((uint64_t)a1, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BA9EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeBFloat16Value(_anonymous_namespace_ *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  __int16 v3;
  _WORD *v6;
  void *__p;
  void *v8;
  _WORD *v9;

  v3 = (__int16)a2;
  v6 = operator new(2uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeBFloat16Value((uint64_t)a1, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BAA74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeFloat16Value(_anonymous_namespace_ *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  __int16 v3;
  _WORD *v6;
  void *__p;
  void *v8;
  _WORD *v9;

  v3 = (__int16)a2;
  v6 = operator new(2uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeFloat16Value((uint64_t)a1, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BAAFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeFloat32Value(MIL::IRTensorValueType *this@<X0>, float a2@<S0>, const MIL::IRTensorValueType *a3@<X1>, _QWORD *a4@<X8>)
{
  float *v7;
  void *__p;
  void *v9;
  float *v10;

  v7 = (float *)operator new(4uLL);
  __p = v7;
  *v7 = a2;
  v9 = v7 + 1;
  v10 = v7 + 1;
  MIL::IRTensorValueType::MakeFloat32Value((uint64_t)this, (uint64_t)&__p, a4);
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
}

void sub_1E05BAB84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeFloat64Value(MIL::IRTensorValueType *this@<X0>, double a2@<D0>, const MIL::IRTensorValueType *a3@<X1>, _QWORD *a4@<X8>)
{
  double *v7;
  void *__p;
  void *v9;
  double *v10;

  v7 = (double *)operator new(8uLL);
  __p = v7;
  *v7 = a2;
  v9 = v7 + 1;
  v10 = v7 + 1;
  MIL::IRTensorValueType::MakeFloat64Value((uint64_t)this, (uint64_t)&__p, a4);
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
}

void sub_1E05BAC0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeBoolValue(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeBoolValue((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BAC94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeInt4Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeInt4Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BAD1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeUInt6Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeUInt6Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BADA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeUInt4Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeUInt4Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BAE2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeUInt3Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeUInt3Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BAEB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeUInt2Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeUInt2Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BAF3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeUInt1Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeUInt1Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BAFC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeUInt8Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeUInt8Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BB04C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeUInt16Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  __int16 v3;
  _WORD *v6;
  void *__p;
  void *v8;
  _WORD *v9;

  v3 = (__int16)a2;
  v6 = operator new(2uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeUInt16Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BB0D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeUInt32Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  int v3;
  _DWORD *v6;
  void *__p;
  void *v8;
  _DWORD *v9;

  v3 = (int)a2;
  v6 = operator new(4uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeUInt32Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BB15C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeInt8Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  char v3;
  _BYTE *v6;
  void *__p;
  void *v8;
  _BYTE *v9;

  v3 = (char)a2;
  v6 = operator new(1uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeInt8Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BB1E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeInt16Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  __int16 v3;
  _WORD *v6;
  void *__p;
  void *v8;
  _WORD *v9;

  v3 = (__int16)a2;
  v6 = operator new(2uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeInt16Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BB26C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeInt32Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  int v3;
  _DWORD *v6;
  void *__p;
  void *v8;
  _DWORD *v9;

  v3 = (int)a2;
  v6 = operator new(4uLL);
  __p = v6;
  *v6 = v3;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeInt32Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BB2F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::IRTensorValueType::MakeInt64Value(MIL::IRTensorValueType *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  void *__p;
  void *v8;
  _QWORD *v9;

  v6 = operator new(8uLL);
  __p = v6;
  *v6 = a2;
  v8 = v6 + 1;
  v9 = v6 + 1;
  MIL::IRTensorValueType::MakeInt64Value((uint64_t)this, (uint64_t)&__p, a3);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_1E05BB37C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTensorValueType::GetAttribute(uint64_t a1)
{
  uint64_t result;
  std::logic_error *exception;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  if (!result)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Attribute does not exist.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  return result;
}

void sub_1E05BB3F0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorValueType::GetNumElements(MIL::IRTensorValueType *this)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  v1 = (*(uint64_t (**)(MIL::IRTensorValueType *))(*(_QWORD *)this + 96))(this);
  v2 = *(_QWORD **)v1;
  v3 = *(_QWORD **)(v1 + 8);
  v4 = 1;
  while (v2 != v3)
  {
    v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v2 + 16))(*v2);
    if (!v5)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::range_error::range_error[abi:ne180100](exception, "Cannot determine number of elements in tensor with unknown dimension.");
      __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
    }
    v4 *= (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
    ++v2;
  }
  return v4;
}

void sub_1E05BB4A0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL MIL::IRTensorValueType::IsScalar(MIL::IRTensorValueType *this)
{
  _QWORD *v1;

  v1 = (_QWORD *)(*(uint64_t (**)(MIL::IRTensorValueType *))(*(_QWORD *)this + 96))(this);
  return *v1 == v1[1];
}

uint64_t MIL::IRTensorValueType::Rank(MIL::IRTensorValueType *this)
{
  _QWORD *v2;

  if (!(*(unsigned int (**)(MIL::IRTensorValueType *))(*(_QWORD *)this + 104))(this))
    return -1;
  v2 = (_QWORD *)(*(uint64_t (**)(MIL::IRTensorValueType *))(*(_QWORD *)this + 96))(this);
  return (uint64_t)(v2[1] - *v2) >> 3;
}

_QWORD *MIL::IRListValueType::IRListValueType(_QWORD *this)
{
  *this = off_1EA998BC0;
  return this;
}

uint64_t MIL::IRListValueType::Make(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2, const MIL::IRValueType *a3)
{
  const MIL::IRValueType *v5;
  const MIL::IRDimension *v6;

  v5 = (const MIL::IRValueType *)MIL::IRConstantDimension::Make(this, a3);
  return MIL::IRListValueType::MakeWithDimension(this, a2, v5, v6);
}

_QWORD *MIL::IRListValueType::Make@<X0>(MIL::IRListValueType *this@<X0>, const MIL::IRValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  *result = &off_1EA9991F0;
  result[1] = this;
  result[2] = a2;
  *a3 = result;
  return result;
}

uint64_t MIL::IRListValueType::MakeValue@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t result;

  v6 = operator new();
  result = MIL::IRListValue::IRListValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05BB62C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C406427F484);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRListValueType::GetNumElements(MIL::IRListValueType *this)
{
  uint64_t v1;
  uint64_t v2;
  std::runtime_error *exception;

  v1 = (*(uint64_t (**)(MIL::IRListValueType *))(*(_QWORD *)this + 72))(this);
  v2 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
  if (!v2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "Cannot determine number of elements in list with unknown length.");
    __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void sub_1E05BB6C0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const MIL::Text::SerializerOptions *MIL::IRListValueType::ToString(MIL::IRListValueType *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Type((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05BB760(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRTupleValueType::IRTupleValueType(_QWORD *this)
{
  *this = off_1EA998C20;
  return this;
}

__n128 MIL::IRTupleValueType::Make@<Q0>(__n128 *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  __n128 result;

  v4 = operator new();
  result = *a1;
  a1->n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  *(_QWORD *)v4 = &off_1EA999268;
  *(__n128 *)(v4 + 8) = result;
  *a2 = v4;
  return result;
}

uint64_t MIL::IRTupleValueType::MakeValue@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t result;

  v6 = operator new();
  result = MIL::IRTupleValue::IRTupleValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05BB860(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0xE1C406427F484);
  _Unwind_Resume(a1);
}

void MIL::IRTupleValueType::GetNumElements(MIL::IRTupleValueType *this)
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::range_error::range_error[abi:ne180100](exception, "Cannot determine number of elements in a tuple.");
  __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
}

void sub_1E05BB8C4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const MIL::Text::SerializerOptions *MIL::IRTupleValueType::ToString(MIL::IRTupleValueType *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Type((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05BB964(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRValueMapHasher::operator()(uint64_t a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 24))(*a2);
}

uint64_t MIL::IRValueMapEq::operator()(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return (*(unsigned int (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 16))(*a2, *a3);
}

_QWORD *MIL::IRDictionaryValueType::IRDictionaryValueType(_QWORD *this)
{
  *this = off_1EA998C78;
  return this;
}

_QWORD *MIL::IRDictionaryValueType::Make@<X0>(MIL::IRDictionaryValueType *this@<X0>, const MIL::IRValueType *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  *result = &off_1EA9992D8;
  result[1] = this;
  result[2] = a2;
  *a3 = result;
  return result;
}

void MIL::IRDictionaryValueType::GetNumElements(MIL::IRDictionaryValueType *this)
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::range_error::range_error[abi:ne180100](exception, "Cannot determine number of elements in a dictionary.");
  __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
}

void sub_1E05BBAA0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const MIL::Text::SerializerOptions *MIL::IRDictionaryValueType::ToString(MIL::IRDictionaryValueType *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Type((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05BBB40(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRDictionaryValueType::MakeValue@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t result;

  v6 = operator new();
  result = MIL::IRDictionaryValue::IRDictionaryValue(v6, a1, a2);
  *a3 = v6;
  return result;
}

void sub_1E05BBBD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0x10E1C402C2AC9EFLL);
  _Unwind_Resume(a1);
}

void MIL::IRNamedValueType::~IRNamedValueType(void **this)
{
  if (*((char *)this + 23) < 0)
    operator delete(*this);
}

{
  if (*((char *)this + 23) < 0)
    operator delete(*this);
}

__n128 MIL::IRNamedValueType::IRNamedValueType(__n128 *a1, __n128 *a2, unint64_t a3)
{
  __n128 result;

  result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  a2->n128_u64[0] = 0;
  a1[1].n128_u64[1] = a3;
  return result;
}

{
  __n128 result;

  result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  a2->n128_u64[0] = 0;
  a1[1].n128_u64[1] = a3;
  return result;
}

uint64_t MIL::IRNamedValueType::Make@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result;
  uint64_t v7;
  char v8;
  __int128 v9;

  result = operator new();
  v7 = *a1;
  *(_QWORD *)&v9 = a1[1];
  *(_QWORD *)((char *)&v9 + 7) = *(uint64_t *)((char *)a1 + 15);
  v8 = *((_BYTE *)a1 + 23);
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  *(_QWORD *)result = v7;
  *(_QWORD *)(result + 8) = v9;
  *(_QWORD *)(result + 15) = *(_QWORD *)((char *)&v9 + 7);
  *(_BYTE *)(result + 23) = v8;
  *(_QWORD *)(result + 24) = a2;
  *a3 = result;
  return result;
}

BOOL MIL::IRNamedValueType::Equals(MIL::IRNamedValueType *this, const MIL::IRNamedValueType *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  const MIL::IRNamedValueType *v6;
  MIL::IRNamedValueType *i;

  v2 = *((unsigned __int8 *)this + 23);
  if ((v2 & 0x80u) == 0)
    v3 = *((unsigned __int8 *)this + 23);
  else
    v3 = *((_QWORD *)this + 1);
  v4 = *((unsigned __int8 *)a2 + 23);
  v5 = (char)v4;
  if ((v4 & 0x80u) != 0)
    v4 = *((_QWORD *)a2 + 1);
  if (v3 != v4)
    return 0;
  v6 = a2;
  if (v5 < 0)
    a2 = *(const MIL::IRNamedValueType **)a2;
  if ((v2 & 0x80) != 0)
  {
    if (!memcmp(*(const void **)this, a2, *((_QWORD *)this + 1)))
      return *((_QWORD *)this + 3) == *((_QWORD *)v6 + 3);
    return 0;
  }
  if (*((_BYTE *)this + 23))
  {
    for (i = this; *(unsigned __int8 *)i == *(unsigned __int8 *)a2; i = (MIL::IRNamedValueType *)((char *)i + 1))
    {
      a2 = (const MIL::IRNamedValueType *)((char *)a2 + 1);
      if (!--v2)
        return *((_QWORD *)this + 3) == *((_QWORD *)v6 + 3);
    }
    return 0;
  }
  return *((_QWORD *)this + 3) == *((_QWORD *)v6 + 3);
}

uint64_t MIL::IRNamedValueType::GetType(MIL::IRNamedValueType *this)
{
  return *((_QWORD *)this + 3);
}

__n128 MIL::IRNamedValueType::SetName(uint64_t a1, __n128 *a2)
{
  __n128 result;

  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  result = *a2;
  *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
  *(__n128 *)a1 = result;
  a2[1].n128_u8[7] = 0;
  a2->n128_u8[0] = 0;
  return result;
}

uint64_t MIL::IRNamedValueType::SetType(uint64_t this, const MIL::IRValueType *a2)
{
  *(_QWORD *)(this + 24) = a2;
  return this;
}

const MIL::Text::SerializerOptions *MIL::IRNamedValueType::ToString(const MIL::IRValueType **this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::IDTypeBinding((MIL::Text::BasicSerializer *)v5, (uint64_t)this, this[3]);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05BBEE0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::IRMemoryLayoutValueType::IRMemoryLayoutValueType(_QWORD *this)
{
  *this = off_1EA998CD8;
  return this;
}

void *MIL::IRMemoryLayoutValueType::TryAsTensorBufferType(void *this)
{
  if (this)
  return this;
}

void *MIL::IRMemoryLayoutValueType::AsTensorBufferType(MIL::IRMemoryLayoutValueType *this)
{
  void *result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  if (!this
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

void *MIL::IRMemoryLayoutValueType::TryAsPixelBufferType(void *this)
{
  if (this)
  return this;
}

void *MIL::IRMemoryLayoutValueType::AsPixelBufferType(MIL::IRMemoryLayoutValueType *this)
{
  void *result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  if (!this
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

void *MIL::IRMemoryLayoutValueType::TryAsCircularBufferType(void *this)
{
  if (this)
  return this;
}

void *MIL::IRMemoryLayoutValueType::AsCircularBufferType(MIL::IRMemoryLayoutValueType *this)
{
  void *result;
  std::bad_cast *exception;
  std::bad_cast *v3;

  if (!this
  {
    exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
    v3 = std::bad_cast::bad_cast(exception);
    __cxa_throw(v3, MEMORY[0x1E0DE4EA0], MEMORY[0x1E0DE4DA0]);
  }
  return result;
}

void MIL::IRTensorBufferValueType::~IRTensorBufferValueType(MIL::IRTensorBufferValueType *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1EA998D40;
  v3 = *((_QWORD *)this + 1);
  v1 = (_QWORD *)((char *)this + 8);
  v2 = v3;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IRTensorBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v1, v2);
}

{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1EA998D40;
  v3 = *((_QWORD *)this + 1);
  v1 = (_QWORD *)((char *)this + 8);
  v2 = v3;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IRTensorBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v1, v2);
}

{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1EA998D40;
  v3 = *((_QWORD *)this + 1);
  v1 = (_QWORD *)((char *)this + 8);
  v2 = v3;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IRTensorBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v1, v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRTensorBufferValueType::IRTensorBufferValueType(_QWORD *this)
{
  *this = &off_1EA998D40;
  this[1] = 0;
  return this;
}

{
  *this = &off_1EA998D40;
  this[1] = 0;
  return this;
}

_QWORD *MIL::IRTensorBufferValueType::IRTensorBufferValueType(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998D40;
  result[1] = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998D40;
  result[1] = v2;
  return result;
}

uint64_t MIL::IRTensorBufferValueType::MakeUsingDefaultStrides(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3)
{
  size_t v6;
  uint64_t v7;
  _OWORD v9[2];
  int v10;
  char v11;
  void *__p[3];
  void *v13[3];

  v6 = (a3[1] - *a3) >> 3;
  MIL::MakeDefaultStrides(a3, (uint64_t *)v13);
  v11 = 1;
  std::vector<unsigned char>::vector(__p, v6, &v11);
  memset(v9, 0, sizeof(v9));
  v10 = 1065353216;
  v7 = MIL::IRTensorBufferValueType::Make(a1, a2, a3, (uint64_t *)v13, (uint64_t *)__p, (uint64_t *)v9);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v9);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v13[0])
  {
    v13[1] = v13[0];
    operator delete(v13[0]);
  }
  return v7;
}

void sub_1E05BC258(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  uint64_t v16;
  void *v18;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  v18 = *(void **)(v16 - 56);
  if (v18)
  {
    *(_QWORD *)(v16 - 48) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::Make(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t Int64Scalar;
  uint64_t v18;
  unint64_t v19;
  uint64_t UInt8Scalar;
  uint64_t v21;
  void *__p[3];
  void *v24[3];
  void *v25[3];

  std::vector<MIL::IRDimension const*>::vector(v25, (a3[1] - *a3) >> 3);
  std::vector<MIL::IRProperty const*>::vector(v24, (a4[1] - *a4) >> 3);
  std::vector<MIL::IRProperty const*>::vector(__p, a5[1] - *a5);
  v12 = *a3;
  if (a3[1] != *a3)
  {
    v13 = 0;
    do
    {
      v14 = MIL::IRConstantDimension::Make(a1, *(MIL::MILContext **)(v12 + 8 * v13));
      *((_QWORD *)v25[0] + v13++) = v14;
      v12 = *a3;
    }
    while (v13 < (a3[1] - *a3) >> 3);
  }
  v15 = *a4;
  if (a4[1] != *a4)
  {
    v16 = 0;
    do
    {
      Int64Scalar = MIL::IRConstantProperty::MakeInt64Scalar(a1, *(MIL::MILContext **)(v15 + 8 * v16));
      *((_QWORD *)v24[0] + v16++) = Int64Scalar;
      v15 = *a4;
    }
    while (v16 < (a4[1] - *a4) >> 3);
  }
  v18 = *a5;
  if (a5[1] != *a5)
  {
    v19 = 0;
    do
    {
      UInt8Scalar = MIL::IRConstantProperty::MakeUInt8Scalar(a1, (MIL::MILContext *)*(unsigned __int8 *)(v18 + v19));
      *((_QWORD *)__p[0] + v19++) = UInt8Scalar;
      v18 = *a5;
    }
    while (v19 < a5[1] - *a5);
  }
  v21 = MIL::IRTensorBufferValueType::MakeWithShape(a1, a2, (__int128 *)v25, (uint64_t)v24, (uint64_t)__p, a6);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v24[0])
  {
    v24[1] = v24[0];
    operator delete(v24[0]);
  }
  if (v25[0])
  {
    v25[1] = v25[0];
    operator delete(v25[0]);
  }
  return v21;
}

void sub_1E05BC418(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTensorBufferValueType::MakeUsingDefaultStrides(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8;
  _OWORD v10[2];
  int v11;
  void *__p[3];

  MIL::MakeDefaultStrides(a3, a4, (uint64_t *)__p);
  memset(v10, 0, sizeof(v10));
  v11 = 1065353216;
  v8 = MIL::IRTensorBufferValueType::Make(a1, a2, a3, (uint64_t *)__p, a4, (uint64_t *)v10);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v10);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v8;
}

void sub_1E05BC504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::Make(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, uint64_t *a4)
{
  size_t v8;
  uint64_t v9;
  _OWORD v11[2];
  int v12;
  char v13;
  void *__p[3];

  v8 = (a3[1] - *a3) >> 3;
  v13 = 1;
  std::vector<unsigned char>::vector(__p, v8, &v13);
  memset(v11, 0, sizeof(v11));
  v12 = 1065353216;
  v9 = MIL::IRTensorBufferValueType::Make(a1, a2, a3, a4, (uint64_t *)__p, (uint64_t *)v11);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v11);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v9;
}

void sub_1E05BC5CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  if (__p)
  {
    a17 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, __int128 *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  char *v12;
  __int128 v13;
  char *v14;
  char *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  char *v27;
  std::__shared_weak_count *v28;
  char *v29;
  std::__shared_weak_count *v30;
  char *v31;
  std::__shared_weak_count *v32;

  v12 = (char *)operator new(0x30uLL);
  *((_QWORD *)v12 + 2) = 0;
  *(_QWORD *)v12 = &unk_1EA999350;
  *((_QWORD *)v12 + 1) = 0;
  v13 = *a3;
  *((_QWORD *)v12 + 5) = *((_QWORD *)a3 + 2);
  v32 = (std::__shared_weak_count *)v12;
  *(_OWORD *)(v12 + 24) = v13;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  v31 = v12 + 24;
  v14 = (char *)operator new(0x30uLL);
  *((_QWORD *)v14 + 2) = 0;
  *(_QWORD *)v14 = &unk_1EA9993A0;
  *((_QWORD *)v14 + 1) = 0;
  *(_OWORD *)(v14 + 24) = *(_OWORD *)a4;
  *((_QWORD *)v14 + 5) = *(_QWORD *)(a4 + 16);
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  v29 = v14 + 24;
  v30 = (std::__shared_weak_count *)v14;
  v15 = (char *)operator new(0x30uLL);
  *((_QWORD *)v15 + 1) = 0;
  *((_QWORD *)v15 + 2) = 0;
  *(_QWORD *)v15 = &unk_1EA9993A0;
  *(_OWORD *)(v15 + 24) = *(_OWORD *)a5;
  *((_QWORD *)v15 + 5) = *(_QWORD *)(a5 + 16);
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(a5 + 8) = 0;
  *(_QWORD *)(a5 + 16) = 0;
  v27 = v15 + 24;
  v28 = (std::__shared_weak_count *)v15;
  v16 = MIL::IRTensorBufferValueType::MakeWithShape(a1, a2, (uint64_t *)&v31, (uint64_t *)&v29, (uint64_t *)&v27, a6);
  v17 = v28;
  if (v28)
  {
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v30;
  if (v30)
  {
    v21 = (unint64_t *)&v30->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = v32;
  if (v32)
  {
    v24 = (unint64_t *)&v32->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  return v16;
}

void sub_1E05BC7AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithRowAlignment(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, MIL::MILContext *a4)
{
  size_t v8;
  uint64_t v9;
  _OWORD v11[2];
  int v12;
  char v13;
  void *__p[3];

  v8 = (a3[1] - *a3) >> 3;
  v13 = 1;
  std::vector<unsigned char>::vector(__p, v8, &v13);
  memset(v11, 0, sizeof(v11));
  v12 = 1065353216;
  v9 = MIL::IRTensorBufferValueType::MakeWithRowAlignment(a1, a2, a3, a4, (uint64_t *)__p, (uint64_t *)v11);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v11);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v9;
}

void sub_1E05BC884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  if (__p)
  {
    a17 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithRowAlignment(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, MIL::MILContext *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t UInt8Scalar;
  uint64_t UInt64Scalar;
  uint64_t v19;
  void *__p[3];
  void *v22[3];

  std::vector<MIL::IRDimension const*>::vector(v22, (a3[1] - *a3) >> 3);
  std::vector<MIL::IRProperty const*>::vector(__p, a5[1] - *a5);
  v12 = *a3;
  if (a3[1] != *a3)
  {
    v13 = 0;
    do
    {
      v14 = MIL::IRConstantDimension::Make(a1, *(MIL::MILContext **)(v12 + 8 * v13));
      *((_QWORD *)v22[0] + v13++) = v14;
      v12 = *a3;
    }
    while (v13 < (a3[1] - *a3) >> 3);
  }
  v15 = *a5;
  if (a5[1] != *a5)
  {
    v16 = 0;
    do
    {
      UInt8Scalar = MIL::IRConstantProperty::MakeUInt8Scalar(a1, (MIL::MILContext *)*(unsigned __int8 *)(v15 + v16));
      *((_QWORD *)__p[0] + v16++) = UInt8Scalar;
      v15 = *a5;
    }
    while (v16 < a5[1] - *a5);
  }
  UInt64Scalar = MIL::IRConstantProperty::MakeUInt64Scalar(a1, a4);
  v19 = MIL::IRTensorBufferValueType::MakeWithShapeAndRowAlignment(a1, a2, (__int128 *)v22, UInt64Scalar, (uint64_t)__p, a6);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v22[0])
  {
    v22[1] = v22[0];
    operator delete(v22[0]);
  }
  return v19;
}

void sub_1E05BC9DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShapeAndRowAlignment(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, __int128 *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  char *v12;
  __int128 v13;
  char *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  char *v23;
  std::__shared_weak_count *v24;
  char *v25;
  std::__shared_weak_count *v26;

  v12 = (char *)operator new(0x30uLL);
  *((_QWORD *)v12 + 2) = 0;
  *(_QWORD *)v12 = &unk_1EA999350;
  *((_QWORD *)v12 + 1) = 0;
  v13 = *a3;
  *((_QWORD *)v12 + 5) = *((_QWORD *)a3 + 2);
  v26 = (std::__shared_weak_count *)v12;
  *(_OWORD *)(v12 + 24) = v13;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  v25 = v12 + 24;
  v14 = (char *)operator new(0x30uLL);
  *((_QWORD *)v14 + 2) = 0;
  *(_QWORD *)v14 = &unk_1EA9993A0;
  *((_QWORD *)v14 + 1) = 0;
  *(_OWORD *)(v14 + 24) = *(_OWORD *)a5;
  *((_QWORD *)v14 + 5) = *(_QWORD *)(a5 + 16);
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(a5 + 8) = 0;
  *(_QWORD *)(a5 + 16) = 0;
  v23 = v14 + 24;
  v24 = (std::__shared_weak_count *)v14;
  v15 = MIL::IRTensorBufferValueType::MakeWithShapeAndRowAlignment(a1, a2, (uint64_t *)&v25, a4, (uint64_t *)&v23, a6);
  v16 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v26;
  if (v26)
  {
    v20 = (unint64_t *)&v26->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  return v15;
}

void sub_1E05BCB6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShapeUsingDefaultStrides(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3)
{
  unint64_t v6;
  uint64_t UInt8Scalar;
  uint64_t v8;
  _OWORD v10[2];
  int v11;
  void *__p[3];
  void *v13[3];

  std::vector<MIL::IRProperty const*>::vector(v13, (a3[1] - *a3) >> 3);
  if (a3[1] != *a3)
  {
    v6 = 0;
    do
    {
      UInt8Scalar = MIL::IRConstantProperty::MakeUInt8Scalar(a1, (MIL::MILContext *)1);
      *((_QWORD *)v13[0] + v6++) = UInt8Scalar;
    }
    while (v6 < (a3[1] - *a3) >> 3);
  }
  MIL::MakeDefaultStrides(a1, a3, __p);
  memset(v10, 0, sizeof(v10));
  v11 = 1065353216;
  v8 = MIL::IRTensorBufferValueType::MakeWithShape(a1, a2, (__int128 *)a3, (uint64_t)__p, (uint64_t)v13, (uint64_t *)v10);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v10);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v13[0])
  {
    v13[1] = v13[0];
    operator delete(v13[0]);
  }
  return v8;
}

void sub_1E05BCC7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  uint64_t v16;
  void *v18;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  v18 = *(void **)(v16 - 56);
  if (v18)
  {
    *(_QWORD *)(v16 - 48) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShapeUsingDefaultStrides(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8;
  _OWORD v10[2];
  int v11;
  void *__p[3];

  MIL::MakeDefaultStrides(a1, a3, a4, __p);
  memset(v10, 0, sizeof(v10));
  v11 = 1065353216;
  v8 = MIL::IRTensorBufferValueType::MakeWithShape(a1, a2, (__int128 *)a3, (uint64_t)__p, (uint64_t)a4, (uint64_t *)v10);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v10);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v8;
}

void sub_1E05BCD50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t UInt8Scalar;
  uint64_t v10;
  _OWORD v12[2];
  int v13;
  void *__p[3];

  std::vector<MIL::IRProperty const*>::vector(__p, (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3);
  if (*(_QWORD *)(a3 + 8) != *(_QWORD *)a3)
  {
    v8 = 0;
    do
    {
      UInt8Scalar = MIL::IRConstantProperty::MakeUInt8Scalar(a1, (MIL::MILContext *)1);
      *((_QWORD *)__p[0] + v8++) = UInt8Scalar;
    }
    while (v8 < (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3);
  }
  memset(v12, 0, sizeof(v12));
  v13 = 1065353216;
  v10 = MIL::IRTensorBufferValueType::MakeWithShape(a1, a2, (__int128 *)a3, a4, (uint64_t)__p, (uint64_t *)v12);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v12);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v10;
}

void sub_1E05BCE4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShapeAndRowAlignment(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t UInt8Scalar;
  uint64_t v10;
  _OWORD v12[2];
  int v13;
  void *__p[3];

  std::vector<MIL::IRProperty const*>::vector(__p, (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3);
  if (*(_QWORD *)(a3 + 8) != *(_QWORD *)a3)
  {
    v8 = 0;
    do
    {
      UInt8Scalar = MIL::IRConstantProperty::MakeUInt8Scalar(a1, (MIL::MILContext *)1);
      *((_QWORD *)__p[0] + v8++) = UInt8Scalar;
    }
    while (v8 < (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3);
  }
  memset(v12, 0, sizeof(v12));
  v13 = 1065353216;
  v10 = MIL::IRTensorBufferValueType::MakeWithShapeAndRowAlignment(a1, a2, (__int128 *)a3, a4, (uint64_t)__p, (uint64_t *)v12);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v12);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v10;
}

void sub_1E05BCF50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShapeUsingDefaultStrides(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t **a3)
{
  uint64_t *v6;
  unint64_t v7;
  uint64_t UInt8Scalar;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  _OWORD v25[2];
  int v26;
  char *v27;
  std::__shared_weak_count *v28;
  void *__p[2];
  uint64_t v30;
  char *v31;
  std::__shared_weak_count *v32;
  uint64_t *v33;
  std::__shared_weak_count *v34;
  __int128 v35;
  uint64_t v36;

  std::vector<MIL::IRProperty const*>::vector(&v35, ((*a3)[1] - **a3) >> 3);
  v6 = *a3;
  if ((*a3)[1] != **a3)
  {
    v7 = 0;
    do
    {
      UInt8Scalar = MIL::IRConstantProperty::MakeUInt8Scalar(a1, (MIL::MILContext *)1);
      *(_QWORD *)(v35 + 8 * v7++) = UInt8Scalar;
      v6 = *a3;
    }
    while (v7 < ((*a3)[1] - **a3) >> 3);
  }
  v9 = (std::__shared_weak_count *)a3[1];
  v33 = v6;
  v34 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    v6 = *a3;
  }
  MIL::MakeDefaultStrides(a1, v6, __p);
  v12 = (char *)operator new(0x30uLL);
  *((_QWORD *)v12 + 2) = 0;
  *(_QWORD *)v12 = &unk_1EA9993A0;
  *((_QWORD *)v12 + 1) = 0;
  *(_OWORD *)(v12 + 24) = *(_OWORD *)__p;
  *((_QWORD *)v12 + 5) = v30;
  __p[0] = 0;
  __p[1] = 0;
  v30 = 0;
  v31 = v12 + 24;
  v32 = (std::__shared_weak_count *)v12;
  v13 = (char *)operator new(0x30uLL);
  *((_QWORD *)v13 + 1) = 0;
  *((_QWORD *)v13 + 2) = 0;
  *(_QWORD *)v13 = &unk_1EA9993A0;
  *(_OWORD *)(v13 + 24) = v35;
  *((_QWORD *)v13 + 5) = v36;
  v35 = 0uLL;
  v36 = 0;
  v27 = v13 + 24;
  v28 = (std::__shared_weak_count *)v13;
  memset(v25, 0, sizeof(v25));
  v26 = 1065353216;
  v14 = MIL::IRTensorBufferValueType::MakeWithShape(a1, a2, (uint64_t *)&v33, (uint64_t *)&v31, (uint64_t *)&v27, (uint64_t *)v25);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v25);
  v15 = v28;
  if (v28)
  {
    v16 = (unint64_t *)&v28->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v32;
  if (v32)
  {
    v19 = (unint64_t *)&v32->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v21 = v34;
  if (v34)
  {
    v22 = (unint64_t *)&v34->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  if ((_QWORD)v35)
  {
    *((_QWORD *)&v35 + 1) = v35;
    operator delete((void *)v35);
  }
  return v14;
}

void sub_1E05BD1A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  uint64_t v21;
  void *v23;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a21);
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v21 - 80);
  v23 = *(void **)(v21 - 64);
  if (v23)
  {
    *(_QWORD *)(v21 - 56) = v23;
    operator delete(v23);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShapeUsingDefaultStrides(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  char *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  _OWORD v26[2];
  int v27;
  uint64_t *v28;
  std::__shared_weak_count *v29;
  void *__p[2];
  uint64_t v31;
  char *v32;
  std::__shared_weak_count *v33;
  uint64_t *v34;
  std::__shared_weak_count *v35;

  v7 = *(uint64_t **)a3;
  v8 = *(std::__shared_weak_count **)(a3 + 8);
  v34 = *(uint64_t **)a3;
  v35 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    v7 = *(uint64_t **)a3;
  }
  MIL::MakeDefaultStrides(a1, v7, *(uint64_t **)a4, __p);
  v11 = (char *)operator new(0x30uLL);
  *((_QWORD *)v11 + 2) = 0;
  *(_OWORD *)(v11 + 24) = *(_OWORD *)__p;
  *(_QWORD *)v11 = &unk_1EA9993A0;
  *((_QWORD *)v11 + 1) = 0;
  *((_QWORD *)v11 + 5) = v31;
  __p[0] = 0;
  __p[1] = 0;
  v31 = 0;
  v32 = v11 + 24;
  v33 = (std::__shared_weak_count *)v11;
  v12 = *(std::__shared_weak_count **)(a4 + 8);
  v28 = *(uint64_t **)a4;
  v29 = v12;
  if (v12)
  {
    v13 = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  memset(v26, 0, sizeof(v26));
  v27 = 1065353216;
  v15 = MIL::IRTensorBufferValueType::MakeWithShape(a1, a2, (uint64_t *)&v34, (uint64_t *)&v32, (uint64_t *)&v28, (uint64_t *)v26);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v26);
  v16 = v29;
  if (v29)
  {
    v17 = (unint64_t *)&v29->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v33;
  if (v33)
  {
    v20 = (unint64_t *)&v33->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v22 = v35;
  if (v35)
  {
    v23 = (unint64_t *)&v35->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  return v15;
}

void sub_1E05BD3CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18)
{
  uint64_t v18;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v18 - 64);
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v18 - 48);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t UInt8Scalar;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _OWORD v29[2];
  int v30;
  char *v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  __int128 v37;
  uint64_t v38;

  std::vector<MIL::IRProperty const*>::vector(&v37, (uint64_t)(*(_QWORD *)(*a3 + 8) - *(_QWORD *)*a3) >> 3);
  v8 = *a3;
  if (*(_QWORD *)(*a3 + 8) != *(_QWORD *)*a3)
  {
    v9 = 0;
    do
    {
      UInt8Scalar = MIL::IRConstantProperty::MakeUInt8Scalar(a1, (MIL::MILContext *)1);
      *(_QWORD *)(v37 + 8 * v9++) = UInt8Scalar;
      v8 = *a3;
    }
    while (v9 < (uint64_t)(*(_QWORD *)(*a3 + 8) - *(_QWORD *)*a3) >> 3);
  }
  v11 = (std::__shared_weak_count *)a3[1];
  v35 = v8;
  v36 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  v14 = a4[1];
  v33 = *a4;
  v34 = (std::__shared_weak_count *)v14;
  if (v14)
  {
    v15 = (unint64_t *)(v14 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = (char *)operator new(0x30uLL);
  *((_QWORD *)v17 + 2) = 0;
  *(_QWORD *)v17 = &unk_1EA9993A0;
  *((_QWORD *)v17 + 1) = 0;
  *(_OWORD *)(v17 + 24) = v37;
  *((_QWORD *)v17 + 5) = v38;
  v37 = 0uLL;
  v38 = 0;
  v31 = v17 + 24;
  v32 = (std::__shared_weak_count *)v17;
  memset(v29, 0, sizeof(v29));
  v30 = 1065353216;
  v18 = MIL::IRTensorBufferValueType::MakeWithShape(a1, a2, &v35, &v33, (uint64_t *)&v31, (uint64_t *)v29);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v29);
  v19 = v32;
  if (v32)
  {
    v20 = (unint64_t *)&v32->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v34;
  if (v34)
  {
    v23 = (unint64_t *)&v34->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v36;
  if (v36)
  {
    v26 = (unint64_t *)&v36->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  if ((_QWORD)v37)
  {
    *((_QWORD *)&v37 + 1) = v37;
    operator delete((void *)v37);
  }
  return v18;
}

void sub_1E05BD620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19)
{
  uint64_t v19;
  void *v21;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  v21 = *(void **)(v19 - 80);
  if (v21)
  {
    *(_QWORD *)(v19 - 72) = v21;
    operator delete(v21);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShapeAndRowAlignment(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t UInt8Scalar;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  _OWORD v23[2];
  int v24;
  char *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  void *__p[2];
  uint64_t v30;

  std::vector<MIL::IRProperty const*>::vector(__p, (uint64_t)(*(_QWORD *)(*a3 + 8) - *(_QWORD *)*a3) >> 3);
  v8 = *a3;
  if (*(_QWORD *)(*a3 + 8) != *(_QWORD *)*a3)
  {
    v9 = 0;
    do
    {
      UInt8Scalar = MIL::IRConstantProperty::MakeUInt8Scalar(a1, (MIL::MILContext *)1);
      *((_QWORD *)__p[0] + v9++) = UInt8Scalar;
      v8 = *a3;
    }
    while (v9 < (uint64_t)(*(_QWORD *)(*a3 + 8) - *(_QWORD *)*a3) >> 3);
  }
  v11 = (std::__shared_weak_count *)a3[1];
  v27 = v8;
  v28 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  v14 = (char *)operator new(0x30uLL);
  *((_QWORD *)v14 + 2) = 0;
  *(_QWORD *)v14 = &unk_1EA9993A0;
  *((_QWORD *)v14 + 1) = 0;
  *(_OWORD *)(v14 + 24) = *(_OWORD *)__p;
  *((_QWORD *)v14 + 5) = v30;
  __p[0] = 0;
  __p[1] = 0;
  v30 = 0;
  v25 = v14 + 24;
  v26 = (std::__shared_weak_count *)v14;
  memset(v23, 0, sizeof(v23));
  v24 = 1065353216;
  v15 = MIL::IRTensorBufferValueType::MakeWithShapeAndRowAlignment(a1, a2, &v27, a4, (uint64_t *)&v25, (uint64_t *)v23);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v23);
  v16 = v26;
  if (v26)
  {
    v17 = (unint64_t *)&v26->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v28;
  if (v28)
  {
    v20 = (unint64_t *)&v28->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v15;
}

void sub_1E05BD81C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, void *__p, uint64_t a20)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  if (__p)
  {
    a20 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorBufferValueType::Make@<X0>(int a1@<W0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, _QWORD *a6@<X8>)
{
  _QWORD *result;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v10 = a1;
  std::make_unique[abi:ne180100]<MIL::IRTensorBufferValueTypeImpl,MIL::IRDataType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,decltype(nullptr),std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(&v10, a2, a3, a4, a5, &v9);
  result = (_QWORD *)operator new();
  v8 = v9;
  *result = &off_1EA998D40;
  result[1] = v8;
  *a6 = result;
  return result;
}

void sub_1E05BD8D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v12;

  v12 = a11;
  a11 = 0;
  if (v12)
    std::default_delete<MIL::IRTensorBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)&a11, v12);
  _Unwind_Resume(exception_object);
}

void std::make_unique[abi:ne180100]<MIL::IRTensorBufferValueTypeImpl,MIL::IRDataType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,decltype(nullptr),std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(int *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X4>, uint64_t *a5@<X5>, uint64_t *a6@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;

  v12 = operator new();
  v13 = v12;
  v14 = *a1;
  v15 = (std::__shared_weak_count *)a2[1];
  v37 = *a2;
  v38 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }
  v18 = (std::__shared_weak_count *)a3[1];
  v35 = *a3;
  v36 = v18;
  if (v18)
  {
    v19 = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  v21 = (std::__shared_weak_count *)a4[1];
  v33 = *a4;
  v34 = v21;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  MIL::IRTensorBufferValueTypeImpl::IRTensorBufferValueTypeImpl(v12, v14, (uint64_t)&v37, (uint64_t)&v35, 0, (uint64_t)&v33, a5);
  *a6 = v13;
  v24 = v34;
  if (v34)
  {
    v25 = (unint64_t *)&v34->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v27 = v36;
  if (v36)
  {
    v28 = (unint64_t *)&v36->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v30 = v38;
  if (v38)
  {
    v31 = (unint64_t *)&v38->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
}

void sub_1E05BDA88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  MEMORY[0x1E0C023A0](v13, 0x10E0C404C31E7C6);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRTensorBufferValueType::Make@<X0>(int a1@<W0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, _QWORD *a7@<X8>)
{
  _QWORD *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  v12 = a1;
  v11 = a4;
  std::make_unique[abi:ne180100]<MIL::IRTensorBufferValueTypeImpl,MIL::IRDataType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,MIL::IRProperty const*&,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(&v12, a2, a3, &v11, a5, a6, &v10);
  result = (_QWORD *)operator new();
  v9 = v10;
  *result = &off_1EA998D40;
  result[1] = v9;
  *a7 = result;
  return result;
}

void sub_1E05BDB2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11;

  v11 = a10;
  a10 = 0;
  if (v11)
    std::default_delete<MIL::IRTensorBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)&a10, v11);
  _Unwind_Resume(exception_object);
}

void std::make_unique[abi:ne180100]<MIL::IRTensorBufferValueTypeImpl,MIL::IRDataType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,MIL::IRProperty const*&,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(int *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v14;
  uint64_t v15;
  int v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  uint64_t v40;
  std::__shared_weak_count *v41;

  v14 = operator new();
  v15 = v14;
  v16 = *a1;
  v17 = (std::__shared_weak_count *)a2[1];
  v40 = *a2;
  v41 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldxr(p_shared_owners);
    while (__stxr(v19 + 1, p_shared_owners));
  }
  v20 = (std::__shared_weak_count *)a3[1];
  v38 = *a3;
  v39 = v20;
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  v23 = *a4;
  v24 = (std::__shared_weak_count *)a5[1];
  v36 = *a5;
  v37 = v24;
  if (v24)
  {
    v25 = (unint64_t *)&v24->__shared_owners_;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  MIL::IRTensorBufferValueTypeImpl::IRTensorBufferValueTypeImpl(v14, v16, (uint64_t)&v40, (uint64_t)&v38, v23, (uint64_t)&v36, a6);
  *a7 = v15;
  v27 = v37;
  if (v37)
  {
    v28 = (unint64_t *)&v37->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v30 = v39;
  if (v39)
  {
    v31 = (unint64_t *)&v39->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = v41;
  if (v41)
  {
    v34 = (unint64_t *)&v41->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
}

void sub_1E05BDCE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  MEMORY[0x1E0C023A0](v13, 0x10E0C404C31E7C6);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeScalar(void (***a1)(MIL::MILContextImpl *__hidden this), int a2)
{
  uint64_t v2;
  void *__p;
  void *v5;
  uint64_t v6;

  __p = 0;
  v5 = 0;
  v6 = 0;
  v2 = MIL::IRTensorBufferValueType::MakeWithShapeUsingDefaultStrides(a1, a2, (uint64_t *)&__p);
  if (__p)
  {
    v5 = __p;
    operator delete(__p);
  }
  return v2;
}

void sub_1E05BDD6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRTensorBufferValueType::GetDataType(MIL::IRTensorBufferValueType *this)
{
  return **((unsigned int **)this + 1);
}

uint64_t MIL::IRTensorBufferValueType::GetShape(MIL::IRTensorBufferValueType *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 8);
}

uint64_t MIL::IRTensorBufferValueType::GetStrides(MIL::IRTensorBufferValueTypeImpl **this)
{
  return MIL::IRTensorBufferValueTypeImpl::GetStrides(this[1]);
}

uint64_t MIL::IRTensorBufferValueTypeImpl::GetStrides(MIL::IRTensorBufferValueTypeImpl *this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = *((_QWORD *)this + 4);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Strides is not set for this tensor_buffer.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05BDDF8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::TryGetStrides(MIL::IRTensorBufferValueType *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 32);
}

uint64_t MIL::IRTensorBufferValueType::GetRowAlignmentInBytes(MIL::IRTensorBufferValueTypeImpl **this)
{
  return MIL::IRTensorBufferValueTypeImpl::GetRowAlignmentInBytes(this[1]);
}

uint64_t MIL::IRTensorBufferValueTypeImpl::GetRowAlignmentInBytes(MIL::IRTensorBufferValueTypeImpl *this)
{
  uint64_t result;
  std::runtime_error *exception;

  result = *((_QWORD *)this + 6);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Row-alignment is not set for this tensor_buffer.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05BDE70(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::TryGetRowAlignmentInBytes(MIL::IRTensorBufferValueType *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 48);
}

uint64_t MIL::IRTensorBufferValueType::GetInterleaveFactors(MIL::IRTensorBufferValueType *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 56);
}

uint64_t MIL::IRTensorBufferValueType::GetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  return MIL::IRTensorBufferValueTypeImpl::GetAttribute(*(_QWORD *)(a1 + 8), a2);
}

uint64_t MIL::IRTensorBufferValueTypeImpl::GetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result;
  std::logic_error *exception;

  result = MIL::IRTensorBufferValueTypeImpl::TryGetAttribute(a1, a2);
  if (!result)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Attribute does not exist.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  return result;
}

void sub_1E05BDEF4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::TryGetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  return MIL::IRTensorBufferValueTypeImpl::TryGetAttribute(*(_QWORD *)(a1 + 8), a2);
}

uint64_t MIL::IRTensorBufferValueTypeImpl::TryGetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;

  v2 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 72), a2);
  if (!v2)
    return 0;
  v3 = *((_QWORD *)v2 + 5);
  v4 = (std::__shared_weak_count *)*((_QWORD *)v2 + 6);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

unsigned __int8 *MIL::IRTensorBufferValueType::TryGetAttributeSharedPtr@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(*(_QWORD *)(a1 + 8) + 72), a2);
  if (result)
  {
    v5 = *((_QWORD *)result + 6);
    *a3 = *((_QWORD *)result + 5);
    a3[1] = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

uint64_t MIL::IRTensorBufferValueType::GetAttributes(MIL::IRTensorBufferValueType *this)
{
  return *((_QWORD *)this + 1) + 72;
}

BOOL MIL::IRTensorBufferValueType::IsScalar(MIL::IRTensorBufferValueType *this)
{
  return **(_QWORD **)(*((_QWORD *)this + 1) + 8) == *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 8) + 8);
}

uint64_t MIL::IRTensorBufferValueType::GetRank(MIL::IRTensorBufferValueType *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v1 + 24))
    return (uint64_t)(*(_QWORD *)(*(_QWORD *)(v1 + 8) + 8) - **(_QWORD **)(v1 + 8)) >> 3;
  else
    return -1;
}

uint64_t MIL::IRTensorBufferValueType::IsFixedRank(MIL::IRTensorBufferValueType *this)
{
  return *(unsigned __int8 *)(*((_QWORD *)this + 1) + 24);
}

uint64_t MIL::IRTensorBufferValueType::GetNumElements(MIL::IRTensorBufferValueType *this)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  v1 = *(_QWORD *)(*((_QWORD *)this + 1) + 8);
  v2 = *(_QWORD **)v1;
  v3 = *(_QWORD **)(v1 + 8);
  v4 = 1;
  while (v2 != v3)
  {
    v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v2 + 16))(*v2);
    if (!v5)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::range_error::range_error[abi:ne180100](exception, "Cannot determine number of elements in memory layout with unknown dimension.");
      __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
    }
    v4 *= (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
    ++v2;
  }
  return v4;
}

void sub_1E05BE0CC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const MIL::Text::SerializerOptions *MIL::IRTensorBufferValueType::ToString(MIL::IRTensorBufferValueType *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Type((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05BE16C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

void MIL::IRPixelBufferValueType::~IRPixelBufferValueType(MIL::IRPixelBufferValueType *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1EA998D90;
  v3 = *((_QWORD *)this + 1);
  v1 = (_QWORD *)((char *)this + 8);
  v2 = v3;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IRPixelBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v1, v2);
}

{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1EA998D90;
  v3 = *((_QWORD *)this + 1);
  v1 = (_QWORD *)((char *)this + 8);
  v2 = v3;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IRPixelBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v1, v2);
}

{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1EA998D90;
  v3 = *((_QWORD *)this + 1);
  v1 = (_QWORD *)((char *)this + 8);
  v2 = v3;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IRPixelBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v1, v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRPixelBufferValueType::IRPixelBufferValueType(_QWORD *this)
{
  *this = &off_1EA998D90;
  this[1] = 0;
  return this;
}

{
  *this = &off_1EA998D90;
  this[1] = 0;
  return this;
}

_QWORD *MIL::IRPixelBufferValueType::IRPixelBufferValueType(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998D90;
  result[1] = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998D90;
  result[1] = v2;
  return result;
}

uint64_t MIL::IRPixelBufferValueType::Make(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, uint64_t *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *__p[3];

  std::vector<MIL::IRDimension const*>::vector(__p, (a3[1] - *a3) >> 3);
  v6 = *a3;
  if (a3[1] != *a3)
  {
    v7 = 0;
    do
    {
      v8 = MIL::IRConstantDimension::Make(a1, *(MIL::MILContext **)(v6 + 8 * v7));
      *((_QWORD *)__p[0] + v7++) = v8;
      v6 = *a3;
    }
    while (v7 < (a3[1] - *a3) >> 3);
  }
  v9 = MIL::IRPixelBufferValueType::MakeWithShape(a1, a2, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v9;
}

void sub_1E05BE360(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRPixelBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, uint64_t a3)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  uint64_t v8;
  unint64_t v9;
  uint64_t v11[2];

  v6 = (std::__shared_weak_count *)operator new(0x30uLL);
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA999350;
  v6[1].std::__shared_count = *(std::__shared_count *)a3;
  v6[1].__shared_weak_owners_ = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v11[0] = (uint64_t)&v6[1];
  v11[1] = (uint64_t)v6;
  v8 = MIL::IRPixelBufferValueType::MakeWithShape(a1, a2, v11);
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  return v8;
}

void sub_1E05BE448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::Make(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t Int64Scalar;
  uint64_t v16;
  void *__p[3];
  void *v19[3];

  std::vector<MIL::IRDimension const*>::vector(v19, (a3[1] - *a3) >> 3);
  std::vector<MIL::IRProperty const*>::vector(__p, (a4[1] - *a4) >> 3);
  v10 = *a3;
  if (a3[1] != *a3)
  {
    v11 = 0;
    do
    {
      v12 = MIL::IRConstantDimension::Make(a1, *(MIL::MILContext **)(v10 + 8 * v11));
      *((_QWORD *)v19[0] + v11++) = v12;
      v10 = *a3;
    }
    while (v11 < (a3[1] - *a3) >> 3);
  }
  v13 = *a4;
  if (a4[1] != *a4)
  {
    v14 = 0;
    do
    {
      Int64Scalar = MIL::IRConstantProperty::MakeInt64Scalar(a1, *(MIL::MILContext **)(v13 + 8 * v14));
      *((_QWORD *)__p[0] + v14++) = Int64Scalar;
      v13 = *a4;
    }
    while (v14 < (a4[1] - *a4) >> 3);
  }
  v16 = MIL::IRPixelBufferValueType::MakeWithShape(a1, a2, (__int128 *)v19, (uint64_t)__p, a5);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v19[0])
  {
    v19[1] = v19[0];
    operator delete(v19[0]);
  }
  return v16;
}

void sub_1E05BE578(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRPixelBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, __int128 *a3, uint64_t a4, uint64_t *a5)
{
  char *v10;
  __int128 v11;
  char *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v24;
  std::__shared_weak_count *v25;
  char *v26;
  std::__shared_weak_count *v27;
  char *v28;
  std::__shared_weak_count *v29;

  v10 = (char *)operator new(0x30uLL);
  *((_QWORD *)v10 + 2) = 0;
  *(_QWORD *)v10 = &unk_1EA999350;
  *((_QWORD *)v10 + 1) = 0;
  v11 = *a3;
  *((_QWORD *)v10 + 5) = *((_QWORD *)a3 + 2);
  v29 = (std::__shared_weak_count *)v10;
  *(_OWORD *)(v10 + 24) = v11;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  v28 = v10 + 24;
  v12 = (char *)operator new(0x30uLL);
  *((_QWORD *)v12 + 2) = 0;
  *(_QWORD *)v12 = &unk_1EA9993A0;
  *((_QWORD *)v12 + 1) = 0;
  *(_OWORD *)(v12 + 24) = *(_OWORD *)a4;
  *((_QWORD *)v12 + 5) = *(_QWORD *)(a4 + 16);
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  v26 = v12 + 24;
  v27 = (std::__shared_weak_count *)v12;
  v24 = 0;
  v25 = 0;
  v13 = MIL::IRPixelBufferValueType::MakeWithShape(a1, a2, (uint64_t *)&v28, (uint64_t *)&v26, &v24, a5);
  v14 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v27;
  if (v27)
  {
    v18 = (unint64_t *)&v27->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v29;
  if (v29)
  {
    v21 = (unint64_t *)&v29->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  return v13;
}

void sub_1E05BE740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::MakeWithBytesPerRowNumSlices(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t Int64Scalar;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *__p[3];
  void *v24[3];
  void *v25[3];

  std::vector<MIL::IRDimension const*>::vector(v25, (a3[1] - *a3) >> 3);
  std::vector<MIL::IRProperty const*>::vector(v24, (a4[1] - *a4) >> 3);
  v12 = *a3;
  if (a3[1] != *a3)
  {
    v13 = 0;
    do
    {
      v14 = MIL::IRConstantDimension::Make(a1, *(MIL::MILContext **)(v12 + 8 * v13));
      *((_QWORD *)v25[0] + v13++) = v14;
      v12 = *a3;
    }
    while (v13 < (a3[1] - *a3) >> 3);
  }
  v15 = *a4;
  if (a4[1] != *a4)
  {
    v16 = 0;
    do
    {
      Int64Scalar = MIL::IRConstantProperty::MakeInt64Scalar(a1, *(MIL::MILContext **)(v15 + 8 * v16));
      *((_QWORD *)v24[0] + v16++) = Int64Scalar;
      v15 = *a4;
    }
    while (v16 < (a4[1] - *a4) >> 3);
  }
  std::vector<MIL::IRProperty const*>::vector(__p, (a5[1] - *a5) >> 3);
  v18 = *a5;
  if (a5[1] != *a5)
  {
    v19 = 0;
    do
    {
      v20 = MIL::IRConstantProperty::MakeInt64Scalar(a1, *(MIL::MILContext **)(v18 + 8 * v19));
      *((_QWORD *)__p[0] + v19++) = v20;
      v18 = *a5;
    }
    while (v19 < (a5[1] - *a5) >> 3);
  }
  v21 = MIL::IRPixelBufferValueType::MakeWithShapeBytesPerRowNumSlices(a1, a2, (__int128 *)v25, (std::__shared_weak_count_vtbl **)v24, (std::__shared_weak_count_vtbl **)__p, a6);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v24[0])
  {
    v24[1] = v24[0];
    operator delete(v24[0]);
  }
  if (v25[0])
  {
    v25[1] = v25[0];
    operator delete(v25[0]);
  }
  return v21;
}

void sub_1E05BE8F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRPixelBufferValueType::MakeWithShapeBytesPerRowNumSlices(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, __int128 *a3, std::__shared_weak_count_vtbl **a4, std::__shared_weak_count_vtbl **a5, uint64_t *a6)
{
  char *v12;
  __int128 v13;
  uint64_t v14;
  std::__shared_weak_count_vtbl *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  uint64_t v18;
  std::__shared_weak_count_vtbl *v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  _QWORD *v35;
  std::__shared_weak_count *v36;
  _QWORD *v37;
  std::__shared_weak_count *v38;
  char *v39;
  std::__shared_weak_count *v40;

  v12 = (char *)operator new(0x30uLL);
  *((_QWORD *)v12 + 2) = 0;
  *(_QWORD *)v12 = &unk_1EA999350;
  *((_QWORD *)v12 + 1) = 0;
  v13 = *a3;
  *((_QWORD *)v12 + 5) = *((_QWORD *)a3 + 2);
  v40 = (std::__shared_weak_count *)v12;
  *(_OWORD *)(v12 + 24) = v13;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  v39 = v12 + 24;
  v15 = *a4;
  v14 = (uint64_t)a4[1];
  if ((std::__shared_weak_count_vtbl *)v14 == *a4)
  {
    v37 = 0;
    v38 = 0;
  }
  else
  {
    v16 = (std::__shared_weak_count *)operator new(0x30uLL);
    v16->__shared_owners_ = 0;
    v16->__shared_weak_owners_ = 0;
    v16->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA9993A0;
    v16[1].__vftable = v15;
    v17 = (uint64_t)a4[2];
    v16[1].__shared_owners_ = v14;
    v16[1].__shared_weak_owners_ = v17;
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    v37 = &v16[1].__vftable;
    v38 = v16;
  }
  v19 = *a5;
  v18 = (uint64_t)a5[1];
  if ((std::__shared_weak_count_vtbl *)v18 == *a5)
  {
    v35 = 0;
    v36 = 0;
  }
  else
  {
    v20 = (std::__shared_weak_count *)operator new(0x30uLL);
    v20->__shared_owners_ = 0;
    v20->__shared_weak_owners_ = 0;
    v20->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA9993A0;
    v20[1].__vftable = v19;
    v21 = (uint64_t)a5[2];
    v20[1].__shared_owners_ = v18;
    v20[1].__shared_weak_owners_ = v21;
    *a5 = 0;
    a5[1] = 0;
    a5[2] = 0;
    v35 = &v20[1].__vftable;
    v36 = v20;
  }
  v22 = MIL::IRPixelBufferValueType::MakeWithShape(a1, a2, (uint64_t *)&v39, (uint64_t *)&v37, (uint64_t *)&v35, a6);
  v23 = v36;
  if ((std::__shared_weak_count_vtbl *)v18 == v19)
  {
    if (!v36)
      goto LABEL_17;
    p_shared_owners = (unint64_t *)&v36->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
  }
  else
  {
    if (!v36)
      goto LABEL_17;
    v24 = (unint64_t *)&v36->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
  }
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
LABEL_17:
  v27 = v38;
  if ((std::__shared_weak_count_vtbl *)v14 == v15)
  {
    if (!v38)
      goto LABEL_27;
    v30 = (unint64_t *)&v38->__shared_owners_;
    do
      v29 = __ldaxr(v30);
    while (__stlxr(v29 - 1, v30));
  }
  else
  {
    if (!v38)
      goto LABEL_27;
    v28 = (unint64_t *)&v38->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
  }
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
LABEL_27:
  v31 = v40;
  if (v40)
  {
    v32 = (unint64_t *)&v40->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  return v22;
}

void sub_1E05BEB84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, uint64_t *a3)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _OWORD v14[2];
  int v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;

  v3 = a3[1];
  v18 = *a3;
  v19 = (std::__shared_weak_count *)v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v16 = 0;
  v17 = 0;
  memset(v14, 0, sizeof(v14));
  v15 = 1065353216;
  v6 = MIL::IRPixelBufferValueType::MakeWithShape(a1, a2, &v18, &v16, (uint64_t *)v14);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v14);
  v7 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = v19;
  if (v19)
  {
    v11 = (unint64_t *)&v19->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return v6;
}

void sub_1E05BEC9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;

  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v15 - 32);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, __int128 *a3, uint64_t *a4)
{
  char *v8;
  __int128 v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  char *v15;
  std::__shared_weak_count *v16;

  v8 = (char *)operator new(0x30uLL);
  *((_QWORD *)v8 + 2) = 0;
  *(_QWORD *)v8 = &unk_1EA999350;
  *((_QWORD *)v8 + 1) = 0;
  v9 = *a3;
  *((_QWORD *)v8 + 5) = *((_QWORD *)a3 + 2);
  v16 = (std::__shared_weak_count *)v8;
  *(_OWORD *)(v8 + 24) = v9;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  v15 = v8 + 24;
  v10 = MIL::IRPixelBufferValueType::MakeWithShape(a1, a2, (uint64_t *)&v15, a4);
  v11 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return v10;
}

void sub_1E05BED88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::MakeWithShapeNumSlices(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, __int128 *a3, uint64_t a4, uint64_t *a5)
{
  char *v10;
  __int128 v11;
  char *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  char *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  char *v28;
  std::__shared_weak_count *v29;

  v10 = (char *)operator new(0x30uLL);
  *((_QWORD *)v10 + 2) = 0;
  *(_QWORD *)v10 = &unk_1EA999350;
  *((_QWORD *)v10 + 1) = 0;
  v11 = *a3;
  *((_QWORD *)v10 + 5) = *((_QWORD *)a3 + 2);
  v29 = (std::__shared_weak_count *)v10;
  *(_OWORD *)(v10 + 24) = v11;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  v27 = 0;
  v28 = v10 + 24;
  v26 = 0;
  v12 = (char *)operator new(0x30uLL);
  *((_QWORD *)v12 + 2) = 0;
  *(_QWORD *)v12 = &unk_1EA9993A0;
  *((_QWORD *)v12 + 1) = 0;
  *(_OWORD *)(v12 + 24) = *(_OWORD *)a4;
  *((_QWORD *)v12 + 5) = *(_QWORD *)(a4 + 16);
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  v24 = v12 + 24;
  v25 = (std::__shared_weak_count *)v12;
  v13 = MIL::IRPixelBufferValueType::MakeWithShape(a1, a2, (uint64_t *)&v28, &v26, (uint64_t *)&v24, a5);
  v14 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v27;
  if (v27)
  {
    v18 = (unint64_t *)&v27->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v29;
  if (v29)
  {
    v21 = (unint64_t *)&v29->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  return v13;
}

void sub_1E05BEF28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MIL::IRPixelBufferValueType::Make(unsigned int a1@<W0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, _QWORD *a5@<X8>)
{
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;

  v5 = a2[1];
  v24 = *a2;
  v25 = (std::__shared_weak_count *)v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a3[1];
  v22 = *a3;
  v23 = (std::__shared_weak_count *)v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v20 = 0;
  v21 = 0;
  MIL::IRPixelBufferValueType::Make(a1, &v24, &v22, &v20, a4, a5);
  v11 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v23;
  if (v23)
  {
    v15 = (unint64_t *)&v23->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v25;
  if (v25)
  {
    v18 = (unint64_t *)&v25->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void sub_1E05BF074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

_QWORD *MIL::IRPixelBufferValueType::Make@<X0>(unsigned int a1@<W0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, _QWORD *a6@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;

  v15 = a1;
  v14 = 0;
  v7 = *a4;
  if (*a3)
  {
    if (v7)
      std::make_unique[abi:ne180100]<MIL::IRPixelBufferValueTypeImpl,MIL::IRPixelFormatType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(&v15, a2, a3, a4, a5, &v13);
    else
      std::make_unique[abi:ne180100]<MIL::IRPixelBufferValueTypeImpl,MIL::IRPixelFormatType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::nullopt_t const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(&v15, a2, a3, a5, &v13);
  }
  else if (v7)
  {
    std::make_unique[abi:ne180100]<MIL::IRPixelBufferValueTypeImpl,MIL::IRPixelFormatType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::nullopt_t const&,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(&v15, a2, a4, a5, &v13);
  }
  else
  {
    std::make_unique[abi:ne180100]<MIL::IRPixelBufferValueTypeImpl,MIL::IRPixelFormatType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::nullopt_t const&,std::nullopt_t const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(&v15, a2, a5, &v13);
  }
  v9 = v13;
  v8 = v14;
  v13 = 0;
  v14 = v9;
  if (v8)
  {
    std::default_delete<MIL::IRPixelBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)&v14, v8);
    v10 = v13;
    v13 = 0;
    if (v10)
      std::default_delete<MIL::IRPixelBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)&v13, v10);
  }
  result = (_QWORD *)operator new();
  v12 = v14;
  *result = &off_1EA998D90;
  result[1] = v12;
  *a6 = result;
  return result;
}

void sub_1E05BF184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v12;

  v12 = a11;
  a11 = 0;
  if (v12)
    std::default_delete<MIL::IRPixelBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)&a11, v12);
  _Unwind_Resume(exception_object);
}

void std::make_unique[abi:ne180100]<MIL::IRPixelBufferValueTypeImpl,MIL::IRPixelFormatType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::nullopt_t const&,std::nullopt_t const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(unsigned int *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X4>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  char v23[8];
  std::__shared_weak_count *v24;
  char v25;
  char v26[8];
  std::__shared_weak_count *v27;
  char v28;
  uint64_t v29;
  std::__shared_weak_count *v30;

  v8 = operator new();
  v9 = v8;
  v10 = *a1;
  v11 = (std::__shared_weak_count *)a2[1];
  v29 = *a2;
  v30 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  v26[0] = 0;
  v28 = 0;
  v23[0] = 0;
  v25 = 0;
  MIL::IRPixelBufferValueTypeImpl::IRPixelBufferValueTypeImpl(v8, v10, (uint64_t)&v29, (uint64_t)v26, (uint64_t)v23, a3);
  *a4 = v9;
  if (v25)
  {
    v14 = v24;
    if (v24)
    {
      v15 = (unint64_t *)&v24->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
  if (v28)
  {
    v17 = v27;
    if (v27)
    {
      v18 = (unint64_t *)&v27->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
  }
  v20 = v30;
  if (v30)
  {
    v21 = (unint64_t *)&v30->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1E05BF318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, int a12, char a13, uint64_t a14, char a15, int a16, char a17)
{
  uint64_t v17;

  if (a11)
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  if (a15)
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  MEMORY[0x1E0C023A0](v17, 0x10A2C40EFD47E9ALL);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRPixelBufferValueTypeImpl,MIL::IRPixelFormatType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::nullopt_t const&,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(unsigned int *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X3>, uint64_t *a4@<X4>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  char v30;
  char v31[8];
  std::__shared_weak_count *v32;
  char v33;
  uint64_t v34;
  std::__shared_weak_count *v35;

  v10 = operator new();
  v11 = v10;
  v12 = *a1;
  v13 = (std::__shared_weak_count *)a2[1];
  v34 = *a2;
  v35 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  v31[0] = 0;
  v33 = 0;
  v16 = (std::__shared_weak_count *)a3[1];
  v28 = *a3;
  v29 = v16;
  if (v16)
  {
    v17 = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v30 = 1;
  MIL::IRPixelBufferValueTypeImpl::IRPixelBufferValueTypeImpl(v10, v12, (uint64_t)&v34, (uint64_t)v31, (uint64_t)&v28, a4);
  *a5 = v11;
  if (v30)
  {
    v19 = v29;
    if (v29)
    {
      v20 = (unint64_t *)&v29->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
  if (v33)
  {
    v22 = v32;
    if (v32)
    {
      v23 = (unint64_t *)&v32->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
  }
  v25 = v35;
  if (v35)
  {
    v26 = (unint64_t *)&v35->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
}

void sub_1E05BF4EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, int a12, char a13, uint64_t a14, char a15, int a16, char a17)
{
  uint64_t v17;

  if (a11)
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  if (a15)
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  MEMORY[0x1E0C023A0](v17, 0x10A2C40EFD47E9ALL);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRPixelBufferValueTypeImpl,MIL::IRPixelFormatType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::nullopt_t const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(unsigned int *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X4>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  char v28[8];
  std::__shared_weak_count *v29;
  char v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  char v33;
  uint64_t v34;
  std::__shared_weak_count *v35;

  v10 = operator new();
  v11 = v10;
  v12 = *a1;
  v13 = (std::__shared_weak_count *)a2[1];
  v34 = *a2;
  v35 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  v16 = (std::__shared_weak_count *)a3[1];
  v31 = *a3;
  v32 = v16;
  if (v16)
  {
    v17 = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v33 = 1;
  v28[0] = 0;
  v30 = 0;
  MIL::IRPixelBufferValueTypeImpl::IRPixelBufferValueTypeImpl(v10, v12, (uint64_t)&v34, (uint64_t)&v31, (uint64_t)v28, a4);
  *a5 = v11;
  if (v30)
  {
    v19 = v29;
    if (v29)
    {
      v20 = (unint64_t *)&v29->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
  if (v33)
  {
    v22 = v32;
    if (v32)
    {
      v23 = (unint64_t *)&v32->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
  }
  v25 = v35;
  if (v35)
  {
    v26 = (unint64_t *)&v35->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
}

void sub_1E05BF6C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, int a12, char a13, uint64_t a14, char a15, int a16, char a17)
{
  uint64_t v17;

  if (a11)
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  if (a15)
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  MEMORY[0x1E0C023A0](v17, 0x10A2C40EFD47E9ALL);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRPixelBufferValueTypeImpl,MIL::IRPixelFormatType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(unsigned int *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  char v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  char v38;
  uint64_t v39;
  std::__shared_weak_count *v40;

  v12 = operator new();
  v13 = v12;
  v14 = *a1;
  v15 = (std::__shared_weak_count *)a2[1];
  v39 = *a2;
  v40 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }
  v18 = (std::__shared_weak_count *)a3[1];
  v36 = *a3;
  v37 = v18;
  if (v18)
  {
    v19 = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  v38 = 1;
  v21 = (std::__shared_weak_count *)a4[1];
  v33 = *a4;
  v34 = v21;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  v35 = 1;
  MIL::IRPixelBufferValueTypeImpl::IRPixelBufferValueTypeImpl(v12, v14, (uint64_t)&v39, (uint64_t)&v36, (uint64_t)&v33, a5);
  *a6 = v13;
  if (v35)
  {
    v24 = v34;
    if (v34)
    {
      v25 = (unint64_t *)&v34->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  if (v38)
  {
    v27 = v37;
    if (v37)
    {
      v28 = (unint64_t *)&v37->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
  }
  v30 = v40;
  if (v40)
  {
    v31 = (unint64_t *)&v40->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
}

void sub_1E05BF8BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, int a12, char a13, uint64_t a14, char a15, int a16, char a17)
{
  uint64_t v17;

  if (a11)
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  if (a15)
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  MEMORY[0x1E0C023A0](v17, 0x10A2C40EFD47E9ALL);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::GetPixelFormatType(MIL::IRPixelBufferValueType *this)
{
  return **((unsigned int **)this + 1);
}

uint64_t MIL::IRPixelBufferValueType::GetShape(MIL::IRPixelBufferValueType *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 8);
}

uint64_t MIL::IRPixelBufferValueType::GetRank(MIL::IRPixelBufferValueType *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v1 + 24))
    return (uint64_t)(*(_QWORD *)(*(_QWORD *)(v1 + 8) + 8) - **(_QWORD **)(v1 + 8)) >> 3;
  else
    return -1;
}

uint64_t MIL::IRPixelBufferValueType::IsFixedRank(MIL::IRPixelBufferValueType *this)
{
  return *(unsigned __int8 *)(*((_QWORD *)this + 1) + 24);
}

uint64_t MIL::IRPixelBufferValueType::GetBytesPerRow(MIL::IRPixelBufferValueTypeImpl **this)
{
  return MIL::IRPixelBufferValueTypeImpl::GetBytesPerRow(this[1]);
}

uint64_t MIL::IRPixelBufferValueTypeImpl::GetBytesPerRow(MIL::IRPixelBufferValueTypeImpl *this)
{
  uint64_t result;
  std::logic_error *exception;

  if (!*((_BYTE *)this + 48) || (result = *((_QWORD *)this + 4)) == 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "BytesPerRow is not set for this pixel buffer.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  return result;
}

void sub_1E05BF9B4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::TryGetBytesPerRow(MIL::IRPixelBufferValueType *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v1 + 48))
    return *(_QWORD *)(v1 + 32);
  else
    return 0;
}

uint64_t MIL::IRPixelBufferValueType::GetNumSlices(MIL::IRPixelBufferValueTypeImpl **this)
{
  return MIL::IRPixelBufferValueTypeImpl::GetNumSlices(this[1]);
}

uint64_t MIL::IRPixelBufferValueTypeImpl::GetNumSlices(MIL::IRPixelBufferValueTypeImpl *this)
{
  uint64_t result;
  std::runtime_error *exception;

  if (!*((_BYTE *)this + 72) || (result = *((_QWORD *)this + 7)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "NumSlices is not set for this pixel buffer.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05BFA44(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::TryGetNumSlices(MIL::IRPixelBufferValueType *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v1 + 72))
    return *(_QWORD *)(v1 + 56);
  else
    return 0;
}

uint64_t MIL::IRPixelBufferValueType::GetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  return MIL::IRPixelBufferValueTypeImpl::GetAttribute(*(_QWORD *)(a1 + 8), a2);
}

uint64_t MIL::IRPixelBufferValueTypeImpl::GetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result;
  std::logic_error *exception;

  result = MIL::IRPixelBufferValueTypeImpl::TryGetAttribute(a1, a2);
  if (!result)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Attribute does not exist.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  return result;
}

void sub_1E05BFACC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::TryGetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  return MIL::IRPixelBufferValueTypeImpl::TryGetAttribute(*(_QWORD *)(a1 + 8), a2);
}

uint64_t MIL::IRPixelBufferValueTypeImpl::TryGetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;

  v2 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 80), a2);
  if (!v2)
    return 0;
  v3 = *((_QWORD *)v2 + 5);
  v4 = (std::__shared_weak_count *)*((_QWORD *)v2 + 6);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

unsigned __int8 *MIL::IRPixelBufferValueType::TryGetAttributeSharedPtr@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(*(_QWORD *)(a1 + 8) + 80), a2);
  if (result)
  {
    v5 = *((_QWORD *)result + 6);
    *a3 = *((_QWORD *)result + 5);
    a3[1] = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

uint64_t MIL::IRPixelBufferValueType::GetAttributes(MIL::IRPixelBufferValueType *this)
{
  return *((_QWORD *)this + 1) + 80;
}

uint64_t MIL::IRPixelBufferValueType::GetNumPlanes(MIL::IRPixelBufferValueType *this)
{
  return MIL::GetNumPlanesForFormat(**((_DWORD **)this + 1));
}

uint64_t MIL::IRPixelBufferValueType::GetNumElements(MIL::IRPixelBufferValueType *this)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  std::logic_error *exception;
  struct type_info *v9;
  void (*v10)(void *);

  if (MIL::GetNumPlanesForFormat(**((_DWORD **)this + 1)) != 1)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Number of elements cannot be computed for multi-planar images yet.");
    v9 = (struct type_info *)off_1EA992598;
    v10 = (void (*)(void *))MEMORY[0x1E0DE4360];
LABEL_8:
    __cxa_throw(exception, v9, v10);
  }
  v2 = *(_QWORD *)(*((_QWORD *)this + 1) + 8);
  v3 = *(_QWORD **)v2;
  v4 = *(_QWORD **)(v2 + 8);
  v5 = 1;
  while (v3 != v4)
  {
    v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v3 + 16))(*v3);
    if (!v6)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::range_error::range_error[abi:ne180100]((std::runtime_error *)exception, "Cannot determine number of elements in memory layout with unknown dimension.");
      v9 = (struct type_info *)off_1EA992578;
      v10 = (void (*)(void *))MEMORY[0x1E0DE42B0];
      goto LABEL_8;
    }
    v5 *= (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
    ++v3;
  }
  return v5;
}

void sub_1E05BFCA8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const MIL::Text::SerializerOptions *MIL::IRPixelBufferValueType::ToString(MIL::IRPixelBufferValueType *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Type((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05BFD4C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

void MIL::IRCircularBufferValueType::~IRCircularBufferValueType(MIL::IRCircularBufferValueType *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1EA998DE0;
  v3 = *((_QWORD *)this + 1);
  v1 = (_QWORD *)((char *)this + 8);
  v2 = v3;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IRCircularBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v1, v2);
}

{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1EA998DE0;
  v3 = *((_QWORD *)this + 1);
  v1 = (_QWORD *)((char *)this + 8);
  v2 = v3;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IRCircularBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v1, v2);
}

{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1EA998DE0;
  v3 = *((_QWORD *)this + 1);
  v1 = (_QWORD *)((char *)this + 8);
  v2 = v3;
  *v1 = 0;
  if (v3)
    std::default_delete<MIL::IRCircularBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v1, v2);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRCircularBufferValueType::IRCircularBufferValueType(_QWORD *this)
{
  *this = &off_1EA998DE0;
  this[1] = 0;
  return this;
}

{
  *this = &off_1EA998DE0;
  this[1] = 0;
  return this;
}

_QWORD *MIL::IRCircularBufferValueType::IRCircularBufferValueType(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998DE0;
  result[1] = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998DE0;
  result[1] = v2;
  return result;
}

_QWORD *MIL::IRCircularBufferValueType::Make@<X0>(int a1@<W0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, _QWORD *a6@<X5>, uint64_t *a7@<X6>, _QWORD *a8@<X8>)
{
  _QWORD *result;
  uint64_t *v10;
  uint64_t *v11;
  _QWORD *v12;
  int v13;

  v13 = a1;
  v12 = a6;
  std::make_unique[abi:ne180100]<MIL::IRCircularBufferValueTypeImpl,MIL::IRDataType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,MIL::IRProperty const*&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(&v13, a2, a3, a4, a5, &v12, a7, &v11);
  result = (_QWORD *)operator new();
  v10 = v11;
  *result = &off_1EA998DE0;
  result[1] = v10;
  *a8 = result;
  return result;
}

void sub_1E05BFF00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11;

  v11 = a10;
  a10 = 0;
  if (v11)
    std::default_delete<MIL::IRCircularBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)&a10, v11);
  _Unwind_Resume(exception_object);
}

void std::make_unique[abi:ne180100]<MIL::IRCircularBufferValueTypeImpl,MIL::IRDataType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,MIL::IRProperty const*&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(int *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, _QWORD **a6@<X5>, uint64_t *a7@<X6>, uint64_t **a8@<X8>)
{
  uint64_t *v16;
  uint64_t *v17;
  int v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  std::__shared_weak_count *v50;

  v16 = (uint64_t *)operator new();
  v17 = v16;
  v18 = *a1;
  v19 = (std::__shared_weak_count *)a2[1];
  v49 = *a2;
  v50 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v21 = __ldxr(p_shared_owners);
    while (__stxr(v21 + 1, p_shared_owners));
  }
  v22 = a3[1];
  v47 = *a3;
  v48 = (std::__shared_weak_count *)v22;
  if (v22)
  {
    v23 = (unint64_t *)(v22 + 8);
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  v25 = a4[1];
  v45 = *a4;
  v46 = (std::__shared_weak_count *)v25;
  if (v25)
  {
    v26 = (unint64_t *)(v25 + 8);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  v28 = a5[1];
  v43 = *a5;
  v44 = (std::__shared_weak_count *)v28;
  if (v28)
  {
    v29 = (unint64_t *)(v28 + 8);
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
  }
  MIL::IRCircularBufferValueTypeImpl::IRCircularBufferValueTypeImpl(v16, v18, (uint64_t)&v49, &v47, &v45, &v43, *a6, a7);
  *a8 = v17;
  v31 = v44;
  if (v44)
  {
    v32 = (unint64_t *)&v44->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v46;
  if (v46)
  {
    v35 = (unint64_t *)&v46->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = v48;
  if (v48)
  {
    v38 = (unint64_t *)&v48->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  v40 = v50;
  if (v50)
  {
    v41 = (unint64_t *)&v50->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
}

void sub_1E05C0124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15)
{
  uint64_t v15;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  MEMORY[0x1E0C023A0](v15, 0x60C40CD5974ACLL);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCircularBufferValueType::Make(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, unsigned int a6, MIL::MILContext *a7, uint64_t *a8)
{
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t Int64Scalar;
  uint64_t v22;
  unint64_t v23;
  uint64_t UInt8Scalar;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  void *__p[3];
  void *v30[3];
  void *v31[3];

  std::vector<MIL::IRDimension const*>::vector(v31, (a3[1] - *a3) >> 3);
  std::vector<MIL::IRProperty const*>::vector(v30, (a4[1] - *a4) >> 3);
  std::vector<MIL::IRProperty const*>::vector(__p, a5[1] - *a5);
  v16 = *a3;
  if (a3[1] != *a3)
  {
    v17 = 0;
    do
    {
      v18 = MIL::IRConstantDimension::Make(a1, *(MIL::MILContext **)(v16 + 8 * v17));
      *((_QWORD *)v31[0] + v17++) = v18;
      v16 = *a3;
    }
    while (v17 < (a3[1] - *a3) >> 3);
  }
  v19 = *a4;
  if (a4[1] != *a4)
  {
    v20 = 0;
    do
    {
      Int64Scalar = MIL::IRConstantProperty::MakeInt64Scalar(a1, *(MIL::MILContext **)(v19 + 8 * v20));
      *((_QWORD *)v30[0] + v20++) = Int64Scalar;
      v19 = *a4;
    }
    while (v20 < (a4[1] - *a4) >> 3);
  }
  v22 = *a5;
  if (a5[1] != *a5)
  {
    v23 = 0;
    do
    {
      UInt8Scalar = MIL::IRConstantProperty::MakeUInt8Scalar(a1, (MIL::MILContext *)*(unsigned __int8 *)(v22 + v23));
      *((_QWORD *)__p[0] + v23++) = UInt8Scalar;
      v22 = *a5;
    }
    while (v23 < a5[1] - *a5);
  }
  v25 = (_QWORD *)MIL::IRConstantProperty::MakeInt64Scalar(a1, (MIL::MILContext *)a6);
  v26 = MIL::IRConstantDimension::Make(a1, a7);
  v27 = MIL::IRCircularBufferValueType::MakeWithShape(a1, a2, (uint64_t)v31, (uint64_t)v30, (uint64_t)__p, v25, v26, a8);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v30[0])
  {
    v30[1] = v30[0];
    operator delete(v30[0]);
  }
  if (v31[0])
  {
    v31[1] = v31[0];
    operator delete(v31[0]);
  }
  return v27;
}

void sub_1E05C0320(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRCircularBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, uint64_t a7, uint64_t *a8)
{
  std::__shared_weak_count *v16;
  std::__shared_count v17;
  char *v18;
  char *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  char *v31;
  std::__shared_weak_count *v32;
  char *v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  std::__shared_weak_count *v36;

  v16 = (std::__shared_weak_count *)operator new(0x30uLL);
  v16->__shared_weak_owners_ = 0;
  v16->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA999350;
  v16->__shared_owners_ = 0;
  v17 = *(std::__shared_count *)a3;
  v16[1].__shared_weak_owners_ = *(_QWORD *)(a3 + 16);
  v36 = v16;
  v16[1].std::__shared_count = v17;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v35 = v16 + 1;
  v18 = (char *)operator new(0x30uLL);
  *((_QWORD *)v18 + 2) = 0;
  *(_QWORD *)v18 = &unk_1EA9993A0;
  *((_QWORD *)v18 + 1) = 0;
  *(_OWORD *)(v18 + 24) = *(_OWORD *)a4;
  *((_QWORD *)v18 + 5) = *(_QWORD *)(a4 + 16);
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  v33 = v18 + 24;
  v34 = (std::__shared_weak_count *)v18;
  v19 = (char *)operator new(0x30uLL);
  *((_QWORD *)v19 + 1) = 0;
  *((_QWORD *)v19 + 2) = 0;
  *(_QWORD *)v19 = &unk_1EA9993A0;
  *(_OWORD *)(v19 + 24) = *(_OWORD *)a5;
  *((_QWORD *)v19 + 5) = *(_QWORD *)(a5 + 16);
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(a5 + 8) = 0;
  *(_QWORD *)(a5 + 16) = 0;
  v31 = v19 + 24;
  v32 = (std::__shared_weak_count *)v19;
  v20 = MIL::IRCircularBufferValueType::MakeWithShape(a1, a2, &v35, (uint64_t *)&v33, (uint64_t *)&v31, a6, a7, a8);
  v21 = v32;
  if (v32)
  {
    p_shared_owners = (unint64_t *)&v32->__shared_owners_;
    do
      v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = v34;
  if (v34)
  {
    v25 = (unint64_t *)&v34->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v27 = v36;
  if (v36)
  {
    v28 = (unint64_t *)&v36->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  return v20;
}

void sub_1E05C054C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCircularBufferValueType::GetDataType(MIL::IRCircularBufferValueType *this)
{
  return **(unsigned int **)(*((_QWORD *)this + 1) + 24);
}

uint64_t MIL::IRCircularBufferValueType::GetShape(MIL::IRCircularBufferValueType *this)
{
  return *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 24) + 8);
}

uint64_t MIL::IRCircularBufferValueType::GetSliceShape(MIL::IRCircularBufferValueType *this)
{
  return **((_QWORD **)this + 1);
}

uint64_t MIL::IRCircularBufferValueType::GetStrides(MIL::IRCircularBufferValueType *this)
{
  return MIL::IRTensorBufferValueTypeImpl::GetStrides(*(MIL::IRTensorBufferValueTypeImpl **)(*((_QWORD *)this + 1) + 24));
}

uint64_t MIL::IRCircularBufferValueType::IsSliceFixedRank(MIL::IRCircularBufferValueType *this)
{
}

uint64_t `anonymous namespace'::IsShapeFixedRank(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  int v4;
  std::runtime_error *exception;

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  v3 = 1;
  while (v1 != v2)
  {
    v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 32))(*v1) ^ 1;
    if ((v4 & 1) == 0 && (v3 & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "A shape may contain only one variadic dimension.");
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
    }
    v3 = v4 & v3;
    ++v1;
  }
  return v3;
}

void sub_1E05C0650(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCircularBufferValueType::IsFixedRank(MIL::IRCircularBufferValueType *this)
{
}

uint64_t MIL::IRCircularBufferValueType::GetInterleaveFactors(MIL::IRCircularBufferValueType *this)
{
  return *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 24) + 56);
}

uint64_t MIL::IRCircularBufferValueType::GetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  return MIL::IRCircularBufferValueTypeImpl::GetAttribute(*(_QWORD *)(a1 + 8), a2);
}

uint64_t MIL::IRCircularBufferValueTypeImpl::GetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result;
  std::logic_error *exception;

  result = MIL::IRCircularBufferValueTypeImpl::TryGetAttribute(a1, a2);
  if (!result)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Attribute does not exist.");
    __cxa_throw(exception, (struct type_info *)off_1EA992588, MEMORY[0x1E0DE42E0]);
  }
  return result;
}

void sub_1E05C06DC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCircularBufferValueType::TryGetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  return MIL::IRCircularBufferValueTypeImpl::TryGetAttribute(*(_QWORD *)(a1 + 8), a2);
}

uint64_t MIL::IRCircularBufferValueTypeImpl::TryGetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;

  v2 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(*(_QWORD *)(a1 + 24) + 72), a2);
  if (!v2)
    return 0;
  v3 = *((_QWORD *)v2 + 5);
  v4 = (std::__shared_weak_count *)*((_QWORD *)v2 + 6);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

unsigned __int8 *MIL::IRCircularBufferValueType::TryGetAttributeSharedPtr@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  return MIL::IRCircularBufferValueTypeImpl::TryGetAttributeSharedPtr(*(_QWORD *)(a1 + 8), a2, a3);
}

unsigned __int8 *MIL::IRCircularBufferValueTypeImpl::TryGetAttributeSharedPtr@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(*(_QWORD *)(a1 + 24) + 72), a2);
  if (result)
  {
    v5 = *((_QWORD *)result + 6);
    *a3 = *((_QWORD *)result + 5);
    a3[1] = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

uint64_t MIL::IRCircularBufferValueType::GetAttributes(MIL::IRCircularBufferValueType *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 24) + 72;
}

uint64_t MIL::IRCircularBufferValueType::GetWrapDim(MIL::IRCircularBufferValueType *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 16);
}

uint64_t MIL::IRCircularBufferValueType::GetNumElements(MIL::IRCircularBufferValueType *this)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  std::runtime_error *exception;

  v1 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 24) + 8);
  v2 = *(_QWORD **)v1;
  v3 = *(_QWORD **)(v1 + 8);
  v4 = 1;
  while (v2 != v3)
  {
    v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v2 + 16))(*v2);
    if (!v5)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::range_error::range_error[abi:ne180100](exception, "Cannot determine number of elements in memory layout with unknown dimension.");
      __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
    }
    v4 *= (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
    ++v2;
  }
  return v4;
}

void sub_1E05C0888(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const MIL::Text::SerializerOptions *MIL::IRCircularBufferValueType::ToString(MIL::IRCircularBufferValueType *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Type((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05C0928(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::IRCircularBufferValueType::GetRank(MIL::IRCircularBufferValueType *this)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v1 = (_QWORD *)*((_QWORD *)this + 1);
  v2 = *(_QWORD **)(v1[3] + 8);
  v3 = v2[1] - *v2;
  if (!v3)
    v3 = *(_QWORD *)(*v1 + 8) - *(_QWORD *)*v1;
  v4 = v3 >> 3;
    return v4;
  else
    return -1;
}

void MIL::IRStateValueType::~IRStateValueType(MIL::IRStateValueType *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA998E30;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0x60C4044C4A2DFLL);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA998E30;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0x60C4044C4A2DFLL);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1EA998E30;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    MEMORY[0x1E0C023A0](v2, 0x60C4044C4A2DFLL);
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::IRStateValueType::IRStateValueType(_QWORD *this)
{
  *this = &off_1EA998E30;
  this[1] = 0;
  return this;
}

{
  *this = &off_1EA998E30;
  this[1] = 0;
  return this;
}

_QWORD *MIL::IRStateValueType::IRStateValueType(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998E30;
  result[1] = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = &off_1EA998E30;
  result[1] = v2;
  return result;
}

_QWORD *MIL::IRStateValueType::Make@<X0>(MIL::IRStateValueType *this@<X0>, _QWORD *a2@<X8>)
{
  const void **v5;
  _QWORD *result;

  v5 = (const void **)operator new();
  MIL::IRStateValueTypeImpl::IRStateValueTypeImpl(v5, this);
  result = (_QWORD *)operator new();
  *result = &off_1EA998E30;
  result[1] = v5;
  *a2 = result;
  return result;
}

void sub_1E05C0B58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRStateValueType::GetWrappedType(MIL::IRStateValueType *this)
{
  return **((_QWORD **)this + 1);
}

uint64_t MIL::IRStateValueType::GetNumElements(MIL::IRStateValueType *this)
{
  return (*(uint64_t (**)(_QWORD))(***((_QWORD ***)this + 1) + 16))(**((_QWORD **)this + 1));
}

const MIL::Text::SerializerOptions *MIL::IRStateValueType::ToString(MIL::IRStateValueType *this)
{
  double v2;
  MIL::Text::BasicSerializer *v3;
  const MIL::Text::SerializerOptions *result;
  _BYTE v5[392];
  const MIL::Text::SerializerOptions *v6;

  v2 = MIL::Text::SerializerOptions::Make((uint64_t *)&v6);
  (*(void (**)(const MIL::Text::SerializerOptions *, uint64_t, double))(*(_QWORD *)v6 + 112))(v6, 4, v2);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, v6);
  v3 = MIL::Text::BasicSerializer::Type((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v3);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
  result = v6;
  v6 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05C0C2C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::IRConstantDimensionImpl::~IRConstantDimensionImpl(_anonymous_namespace_::IRConstantDimensionImpl *this)
{
  JUMPOUT(0x1E0C023A0);
}

uint64_t `anonymous namespace'::IRConstantDimensionImpl::GetSize(_anonymous_namespace_::IRConstantDimensionImpl *this)
{
  return *((_QWORD *)this + 1);
}

void `anonymous namespace'::IRUnknownDimensionImpl::~IRUnknownDimensionImpl(_anonymous_namespace_::IRUnknownDimensionImpl *this)
{
  JUMPOUT(0x1E0C023A0);
}

uint64_t `anonymous namespace'::IRUnknownDimensionImpl::IsVariadic(_anonymous_namespace_::IRUnknownDimensionImpl *this)
{
  return *((unsigned __int8 *)this + 8);
}

const MIL::Text::SerializerOptions *`anonymous namespace'::IRUnknownDimensionImpl::ToString(_anonymous_namespace_::IRUnknownDimensionImpl *this)
{
  MIL::Text::BasicSerializer *v2;
  const MIL::Text::SerializerOptions *result;
  _BYTE v4[392];
  const MIL::Text::SerializerOptions *v5;

  MIL::Text::SerializerOptions::Make((uint64_t *)&v5);
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v4, v5);
  v2 = MIL::Text::BasicSerializer::Dimension((MIL::Text::BasicSerializer *)v4, this);
  MIL::Text::BasicSerializer::GetOutput(v2);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v4);
  result = v5;
  v5 = 0;
  if (result)
    return (const MIL::Text::SerializerOptions *)(*(uint64_t (**)(const MIL::Text::SerializerOptions *))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1E05C0D1C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 40);
  *(_QWORD *)(v1 - 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

MIL::IRConstantPropertyImpl *std::unique_ptr<MIL::IRConstantPropertyImpl>::reset[abi:ne180100](MIL::IRConstantPropertyImpl **a1, MIL::IRConstantPropertyImpl *a2)
{
  MIL::IRConstantPropertyImpl *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    MIL::IRConstantPropertyImpl::~IRConstantPropertyImpl(result);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

void MIL::IRConstantPropertyImpl::~IRConstantPropertyImpl(MIL::IRConstantPropertyImpl *this)
{
  uint64_t v2;
  char v3;

  v2 = *((unsigned int *)this + 2);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, MIL::IRConstantPropertyImpl *))off_1EA999058[v2])(&v3, this);
  *((_DWORD *)this + 2) = -1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_10unique_ptrIN12_GLOBAL__N_115PropertyStorageIxEENS_14default_deleteISB_EEEENS8_INSA_IhEENSC_ISF_EEEENS8_INSA_IyEENSC_ISI_EEEEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSM_1EJSE_SH_SK_EEEEEEDcSO_DpT0_(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  *a2 = 0;
  if (result)
    JUMPOUT(0x1E0C023A0);
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_10unique_ptrIN12_GLOBAL__N_115PropertyStorageIxEENS_14default_deleteISB_EEEENS8_INSA_IhEENSC_ISF_EEEENS8_INSA_IyEENSC_ISI_EEEEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSM_1EJSE_SH_SK_EEEEEEDcSO_DpT0_(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  *a2 = 0;
  if (result)
    JUMPOUT(0x1E0C023A0);
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_10unique_ptrIN12_GLOBAL__N_115PropertyStorageIxEENS_14default_deleteISB_EEEENS8_INSA_IhEENSC_ISF_EEEENS8_INSA_IyEENSC_ISI_EEEEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSM_1EJSE_SH_SK_EEEEEEDcSO_DpT0_(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  *a2 = 0;
  if (result)
    JUMPOUT(0x1E0C023A0);
  return result;
}

uint64_t `anonymous namespace'::IRTensorValueTypeImpl::GetShape(_anonymous_namespace_::IRTensorValueTypeImpl *this)
{
  return *((_QWORD *)this + 2);
}

void `anonymous namespace'::IRTensorValueTypeImpl::~IRTensorValueTypeImpl(_anonymous_namespace_::IRTensorValueTypeImpl *this)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 32);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
}

{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 32);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
  JUMPOUT(0x1E0C023A0);
}

uint64_t `anonymous namespace'::IRTensorValueTypeImpl::TryGetAttribute(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;

  v2 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 32), a2);
  if (!v2)
    return 0;
  v3 = *((_QWORD *)v2 + 5);
  v4 = (std::__shared_weak_count *)*((_QWORD *)v2 + 6);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

unsigned __int8 *`anonymous namespace'::IRTensorValueTypeImpl::TryGetAttributeSharedPtr@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 32), a2);
  if (result)
  {
    v5 = *((_QWORD *)result + 6);
    *a3 = *((_QWORD *)result + 5);
    a3[1] = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

uint64_t `anonymous namespace'::IRTensorValueTypeImpl::GetAttributes(_anonymous_namespace_::IRTensorValueTypeImpl *this)
{
  return (uint64_t)this + 32;
}

uint64_t `anonymous namespace'::IRTensorValueTypeImpl::GetDataType(_anonymous_namespace_::IRTensorValueTypeImpl *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t `anonymous namespace'::IRTensorValueTypeImpl::IsFixedRank(_anonymous_namespace_::IRTensorValueTypeImpl *this)
{
  return *((unsigned __int8 *)this + 72);
}

_QWORD *std::shared_ptr<std::vector<MIL::IRDimension const*>>::shared_ptr[abi:ne180100]<std::vector<MIL::IRDimension const*>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1EA999118;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1E05C1008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  a10 = 0;
  if (v10)
    std::default_delete<std::vector<MIL::IRDimension const*>>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<std::vector<MIL::IRDimension const*> *,std::shared_ptr<std::vector<MIL::IRDimension const*>>::__shared_ptr_default_delete<std::vector<MIL::IRDimension const*>,std::vector<MIL::IRDimension const*>>,std::allocator<std::vector<MIL::IRDimension const*>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

void std::__shared_ptr_pointer<std::vector<MIL::IRDimension const*> *,std::shared_ptr<std::vector<MIL::IRDimension const*>>::__shared_ptr_default_delete<std::vector<MIL::IRDimension const*>,std::vector<MIL::IRDimension const*>>,std::allocator<std::vector<MIL::IRDimension const*>>>::__on_zero_shared(uint64_t a1)
{
  std::default_delete<std::vector<MIL::IRDimension const*>>::operator()[abi:ne180100](a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<std::vector<MIL::IRDimension const*> *,std::shared_ptr<std::vector<MIL::IRDimension const*>>::__shared_ptr_default_delete<std::vector<MIL::IRDimension const*>,std::vector<MIL::IRDimension const*>>,std::allocator<std::vector<MIL::IRDimension const*>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::default_delete<std::vector<MIL::IRDimension const*>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a2)
  {
    v2 = *(void **)a2;
    if (*(_QWORD *)a2)
    {
      *(_QWORD *)(a2 + 8) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x1E0C023A0);
  }
}

_QWORD *std::vector<MIL::Bf16>::vector(_QWORD *a1, uint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<MIL::Fp16>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_1E05C1138(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<MIL::Fp8E5M2>::vector(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1E05C11A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<MIL::Fp8E4M3FN>::vector(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1E05C1218(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<MIL::Fp16>::vector(_QWORD *a1, uint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<MIL::Fp16>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_1E05C128C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,true,0ul>,std::__bit_iterator<std::vector<BOOL>,true,0ul>>(_QWORD *result, _QWORD *a2, int a3, _QWORD *a4, int a5, size_t __sz)
{
  uint64_t v10;

  if (__sz)
  {
    v10 = (uint64_t)result;
    std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    return (_QWORD *)std::vector<unsigned char>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,true,0ul>,std::__bit_iterator<std::vector<BOOL>,true,0ul>>(v10, a2, a3, a4, a5);
  }
  return result;
}

void sub_1E05C1310(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<unsigned char>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,true,0ul>,std::__bit_iterator<std::vector<BOOL>,true,0ul>>(uint64_t result, _QWORD *a2, int a3, _QWORD *a4, int a5)
{
  _BYTE *v5;

  v5 = *(_BYTE **)(result + 8);
  while (a2 != a4 || a3 != a5)
  {
    *v5++ = (*a2 >> a3) & 1;
    a2 += a3 == 63;
    if (a3 == 63)
      a3 = 0;
    else
      ++a3;
  }
  *(_QWORD *)(result + 8) = v5;
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  _QWORD *v17;
  __int128 *v18;
  __int128 v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  size_t v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD v29[2];
  char v30;

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  v17 = operator new(0x38uLL);
  v29[0] = v17;
  v29[1] = a1 + 16;
  *v17 = 0;
  v17[1] = v10;
  v18 = *a4;
  v19 = **a4;
  v17[4] = *((_QWORD *)*a4 + 2);
  *((_OWORD *)v17 + 1) = v19;
  *((_QWORD *)v18 + 1) = 0;
  *((_QWORD *)v18 + 2) = 0;
  *(_QWORD *)v18 = 0;
  v17[5] = 0;
  v17[6] = 0;
  v30 = 1;
  v20 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v21 = *(float *)(a1 + 32);
  if (!v11 || (float)(v21 * (float)v11) < v20)
  {
    v22 = 1;
    if (v11 >= 3)
      v22 = (v11 & (v11 - 1)) != 0;
    v23 = v22 | (2 * v11);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      v25 = v24;
    else
      v25 = v23;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v25);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v26 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v26)
  {
    *(_QWORD *)v29[0] = *v26;
    *v26 = v29[0];
  }
  else
  {
    *(_QWORD *)v29[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v29[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v29[0])
    {
      v27 = *(_QWORD *)(*(_QWORD *)v29[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v27 >= v11)
          v27 %= v11;
      }
      else
      {
        v27 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v27) = v29[0];
    }
  }
  i = (unsigned __int8 *)v29[0];
  v29[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v29, 0);
  return i;
}

void sub_1E05C15FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<MIL::AbstractConstExpr const *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<MIL::AbstractConstExpr const *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::AbstractConstExpr const *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<unsigned char>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<unsigned char>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C1794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<std::string>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string&>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<std::string>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C18D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<MIL::Bf16>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<MIL::Bf16>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C1A1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<MIL::Fp16>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<MIL::Fp16>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C1B60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<MIL::Fp8E5M2>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<MIL::Fp8E5M2>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C1CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<MIL::Fp8E4M3FN>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<MIL::Fp8E4M3FN>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C1DE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<float>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<float>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C1F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<double>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<double>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C2070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<signed char>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<signed char>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C21B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<short>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<short>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C22F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<int>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<int>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C243C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<long long>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<long long>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C2580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<unsigned short>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<unsigned short>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C26C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<unsigned int>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<unsigned int>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C2808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MIL::IRValueConstExprOutputData<unsigned long long>,MIL::IRTensorValueType const*&,std::shared_ptr<MIL::AbstractConstExpr const>,unsigned long &,std::string &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::string __p;
  __int128 v17;

  v10 = operator new();
  v11 = *a1;
  v17 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v12 = *a3;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  MIL::IRValueConstExprOutputData<unsigned long long>::IRValueConstExprOutputData(v10, v11, &v17, v12, &__p);
  *a5 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1E05C294C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  uint64_t v16;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  MEMORY[0x1E0C023A0](v16, 0x10F3C4093C008B8);
  _Unwind_Resume(a1);
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>(uint64_t a1, __int128 *a2, __int128 *a3, std::string *this)
{
  std::string *v4;
  __int128 *v6;
  __int128 v7;
  _QWORD v9[3];
  char v10;
  std::string *v11;
  std::string *v12;

  v4 = this;
  v11 = this;
  v12 = this;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
        v4 = v12;
      }
      else
      {
        v7 = *v6;
        v4->__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 2);
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      v6 = (__int128 *)((char *)v6 + 24);
      v12 = ++v4;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_1E05C2A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::IRListValueTypeImpl::~IRListValueTypeImpl(_anonymous_namespace_::IRListValueTypeImpl *this)
{
  JUMPOUT(0x1E0C023A0);
}

uint64_t `anonymous namespace'::IRListValueTypeImpl::GetElementType(_anonymous_namespace_::IRListValueTypeImpl *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t `anonymous namespace'::IRListValueTypeImpl::GetLength(_anonymous_namespace_::IRListValueTypeImpl *this)
{
  return *((_QWORD *)this + 2);
}

void `anonymous namespace'::IRTupleValueTypeImpl::~IRTupleValueTypeImpl(_anonymous_namespace_::IRTupleValueTypeImpl *this)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x1E0C023A0);
}

uint64_t `anonymous namespace'::IRTupleValueTypeImpl::GetTypes(_anonymous_namespace_::IRTupleValueTypeImpl *this)
{
  return *((_QWORD *)this + 1);
}

void `anonymous namespace'::IRDictionaryValueTypeImpl::~IRDictionaryValueTypeImpl(_anonymous_namespace_::IRDictionaryValueTypeImpl *this)
{
  JUMPOUT(0x1E0C023A0);
}

uint64_t `anonymous namespace'::IRDictionaryValueTypeImpl::GetKeyType(_anonymous_namespace_::IRDictionaryValueTypeImpl *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t `anonymous namespace'::IRDictionaryValueTypeImpl::GetValueType(_anonymous_namespace_::IRDictionaryValueTypeImpl *this)
{
  return *((_QWORD *)this + 2);
}

void std::default_delete<MIL::IRTensorBufferValueTypeImpl>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a2 + 72);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a2 + 56);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a2 + 32);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a2 + 8);
    JUMPOUT(0x1E0C023A0);
  }
}

_QWORD *std::vector<unsigned char>::vector(_QWORD *a1, size_t a2, _BYTE *a3)
{
  size_t v5;
  _BYTE *v6;
  _BYTE *v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    v5 = a2;
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_BYTE *)a1[1];
    v7 = &v6[v5];
    do
    {
      *v6++ = *a3;
      --v5;
    }
    while (v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_1E05C2BBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<MIL::IRDimension const*>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned long long>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1E05C2C30(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<std::vector<MIL::IRDimension const*>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA999350;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<MIL::IRDimension const*>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA999350;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

void std::__shared_ptr_emplace<std::vector<MIL::IRDimension const*>>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<std::vector<MIL::IRProperty const*>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA9993A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<MIL::IRProperty const*>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA9993A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

void std::__shared_ptr_emplace<std::vector<MIL::IRProperty const*>>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

uint64_t MIL::IRTensorBufferValueTypeImpl::IRTensorBufferValueTypeImpl(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v12;
  const void ****v13;
  _QWORD *v14;
  const void *v15;
  unint64_t v16;
  const void **v17;
  const void **v18;
  _BYTE **v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  unint64_t v23;
  uint64_t v24;
  _DWORD **v25;
  uint64_t v26;
  unint64_t v27;
  _BYTE **v28;
  std::logic_error *exception;
  std::logic_error *v31;
  std::logic_error *v32;

  *(_DWORD *)a1 = a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)a3;
  v12 = a1 + 8;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a1 + 48) = a5;
  *(_OWORD *)(a1 + 56) = *(_OWORD *)a6;
  v13 = (const void ****)(a1 + 56);
  *(_QWORD *)a6 = 0;
  *(_QWORD *)(a6 + 8) = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 72, a7);
  v14 = *(_QWORD **)(a1 + 32);
  v15 = *(const void **)(a1 + 48);
  if (v14)
  {
    if (v15)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Strides and row-alignment cannot be specified simulataneously for tensor_buffers.");
    }
    else
    {
      if (*(_QWORD *)(*(_QWORD *)v12 + 8) - **(_QWORD **)v12 == v14[1] - *v14)
        goto LABEL_4;
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Length of shape and strides must be equal.");
    }
LABEL_33:
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  if (v15)
  {
    if (v28)
    {
      if (*v28[1])
      {
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Row-alignment-in-bytes cannot be a variadic unknown property for tensor_buffers.");
        goto LABEL_33;
      }
    }
  }
LABEL_4:
  v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)v12 + 8) - **(_QWORD **)v12) >> 3;
  v18 = **v13;
  v17 = (*v13)[1];
  if (v16 != v17 - v18)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Length of shape and interleaveFactors must be equal.");
    goto LABEL_33;
  }
  if ((char *)v17 - (char *)v18 != 8
    || !*v18
  {
    if (v17 == v18)
    {
      v27 = 1;
    }
    else
    {
      v20 = 0;
      if (v16 <= 1)
        v21 = 1;
      else
        v21 = v16;
      do
      {
        v22 = v18[v20];
        if (!v22
        {
          v31 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(v31, "Interleave factors should be scalars.");
          v31->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
          __cxa_throw(v31, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
        }
        ++v20;
      }
      while (v21 != v20);
      v23 = 0;
      v24 = 0;
      do
      {
        v25 = (_DWORD **)MIL::IRProperty::AsConstant((MIL::IRProperty *)v18[v23]);
        if (*(_BYTE *)MIL::IRConstantPropertyImpl::GetValue<unsigned char>(v25[1]) == 1)
          ++v24;
        ++v23;
        v18 = **v13;
        v26 = (char *)(*v13)[1] - (char *)v18;
      }
      while (v23 < v26 >> 3);
      v16 = v26 >> 3;
      v27 = v24 + 1;
    }
    if (v27 < v16)
    {
      v32 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v32, "Found multiple interleave factors that are not 1.");
      v32->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
      __cxa_throw(v32, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
    }
  }
  return a1;
}

void sub_1E05C302C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  __cxa_free_exception(v5);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v4);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::default_delete<MIL::IRPixelBufferValueTypeImpl>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a2 + 80);
    if (*(_BYTE *)(a2 + 72))
      std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a2 + 56);
    if (*(_BYTE *)(a2 + 48))
      std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a2 + 32);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a2 + 8);
    JUMPOUT(0x1E0C023A0);
  }
}

uint64_t MIL::IRPixelBufferValueTypeImpl::IRPixelBufferValueTypeImpl(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v11;
  char IsShapeFixedRank;
  uint64_t **v13;
  const void ****v14;
  uint64_t v15;
  uint64_t v16;
  const void **v17;
  const void **v18;
  const void **i;
  const void **v20;
  MIL::IRProperty *v21;
  _DWORD **v22;
  _DWORD **v23;
  std::logic_error *v25;
  std::logic_error *v26;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  __int128 v30;
  std::logic_error *exception;
  std::string v32;
  std::string v33;
  std::string v34;

  *(_DWORD *)a1 = a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)a3;
  v11 = a1 + 8;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  v13 = (uint64_t **)(a1 + 32);
  *(_BYTE *)(a1 + 24) = IsShapeFixedRank;
  *(_BYTE *)(a1 + 48) = 0;
  if (*(_BYTE *)(a4 + 16))
  {
    *(_OWORD *)(a1 + 32) = *(_OWORD *)a4;
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_BYTE *)(a1 + 48) = 1;
  }
  *(_BYTE *)(a1 + 56) = 0;
  v14 = (const void ****)(a1 + 56);
  *(_BYTE *)(a1 + 72) = 0;
  if (*(_BYTE *)(a5 + 16))
  {
    *(_OWORD *)(a1 + 56) = *(_OWORD *)a5;
    *(_QWORD *)a5 = 0;
    *(_QWORD *)(a5 + 8) = 0;
    *(_BYTE *)(a1 + 72) = 1;
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 80, a6);
  if (*(_DWORD *)a1 != 20 && !MIL::IsValidIRPixelFormatType(*(_DWORD *)a1))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unsupported pixel format type.");
    goto LABEL_32;
  }
  if (!*(_BYTE *)(a1 + 24))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Pixel buffers must have known rank.");
    goto LABEL_32;
  }
  if (*(_QWORD *)(*(_QWORD *)v11 + 8) - **(_QWORD **)v11 != 16)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Length of shape must be 2 (height, width).");
    goto LABEL_32;
  }
  if (*(_BYTE *)(a1 + 48))
  {
    if (*(_DWORD *)a1 != 20)
    {
      v16 = **v13;
      v15 = (*v13)[1];
      if (MIL::GetNumPlanesForFormat(*(_DWORD *)a1) != (v15 - v16) >> 3)
      {
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Length of bytesPerRow must be equal to the number of planes in formatType.");
        goto LABEL_32;
      }
    }
  }
  if (!*(_BYTE *)(a1 + 72))
    return a1;
  if (*(_DWORD *)a1 != 20)
  {
    v18 = **v14;
    v17 = (*v14)[1];
    if (MIL::GetNumPlanesForFormat(*(_DWORD *)a1) != v17 - v18)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Length of numSlices must be equal to the number of planes in formatType.");
LABEL_32:
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
      __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
    }
  }
  v20 = **v14;
  for (i = (*v14)[1]; v20 != i; ++v20)
  {
    v21 = (MIL::IRProperty *)*v20;
    if (*v20)
    {
      {
        v22 = (_DWORD **)MIL::IRProperty::AsConstant(v21);
        if (*(_QWORD *)MIL::IRConstantPropertyImpl::GetValue<long long>(v22[1]) != 1
          && !MIL::SupportsMultiSlice(*(_DWORD *)a1))
        {
          v26 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          MIL::IRPixelFormatTypeToString(a2, &v32);
          v27 = std::string::insert(&v32, 0, "Given pixel format type ");
          v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
          v33.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v28;
          v27->__r_.__value_.__l.__size_ = 0;
          v27->__r_.__value_.__r.__words[2] = 0;
          v27->__r_.__value_.__r.__words[0] = 0;
          v29 = std::string::append(&v33, " does not support multislice.");
          v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
          v34.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v30;
          v29->__r_.__value_.__l.__size_ = 0;
          v29->__r_.__value_.__r.__words[2] = 0;
          v29->__r_.__value_.__r.__words[0] = 0;
          std::logic_error::logic_error(v26, &v34);
          v26->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
          __cxa_throw(v26, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
        }
      }
      {
        if (MIL::SupportsMultiSlice(*(_DWORD *)a1))
        {
          v23 = (_DWORD **)MIL::IRProperty::AsConstant(v21);
          if (*(uint64_t *)MIL::IRConstantPropertyImpl::GetValue<long long>(v23[1]) <= 1)
          {
            v25 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(v25, "Multislice pixel format requires numSlices > 1.");
            v25->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
            __cxa_throw(v25, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
          }
        }
      }
    }
  }
  return a1;
}

void sub_1E05C34B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;

  __cxa_free_exception(v32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a9);
  if (*(_BYTE *)(v29 + 72))
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v31);
  if (*(_BYTE *)(v29 + 48))
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v30);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v28);
  _Unwind_Resume(a1);
}

void std::default_delete<MIL::IRCircularBufferValueTypeImpl>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  if (a2)
  {
    v3 = (_QWORD *)(a2 + 24);
    v4 = *(_QWORD *)(a2 + 24);
    *v3 = 0;
    if (v4)
      std::default_delete<MIL::IRTensorBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v3, v4);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a2);
    JUMPOUT(0x1E0C023A0);
  }
}

uint64_t *MIL::IRCircularBufferValueTypeImpl::IRCircularBufferValueTypeImpl(uint64_t *a1, int a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, _QWORD *a7, uint64_t *a8)
{
  _QWORD **v11;
  char *v12;
  char *v13;
  unint64_t v14;
  _DWORD **v15;
  _DWORD **v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  std::logic_error *exception;
  std::logic_error *v26;
  int v27;

  v27 = a2;
  *(_OWORD *)a1 = *(_OWORD *)a3;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  a1[2] = (uint64_t)a7;
  v11 = (_QWORD **)(a1 + 3);
  std::make_unique[abi:ne180100]<MIL::IRTensorBufferValueTypeImpl,MIL::IRDataType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,decltype(nullptr),std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(&v27, a4, a5, a6, a8, a1 + 3);
  v12 = *(char **)*a4;
  v13 = *(char **)(*a4 + 8);
  if (v13 - v12 == 8)
  {
    if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)v12 + 32))(*(_QWORD *)v12) & 1) != 0)
      goto LABEL_8;
    v12 = *(char **)*a4;
    v13 = *(char **)(*a4 + 8);
  }
  if (v13 != v12)
  {
    v14 = 0;
    do
    {
      if (!(*(uint64_t (**)(_QWORD))(**(_QWORD **)&v12[8 * v14] + 16))(*(_QWORD *)&v12[8 * v14]))
      {
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Buffer shape should be fully defined.");
        exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
        __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
      }
      ++v14;
      v12 = *(char **)*a4;
    }
    while (v14 < (uint64_t)(*(_QWORD *)(*a4 + 8) - (_QWORD)v12) >> 3);
  }
LABEL_8:
  if (a7)
  {
    if (v15)
    {
      v16 = v15;
      v17 = *(_QWORD *)MIL::IRConstantPropertyImpl::GetValue<long long>(v15[1]);
      if ((*(_QWORD *)MIL::IRConstantPropertyImpl::GetValue<long long>(v16[1]) & 0x8000000000000000) != 0
        || v17 >= (uint64_t)(*(_QWORD *)((*v11)[1] + 8) - *(_QWORD *)(*v11)[1]) >> 3)
      {
        v26 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v26, "Wrap dimension must be between 0 and num of dimensions - 1.");
        goto LABEL_22;
      }
      v18 = *(_QWORD *)*a1;
      if (v17 >= (*(_QWORD *)(*a1 + 8) - v18) >> 3)
LABEL_19:
        std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
      if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v18 + 8 * v17) + 16))(*(_QWORD *)(v18 + 8 * v17)))
      {
        v19 = *(_QWORD *)*a1;
        if (v17 < (*(_QWORD *)(*a1 + 8) - v19) >> 3)
        {
          v20 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v19 + 8 * v17) + 16))(*(_QWORD *)(v19 + 8 * v17));
          v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 48))(v20);
          v22 = (_QWORD *)(*v11)[1];
          if (v17 < (uint64_t)(v22[1] - *v22) >> 3)
          {
            v23 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*v22 + 8 * v17) + 16))(*(_QWORD *)(*v22 + 8 * v17));
            if (v21 <= (*(uint64_t (**)(uint64_t))(*(_QWORD *)v23 + 48))(v23))
              return a1;
            v26 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(v26, "Slice wrap dimension size is larger than buffer wrap dimension size.");
LABEL_22:
            v26->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
            __cxa_throw(v26, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
          }
        }
        goto LABEL_19;
      }
    }
  }
  return a1;
}

void sub_1E05C3868(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t *v2;
  void *v3;
  uint64_t v5;

  __cxa_free_exception(v3);
  v5 = *v2;
  *v2 = 0;
  if (v5)
    std::default_delete<MIL::IRTensorBufferValueTypeImpl>::operator()[abi:ne180100]((uint64_t)v2, v5);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

const void **MIL::IRStateValueTypeImpl::IRStateValueTypeImpl(const void **this, const MIL::IRValueType *a2)
{
  std::logic_error *exception;

  *this = a2;
  if (!(*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)a2 + 24))(a2)
    && (!*this
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Trying to wrap an unsupported type (only tensors and memory layouts are supported).");
    __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
  }
  return this;
}

void sub_1E05C3948(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypeStore<unsigned long long,MIL::IRConstantDimension const>::Get<unsigned long long>(uint64_t a1, MIL::IRConstantDimension *a2)
{
  _QWORD *v3;
  char v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  MIL::IRConstantDimension *v9;

  v9 = a2;
  v3 = std::__hash_table<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>>>::__emplace_unique_key_args<unsigned long long,unsigned long long,decltype(nullptr)>(a1, (unint64_t *)&v9, &v9);
  if (v4)
  {
    MIL::IRConstantDimension::Make(a2, &v9);
    v5 = (unint64_t)v9;
    v9 = 0;
    v6 = v3[3];
    v3[3] = v5;
    if (v6)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      v7 = (unint64_t)v9;
      v9 = 0;
      if (v7)
        (*(void (**)(unint64_t))(*(_QWORD *)v7 + 8))(v7);
    }
  }
  return v3[3];
}

uint64_t MIL::IRTypeStore<long long,MIL::IRConstantProperty const>::Get<long long>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  char v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v8;
  uint64_t v9;

  v8 = a2;
  v9 = a2;
  v2 = std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<MIL::IRConstantProperty const>>>>::__emplace_unique_key_args<long long,long long,decltype(nullptr)>(a1, &v8, &v8);
  if (v3)
  {
    MIL::IRConstantProperty::Make<long long>(&v9, &v8);
    v4 = v8;
    v8 = 0;
    v5 = v2[3];
    v2[3] = v4;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      v6 = v8;
      v8 = 0;
      if (v6)
        (*(void (**)(unint64_t))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return v2[3];
}

uint64_t MIL::IRTypeStore<unsigned char,MIL::IRConstantProperty const>::Get<unsigned char>(uint64_t a1, unsigned __int8 a2)
{
  _QWORD *v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  unsigned __int8 v9;
  unsigned __int8 v10;

  v10 = a2;
  v9 = a2;
  v8 = 0;
  v2 = std::__hash_table<std::__hash_value_type<unsigned char,std::unique_ptr<MIL::IRConstantProperty const>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::unique_ptr<MIL::IRConstantProperty const>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::unique_ptr<MIL::IRConstantProperty const>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::unique_ptr<MIL::IRConstantProperty const>>>>::__emplace_unique_key_args<unsigned char,unsigned char,decltype(nullptr)>(a1, &v9, &v9);
  if (v3)
  {
    MIL::IRConstantProperty::Make<unsigned char>(&v10, &v8);
    v4 = v8;
    v8 = 0;
    v5 = v2[3];
    v2[3] = v4;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      v6 = v8;
      v8 = 0;
      if (v6)
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return v2[3];
}

uint64_t MIL::IRTypeStore<unsigned long long,MIL::IRConstantProperty const>::Get<unsigned long long>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  char v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v8;
  uint64_t v9;

  v8 = a2;
  v9 = a2;
  v2 = std::__hash_table<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantProperty const>>>>::__emplace_unique_key_args<unsigned long long,unsigned long long,decltype(nullptr)>(a1, &v8, &v8);
  if (v3)
  {
    MIL::IRConstantProperty::Make<unsigned long long>(&v9, &v8);
    v4 = v8;
    v8 = 0;
    v5 = v2[3];
    v2[3] = v4;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      v6 = v8;
      v8 = 0;
      if (v6)
        (*(void (**)(unint64_t))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return v2[3];
}

uint64_t MIL::IRTypeStore<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRTensorValueType const>::Get<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  char v15;
  char v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38[2];
  std::__shared_weak_count *v39;
  _QWORD v40[2];
  _QWORD v41[2];
  int v42;

  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)&v33, (uint64_t)a4);
  LODWORD(v38[0]) = a2;
  v8 = a3[1];
  v38[1] = *a3;
  v39 = (std::__shared_weak_count *)v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = v33;
  v12 = v34;
  v33 = 0;
  v34 = 0;
  v40[0] = v11;
  v40[1] = v12;
  v41[0] = v35;
  v41[1] = v36;
  v42 = v37;
  if (v36)
  {
    v13 = *(_QWORD *)(v35 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v13 >= v12)
        v13 %= v12;
    }
    else
    {
      v13 &= v12 - 1;
    }
    *(_QWORD *)(v11 + 8 * v13) = v41;
    v35 = 0;
    v36 = 0;
  }
  v32 = 0;
  v14 = std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>>>::__emplace_unique_key_args<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,decltype(nullptr)>(a1, (int *)v38, (uint64_t)v38);
  v16 = v15;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v40);
  v17 = v39;
  if (v39)
  {
    p_shared_owners = (unint64_t *)&v39->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&v33);
  if (v16)
  {
    v20 = a3[1];
    v30 = *a3;
    v31 = (std::__shared_weak_count *)v20;
    if (v20)
    {
      v21 = (unint64_t *)(v20 + 8);
      do
        v22 = __ldxr(v21);
      while (__stxr(v22 + 1, v21));
    }
    MIL::IRTensorValueType::Make(a2, (uint64_t)&v30, a4, v38);
    v23 = v38[0];
    v38[0] = 0;
    v24 = v14[10];
    v14[10] = v23;
    if (v24)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
      v25 = v38[0];
      v38[0] = 0;
      if (v25)
        (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
    }
    v26 = v31;
    if (v31)
    {
      v27 = (unint64_t *)&v31->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
  }
  return v14[10];
}

void sub_1E05C3D88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(uint64_t a1, int *a2)
{
  unint64_t ***v3;
  unint64_t **v4;
  unint64_t **v5;
  unint64_t *v6;
  uint64_t v8;

  v8 = 0;
  v3 = (unint64_t ***)*((_QWORD *)a2 + 1);
  v4 = *v3;
  v5 = v3[1];
  while (v4 != v5)
  {
    v6 = *v4++;
    MIL::Util::HashCombine(&v8, v6);
  }
  MIL::Util::HashCombine(&v8, (unint64_t *)*a2);
}

uint64_t `anonymous namespace'::HashCombineForAttr(uint64_t a1, uint64_t a2)
{
  uint64_t **v2;
  unint64_t *v3;
  unint64_t *v4;
  char v6;
  uint64_t v7;

  v7 = a2;
  v2 = *(uint64_t ***)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (unint64_t *)std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)&v6, (uint64_t)(v2 + 2));
      MIL::Util::HashCombine(&v7, v3);
      v4 = (unint64_t *)(*(uint64_t (**)(uint64_t *))(*v2[5] + 24))(v2[5]);
      MIL::Util::HashCombine(&v7, v4);
      v2 = (uint64_t **)*v2;
    }
    while (v2);
    return v7;
  }
  return a2;
}

BOOL std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  size_t v7;

  if (*(_DWORD *)a2 == *(_DWORD *)a3
    && (v5 = *(_QWORD *)(a2 + 8),
        v6 = *(_QWORD *)(a3 + 8),
        v7 = *(_QWORD *)(v5 + 8) - *(_QWORD *)v5,
        v7 == *(_QWORD *)(v6 + 8) - *(_QWORD *)v6)
    && !memcmp(*(const void **)v5, *(const void **)v6, v7))
  {
  }
  else
  {
    return 0;
  }
}

BOOL `anonymous namespace'::CompareAttr(uint64_t a1, _QWORD *a2)
{
  unsigned __int8 *v3;
  _BOOL8 v4;
  unsigned __int8 *v5;

  if (*(_QWORD *)(a1 + 24) != a2[3])
    return 0;
  v3 = (unsigned __int8 *)(a1 + 16);
  do
  {
    v3 = *(unsigned __int8 **)v3;
    v4 = v3 == 0;
    if (!v3)
      break;
    v5 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a2, v3 + 16);
    if (!v5)
      break;
  }
  while (((*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)v5 + 5) + 16))(*((_QWORD *)v5 + 5), *((_QWORD *)v3 + 5)) & 1) != 0);
  return v4;
}

uint64_t MIL::IRTypeStore<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,MIL::IRListValueType const>::Get<MIL::IRValueType const*,MIL::IRDimension const*>(uint64_t a1, MIL::IRListValueType *a2, const MIL::IRValueType *a3)
{
  _QWORD *v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v11;

  *(_QWORD *)&v11 = a2;
  *((_QWORD *)&v11 + 1) = a3;
  v5 = std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>>>::__emplace_unique_key_args<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,decltype(nullptr)>(a1, (uint64_t *)&v11, &v11);
  if (v6)
  {
    MIL::IRListValueType::Make(a2, a3, &v11);
    v7 = v11;
    *(_QWORD *)&v11 = 0;
    v8 = v5[4];
    v5[4] = v7;
    if (v8)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
      v9 = v11;
      *(_QWORD *)&v11 = 0;
      if (v9)
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    }
  }
  return v5[4];
}

uint64_t std::hash<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>>::operator()(uint64_t a1, uint64_t *a2)
{
  unint64_t *v2;
  uint64_t v3;
  uint64_t v5;

  v3 = *a2;
  v2 = (unint64_t *)a2[1];
  v5 = v3;
  MIL::Util::HashCombine(&v5, v2);
  return v5;
}

uint64_t MIL::IRTypeStore<std::shared_ptr<std::vector<MIL::IRValueType const*>>,MIL::IRTupleValueType const>::Get<std::shared_ptr<std::vector<MIL::IRValueType const*>> const&>(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  _QWORD *v6;
  char v7;
  char v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  __n128 v15;
  unint64_t ***v16;
  uint64_t v17;
  unint64_t ***v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  __n128 v23;
  uint64_t v24;
  unint64_t ***v25;
  std::__shared_weak_count *v26;

  v3 = *(std::__shared_weak_count **)(a2 + 8);
  v25 = *(unint64_t ****)a2;
  v26 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v24 = 0;
  v6 = std::__hash_table<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::__unordered_map_hasher<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::__unordered_map_equal<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>>>::__emplace_unique_key_args<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::shared_ptr<std::vector<MIL::IRValueType const*>>,decltype(nullptr)>(a1, &v25, (uint64_t)&v25);
  v8 = v7;
  v9 = v26;
  if (v26)
  {
    v10 = (unint64_t *)&v26->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v8)
  {
    v12 = *(_QWORD *)(a2 + 8);
    v23.n128_u64[0] = *(_QWORD *)a2;
    v23.n128_u64[1] = v12;
    if (v12)
    {
      v13 = (unint64_t *)(v12 + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v15 = MIL::IRTupleValueType::Make(&v23, (uint64_t *)&v25);
    v16 = v25;
    v25 = 0;
    v17 = v6[4];
    v6[4] = v16;
    if (v17)
    {
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v17 + 8))(v17, v15);
      v18 = v25;
      v25 = 0;
      if (v18)
        ((void (*)(unint64_t ***))(*v18)[1])(v18);
    }
    v19 = (std::__shared_weak_count *)v23.n128_u64[1];
    if (v23.n128_u64[1])
    {
      v20 = (unint64_t *)(v23.n128_u64[1] + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *, __n128))v19->__on_zero_shared)(v19, v15);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
  return v6[4];
}

void sub_1E05C4194(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>::operator()(uint64_t a1, unint64_t ****a2)
{
  unint64_t **v2;
  unint64_t **v3;
  unint64_t *v4;
  uint64_t v6;

  v6 = 0;
  v2 = **a2;
  v3 = (*a2)[1];
  if (v2 == v3)
    return 0;
  do
  {
    v4 = *v2++;
    MIL::Util::HashCombine(&v6, v4);
  }
  while (v2 != v3);
  return v6;
}

BOOL std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>::operator()(uint64_t a1, const void ***a2, uint64_t *a3)
{
  uint64_t v3;
  _BYTE *v4;
  size_t v5;

  v3 = *a3;
  v4 = **a2;
  v5 = (_BYTE *)(*a2)[1] - v4;
  return v5 == *(_QWORD *)(v3 + 8) - *(_QWORD *)v3 && memcmp(v4, *(const void **)v3, v5) == 0;
}

uint64_t MIL::IRTypeStore<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,MIL::IRDictionaryValueType const>::Get<MIL::IRValueType const*,MIL::IRValueType const*>(uint64_t a1, MIL::IRDictionaryValueType *a2, const MIL::IRValueType *a3)
{
  _QWORD *v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v11;

  *(_QWORD *)&v11 = a2;
  *((_QWORD *)&v11 + 1) = a3;
  v5 = std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>>>::__emplace_unique_key_args<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,decltype(nullptr)>(a1, (uint64_t *)&v11, &v11);
  if (v6)
  {
    MIL::IRDictionaryValueType::Make(a2, a3, &v11);
    v7 = v11;
    *(_QWORD *)&v11 = 0;
    v8 = v5[4];
    v5[4] = v7;
    if (v8)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
      v9 = v11;
      *(_QWORD *)&v11 = 0;
      if (v9)
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    }
  }
  return v5[4];
}

uint64_t MIL::IRTypeStore<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRTensorBufferValueType const>::Get<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t *a7)
{
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  _QWORD *v23;
  char v24;
  char v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61[5];
  uint64_t v62;
  std::__shared_weak_count *v63;
  uint64_t v64;
  std::__shared_weak_count *v65;
  uint64_t v66;
  std::__shared_weak_count *v67;
  int v68[4];
  std::__shared_weak_count *v69;
  std::__shared_weak_count *v70;
  std::__shared_weak_count *v71;
  uint64_t v72;
  uint64_t v73;
  int v74;

  v14 = (std::__shared_weak_count *)a3[1];
  v66 = *a3;
  v67 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  v17 = (std::__shared_weak_count *)a4[1];
  v64 = *a4;
  v65 = v17;
  if (v17)
  {
    v18 = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v20 = a6[1];
  v62 = *a6;
  v63 = (std::__shared_weak_count *)v20;
  if (v20)
  {
    v21 = (unint64_t *)(v20 + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v61, (uint64_t)a7);
  v74 = a2;
  v73 = a5;
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4ELm5EEEEJN3MIL10IRDataTypeENS_10shared_ptrINS_6vectorIPKNS3_11IRDimensionENS_9allocatorIS9_EEEEEENS5_INS6_IPKNS3_10IRPropertyENSA_ISG_EEEEEESG_SJ_NS_13unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENSA_IcEEEENS5_IKNS3_7IRValueEEENS_4hashISP_EENS_8equal_toISP_EENSA_INS_4pairIKSP_SS_EEEEEEEEC2B8ne180100IJLm0ELm1ELm2ELm3ELm4ELm5EEJS4_SD_SJ_SG_SJ_S11_EJEJEJRS4_RSD_RSJ_RSG_S16_S11_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENS19_IJDpT2_EEEDpOT3_((uint64_t)v68, &v74, &v66, &v64, &v73, &v62, v61);
  v73 = 0;
  v23 = std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>>>::__emplace_unique_key_args<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,decltype(nullptr)>(a1, v68, (uint64_t)v68);
  v25 = v24;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&v72);
  v26 = v71;
  if (v71)
  {
    v27 = (unint64_t *)&v71->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = v70;
  if (v70)
  {
    v30 = (unint64_t *)&v70->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v69;
  if (v69)
  {
    v33 = (unint64_t *)&v69->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v61);
  v35 = v63;
  if (v63)
  {
    v36 = (unint64_t *)&v63->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = v65;
  if (v65)
  {
    v39 = (unint64_t *)&v65->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  v41 = v67;
  if (v67)
  {
    v42 = (unint64_t *)&v67->__shared_owners_;
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }
  if (v25)
  {
    v44 = *(_OWORD *)a3;
    *a3 = 0;
    a3[1] = 0;
    v59 = *(_OWORD *)a4;
    v60 = v44;
    *a4 = 0;
    a4[1] = 0;
    v58 = *(_OWORD *)a6;
    *a6 = 0;
    a6[1] = 0;
    MIL::IRTensorBufferValueType::Make(a2, (uint64_t *)&v60, (uint64_t *)&v59, a5, (uint64_t *)&v58, a7, v68);
    v45 = *(_QWORD *)v68;
    *(_QWORD *)v68 = 0;
    v46 = v23[15];
    v23[15] = v45;
    if (v46)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v46 + 8))(v46);
      v47 = *(_QWORD *)v68;
      *(_QWORD *)v68 = 0;
      if (v47)
        (*(void (**)(uint64_t))(*(_QWORD *)v47 + 8))(v47);
    }
    v48 = (std::__shared_weak_count *)*((_QWORD *)&v58 + 1);
    if (*((_QWORD *)&v58 + 1))
    {
      v49 = (unint64_t *)(*((_QWORD *)&v58 + 1) + 8);
      do
        v50 = __ldaxr(v49);
      while (__stlxr(v50 - 1, v49));
      if (!v50)
      {
        ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
        std::__shared_weak_count::__release_weak(v48);
      }
    }
    v51 = (std::__shared_weak_count *)*((_QWORD *)&v59 + 1);
    if (*((_QWORD *)&v59 + 1))
    {
      v52 = (unint64_t *)(*((_QWORD *)&v59 + 1) + 8);
      do
        v53 = __ldaxr(v52);
      while (__stlxr(v53 - 1, v52));
      if (!v53)
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }
    }
    v54 = (std::__shared_weak_count *)*((_QWORD *)&v60 + 1);
    if (*((_QWORD *)&v60 + 1))
    {
      v55 = (unint64_t *)(*((_QWORD *)&v60 + 1) + 8);
      do
        v56 = __ldaxr(v55);
      while (__stlxr(v56 - 1, v55));
      if (!v56)
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
    }
  }
  return v23[15];
}

void sub_1E05C468C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>::~tuple(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 64);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 48);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 24);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 8);
  return a1;
}

uint64_t std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(uint64_t a1, int *a2)
{
  unint64_t ***v3;
  unint64_t **v4;
  unint64_t **v5;
  unint64_t *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t ***v11;
  unint64_t **v12;
  unint64_t **v13;
  unint64_t ***v14;
  unint64_t **v15;
  unint64_t **v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v21;

  v21 = 0;
  MIL::Util::HashCombine(&v21, (unint64_t *)*a2);
  v3 = (unint64_t ***)*((_QWORD *)a2 + 1);
  v4 = *v3;
  v5 = v3[1];
  while (v4 != v5)
  {
    v6 = *v4++;
    MIL::Util::HashCombine(&v21, v6);
  }
  v7 = *((_QWORD *)a2 + 3);
  v8 = (std::__shared_weak_count *)*((_QWORD *)a2 + 4);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  if (v7)
  {
    v11 = (unint64_t ***)*((_QWORD *)a2 + 3);
    v12 = *v11;
    v13 = v11[1];
    while (v12 != v13)
      MIL::Util::HashCombine(&v21, *v12++);
  }
  else
  {
    MIL::Util::HashCombine(&v21, 0);
  }
  MIL::Util::HashCombine(&v21, *((unint64_t **)a2 + 5));
  v14 = (unint64_t ***)*((_QWORD *)a2 + 6);
  v15 = *v14;
  v16 = v14[1];
  while (v15 != v16)
    MIL::Util::HashCombine(&v21, *v15++);
  v21 = v17;
  if (v8)
  {
    v18 = (unint64_t *)&v8->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return v17;
}

void sub_1E05C4850(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  _BOOL4 v19;
  size_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;

  if (*(_DWORD *)a2 != *(_DWORD *)a3)
    return 0;
  v5 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a3 + 8);
  v7 = *(_QWORD *)(v5 + 8) - *(_QWORD *)v5;
  if (v7 != *(_QWORD *)(v6 + 8) - *(_QWORD *)v6)
    return 0;
  if (memcmp(*(const void **)v5, *(const void **)v6, v7))
    return 0;
  v8 = *(_QWORD *)(a2 + 48);
  v9 = *(_QWORD *)(a3 + 48);
  v10 = *(_QWORD *)(v8 + 8) - *(_QWORD *)v8;
  if (v10 != *(_QWORD *)(v9 + 8) - *(_QWORD *)v9
    || memcmp(*(const void **)v8, *(const void **)v9, v10)
    || *(_QWORD *)(a2 + 40) != *(_QWORD *)(a3 + 40))
  {
    return 0;
  }
  v11 = *(_QWORD *)(a2 + 24);
  v12 = *(std::__shared_weak_count **)(a2 + 32);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v15 = *(_QWORD *)(a3 + 24);
  v16 = *(std::__shared_weak_count **)(a3 + 32);
  if (v16)
  {
    v17 = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v19 = 0;
  if ((v11 != 0) == (v15 != 0))
  {
    if (!v11
      || !v15
      || (v20 = *(_QWORD *)(v11 + 8) - *(_QWORD *)v11, v20 == *(_QWORD *)(v15 + 8) - *(_QWORD *)v15)
      && !memcmp(*(const void **)v11, *(const void **)v15, v20))
    {
      v19 = 1;
    }
  }
  if (v16)
  {
    v21 = (unint64_t *)&v16->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  if (v12)
  {
    v23 = (unint64_t *)&v12->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

BOOL std::operator!=[abi:ne180100]<MIL::IRProperty const*,std::allocator<MIL::IRProperty const*>>(uint64_t a1, uint64_t a2)
{
  const void *v2;
  size_t v4;
  const void *v5;

  v2 = *(const void **)a1;
  v4 = *(_QWORD *)(a1 + 8) - (_QWORD)v2;
  v5 = *(const void **)a2;
  return v4 != *(_QWORD *)(a2 + 8) - (_QWORD)v5 || memcmp(v2, v5, v4) != 0;
}

uint64_t MIL::IRTypeStore<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRPixelBufferValueType const>::Get<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  _QWORD *v21;
  char v22;
  char v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60[5];
  uint64_t v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  _QWORD v67[2];
  std::__shared_weak_count *v68;
  std::__shared_weak_count *v69;
  std::__shared_weak_count *v70;
  uint64_t v71;

  v12 = (std::__shared_weak_count *)a3[1];
  v65 = *a3;
  v66 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v15 = (std::__shared_weak_count *)a4[1];
  v63 = *a4;
  v64 = v15;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v18 = (std::__shared_weak_count *)a5[1];
  v61 = *a5;
  v62 = v18;
  if (v18)
  {
    v19 = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v60, (uint64_t)a6);
  LODWORD(v59) = a2;
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN3MIL17IRPixelFormatTypeENS_10shared_ptrINS_6vectorIPKNS3_11IRDimensionENS_9allocatorIS9_EEEEEENS5_INS6_IPKNS3_10IRPropertyENSA_ISG_EEEEEESJ_NS_13unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENSA_IcEEEENS5_IKNS3_7IRValueEEENS_4hashISP_EENS_8equal_toISP_EENSA_INS_4pairIKSP_SS_EEEEEEEEC2B8ne180100IJLm0ELm1ELm2ELm3ELm4EEJS4_SD_SJ_SJ_S11_EJEJEJRS4_RSD_RSJ_S16_S11_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENS18_IJDpT2_EEEDpOT3_((uint64_t)v67, &v59, &v65, &v63, &v61, v60);
  v59 = 0;
  v21 = std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>>>::__emplace_unique_key_args<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,decltype(nullptr)>(a1, v67, (uint64_t)v67);
  v23 = v22;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&v71);
  v24 = v70;
  if (v70)
  {
    v25 = (unint64_t *)&v70->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v27 = v69;
  if (v69)
  {
    v28 = (unint64_t *)&v69->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v30 = v68;
  if (v68)
  {
    v31 = (unint64_t *)&v68->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v60);
  v33 = v62;
  if (v62)
  {
    v34 = (unint64_t *)&v62->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  v36 = v64;
  if (v64)
  {
    v37 = (unint64_t *)&v64->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  v39 = v66;
  if (v66)
  {
    v40 = (unint64_t *)&v66->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  if (v23)
  {
    v42 = *(_OWORD *)a3;
    *a3 = 0;
    a3[1] = 0;
    v57 = *(_OWORD *)a4;
    v58 = v42;
    *a4 = 0;
    a4[1] = 0;
    v56 = *(_OWORD *)a5;
    *a5 = 0;
    a5[1] = 0;
    MIL::IRPixelBufferValueType::Make(a2, (uint64_t *)&v58, (uint64_t *)&v57, (uint64_t *)&v56, a6, v67);
    v43 = v67[0];
    v67[0] = 0;
    v44 = v21[14];
    v21[14] = v43;
    if (v44)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44);
      v45 = v67[0];
      v67[0] = 0;
      if (v45)
        (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
    }
    v46 = (std::__shared_weak_count *)*((_QWORD *)&v56 + 1);
    if (*((_QWORD *)&v56 + 1))
    {
      v47 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
    v49 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
    if (*((_QWORD *)&v57 + 1))
    {
      v50 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }
    v52 = (std::__shared_weak_count *)*((_QWORD *)&v58 + 1);
    if (*((_QWORD *)&v58 + 1))
    {
      v53 = (unint64_t *)(*((_QWORD *)&v58 + 1) + 8);
      do
        v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
    }
  }
  return v21[14];
}

void sub_1E05C4DEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>::~tuple(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 56);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 40);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 24);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 8);
  return a1;
}

uint64_t std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(uint64_t a1, _QWORD *a2)
{
  unint64_t ***v3;
  unint64_t **v4;
  unint64_t **v5;
  unint64_t *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t ***v11;
  unint64_t **v12;
  unint64_t **v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t ***v18;
  unint64_t **v19;
  unint64_t **v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v27;
  uint64_t v28;

  v28 = 0;
  MIL::Util::HashCombine(&v28, (unint64_t *)*(unsigned int *)a2);
  v3 = (unint64_t ***)a2[1];
  v4 = *v3;
  v5 = v3[1];
  while (v4 != v5)
  {
    v6 = *v4++;
    MIL::Util::HashCombine(&v28, v6);
  }
  v7 = a2[3];
  v8 = (std::__shared_weak_count *)a2[4];
  v27 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  if (v7)
  {
    v11 = (unint64_t ***)a2[3];
    v12 = *v11;
    v13 = v11[1];
    while (v12 != v13)
      MIL::Util::HashCombine(&v28, *v12++);
  }
  else
  {
    MIL::Util::HashCombine(&v28, 0);
  }
  v14 = a2[5];
  v15 = (std::__shared_weak_count *)a2[6];
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  if (v14)
  {
    v18 = (unint64_t ***)a2[5];
    v19 = *v18;
    v20 = v18[1];
    while (v19 != v20)
      MIL::Util::HashCombine(&v28, *v19++);
  }
  else
  {
    MIL::Util::HashCombine(&v28, 0);
  }
  v28 = v21;
  if (v15)
  {
    v22 = (unint64_t *)&v15->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v27)
  {
    v24 = (unint64_t *)&v27->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  return v21;
}

void sub_1E05C500C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  size_t v16;
  int v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  _BOOL4 v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v36;

  if (*(_DWORD *)a2 != *(_DWORD *)a3)
    return 0;
  v5 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a3 + 8);
  v7 = *(_QWORD *)(v5 + 8) - *(_QWORD *)v5;
  if (v7 != *(_QWORD *)(v6 + 8) - *(_QWORD *)v6 || memcmp(*(const void **)v5, *(const void **)v6, v7))
    return 0;
  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(std::__shared_weak_count **)(a2 + 32);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v12 = *(_QWORD *)(a3 + 24);
  v13 = *(std::__shared_weak_count **)(a3 + 32);
  if (v13)
  {
    v14 = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  if ((v8 != 0) != (v12 != 0)
    || v8
    && v12
    && ((v16 = *(_QWORD *)(v8 + 8) - *(_QWORD *)v8, v16 != *(_QWORD *)(v12 + 8) - *(_QWORD *)v12)
     || memcmp(*(const void **)v8, *(const void **)v12, v16)))
  {
    v17 = 0;
    if (!v13)
      goto LABEL_22;
  }
  else
  {
    v17 = 1;
    if (!v13)
      goto LABEL_22;
  }
  v18 = (unint64_t *)&v13->__shared_owners_;
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
LABEL_22:
  if (v9)
  {
    v20 = (unint64_t *)&v9->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v17)
  {
    v22 = *(_QWORD *)(a2 + 40);
    v23 = *(std::__shared_weak_count **)(a2 + 48);
    v36 = v23;
    if (v23)
    {
      v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldxr(v24);
      while (__stxr(v25 + 1, v24));
    }
    v26 = *(_QWORD *)(a3 + 40);
    v27 = *(std::__shared_weak_count **)(a3 + 48);
    if (v27)
    {
      v28 = (unint64_t *)&v27->__shared_owners_;
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }
    v30 = (v22 != 0) == (v26 != 0)
       && (!v22
        || !v26
        || !std::operator!=[abi:ne180100]<MIL::IRProperty const*,std::allocator<MIL::IRProperty const*>>(v22, v26));
    if (v27)
    {
      v31 = (unint64_t *)&v27->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    if (v36)
    {
      v33 = (unint64_t *)&v36->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    if (v30)
  }
  return 0;
}

void sub_1E05C52A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTypeStore<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRCircularBufferValueType const>::Get<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, _QWORD *a7, uint64_t *a8)
{
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD *v28;
  char v29;
  char v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77[5];
  uint64_t v78;
  std::__shared_weak_count *v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  int v86[4];
  std::__shared_weak_count *v87;
  std::__shared_weak_count *v88;
  std::__shared_weak_count *v89;
  std::__shared_weak_count *v90;
  uint64_t v91;
  _QWORD *v92;
  int v93[3];

  v16 = (std::__shared_weak_count *)a3[1];
  v84 = *a3;
  v85 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
  }
  v19 = (std::__shared_weak_count *)a4[1];
  v82 = *a4;
  v83 = v19;
  if (v19)
  {
    v20 = (unint64_t *)&v19->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v22 = (std::__shared_weak_count *)a5[1];
  v80 = *a5;
  v81 = v22;
  if (v22)
  {
    v23 = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  v25 = (std::__shared_weak_count *)a6[1];
  v78 = *a6;
  v79 = v25;
  if (v25)
  {
    v26 = (unint64_t *)&v25->__shared_owners_;
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v77, (uint64_t)a8);
  v93[0] = a2;
  v92 = a7;
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4ELm5ELm6EEEEJN3MIL10IRDataTypeENS_10shared_ptrINS_6vectorIPKNS3_11IRDimensionENS_9allocatorIS9_EEEEEESD_NS5_INS6_IPKNS3_10IRPropertyENSA_ISG_EEEEEESJ_SG_NS_13unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENSA_IcEEEENS5_IKNS3_7IRValueEEENS_4hashISP_EENS_8equal_toISP_EENSA_INS_4pairIKSP_SS_EEEEEEEEC2B8ne180100IJLm0ELm1ELm2ELm3ELm4ELm5ELm6EEJS4_SD_SD_SJ_SJ_SG_S11_EJEJEJRS4_RSD_S15_RSJ_S16_RSG_S11_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENS19_IJDpT2_EEEDpOT3_((uint64_t)v86, v93, &v84, &v82, &v80, &v78, &v92, v77);
  v92 = 0;
  v28 = std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>>>::__emplace_unique_key_args<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,decltype(nullptr)>(a1, v86, (uint64_t)v86);
  v30 = v29;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&v91);
  v31 = v90;
  if (v90)
  {
    v32 = (unint64_t *)&v90->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v89;
  if (v89)
  {
    v35 = (unint64_t *)&v89->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = v88;
  if (v88)
  {
    v38 = (unint64_t *)&v88->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  v40 = v87;
  if (v87)
  {
    v41 = (unint64_t *)&v87->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v77);
  v43 = v79;
  if (v79)
  {
    v44 = (unint64_t *)&v79->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
  v46 = v81;
  if (v81)
  {
    v47 = (unint64_t *)&v81->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  v49 = v83;
  if (v83)
  {
    v50 = (unint64_t *)&v83->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  v52 = v85;
  if (v85)
  {
    v53 = (unint64_t *)&v85->__shared_owners_;
    do
      v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  if (v30)
  {
    v55 = *(_OWORD *)a3;
    *a3 = 0;
    a3[1] = 0;
    v75 = *(_OWORD *)a4;
    v76 = v55;
    *a4 = 0;
    a4[1] = 0;
    v56 = *(_OWORD *)a5;
    *a5 = 0;
    a5[1] = 0;
    v73 = *(_OWORD *)a6;
    v74 = v56;
    *a6 = 0;
    a6[1] = 0;
    MIL::IRCircularBufferValueType::Make(a2, (uint64_t *)&v76, (uint64_t *)&v75, (uint64_t *)&v74, (uint64_t *)&v73, a7, a8, v86);
    v57 = *(_QWORD *)v86;
    *(_QWORD *)v86 = 0;
    v58 = v28[17];
    v28[17] = v57;
    if (v58)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v58 + 8))(v58);
      v59 = *(_QWORD *)v86;
      *(_QWORD *)v86 = 0;
      if (v59)
        (*(void (**)(uint64_t))(*(_QWORD *)v59 + 8))(v59);
    }
    v60 = (std::__shared_weak_count *)*((_QWORD *)&v73 + 1);
    if (*((_QWORD *)&v73 + 1))
    {
      v61 = (unint64_t *)(*((_QWORD *)&v73 + 1) + 8);
      do
        v62 = __ldaxr(v61);
      while (__stlxr(v62 - 1, v61));
      if (!v62)
      {
        ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
        std::__shared_weak_count::__release_weak(v60);
      }
    }
    v63 = (std::__shared_weak_count *)*((_QWORD *)&v74 + 1);
    if (*((_QWORD *)&v74 + 1))
    {
      v64 = (unint64_t *)(*((_QWORD *)&v74 + 1) + 8);
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
        std::__shared_weak_count::__release_weak(v63);
      }
    }
    v66 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
    if (*((_QWORD *)&v75 + 1))
    {
      v67 = (unint64_t *)(*((_QWORD *)&v75 + 1) + 8);
      do
        v68 = __ldaxr(v67);
      while (__stlxr(v68 - 1, v67));
      if (!v68)
      {
        ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
        std::__shared_weak_count::__release_weak(v66);
      }
    }
    v69 = (std::__shared_weak_count *)*((_QWORD *)&v76 + 1);
    if (*((_QWORD *)&v76 + 1))
    {
      v70 = (unint64_t *)(*((_QWORD *)&v76 + 1) + 8);
      do
        v71 = __ldaxr(v70);
      while (__stlxr(v71 - 1, v70));
      if (!v71)
      {
        ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
        std::__shared_weak_count::__release_weak(v69);
      }
    }
  }
  return v28[17];
}

void sub_1E05C573C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>::~tuple(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 80);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 56);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 40);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 24);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 8);
  return a1;
}

uint64_t std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(uint64_t a1, int *a2)
{
  unint64_t ***v3;
  unint64_t **v4;
  unint64_t **v5;
  unint64_t *v6;
  unint64_t ***v7;
  unint64_t **v8;
  unint64_t **v9;
  unint64_t *v10;
  unint64_t ***v11;
  unint64_t **v12;
  unint64_t **v13;
  unint64_t *v14;
  unint64_t ***v15;
  unint64_t **v16;
  unint64_t **v17;
  unint64_t *v18;
  uint64_t v20;

  v20 = 0;
  MIL::Util::HashCombine(&v20, (unint64_t *)*a2);
  v3 = (unint64_t ***)*((_QWORD *)a2 + 1);
  v4 = *v3;
  v5 = v3[1];
  while (v4 != v5)
  {
    v6 = *v4++;
    MIL::Util::HashCombine(&v20, v6);
  }
  v7 = (unint64_t ***)*((_QWORD *)a2 + 3);
  v8 = *v7;
  v9 = v7[1];
  while (v8 != v9)
  {
    v10 = *v8++;
    MIL::Util::HashCombine(&v20, v10);
  }
  v11 = (unint64_t ***)*((_QWORD *)a2 + 5);
  v12 = *v11;
  v13 = v11[1];
  while (v12 != v13)
  {
    v14 = *v12++;
    MIL::Util::HashCombine(&v20, v14);
  }
  v15 = (unint64_t ***)*((_QWORD *)a2 + 7);
  v16 = *v15;
  v17 = v15[1];
  while (v16 != v17)
  {
    v18 = *v16++;
    MIL::Util::HashCombine(&v20, v18);
  }
  MIL::Util::HashCombine(&v20, *((unint64_t **)a2 + 9));
}

BOOL std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;

  if (*(_DWORD *)a2 != *(_DWORD *)a3)
    return 0;
  v5 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a3 + 8);
  v7 = *(_QWORD *)(v5 + 8) - *(_QWORD *)v5;
  if (v7 != *(_QWORD *)(v6 + 8) - *(_QWORD *)v6)
    return 0;
  if (memcmp(*(const void **)v5, *(const void **)v6, v7))
    return 0;
  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(_QWORD *)(a3 + 24);
  v10 = *(_QWORD *)(v8 + 8) - *(_QWORD *)v8;
  if (v10 != *(_QWORD *)(v9 + 8) - *(_QWORD *)v9)
    return 0;
  if (!memcmp(*(const void **)v8, *(const void **)v9, v10)
    && (v11 = *(_QWORD *)(a2 + 40),
        v12 = *(_QWORD *)(a3 + 40),
        v13 = *(_QWORD *)(v11 + 8) - *(_QWORD *)v11,
        v13 == *(_QWORD *)(v12 + 8) - *(_QWORD *)v12)
    && !memcmp(*(const void **)v11, *(const void **)v12, v13)
    && (v14 = *(_QWORD *)(a2 + 56),
        v15 = *(_QWORD *)(a3 + 56),
        v16 = *(_QWORD *)(v14 + 8) - *(_QWORD *)v14,
        v16 == *(_QWORD *)(v15 + 8) - *(_QWORD *)v15)
    && !memcmp(*(const void **)v14, *(const void **)v15, v16)
    && *(_QWORD *)(a2 + 72) == *(_QWORD *)(a3 + 72))
  {
  }
  else
  {
    return 0;
  }
}

uint64_t MIL::IRTypeStore<MIL::IRValueType const*,MIL::IRStateValueType const>::Get<MIL::IRValueType const*>(uint64_t a1, MIL::IRStateValueType *a2)
{
  _QWORD *v3;
  char v4;
  MIL::IRStateValueType *v5;
  uint64_t v6;
  MIL::IRStateValueType *v7;
  MIL::IRStateValueType *v9;

  v9 = a2;
  v3 = std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::__emplace_unique_key_args<MIL::IRValueType const*,MIL::IRValueType const*,decltype(nullptr)>(a1, &v9, &v9);
  if (v4)
  {
    MIL::IRStateValueType::Make(a2, &v9);
    v5 = v9;
    v9 = 0;
    v6 = v3[3];
    v3[3] = v5;
    if (v6)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      v7 = v9;
      v9 = 0;
      if (v7)
        (*(void (**)(MIL::IRStateValueType *))(*(_QWORD *)v7 + 8))(v7);
    }
  }
  return v3[3];
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4ELm5EEEEJN3MIL10IRDataTypeENS_10shared_ptrINS_6vectorIPKNS3_11IRDimensionENS_9allocatorIS9_EEEEEENS5_INS6_IPKNS3_10IRPropertyENSA_ISG_EEEEEESG_SJ_NS_13unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENSA_IcEEEENS5_IKNS3_7IRValueEEENS_4hashISP_EENS_8equal_toISP_EENSA_INS_4pairIKSP_SS_EEEEEEEEC2B8ne180100IJLm0ELm1ELm2ELm3ELm4ELm5EEJS4_SD_SJ_SG_SJ_S11_EJEJEJRS4_RSD_RSJ_RSG_S16_S11_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENS19_IJDpT2_EEEDpOT3_(uint64_t a1, _DWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  *(_DWORD *)a1 = *a2;
  v8 = a3[1];
  *(_QWORD *)(a1 + 8) = *a3;
  *(_QWORD *)(a1 + 16) = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = a4[1];
  *(_QWORD *)(a1 + 24) = *a4;
  *(_QWORD *)(a1 + 32) = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v15 = *a6;
  v14 = a6[1];
  *(_QWORD *)(a1 + 40) = *a5;
  *(_QWORD *)(a1 + 48) = v15;
  *(_QWORD *)(a1 + 56) = v14;
  if (v14)
  {
    v16 = (unint64_t *)(v14 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 64, a7);
  return a1;
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4EEEEJN3MIL17IRPixelFormatTypeENS_10shared_ptrINS_6vectorIPKNS3_11IRDimensionENS_9allocatorIS9_EEEEEENS5_INS6_IPKNS3_10IRPropertyENSA_ISG_EEEEEESJ_NS_13unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENSA_IcEEEENS5_IKNS3_7IRValueEEENS_4hashISP_EENS_8equal_toISP_EENSA_INS_4pairIKSP_SS_EEEEEEEEC2B8ne180100IJLm0ELm1ELm2ELm3ELm4EEJS4_SD_SJ_SJ_S11_EJEJEJRS4_RSD_RSJ_S16_S11_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENS18_IJDpT2_EEEDpOT3_(uint64_t a1, _DWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, uint64_t *a6)
{
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  *(_DWORD *)a1 = *a2;
  v7 = a3[1];
  *(_QWORD *)(a1 + 8) = *a3;
  *(_QWORD *)(a1 + 16) = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = a4[1];
  *(_QWORD *)(a1 + 24) = *a4;
  *(_QWORD *)(a1 + 32) = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = a5[1];
  *(_QWORD *)(a1 + 40) = *a5;
  *(_QWORD *)(a1 + 48) = v13;
  if (v13)
  {
    v14 = (unint64_t *)(v13 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 56, a6);
  return a1;
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4ELm5ELm6EEEEJN3MIL10IRDataTypeENS_10shared_ptrINS_6vectorIPKNS3_11IRDimensionENS_9allocatorIS9_EEEEEESD_NS5_INS6_IPKNS3_10IRPropertyENSA_ISG_EEEEEESJ_SG_NS_13unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENSA_IcEEEENS5_IKNS3_7IRValueEEENS_4hashISP_EENS_8equal_toISP_EENSA_INS_4pairIKSP_SS_EEEEEEEEC2B8ne180100IJLm0ELm1ELm2ELm3ELm4ELm5ELm6EEJS4_SD_SD_SJ_SJ_SG_S11_EJEJEJRS4_RSD_S15_RSJ_S16_RSG_S11_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENS19_IJDpT2_EEEDpOT3_(uint64_t a1, _DWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7, uint64_t *a8)
{
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;

  *(_DWORD *)a1 = *a2;
  v9 = a3[1];
  *(_QWORD *)(a1 + 8) = *a3;
  *(_QWORD *)(a1 + 16) = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v12 = a4[1];
  *(_QWORD *)(a1 + 24) = *a4;
  *(_QWORD *)(a1 + 32) = v12;
  if (v12)
  {
    v13 = (unint64_t *)(v12 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = a5[1];
  *(_QWORD *)(a1 + 40) = *a5;
  *(_QWORD *)(a1 + 48) = v15;
  if (v15)
  {
    v16 = (unint64_t *)(v15 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v18 = a6[1];
  *(_QWORD *)(a1 + 56) = *a6;
  *(_QWORD *)(a1 + 64) = v18;
  if (v18)
  {
    v19 = (unint64_t *)(v18 + 8);
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  *(_QWORD *)(a1 + 72) = *a7;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 80, a8);
  return a1;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>>>::__emplace_unique_key_args<unsigned long long,unsigned long long,decltype(nullptr)>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = (_QWORD *)(a1 + 16);
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v6;
  i[2] = *a3;
  i[3] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *i = *v20;
LABEL_38:
    *v20 = i;
    goto LABEL_39;
  }
  *i = *v12;
  *v12 = i;
  *(_QWORD *)(v19 + 8 * v3) = v12;
  if (*i)
  {
    v21 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1E05C5E58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,void *>>>::operator()[abi:ne180100](uint64_t a1, _QWORD *__p)
{
  uint64_t v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = __p[3];
    __p[3] = 0;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

_QWORD *std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<MIL::IRConstantProperty const>>>>::__emplace_unique_key_args<long long,long long,decltype(nullptr)>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = (_QWORD *)(a1 + 16);
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v6;
  i[2] = *a3;
  i[3] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *i = *v20;
LABEL_38:
    *v20 = i;
    goto LABEL_39;
  }
  *i = *v12;
  *v12 = i;
  *(_QWORD *)(v19 + 8 * v3) = v12;
  if (*i)
  {
    v21 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1E05C60F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned char,std::unique_ptr<MIL::IRConstantProperty const>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::unique_ptr<MIL::IRConstantProperty const>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::unique_ptr<MIL::IRConstantProperty const>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::unique_ptr<MIL::IRConstantProperty const>>>>::__emplace_unique_key_args<unsigned char,unsigned char,decltype(nullptr)>(uint64_t a1, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((unsigned __int8 *)v10 + 16) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v12 = (_QWORD *)(a1 + 16);
  v10 = operator new(0x20uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_BYTE *)v10 + 16) = *a3;
  v10[3] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *v10 = *v20;
LABEL_38:
    *v20 = v10;
    goto LABEL_39;
  }
  *v10 = *v12;
  *v12 = v10;
  *(_QWORD *)(v19 + 8 * v3) = v12;
  if (*v10)
  {
    v21 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_1E05C633C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantProperty const>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantProperty const>>>>::__emplace_unique_key_args<unsigned long long,unsigned long long,decltype(nullptr)>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = (_QWORD *)(a1 + 16);
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v6;
  i[2] = *a3;
  i[3] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *i = *v20;
LABEL_38:
    *v20 = i;
    goto LABEL_39;
  }
  *i = *v12;
  *v12 = i;
  *(_QWORD *)(v19 + 8 * v3) = v12;
  if (*i)
  {
    v21 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1E05C6580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>>>::__emplace_unique_key_args<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,decltype(nullptr)>(uint64_t a1, int *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  char *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[2];
  char v26;

  v7 = std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(a1, a2);
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      v13 = (_QWORD *)*v12;
      if (*v12)
      {
        do
        {
          v14 = v13[1];
          if (v14 == v8)
          {
            LOBYTE(v7) = std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(v7, (uint64_t)(v13 + 2), (uint64_t)a2);
            if ((v7 & 1) != 0)
              return v13;
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9)
                v14 %= v9;
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3)
              break;
          }
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
    }
  }
  v15 = (char *)operator new(0x58uLL);
  v25[0] = v15;
  v25[1] = a1 + 16;
  *(_QWORD *)v15 = 0;
  *((_QWORD *)v15 + 1) = v8;
  *((_DWORD *)v15 + 4) = *(_DWORD *)a3;
  *(_OWORD *)(v15 + 24) = *(_OWORD *)(a3 + 8);
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)(v15 + 40), (uint64_t *)(a3 + 24));
  *((_QWORD *)v15 + 10) = 0;
  v26 = 1;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v23 >= v9)
          v23 %= v9;
      }
      else
      {
        v23 &= v9 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  v13 = (_QWORD *)v25[0];
  v25[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return v13;
}

void sub_1E05C6814(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRTensorValueType const>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

uint64_t std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRTensorValueType const>>,0>(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 24);
  return std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 8);
}

_QWORD *std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>>>::__emplace_unique_key_args<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,decltype(nullptr)>(uint64_t a1, uint64_t *a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  _QWORD **v12;
  _QWORD *i;
  unint64_t v14;
  _QWORD *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[2];
  char v28;

  v8 = *a2;
  v7 = (unint64_t *)a2[1];
  v27[0] = v8;
  MIL::Util::HashCombine(v27, v7);
  v9 = v27[0];
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v3 = v27[0];
      if (v27[0] >= v10)
        v3 = v27[0] % v10;
    }
    else
    {
      v3 = (v10 - 1) & v27[0];
    }
    v12 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = (_QWORD *)*i)
      {
        v14 = i[1];
        if (v14 == v27[0])
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10)
              v14 %= v10;
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  v16 = (_QWORD *)(a1 + 16);
  i = operator new(0x28uLL);
  v27[1] = a1 + 16;
  *i = 0;
  i[1] = v9;
  *((_OWORD *)i + 1) = *a3;
  i[4] = 0;
  v28 = 1;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    v19 = 1;
    if (v10 >= 3)
      v19 = (v10 & (v10 - 1)) != 0;
    v20 = v19 | (2 * v10);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v24)
  {
    *i = *v24;
LABEL_42:
    *v24 = i;
    goto LABEL_43;
  }
  *i = *v16;
  *v16 = i;
  *(_QWORD *)(v23 + 8 * v3) = v16;
  if (*i)
  {
    v25 = *(_QWORD *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10)
        v25 %= v10;
    }
    else
    {
      v25 &= v10 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_42;
  }
LABEL_43:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1E05C6AF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>,void *>>>::operator()[abi:ne180100](uint64_t a1, _QWORD *__p)
{
  uint64_t v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = __p[4];
    __p[4] = 0;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void *std::__hash_table<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::__unordered_map_hasher<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::__unordered_map_equal<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>>>::__emplace_unique_key_args<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::shared_ptr<std::vector<MIL::IRValueType const*>>,decltype(nullptr)>(uint64_t a1, unint64_t ****a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  void *i;
  unint64_t v14;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  v7 = std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>::operator()(a1, a2);
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = *(void **)i)
      {
        v14 = *((_QWORD *)i + 1);
        if (v14 == v8)
        {
          LOBYTE(v7) = std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>::operator()(v7, (const void ***)i + 2, (uint64_t *)a2);
          if ((v7 & 1) != 0)
            return i;
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  i = operator new(0x28uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v8;
  *((_OWORD *)i + 1) = *(_OWORD *)a3;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *((_QWORD *)i + 4) = 0;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v23)
  {
    *(_QWORD *)i = *v23;
LABEL_38:
    *v23 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v15;
  *v15 = i;
  *(_QWORD *)(v22 + 8 * v3) = v15;
  if (*(_QWORD *)i)
  {
    v24 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9)
        v24 %= v9;
    }
    else
    {
      v24 &= v9 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1E05C6DAC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,void *>>>::operator()[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = a2[4];
    a2[4] = 0;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 2));
  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

_QWORD *std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>>>::__emplace_unique_key_args<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,decltype(nullptr)>(uint64_t a1, uint64_t *a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  _QWORD **v12;
  _QWORD *i;
  unint64_t v14;
  _QWORD *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[2];
  char v28;

  v8 = *a2;
  v7 = (unint64_t *)a2[1];
  v27[0] = v8;
  MIL::Util::HashCombine(v27, v7);
  v9 = v27[0];
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v3 = v27[0];
      if (v27[0] >= v10)
        v3 = v27[0] % v10;
    }
    else
    {
      v3 = (v10 - 1) & v27[0];
    }
    v12 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = (_QWORD *)*i)
      {
        v14 = i[1];
        if (v14 == v27[0])
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10)
              v14 %= v10;
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  v16 = (_QWORD *)(a1 + 16);
  i = operator new(0x28uLL);
  v27[1] = a1 + 16;
  *i = 0;
  i[1] = v9;
  *((_OWORD *)i + 1) = *a3;
  i[4] = 0;
  v28 = 1;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    v19 = 1;
    if (v10 >= 3)
      v19 = (v10 & (v10 - 1)) != 0;
    v20 = v19 | (2 * v10);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v24)
  {
    *i = *v24;
LABEL_42:
    *v24 = i;
    goto LABEL_43;
  }
  *i = *v16;
  *v16 = i;
  *(_QWORD *)(v23 + 8 * v3) = v16;
  if (*i)
  {
    v25 = *(_QWORD *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10)
        v25 %= v10;
    }
    else
    {
      v25 &= v10 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_42;
  }
LABEL_43:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1E05C7070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,std::unique_ptr<MIL::IRListValueType const>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>>>::__emplace_unique_key_args<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,decltype(nullptr)>(uint64_t a1, int *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[2];
  char v26;

  v7 = std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(a1, a2);
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      v13 = (_QWORD *)*v12;
      if (*v12)
      {
        do
        {
          v14 = v13[1];
          if (v14 == v8)
          {
            LOBYTE(v7) = std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(v7, (uint64_t)(v13 + 2), (uint64_t)a2);
            if ((v7 & 1) != 0)
              return v13;
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9)
                v14 %= v9;
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3)
              break;
          }
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
    }
  }
  v15 = operator new(0x80uLL);
  v25[0] = v15;
  v25[1] = a1 + 16;
  *v15 = 0;
  v15[1] = v8;
  std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul,4ul,5ul>,MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>::__tuple_impl((uint64_t)(v15 + 2), a3);
  v15[15] = 0;
  v26 = 1;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v23 >= v9)
          v23 %= v9;
      }
      else
      {
        v23 &= v9 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  v13 = (_QWORD *)v25[0];
  v25[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return v13;
}

void sub_1E05C72EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul,4ul,5ul>,MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>::__tuple_impl(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 64, (uint64_t *)(a2 + 64));
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRTensorBufferValueType const>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

uint64_t std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRTensorBufferValueType const>>,0>(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 64);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 48);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 24);
  return std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 8);
}

_QWORD *std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>>>::__emplace_unique_key_args<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,decltype(nullptr)>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[2];
  char v26;

  v7 = std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(a1, a2);
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      v13 = (_QWORD *)*v12;
      if (*v12)
      {
        do
        {
          v14 = v13[1];
          if (v14 == v8)
          {
            LOBYTE(v7) = std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(v7, (uint64_t)(v13 + 2), (uint64_t)a2);
            if ((v7 & 1) != 0)
              return v13;
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9)
                v14 %= v9;
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3)
              break;
          }
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
    }
  }
  v15 = operator new(0x78uLL);
  v25[0] = v15;
  v25[1] = a1 + 16;
  *v15 = 0;
  v15[1] = v8;
  std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul,4ul>,MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>::__tuple_impl((uint64_t)(v15 + 2), a3);
  v15[14] = 0;
  v26 = 1;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v23 >= v9)
          v23 %= v9;
      }
      else
      {
        v23 &= v9 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  v13 = (_QWORD *)v25[0];
  v25[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return v13;
}

void sub_1E05C7658(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul,4ul>,MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>::__tuple_impl(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 56, (uint64_t *)(a2 + 56));
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRPixelBufferValueType const>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

uint64_t std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRPixelBufferValueType const>>,0>(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 96);
  *(_QWORD *)(a1 + 96) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 56);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 40);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 24);
  return std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 8);
}

_QWORD *std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>>>::__emplace_unique_key_args<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,decltype(nullptr)>(uint64_t a1, int *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[2];
  char v26;

  v7 = std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(a1, a2);
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      v13 = (_QWORD *)*v12;
      if (*v12)
      {
        do
        {
          v14 = v13[1];
          if (v14 == v8)
          {
            LOBYTE(v7) = std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>::operator()(v7, (uint64_t)(v13 + 2), (uint64_t)a2);
            if ((v7 & 1) != 0)
              return v13;
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9)
                v14 %= v9;
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3)
              break;
          }
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
    }
  }
  v15 = operator new(0x90uLL);
  v25[0] = v15;
  v25[1] = a1 + 16;
  *v15 = 0;
  v15[1] = v8;
  std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul,4ul,5ul,6ul>,MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>::__tuple_impl((uint64_t)(v15 + 2), a3);
  v15[17] = 0;
  v26 = 1;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v21);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v23 >= v9)
          v23 %= v9;
      }
      else
      {
        v23 &= v9 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  v13 = (_QWORD *)v25[0];
  v25[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return v13;
}

void sub_1E05C79BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul,4ul,5ul,6ul>,MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>::__tuple_impl(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(a1 + 80, (uint64_t *)(a2 + 80));
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRCircularBufferValueType const>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

uint64_t std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRCircularBufferValueType const>>,0>(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a1 + 120) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a1 + 80);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 56);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 40);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 24);
  return std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](a1 + 8);
}

_QWORD *std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::__emplace_unique_key_args<MIL::IRValueType const*,MIL::IRValueType const*,decltype(nullptr)>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  v14 = (_QWORD *)(a1 + 16);
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  i[3] = 0;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *i = *v22;
LABEL_38:
    *v22 = i;
    goto LABEL_39;
  }
  *i = *v14;
  *v14 = i;
  *(_QWORD *)(v21 + 8 * v3) = v14;
  if (*i)
  {
    v23 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9)
        v23 %= v9;
    }
    else
    {
      v23 &= v9 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1E05C7D3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unique_ptr<MIL::IRConstantDimension const>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

uint64_t MIL::IsEqualOrStrongerType(MIL *this, const MIL::IRValueType *a2, const MIL::IRValueType *a3)
{
  const MIL::IRValueType *v3;
  MIL *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t IsEqualOrStrongerType;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  MIL *v31;
  _QWORD *v32;
  const MIL::IRValueType *v33;
  _QWORD *v34;
  uint64_t v35;
  _anonymous_namespace_ *v36;
  const MIL::IRDictionaryValueType *v37;
  const MIL::IRDictionaryValueType *v38;
  void *v40;
  void *v41;
  _anonymous_namespace_ *v42;
  _anonymous_namespace_ *v43;
  void *v44;
  const MIL::IRTensorBufferValueType *v45;
  const MIL::IRTensorBufferValueType *v46;
  _anonymous_namespace_ *v47;
  void *v48;
  const MIL::IRPixelBufferValueType *v49;
  const MIL::IRPixelBufferValueType *v50;
  _anonymous_namespace_ *v51;
  _anonymous_namespace_ *v52;
  void *v53;
  const MIL::IRCircularBufferValueType *v54;
  const MIL::IRCircularBufferValueType *v55;
  _anonymous_namespace_ *v56;
  _anonymous_namespace_ *v57;
  const MIL::IRStateValueType *v58;
  const MIL::IRStateValueType *v59;
  std::runtime_error *exception;
  void *__p;
  void *v62;
  uint64_t v63;
  void *v64;
  void *v65;
  uint64_t v66;
  void *v67;
  _BYTE *v68;
  uint64_t v69;
  void *v70;
  _BYTE *v71;
  uint64_t v72;

  if (this == a2)
    return 1;
  v3 = a2;
  v4 = this;
  while (1)
  {
    v5 = (*(uint64_t (**)(MIL *))(*(_QWORD *)v4 + 24))(v4);
    if (v5)
      break;
    v6 = (*(uint64_t (**)(MIL *))(*(_QWORD *)v4 + 32))(v4);
    if (!v6)
    {
      v22 = (*(uint64_t (**)(MIL *))(*(_QWORD *)v4 + 40))(v4);
      if (v22)
      {
        v23 = v22;
        v24 = (*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)v3 + 40))(v3);
        if (v24)
        {
          v25 = v24;
          v26 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v23 + 64))(v23);
          v27 = v26[1] - *v26;
          v28 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v25 + 64))(v25);
          if (v27 == v28[1] - *v28)
          {
            v29 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v23 + 64))(v23);
            if (v29[1] == *v29)
              return 1;
            v30 = 0;
            do
            {
              v31 = *(MIL **)(*(_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v23 + 64))(v23) + 8 * v30);
              v32 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v25 + 64))(v25);
              IsEqualOrStrongerType = MIL::IsEqualOrStrongerType(v31, *(const MIL::IRValueType **)(*v32 + 8 * v30), v33);
              if ((IsEqualOrStrongerType & 1) == 0)
                break;
              ++v30;
              v34 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v23 + 64))(v23);
            }
            while (v30 < (uint64_t)(v34[1] - *v34) >> 3);
            return IsEqualOrStrongerType;
          }
        }
      }
      else
      {
        v35 = (*(uint64_t (**)(MIL *))(*(_QWORD *)v4 + 48))(v4);
        if (!v35)
        {
          v40 = MIL::IRValueType::TryCastAsMemoryLayoutType(v4);
          if (v40)
          {
            v41 = v40;
            v42 = (_anonymous_namespace_ *)MIL::IRMemoryLayoutValueType::TryAsTensorBufferType(v40);
            v43 = (_anonymous_namespace_ *)MIL::IRMemoryLayoutValueType::TryAsPixelBufferType(v41);
            if (v42)
            {
              v44 = MIL::IRValueType::TryCastAsMemoryLayoutType(v3);
              if (v44)
              {
                v45 = (const MIL::IRTensorBufferValueType *)MIL::IRMemoryLayoutValueType::TryAsTensorBufferType(v44);
                if (v45)
              }
              return 0;
            }
            v47 = v43;
            if (v43)
            {
              v48 = MIL::IRValueType::TryCastAsMemoryLayoutType(v3);
              if (v48)
              {
                v49 = (const MIL::IRPixelBufferValueType *)MIL::IRMemoryLayoutValueType::TryAsPixelBufferType(v48);
                if (v49)
              }
              return 0;
            }
            v51 = (_anonymous_namespace_ *)MIL::IRMemoryLayoutValueType::TryAsCircularBufferType(v41);
            if (v51)
            {
              v52 = v51;
              v53 = MIL::IRValueType::TryCastAsMemoryLayoutType(v3);
              if (v53)
              {
                v54 = (const MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::TryAsCircularBufferType(v53);
                if (v54)
              }
              return 0;
            }
          }
          v56 = (_anonymous_namespace_ *)MIL::IRValueType::TryCastAsStateType(v4);
          if (!v56)
          {
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Unsupported MIL type for comparison.");
            __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
          }
          v57 = v56;
          v58 = (const MIL::IRStateValueType *)MIL::IRValueType::TryCastAsStateType(v3);
          if (v58)
          return 0;
        }
        v36 = (_anonymous_namespace_ *)v35;
        v37 = (const MIL::IRDictionaryValueType *)(*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)v3 + 48))(v3);
        if (v37)
      }
      return 0;
    }
    v7 = v6;
    IsEqualOrStrongerType = (*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)v3 + 32))(v3);
    if (!IsEqualOrStrongerType)
      return IsEqualOrStrongerType;
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 72))(v7);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
    if (v10)
    {
      v11 = v10;
      v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)IsEqualOrStrongerType + 72))(IsEqualOrStrongerType);
      v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
      if (!v13)
        return 0;
      v14 = v13;
      v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 48))(v11);
      if (v15 != (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 48))(v14))
        return 0;
    }
    v4 = (MIL *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 64))(v7);
    v3 = (const MIL::IRValueType *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)IsEqualOrStrongerType + 64))(IsEqualOrStrongerType);
    if (v4 == v3)
      return 1;
  }
  v16 = v5;
  IsEqualOrStrongerType = (*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)v3 + 24))(v3);
  if (!IsEqualOrStrongerType)
    return IsEqualOrStrongerType;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v16 + 88))(v16) != 18)
  {
    v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 88))(v16);
    if (v17 != (*(unsigned int (**)(uint64_t))(*(_QWORD *)IsEqualOrStrongerType + 88))(IsEqualOrStrongerType))
      return 0;
  }
  v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 96))(v16);
  v71 = 0;
  v72 = 0;
  v70 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v70, *(const void **)v18, *(_QWORD *)(v18 + 8), (uint64_t)(*(_QWORD *)(v18 + 8) - *(_QWORD *)v18) >> 3);
  v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)IsEqualOrStrongerType + 96))(IsEqualOrStrongerType);
  v67 = 0;
  v68 = 0;
  v69 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v67, *(const void **)v19, *(_QWORD *)(v19 + 8), (uint64_t)(*(_QWORD *)(v19 + 8) - *(_QWORD *)v19) >> 3);
  v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 104))(v16);
  v64 = 0;
  v65 = 0;
  v66 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v64, v70, (uint64_t)v71, (v71 - (_BYTE *)v70) >> 3);
  v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)IsEqualOrStrongerType + 104))(IsEqualOrStrongerType);
  __p = 0;
  v62 = 0;
  v63 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&__p, v67, (uint64_t)v68, (v68 - (_BYTE *)v67) >> 3);
  if (__p)
  {
    v62 = __p;
    operator delete(__p);
  }
  if (v64)
  {
    v65 = v64;
    operator delete(v64);
  }
  if (v67)
  {
    v68 = v67;
    operator delete(v67);
  }
  if (v70)
  {
    v71 = v70;
    operator delete(v70);
  }
  return IsEqualOrStrongerType;
}

void sub_1E05C8284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  void *v19;

  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IsEqualOrStrongerDictType(_anonymous_namespace_ *this, const MIL::IRDictionaryValueType *a2, const MIL::IRDictionaryValueType *a3)
{
  MIL *v5;
  const MIL::IRValueType *v6;
  const MIL::IRValueType *v7;
  uint64_t result;
  MIL *v9;
  const MIL::IRValueType *v10;
  const MIL::IRValueType *v11;

  v5 = (MIL *)(*(uint64_t (**)(_anonymous_namespace_ *, const MIL::IRDictionaryValueType *, const MIL::IRDictionaryValueType *))(*(_QWORD *)this + 64))(this, a2, a3);
  v6 = (const MIL::IRValueType *)(*(uint64_t (**)(const MIL::IRDictionaryValueType *))(*(_QWORD *)a2 + 64))(a2);
  result = MIL::IsEqualOrStrongerType(v5, v6, v7);
  if ((_DWORD)result)
  {
    v9 = (MIL *)(*(uint64_t (**)(_anonymous_namespace_ *))(*(_QWORD *)this + 72))(this);
    v10 = (const MIL::IRValueType *)(*(uint64_t (**)(const MIL::IRDictionaryValueType *))(*(_QWORD *)a2 + 72))(a2);
    return MIL::IsEqualOrStrongerType(v9, v10, v11);
  }
  return result;
}

uint64_t `anonymous namespace'::IsEqualOrStrongerTensorBufferType(_anonymous_namespace_ *this, const MIL::IRTensorBufferValueType *a2, const MIL::IRTensorBufferValueType *a3)
{
  const MIL::IRValueType *v5;
  int DataType;
  uint64_t result;
  _BOOL4 v8;
  uint64_t Strides;
  uint64_t v10;
  BOOL IsEqualOrStrongerPropertiesVec;
  _BOOL4 v12;
  uint64_t RowAlignmentInBytes;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  void *__p;
  void *v18;
  _QWORD *v19;
  void *v20;
  void *v21;
  _QWORD *v22;

  if (MIL::IRTensorBufferValueType::GetDataType(this) != 18)
  {
    DataType = MIL::IRTensorBufferValueType::GetDataType(this);
    if (DataType != MIL::IRTensorBufferValueType::GetDataType(a2))
      return 0;
  }
  if (!(_DWORD)result)
    return result;
  v8 = MIL::IRTensorBufferValueType::TryGetStrides(a2) == 0;
  if (v8 == (MIL::IRTensorBufferValueType::TryGetStrides(this) != 0))
    return 0;
  if (MIL::IRTensorBufferValueType::TryGetStrides(a2) && MIL::IRTensorBufferValueType::TryGetStrides(this))
  {
    Strides = MIL::IRTensorBufferValueType::GetStrides((MIL::IRTensorBufferValueTypeImpl **)this);
    v21 = 0;
    v22 = 0;
    v20 = 0;
    std::vector<MIL::IRProperty const*>::__init_with_size[abi:ne180100]<MIL::IRProperty const**,MIL::IRProperty const**>(&v20, *(const void **)Strides, *(_QWORD *)(Strides + 8), (uint64_t)(*(_QWORD *)(Strides + 8) - *(_QWORD *)Strides) >> 3);
    v10 = MIL::IRTensorBufferValueType::GetStrides((MIL::IRTensorBufferValueTypeImpl **)a2);
    __p = 0;
    v18 = 0;
    v19 = 0;
    std::vector<MIL::IRProperty const*>::__init_with_size[abi:ne180100]<MIL::IRProperty const**,MIL::IRProperty const**>(&__p, *(const void **)v10, *(_QWORD *)(v10 + 8), (uint64_t)(*(_QWORD *)(v10 + 8) - *(_QWORD *)v10) >> 3);
    if (__p)
    {
      v18 = __p;
      operator delete(__p);
    }
    if (v20)
    {
      v21 = v20;
      operator delete(v20);
    }
    if (!IsEqualOrStrongerPropertiesVec)
      return 0;
  }
  v12 = MIL::IRTensorBufferValueType::TryGetRowAlignmentInBytes(a2) == 0;
  if (v12 == (MIL::IRTensorBufferValueType::TryGetRowAlignmentInBytes(this) != 0))
    return 0;
  if (!MIL::IRTensorBufferValueType::TryGetRowAlignmentInBytes(a2))
    return 1;
  if (!MIL::IRTensorBufferValueType::TryGetRowAlignmentInBytes(this))
    return 1;
  RowAlignmentInBytes = MIL::IRTensorBufferValueType::TryGetRowAlignmentInBytes(this);
  v14 = MIL::IRTensorBufferValueType::TryGetRowAlignmentInBytes(a2);
  v15 = operator new(8uLL);
  *v15 = RowAlignmentInBytes;
  v21 = v15 + 1;
  v22 = v15 + 1;
  v20 = v15;
  v16 = operator new(8uLL);
  *v16 = v14;
  v18 = v16 + 1;
  v19 = v16 + 1;
  __p = v16;
  operator delete(v16);
  operator delete(v15);
  return (v14 & 1) != 0;
}

void sub_1E05C8570(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  void *v13;
  void *v14;
  void *v15;

  v15 = v14;
  operator delete(v15);
  operator delete(v13);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::IsEqualOrStrongerPixelBufferType(_anonymous_namespace_ *this, const MIL::IRPixelBufferValueType *a2, const MIL::IRPixelBufferValueType *a3)
{
  int PixelFormatType;
  uint64_t Shape;
  uint64_t v7;
  const MIL::IRValueType *v8;
  int HasEqualOrStrongerShape;
  uint64_t BytesPerRow;
  void ***v11;
  uint64_t result;
  void **v13;
  unint64_t v14;
  void *__p;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v20;

  if (MIL::IRPixelBufferValueType::GetPixelFormatType(this) != 20)
  {
    PixelFormatType = MIL::IRPixelBufferValueType::GetPixelFormatType(this);
    if (PixelFormatType != MIL::IRPixelBufferValueType::GetPixelFormatType(a2))
      return 0;
  }
  Shape = MIL::IRPixelBufferValueType::GetShape(this);
  v19 = 0;
  v20 = 0;
  v18 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v18, *(const void **)Shape, *(_QWORD *)(Shape + 8), (uint64_t)(*(_QWORD *)(Shape + 8) - *(_QWORD *)Shape) >> 3);
  v7 = MIL::IRPixelBufferValueType::GetShape(a2);
  __p = 0;
  v16 = 0;
  v17 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&__p, *(const void **)v7, *(_QWORD *)(v7 + 8), (uint64_t)(*(_QWORD *)(v7 + 8) - *(_QWORD *)v7) >> 3);
  if (__p)
  {
    v16 = __p;
    operator delete(__p);
  }
  if (v18)
  {
    v19 = v18;
    operator delete(v18);
  }
  if (!HasEqualOrStrongerShape)
    return 0;
  BytesPerRow = MIL::IRPixelBufferValueType::TryGetBytesPerRow(this);
  v11 = (void ***)MIL::IRPixelBufferValueType::TryGetBytesPerRow(a2);
  if (!BytesPerRow)
  {
    if (v11)
      return 0;
  }
  if (BytesPerRow && v11)
  if (!BytesPerRow)
    return 1;
  if (v11)
    return 1;
  v13 = *(void ***)BytesPerRow;
  if (*(_QWORD *)(BytesPerRow + 8) == *(_QWORD *)BytesPerRow)
    return 1;
  v14 = 0;
  while (1)
  {
    result = (uint64_t)MIL::IRProperty::TryAsUnknown(v13[v14]);
    if (!result)
      break;
    if ((MIL::IRUnknownProperty::IsVariadic((MIL::IRUnknownProperty *)result) & 1) == 0)
      return 0;
    ++v14;
    v13 = *(void ***)BytesPerRow;
    if (v14 >= (uint64_t)(*(_QWORD *)(BytesPerRow + 8) - *(_QWORD *)BytesPerRow) >> 3)
      return 1;
  }
  return result;
}

void sub_1E05C8718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

BOOL `anonymous namespace'::IsEqualOrStrongerCircularBufferType(_anonymous_namespace_ *this, const MIL::IRCircularBufferValueType *a2, const MIL::IRCircularBufferValueType *a3)
{
  int DataType;
  void *WrapDim;
  const MIL::IRValueType *v7;
  uint64_t Strides;
  uint64_t v9;
  _BOOL8 IsEqualOrStrongerPropertiesVec;
  void *v11;
  void *v12;
  MIL::IRConstantProperty *v13;
  uint64_t Int64ScalarValue;
  void *v15;
  MIL::IRConstantProperty *v16;
  void *__p;
  void *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;

  if (MIL::IRCircularBufferValueType::GetDataType(this) != 18)
  {
    DataType = MIL::IRCircularBufferValueType::GetDataType(this);
    if (DataType != MIL::IRCircularBufferValueType::GetDataType(a2))
      return 0;
  }
  WrapDim = (void *)MIL::IRCircularBufferValueType::GetWrapDim(this);
  if (!MIL::IRProperty::TryAsUnknown(WrapDim))
  {
    v11 = (void *)MIL::IRCircularBufferValueType::GetWrapDim(a2);
    if (MIL::IRProperty::TryAsUnknown(v11))
      return 0;
    v12 = (void *)MIL::IRCircularBufferValueType::GetWrapDim(this);
    v13 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(v12);
    Int64ScalarValue = MIL::IRConstantProperty::GetInt64ScalarValue(v13);
    v15 = (void *)MIL::IRCircularBufferValueType::GetWrapDim(a2);
    v16 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(v15);
    if (Int64ScalarValue != MIL::IRConstantProperty::GetInt64ScalarValue(v16))
      return 0;
  }
    return 0;
  Strides = MIL::IRCircularBufferValueType::GetStrides(this);
  v22 = 0;
  v23 = 0;
  v21 = 0;
  std::vector<MIL::IRProperty const*>::__init_with_size[abi:ne180100]<MIL::IRProperty const**,MIL::IRProperty const**>(&v21, *(const void **)Strides, *(_QWORD *)(Strides + 8), (uint64_t)(*(_QWORD *)(Strides + 8) - *(_QWORD *)Strides) >> 3);
  v9 = MIL::IRCircularBufferValueType::GetStrides(a2);
  __p = 0;
  v19 = 0;
  v20 = 0;
  std::vector<MIL::IRProperty const*>::__init_with_size[abi:ne180100]<MIL::IRProperty const**,MIL::IRProperty const**>(&__p, *(const void **)v9, *(_QWORD *)(v9 + 8), (uint64_t)(*(_QWORD *)(v9 + 8) - *(_QWORD *)v9) >> 3);
  if (__p)
  {
    v19 = __p;
    operator delete(__p);
  }
  if (v21)
  {
    v22 = v21;
    operator delete(v21);
  }
  return IsEqualOrStrongerPropertiesVec;
}

void sub_1E05C8884(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::IsEqualOrStrongerStateType(_anonymous_namespace_ *this, const MIL::IRStateValueType *a2, const MIL::IRStateValueType *a3)
{
  MIL *WrappedType;
  const MIL::IRValueType *v5;
  const MIL::IRValueType *v6;

  WrappedType = (MIL *)MIL::IRStateValueType::GetWrappedType(this);
  v5 = (const MIL::IRValueType *)MIL::IRStateValueType::GetWrappedType(a2);
  return MIL::IsEqualOrStrongerType(WrappedType, v5, v6);
}

const MIL::IRValueType *MIL::GetStrongestCompatibleType(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2, const MIL::IRValueType *a3, const MIL::IRValueType *a4)
{
  const MIL::IRValueType *v5;
  const MIL::IRValueType *v7;
  MIL::IRTensorValueType *v8;
  uint64_t v9;
  BOOL v10;
  MIL::IRTensorValueType *v11;
  uint64_t v12;
  int v13;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t i;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  int v37;
  void *__p;
  uint64_t *v40;
  char *v41;

  v5 = a2;
  if ((MIL::IsEqualOrStrongerType(a2, a3, a3) & 1) == 0)
  {
    if ((MIL::IsEqualOrStrongerType(a3, v5, v7) & 1) != 0)
      return a3;
    v8 = (MIL::IRTensorValueType *)(*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)v5 + 24))(v5);
    v9 = (*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)a3 + 24))(a3);
    if (v8)
      v10 = v9 == 0;
    else
      v10 = 1;
    if (v10)
      return 0;
    v11 = (MIL::IRTensorValueType *)v9;
    if (!(*(unsigned int (**)(MIL::IRTensorValueType *))(*(_QWORD *)v8 + 104))(v8))
      return 0;
    if (!(*(unsigned int (**)(MIL::IRTensorValueType *))(*(_QWORD *)v11 + 104))(v11))
      return 0;
    v12 = MIL::IRTensorValueType::Rank(v8);
    if (v12 != MIL::IRTensorValueType::Rank(v11))
      return 0;
    v13 = (*(uint64_t (**)(MIL::IRTensorValueType *))(*(_QWORD *)v8 + 88))(v8);
    if (v13 != (*(unsigned int (**)(MIL::IRTensorValueType *))(*(_QWORD *)v11 + 88))(v11))
      return 0;
    v14 = (uint64_t *)(*(uint64_t (**)(MIL::IRTensorValueType *))(*(_QWORD *)v8 + 96))(v8);
    v15 = (_QWORD *)(*(uint64_t (**)(MIL::IRTensorValueType *))(*(_QWORD *)v11 + 96))(v11);
    v40 = 0;
    v41 = 0;
    __p = 0;
    std::vector<std::string const*>::reserve(&__p, (v14[1] - *v14) >> 3);
    v16 = *v14;
    if (v14[1] != *v14)
    {
      for (i = 0; i < (v14[1] - *v14) >> 3; ++i)
      {
        v18 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v16 + 8 * i) + 16))(*(_QWORD *)(v16 + 8 * i));
        v19 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*v15 + 8 * i) + 16))(*(_QWORD *)(*v15 + 8 * i));
        v20 = v19;
        if (v18)
          v21 = v19 == 0;
        else
          v21 = 1;
        if (v21
          || (v22 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 48))(v18),
              v22 != (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 48))(v20)))
        {
          v18 = MIL::IRUnknownDimension::Make(this, 0);
          v23 = v40;
          if (v40 >= (uint64_t *)v41)
          {
            v29 = ((char *)v40 - (_BYTE *)__p) >> 3;
            if ((unint64_t)(v29 + 1) >> 61)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v30 = (v41 - (_BYTE *)__p) >> 2;
            if (v30 <= v29 + 1)
              v30 = v29 + 1;
            if ((unint64_t)(v41 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
              v26 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v26 = v30;
            if (v26)
              v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v41, v26);
            else
              v27 = 0;
            v31 = (uint64_t *)&v27[8 * v29];
            *v31 = v18;
            v28 = v31 + 1;
            v33 = (char *)__p;
            v32 = (char *)v40;
            if (v40 != __p)
            {
              do
              {
                v34 = *((_QWORD *)v32 - 1);
                v32 -= 8;
                *--v31 = v34;
              }
              while (v32 != v33);
LABEL_45:
              v32 = (char *)__p;
            }
LABEL_46:
            __p = v31;
            v40 = v28;
            v41 = &v27[8 * v26];
            if (v32)
              operator delete(v32);
            goto LABEL_48;
          }
        }
        else
        {
          v23 = v40;
          if (v40 >= (uint64_t *)v41)
          {
            v24 = ((char *)v40 - (_BYTE *)__p) >> 3;
            if ((unint64_t)(v24 + 1) >> 61)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v25 = (v41 - (_BYTE *)__p) >> 2;
            if (v25 <= v24 + 1)
              v25 = v24 + 1;
            if ((unint64_t)(v41 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
              v26 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v26 = v25;
            if (v26)
              v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v41, v26);
            else
              v27 = 0;
            v31 = (uint64_t *)&v27[8 * v24];
            *v31 = v18;
            v28 = v31 + 1;
            v35 = (char *)__p;
            v32 = (char *)v40;
            if (v40 != __p)
            {
              do
              {
                v36 = *((_QWORD *)v32 - 1);
                v32 -= 8;
                *--v31 = v36;
              }
              while (v32 != v35);
              goto LABEL_45;
            }
            goto LABEL_46;
          }
        }
        *v23 = v18;
        v28 = v23 + 1;
LABEL_48:
        v40 = v28;
        v16 = *v14;
      }
    }
    v37 = (*(uint64_t (**)(MIL::IRTensorValueType *))(*(_QWORD *)v8 + 88))(v8);
    v5 = (const MIL::IRValueType *)MIL::IRTensorValueType::MakeWithShape(this, v37, (uint64_t)&__p);
    if (__p)
    {
      v40 = (uint64_t *)__p;
      operator delete(__p);
    }
  }
  return v5;
}

void sub_1E05C8C68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::GetTensorShapeWithDimensionsAllKnown(MIL *this@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  uint64_t v20;
  std::logic_error *exception;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v4 = (_QWORD *)(*(uint64_t (**)(MIL *, const MIL::IRTensorValueType *))(*(_QWORD *)this + 96))(this, a2);
  std::vector<unsigned long long>::reserve((void **)a3, (uint64_t)(v4[1] - *v4) >> 3);
  v5 = (_QWORD *)*v4;
  v6 = (_QWORD *)v4[1];
  if ((_QWORD *)*v4 != v6)
  {
    do
    {
      v7 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v5 + 16))(*v5);
      if (!v7)
      {
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "IRTensorValueType contains unknown dimension.");
        exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
        __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
      }
      v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
      v9 = v8;
      v11 = *(uint64_t **)(a3 + 8);
      v10 = *(_QWORD *)(a3 + 16);
      if ((unint64_t)v11 >= v10)
      {
        v13 = *(uint64_t **)a3;
        v14 = ((uint64_t)v11 - *(_QWORD *)a3) >> 3;
        v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v16 = v10 - (_QWORD)v13;
        if (v16 >> 2 > v15)
          v15 = v16 >> 2;
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v15;
        if (v17)
        {
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a3 + 16, v17);
          v13 = *(uint64_t **)a3;
          v11 = *(uint64_t **)(a3 + 8);
        }
        else
        {
          v18 = 0;
        }
        v19 = (uint64_t *)&v18[8 * v14];
        *v19 = v9;
        v12 = v19 + 1;
        while (v11 != v13)
        {
          v20 = *--v11;
          *--v19 = v20;
        }
        *(_QWORD *)a3 = v19;
        *(_QWORD *)(a3 + 8) = v12;
        *(_QWORD *)(a3 + 16) = &v18[8 * v17];
        if (v13)
          operator delete(v13);
      }
      else
      {
        *v11 = v8;
        v12 = v11 + 1;
      }
      *(_QWORD *)(a3 + 8) = v12;
      ++v5;
    }
    while (v5 != v6);
  }
}

void sub_1E05C8E34(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<unsigned long long>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t *MIL::MakeDefaultStrides@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t *result;
  uint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::logic_error *exception;

  result = a3;
  v6 = a1[1];
  v7 = (v6 - *a1) >> 3;
  v8 = (unsigned __int8 *)*a2;
  v9 = (unsigned __int8 *)a2[1];
  if ((unsigned __int8 *)v7 != &v9[-*a2])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Length of shape and interleaveFactors must be equal.");
    goto LABEL_19;
  }
  if (*a1 == v6)
  {
    *result = 0;
    result[1] = 0;
    result[2] = 0;
  }
  else
  {
    if (v9 != v8)
    {
      if (v7 <= 1)
        v10 = 1;
      else
        v10 = (v6 - *a1) >> 3;
      v11 = 1;
      while (1)
      {
        v13 = *v8++;
        v12 = v13;
        if (v13 != 1)
        {
          v14 = v11 == 1;
          v11 = v12;
          if (!v14)
            break;
        }
        if (!--v10)
          goto LABEL_15;
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "Found multiple interleave factors that are not 1.");
LABEL_19:
      __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
    }
    v11 = 1;
LABEL_15:
    result = std::vector<long long>::vector(result, v7);
    v15 = *result;
    v16 = result[1] - *result;
    v17 = v16 >> 3;
    *(_QWORD *)(*result + 8 * ((v16 >> 3) - 1)) = v11;
    if (v16 >> 3 != 1)
    {
      v18 = *(_QWORD *)(v16 + v15 - 8);
      v19 = v15 - 16;
      v20 = *a1 - 8;
      v21 = *a2 - 1;
      do
      {
        v18 += v18 * ((*(_QWORD *)(v20 + 8 * v17) - 1) / *(unsigned __int8 *)(v21 + v17));
        *(_QWORD *)(v19 + 8 * v17--) = v18;
      }
      while (v17 != 1);
    }
  }
  return result;
}

void sub_1E05C9048(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::MakeDefaultStrides(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  size_t v4;
  char v5;
  void *__p[3];

  v4 = (uint64_t)(a1[1] - *a1) >> 3;
  v5 = 1;
  std::vector<unsigned char>::vector(__p, v4, &v5);
  MIL::MakeDefaultStrides(a1, __p, a2);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1E05C90C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::MakeDefaultStrides(void (***a1)(MIL::MILContextImpl *__hidden this)@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  MIL::IRConstantProperty *v14;
  char UInt8ScalarValue;
  MIL::MILContext **v16;
  unint64_t v17;
  MIL::MILContext **v18;
  MIL::MILContext **v19;
  void *__p[3];
  void *v21[3];

  std::vector<unsigned long long>::vector(v21, (a2[1] - *a2) >> 3);
  std::vector<unsigned char>::vector(__p, (a3[1] - *a3) >> 3);
  v8 = *a2;
  if (a2[1] != *a2)
  {
    v9 = 0;
    do
    {
      v10 = MIL::IRDimension::AsConstant(*(MIL::IRDimension **)(v8 + 8 * v9));
      v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 48))(v10);
      *((_QWORD *)v21[0] + v9++) = v11;
      v8 = *a2;
    }
    while (v9 < (a2[1] - *a2) >> 3);
  }
  v12 = *a3;
  if (a3[1] != *a3)
  {
    v13 = 0;
    do
    {
      v14 = (MIL::IRConstantProperty *)MIL::IRProperty::AsConstant(*(MIL::IRProperty **)(v12 + 8 * v13));
      UInt8ScalarValue = MIL::IRConstantProperty::GetUInt8ScalarValue(v14);
      *((_BYTE *)__p[0] + v13++) = UInt8ScalarValue;
      v12 = *a3;
    }
    while (v13 < (a3[1] - *a3) >> 3);
  }
  MIL::MakeDefaultStrides(v21, __p, (uint64_t *)&v18);
  std::vector<MIL::IRProperty const*>::vector(a4, v19 - v18);
  v16 = v19;
  if (v19 != v18)
  {
    v17 = 0;
    v16 = v18;
    do
    {
      *(_QWORD *)(*a4 + 8 * v17) = MIL::IRConstantProperty::MakeInt64Scalar(a1, v16[v17]);
      ++v17;
      v16 = v18;
    }
    while (v17 < v19 - v18);
  }
  if (v16)
  {
    v19 = v16;
    operator delete(v16);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v21[0])
  {
    v21[1] = v21[0];
    operator delete(v21[0]);
  }
}

void sub_1E05C9250(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void MIL::MakeDefaultStrides(void (***a1)(MIL::MILContextImpl *__hidden this)@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v6;
  uint64_t UInt8Scalar;
  void *__p[3];

  std::vector<MIL::IRProperty const*>::vector(__p, (a2[1] - *a2) >> 3);
  if (a2[1] != *a2)
  {
    v6 = 0;
    do
    {
      UInt8Scalar = MIL::IRConstantProperty::MakeUInt8Scalar(a1, (MIL::MILContext *)1);
      *((_QWORD *)__p[0] + v6++) = UInt8Scalar;
    }
    while (v6 < (a2[1] - *a2) >> 3);
  }
  MIL::MakeDefaultStrides(a1, a2, (uint64_t *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1E05C9360(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL MIL::IsTensor(MIL *this, const MIL::IRValueType *a2)
{
  return (*(uint64_t (**)(MIL *, const MIL::IRValueType *))(*(_QWORD *)this + 24))(this, a2) != 0;
}

void *MIL::IsTensorBuffer(MIL *this, const MIL::IRValueType *a2)
{
  void *result;
  void *v4;

  result = MIL::IRValueType::TryCastAsMemoryLayoutType(this);
  if (result)
  {
    v4 = MIL::IRValueType::TryCastAsMemoryLayoutType(this);
    return (void *)(MIL::IRMemoryLayoutValueType::TryAsTensorBufferType(v4) != 0);
  }
  return result;
}

void *MIL::IsPixelBuffer(MIL *this, const MIL::IRValueType *a2)
{
  void *result;
  void *v4;

  result = MIL::IRValueType::TryCastAsMemoryLayoutType(this);
  if (result)
  {
    v4 = MIL::IRValueType::TryCastAsMemoryLayoutType(this);
    return (void *)(MIL::IRMemoryLayoutValueType::TryAsPixelBufferType(v4) != 0);
  }
  return result;
}

void *MIL::IsCircularBuffer(MIL *this, const MIL::IRValueType *a2)
{
  void *result;
  void *v4;

  result = MIL::IRValueType::TryCastAsMemoryLayoutType(this);
  if (result)
  {
    v4 = MIL::IRValueType::TryCastAsMemoryLayoutType(this);
    return (void *)(MIL::IRMemoryLayoutValueType::TryAsCircularBufferType(v4) != 0);
  }
  return result;
}

uint64_t `anonymous namespace'::HasEqualOrStrongerShape(int a1, uint64_t *a2, int a3, _QWORD *a4)
{
  char v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v7 = a1;
  if (a1)
  {
    result = 0;
    v9 = *a2;
    v10 = a2[1];
    if (v10 - *a2 != a4[1] - *a4 || (a3 & 1) == 0)
      return result;
    goto LABEL_15;
  }
  v11 = *a2;
  v12 = a2[1];
  if (((v12 - *a2) >> 3) - 1 > (unint64_t)((uint64_t)(a4[1] - *a4) >> 3))
    return 0;
  if (v12 != v11)
  {
    v13 = 0;
    while ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v11 + 8 * v13) + 24))(*(_QWORD *)(v11 + 8 * v13)))
    {
      ++v13;
      v11 = *a2;
      v14 = a2[1] - *a2;
      if (v13 >= v14 >> 3)
      {
        v15 = (v14 >> 3) - 1;
        return v15 <= ((uint64_t)(a4[1] - *a4) >> 3) - (unint64_t)(a3 ^ 1u);
      }
    }
    v9 = *a2;
    v10 = a2[1];
LABEL_15:
    if (v10 != v9)
    {
      v16 = 0;
      while (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v9 + 8 * v16) + 32))(*(_QWORD *)(v9 + 8 * v16)) & 1) == 0)
      {
        v17 = *(_QWORD *)(*a2 + 8 * v16);
        v18 = *(_QWORD *)(*a4 + 8 * v16);
        v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 16))(v17);
        if (v19)
        {
          v20 = v19;
          result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 16))(v18);
          if (!result)
            return result;
          v21 = result;
          v22 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 48))(v20);
          if (v22 != (*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 48))(v21))
            return 0;
        }
        else if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 32))(v17) & 1) == 0
               && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 32))(v18) & 1) != 0)
        {
          return 0;
        }
        ++v16;
        v9 = *a2;
        if (v16 >= (a2[1] - *a2) >> 3)
          break;
      }
    }
    if ((v7 & 1) == 0)
    {
      v23 = *a2;
      v24 = a2[1] - *a2;
      if ((unint64_t)v24 >= 9)
      {
        v25 = v24 >> 3;
        v26 = -1;
        v27 = 1;
        while (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v23 + 8 * (v25 + v26)) + 32))(*(_QWORD *)(v23 + 8 * (v25 + v26))) & 1) == 0)
        {
          v28 = *(_QWORD *)(*a2 + 8 * (v26 + ((unint64_t)(a2[1] - *a2) >> 3)));
          v29 = *(_QWORD *)(*a4 + 8 * (v26 + ((a4[1] - *a4) >> 3)));
          v30 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 16))(v28);
          if (v30)
          {
            v31 = v30;
            result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 16))(v29);
            if (!result)
              return result;
            v32 = result;
            v33 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v31 + 48))(v31);
            if (v33 != (*(uint64_t (**)(uint64_t))(*(_QWORD *)v32 + 48))(v32))
              return 0;
          }
          else if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 32))(v28) & 1) == 0
                 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 32))(v29) & 1) != 0)
          {
            return 0;
          }
          ++v27;
          v23 = *a2;
          v25 = (a2[1] - *a2) >> 3;
          --v26;
          result = 1;
          if (v27 >= v25)
            return result;
        }
      }
    }
    return 1;
  }
  v15 = -1;
  return v15 <= ((uint64_t)(a4[1] - *a4) >> 3) - (unint64_t)(a3 ^ 1u);
}

uint64_t `anonymous namespace'::HasEqualOrStrongerShape(_anonymous_namespace_ *this, const MIL::IRValueType *a2, const MIL::IRValueType *a3)
{
  const MIL::IRValueType *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t HasEqualOrStrongerShape;
  void *v15;
  uint64_t *v16;
  const MIL::IRValueType *v17;
  MIL::IRMemoryLayoutValueType *v18;
  MIL::IRTensorBufferValueType *v19;
  int IsFixedRank;
  MIL::IRMemoryLayoutValueType *v21;
  MIL::IRTensorBufferValueType *v22;
  uint64_t Shape;
  MIL::IRMemoryLayoutValueType *v24;
  MIL::IRTensorBufferValueType *v25;
  int v26;
  MIL::IRMemoryLayoutValueType *v27;
  MIL::IRTensorBufferValueType *v28;
  uint64_t v29;
  const MIL::IRValueType *v30;
  MIL::IRMemoryLayoutValueType *v31;
  MIL::IRPixelBufferValueType *v32;
  int v33;
  MIL::IRMemoryLayoutValueType *v34;
  MIL::IRPixelBufferValueType *v35;
  uint64_t v36;
  MIL::IRMemoryLayoutValueType *v37;
  MIL::IRPixelBufferValueType *v38;
  int v39;
  MIL::IRMemoryLayoutValueType *v40;
  MIL::IRPixelBufferValueType *v41;
  uint64_t v42;
  const MIL::IRValueType *v43;
  MIL::IRMemoryLayoutValueType *v44;
  MIL::IRCircularBufferValueType *v45;
  int v46;
  MIL::IRMemoryLayoutValueType *v47;
  MIL::IRCircularBufferValueType *v48;
  uint64_t v49;
  MIL::IRMemoryLayoutValueType *v50;
  MIL::IRCircularBufferValueType *v51;
  int v52;
  MIL::IRMemoryLayoutValueType *v53;
  MIL::IRCircularBufferValueType *v54;
  uint64_t v55;
  MIL::IRMemoryLayoutValueType *v56;
  MIL::IRCircularBufferValueType *v57;
  int v58;
  MIL::IRMemoryLayoutValueType *v59;
  MIL::IRCircularBufferValueType *v60;
  uint64_t SliceShape;
  MIL::IRMemoryLayoutValueType *v62;
  MIL::IRCircularBufferValueType *v63;
  int v64;
  MIL::IRMemoryLayoutValueType *v65;
  MIL::IRCircularBufferValueType *v66;
  uint64_t v67;
  std::logic_error *exception;
  void *v70;
  void *v71;
  uint64_t v72;
  void *v73;
  void *v74;
  uint64_t v75;
  void *v76;
  void *v77;
  uint64_t v78;
  void *v79[3];
  void *v80;
  void *v81;
  uint64_t v82;
  uint64_t v83[3];
  void *__p;
  void *v85;
  uint64_t v86;
  uint64_t v87[3];
  void *v88;
  void *v89;
  uint64_t v90;
  uint64_t v91[3];

  if ((*(uint64_t (**)(_anonymous_namespace_ *, const MIL::IRValueType *, const MIL::IRValueType *))(*(_QWORD *)this + 24))(this, a2, a3)&& (*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)a2 + 24))(a2))
  {
    v6 = MIL::IRValueType::AsTensorType(this);
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 104))(v6);
    v8 = MIL::IRValueType::AsTensorType(this);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 96))(v8);
    memset(v91, 0, sizeof(v91));
    std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(v91, *(const void **)v9, *(_QWORD *)(v9 + 8), (uint64_t)(*(_QWORD *)(v9 + 8) - *(_QWORD *)v9) >> 3);
    v10 = MIL::IRValueType::AsTensorType(a2);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 104))(v10);
    v12 = MIL::IRValueType::AsTensorType(a2);
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 96))(v12);
    v88 = 0;
    v89 = 0;
    v90 = 0;
    std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v88, *(const void **)v13, *(_QWORD *)(v13 + 8), (uint64_t)(*(_QWORD *)(v13 + 8) - *(_QWORD *)v13) >> 3);
    if (v88)
    {
      v89 = v88;
      operator delete(v88);
    }
    v15 = (void *)v91[0];
    if (v91[0])
    {
      v16 = v91;
LABEL_31:
      v16[1] = (uint64_t)v15;
      operator delete(v15);
    }
  }
  else if (MIL::IsTensorBuffer(this, v5) && MIL::IsTensorBuffer(a2, v17))
  {
    v18 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(this);
    v19 = (MIL::IRTensorBufferValueType *)MIL::IRMemoryLayoutValueType::AsTensorBufferType(v18);
    IsFixedRank = MIL::IRTensorBufferValueType::IsFixedRank(v19);
    v21 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(this);
    v22 = (MIL::IRTensorBufferValueType *)MIL::IRMemoryLayoutValueType::AsTensorBufferType(v21);
    Shape = MIL::IRTensorBufferValueType::GetShape(v22);
    memset(v87, 0, sizeof(v87));
    std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(v87, *(const void **)Shape, *(_QWORD *)(Shape + 8), (uint64_t)(*(_QWORD *)(Shape + 8) - *(_QWORD *)Shape) >> 3);
    v24 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(a2);
    v25 = (MIL::IRTensorBufferValueType *)MIL::IRMemoryLayoutValueType::AsTensorBufferType(v24);
    v26 = MIL::IRTensorBufferValueType::IsFixedRank(v25);
    v27 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(a2);
    v28 = (MIL::IRTensorBufferValueType *)MIL::IRMemoryLayoutValueType::AsTensorBufferType(v27);
    v29 = MIL::IRTensorBufferValueType::GetShape(v28);
    __p = 0;
    v85 = 0;
    v86 = 0;
    std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&__p, *(const void **)v29, *(_QWORD *)(v29 + 8), (uint64_t)(*(_QWORD *)(v29 + 8) - *(_QWORD *)v29) >> 3);
    if (__p)
    {
      v85 = __p;
      operator delete(__p);
    }
    v15 = (void *)v87[0];
    if (v87[0])
    {
      v16 = v87;
      goto LABEL_31;
    }
  }
  else if (MIL::IsPixelBuffer(this, v17) && MIL::IsPixelBuffer(a2, v30))
  {
    v31 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(this);
    v32 = (MIL::IRPixelBufferValueType *)MIL::IRMemoryLayoutValueType::AsPixelBufferType(v31);
    v33 = MIL::IRPixelBufferValueType::IsFixedRank(v32);
    v34 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(this);
    v35 = (MIL::IRPixelBufferValueType *)MIL::IRMemoryLayoutValueType::AsPixelBufferType(v34);
    v36 = MIL::IRPixelBufferValueType::GetShape(v35);
    memset(v83, 0, sizeof(v83));
    std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(v83, *(const void **)v36, *(_QWORD *)(v36 + 8), (uint64_t)(*(_QWORD *)(v36 + 8) - *(_QWORD *)v36) >> 3);
    v37 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(a2);
    v38 = (MIL::IRPixelBufferValueType *)MIL::IRMemoryLayoutValueType::AsPixelBufferType(v37);
    v39 = MIL::IRPixelBufferValueType::IsFixedRank(v38);
    v40 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(a2);
    v41 = (MIL::IRPixelBufferValueType *)MIL::IRMemoryLayoutValueType::AsPixelBufferType(v40);
    v42 = MIL::IRPixelBufferValueType::GetShape(v41);
    v80 = 0;
    v81 = 0;
    v82 = 0;
    std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v80, *(const void **)v42, *(_QWORD *)(v42 + 8), (uint64_t)(*(_QWORD *)(v42 + 8) - *(_QWORD *)v42) >> 3);
    if (v80)
    {
      v81 = v80;
      operator delete(v80);
    }
    v15 = (void *)v83[0];
    if (v83[0])
    {
      v16 = v83;
      goto LABEL_31;
    }
  }
  else
  {
    if (!MIL::IsCircularBuffer(this, v30) || !MIL::IsCircularBuffer(a2, v43))
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "HasEqualOrStrongerShape called with unsupported type.");
      __cxa_throw(exception, (struct type_info *)off_1EA992598, MEMORY[0x1E0DE4360]);
    }
    v44 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(this);
    v45 = (MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::AsCircularBufferType(v44);
    v46 = MIL::IRCircularBufferValueType::IsFixedRank(v45);
    v47 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(this);
    v48 = (MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::AsCircularBufferType(v47);
    v49 = MIL::IRCircularBufferValueType::GetShape(v48);
    memset(v79, 0, sizeof(v79));
    std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(v79, *(const void **)v49, *(_QWORD *)(v49 + 8), (uint64_t)(*(_QWORD *)(v49 + 8) - *(_QWORD *)v49) >> 3);
    v50 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(a2);
    v51 = (MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::AsCircularBufferType(v50);
    v52 = MIL::IRCircularBufferValueType::IsFixedRank(v51);
    v53 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(a2);
    v54 = (MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::AsCircularBufferType(v53);
    v55 = MIL::IRCircularBufferValueType::GetShape(v54);
    v76 = 0;
    v77 = 0;
    v78 = 0;
    std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v76, *(const void **)v55, *(_QWORD *)(v55 + 8), (uint64_t)(*(_QWORD *)(v55 + 8) - *(_QWORD *)v55) >> 3);
    {
      v56 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(this);
      v57 = (MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::AsCircularBufferType(v56);
      v58 = MIL::IRCircularBufferValueType::IsFixedRank(v57);
      v59 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(this);
      v60 = (MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::AsCircularBufferType(v59);
      SliceShape = MIL::IRCircularBufferValueType::GetSliceShape(v60);
      v73 = 0;
      v74 = 0;
      v75 = 0;
      std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v73, *(const void **)SliceShape, *(_QWORD *)(SliceShape + 8), (uint64_t)(*(_QWORD *)(SliceShape + 8) - *(_QWORD *)SliceShape) >> 3);
      v62 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(a2);
      v63 = (MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::AsCircularBufferType(v62);
      v64 = MIL::IRCircularBufferValueType::IsFixedRank(v63);
      v65 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::AsMemoryLayoutType(a2);
      v66 = (MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::AsCircularBufferType(v65);
      v67 = MIL::IRCircularBufferValueType::GetSliceShape(v66);
      v70 = 0;
      v71 = 0;
      v72 = 0;
      std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v70, *(const void **)v67, *(_QWORD *)(v67 + 8), (uint64_t)(*(_QWORD *)(v67 + 8) - *(_QWORD *)v67) >> 3);
      if (v70)
      {
        v71 = v70;
        operator delete(v70);
      }
      if (v73)
      {
        v74 = v73;
        operator delete(v73);
      }
    }
    else
    {
      HasEqualOrStrongerShape = 0;
    }
    if (v76)
    {
      v77 = v76;
      operator delete(v76);
    }
    v15 = v79[0];
    if (v79[0])
    {
      v16 = (uint64_t *)v79;
      goto LABEL_31;
    }
  }
  return HasEqualOrStrongerShape;
}

void sub_1E05C9BA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28)
{
  if (__p)
    operator delete(__p);
  if (a24)
    operator delete(a24);
  _Unwind_Resume(exception_object);
}

BOOL `anonymous namespace'::IsEqualOrStrongerPropertiesVec(void ***a1, void ***a2)
{
  void **v4;
  void **v5;
  int v6;
  MIL::IRUnknownProperty *v7;
  int v8;
  void **v9;
  void **v10;
  int v11;
  MIL::IRUnknownProperty *v12;
  int v13;
  void **v14;
  void **v15;
  void **v16;
  void **v17;
  _BOOL8 result;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  MIL::IRUnknownProperty *v23;
  void **v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  MIL::IRUnknownProperty *v29;
  std::runtime_error *exception;

  v4 = *a1;
  v5 = a1[1];
  v6 = 1;
  while (v4 != v5)
  {
    v7 = (MIL::IRUnknownProperty *)MIL::IRProperty::TryAsUnknown(*v4);
    if (v7)
    {
      v8 = MIL::IRUnknownProperty::IsVariadic(v7) ^ 1;
      if (((v8 | v6) & 1) == 0)
      {
LABEL_41:
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "A property vector may contain only one variadic property.");
        __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
      }
      v6 &= v8;
    }
    ++v4;
  }
  v9 = *a2;
  v10 = a2[1];
  v11 = 1;
  while (v9 != v10)
  {
    v12 = (MIL::IRUnknownProperty *)MIL::IRProperty::TryAsUnknown(*v9);
    if (v12)
    {
      v13 = MIL::IRUnknownProperty::IsVariadic(v12) ^ 1;
      if (((v13 | v11) & 1) == 0)
        goto LABEL_41;
      v11 &= v13;
    }
    ++v9;
  }
  if ((v6 & 1) != 0)
  {
    v14 = *a1;
    v15 = a1[1];
    if ((((char *)v15 - (char *)*a1 == (char *)a2[1] - (char *)*a2) & v11) != 0)
    {
LABEL_26:
      if (v15 != v14)
      {
        v22 = 0;
        do
        {
          v23 = (MIL::IRUnknownProperty *)MIL::IRProperty::TryAsUnknown(v14[v22]);
          if (v23 && (MIL::IRUnknownProperty::IsVariadic(v23) & 1) != 0)
            break;
          ++v22;
          v14 = *a1;
        }
        while (v22 < a1[1] - *a1);
      }
      if ((v6 & 1) == 0)
      {
        v24 = *a1;
        v25 = (char *)a1[1] - (char *)*a1;
        if ((unint64_t)v25 >= 9)
        {
          v26 = v25 >> 3;
          v27 = -1;
          v28 = 1;
          while (1)
          {
            v29 = (MIL::IRUnknownProperty *)MIL::IRProperty::TryAsUnknown(*(&v24[v26] + v27));
            if (v29)
            {
              if ((MIL::IRUnknownProperty::IsVariadic(v29) & 1) != 0)
                break;
            }
            ++v28;
            v24 = *a1;
            v26 = a1[1] - *a1;
            --v27;
            result = 1;
            if (v28 >= v26)
              return result;
          }
        }
      }
      return 1;
    }
    return 0;
  }
  v16 = *a1;
  v17 = a1[1];
  if (v17 - *a1 - 1 > (unint64_t)(a2[1] - *a2))
    return 0;
  if (v17 != v16)
  {
    v19 = 0;
    while (MIL::IRProperty::TryAsUnknown(v16[v19]))
    {
      ++v19;
      v16 = *a1;
      v20 = (char *)a1[1] - (char *)*a1;
      if (v19 >= v20 >> 3)
      {
        v21 = (v20 >> 3) - 1;
        return v21 <= a2[1] - *a2 - (unint64_t)((v11 & 1) == 0);
      }
    }
    v14 = *a1;
    v15 = a1[1];
    goto LABEL_26;
  }
  v21 = -1;
  return v21 <= a2[1] - *a2 - (unint64_t)((v11 & 1) == 0);
}

void sub_1E05C9F10(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<MIL::IRProperty const*>::__init_with_size[abi:ne180100]<MIL::IRProperty const**,MIL::IRProperty const**>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1E05C9F84(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::IsEqualOrStrongerPropertiesVec(std::vector<MIL::IRProperty const*> const&,std::vector<MIL::IRProperty const*> const&)::$_1::operator()(void *a1, void *a2)
{
  MIL::IRConstantPropertyImpl **v4;
  MIL::IRConstantPropertyImpl **v5;
  uint64_t result;
  MIL::IRConstantPropertyImpl **v7;
  int ScalarDataType;
  uint64_t Int64ScalarValue;
  uint64_t UInt64ScalarValue;
  MIL::IRUnknownProperty *v11;
  MIL::IRUnknownProperty *v12;
  int UInt8ScalarValue;

  v4 = (MIL::IRConstantPropertyImpl **)MIL::IRProperty::TryAsConstant(a1);
  if (!v4)
  {
    v11 = (MIL::IRUnknownProperty *)MIL::IRProperty::TryAsUnknown(a1);
    if (!v11)
      return 1;
    if ((MIL::IRUnknownProperty::IsVariadic(v11) & 1) != 0)
      return 1;
    v12 = (MIL::IRUnknownProperty *)MIL::IRProperty::TryAsUnknown(a2);
    return !v12 || (MIL::IRUnknownProperty::IsVariadic(v12) & 1) == 0;
  }
  v5 = v4;
  result = (uint64_t)MIL::IRProperty::TryAsConstant(a2);
  if (!result)
    return result;
  v7 = (MIL::IRConstantPropertyImpl **)result;
  ScalarDataType = MIL::IRConstantProperty::GetScalarDataType(v5);
  if (ScalarDataType != MIL::IRConstantProperty::GetScalarDataType(v7))
    return 0;
  if (MIL::IRConstantProperty::GetScalarDataType(v5) == 12)
  {
    Int64ScalarValue = MIL::IRConstantProperty::GetInt64ScalarValue((MIL::IRConstantProperty *)v5);
    UInt64ScalarValue = MIL::IRConstantProperty::GetInt64ScalarValue((MIL::IRConstantProperty *)v7);
    return Int64ScalarValue == UInt64ScalarValue;
  }
  if (MIL::IRConstantProperty::GetScalarDataType(v5) == 14)
  {
    UInt8ScalarValue = MIL::IRConstantProperty::GetUInt8ScalarValue((MIL::IRConstantProperty *)v5);
    return UInt8ScalarValue == MIL::IRConstantProperty::GetUInt8ScalarValue((MIL::IRConstantProperty *)v7);
  }
  if (MIL::IRConstantProperty::GetScalarDataType(v5) != 17)
    return 1;
  Int64ScalarValue = MIL::IRConstantProperty::GetUInt64ScalarValue((MIL::IRConstantProperty *)v5);
  UInt64ScalarValue = MIL::IRConstantProperty::GetUInt64ScalarValue((MIL::IRConstantProperty *)v7);
  return Int64ScalarValue == UInt64ScalarValue;
}

_QWORD *std::vector<long long>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned long long>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1E05CA114(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<unsigned long long>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned long long>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1E05CA188(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<unsigned char>::vector(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1E05CA1F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void OperationNameLocationImpl::~OperationNameLocationImpl(void **this)
{
  *this = off_1EA9993F0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_1EA9993F0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_1EA9993F0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::OperationNameLocation::Make@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result;
  uint64_t v5;

  result = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)a1;
  *(_QWORD *)(result + 16) = v5;
  *(_QWORD *)(result + 23) = *(_QWORD *)(a1 + 15);
  LOBYTE(v5) = *(_BYTE *)(a1 + 23);
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)result = off_1EA9993F0;
  *(_BYTE *)(result + 31) = v5;
  *a2 = result;
  return result;
}

void TextFileLocationImpl::~TextFileLocationImpl(void **this)
{
  *this = off_1EA999428;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_1EA999428;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_1EA999428;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x1E0C023A0);
}

uint64_t MIL::TextFileLocation::Make@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result;
  uint64_t v9;

  result = operator new();
  v9 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)a1;
  *(_QWORD *)(result + 16) = v9;
  *(_QWORD *)(result + 23) = *(_QWORD *)(a1 + 15);
  LOBYTE(v9) = *(_BYTE *)(a1 + 23);
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)result = off_1EA999428;
  *(_BYTE *)(result + 31) = v9;
  *(_QWORD *)(result + 32) = a2;
  *(_QWORD *)(result + 40) = a3;
  *a4 = result;
  return result;
}

void UnknownLocationImpl::~UnknownLocationImpl(UnknownLocationImpl *this)
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *MIL::UnknownLocation::Make@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  *result = &off_1EA9995C0;
  *a1 = result;
  return result;
}

_QWORD *MIL::Location::Location(_QWORD *this)
{
  *this = off_1EA999470;
  return this;
}

uint64_t MIL::Location::operator!=(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) ^ 1;
}

void MIL::Location::GetDescription(MIL::Location *this@<X0>, std::string *a2@<X8>)
{
  OperationNameLocationImpl *v4;
  TextFileLocationImpl *v5;
  std::logic_error *exception;

  if (!this)
    goto LABEL_8;
  if (v4)
  {
    OperationNameLocationImpl::GetDescriptionImpl(v4, a2);
    return;
  }
  if (v5)
  {
    TextFileLocationImpl::GetDescriptionImpl(v5, a2);
    return;
  }
  {
LABEL_8:
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unknown Location type.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
  }
  std::string::basic_string[abi:ne180100]<0>(a2, "unknown location");
}

void sub_1E05CA61C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void OperationNameLocationImpl::GetDescriptionImpl(OperationNameLocationImpl *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v3;
  __int128 v4;

  v3 = (*(uint64_t (**)(OperationNameLocationImpl *))(*(_QWORD *)this + 32))(this);
  if (*(char *)(v3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)v3, *(_QWORD *)(v3 + 8));
  }
  else
  {
    v4 = *(_OWORD *)v3;
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(v3 + 16);
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v4;
  }
}

void TextFileLocationImpl::GetDescriptionImpl(TextFileLocationImpl *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  unint64_t v8;
  std::string *v9;
  std::string::size_type size;
  std::string *v11;
  __int128 v12;
  unint64_t v13;
  std::string *v14;
  std::string::size_type v15;
  std::string *v16;
  std::string v17;
  std::string v18;
  std::string v19;
  std::string v20;
  std::string v21;
  std::string v22;

  v4 = (*(uint64_t (**)(TextFileLocationImpl *))(*(_QWORD *)this + 40))(this);
  v5 = *(unsigned __int8 *)(v4 + 23);
  if ((v5 & 0x80u) != 0)
    v5 = *(_QWORD *)(v4 + 8);
  if (v5)
  {
    v6 = (*(uint64_t (**)(TextFileLocationImpl *))(*(_QWORD *)this + 40))(this);
    if (*(char *)(v6 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v22, *(const std::string::value_type **)v6, *(_QWORD *)(v6 + 8));
    }
    else
    {
      v7 = *(_OWORD *)v6;
      v22.__r_.__value_.__r.__words[2] = *(_QWORD *)(v6 + 16);
      *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v7;
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&v22, "(unknown)");
  }
  std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)&v22.__r_.__value_.__l.__data_, 58, (uint64_t)&v19);
  v8 = (*(uint64_t (**)(TextFileLocationImpl *))(*(_QWORD *)this + 48))(this);
  std::to_string(&v18, v8);
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v9 = &v18;
  else
    v9 = (std::string *)v18.__r_.__value_.__r.__words[0];
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v18.__r_.__value_.__r.__words[2]);
  else
    size = v18.__r_.__value_.__l.__size_;
  v11 = std::string::append(&v19, (const std::string::value_type *)v9, size);
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  std::string::push_back(&v20, 58);
  v21 = v20;
  memset(&v20, 0, sizeof(v20));
  v13 = (*(uint64_t (**)(TextFileLocationImpl *))(*(_QWORD *)this + 32))(this);
  std::to_string(&v17, v13);
  if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = &v17;
  else
    v14 = (std::string *)v17.__r_.__value_.__r.__words[0];
  if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = HIBYTE(v17.__r_.__value_.__r.__words[2]);
  else
    v15 = v17.__r_.__value_.__l.__size_;
  v16 = std::string::append(&v21, (const std::string::value_type *)v14, v15);
  *a2 = *v16;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v17.__r_.__value_.__l.__data_);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v20.__r_.__value_.__l.__data_);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
}

void sub_1E05CA860(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v33 - 73) < 0)
    operator delete(*(void **)(v33 - 96));
  if (a33 < 0)
    operator delete(a28);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  if (*(char *)(v33 - 41) < 0)
    operator delete(*(void **)(v33 - 64));
  _Unwind_Resume(exception_object);
}

uint64_t OperationNameLocationImpl::operator==(uint64_t a1, void *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned __int8 *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  BOOL v18;

  if (result)
  {
    v4 = result;
    v5 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 32))(v4);
    v7 = v5[23];
    if ((v7 & 0x80u) == 0)
      v8 = v5[23];
    else
      v8 = *((_QWORD *)v5 + 1);
    v9 = *(unsigned __int8 *)(v6 + 23);
    v10 = (char)v9;
    if ((v9 & 0x80u) != 0)
      v9 = *(_QWORD *)(v6 + 8);
    if (v8 == v9)
    {
      if (v10 >= 0)
        v11 = (unsigned __int8 *)v6;
      else
        v11 = *(unsigned __int8 **)v6;
      if ((v7 & 0x80) != 0)
      {
        return memcmp(*(const void **)v5, v11, *((_QWORD *)v5 + 1)) == 0;
      }
      else if (v5[23])
      {
        v12 = v7 - 1;
        do
        {
          v14 = *v5++;
          v13 = v14;
          v16 = *v11++;
          v15 = v16;
          v18 = v12-- != 0;
          result = v13 == v15;
        }
        while (v13 == v15 && v18);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void OperationNameLocationImpl::GetReportString(OperationNameLocationImpl *this@<X0>, std::string *a2@<X8>)
{
  std::string *v3;
  std::string v4;

  OperationNameLocationImpl::GetDescriptionImpl(this, &v4);
  v3 = std::string::insert(&v4, 0, "in operation ");
  *a2 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v4.__r_.__value_.__l.__data_);
}

void sub_1E05CAA50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t OperationNameLocationImpl::GetName(OperationNameLocationImpl *this)
{
  return (uint64_t)this + 8;
}

uint64_t TextFileLocationImpl::operator==(uint64_t a1, void *lpsrc)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned __int8 *v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  BOOL v20;

  if (result)
  {
    v4 = result;
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    if (v5 != (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 32))(v4))
      return 0;
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    if (v6 != (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4))
      return 0;
    v7 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    v9 = v7[23];
    if ((v9 & 0x80u) == 0)
      v10 = v7[23];
    else
      v10 = *((_QWORD *)v7 + 1);
    v11 = *(unsigned __int8 *)(v8 + 23);
    v12 = (char)v11;
    if ((v11 & 0x80u) != 0)
      v11 = *(_QWORD *)(v8 + 8);
    if (v10 == v11)
    {
      if (v12 >= 0)
        v13 = (unsigned __int8 *)v8;
      else
        v13 = *(unsigned __int8 **)v8;
      if ((v9 & 0x80) != 0)
      {
        return memcmp(*(const void **)v7, v13, *((_QWORD *)v7 + 1)) == 0;
      }
      else if (v7[23])
      {
        v14 = v9 - 1;
        do
        {
          v16 = *v7++;
          v15 = v16;
          v18 = *v13++;
          v17 = v18;
          v20 = v14-- != 0;
          result = v15 == v17;
        }
        while (v15 == v17 && v20);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void TextFileLocationImpl::GetReportString(TextFileLocationImpl *this@<X0>, std::string *a2@<X8>)
{
  std::string *v3;
  std::string v4;

  TextFileLocationImpl::GetDescriptionImpl(this, &v4);
  v3 = std::string::insert(&v4, 0, "at ");
  *a2 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v4.__r_.__value_.__l.__data_);
}

void sub_1E05CAC30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t TextFileLocationImpl::GetColumn(TextFileLocationImpl *this)
{
  return *((_QWORD *)this + 5);
}

uint64_t TextFileLocationImpl::GetFile(TextFileLocationImpl *this)
{
  return (uint64_t)this + 8;
}

uint64_t TextFileLocationImpl::GetLine(TextFileLocationImpl *this)
{
  return *((_QWORD *)this + 4);
}

BOOL UnknownLocationImpl::operator==(int a1, void *lpsrc)
{
}

_QWORD *UnknownLocationImpl::GetReportString@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "at unknown location");
}

void MIL::MILContextImpl::~MILContextImpl(MIL::MILContextImpl *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *((_QWORD *)this + 80);
  *((_QWORD *)this + 80) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 79);
  *((_QWORD *)this + 79) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 78);
  *((_QWORD *)this + 78) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 77);
  *((_QWORD *)this + 77) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 76);
  *((_QWORD *)this + 76) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>>>::~__hash_table((uint64_t)this + 568);
  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table((uint64_t)this + 528);
  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>>>::~__hash_table((uint64_t)this + 488);
  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>>>::~__hash_table((uint64_t)this + 448);
  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>>>::~__hash_table((uint64_t)this + 408);
  std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>>>::~__hash_table((uint64_t)this + 368);
  std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>>>::~__hash_table((uint64_t)this + 328);
  std::__hash_table<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::__unordered_map_hasher<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::__unordered_map_equal<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>>>::~__hash_table((uint64_t)this + 288);
  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>>>::~__hash_table((uint64_t)this + 248);
  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table((uint64_t)this + 208);
  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table((uint64_t)this + 168);
  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table((uint64_t)this + 128);
  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table((uint64_t)this + 88);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 48);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 8);
}

{
  MIL::MILContextImpl::~MILContextImpl(this);
  JUMPOUT(0x1E0C023A0);
}

void MIL::MILContextImpl::GetAllOpsetNames(MIL::MILContextImpl *this@<X0>, std::vector<std::string> *a2@<X8>)
{
  _QWORD *v4;
  const void **p_data;
  __int128 *v6;
  unint64_t v7;
  uint64_t v8;
  _BYTE v9[9];

  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  std::vector<std::string>::reserve(a2, *((_QWORD *)this + 74));
  v4 = (_QWORD *)*((_QWORD *)this + 73);
  if (v4)
  {
    p_data = (const void **)&a2->__end_->__r_.__value_.__l.__data_;
    do
    {
      v6 = (__int128 *)(v4 + 2);
      if ((std::string *)p_data >= a2->__end_cap_.__value_)
      {
        p_data = (const void **)std::vector<std::string>::__push_back_slow_path<std::string const&>((uint64_t *)a2, v6);
      }
      else
      {
        std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)a2, v6);
        p_data += 3;
      }
      a2->__end_ = (std::vector<std::string>::pointer)p_data;
      v4 = (_QWORD *)*v4;
    }
    while (v4);
  }
  else
  {
    p_data = (const void **)&a2->__end_->__r_.__value_.__l.__data_;
  }
  v7 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (((char *)p_data - (char *)a2->__begin_) >> 3));
  if (p_data == (const void **)a2->__begin_)
    v8 = 0;
  else
    v8 = v7;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>((uint64_t)a2->__begin_, p_data, (uint64_t)v9, v8, 1);
}

void sub_1E05CAEB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

unsigned __int8 *MIL::MILContextImpl::RegisterOpset(uint64_t a1, unsigned __int8 *a2, uint64_t *a3)
{
  unsigned __int8 *result;
  char v4;
  std::runtime_error *exception;
  std::string *v6;
  __int128 v7;
  std::string v8;
  std::string v9;

  result = std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<MIL::IROpset const>>(a1 + 568, a2, (uint64_t)a2, a3);
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v6 = std::string::append(&v8, "'.");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v9.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v9.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v9);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05CAF88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

unsigned __int8 *MIL::MILContextImpl::TryGetOpset(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *result;

  result = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 568), a2);
  if (result)
    return (unsigned __int8 *)*((_QWORD *)result + 5);
  return result;
}

unsigned __int8 *MIL::MILContextImpl::GetOrCreateLegacyStorageReader@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, std::string::size_type *a3@<X8>)
{
  uint64_t v5;
  unsigned __int8 *result;
  std::string::size_type v7;
  unint64_t *v8;
  unint64_t v9;

  v5 = a1 + 8;
  result = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((_QWORD *)(a1 + 8), a2);
  if (result)
  {
    v7 = *((_QWORD *)result + 6);
    *a3 = *((_QWORD *)result + 5);
    a3[1] = v7;
    if (v7)
    {
      v8 = (unint64_t *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
  }
  else
  {
    std::allocate_shared[abi:ne180100]<MIL::Blob::LegacyStorageReader,std::allocator<MIL::Blob::LegacyStorageReader>,std::string const&,void>((uint64_t)a2, a3);
    return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>>>::__emplace_unique_key_args<std::string,std::string const&,std::shared_ptr<MIL::Blob::LegacyStorageReader>&>(v5, a2, (__int128 *)a2, a3);
  }
  return result;
}

void sub_1E05CB090(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *MIL::MILContextImpl::GetOrCreateStorageReader@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, std::string::size_type *a3@<X8>)
{
  uint64_t v5;
  unsigned __int8 *result;
  std::string::size_type v7;
  unint64_t *v8;
  unint64_t v9;

  v5 = a1 + 48;
  result = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((_QWORD *)(a1 + 48), a2);
  if (result)
  {
    v7 = *((_QWORD *)result + 6);
    *a3 = *((_QWORD *)result + 5);
    a3[1] = v7;
    if (v7)
    {
      v8 = (unint64_t *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
  }
  else
  {
    std::allocate_shared[abi:ne180100]<MIL::Blob::StorageReader,std::allocator<MIL::Blob::StorageReader>,std::string const&,void>((uint64_t)a2, a3);
    return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>>>::__emplace_unique_key_args<std::string,std::string const&,std::shared_ptr<MIL::Blob::StorageReader>&>(v5, a2, (__int128 *)a2, a3);
  }
  return result;
}

void sub_1E05CB12C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

BOOL MIL::MILContextImpl::TypeIsRegistered(MIL::MILContextImpl *this, const MIL::IRValueType *a2)
{
  uint64_t v4;
  _QWORD *i;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  std::runtime_error *exception;

  v4 = (*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)a2 + 24))(a2);
  if (v4)
  {
    for (i = (_QWORD *)*((_QWORD *)this + 33); i; i = (_QWORD *)*i)
    {
      if (i[10] == v4)
        break;
    }
    return i != 0;
  }
  v6 = (*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)a2 + 32))(a2);
  if (!v6)
  {
    v7 = (*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)a2 + 40))(a2);
    if (v7)
    {
      v8 = (_QWORD *)*((_QWORD *)this + 38);
      if (v8)
      {
        while (v8[4] != v7)
        {
          i = 0;
          v8 = (_QWORD *)*v8;
          if (!v8)
            return i != 0;
        }
LABEL_43:
        i = v8;
        return i != 0;
      }
    }
    else
    {
      v9 = (*(uint64_t (**)(const MIL::IRValueType *))(*(_QWORD *)a2 + 48))(a2);
      if (!v9)
      {
        v10 = MIL::IRValueType::TryCastAsMemoryLayoutType(a2);
        if (v10)
        {
          v11 = v10;
          v12 = MIL::IRMemoryLayoutValueType::TryAsTensorBufferType(v10);
          if (v12)
          {
            v8 = (_QWORD *)*((_QWORD *)this + 53);
            if (v8)
            {
              while ((void *)v8[15] != v12)
              {
                i = 0;
                v8 = (_QWORD *)*v8;
                if (!v8)
                  return i != 0;
              }
              goto LABEL_43;
            }
            goto LABEL_42;
          }
          v13 = MIL::IRMemoryLayoutValueType::TryAsPixelBufferType(v11);
          if (v13)
          {
            v8 = (_QWORD *)*((_QWORD *)this + 58);
            if (v8)
            {
              while ((void *)v8[14] != v13)
              {
                i = 0;
                v8 = (_QWORD *)*v8;
                if (!v8)
                  return i != 0;
              }
              goto LABEL_43;
            }
            goto LABEL_42;
          }
          v14 = MIL::IRMemoryLayoutValueType::TryAsCircularBufferType(v11);
          if (v14)
          {
            v8 = (_QWORD *)*((_QWORD *)this + 63);
            if (v8)
            {
              while ((void *)v8[17] != v14)
              {
                i = 0;
                v8 = (_QWORD *)*v8;
                if (!v8)
                  return i != 0;
              }
              goto LABEL_43;
            }
            goto LABEL_42;
          }
        }
        v15 = MIL::IRValueType::TryCastAsStateType(a2);
        if (!v15)
        {
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Unknown type for TypeIsRegistered.");
          __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
        }
        v8 = (_QWORD *)*((_QWORD *)this + 68);
        if (v8)
        {
          while ((void *)v8[3] != v15)
          {
            i = 0;
            v8 = (_QWORD *)*v8;
            if (!v8)
              return i != 0;
          }
          goto LABEL_43;
        }
        goto LABEL_42;
      }
      v8 = (_QWORD *)*((_QWORD *)this + 48);
      if (v8)
      {
        while (v8[4] != v9)
        {
          i = 0;
          v8 = (_QWORD *)*v8;
          if (!v8)
            return i != 0;
        }
        goto LABEL_43;
      }
    }
LABEL_42:
    i = 0;
    return i != 0;
  }
  for (i = (_QWORD *)*((_QWORD *)this + 43); i; i = (_QWORD *)*i)
  {
    if (i[4] == v6)
      break;
  }
  return i != 0;
}

void sub_1E05CB350(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::MILContext::MILContext(_QWORD *this)
{
  *this = off_1EA999620;
  return this;
}

uint64_t MIL::MILContext::GetOpset(uint64_t a1)
{
  uint64_t result;
  std::runtime_error *exception;
  std::string *v3;
  __int128 v4;
  std::string v5;
  std::string v6;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (!result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v3 = std::string::append(&v5, "' not does not exist.");
    v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    v6.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v6.__r_.__value_.__l.__data_ = v4;
    v3->__r_.__value_.__l.__size_ = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
    v3->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v6);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  return result;
}

void sub_1E05CB430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

_QWORD *MIL::MILContextImpl::RegisterOpConversion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _BYTE v9[24];
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 608);
  std::__function::__value_func<void ()(MIL::Transform::ProgramTransformer &)>::__value_func[abi:ne180100]((uint64_t)v9, a4);
  (*(void (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v6 + 16))(v6, a2, a3, v9);
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1E05CB548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t MIL::MILContextImpl::ConvertProgram(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 608) + 32))(*(_QWORD *)(a1 + 608));
}

{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 608) + 24))(*(_QWORD *)(a1 + 608));
}

uint64_t MIL::MILContextImpl::TryConvertProgram(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 608) + 48))(*(_QWORD *)(a1 + 608));
}

{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 608) + 40))(*(_QWORD *)(a1 + 608));
}

uint64_t MIL::MILContextImpl::CanConvertProgram(MIL::MILContextImpl *this, const MIL::IRProgram *a2)
{
  return (*(uint64_t (**)(_QWORD, const MIL::IRProgram *))(**((_QWORD **)this + 76) + 56))(*((_QWORD *)this + 76), a2);
}

MIL::MILContextImpl *MIL::MILContext::Make@<X0>(_QWORD *a1@<X8>)
{
  void *v3;
  MIL::MILContextImpl *result;

  v3 = (void *)operator new();
  bzero(v3, 0x288uLL);
  result = MIL::MILContextImpl::MILContextImpl((MIL::MILContextImpl *)v3);
  *a1 = v3;
  return result;
}

void sub_1E05CB61C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0x10E1C40E5EB867ELL);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRConstantDimension::Make(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2)
{
  if (*this != &off_1EA999688)
    __cxa_bad_cast();
  return MIL::IRTypeStore<unsigned long long,MIL::IRConstantDimension const>::Get<unsigned long long>((uint64_t)(this + 11), a2);
}

uint64_t MIL::IRUnknownDimension::Make(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2)
{
  char *v2;

  if (!(_DWORD)a2)
  {
    if (*this == &off_1EA999688)
    {
      v2 = (char *)(this + 77);
      return *(_QWORD *)v2;
    }
LABEL_7:
    __cxa_bad_cast();
  }
  if (*this != &off_1EA999688)
    goto LABEL_7;
  v2 = (char *)(this + 78);
  return *(_QWORD *)v2;
}

uint64_t MIL::IRConstantProperty::MakeInt64Scalar(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2)
{
  if (*this != &off_1EA999688)
    __cxa_bad_cast();
  return MIL::IRTypeStore<long long,MIL::IRConstantProperty const>::Get<long long>((uint64_t)(this + 16), (uint64_t)a2);
}

uint64_t MIL::IRConstantProperty::MakeUInt8Scalar(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2)
{
  if (*this != &off_1EA999688)
    __cxa_bad_cast();
  return MIL::IRTypeStore<unsigned char,MIL::IRConstantProperty const>::Get<unsigned char>((uint64_t)(this + 21), a2);
}

uint64_t MIL::IRConstantProperty::MakeUInt64Scalar(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2)
{
  if (*this != &off_1EA999688)
    __cxa_bad_cast();
  return MIL::IRTypeStore<unsigned long long,MIL::IRConstantProperty const>::Get<unsigned long long>((uint64_t)(this + 26), (uint64_t)a2);
}

uint64_t MIL::IRUnknownProperty::Make(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2)
{
  char *v2;

  if (!(_DWORD)a2)
  {
    if (*this == &off_1EA999688)
    {
      v2 = (char *)(this + 79);
      return *(_QWORD *)v2;
    }
LABEL_7:
    __cxa_bad_cast();
  }
  if (*this != &off_1EA999688)
    goto LABEL_7;
  v2 = (char *)(this + 80);
  return *(_QWORD *)v2;
}

uint64_t MIL::IRTensorValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3)
{
  uint64_t v3;
  _OWORD v5[2];
  int v6;

  memset(v5, 0, sizeof(v5));
  v6 = 1065353216;
  v3 = MIL::IRTensorValueType::MakeWithShape(a1, a2, a3, (uint64_t *)v5);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v5);
  return v3;
}

void sub_1E05CB7B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9[5];

  if (*a1 != &off_1EA999688)
    __cxa_bad_cast();
  v6 = (uint64_t)(a1 + 31);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)v9, a4);
  v7 = MIL::IRTypeStore<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRTensorValueType const>::Get<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>> const&,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(v6, a2, a3, v9);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v9);
  return v7;
}

void sub_1E05CB848(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRListValueType::MakeWithDimension(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2, const MIL::IRValueType *a3, const MIL::IRDimension *a4)
{
  std::runtime_error *exception;

  if ((*(unsigned int (**)(const MIL::IRValueType *))(*(_QWORD *)a3 + 32))(a3))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Cannot create a list with a variadic length.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  if (*this != &off_1EA999688)
    __cxa_bad_cast();
  return MIL::IRTypeStore<std::pair<MIL::IRValueType const*,MIL::IRDimension const*>,MIL::IRListValueType const>::Get<MIL::IRValueType const*,MIL::IRDimension const*>((uint64_t)(this + 41), a2, a3);
}

void sub_1E05CB8F0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTupleValueType::Make(void (***a1)(MIL::MILContextImpl *__hidden this), uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v10;
  std::__shared_weak_count *v11;

  if (*a1 != &off_1EA999688)
    __cxa_bad_cast();
  v3 = (uint64_t)(a1 + 36);
  v4 = operator new();
  *(_OWORD *)v4 = *(_OWORD *)a2;
  *(_QWORD *)(v4 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  std::shared_ptr<std::vector<MIL::IRValueType const*>>::shared_ptr[abi:ne180100]<std::vector<MIL::IRValueType const*>,void>(&v10, v4);
  v5 = MIL::IRTypeStore<std::shared_ptr<std::vector<MIL::IRValueType const*>>,MIL::IRTupleValueType const>::Get<std::shared_ptr<std::vector<MIL::IRValueType const*>> const&>(v3, (uint64_t)&v10);
  v6 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v5;
}

void sub_1E05CB9CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRDictionaryValueType::Make(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2, const MIL::IRValueType *a3, const MIL::IRValueType *a4)
{
  if (*this != &off_1EA999688)
    __cxa_bad_cast();
  return MIL::IRTypeStore<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,MIL::IRDictionaryValueType const>::Get<MIL::IRValueType const*,MIL::IRValueType const*>((uint64_t)(this + 46), a2, a3);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v28[5];
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;

  if (*a1 != &off_1EA999688)
    __cxa_bad_cast();
  v7 = a3[1];
  v33 = *a3;
  v34 = (std::__shared_weak_count *)v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = (uint64_t)(a1 + 51);
  v11 = a4[1];
  v31 = *a4;
  v32 = (std::__shared_weak_count *)v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = a5[1];
  v29 = *a5;
  v30 = (std::__shared_weak_count *)v14;
  if (v14)
  {
    v15 = (unint64_t *)(v14 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)v28, a6);
  v17 = MIL::IRTypeStore<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRTensorBufferValueType const>::Get<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(v10, a2, &v33, &v31, 0, &v29, v28);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v28);
  v18 = v30;
  if (v30)
  {
    p_shared_owners = (unint64_t *)&v30->__shared_owners_;
    do
      v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v32;
  if (v32)
  {
    v22 = (unint64_t *)&v32->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = v34;
  if (v34)
  {
    v25 = (unint64_t *)&v34->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  return v17;
}

void sub_1E05CBB90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 - 48);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 - 32);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRTensorBufferValueType::MakeWithShapeAndRowAlignment(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v26[5];
  uint64_t v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;

  if (*a1 != &off_1EA999688)
    __cxa_bad_cast();
  v8 = (uint64_t)(a1 + 51);
  v9 = a3[1];
  v31 = *a3;
  v32 = (std::__shared_weak_count *)v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v29 = 0;
  v30 = 0;
  v12 = a5[1];
  v27 = *a5;
  v28 = (std::__shared_weak_count *)v12;
  if (v12)
  {
    v13 = (unint64_t *)(v12 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)v26, a6);
  v15 = MIL::IRTypeStore<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRTensorBufferValueType const>::Get<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(v8, a2, &v31, &v29, a4, &v27, v26);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v26);
  v16 = v28;
  if (v28)
  {
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v30;
  if (v30)
  {
    v20 = (unint64_t *)&v30->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v32;
  if (v32)
  {
    v23 = (unint64_t *)&v32->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  return v15;
}

void sub_1E05CBD30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;
  uint64_t v12;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v10 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 - 48);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v20[5];
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;

  if (*a1 != &off_1EA999688)
    __cxa_bad_cast();
  v5 = (uint64_t)(a1 + 56);
  v6 = a3[1];
  v25 = *a3;
  v26 = (std::__shared_weak_count *)v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v23 = 0;
  v24 = 0;
  v21 = 0;
  v22 = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)v20, a4);
  v9 = MIL::IRTypeStore<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRPixelBufferValueType const>::Get<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(v5, a2, &v25, &v23, &v21, v20);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v20);
  v10 = v22;
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v24;
  if (v24)
  {
    v14 = (unint64_t *)&v24->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v26;
  if (v26)
  {
    v17 = (unint64_t *)&v26->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  return v9;
}

void sub_1E05CBEA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 - 48);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 - 32);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v24[5];
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;

  if (*a1 != &off_1EA999688)
    __cxa_bad_cast();
  v6 = (uint64_t)(a1 + 56);
  v7 = a3[1];
  v29 = *a3;
  v30 = (std::__shared_weak_count *)v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = a4[1];
  v27 = *a4;
  v28 = (std::__shared_weak_count *)v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v25 = 0;
  v26 = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)v24, a5);
  v13 = MIL::IRTypeStore<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRPixelBufferValueType const>::Get<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(v6, a2, &v29, &v27, &v25, v24);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v24);
  v14 = v26;
  if (v26)
  {
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v28;
  if (v28)
  {
    v18 = (unint64_t *)&v28->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v30;
  if (v30)
  {
    v21 = (unint64_t *)&v30->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  return v13;
}

void sub_1E05CC034(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 - 48);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 - 32);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRPixelBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), unsigned int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v28[5];
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;

  if (*a1 != &off_1EA999688)
    __cxa_bad_cast();
  v7 = a3[1];
  v33 = *a3;
  v34 = (std::__shared_weak_count *)v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = (uint64_t)(a1 + 56);
  v11 = a4[1];
  v31 = *a4;
  v32 = (std::__shared_weak_count *)v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = a5[1];
  v29 = *a5;
  v30 = (std::__shared_weak_count *)v14;
  if (v14)
  {
    v15 = (unint64_t *)(v14 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)v28, a6);
  v17 = MIL::IRTypeStore<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRPixelBufferValueType const>::Get<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(v10, a2, &v33, &v31, &v29, v28);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v28);
  v18 = v30;
  if (v30)
  {
    p_shared_owners = (unint64_t *)&v30->__shared_owners_;
    do
      v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v32;
  if (v32)
  {
    v22 = (unint64_t *)&v32->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = v34;
  if (v34)
  {
    v25 = (unint64_t *)&v34->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  return v17;
}

void sub_1E05CC1E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 - 48);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v2 - 32);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRCircularBufferValueType::MakeWithShape(void (***a1)(MIL::MILContextImpl *__hidden this), int a2, std::__shared_weak_count **a3, uint64_t *a4, uint64_t *a5, _QWORD *a6, uint64_t a7, uint64_t *a8)
{
  std::__shared_weak_count *v14;
  MIL::IRConstantProperty *v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count_vtbl *v17;
  unint64_t v18;
  void **v19;
  unint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  unint64_t *p_shared_owners;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t *v54;
  unint64_t v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  int v73;
  uint64_t v76[5];
  uint64_t v77;
  std::__shared_weak_count *v78;
  uint64_t v79;
  std::__shared_weak_count *v80;
  _QWORD *v81;
  std::__shared_weak_count *v82;
  void **v83;
  std::__shared_weak_count *v84;
  void **v85;
  std::__shared_weak_count *v86;

  v14 = (std::__shared_weak_count *)operator new(0x30uLL);
  v14->__shared_weak_owners_ = 0;
  v14->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA999350;
  v14->__shared_owners_ = 0;
  v14[1].__shared_owners_ = 0;
  v14[1].__shared_weak_owners_ = 0;
  v86 = v14;
  v14[1].__vftable = 0;
  v85 = (void **)&v14[1].__vftable;
  v15 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(a6);
  v73 = a2;
  v16 = *a3;
  v17 = (*a3)->__vftable;
  if ((std::__shared_weak_count_vtbl *)(*a3)->__shared_owners_ != v17)
  {
    v18 = 0;
    do
    {
      if (v15)
      {
        v19 = v85;
        if (v18 == MIL::IRConstantProperty::GetInt64ScalarValue(v15))
        {
          v20 = (unint64_t)v85[2];
          v21 = v85[1];
          if ((unint64_t)v21 >= v20)
          {
            v31 = ((char *)v21 - (_BYTE *)*v85) >> 3;
            if ((unint64_t)(v31 + 1) >> 61)
LABEL_84:
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v32 = v20 - (_QWORD)*v85;
            v33 = v32 >> 2;
            if (v32 >> 2 <= (unint64_t)(v31 + 1))
              v33 = v31 + 1;
            if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8)
              v34 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v34 = v33;
            if (v34)
              v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(v85 + 2), v34);
            else
              v35 = 0;
            v40 = &v35[8 * v31];
            *(_QWORD *)v40 = a7;
            v22 = v40 + 8;
            v42 = (char *)*v19;
            v41 = (char *)v19[1];
            if (v41 != *v19)
            {
              do
              {
                v43 = *((_QWORD *)v41 - 1);
                v41 -= 8;
                *((_QWORD *)v40 - 1) = v43;
                v40 -= 8;
              }
              while (v41 != v42);
              v41 = (char *)*v19;
            }
            *v19 = v40;
            v19[1] = v22;
            v19[2] = &v35[8 * v34];
            if (v41)
              operator delete(v41);
          }
          else
          {
            *v21 = a7;
            v22 = v21 + 1;
          }
          v19[1] = v22;
          goto LABEL_42;
        }
        v16 = *a3;
        v17 = (*a3)->__vftable;
      }
      else
      {
        v19 = v85;
      }
      if (v18 >= (v16->__shared_owners_ - (uint64_t)v17) >> 3)
        std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
      v23 = (unint64_t)v19[2];
      v24 = v19[1];
      if ((unint64_t)v24 >= v23)
      {
        v26 = ((char *)v24 - (_BYTE *)*v19) >> 3;
        if ((unint64_t)(v26 + 1) >> 61)
          goto LABEL_84;
        v27 = v23 - (_QWORD)*v19;
        v28 = v27 >> 2;
        if (v27 >> 2 <= (unint64_t)(v26 + 1))
          v28 = v26 + 1;
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8)
          v29 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v29 = v28;
        if (v29)
          v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(v19 + 2), v29);
        else
          v30 = 0;
        v36 = &v30[8 * v26];
        *(_QWORD *)v36 = *((_QWORD *)&v17->~__shared_weak_count + v18);
        v25 = v36 + 8;
        v38 = (char *)*v19;
        v37 = (char *)v19[1];
        if (v37 != *v19)
        {
          do
          {
            v39 = *((_QWORD *)v37 - 1);
            v37 -= 8;
            *((_QWORD *)v36 - 1) = v39;
            v36 -= 8;
          }
          while (v37 != v38);
          v37 = (char *)*v19;
        }
        *v19 = v36;
        v19[1] = v25;
        v19[2] = &v30[8 * v29];
        if (v37)
          operator delete(v37);
      }
      else
      {
        *v24 = *((_QWORD *)&v17->~__shared_weak_count + v18);
        v25 = v24 + 1;
      }
      v19[1] = v25;
LABEL_42:
      ++v18;
      v16 = *a3;
      v17 = (*a3)->__vftable;
    }
    while (v18 < ((*a3)->__shared_owners_ - (uint64_t)v17) >> 3);
  }
  if (*a1 != &off_1EA999688)
    __cxa_bad_cast();
  v83 = v85;
  v84 = v86;
  if (v86)
  {
    p_shared_owners = (unint64_t *)&v86->__shared_owners_;
    do
      v45 = __ldxr(p_shared_owners);
    while (__stxr(v45 + 1, p_shared_owners));
    v16 = *a3;
  }
  v46 = a3[1];
  v81 = &v16->__vftable;
  v82 = v46;
  if (v46)
  {
    v47 = (unint64_t *)&v46->__shared_owners_;
    do
      v48 = __ldxr(v47);
    while (__stxr(v48 + 1, v47));
  }
  v49 = (uint64_t)(a1 + 61);
  v50 = a4[1];
  v79 = *a4;
  v80 = (std::__shared_weak_count *)v50;
  if (v50)
  {
    v51 = (unint64_t *)(v50 + 8);
    do
      v52 = __ldxr(v51);
    while (__stxr(v52 + 1, v51));
  }
  v53 = a5[1];
  v77 = *a5;
  v78 = (std::__shared_weak_count *)v53;
  if (v53)
  {
    v54 = (unint64_t *)(v53 + 8);
    do
      v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)v76, a8);
  v56 = MIL::IRTypeStore<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,MIL::IRCircularBufferValueType const>::Get<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(v49, v73, (uint64_t *)&v83, (uint64_t *)&v81, &v79, &v77, a6, v76);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v76);
  v57 = v78;
  if (v78)
  {
    v58 = (unint64_t *)&v78->__shared_owners_;
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  v60 = v80;
  if (v80)
  {
    v61 = (unint64_t *)&v80->__shared_owners_;
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
    }
  }
  v63 = v82;
  if (v82)
  {
    v64 = (unint64_t *)&v82->__shared_owners_;
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }
  v66 = v84;
  if (v84)
  {
    v67 = (unint64_t *)&v84->__shared_owners_;
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }
  v69 = v86;
  if (v86)
  {
    v70 = (unint64_t *)&v86->__shared_owners_;
    do
      v71 = __ldaxr(v70);
    while (__stlxr(v71 - 1, v70));
    if (!v71)
    {
      ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
      std::__shared_weak_count::__release_weak(v69);
    }
  }
  return v56;
}

void sub_1E05CC68C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;
  uint64_t v17;
  uint64_t v18;
  va_list va2;
  uint64_t v20;
  va_list va3;

  va_start(va3, a7);
  va_start(va2, a7);
  va_start(va1, a7);
  va_start(va, a7);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v15 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v18 = va_arg(va3, _QWORD);
  v20 = va_arg(va3, _QWORD);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)va);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)va3);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v7 - 120);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v7 - 104);
  _Unwind_Resume(a1);
}

uint64_t MIL::IRStateValueType::Make(void (***this)(MIL::MILContextImpl *__hidden this), MIL::MILContext *a2, const MIL::IRValueType *a3)
{
  if (*this != &off_1EA999688)
    __cxa_bad_cast();
  return MIL::IRTypeStore<MIL::IRValueType const*,MIL::IRStateValueType const>::Get<MIL::IRValueType const*>((uint64_t)(this + 66), a2);
}

uint64_t std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::__deallocate_node(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = v2[3];
      v2[3] = 0;
      if (v4)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRCircularBufferValueType const>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRPixelBufferValueType const>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRTensorBufferValueType const>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>>>::__deallocate_node(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = v2[4];
      v2[4] = 0;
      if (v4)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::__unordered_map_hasher<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::__unordered_map_equal<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::__unordered_map_hasher<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::__unordered_map_equal<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::__unordered_map_hasher<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::__unordered_map_equal<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = v2[4];
      v2[4] = 0;
      if (v4)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
      std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>> const,std::unique_ptr<MIL::IRTensorValueType const>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, char a5)
{
  const void **v9;
  const void **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  const void **v16;
  uint64_t v17;
  const void **v18;
  const void **v19;
  const void **v20;
  __int128 v21;
  unint64_t v22;
  char v23;
  BOOL v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  const void *v28;
  const void *v29;

LABEL_1:
  v9 = a2 - 3;
  v10 = (const void **)a1;
LABEL_2:
  v11 = 1 - a4;
  while (2)
  {
    a1 = (uint64_t)v10;
    v12 = v11;
    v13 = (char *)a2 - (char *)v10;
    v14 = 0xAAAAAAAAAAAAAAABLL * (a2 - v10);
    switch(v14)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (std::less<std::string>::operator()[abi:ne180100](a3, a2 - 3, v10))
        {
          v29 = v10[2];
          v27 = *(_OWORD *)v10;
          v25 = *(_OWORD *)v9;
          v10[2] = *(a2 - 1);
          *(_OWORD *)v10 = v25;
          *(_OWORD *)v9 = v27;
          *(a2 - 1) = v29;
        }
        return;
      case 3uLL:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v10, v10 + 3, a2 - 3, a3);
        return;
      case 4uLL:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((uint64_t)v10, v10 + 3, v10 + 6, (__int128 *)(a2 - 3), a3);
        return;
      case 5uLL:
        std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((uint64_t)v10, v10 + 3, v10 + 6, (__int128 *)(v10 + 9), (__int128 *)(a2 - 3), a3);
        return;
      default:
        if (v13 <= 575)
        {
          if ((a5 & 1) != 0)
            std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((uint64_t)v10, a2, a3);
          else
            std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v10, a2, a3);
          return;
        }
        if (v12 != 1)
        {
          v15 = v14 >> 1;
          v16 = &v10[3 * (v14 >> 1)];
          if ((unint64_t)v13 < 0xC01)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(&v10[3 * v15], v10, a2 - 3, a3);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v10, &v10[3 * v15], a2 - 3, a3);
            v17 = 3 * v15;
            v18 = &v10[3 * v15 - 3];
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v10 + 3, v18, a2 - 6, a3);
            v19 = v10 + 6;
            v20 = &v10[v17 + 3];
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v19, v20, a2 - 9, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v18, v16, v20, a3);
            v28 = *(const void **)(a1 + 16);
            v26 = *(_OWORD *)a1;
            v21 = *(_OWORD *)v16;
            *(_QWORD *)(a1 + 16) = v16[2];
            *(_OWORD *)a1 = v21;
            v16[2] = v28;
            *(_OWORD *)v16 = v26;
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          if (!std::less<std::string>::operator()[abi:ne180100](a3, (const void **)(a1 - 24), (const void **)a1))
          {
            v10 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::string *,std::__less<void,void> &>((const void **)a1, (unint64_t)a2, a3);
            goto LABEL_16;
          }
LABEL_11:
          v22 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::string *,std::__less<void,void> &>((__int128 *)a1, a2, a3);
          if ((v23 & 1) == 0)
            goto LABEL_14;
          v24 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, v22, a3);
          v10 = (const void **)(v22 + 24);
          if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v22 + 24, (uint64_t)a2, a3))
          {
            v11 = v12 + 1;
            if (v24)
              continue;
LABEL_14:
            std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>(a1, v22, a3, -v12, a5 & 1);
            v10 = (const void **)(v22 + 24);
LABEL_16:
            a5 = 0;
            a4 = -v12;
            goto LABEL_2;
          }
          a4 = -v12;
          a2 = (const void **)v22;
          if (v24)
            return;
          goto LABEL_1;
        }
        if (v10 != a2)
          std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,std::string *>((uint64_t)v10, (__int128 *)a2, (__int128 *)a2, a3);
        return;
    }
  }
}

  v9 = (uint64_t *)&a2[-1];
  v10 = a1;
  while (2)
  {
    a1 = v10;
    v11 = (char *)a2 - (char *)v10;
    v12 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)v10) >> 3);
    switch(v12)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v28 = *v10;
        v29 = v10[1];
        if (*v10 == v29)
          return;
        v30 = 0;
        begin = a2[-1].__begin_;
        while (1)
        {
          v32 = (float *)&begin[v30];
          if (&begin[v30] == a2[-1].__end_)
            break;
          v33 = *(float *)(v28 + v30 * 4);
          if (*v32 < v33)
            break;
          ++v30;
          if (v33 < *v32 || v30 * 4 + v28 == v29)
            return;
        }
        *v10 = (uint64_t)begin;
        a2[-1].__begin_ = (std::vector<unsigned int>::pointer)v28;
        v35 = (unsigned int *)v10[1];
        v10[1] = (uint64_t)a2[-1].__end_;
        a2[-1].__end_ = v35;
        v36 = (unsigned int *)v10[2];
        v10[2] = (uint64_t)a2[-1].__end_cap_.__value_;
        a2[-1].__end_cap_.__value_ = v36;
        return;
      case 3uLL:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>(v10, v10 + 3, v9);
        return;
      case 4uLL:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>(v10, v10 + 3, v10 + 6, v9);
        return;
      case 5uLL:
        std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>(v10, v10 + 3, v10 + 6, v10 + 9, v9);
        return;
      default:
        if (v11 <= 575)
        {
          if ((a5 & 1) != 0)
            std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>((std::vector<unsigned int> *)v10, a2);
          else
            std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>((std::vector<unsigned int> *)v10, a2);
          return;
        }
        if (!a4)
        {
          if (v10 != (uint64_t *)a2)
            std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *,std::vector<float> *>((std::vector<unsigned int> *)v10, a2, &a2->__begin_, a3);
          return;
        }
        v13 = v12 >> 1;
        v14 = &a1[3 * (v12 >> 1)];
        if ((unint64_t)v11 < 0xC01)
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>(&a1[3 * (v12 >> 1)], a1, v9);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>(a1, &a1[3 * (v12 >> 1)], v9);
          v15 = v9;
          v16 = &a1[3 * v13];
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>(a1 + 3, v16 - 3, (uint64_t *)&a2[-2]);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>(a1 + 6, &a1[3 * v13 + 3], (uint64_t *)&a2[-3]);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>(v16 - 3, v14, &a1[3 * v13 + 3]);
          v17 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)v14;
          *(_OWORD *)v14 = v17;
          v18 = a1[2];
          a1[2] = v16[2];
          v16[2] = v18;
          v9 = v15;
        }
        --a4;
        if ((a5 & 1) != 0)
          goto LABEL_9;
        v22 = a1[1];
        if (*a1 == v22)
        {
LABEL_22:
          v10 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<float> *,std::__less<void,void> &>((uint64_t)a1, (unint64_t)a2);
          a5 = 0;
          continue;
        }
        v23 = (float *)*(a1 - 3);
        v24 = *a1 + 4;
        while (v23 != (float *)*(a1 - 2))
        {
          v25 = *v23;
          v26 = *(float *)(v24 - 4);
          if (*v23 < v26)
            break;
          ++v23;
          v27 = v26 < v25 || v24 == v22;
          v24 += 4;
          if (v27)
            goto LABEL_22;
        }
LABEL_9:
        v19 = (uint64_t *)std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<float> *,std::__less<void,void> &>((uint64_t)a1, (float **)a2);
        if ((v20 & 1) == 0)
        {
LABEL_12:
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *,false>(a1, v19, a3, a4, a5 & 1);
          a5 = 0;
          v10 = v19 + 3;
          continue;
        }
        v21 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>(a1, v19);
        v10 = v19 + 3;
        if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::vector<float> *>(v19 + 3, (uint64_t *)a2))
        {
          if (v21)
            continue;
          goto LABEL_12;
        }
        a2 = (std::vector<unsigned int> *)v19;
        if (!v21)
          goto LABEL_1;
        return;
    }
  }
}

  v9 = a2 - 1;
  v10 = a1;
LABEL_2:
  v11 = 1 - a4;
  while (2)
  {
    a1 = v10;
    v12 = v11;
    v13 = (char *)a2 - (char *)v10;
    v14 = a2 - v10;
    switch(v14)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)(a2 - 1), (uint64_t)v10))
        {
          v21 = *v10;
          *v10 = *v9;
          *v9 = v21;
        }
        return;
      case 3uLL:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v10, v10 + 1, a2 - 1, a3);
        return;
      case 4uLL:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v10, v10 + 1, v10 + 2, a2 - 1, a3);
        return;
      case 5uLL:
        std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v10, v10 + 1, v10 + 2, v10 + 3, a2 - 1, a3);
        return;
      default:
        if (v13 <= 383)
        {
          if ((a5 & 1) != 0)
            std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>((uint64_t)v10, a2, a3);
          else
            std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>((uint64_t)v10, a2, a3);
          return;
        }
        if (v12 != 1)
        {
          v15 = v14 >> 1;
          v16 = &v10[v14 >> 1];
          if ((unint64_t)v13 < 0x801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(&v10[v14 >> 1], v10, a2 - 1, a3);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v10, &v10[v14 >> 1], a2 - 1, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v10 + 1, v16 - 1, a2 - 2, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v10 + 2, &v10[v15 + 1], a2 - 3, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v16 - 1, v16, &v10[v15 + 1], a3);
            v20 = *v10;
            *v10 = *v16;
            *v16 = v20;
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          if ((std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)(v10 - 1), (uint64_t)v10) & 1) == 0)
          {
            v10 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::string_view *,std::__less<void,void> &>(v10, a2, a3);
            goto LABEL_16;
          }
LABEL_11:
          v17 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::string_view *,std::__less<void,void> &>(v10, (unint64_t)a2, a3);
          if ((v18 & 1) == 0)
            goto LABEL_14;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v10, v17, a3);
          v10 = v17 + 1;
          if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(v17 + 1, a2, a3))
          {
            v11 = v12 + 1;
            if (v19)
              continue;
LABEL_14:
            std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,false>(a1, v17, a3, -v12, a5 & 1);
            v10 = v17 + 1;
LABEL_16:
            a5 = 0;
            a4 = -v12;
            goto LABEL_2;
          }
          a4 = -v12;
          a2 = v17;
          if (v19)
            return;
          goto LABEL_1;
        }
        if (v10 != a2)
          std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,std::string_view *>(v10, a2, a2, a3);
        return;
    }
  }
}

  v8 = (unint64_t *)(a2 - 1);
  i = a1;
  while (2)
  {
    a1 = i;
    v10 = (uint64_t)a2 - i;
    v11 = (uint64_t)((uint64_t)a2 - i) >> 4;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v41 = a2 - 1;
        v42 = *((_QWORD *)a2 - 2);
        if (v42 < *(_QWORD *)i || *(_QWORD *)i >= v42 && *((_QWORD *)a2 - 1) < *(_QWORD *)(i + 8))
        {
          v107 = *(_OWORD *)i;
          *(_OWORD *)i = *v41;
          *v41 = v107;
        }
        return;
      case 3uLL:
        return;
      case 4uLL:
        return;
      case 5uLL:
        v43 = (__int128 *)(i + 16);
        v44 = (__int128 *)(i + 32);
        v45 = (__int128 *)(i + 48);
        v46 = a2 - 1;
        v47 = *((_QWORD *)a2 - 2);
        v48 = *(_QWORD *)(i + 48);
        if (v47 < v48 || v48 >= v47 && *((_QWORD *)a2 - 1) < *(_QWORD *)(i + 56))
        {
          v49 = *v45;
          *v45 = *v46;
          *v46 = v49;
          v50 = *(_QWORD *)(i + 48);
          v51 = *(_QWORD *)(i + 32);
          if (v50 < v51 || v51 >= v50 && *(_QWORD *)(i + 56) < *(_QWORD *)(i + 40))
          {
            v52 = *v44;
            *v44 = *v45;
            *v45 = v52;
            v53 = *(_QWORD *)(i + 32);
            v54 = *(_QWORD *)(i + 16);
            if (v53 < v54 || v54 >= v53 && *(_QWORD *)(i + 40) < *(_QWORD *)(i + 24))
            {
              v55 = *v43;
              *v43 = *v44;
              *v44 = v55;
              v56 = *(_QWORD *)(i + 16);
              if (v56 < *(_QWORD *)i || *(_QWORD *)i >= v56 && *(_QWORD *)(i + 24) < *(_QWORD *)(i + 8))
              {
                v108 = *(_OWORD *)i;
                *(_OWORD *)i = *v43;
                *v43 = v108;
              }
            }
          }
        }
        return;
      default:
        if (v10 <= 383)
        {
          v57 = (__int128 *)(i + 16);
          v59 = (__int128 *)i == a2 || v57 == a2;
          if ((a4 & 1) != 0)
          {
            if (v59)
              return;
            v60 = 0;
            v61 = (_OWORD *)i;
            while (1)
            {
              v62 = (unint64_t *)v61;
              v61 = v57;
              v63 = v62[2];
              if (v63 < *v62)
                break;
              if (*v62 >= v63)
              {
                v64 = v62[3];
                if (v64 < v62[1])
                  goto LABEL_103;
              }
LABEL_116:
              v57 = v61 + 1;
              v60 += 16;
              if (v61 + 1 == a2)
                return;
            }
            v64 = v62[3];
LABEL_103:
            *v61 = *(_OWORD *)v62;
            v65 = (_QWORD *)i;
            if (v62 != (unint64_t *)i)
            {
              v66 = v60;
              while (1)
              {
                v67 = (_OWORD *)(i + v66);
                v68 = *(_QWORD *)(i + v66 - 16);
                if (v63 >= v68)
                {
                  if (v68 < v63)
                  {
                    v65 = (_QWORD *)(i + v66);
                    goto LABEL_115;
                  }
                  if (v64 >= *((_QWORD *)v67 - 1))
                    break;
                }
                v62 -= 2;
                *v67 = *(_OWORD *)(i + v66 - 16);
                v66 -= 16;
                if (!v66)
                {
                  v65 = (_QWORD *)i;
                  goto LABEL_115;
                }
              }
              v65 = v62;
            }
LABEL_115:
            *v65 = v63;
            v65[1] = v64;
            goto LABEL_116;
          }
          if (v59)
            return;
          while (1)
          {
            v98 = (unint64_t *)a1;
            a1 = (uint64_t)v57;
            v99 = v98[2];
            if (v99 < *v98)
              break;
            if (*v98 >= v99)
            {
              v100 = v98[3];
              if (v100 < v98[1])
                goto LABEL_177;
            }
LABEL_183:
            v57 = (__int128 *)(a1 + 16);
            if ((__int128 *)(a1 + 16) == a2)
              return;
          }
          v100 = v98[3];
          do
          {
            do
            {
LABEL_177:
              v101 = v98;
              *((_OWORD *)v98 + 1) = *(_OWORD *)v98;
              v103 = *(v98 - 2);
              v98 -= 2;
              v102 = v103;
            }
            while (v99 < v103);
          }
          while (v102 >= v99 && v100 < *(v101 - 1));
          *v101 = v99;
          v101[1] = v100;
          goto LABEL_183;
        }
        if (!a3)
        {
          if ((__int128 *)i == a2)
            return;
          v69 = (v11 - 2) >> 1;
          v70 = v69;
          do
          {
            v71 = v70;
            if (v69 >= v70)
            {
              v72 = (2 * v70) | 1;
              v73 = (unint64_t *)(i + 16 * v72);
              if (2 * v71 + 2 < (uint64_t)v11)
              {
                v74 = v73[2];
                if (*v73 < v74 || v74 >= *v73 && v73[1] < v73[3])
                {
                  v73 += 2;
                  v72 = 2 * v71 + 2;
                }
              }
              v75 = (unint64_t *)(i + 16 * v71);
              v76 = *v75;
              if (*v73 >= *v75)
              {
                v77 = *(_QWORD *)(i + 16 * v71 + 8);
                if (v76 < *v73 || v73[1] >= v77)
                {
                  *(_OWORD *)v75 = *(_OWORD *)v73;
                  if (v69 >= v72)
                  {
                    while (1)
                    {
                      v79 = 2 * v72;
                      v72 = (2 * v72) | 1;
                      v78 = (unint64_t *)(i + 16 * v72);
                      v80 = v79 + 2;
                      if (v80 < (uint64_t)v11)
                      {
                        v81 = v78[2];
                        if (*v78 < v81 || v81 >= *v78 && v78[1] < v78[3])
                        {
                          v78 += 2;
                          v72 = v80;
                        }
                      }
                      if (*v78 < v76 || v76 >= *v78 && v78[1] < v77)
                        break;
                      *(_OWORD *)v73 = *(_OWORD *)v78;
                      v73 = v78;
                      if (v69 < v72)
                        goto LABEL_131;
                    }
                  }
                  v78 = v73;
LABEL_131:
                  *v78 = v76;
                  v78[1] = v77;
                }
              }
            }
            v70 = v71 - 1;
          }
          while (v71);
          v82 = (unint64_t)v10 >> 4;
          while (1)
          {
            v83 = 0;
            v109 = *(_OWORD *)i;
            v84 = (__int128 *)i;
            do
            {
              v85 = v84;
              v84 += v83 + 1;
              v86 = 2 * v83;
              v83 = (2 * v83) | 1;
              v87 = v86 + 2;
              if (v87 < v82)
              {
                v88 = *((_QWORD *)v84 + 2);
                if (*(_QWORD *)v84 < v88 || v88 >= *(_QWORD *)v84 && *((_QWORD *)v84 + 1) < *((_QWORD *)v84 + 3))
                {
                  ++v84;
                  v83 = v87;
                }
              }
              *v85 = *v84;
            }
            while (v83 <= (uint64_t)((unint64_t)(v82 - 2) >> 1));
            if (v84 == --a2)
            {
              *v84 = v109;
            }
            else
            {
              *v84 = *a2;
              *a2 = v109;
              v89 = (uint64_t)v84 - i + 16;
              if (v89 >= 17)
              {
                v90 = ((unint64_t)v89 >> 4) - 2;
                v91 = v90 >> 1;
                v92 = (unint64_t *)(i + 16 * (v90 >> 1));
                v93 = *(_QWORD *)v84;
                if (*v92 < *(_QWORD *)v84)
                {
                  v94 = *((_QWORD *)v84 + 1);
LABEL_158:
                  *v84 = *(_OWORD *)v92;
                  if (v90 >= 2)
                  {
                    while (1)
                    {
                      v96 = v91 - 1;
                      v91 = (v91 - 1) >> 1;
                      v95 = (unint64_t *)(i + 16 * v91);
                      if (*v95 >= v93 && (v93 < *v95 || v95[1] >= v94))
                        break;
                      *(_OWORD *)v92 = *(_OWORD *)v95;
                      v92 = (unint64_t *)(i + 16 * v91);
                      if (v96 <= 1)
                        goto LABEL_164;
                    }
                  }
                  v95 = v92;
LABEL_164:
                  *v95 = v93;
                  v95[1] = v94;
                  goto LABEL_165;
                }
                if (v93 >= *v92)
                {
                  v94 = *((_QWORD *)v84 + 1);
                  if (v92[1] < v94)
                    goto LABEL_158;
                }
              }
            }
LABEL_165:
            if (v82-- <= 2)
              return;
          }
        }
        v12 = v11 >> 1;
        v13 = (unint64_t *)(i + 16 * (v11 >> 1));
        if ((unint64_t)v10 < 0x801)
        {
        }
        else
        {
          v104 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)v13;
          *(_OWORD *)v13 = v104;
        }
        --a3;
        v14 = *(_QWORD *)a1;
        if ((a4 & 1) == 0)
        {
          v15 = *(_QWORD *)(a1 - 16);
          if (v15 >= v14)
          {
            v16 = *(_QWORD *)(a1 + 8);
            if (v14 < v15 || *(_QWORD *)(a1 - 8) >= v16)
            {
              v32 = *v8;
              if (v14 >= *v8 && (v32 < v14 || v16 >= *((_QWORD *)a2 - 1)))
              {
                for (i = a1 + 16;
                      i < (unint64_t)a2
                   && v14 >= *(_QWORD *)i
                   && (*(_QWORD *)i < v14 || v16 >= *(_QWORD *)(i + 8));
              }
              else
              {
                i = a1;
                do
                {
                  v34 = *(_QWORD *)(i + 16);
                  i += 16;
                  v33 = v34;
                }
                while (v14 >= v34 && (v33 < v14 || v16 >= *(_QWORD *)(i + 8)));
              }
              j = a2;
              if (i < (unint64_t)a2)
              {
                for (j = a2 - 1; v14 < v32 || v32 >= v14 && v16 < *((_QWORD *)j + 1); --j)
                {
                  v36 = *((_QWORD *)j - 2);
                  v32 = v36;
                }
              }
              while (i < (unint64_t)j)
              {
                v106 = *(_OWORD *)i;
                *(_OWORD *)i = *j;
                *j = v106;
                do
                {
                  v38 = *(_QWORD *)(i + 16);
                  i += 16;
                  v37 = v38;
                }
                while (v14 >= v38 && (v37 < v14 || v16 >= *(_QWORD *)(i + 8)));
                do
                {
                  do
                  {
                    v40 = *((_QWORD *)j-- - 2);
                    v39 = v40;
                  }
                  while (v14 < v40);
                }
                while (v39 >= v14 && v16 < *((_QWORD *)j + 1));
              }
              if (i - 16 != a1)
                *(_OWORD *)a1 = *(_OWORD *)(i - 16);
              a4 = 0;
              *(_QWORD *)(i - 16) = v14;
              *(_QWORD *)(i - 8) = v16;
              continue;
            }
          }
        }
        v17 = 0;
        v18 = *(_QWORD *)(a1 + 8);
        while (1)
        {
          v19 = *(_QWORD *)(a1 + v17 + 16);
          if (v19 >= v14 && (v14 < v19 || *(_QWORD *)(a1 + v17 + 24) >= v18))
            break;
          v17 += 16;
        }
        v20 = a1 + v17 + 16;
        if (v17)
        {
          v21 = *v8;
          for (k = a2 - 1; v21 >= v14 && (v14 < v21 || *((_QWORD *)k + 1) >= v18); --k)
          {
            v23 = *((_QWORD *)k - 2);
            v21 = v23;
          }
        }
        else
        {
          k = a2;
          if (v20 < (unint64_t)a2)
          {
            v24 = *v8;
            k = a2 - 1;
            if (*v8 >= v14)
            {
              k = a2 - 1;
              do
              {
                if (v14 >= v24)
                {
                  if (v20 >= (unint64_t)k || *((_QWORD *)k + 1) < v18)
                    break;
                }
                else if (v20 >= (unint64_t)k)
                {
                  break;
                }
                v25 = *((_QWORD *)k-- - 2);
                v24 = v25;
              }
              while (v25 >= v14);
            }
          }
        }
        i = v20;
        if (v20 < (unint64_t)k)
        {
          v26 = (unint64_t)k;
          do
          {
            v105 = *(_OWORD *)i;
            *(_OWORD *)i = *(_OWORD *)v26;
            *(_OWORD *)v26 = v105;
            do
            {
              do
              {
                v28 = *(_QWORD *)(i + 16);
                i += 16;
                v27 = v28;
              }
              while (v28 < v14);
            }
            while (v14 >= v27 && *(_QWORD *)(i + 8) < v18);
            do
            {
              v30 = *(_QWORD *)(v26 - 16);
              v26 -= 16;
              v29 = v30;
            }
            while (v30 >= v14 && (v14 < v29 || *(_QWORD *)(v26 + 8) >= v18));
          }
          while (i < v26);
        }
        if (i - 16 != a1)
          *(_OWORD *)a1 = *(_OWORD *)(i - 16);
        *(_QWORD *)(i - 16) = v14;
        *(_QWORD *)(i - 8) = v18;
        if (v20 < (unint64_t)k)
        {
LABEL_47:
          a4 = 0;
          continue;
        }
        {
          if (v31)
            continue;
          goto LABEL_47;
        }
        a2 = (__int128 *)(i - 16);
        if (!v31)
          goto LABEL_1;
        return;
    }
  }
}

  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = ((char *)a2 - (char *)v9) >> 4;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v20 = (__int128 *)(a2 - 2);
        v21 = *(a2 - 2);
        if (v21 < *v9 || *v9 >= v21 && *(a2 - 1) < v9[1])
        {
          v23 = *(_OWORD *)v9;
          *(_OWORD *)v9 = *v20;
          *v20 = v23;
        }
        return;
      case 3uLL:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((__int128 *)v9, v9 + 2, (__int128 *)a2 - 1);
        return;
      case 4uLL:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((uint64_t)v9, v9 + 2, (uint64_t)(v9 + 4), (uint64_t)(a2 - 2));
        return;
      case 5uLL:
        std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((__n128 *)v9, v9 + 2, (__n128 *)v9 + 2, (__n128 *)v9 + 3, (__n128 *)a2 - 1);
        return;
      default:
        if (v12 <= 383)
        {
          if ((a5 & 1) != 0)
            std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(v9, a2);
          else
            std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(v9, a2);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((__int128 *)&v9[2 * (v13 >> 1)], v9, (__int128 *)a2 - 1);
            if ((a5 & 1) != 0)
              goto LABEL_13;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((__int128 *)v9, &v9[2 * (v13 >> 1)], (__int128 *)a2 - 1);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((__int128 *)v9 + 1, v15 - 2, (__int128 *)a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((__int128 *)v9 + 2, &v9[2 * v14 + 2], (__int128 *)a2 - 3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((__int128 *)v15 - 1, v15, (__int128 *)&v9[2 * v14 + 2]);
            v22 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *(_OWORD *)v15;
            *(_OWORD *)v15 = v22;
            if ((a5 & 1) != 0)
              goto LABEL_13;
          }
          v16 = *(v9 - 2);
          if (v16 >= *v9 && (*v9 < v16 || *(v9 - 1) >= v9[1]))
          {
            v9 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *,std::__less<void,void> &>(v9, (unint64_t)a2);
            goto LABEL_18;
          }
LABEL_13:
          v17 = (__int128 *)std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *,std::__less<void,void> &>(v9, (unint64_t)a2);
          if ((v18 & 1) == 0)
            goto LABEL_16;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((uint64_t)v9, v17);
          v9 = (unint64_t *)(v17 + 1);
          if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((uint64_t)(v17 + 1), (__int128 *)a2))
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_16:
            std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *,false>(a1, v17, a3, -v11, a5 & 1);
            v9 = (unint64_t *)(v17 + 1);
LABEL_18:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = (unint64_t *)v17;
          if (v19)
            return;
          goto LABEL_1;
        }
        if (v9 != a2)
          std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(v9, a2, a2, a3);
        return;
    }
  }
}

void std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  const void **v7;
  uint64_t v9;
  const void **v10;
  const void **v11;
  uint64_t v12;
  uint64_t v13;
  void **v14;
  int v15;
  uint64_t v16;
  __int128 v17;
  const void *v18;
  uint64_t v19;
  uint64_t v20;

  if ((const void **)a1 != a2)
  {
    v19 = v3;
    v20 = v4;
    v7 = (const void **)(a1 + 24);
    if ((const void **)(a1 + 24) != a2)
    {
      v9 = 0;
      v10 = (const void **)a1;
      do
      {
        v11 = v10;
        v10 = v7;
        if (std::less<std::string>::operator()[abi:ne180100](a3, v7, v11))
        {
          v17 = *(_OWORD *)v10;
          v18 = v10[2];
          v10[1] = 0;
          v10[2] = 0;
          *v10 = 0;
          v12 = v9;
          do
          {
            v13 = a1 + v12;
            v14 = (void **)(a1 + v12 + 24);
            if (*(char *)(a1 + v12 + 47) < 0)
              operator delete(*v14);
            *(_OWORD *)v14 = *(_OWORD *)v13;
            *(_QWORD *)(a1 + v12 + 40) = *(_QWORD *)(v13 + 16);
            *(_BYTE *)(v13 + 23) = 0;
            *(_BYTE *)v13 = 0;
            if (!v12)
            {
              v16 = a1;
              goto LABEL_13;
            }
            v12 -= 24;
          }
          while (std::less<std::string>::operator()[abi:ne180100](a3, (const void **)&v17, (const void **)(v12 + a1)));
          v15 = *(char *)(a1 + v12 + 47);
          v16 = a1 + v12 + 24;
          if (v15 < 0)
            operator delete(*(void **)v16);
LABEL_13:
          *(_OWORD *)v16 = v17;
          *(_QWORD *)(v16 + 16) = v18;
        }
        v7 = v10 + 3;
        v9 += 24;
      }
      while (v10 + 3 != a2);
    }
  }
}

void std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(const void **a1, const void **a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  const void **v6;
  const void **v7;
  const void **v9;
  const void **v10;
  const void **v11;
  void **v12;
  BOOL v13;
  int v14;
  const void **v15;
  __int128 v16;
  const void *v17;
  uint64_t v18;
  uint64_t v19;

  if (a1 != a2)
  {
    v18 = v3;
    v19 = v4;
    v6 = a1;
    v7 = a1 + 3;
    if (a1 + 3 != a2)
    {
      v9 = a1 - 3;
      do
      {
        v10 = v6;
        v6 = v7;
        if (std::less<std::string>::operator()[abi:ne180100](a3, v7, v10))
        {
          v16 = *(_OWORD *)v6;
          v17 = v6[2];
          v6[1] = 0;
          v6[2] = 0;
          *v6 = 0;
          v11 = v9;
          do
          {
            v12 = (void **)(v11 + 6);
            if (*((char *)v11 + 71) < 0)
              operator delete(*v12);
            *(_OWORD *)v12 = *(_OWORD *)(v11 + 3);
            v11[8] = v11[5];
            *((_BYTE *)v11 + 47) = 0;
            *((_BYTE *)v11 + 24) = 0;
            v13 = std::less<std::string>::operator()[abi:ne180100](a3, (const void **)&v16, v11);
            v11 -= 3;
          }
          while (v13);
          v14 = *((char *)v11 + 71);
          v15 = v11 + 6;
          if (v14 < 0)
            operator delete((void *)*v15);
          *(_OWORD *)v15 = v16;
          v15[2] = v17;
        }
        v7 = v6 + 3;
        v9 += 3;
      }
      while (v6 + 3 != a2);
    }
  }
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(const void **a1, const void **a2, const void **a3, uint64_t a4)
{
  BOOL v8;
  uint64_t result;
  const void *v10;
  __int128 v11;
  const void *v12;
  const void *v13;
  __int128 v14;
  const void *v15;
  const void *v16;
  __int128 v17;
  const void *v18;
  const void *v19;
  __int128 v20;
  const void *v21;
  const void *v22;
  __int128 v23;
  const void *v24;

  v8 = std::less<std::string>::operator()[abi:ne180100](a4, a2, a1);
  result = std::less<std::string>::operator()[abi:ne180100](a4, a3, a2);
  if (!v8)
  {
    if (!(_DWORD)result)
      return result;
    v13 = a2[2];
    v14 = *(_OWORD *)a2;
    v15 = a3[2];
    *(_OWORD *)a2 = *(_OWORD *)a3;
    a2[2] = v15;
    *(_OWORD *)a3 = v14;
    a3[2] = v13;
    if (!std::less<std::string>::operator()[abi:ne180100](a4, a2, a1))
      return 1;
    v16 = a1[2];
    v17 = *(_OWORD *)a1;
    v18 = a2[2];
    *(_OWORD *)a1 = *(_OWORD *)a2;
    a1[2] = v18;
    *(_OWORD *)a2 = v17;
    a2[2] = v16;
    return 2;
  }
  if (!(_DWORD)result)
  {
    v19 = a1[2];
    v20 = *(_OWORD *)a1;
    v21 = a2[2];
    *(_OWORD *)a1 = *(_OWORD *)a2;
    a1[2] = v21;
    *(_OWORD *)a2 = v20;
    a2[2] = v19;
    if (!std::less<std::string>::operator()[abi:ne180100](a4, a3, a2))
      return 1;
    v22 = a2[2];
    v23 = *(_OWORD *)a2;
    v24 = a3[2];
    *(_OWORD *)a2 = *(_OWORD *)a3;
    a2[2] = v24;
    *(_OWORD *)a3 = v23;
    a3[2] = v22;
    return 2;
  }
  v10 = a1[2];
  v11 = *(_OWORD *)a1;
  v12 = a3[2];
  *(_OWORD *)a1 = *(_OWORD *)a3;
  a1[2] = v12;
  *(_OWORD *)a3 = v11;
  a3[2] = v10;
  return 1;
}

const void **std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::string *,std::__less<void,void> &>(const void **a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  const void **v6;
  const void **v7;
  _BOOL4 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  void **v12;
  __int128 v13;
  __int128 v14;
  __int128 v16;
  const void *v17;
  __int128 v18;
  const void *v19;

  v4 = a2;
  v16 = *(_OWORD *)a1;
  v17 = a1[2];
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  if (std::less<std::string>::operator()[abi:ne180100](a3, (const void **)&v16, (const void **)(a2 - 24)))
  {
    v6 = a1;
    do
      v6 += 3;
    while (!std::less<std::string>::operator()[abi:ne180100](a3, (const void **)&v16, v6));
  }
  else
  {
    v7 = a1 + 3;
    do
    {
      v6 = v7;
      if ((unint64_t)v7 >= v4)
        break;
      v8 = std::less<std::string>::operator()[abi:ne180100](a3, (const void **)&v16, v7);
      v7 = v6 + 3;
    }
    while (!v8);
  }
  if ((unint64_t)v6 < v4)
  {
    do
      v4 -= 24;
    while (std::less<std::string>::operator()[abi:ne180100](a3, (const void **)&v16, (const void **)v4));
  }
  while ((unint64_t)v6 < v4)
  {
    v9 = *(_OWORD *)v6;
    v19 = v6[2];
    v18 = v9;
    v10 = *(_OWORD *)v4;
    v6[2] = *(const void **)(v4 + 16);
    *(_OWORD *)v6 = v10;
    v11 = v18;
    *(_QWORD *)(v4 + 16) = v19;
    *(_OWORD *)v4 = v11;
    do
      v6 += 3;
    while (!std::less<std::string>::operator()[abi:ne180100](a3, (const void **)&v16, v6));
    do
      v4 -= 24;
    while (std::less<std::string>::operator()[abi:ne180100](a3, (const void **)&v16, (const void **)v4));
  }
  v12 = (void **)(v6 - 3);
  if (v6 - 3 == a1)
  {
    if (*((char *)v6 - 1) < 0)
      operator delete(*v12);
  }
  else
  {
    if (*((char *)a1 + 23) < 0)
      operator delete((void *)*a1);
    v13 = *(_OWORD *)v12;
    a1[2] = *(v6 - 1);
    *(_OWORD *)a1 = v13;
    *((_BYTE *)v6 - 1) = 0;
    *((_BYTE *)v6 - 24) = 0;
  }
  v14 = v16;
  *(v6 - 1) = v17;
  *(_OWORD *)v12 = v14;
  return v6;
}

unint64_t std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::string *,std::__less<void,void> &>(__int128 *a1, const void **a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  const void **v9;
  __int128 v10;
  const void *v11;
  const void *v12;
  void **v13;
  __int128 v14;
  __int128 v15;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  const void *v20;

  v6 = 0;
  v17 = *a1;
  v18 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  *(_QWORD *)a1 = 0;
  do
    v6 += 24;
  while (std::less<std::string>::operator()[abi:ne180100](a3, (const void **)((char *)a1 + v6), (const void **)&v17));
  v7 = (unint64_t)a1 + v6;
  if (v6 == 24)
  {
    do
    {
      if (v7 >= (unint64_t)a2)
        break;
      a2 -= 3;
    }
    while (!std::less<std::string>::operator()[abi:ne180100](a3, a2, (const void **)&v17));
  }
  else
  {
    do
      a2 -= 3;
    while (!std::less<std::string>::operator()[abi:ne180100](a3, a2, (const void **)&v17));
  }
  v8 = (unint64_t)a1 + v6;
  if (v7 < (unint64_t)a2)
  {
    v9 = a2;
    do
    {
      v19 = *(_OWORD *)v8;
      v10 = v19;
      v20 = *(const void **)(v8 + 16);
      v11 = v20;
      v12 = v9[2];
      *(_OWORD *)v8 = *(_OWORD *)v9;
      *(_QWORD *)(v8 + 16) = v12;
      v9[2] = v11;
      *(_OWORD *)v9 = v10;
      do
        v8 += 24;
      while (std::less<std::string>::operator()[abi:ne180100](a3, (const void **)v8, (const void **)&v17));
      do
        v9 -= 3;
      while (!std::less<std::string>::operator()[abi:ne180100](a3, v9, (const void **)&v17));
    }
    while (v8 < (unint64_t)v9);
  }
  v13 = (void **)(v8 - 24);
  if ((__int128 *)(v8 - 24) == a1)
  {
    if (*(char *)(v8 - 1) < 0)
      operator delete(*v13);
  }
  else
  {
    if (*((char *)a1 + 23) < 0)
      operator delete(*(void **)a1);
    v14 = *(_OWORD *)v13;
    *((_QWORD *)a1 + 2) = *(_QWORD *)(v8 - 8);
    *a1 = v14;
    *(_BYTE *)(v8 - 1) = 0;
    *(_BYTE *)(v8 - 24) = 0;
  }
  v15 = v17;
  *(_QWORD *)(v8 - 8) = v18;
  *(_OWORD *)v13 = v15;
  return v8 - 24;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  const void **v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  void **v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;

  v6 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v8 = a2 - 24;
      if (std::less<std::string>::operator()[abi:ne180100](a3, (const void **)(a2 - 24), (const void **)a1))
      {
        v9 = *(_QWORD *)(a1 + 16);
        v10 = *(_OWORD *)a1;
        v11 = *(_QWORD *)(v8 + 16);
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_QWORD *)(a1 + 16) = v11;
        *(_OWORD *)v8 = v10;
        *(_QWORD *)(v8 + 16) = v9;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((const void **)a1, (const void **)(a1 + 24), (const void **)(a2 - 24), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, (const void **)(a1 + 24), (const void **)(a1 + 48), (__int128 *)(a2 - 24), a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, (const void **)(a1 + 24), (const void **)(a1 + 48), (__int128 *)(a1 + 72), (__int128 *)(a2 - 24), a3);
      return 1;
    default:
      v12 = (const void **)(a1 + 48);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((const void **)a1, (const void **)(a1 + 24), (const void **)(a1 + 48), a3);
      v13 = a1 + 72;
      if (a1 + 72 == a2)
        return 1;
      v14 = 0;
      v15 = 0;
      break;
  }
  while (1)
  {
    if (std::less<std::string>::operator()[abi:ne180100](a3, (const void **)v13, v12))
    {
      v22 = *(_OWORD *)v13;
      v23 = *(_QWORD *)(v13 + 16);
      *(_QWORD *)(v13 + 8) = 0;
      *(_QWORD *)(v13 + 16) = 0;
      *(_QWORD *)v13 = 0;
      v16 = v14;
      do
      {
        v17 = a1 + v16;
        v18 = (void **)(a1 + v16 + 72);
        if (*(char *)(a1 + v16 + 95) < 0)
          operator delete(*v18);
        *(_OWORD *)v18 = *(_OWORD *)(v17 + 48);
        *(_QWORD *)(a1 + v16 + 88) = *(_QWORD *)(v17 + 64);
        *(_BYTE *)(v17 + 71) = 0;
        *(_BYTE *)(v17 + 48) = 0;
        if (v16 == -48)
        {
          v21 = a1;
          goto LABEL_15;
        }
        v19 = std::less<std::string>::operator()[abi:ne180100](a3, (const void **)&v22, (const void **)(a1 + v16 + 24));
        v16 -= 24;
      }
      while (v19);
      v20 = *(char *)(a1 + v16 + 95);
      v21 = a1 + v16 + 72;
      if (v20 < 0)
        operator delete(*(void **)v21);
LABEL_15:
      *(_OWORD *)v21 = v22;
      *(_QWORD *)(v21 + 16) = v23;
      if (++v15 == 8)
        return v13 + 24 == a2;
    }
    v12 = (const void **)v13;
    v14 += 24;
    v13 += 24;
    if (v13 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, const void **a2, const void **a3, __int128 *a4, uint64_t a5)
{
  __n128 result;
  const void *v11;
  __int128 v12;
  const void *v13;
  const void *v14;
  __int128 v15;
  const void *v16;
  const void *v17;
  const void *v18;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((const void **)a1, a2, a3, a5);
  if (std::less<std::string>::operator()[abi:ne180100](a5, (const void **)a4, a3))
  {
    v11 = a3[2];
    v12 = *(_OWORD *)a3;
    v13 = (const void *)*((_QWORD *)a4 + 2);
    *(_OWORD *)a3 = *a4;
    a3[2] = v13;
    *a4 = v12;
    *((_QWORD *)a4 + 2) = v11;
    if (std::less<std::string>::operator()[abi:ne180100](a5, a3, a2))
    {
      v14 = a2[2];
      v15 = *(_OWORD *)a2;
      v16 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v16;
      *(_OWORD *)a3 = v15;
      a3[2] = v14;
      if (std::less<std::string>::operator()[abi:ne180100](a5, a2, (const void **)a1))
      {
        v17 = *(const void **)(a1 + 16);
        result = *(__n128 *)a1;
        v18 = a2[2];
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_QWORD *)(a1 + 16) = v18;
        *(__n128 *)a2 = result;
        a2[2] = v17;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, const void **a2, const void **a3, __int128 *a4, __int128 *a5, uint64_t a6)
{
  __n128 result;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  const void *v16;
  __int128 v17;
  const void *v18;
  const void *v19;
  __int128 v20;
  const void *v21;
  const void *v22;
  const void *v23;

  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a2, a3, a4, a6);
  if (std::less<std::string>::operator()[abi:ne180100](a6, (const void **)a5, (const void **)a4))
  {
    v13 = *((_QWORD *)a4 + 2);
    v14 = *a4;
    v15 = *((_QWORD *)a5 + 2);
    *a4 = *a5;
    *((_QWORD *)a4 + 2) = v15;
    *a5 = v14;
    *((_QWORD *)a5 + 2) = v13;
    if (std::less<std::string>::operator()[abi:ne180100](a6, (const void **)a4, a3))
    {
      v16 = a3[2];
      v17 = *(_OWORD *)a3;
      v18 = (const void *)*((_QWORD *)a4 + 2);
      *(_OWORD *)a3 = *a4;
      a3[2] = v18;
      *a4 = v17;
      *((_QWORD *)a4 + 2) = v16;
      if (std::less<std::string>::operator()[abi:ne180100](a6, a3, a2))
      {
        v19 = a2[2];
        v20 = *(_OWORD *)a2;
        v21 = a3[2];
        *(_OWORD *)a2 = *(_OWORD *)a3;
        a2[2] = v21;
        *(_OWORD *)a3 = v20;
        a3[2] = v19;
        if (std::less<std::string>::operator()[abi:ne180100](a6, a2, (const void **)a1))
        {
          v22 = *(const void **)(a1 + 16);
          result = *(__n128 *)a1;
          v23 = a2[2];
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_QWORD *)(a1 + 16) = v23;
          *(__n128 *)a2 = result;
          a2[2] = v22;
        }
      }
    }
  }
  return result;
}

__int128 *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,std::string *>(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __n128 *v12;
  __int128 *v13;
  __int128 *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  int64_t v18;
  __int128 *v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  __int128 v25;
  _BYTE v28[15];

  if ((__int128 *)a1 != a2)
  {
    v8 = (uint64_t)a2 - a1;
    v9 = ((uint64_t)a2 - a1) / 24;
    if ((uint64_t)a2 - a1 >= 25)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = (__n128 *)(a1 + 24 * v10);
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a4, v9, v12);
        v12 = (__n128 *)((char *)v12 - 24);
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        if (std::less<std::string>::operator()[abi:ne180100](a4, (const void **)v14, (const void **)a1))
        {
          v15 = *((_QWORD *)v14 + 2);
          v16 = *v14;
          v17 = *(_QWORD *)(a1 + 16);
          *v14 = *(_OWORD *)a1;
          *((_QWORD *)v14 + 2) = v17;
          *(_OWORD *)a1 = v16;
          *(_QWORD *)(a1 + 16) = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a4, v9, (__n128 *)a1);
        }
        v14 = (__int128 *)((char *)v14 + 24);
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 25)
    {
      v18 = v8 / 0x18uLL;
      v19 = (__int128 *)((char *)a2 - 24);
      do
      {
        v20 = *(_QWORD *)a1;
        *(_QWORD *)v28 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)&v28[7] = *(_QWORD *)(a1 + 15);
        v21 = *(_BYTE *)(a1 + 23);
        *(_QWORD *)(a1 + 8) = 0;
        *(_QWORD *)(a1 + 16) = 0;
        *(_QWORD *)a1 = 0;
        v22 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a4, v18);
        v23 = v22;
        v24 = *(char *)(v22 + 23);
        if (v19 == (__int128 *)v22)
        {
          if (v24 < 0)
            operator delete(*(void **)v22);
          *(_QWORD *)v23 = v20;
          *(_QWORD *)(v23 + 8) = *(_QWORD *)v28;
          *(_QWORD *)(v23 + 15) = *(_QWORD *)&v28[7];
          *(_BYTE *)(v23 + 23) = v21;
        }
        else
        {
          if (v24 < 0)
            operator delete(*(void **)v22);
          v25 = *v19;
          *(_QWORD *)(v23 + 16) = *((_QWORD *)v19 + 2);
          *(_OWORD *)v23 = v25;
          *(_QWORD *)v19 = v20;
          *((_QWORD *)v19 + 1) = *(_QWORD *)v28;
          *(_QWORD *)((char *)v19 + 15) = *(_QWORD *)&v28[7];
          *((_BYTE *)v19 + 23) = v21;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, v23 + 24, a4, 0xAAAAAAAAAAAAAAABLL * ((v23 + 24 - a1) >> 3));
        }
        v19 = (__int128 *)((char *)v19 - 24);
      }
      while (v18-- > 2);
    }
    return v13;
  }
  return a3;
}

void sub_1E05CDB70(_Unwind_Exception *exception_object)
{
  void *v1;
  int v2;

  if (v2 < 0)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

__n128 std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  __n128 *v7;
  uint64_t v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __n128 result;
  __n128 *v16;
  __n128 v17;
  uint64_t v18;
  uint64_t v19;
  __n128 v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v6 = a3 - 2;
  if (a3 >= 2)
  {
    v22 = v4;
    v23 = v5;
    v7 = a4;
    v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * (((uint64_t)a4 - a1) >> 3)))
    {
      v12 = (0x5555555555555556 * (((uint64_t)a4 - a1) >> 3)) | 1;
      v13 = a1 + 24 * v12;
      v14 = 0x5555555555555556 * (((uint64_t)a4 - a1) >> 3) + 2;
      if (v14 < a3
        && std::less<std::string>::operator()[abi:ne180100](a2, (const void **)(a1 + 24 * v12), (const void **)(v13 + 24)))
      {
        v13 += 24;
        v12 = v14;
      }
      if (!std::less<std::string>::operator()[abi:ne180100](a2, (const void **)v13, (const void **)v7))
      {
        v20 = *v7;
        v21 = v7[1].n128_u64[0];
        v7->n128_u64[1] = 0;
        v7[1].n128_u64[0] = 0;
        v7->n128_u64[0] = 0;
        while (1)
        {
          v16 = (__n128 *)v13;
          if (v7[1].n128_i8[7] < 0)
            operator delete((void *)v7->n128_u64[0]);
          v17 = *(__n128 *)v13;
          v7[1].n128_u64[0] = *(_QWORD *)(v13 + 16);
          *v7 = v17;
          *(_BYTE *)(v13 + 23) = 0;
          *(_BYTE *)v13 = 0;
          if (v9 < v12)
            break;
          v18 = (2 * v12) | 1;
          v13 = a1 + 24 * v18;
          v19 = 2 * v12 + 2;
          if (v19 < a3
            && std::less<std::string>::operator()[abi:ne180100](a2, (const void **)(a1 + 24 * v18), (const void **)(v13 + 24)))
          {
            v13 += 24;
            v18 = v19;
          }
          v7 = v16;
          v12 = v18;
          if (std::less<std::string>::operator()[abi:ne180100](a2, (const void **)v13, (const void **)&v20))
          {
            if (v16[1].n128_i8[7] < 0)
              operator delete((void *)v16->n128_u64[0]);
            break;
          }
        }
        result = v20;
        v16[1].n128_u64[0] = v21;
        *v16 = result;
      }
    }
  }
  return result;
}

uint64_t std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;

  v6 = 0;
  v7 = a3 - 2;
  if (a3 < 2)
    v7 = a3 - 1;
  v8 = v7 >> 1;
  do
  {
    v9 = a1 + 24 * v6 + 24;
    v10 = 2 * v6;
    v6 = (2 * v6) | 1;
    v11 = v10 + 2;
    if (v10 + 2 < a3
      && std::less<std::string>::operator()[abi:ne180100](a2, (const void **)v9, (const void **)(v9 + 24)))
    {
      v9 += 24;
      v6 = v11;
    }
    if (*(char *)(a1 + 23) < 0)
      operator delete(*(void **)a1);
    v12 = *(_OWORD *)v9;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(v9 + 16);
    *(_OWORD *)a1 = v12;
    *(_BYTE *)(v9 + 23) = 0;
    *(_BYTE *)v9 = 0;
    a1 = v9;
  }
  while (v6 <= v8);
  return v9;
}

double std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v8;
  __int128 *v9;
  __int128 *v10;
  double result;
  __int128 *v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (a4 >= 2)
  {
    v16 = v4;
    v17 = v5;
    v8 = (unint64_t)(a4 - 2) >> 1;
    v9 = (__int128 *)(a1 + 24 * v8);
    v10 = (__int128 *)(a2 - 24);
    if (std::less<std::string>::operator()[abi:ne180100](a3, (const void **)v9, (const void **)(a2 - 24)))
    {
      v14 = *v10;
      v15 = *((_QWORD *)v10 + 2);
      *((_QWORD *)v10 + 1) = 0;
      *((_QWORD *)v10 + 2) = 0;
      *(_QWORD *)v10 = 0;
      while (1)
      {
        v12 = v9;
        if (*((char *)v10 + 23) < 0)
          operator delete(*(void **)v10);
        v13 = *v9;
        *((_QWORD *)v10 + 2) = *((_QWORD *)v9 + 2);
        *v10 = v13;
        *((_BYTE *)v9 + 23) = 0;
        *(_BYTE *)v9 = 0;
        if (!v8)
          break;
        v8 = (v8 - 1) >> 1;
        v9 = (__int128 *)(a1 + 24 * v8);
        v10 = v12;
        if (!std::less<std::string>::operator()[abi:ne180100](a3, (const void **)v9, (const void **)&v14))
        {
          if (*((char *)v12 + 23) < 0)
            operator delete(*(void **)v12);
          break;
        }
      }
      result = *(double *)&v14;
      *v12 = v14;
      *((_QWORD *)v12 + 2) = v15;
    }
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<MIL::IROpset const>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v4;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[3];

  v9 = (_QWORD *)(a1 + 24);
  v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>>>::__construct_node_hash<std::string const&,std::unique_ptr<MIL::IROpset const>>(a1, v11, a3, a4, (uint64_t)v27);
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    v20 = 1;
    if (v12 >= 3)
      v20 = (v12 & (v12 - 1)) != 0;
    v21 = v20 | (2 * v12);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v23);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v27[0] = *v24;
    *v24 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v27[0])
    {
      v25 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12)
          v25 %= v12;
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v27[0];
    }
  }
  i = (unsigned __int8 *)v27[0];
  v27[0] = 0;
  ++*v9;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v27, 0);
  return i;
}

void sub_1E05CE160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>>>::__construct_node_hash<std::string const&,std::unique_ptr<MIL::IROpset const>>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  _QWORD *v10;
  std::string *v11;
  uint64_t v12;

  v9 = a1 + 16;
  v10 = operator new(0x30uLL);
  *(_QWORD *)a5 = v10;
  *(_QWORD *)(a5 + 8) = v9;
  *(_BYTE *)(a5 + 16) = 0;
  *v10 = 0;
  v10[1] = a2;
  v11 = (std::string *)(v10 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v10[4] = *(_QWORD *)(a3 + 16);
  }
  v12 = *a4;
  *a4 = 0;
  v10[5] = v12;
  *(_BYTE *)(a5 + 16) = 1;
}

void sub_1E05CE204(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<MIL::IRBlock>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

_QWORD *std::allocate_shared[abi:ne180100]<MIL::Blob::LegacyStorageReader,std::allocator<MIL::Blob::LegacyStorageReader>,std::string const&,void>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x68uLL);
  result = std::__shared_ptr_emplace<MIL::Blob::LegacyStorageReader>::__shared_ptr_emplace[abi:ne180100]<std::string const&,std::allocator<MIL::Blob::LegacyStorageReader>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1E05CE2A4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<MIL::Blob::LegacyStorageReader>::__shared_ptr_emplace[abi:ne180100]<std::string const&,std::allocator<MIL::Blob::LegacyStorageReader>,0>(_QWORD *a1, uint64_t a2)
{
  char v4;

  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_1EA999718;
  std::allocator<MIL::Blob::LegacyStorageReader>::construct[abi:ne180100]<MIL::Blob::LegacyStorageReader,std::string const&>((uint64_t)&v4, (uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1E05CE300(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::Blob::LegacyStorageReader>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA999718;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MIL::Blob::LegacyStorageReader>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA999718;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

void std::__shared_ptr_emplace<MIL::Blob::LegacyStorageReader>::__on_zero_shared(uint64_t a1)
{
  MIL::Blob::LegacyStorageReader::~LegacyStorageReader((MIL::Blob::LegacyStorageReader *)(a1 + 24));
}

void std::allocator<MIL::Blob::LegacyStorageReader>::construct[abi:ne180100]<MIL::Blob::LegacyStorageReader,std::string const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::string __p;

  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    __p = *(std::string *)a3;
  MIL::Blob::LegacyStorageReader::LegacyStorageReader(a2, (__int128 *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1E05CE3C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>>>::__emplace_unique_key_args<std::string,std::string const&,std::shared_ptr<MIL::Blob::LegacyStorageReader>&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3, std::string::size_type *a4)
{
  unint64_t v4;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[3];

  v9 = (_QWORD *)(a1 + 24);
  v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>>>::__construct_node_hash<std::string const&,std::shared_ptr<MIL::Blob::LegacyStorageReader>&>(a1, v11, a3, a4, (uint64_t)v27);
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    v20 = 1;
    if (v12 >= 3)
      v20 = (v12 & (v12 - 1)) != 0;
    v21 = v20 | (2 * v12);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v23);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v27[0] = *v24;
    *v24 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v27[0])
    {
      v25 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12)
          v25 %= v12;
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v27[0];
    }
  }
  i = (unsigned __int8 *)v27[0];
  v27[0] = 0;
  ++*v9;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v27, 0);
  return i;
}

void sub_1E05CE654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::LegacyStorageReader>>>>::__construct_node_hash<std::string const&,std::shared_ptr<MIL::Blob::LegacyStorageReader>&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, std::string::size_type *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  char *v10;
  std::string *result;

  v9 = a1 + 16;
  v10 = (char *)operator new(0x38uLL);
  *(_QWORD *)a5 = v10;
  *(_QWORD *)(a5 + 8) = v9;
  *(_BYTE *)(a5 + 16) = 0;
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = a2;
  result = std::pair<std::string const,std::shared_ptr<MIL::Blob::LegacyStorageReader>>::pair[abi:ne180100]<std::string const&,std::shared_ptr<MIL::Blob::LegacyStorageReader>&,0>((std::string *)(v10 + 16), a3, a4);
  *(_BYTE *)(a5 + 16) = 1;
  return result;
}

void sub_1E05CE6D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::shared_ptr<MIL::Blob::LegacyStorageReader>>::pair[abi:ne180100]<std::string const&,std::shared_ptr<MIL::Blob::LegacyStorageReader>&,0>(std::string *this, __int128 *a2, std::string::size_type *a3)
{
  __int128 v5;
  std::string::size_type v6;
  unint64_t *v7;
  unint64_t v8;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  v6 = a3[1];
  this[1].__r_.__value_.__r.__words[0] = *a3;
  this[1].__r_.__value_.__l.__size_ = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  return this;
}

_QWORD *std::allocate_shared[abi:ne180100]<MIL::Blob::StorageReader,std::allocator<MIL::Blob::StorageReader>,std::string const&,void>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x20uLL);
  result = std::__shared_ptr_emplace<MIL::Blob::StorageReader>::__shared_ptr_emplace[abi:ne180100]<std::string const&,std::allocator<MIL::Blob::StorageReader>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1E05CE7A4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<MIL::Blob::StorageReader>::__shared_ptr_emplace[abi:ne180100]<std::string const&,std::allocator<MIL::Blob::StorageReader>,0>(_QWORD *a1, uint64_t a2)
{
  char v4;

  a1[2] = 0;
  *a1 = &unk_1EA999768;
  a1[1] = 0;
  std::allocator<MIL::Blob::StorageReader>::construct[abi:ne180100]<MIL::Blob::StorageReader,std::string const&>((uint64_t)&v4, (uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1E05CE804(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::Blob::StorageReader>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA999768;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MIL::Blob::StorageReader>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA999768;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

void std::__shared_ptr_emplace<MIL::Blob::StorageReader>::__on_zero_shared(uint64_t a1)
{
  MIL::Blob::StorageReader::~StorageReader((void ***)(a1 + 24));
}

void std::allocator<MIL::Blob::StorageReader>::construct[abi:ne180100]<MIL::Blob::StorageReader,std::string const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::string __p;

  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    __p = *(std::string *)a3;
  MIL::Blob::StorageReader::StorageReader(a2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1E05CE8D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>>>::__emplace_unique_key_args<std::string,std::string const&,std::shared_ptr<MIL::Blob::StorageReader>&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3, std::string::size_type *a4)
{
  unint64_t v4;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD v27[3];

  v9 = (_QWORD *)(a1 + 24);
  v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>>>::__construct_node_hash<std::string const&,std::shared_ptr<MIL::Blob::StorageReader>&>(a1, v11, a3, a4, (uint64_t)v27);
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    v20 = 1;
    if (v12 >= 3)
      v20 = (v12 & (v12 - 1)) != 0;
    v21 = v20 | (2 * v12);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v23);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *(_QWORD *)v27[0] = *v24;
    *v24 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v27[0])
    {
      v25 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12)
          v25 %= v12;
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v27[0];
    }
  }
  i = (unsigned __int8 *)v27[0];
  v27[0] = 0;
  ++*v9;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v27, 0);
  return i;
}

void sub_1E05CEB60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Blob::StorageReader>>>>::__construct_node_hash<std::string const&,std::shared_ptr<MIL::Blob::StorageReader>&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, std::string::size_type *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  char *v10;
  std::string *result;

  v9 = a1 + 16;
  v10 = (char *)operator new(0x38uLL);
  *(_QWORD *)a5 = v10;
  *(_QWORD *)(a5 + 8) = v9;
  *(_BYTE *)(a5 + 16) = 0;
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = a2;
  result = std::pair<std::string const,std::shared_ptr<MIL::Blob::LegacyStorageReader>>::pair[abi:ne180100]<std::string const&,std::shared_ptr<MIL::Blob::LegacyStorageReader>&,0>((std::string *)(v10 + 16), a3, a4);
  *(_BYTE *)(a5 + 16) = 1;
  return result;
}

void sub_1E05CEBE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(MIL::Transform::ProgramTransformer &)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

MIL::MILContextImpl *MIL::MILContextImpl::MILContextImpl(MIL::MILContextImpl *this)
{
  *(_QWORD *)this = &off_1EA999688;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 1065353216;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 30) = 1065353216;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((_DWORD *)this + 50) = 1065353216;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_DWORD *)this + 60) = 1065353216;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((_DWORD *)this + 70) = 1065353216;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_DWORD *)this + 80) = 1065353216;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((_DWORD *)this + 90) = 1065353216;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_DWORD *)this + 100) = 1065353216;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *((_DWORD *)this + 110) = 1065353216;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *((_DWORD *)this + 120) = 1065353216;
  *(_OWORD *)((char *)this + 504) = 0u;
  *((_DWORD *)this + 130) = 1065353216;
  *((_OWORD *)this + 33) = 0u;
  *((_OWORD *)this + 34) = 0u;
  *((_DWORD *)this + 140) = 1065353216;
  *(_OWORD *)((char *)this + 568) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  *((_DWORD *)this + 150) = 1065353216;
  MIL::Conversion::OpConversion::Make((_QWORD *)this + 76);
  MIL::IRUnknownDimension::Make(0, (_QWORD *)this + 77);
  MIL::IRUnknownDimension::Make((MIL::IRUnknownDimension *)1, (_QWORD *)this + 78);
  MIL::IRUnknownProperty::Make(0, (_QWORD *)this + 79);
  MIL::IRUnknownProperty::Make((MIL::IRUnknownProperty *)1, (_QWORD *)this + 80);
  return this;
}

void sub_1E05CEE0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v28 = *v26;
  *v26 = 0;
  if (v28)
    (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
  v29 = *v24;
  *v24 = 0;
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
  v30 = *v22;
  *v22 = 0;
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  v31 = *v21;
  *v21 = 0;
  if (v31)
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
  std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<MIL::IROpset const>>>>::~__hash_table(v23 + 320);
  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table(a10);
  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRCircularBufferValueType const>>>>::~__hash_table(v20);
  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>,std::equal_to<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRPixelFormatType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRPixelBufferValueType const>>>>::~__hash_table(v19);
  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*>>,std::shared_ptr<std::vector<MIL::IRProperty const*>>,MIL::IRProperty const*,std::shared_ptr<std::vector<MIL::IRProperty const*>>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorBufferValueType const>>>>::~__hash_table(v18);
  std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>>>::~__hash_table(a11);
  std::__hash_table<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::__unordered_map_hasher<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::__unordered_map_equal<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>,std::equal_to<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,std::hash<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>>,true>,std::allocator<std::__hash_value_type<std::pair<MIL::IRValueType const*,MIL::IRValueType const*>,std::unique_ptr<MIL::IRDictionaryValueType const>>>>::~__hash_table(v25);
  std::__hash_table<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::__unordered_map_hasher<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::__unordered_map_equal<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>,std::equal_to<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,std::hash<std::shared_ptr<std::vector<MIL::IRValueType const*>>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<std::vector<MIL::IRValueType const*>>,std::unique_ptr<MIL::IRTupleValueType const>>>>::~__hash_table(a12);
  std::__hash_table<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::__unordered_map_hasher<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::__unordered_map_equal<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>,std::equal_to<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,std::hash<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>>,true>,std::allocator<std::__hash_value_type<std::tuple<MIL::IRDataType,std::shared_ptr<std::vector<MIL::IRDimension const*> const>,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>,std::unique_ptr<MIL::IRTensorValueType const>>>>::~__hash_table(v23);
  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table(a13);
  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table(a14);
  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table(a15);
  std::__hash_table<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::__unordered_map_hasher<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,true>,std::__unordered_map_equal<MIL::IRValueType const*,std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>,std::equal_to<MIL::IRValueType const*>,std::hash<MIL::IRValueType const*>,true>,std::allocator<std::__hash_value_type<MIL::IRValueType const*,std::unique_ptr<MIL::IRStateValueType const>>>>::~__hash_table(a16);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a17);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(a18);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<std::vector<MIL::IRValueType const*>>::shared_ptr[abi:ne180100]<std::vector<MIL::IRValueType const*>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1EA9997B8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1E05CEF70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  a10 = 0;
  if (v10)
    std::default_delete<std::vector<MIL::IRDimension const*>>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<std::vector<MIL::IRValueType const*> *,std::shared_ptr<std::vector<MIL::IRValueType const*>>::__shared_ptr_default_delete<std::vector<MIL::IRValueType const*>,std::vector<MIL::IRValueType const*>>,std::allocator<std::vector<MIL::IRValueType const*>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

void std::__shared_ptr_pointer<std::vector<MIL::IRValueType const*> *,std::shared_ptr<std::vector<MIL::IRValueType const*>>::__shared_ptr_default_delete<std::vector<MIL::IRValueType const*>,std::vector<MIL::IRValueType const*>>,std::allocator<std::vector<MIL::IRValueType const*>>>::__on_zero_shared(uint64_t a1)
{
  std::default_delete<std::vector<MIL::IRDimension const*>>::operator()[abi:ne180100](a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<std::vector<MIL::IRValueType const*> *,std::shared_ptr<std::vector<MIL::IRValueType const*>>::__shared_ptr_default_delete<std::vector<MIL::IRValueType const*>,std::vector<MIL::IRValueType const*>>,std::allocator<std::vector<MIL::IRValueType const*>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void MIL::Attributes::BlobFileMutabilityInfo::~BlobFileMutabilityInfo(MIL::Attributes::BlobFileMutabilityInfo *this)
{
  std::unique_ptr<MIL::Attributes::BlobFileMutabilityInfo::Impl>::reset[abi:ne180100]((uint64_t *)this, 0);
}

{
  std::unique_ptr<MIL::Attributes::BlobFileMutabilityInfo::Impl>::reset[abi:ne180100]((uint64_t *)this, 0);
}

_QWORD *MIL::Attributes::BlobFileMutabilityInfo::BlobFileMutabilityInfo(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = v2;
  return result;
}

_QWORD *MIL::Attributes::BlobFileMutabilityInfo::Make@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v3;
  _QWORD *result;

  v3 = operator new();
  *(_QWORD *)(v3 + 32) = 0;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_DWORD *)(v3 + 32) = 1065353216;
  result = (_QWORD *)operator new();
  *result = v3;
  *a1 = result;
  return result;
}

void sub_1E05CF0E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<MIL::Attributes::BlobFileMutabilityInfo::Impl>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t MIL::Attributes::BlobFileMutabilityInfo::Make@<X0>(MIL::Attributes::BlobFileMutabilityInfo *this@<X0>, _QWORD *a2@<X8>)
{
  MIL::IRTupleValue *v4;
  uint64_t v5;
  const void **v6;
  std::string::size_type size;
  std::string *v8;
  int data;
  int v10;
  MIL::IRValue **v12;
  MIL::IRDictionaryValue *v13;
  uint64_t i;
  unsigned __int8 *v15;
  uint64_t v16;
  std::string::size_type v17;
  __int128 v18;
  unint64_t v19;
  _QWORD *v20;
  std::runtime_error *exception;
  std::string *v23;
  __int128 v24;
  std::string v25;
  _QWORD v26[2];
  __int128 v27;
  __int128 v28;
  int v29;
  std::string __str;
  std::string __p;
  std::string *p_p;
  _BYTE v33[32];
  int v34;

  v27 = 0u;
  v28 = 0u;
  v29 = 1065353216;
  v4 = (MIL::IRTupleValue *)MIL::IRValue::AsTuple(this);
  v26[0] = MIL::IRTupleValue::GetValues(v4);
  v26[1] = v5;
  v6 = (const void **)MIL::Util::Span<std::shared_ptr<MIL::IRValue const> const,18446744073709551615ul>::At(v26, 0);
  MIL::IRValue::GetScalar<std::string>(*v6, &v25);
  size = HIBYTE(v25.__r_.__value_.__r.__words[2]);
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v25.__r_.__value_.__l.__size_;
  if (size != 5)
    goto LABEL_27;
  v8 = &v25;
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v8 = (std::string *)v25.__r_.__value_.__r.__words[0];
  data = (int)v8->__r_.__value_.__l.__data_;
  v10 = v8->__r_.__value_.__s.__data_[4];
  if (data != 1752457552 || v10 != 115)
  {
LABEL_27:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    v23 = std::string::append(&__p, "'.");
    v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    *(_QWORD *)&v33[16] = *((_QWORD *)&v23->__r_.__value_.__l + 2);
    *(_OWORD *)v33 = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, (const std::string *)v33);
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], (void (*)(void *))MEMORY[0x1E0DE4338]);
  }
  v12 = (MIL::IRValue **)MIL::Util::Span<std::shared_ptr<MIL::IRValue const> const,18446744073709551615ul>::At(v26, 1uLL);
  v13 = (MIL::IRDictionaryValue *)MIL::IRValue::AsDictionary(*v12);
  memset(v33, 0, sizeof(v33));
  v34 = 1065353216;
  for (i = MIL::IRDictionaryValue::begin(v13); i != MIL::IRDictionaryValue::end(v13); i = *(_QWORD *)i)
  {
    MIL::IRValue::GetScalar<std::string>(*(const void **)(i + 16), &__p);
    MIL::IRValue::GetScalar<std::string>(*(const void **)(i + 32), &__str);
    p_p = &__p;
    v15 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v33, (unsigned __int8 *)&__p, (uint64_t)&std::piecewise_construct, (__int128 **)&p_p);
    std::string::operator=((std::string *)(v15 + 40), &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__move_assign((uint64_t)&v27, (uint64_t *)v33);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v33);
  v16 = operator new();
  v17 = v16;
  v18 = v27;
  v27 = 0uLL;
  *(_OWORD *)v33 = v18;
  *(_OWORD *)&v33[16] = v28;
  v34 = v29;
  if (*((_QWORD *)&v28 + 1))
  {
    v19 = *(_QWORD *)(v28 + 8);
    if ((*((_QWORD *)&v18 + 1) & (*((_QWORD *)&v18 + 1) - 1)) != 0)
    {
      if (v19 >= *((_QWORD *)&v18 + 1))
        v19 %= *((_QWORD *)&v18 + 1);
    }
    else
    {
      v19 &= *((_QWORD *)&v18 + 1) - 1;
    }
    *(_QWORD *)(v18 + 8 * v19) = &v33[16];
    v28 = 0uLL;
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(v16, (uint64_t *)v33);
  __p.__r_.__value_.__r.__words[0] = v17;
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v33);
  v20 = (_QWORD *)operator new();
  *v20 = v17;
  *a2 = v20;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v25.__r_.__value_.__l.__data_);
  return std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&v27);
}

void sub_1E05CF3C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  void *v35;
  int v36;
  uint64_t v37;

  if (*(char *)(v37 - 73) < 0)
    operator delete(*(void **)(v37 - 96));
  if (a35 < 0)
  {
    operator delete(__p);
    if ((v36 & 1) == 0)
    {
LABEL_8:
      if (a15 < 0)
        operator delete(a10);
      std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a18);
      _Unwind_Resume(a1);
    }
  }
  else if (!v36)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v35);
  goto LABEL_8;
}

uint64_t MIL::Util::Span<std::shared_ptr<MIL::IRValue const> const,18446744073709551615ul>::At(_QWORD *a1, unint64_t a2)
{
  std::runtime_error *exception;

  if (a1[1] <= a2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "index out of bounds");
    __cxa_throw(exception, (struct type_info *)off_1EA992578, MEMORY[0x1E0DE42B0]);
  }
  return *a1 + 16 * a2;
}

void sub_1E05CF50C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *MIL::Attributes::BlobFileMutabilityInfo::Make@<X0>(MIL::Attributes::BlobFileMutabilityInfo *this@<X0>, _QWORD *a2@<X8>)
{
  MIL::Attributes::BlobFileMutabilityInfo *Attribute;
  void *__p[2];
  char v8;

  std::string::basic_string[abi:ne180100]<0>(__p, "BlobFileMutabilityInfo");
  Attribute = (MIL::Attributes::BlobFileMutabilityInfo *)MIL::IRObject::TryGetAttribute((uint64_t)this, (unsigned __int8 *)__p);
  if (v8 < 0)
    operator delete(__p[0]);
  if (Attribute)
    return (_QWORD *)MIL::Attributes::BlobFileMutabilityInfo::Make(Attribute, a2);
  else
    return MIL::Attributes::BlobFileMutabilityInfo::Make(a2);
}

void sub_1E05CF590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Attributes::BlobFileMutabilityInfo::GetValue@<X0>(MIL::Attributes::BlobFileMutabilityInfo *this@<X0>, void (***a2)(MIL::MILContextImpl *__hidden this)@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5;
  const MIL::IRValueType *v6;
  _anonymous_namespace_ *Scalar;
  uint64_t *i;
  std::__shared_weak_count *v9;
  std::__shared_weak_count_vtbl *v10;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  void **v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count_vtbl *v21;
  _QWORD *v22;
  MIL::IRDictionaryValue *v23;
  void **v24;
  uint64_t v25;
  __int128 v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t j;
  MIL::IRDictionaryValue *v30;
  std::__shared_weak_count *v31;
  MIL::IRDictionaryValue *v33;
  void *__p[2];
  char v35;
  void **v36;
  void **v37;
  _OWORD *v38;
  std::string v39;
  std::__shared_weak_count *v40;
  std::string v41;
  _OWORD v42[2];
  int v43;
  void ***v44;
  char v45;
  std::__shared_weak_count *v46;
  std::__shared_weak_count *v47;
  MIL::IRDictionaryValue *v48;
  _QWORD *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)this;
  Scalar = (_anonymous_namespace_ *)MIL::IRTensorValueType::MakeScalar(a2, 3);
  memset(v42, 0, sizeof(v42));
  v43 = 1065353216;
  for (i = *(uint64_t **)(v5 + 16); i; i = (uint64_t *)*i)
  {
    if (*((char *)i + 63) < 0)
      std::string::__init_copy_ctor_external(&v41, (const std::string::value_type *)i[5], i[6]);
    else
      v41 = *(std::string *)(i + 5);
    MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)&v41, &v44);
    if (*((char *)i + 39) < 0)
      std::string::__init_copy_ctor_external(&v39, (const std::string::value_type *)i[2], i[3]);
    else
      v39 = *(std::string *)(i + 2);
    MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)&v39, &v40);
    v46 = v40;
    if (v40)
    {
      v9 = (std::__shared_weak_count *)operator new();
      v10 = (std::__shared_weak_count_vtbl *)v40;
      v9->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA992A68;
      v9->__shared_owners_ = 0;
      v9->__shared_weak_owners_ = 0;
      v9[1].__vftable = v10;
    }
    else
    {
      v9 = 0;
    }
    v47 = v9;
    v40 = 0;
    v36 = (void **)&v46;
    v11 = std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::shared_ptr<MIL::IRValue const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::IRValue const>&&>,std::tuple<>>((uint64_t)v42, &v46, (uint64_t)&std::piecewise_construct, (_OWORD **)&v36);
    std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>(v11 + 4, (uint64_t *)&v44);
    v12 = v47;
    if (v47)
    {
      p_shared_owners = (unint64_t *)&v47->__shared_owners_;
      do
        v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    v15 = v40;
    v40 = 0;
    if (v15)
      ((void (*)(std::__shared_weak_count *))v15->~__shared_weak_count_0)(v15);
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v39.__r_.__value_.__l.__data_);
    v16 = (void **)v44;
    v44 = 0;
    if (v16)
      (*((void (**)(void **))*v16 + 1))(v16);
    if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v41.__r_.__value_.__l.__data_);
  }
  v17 = MIL::IRDictionaryValueType::Make(a2, Scalar, Scalar, v6);
  v18 = operator new(0x10uLL);
  v47 = (std::__shared_weak_count *)(v18 + 2);
  v48 = (MIL::IRDictionaryValue *)(v18 + 2);
  *v18 = Scalar;
  v18[1] = v17;
  v46 = (std::__shared_weak_count *)v18;
  v19 = MIL::IRTupleValueType::Make(a2, (uint64_t)&v46);
  if (v46)
  {
    v47 = v46;
    operator delete(v46);
  }
  v35 = 5;
  strcpy((char *)__p, "Paths");
  MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)__p, &v40);
  v46 = v40;
  if (v40)
  {
    v20 = (std::__shared_weak_count *)operator new();
    v21 = (std::__shared_weak_count_vtbl *)v40;
    v20->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EA992A68;
    v20->__shared_owners_ = 0;
    v20->__shared_weak_owners_ = 0;
    v20[1].__vftable = v21;
  }
  else
  {
    v20 = 0;
  }
  v47 = v20;
  v40 = 0;
  MIL::IRDictionaryValueType::MakeValue(v17, (uint64_t)v42, (uint64_t *)&v33);
  v48 = v33;
  if (v33)
  {
    v22 = (_QWORD *)operator new();
    v23 = v33;
    *v22 = &unk_1EA999830;
    v22[1] = 0;
    v22[2] = 0;
    v22[3] = v23;
  }
  else
  {
    v22 = 0;
  }
  v49 = v22;
  v33 = 0;
  v37 = 0;
  v38 = 0;
  v36 = 0;
  v44 = &v36;
  v45 = 0;
  v24 = (void **)operator new(0x20uLL);
  v25 = 0;
  v36 = v24;
  v37 = v24;
  v38 = v24 + 4;
  do
  {
    v26 = *((_OWORD *)&v46 + v25);
    *(_OWORD *)v24 = v26;
    if (*((_QWORD *)&v26 + 1))
    {
      v27 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
      do
        v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
    }
    ++v25;
    v24 += 2;
  }
  while (v25 != 2);
  v37 = v24;
  MIL::IRTupleValueType::MakeValue(v19, (uint64_t)&v36, a3);
  v44 = &v36;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v44);
  for (j = 16; j != -16; j -= 16)
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&v46 + j);
  v30 = v33;
  v33 = 0;
  if (v30)
  {
    MIL::IRDictionaryValue::~IRDictionaryValue(v30);
    MEMORY[0x1E0C023A0]();
  }
  v31 = v40;
  v40 = 0;
  if (v31)
    ((void (*)(std::__shared_weak_count *))v31->~__shared_weak_count_0)(v31);
  if (v35 < 0)
    operator delete(__p[0]);
  return std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v42);
}

void sub_1E05CF9EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, MIL::IRDictionaryValue *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,char a34)
{
  uint64_t v34;
  uint64_t v36;
  uint64_t v37;

  std::unique_ptr<MIL::IRDictionaryValue const>::reset[abi:ne180100](&a10, 0);
  v36 = v34 - 104;
  v37 = a26;
  a26 = 0;
  if (v37)
    (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
  if (a16 < 0)
    operator delete(__p);
  while (v36 != v34 - 120)
  {
    v36 -= 16;
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v36);
  }
  std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a34);
  _Unwind_Resume(a1);
}

std::string *MIL::Attributes::BlobFileMutabilityInfo::AddPath(uint64_t *a1, __int128 *a2, const std::string *a3)
{
  uint64_t v4;
  unsigned __int8 *v5;
  __int128 *v7;

  v4 = *a1;
  v7 = a2;
  v5 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v4, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, &v7);
  return std::string::operator=((std::string *)(v5 + 40), a3);
}

void MIL::Attributes::BlobFileMutabilityInfo::GetPath(_QWORD **a1@<X0>, unsigned __int8 *a2@<X1>, std::string *a3@<X8>)
{
  MIL::Attributes::BlobFileMutabilityInfo::Impl::GetPath(*a1, a2, a3);
}

void MIL::Attributes::BlobFileMutabilityInfo::Impl::GetPath(_QWORD *a1@<X0>, unsigned __int8 *a2@<X1>, std::string *a3@<X8>)
{
  unsigned __int8 *v4;
  __int128 v5;

  v4 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a1, a2);
  if (v4)
  {
    if ((char)v4[63] < 0)
    {
      std::string::__init_copy_ctor_external(a3, *((const std::string::value_type **)v4 + 5), *((_QWORD *)v4 + 6));
    }
    else
    {
      v5 = *(_OWORD *)(v4 + 40);
      a3->__r_.__value_.__r.__words[2] = *((_QWORD *)v4 + 7);
      *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v5;
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(a3, "");
  }
}

uint64_t MIL::Attributes::BlobFileMutabilityInfo::GetAllPaths(MIL::Attributes::BlobFileMutabilityInfo *this)
{
  return *(_QWORD *)this;
}

unsigned __int8 *MIL::Attributes::BlobFileMutabilityInfo::RemovePath(_QWORD **a1, unsigned __int8 *a2)
{
  return std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__erase_unique<std::string>(*a1, a2);
}

void MIL::Attributes::BlobFileMutabilityInfo::Clear(MIL::Attributes::BlobFileMutabilityInfo *this)
{
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::clear(*(_QWORD *)this);
}

void MIL::Attributes::BlobFileMutabilityInfo::ReplaceModelPaths(uint64_t a1, _QWORD *a2)
{
  uint64_t *i;

  for (i = *(uint64_t **)(*(_QWORD *)a1 + 16); i; i = (uint64_t *)*i)
    MIL::Util::ReplaceModelPaths((std::string *)(i + 5), a2);
}

void MIL::Attributes::BlobFileMutabilityInfo::ApplyModelPath(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *i;

  for (i = *(_QWORD **)(*(_QWORD *)a1 + 16); i; i = (_QWORD *)*i)
    MIL::Util::ApplyModelPath((uint64_t)(i + 5), a2, a3);
}

void MIL::Attributes::BlobFileMutabilityInfo::Replace(MIL::Attributes::BlobFileMutabilityInfo *this, MIL::IRProgram *a2)
{
  uint64_t v4;
  uint64_t v5;
  void (***v6)(MIL::MILContextImpl *__hidden);
  _QWORD *v7;
  MIL::IRTupleValue *v8;
  MIL::IRTupleValue *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  MIL::IRTupleValue *v13;
  uint64_t v14;
  __int128 v15;
  void *__p[2];
  char v17;
  MIL::IRTupleValue *v18[2];
  char v19;

  v4 = *(_QWORD *)this;
  v5 = (*(uint64_t (**)(MIL::IRProgram *))(*(_QWORD *)a2 + 40))(a2);
  if (!*(_QWORD *)(v4 + 24))
  {
    std::string::basic_string[abi:ne180100]<0>(v18, "BlobFileMutabilityInfo");
    MIL::IRObject::RemoveAttribute((uint64_t)a2, (unsigned __int8 *)v18);
    if ((v19 & 0x80000000) == 0)
      return;
    v9 = v18[0];
    goto LABEL_16;
  }
  v6 = (void (***)(MIL::MILContextImpl *__hidden))v5;
  std::string::basic_string[abi:ne180100]<0>(__p, "BlobFileMutabilityInfo");
  MIL::Attributes::BlobFileMutabilityInfo::GetValue(this, v6, (uint64_t *)v18);
  *(MIL::IRTupleValue **)&v15 = v18[0];
  if (v18[0])
  {
    v7 = (_QWORD *)operator new();
    v8 = v18[0];
    *v7 = &unk_1EA999890;
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = v8;
  }
  else
  {
    v7 = 0;
  }
  *((_QWORD *)&v15 + 1) = v7;
  v18[0] = 0;
  MIL::IRObject::SetAttribute((uint64_t)a2, (unsigned __int8 *)__p, &v15);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
  if (*((_QWORD *)&v15 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v18[0];
  v18[0] = 0;
  if (v13)
  {
    MIL::IRTupleValue::~IRTupleValue(v13);
    MEMORY[0x1E0C023A0](v14);
  }
  if (v17 < 0)
  {
    v9 = (MIL::IRTupleValue *)__p[0];
LABEL_16:
    operator delete(v9);
  }
}

void sub_1E05CFE38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::Attributes::BlobFileMutabilityInfo::Rewrite(MIL::Attributes::BlobFileMutabilityInfo *this@<X0>, const MIL::IRProgram *a2@<X1>, MIL::IRProgram **a3@<X8>)
{
  (*(void (**)(MIL::IRProgram **__return_ptr, const MIL::IRProgram *))(*(_QWORD *)a2 + 32))(a3, a2);
  MIL::Attributes::BlobFileMutabilityInfo::Replace(this, *a3);
}

void sub_1E05CFECC(_Unwind_Exception *exception_object)
{
  uint64_t *v1;
  uint64_t v3;

  v3 = *v1;
  *v1 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Attributes::BlobFileMutabilityInfo::operator==(uint64_t *a1, _QWORD **a2)
{
  return std::operator==[abi:ne180100]<std::string,std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::pair<std::string const,std::string>>>(*a1, *a2);
}

std::string *MIL::Attributes::BlobFileMutabilityInfo::UpdateMutabilityPaths(std::string **a1, uint64_t a2, std::string *a3)
{
  return MIL::Attributes::BlobFileMutabilityInfo::Impl::UpdateMutabilityPaths(*a1, a2, a3);
}

std::string *MIL::Attributes::BlobFileMutabilityInfo::Impl::UpdateMutabilityPaths(std::string *result, uint64_t a2, std::string *__str)
{
  uint64_t *v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;

  v3 = (uint64_t *)result->__r_.__value_.__r.__words[2];
  if (v3)
  {
    while (1)
    {
      v6 = *((unsigned __int8 *)v3 + 63);
      if ((v6 & 0x80u) == 0)
        v7 = *((unsigned __int8 *)v3 + 63);
      else
        v7 = v3[6];
      v8 = *(unsigned __int8 *)(a2 + 23);
      v9 = (char)v8;
      if ((v8 & 0x80u) != 0)
        v8 = *(_QWORD *)(a2 + 8);
      if (v7 != v8)
        goto LABEL_19;
      v10 = v9 >= 0 ? (unsigned __int8 *)a2 : *(unsigned __int8 **)a2;
      if ((v6 & 0x80) == 0)
        break;
      result = (std::string *)memcmp((const void *)v3[5], v10, v3[6]);
      if (!(_DWORD)result)
        goto LABEL_18;
LABEL_19:
      v3 = (uint64_t *)*v3;
      if (!v3)
        return result;
    }
    if (*((_BYTE *)v3 + 63))
    {
      v11 = (unsigned __int8 *)(v3 + 5);
      while (*v11 == *v10)
      {
        ++v11;
        ++v10;
        if (!--v6)
          goto LABEL_18;
      }
      goto LABEL_19;
    }
LABEL_18:
    result = std::string::operator=((std::string *)(v3 + 5), __str);
    goto LABEL_19;
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_1E05D0244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;
  __int128 *v10;
  __int128 v11;

  v7 = a1 + 16;
  v8 = operator new(0x40uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
  }
  else
  {
    v11 = *v10;
    v8[4] = *((_QWORD *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  v8[5] = 0;
  v8[6] = 0;
  v8[7] = 0;
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_1E05D02E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__erase_unique<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  unsigned __int8 *result;
  _BYTE v4[24];

  result = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::remove(a1, result, (uint64_t)v4);
    std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v4, 0);
    return (unsigned __int8 *)1;
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t std::operator==[abi:ne180100]<std::string,std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::pair<std::string const,std::string>>>(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  const void **v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  const void **v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;

  if (*(_QWORD *)(a1 + 24) != a2[3])
    return 0;
  v2 = *(uint64_t **)(a1 + 16);
  if (!v2)
    return 1;
  do
  {
    v4 = (const void **)(v2 + 2);
    result = (uint64_t)std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a2, (unsigned __int8 *)v2 + 16);
    if (!result)
      break;
    v6 = result;
    v7 = *((unsigned __int8 *)v2 + 39);
    if ((v7 & 0x80u) == 0)
      v8 = *((unsigned __int8 *)v2 + 39);
    else
      v8 = v2[3];
    v9 = *(unsigned __int8 *)(result + 39);
    v10 = (char)v9;
    if ((v9 & 0x80u) != 0)
      v9 = *(_QWORD *)(result + 24);
    if (v8 != v9)
      return 0;
    if (v10 >= 0)
      v11 = (unsigned __int8 *)(result + 16);
    else
      v11 = *(unsigned __int8 **)(result + 16);
    if ((v7 & 0x80) != 0)
    {
      if (memcmp(*v4, v11, v2[3]))
        return 0;
    }
    else if (*((_BYTE *)v2 + 39))
    {
      while (*(unsigned __int8 *)v4 == *v11)
      {
        v4 = (const void **)((char *)v4 + 1);
        ++v11;
        if (!--v7)
          goto LABEL_19;
      }
      return 0;
    }
LABEL_19:
    v12 = *((unsigned __int8 *)v2 + 63);
    if ((v12 & 0x80u) == 0)
      v13 = *((unsigned __int8 *)v2 + 63);
    else
      v13 = v2[6];
    v14 = *(unsigned __int8 *)(v6 + 63);
    v15 = (char)v14;
    if ((v14 & 0x80u) != 0)
      v14 = *(_QWORD *)(v6 + 48);
    if (v13 != v14)
      return 0;
    v16 = (const void **)(v2 + 5);
    v19 = *(unsigned __int8 **)(v6 + 40);
    v18 = (unsigned __int8 *)(v6 + 40);
    v17 = v19;
    if (v15 >= 0)
      v20 = v18;
    else
      v20 = v17;
    if ((v12 & 0x80) != 0)
    {
      if (memcmp(*v16, v20, v2[6]))
        return 0;
    }
    else if (*((_BYTE *)v2 + 63))
    {
      while (*(unsigned __int8 *)v16 == *v20)
      {
        v16 = (const void **)((char *)v16 + 1);
        ++v20;
        if (!--v12)
          goto LABEL_34;
      }
      return 0;
    }
LABEL_34:
    v2 = (uint64_t *)*v2;
    result = 1;
  }
  while (v2);
  return result;
}

uint64_t std::unique_ptr<MIL::Attributes::BlobFileMutabilityInfo::Impl>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(result);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::clear(a1);
  v4 = *a2;
  *a2 = 0;
  v5 = *(void **)a1;
  *(_QWORD *)a1 = v4;
  if (v5)
    operator delete(v5);
  v8 = a2[2];
  v7 = a2 + 2;
  v6 = v8;
  v9 = *(v7 - 1);
  *(_QWORD *)(a1 + 16) = v8;
  *(_QWORD *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  v10 = v7[1];
  *(_QWORD *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    v11 = *(_QWORD *)(v6 + 8);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v11 %= v12;
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v11) = a1 + 16;
    *v7 = 0;
    v7[1] = 0;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::shared_ptr<MIL::IRValue const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::IRValue const>&&>,std::tuple<>>(uint64_t a1, _QWORD *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  _QWORD **v14;
  _QWORD *i;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  float v19;
  float v20;
  _BOOL8 v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;

  v8 = (_QWORD *)(a1 + 24);
  v9 = MIL::IRValueMapHasher::operator()(a1 + 24, a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = (_QWORD *)*i)
      {
        v16 = i[1];
        if (v16 == v10)
        {
          if (MIL::IRValueMapEq::operator()(a1 + 32, i + 2, a2))
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  v17 = (_QWORD *)(a1 + 16);
  i = operator new(0x30uLL);
  *i = 0;
  i[1] = v10;
  v18 = *a4;
  *((_OWORD *)i + 1) = **a4;
  *v18 = 0;
  v18[1] = 0;
  i[4] = 0;
  i[5] = 0;
  v19 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v20 = *(float *)(a1 + 32);
  if (!v11 || (float)(v20 * (float)v11) < v19)
  {
    v21 = 1;
    if (v11 >= 3)
      v21 = (v11 & (v11 - 1)) != 0;
    v22 = v21 | (2 * v11);
    v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23)
      v24 = v23;
    else
      v24 = v22;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v24);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v25 = *(_QWORD *)a1;
  v26 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v26)
  {
    *i = *v26;
LABEL_38:
    *v26 = i;
    goto LABEL_39;
  }
  *i = *v17;
  *v17 = i;
  *(_QWORD *)(v25 + 8 * v4) = v17;
  if (*i)
  {
    v27 = *(_QWORD *)(*i + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v27 >= v11)
        v27 %= v11;
    }
    else
    {
      v27 &= v11 - 1;
    }
    v26 = (_QWORD *)(*(_QWORD *)a1 + 8 * v27);
    goto LABEL_38;
  }
LABEL_39:
  ++*v8;
  return i;
}

void sub_1E05D0838(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)__p + 32);
    std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)__p + 16);
  }
  if (__p)
    operator delete(__p);
}

MIL::IRDictionaryValue *std::unique_ptr<MIL::IRDictionaryValue const>::reset[abi:ne180100](MIL::IRDictionaryValue **a1, MIL::IRDictionaryValue *a2)
{
  MIL::IRDictionaryValue *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    MIL::IRDictionaryValue::~IRDictionaryValue(result);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

void std::__shared_ptr_pointer<MIL::IRDictionaryValue const *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

MIL::IRDictionaryValue *std::__shared_ptr_pointer<MIL::IRDictionaryValue const *>::__on_zero_shared(uint64_t a1)
{
  MIL::IRDictionaryValue *result;

  result = *(MIL::IRDictionaryValue **)(a1 + 24);
  if (result)
  {
    MIL::IRDictionaryValue::~IRDictionaryValue(result);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IRDictionaryValue const *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

MIL::IRTupleValue *std::unique_ptr<MIL::IRTupleValue const>::reset[abi:ne180100](MIL::IRTupleValue **a1, MIL::IRTupleValue *a2)
{
  MIL::IRTupleValue *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    MIL::IRTupleValue::~IRTupleValue(result);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

void std::__shared_ptr_pointer<MIL::IRTupleValue const *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

MIL::IRTupleValue *std::__shared_ptr_pointer<MIL::IRTupleValue const *>::__on_zero_shared(uint64_t a1)
{
  MIL::IRTupleValue *result;

  result = *(MIL::IRTupleValue **)(a1 + 24);
  if (result)
  {
    MIL::IRTupleValue::~IRTupleValue(result);
    JUMPOUT(0x1E0C023A0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::IRTupleValue const *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *MIL::Attributes::ModelInfoToString@<X0>(void *result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  int *v4;
  size_t v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  v3 = 0;
  {
    v3 += 6;
    if (v3 == 30)
      goto LABEL_6;
  }
LABEL_6:
  v5 = *((_QWORD *)v4 + 2);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = (const void *)*((_QWORD *)v4 + 1);
  if (v5 >= 0x17)
  {
    v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v7 = v5 | 7;
    v8 = v7 + 1;
    v9 = operator new(v7 + 1);
    a2[1] = v5;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((_BYTE *)a2 + 23) = v5;
    if (!v5)
      goto LABEL_14;
  }
  result = memmove(a2, v6, v5);
LABEL_14:
  *((_BYTE *)a2 + v5) = 0;
  return result;
}

void MIL::Attributes::BuildInfo::~BuildInfo(MIL::Attributes::BuildInfo *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v1)
    std::default_delete<MIL::Attributes::BuildInfo::Impl>::operator()[abi:ne180100]((uint64_t)this, v1);
}

{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v1)
    std::default_delete<MIL::Attributes::BuildInfo::Impl>::operator()[abi:ne180100]((uint64_t)this, v1);
}

_QWORD *MIL::Attributes::BuildInfo::BuildInfo(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = v2;
  return result;
}

_QWORD *MIL::Attributes::BuildInfo::Make@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v3;
  _QWORD *result;

  v3 = operator new();
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_QWORD *)(v3 + 128) = 0;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 112) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_QWORD *)(v3 + 72) = v3 + 80;
  *(_DWORD *)(v3 + 128) = 1065353216;
  result = (_QWORD *)operator new();
  *result = v3;
  *a1 = result;
  return result;
}

void sub_1E05D0C30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  a10 = 0;
  std::default_delete<MIL::Attributes::BuildInfo::Impl>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  _Unwind_Resume(a1);
}

void MIL::Attributes::BuildInfo::Make(MIL::Attributes::BuildInfo *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t Attribute;
  uint64_t v5;
  MIL::IRDictionaryValue *v6;
  MIL::IRDictionaryValue *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  std::string::size_type v11;
  std::string::size_type size;
  std::string *v13;
  std::string::size_type v15;
  int v16;
  std::string *v18;
  std::string::size_type v19;
  uint64_t v20;
  unsigned __int8 *v22;
  void **v23;
  char v24;
  std::string::value_type *v25;
  void *v26;
  std::string::value_type *v27;
  std::string::size_type v28;
  char v29;
  char v30;
  int v31;
  uint64_t v32;
  std::string::size_type v33;
  char v34;
  std::string::size_type v35;
  __int128 v36;
  char v37;
  _QWORD *v38;
  _QWORD *v39;
  std::string::size_type v40;
  void *v41;
  char v42;
  std::string::size_type __sz;
  void *v44;
  void *v45;
  char v46;
  std::string v47;
  std::string v48;
  std::string v49;
  void *__p[2];
  __int128 v51;
  int v52;
  _DWORD v53[2];
  _DWORD v54[2];
  _DWORD v55[6];

  BYTE7(v51) = 9;
  strcpy((char *)__p, "buildInfo");
  Attribute = MIL::IRObject::TryGetAttribute((uint64_t)this, (unsigned __int8 *)__p);
  v5 = Attribute;
  if (SBYTE7(v51) < 0)
  {
    operator delete(__p[0]);
    if (!v5)
    {
LABEL_47:
      MIL::Attributes::BuildInfo::Make(a2);
      return;
    }
  }
  else if (!Attribute)
  {
    goto LABEL_47;
  }
  v6 = (MIL::IRDictionaryValue *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 64))(v5);
  if (!v6)
    goto LABEL_47;
  v7 = v6;
  *(_DWORD *)((char *)v55 + 3) = 0;
  v55[0] = 0;
  *(_DWORD *)((char *)v54 + 3) = 0;
  v54[0] = 0;
  memset(v53, 0, 7);
  *(_OWORD *)__p = 0u;
  v51 = 0u;
  v52 = 1065353216;
  v8 = MIL::IRDictionaryValue::begin(v6);
  v9 = MIL::IRDictionaryValue::end(v7);
  v39 = a2;
  if (v8 == v9)
  {
    v26 = 0;
    v30 = 0;
    v28 = 0;
    v27 = 0;
    v29 = 0;
    __sz = 0;
    v25 = 0;
    v24 = 0;
    v11 = 0;
LABEL_51:
    v31 = 0;
    v49.__r_.__value_.__r.__words[0] = (std::string::size_type)v26;
    v49.__r_.__value_.__l.__size_ = v11;
    LODWORD(v49.__r_.__value_.__r.__words[2]) = v55[0];
    *(_DWORD *)((char *)&v49.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v55 + 3);
    *((_BYTE *)&v49.__r_.__value_.__s + 23) = v24;
    if (v29 < 0)
      goto LABEL_54;
    goto LABEL_52;
  }
  v44 = 0;
  v45 = 0;
  v42 = 0;
  v40 = 0;
  v41 = 0;
  v46 = 0;
  __sz = 0;
  v10 = 0;
  v11 = 0;
  do
  {
    MIL::IRValue::GetScalar<std::string>(*(const void **)(v8 + 16), &v49);
    MIL::IRValue::GetScalar<std::string>(*(const void **)(v8 + 32), &v48);
    size = HIBYTE(v49.__r_.__value_.__r.__words[2]);
    if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = v49.__r_.__value_.__l.__size_;
    if (size == 11)
    {
      if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v18 = &v49;
      else
        v18 = (std::string *)v49.__r_.__value_.__r.__words[0];
      v19 = v18->__r_.__value_.__r.__words[0];
      v20 = *(std::string::size_type *)((char *)v18->__r_.__value_.__r.__words + 3);
      if (v19 != 0x776F2D6C65646F6DLL || v20 != 0x72656E776F2D6C65)
      {
LABEL_34:
        v47.__r_.__value_.__r.__words[0] = (std::string::size_type)&v49;
        v22 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (unsigned __int8 *)&v49, (uint64_t)&std::piecewise_construct, (__int128 **)&v47);
        v23 = (void **)(v22 + 40);
        if ((char)v22[63] < 0)
          operator delete(*v23);
        *(std::string *)v23 = v48;
        goto LABEL_37;
      }
      if (v46 < 0)
        operator delete(v44);
      __sz = v48.__r_.__value_.__l.__size_;
      v44 = (void *)v48.__r_.__value_.__r.__words[0];
      v54[0] = v48.__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v54 + 3) = *(_DWORD *)((char *)&v48.__r_.__value_.__r.__words[2] + 3);
      v46 = HIBYTE(v48.__r_.__value_.__r.__words[2]);
    }
    else
    {
      if (size != 10)
        goto LABEL_34;
      if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v13 = &v49;
      else
        v13 = (std::string *)v49.__r_.__value_.__r.__words[0];
      if (v13->__r_.__value_.__r.__words[0] == 0x616E2D6C65646F6DLL
        && LOWORD(v13->__r_.__value_.__r.__words[1]) == 25965)
      {
        if (v10 < 0)
          operator delete(v45);
        v11 = v48.__r_.__value_.__l.__size_;
        v45 = (void *)v48.__r_.__value_.__r.__words[0];
        v55[0] = v48.__r_.__value_.__r.__words[2];
        *(_DWORD *)((char *)v55 + 3) = *(_DWORD *)((char *)&v48.__r_.__value_.__r.__words[2] + 3);
        v10 = HIBYTE(v48.__r_.__value_.__r.__words[2]);
      }
      else
      {
        v15 = v13->__r_.__value_.__r.__words[0];
        v16 = LOWORD(v13->__r_.__value_.__r.__words[1]);
        if (v15 != 0x61702D6C65646F6DLL || v16 != 26740)
          goto LABEL_34;
        if (v42 < 0)
          operator delete(v41);
        v40 = v48.__r_.__value_.__l.__size_;
        v41 = (void *)v48.__r_.__value_.__r.__words[0];
        v53[0] = v48.__r_.__value_.__r.__words[2];
        *(_DWORD *)((char *)v53 + 3) = *(_DWORD *)((char *)&v48.__r_.__value_.__r.__words[2] + 3);
        v42 = HIBYTE(v48.__r_.__value_.__r.__words[2]);
      }
    }
LABEL_37:
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v49.__r_.__value_.__l.__data_);
    v8 = *(_QWORD *)v8;
  }
  while (v8 != v9);
  v24 = v10;
  if ((v10 & 0x80) == 0)
  {
    v25 = (std::string::value_type *)v44;
    v26 = v45;
    v28 = v40;
    v27 = (std::string::value_type *)v41;
    v29 = v46;
    v30 = v42;
    goto LABEL_51;
  }
  v25 = (std::string::value_type *)v44;
  v26 = v45;
  v27 = (std::string::value_type *)v41;
  v29 = v46;
  v30 = v42;
  std::string::__init_copy_ctor_external(&v49, (const std::string::value_type *)v45, v11);
  v28 = v40;
  v31 = 1;
  if ((v46 & 0x80) == 0)
  {
LABEL_52:
    v48.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
    v48.__r_.__value_.__l.__size_ = __sz;
    LODWORD(v48.__r_.__value_.__r.__words[2]) = v54[0];
    *(_DWORD *)((char *)&v48.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v54 + 3);
    *((_BYTE *)&v48.__r_.__value_.__s + 23) = v29;
    goto LABEL_55;
  }
LABEL_54:
  std::string::__init_copy_ctor_external(&v48, v25, __sz);
LABEL_55:
  if (v30 < 0)
  {
    std::string::__init_copy_ctor_external(&v47, v27, v28);
  }
  else
  {
    v47.__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
    v47.__r_.__value_.__l.__size_ = v28;
    LODWORD(v47.__r_.__value_.__r.__words[2]) = v53[0];
    *(_DWORD *)((char *)&v47.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v53 + 3);
    *((_BYTE *)&v47.__r_.__value_.__s + 23) = v30;
  }
  v32 = operator new();
  v33 = v49.__r_.__value_.__r.__words[0];
  *(_QWORD *)(v32 + 8) = v49.__r_.__value_.__l.__size_;
  *(_QWORD *)(v32 + 15) = *(std::string::size_type *)((char *)&v49.__r_.__value_.__r.__words[1] + 7);
  v34 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
  *(_OWORD *)&v49.__r_.__value_.__r.__words[1] = 0uLL;
  v35 = v48.__r_.__value_.__l.__size_;
  *(_QWORD *)(v32 + 24) = v48.__r_.__value_.__r.__words[0];
  *(_QWORD *)(v32 + 32) = v35;
  *(_QWORD *)(v32 + 39) = *(std::string::size_type *)((char *)&v48.__r_.__value_.__r.__words[1] + 7);
  LOBYTE(v35) = *((_BYTE *)&v48.__r_.__value_.__s + 23);
  v49.__r_.__value_.__r.__words[0] = 0;
  memset(&v48, 0, sizeof(v48));
  v36 = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
  *(_QWORD *)(v32 + 63) = *(std::string::size_type *)((char *)&v47.__r_.__value_.__r.__words[1] + 7);
  v37 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
  memset(&v47, 0, sizeof(v47));
  *(_QWORD *)v32 = v33;
  *(_BYTE *)(v32 + 23) = v34;
  *(_BYTE *)(v32 + 47) = v35;
  *(_OWORD *)(v32 + 48) = v36;
  *(_BYTE *)(v32 + 71) = v37;
  *(_QWORD *)(v32 + 88) = 0;
  *(_QWORD *)(v32 + 80) = 0;
  *(_QWORD *)(v32 + 72) = v32 + 80;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(v32 + 96, (uint64_t *)__p);
  v38 = (_QWORD *)operator new();
  *v38 = v32;
  *v39 = v38;
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v47.__r_.__value_.__l.__data_);
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v48.__r_.__value_.__l.__data_);
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v49.__r_.__value_.__l.__data_);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)__p);
  if ((v30 & 0x80) == 0)
  {
    if ((v29 & 0x80) == 0)
      goto LABEL_66;
LABEL_70:
    operator delete(v25);
    if (!v31)
      return;
LABEL_67:
    operator delete(v26);
    return;
  }
  operator delete(v27);
  if (v29 < 0)
    goto LABEL_70;
LABEL_66:
  if (v31)
    goto LABEL_67;
}

void sub_1E05D116C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, int a12, char a13, uint64_t a14, void *a15, void *a16, int a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  char v43;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a38);
  if (a13 < 0)
    operator delete(__p);
  if (a18 < 0)
    operator delete(a15);
  if (v43 < 0)
    operator delete(a16);
  _Unwind_Resume(a1);
}

void MIL::Attributes::BuildInfo::GetModelName(MIL::Attributes::BuildInfo *this@<X0>, std::string *a2@<X8>)
{
  __int128 *v2;
  __int128 v3;

  v2 = *(__int128 **)this;
  if (*(char *)(*(_QWORD *)this + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
  }
  else
  {
    v3 = *v2;
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)v2 + 2);
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v3;
  }
}

__n128 MIL::Attributes::BuildInfo::SetModelName(uint64_t *a1, __n128 *a2)
{
  uint64_t v3;
  __n128 result;

  v3 = *a1;
  if (*(char *)(*a1 + 23) < 0)
    operator delete(*(void **)v3);
  result = *a2;
  *(_QWORD *)(v3 + 16) = a2[1].n128_u64[0];
  *(__n128 *)v3 = result;
  a2[1].n128_u8[7] = 0;
  a2->n128_u8[0] = 0;
  return result;
}

void MIL::Attributes::BuildInfo::GetModelOwner(MIL::Attributes::BuildInfo *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v2;
  __int128 v3;

  v2 = *(_QWORD *)this;
  if (*(char *)(*(_QWORD *)this + 47) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(v2 + 24), *(_QWORD *)(v2 + 32));
  }
  else
  {
    v3 = *(_OWORD *)(v2 + 24);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(v2 + 40);
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v3;
  }
}

__n128 MIL::Attributes::BuildInfo::SetModelOwner(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 result;

  v3 = *(_QWORD *)a1 + 24;
  if (*(char *)(*(_QWORD *)a1 + 47) < 0)
    operator delete(*(void **)v3);
  result = *a2;
  *(_QWORD *)(v3 + 16) = a2[1].n128_u64[0];
  *(__n128 *)v3 = result;
  a2[1].n128_u8[7] = 0;
  a2->n128_u8[0] = 0;
  return result;
}

void MIL::Attributes::BuildInfo::GetModelPath(MIL::Attributes::BuildInfo *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v2;
  __int128 v3;

  v2 = *(_QWORD *)this;
  if (*(char *)(*(_QWORD *)this + 71) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(v2 + 48), *(_QWORD *)(v2 + 56));
  }
  else
  {
    v3 = *(_OWORD *)(v2 + 48);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(v2 + 64);
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v3;
  }
}

__n128 MIL::Attributes::BuildInfo::SetModelPath(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 result;

  v3 = *(_QWORD *)a1 + 48;
  if (*(char *)(*(_QWORD *)a1 + 71) < 0)
    operator delete(*(void **)v3);
  result = *a2;
  *(_QWORD *)(v3 + 16) = a2[1].n128_u64[0];
  *(__n128 *)v3 = result;
  a2[1].n128_u8[7] = 0;
  a2->n128_u8[0] = 0;
  return result;
}

void MIL::Attributes::BuildInfo::GetVersion(uint64_t *a1@<X0>, std::string *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v4;
  std::string v5;
  std::string __p;

  v4 = *a1;
  v5 = *a2;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  MIL::Attributes::BuildInfo::Impl::TryGetValue(v4, (unsigned __int8 *)&__p, a3);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v5.__r_.__value_.__l.__data_);
}

void sub_1E05D1470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  _Unwind_Resume(exception_object);
}

void MIL::Attributes::BuildInfo::Impl::TryGetValue(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, std::string *a3@<X8>)
{
  unsigned __int8 *v4;
  __int128 v5;

  v4 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>((_QWORD *)(a1 + 96), a2);
  if (v4)
  {
    if ((char)v4[63] < 0)
    {
      std::string::__init_copy_ctor_external(a3, *((const std::string::value_type **)v4 + 5), *((_QWORD *)v4 + 6));
    }
    else
    {
      v5 = *(_OWORD *)(v4 + 40);
      a3->__r_.__value_.__r.__words[2] = *((_QWORD *)v4 + 7);
      *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v5;
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(a3, "");
  }
}

void `anonymous namespace'::GetVersionKey(std::string *a1@<X0>, std::string *a2@<X8>)
{
  std::string *v3;
  std::string::value_type __s[23];
  char v5;

  v5 = 8;
  strcpy(__s, "-version");
  v3 = std::string::append(a1, __s, 8uLL);
  *a2 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (v5 < 0)
    operator delete(*(void **)__s);
}

void sub_1E05D158C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::Attributes::BuildInfo::SetVersion(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  void *__p[2];
  uint64_t v8;
  std::string v9;
  void *v10[2];
  uint64_t v11;
  std::string v12;
  std::string v13;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v12, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v12 = *(std::string *)a2;
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v12.__r_.__value_.__l.__data_);
  v6 = *a1;
  *(_OWORD *)v10 = *(_OWORD *)a2;
  v11 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v9 = v13;
  v8 = *(_QWORD *)(a3 + 16);
  *(_OWORD *)__p = *(_OWORD *)a3;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  MIL::Attributes::BuildInfo::Impl::SetValue(v6, (const void **)v10, (__int128 *)&v9, (__n128 *)__p);
  if (SHIBYTE(v8) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v9.__r_.__value_.__l.__data_);
  if (SHIBYTE(v11) < 0)
    operator delete(v10[0]);
}

void sub_1E05D16A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a14 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(exception_object);
}

__n128 MIL::Attributes::BuildInfo::Impl::SetValue(uint64_t a1, const void **a2, __int128 *a3, __n128 *a4)
{
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  __n128 result;
  __int128 *v10;

  std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>((uint64_t **)(a1 + 72), a2, (uint64_t)a2);
  v10 = a3;
  v7 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1 + 96, (unsigned __int8 *)a3, (uint64_t)&std::piecewise_construct, &v10);
  v8 = v7 + 40;
  if ((char)v7[63] < 0)
    operator delete(*(void **)v8);
  result = *a4;
  *((_QWORD *)v8 + 2) = a4[1].n128_u64[0];
  *(__n128 *)v8 = result;
  a4[1].n128_u8[7] = 0;
  a4->n128_u8[0] = 0;
  return result;
}

void MIL::Attributes::BuildInfo::GetToolNames(MIL::Attributes::BuildInfo *this@<X0>, std::vector<std::string> *a2@<X8>)
{
  char **v4;
  unint64_t end;
  __int128 *v6;
  char *v7;
  char **v8;
  BOOL v9;
  char **v10;
  char *v11[3];

  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  std::set<std::string>::set[abi:ne180100]((uint64_t *)&v10, (const void ***)(*(_QWORD *)this + 72));
  std::vector<std::string>::reserve(a2, (std::vector<std::string>::size_type)v11[1]);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)&v10, v11[0]);
  std::set<std::string>::set[abi:ne180100]((uint64_t *)&v10, (const void ***)(*(_QWORD *)this + 72));
  v4 = v10;
  if (v10 != v11)
  {
    end = (unint64_t)a2->__end_;
    do
    {
      v6 = (__int128 *)(v4 + 4);
      if ((std::string *)end >= a2->__end_cap_.__value_)
      {
        end = std::vector<std::string>::__push_back_slow_path<std::string const&>((uint64_t *)a2, v6);
      }
      else
      {
        std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)a2, v6);
        end += 24;
      }
      a2->__end_ = (std::vector<std::string>::pointer)end;
      v7 = v4[1];
      if (v7)
      {
        do
        {
          v8 = (char **)v7;
          v7 = *(char **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (char **)v4[2];
          v9 = *v8 == (char *)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != v11);
  }
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)&v10, v11[0]);
}

void sub_1E05D1880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void MIL::Attributes::BuildInfo::GetComponentVersions(std::string **a1@<X0>, std::string *a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE v5[40];
  _BYTE v6[40];
  std::string v7;
  std::string v8;

  v7 = *a2;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(*a1, (uint64_t)&v8, (uint64_t)v6);
  std::unordered_map<std::string,std::string>::unordered_map((uint64_t)v5, (uint64_t)v6);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v5);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v6);
  if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v8.__r_.__value_.__l.__data_);
}

void sub_1E05D195C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v14;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a9);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a14);
  if (*(char *)(v14 - 17) < 0)
    operator delete(*(void **)(v14 - 40));
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GetComponentVersionKeyPrefix(std::string *a1@<X0>, std::string *a2@<X8>)
{
  std::string *v3;
  std::string::value_type __s[23];
  char v5;

  v5 = 11;
  strcpy(__s, "-component-");
  v3 = std::string::append(a1, __s, 0xBuLL);
  *a2 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (v5 < 0)
    operator delete(*(void **)__s);
}

void sub_1E05D1A30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching@<X0>(std::string *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  uint64_t v4;
  _QWORD v5[3];
  _QWORD *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = &off_1EA999968;
  v5[1] = a2;
  v6 = v5;
  MIL::Attributes::BuildInfo::Impl::TryGetValues(a1, (uint64_t)v5, a3);
  result = v6;
  if (v6 == v5)
  {
    v4 = 4;
    result = v5;
  }
  else
  {
    if (!v6)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

void sub_1E05D1AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::StripPrefixFromKeys(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *i;
  std::string::size_type v6;
  unsigned __int8 *v7;
  std::string v8;
  std::string *v9;

  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  for (i = *(uint64_t **)(a1 + 16); i; i = (uint64_t *)*i)
  {
    if (*(char *)(a2 + 23) >= 0)
      v6 = *(unsigned __int8 *)(a2 + 23);
    else
      v6 = *(_QWORD *)(a2 + 8);
    std::string::basic_string(&v8, (const std::string *)(i + 2), v6, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v9);
    v9 = &v8;
    v7 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a3, (unsigned __int8 *)&v8, (uint64_t)&std::piecewise_construct, (__int128 **)&v9);
    std::string::operator=((std::string *)(v7 + 40), (const std::string *)(i + 5));
    if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v8.__r_.__value_.__l.__data_);
  }
}

void sub_1E05D1BE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v15);
  _Unwind_Resume(a1);
}

void MIL::Attributes::BuildInfo::SetComponentVersion(uint64_t *a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  int v8;
  const std::string::value_type *v9;
  std::string::size_type v10;
  std::string *v11;
  void *v12;
  char v13;
  uint64_t v14;
  __int128 v15;
  void *__p[2];
  uint64_t v17;
  void *v18;
  _BYTE v19[15];
  char v20;
  void *v21[2];
  uint64_t v22;
  std::string v23;
  std::string v24;
  _QWORD v25[3];

  v25[2] = *MEMORY[0x1E0C80C00];
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v23, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v23 = *(std::string *)a2;
  v8 = *(char *)(a3 + 23);
  if (v8 >= 0)
    v9 = (const std::string::value_type *)a3;
  else
    v9 = *(const std::string::value_type **)a3;
  if (v8 >= 0)
    v10 = *(unsigned __int8 *)(a3 + 23);
  else
    v10 = *(_QWORD *)(a3 + 8);
  v11 = std::string::append(&v24, v9, v10);
  v12 = (void *)v11->__r_.__value_.__r.__words[0];
  v25[0] = v11->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v25 + 7) = *(std::string::size_type *)((char *)&v11->__r_.__value_.__r.__words[1] + 7);
  v13 = HIBYTE(v11->__r_.__value_.__r.__words[2]);
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  v14 = *a1;
  *(_OWORD *)v21 = *(_OWORD *)a2;
  v22 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v18 = v12;
  *(_QWORD *)v19 = v25[0];
  *(_QWORD *)&v19[7] = *(_QWORD *)((char *)v25 + 7);
  v20 = v13;
  v15 = *a4;
  v17 = *((_QWORD *)a4 + 2);
  *(_OWORD *)__p = v15;
  *((_QWORD *)a4 + 1) = 0;
  *((_QWORD *)a4 + 2) = 0;
  *(_QWORD *)a4 = 0;
  MIL::Attributes::BuildInfo::Impl::SetValue(v14, (const void **)v21, (__int128 *)&v18, (__n128 *)__p);
  if (SHIBYTE(v17) < 0)
    operator delete(__p[0]);
  if (v20 < 0)
    operator delete(v18);
  if (SHIBYTE(v22) < 0)
    operator delete(v21[0]);
}

void sub_1E05D1D94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  _Unwind_Resume(exception_object);
}

void MIL::Attributes::BuildInfo::GetPrivateCustomInformation(std::string **a1@<X0>, std::string *a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE v5[40];
  _BYTE v6[40];
  std::string v7;
  std::string v8;

  v7 = *a2;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(*a1, (uint64_t)&v8, (uint64_t)v6);
  std::unordered_map<std::string,std::string>::unordered_map((uint64_t)v5, (uint64_t)v6);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v5);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v6);
  if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v8.__r_.__value_.__l.__data_);
}

void sub_1E05D1EAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v14;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a9);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a14);
  if (*(char *)(v14 - 17) < 0)
    operator delete(*(void **)(v14 - 40));
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GetPrivateCustomInfoKeyPrefix(std::string *a1@<X0>, std::string *a2@<X8>)
{
  std::string *v3;
  std::string::value_type __s[23];
  char v5;

  v5 = 9;
  strcpy(__s, "-private-");
  v3 = std::string::append(a1, __s, 9uLL);
  *a2 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (v5 < 0)
    operator delete(*(void **)__s);
}

void sub_1E05D1F78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::Attributes::BuildInfo::SetPrivateCustomInformation(uint64_t *a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  int v8;
  const std::string::value_type *v9;
  std::string::size_type v10;
  std::string *v11;
  void *v12;
  char v13;
  uint64_t v14;
  __int128 v15;
  void *__p[2];
  uint64_t v17;
  void *v18;
  _BYTE v19[15];
  char v20;
  void *v21[2];
  uint64_t v22;
  std::string v23;
  std::string v24;
  _QWORD v25[3];

  v25[2] = *MEMORY[0x1E0C80C00];
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v23, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v23 = *(std::string *)a2;
  v8 = *(char *)(a3 + 23);
  if (v8 >= 0)
    v9 = (const std::string::value_type *)a3;
  else
    v9 = *(const std::string::value_type **)a3;
  if (v8 >= 0)
    v10 = *(unsigned __int8 *)(a3 + 23);
  else
    v10 = *(_QWORD *)(a3 + 8);
  v11 = std::string::append(&v24, v9, v10);
  v12 = (void *)v11->__r_.__value_.__r.__words[0];
  v25[0] = v11->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v25 + 7) = *(std::string::size_type *)((char *)&v11->__r_.__value_.__r.__words[1] + 7);
  v13 = HIBYTE(v11->__r_.__value_.__r.__words[2]);
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  v14 = *a1;
  *(_OWORD *)v21 = *(_OWORD *)a2;
  v22 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v18 = v12;
  *(_QWORD *)v19 = v25[0];
  *(_QWORD *)&v19[7] = *(_QWORD *)((char *)v25 + 7);
  v20 = v13;
  v15 = *a4;
  v17 = *((_QWORD *)a4 + 2);
  *(_OWORD *)__p = v15;
  *((_QWORD *)a4 + 1) = 0;
  *((_QWORD *)a4 + 2) = 0;
  *(_QWORD *)a4 = 0;
  MIL::Attributes::BuildInfo::Impl::SetValue(v14, (const void **)v21, (__int128 *)&v18, (__n128 *)__p);
  if (SHIBYTE(v17) < 0)
    operator delete(__p[0]);
  if (v20 < 0)
    operator delete(v18);
  if (SHIBYTE(v22) < 0)
    operator delete(v21[0]);
}

void sub_1E05D211C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  _Unwind_Resume(exception_object);
}

void MIL::Attributes::BuildInfo::GetPublicCustomInformation(std::string **a1@<X0>, std::string *a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE v5[40];
  _BYTE v6[40];
  std::string v7;
  std::string v8;

  v7 = *a2;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(*a1, (uint64_t)&v8, (uint64_t)v6);
  std::unordered_map<std::string,std::string>::unordered_map((uint64_t)v5, (uint64_t)v6);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v5);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v6);
  if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v8.__r_.__value_.__l.__data_);
}

void sub_1E05D2234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v14;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a9);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&a14);
  if (*(char *)(v14 - 17) < 0)
    operator delete(*(void **)(v14 - 40));
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GetPublicCustomInfoKeyPrefix(std::string *a1@<X0>, std::string *a2@<X8>)
{
  std::string *v3;
  std::string::value_type __s[8];
  char v5;

  v5 = 6;
  strcpy(__s, "-misc-");
  v3 = std::string::append(a1, __s, 6uLL);
  *a2 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (v5 < 0)
    operator delete(*(void **)__s);
}

void sub_1E05D2300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::Attributes::BuildInfo::SetPublicCustomInformation(uint64_t *a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  int v8;
  const std::string::value_type *v9;
  std::string::size_type v10;
  std::string *v11;
  void *v12;
  char v13;
  uint64_t v14;
  __int128 v15;
  void *__p[2];
  uint64_t v17;
  void *v18;
  _BYTE v19[15];
  char v20;
  void *v21[2];
  uint64_t v22;
  std::string v23;
  std::string v24;
  _QWORD v25[3];

  v25[2] = *MEMORY[0x1E0C80C00];
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v23, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v23 = *(std::string *)a2;
  v8 = *(char *)(a3 + 23);
  if (v8 >= 0)
    v9 = (const std::string::value_type *)a3;
  else
    v9 = *(const std::string::value_type **)a3;
  if (v8 >= 0)
    v10 = *(unsigned __int8 *)(a3 + 23);
  else
    v10 = *(_QWORD *)(a3 + 8);
  v11 = std::string::append(&v24, v9, v10);
  v12 = (void *)v11->__r_.__value_.__r.__words[0];
  v25[0] = v11->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v25 + 7) = *(std::string::size_type *)((char *)&v11->__r_.__value_.__r.__words[1] + 7);
  v13 = HIBYTE(v11->__r_.__value_.__r.__words[2]);
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  v14 = *a1;
  *(_OWORD *)v21 = *(_OWORD *)a2;
  v22 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v18 = v12;
  *(_QWORD *)v19 = v25[0];
  *(_QWORD *)&v19[7] = *(_QWORD *)((char *)v25 + 7);
  v20 = v13;
  v15 = *a4;
  v17 = *((_QWORD *)a4 + 2);
  *(_OWORD *)__p = v15;
  *((_QWORD *)a4 + 1) = 0;
  *((_QWORD *)a4 + 2) = 0;
  *(_QWORD *)a4 = 0;
  MIL::Attributes::BuildInfo::Impl::SetValue(v14, (const void **)v21, (__int128 *)&v18, (__n128 *)__p);
  if (SHIBYTE(v17) < 0)
    operator delete(__p[0]);
  if (v20 < 0)
    operator delete(v18);
  if (SHIBYTE(v22) < 0)
    operator delete(v21[0]);
}

void sub_1E05D24A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  _Unwind_Resume(exception_object);
}

void MIL::Attributes::BuildInfo::GetPrivateInformation(std::string **this@<X0>, uint64_t a2@<X8>)
{
  std::string::const_iterator v4;
  std::string *v5;
  __int128 v6;
  std::string *v7;
  __int128 *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::regex_traits<char> v13[2];
  std::__shared_weak_count *v14;
  std::string::value_type __s[23];
  char v16;
  std::string v17;
  std::string v18;
  __int128 v19;
  std::string::size_type v20;
  __int128 *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  *((_BYTE *)&v17.__r_.__value_.__s + 23) = 13;
  strcpy((char *)&v17, "[[:alpha:]-]+");
  v4.__i_ = (std::__wrap_iter<const char *>::iterator_type)&v17;
  std::string::insert(&v17, v4, 94);
  v18 = v17;
  memset(&v17, 0, sizeof(v17));
  v16 = 9;
  strcpy(__s, "-private-");
  v5 = std::string::append(&v18, __s, 9uLL);
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v20 = v5->__r_.__value_.__r.__words[2];
  v19 = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>(v13, (uint64_t)&v19, 32);
  if (SHIBYTE(v20) < 0)
    operator delete((void *)v19);
  if (v16 < 0)
    operator delete(*(void **)__s);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v17.__r_.__value_.__l.__data_);
  v7 = *this;
  *(_QWORD *)&v19 = &off_1EA99A110;
  *((_QWORD *)&v19 + 1) = v13;
  v21 = &v19;
  MIL::Attributes::BuildInfo::Impl::TryGetValues(v7, (uint64_t)&v19, a2);
  v8 = v21;
  if (v21 == &v19)
  {
    v9 = 4;
    v8 = &v19;
    goto LABEL_13;
  }
  if (v21)
  {
    v9 = 5;
LABEL_13:
    (*(void (**)(void))(*(_QWORD *)v8 + 8 * v9))();
  }
  v10 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  std::locale::~locale(&v13[0].__loc_);
}

void sub_1E05D26E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v31;
  uint64_t v32;

  v31 = *(_QWORD **)(v29 - 40);
  if (v31 == v28)
  {
    v32 = 4;
    v31 = (_QWORD *)(v29 - 64);
  }
  else
  {
    if (!v31)
      goto LABEL_6;
    v32 = 5;
  }
  (*(void (**)(void))(*v31 + 8 * v32))();
LABEL_6:
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a14);
  std::locale::~locale((std::locale *)&a9);
  _Unwind_Resume(a1);
}

std::string *MIL::Attributes::BuildInfo::Impl::TryGetValues@<X0>(std::string *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *i;
  uint64_t v6;
  unsigned __int8 *v7;
  __int128 *v8;

  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  for (i = (uint64_t *)result[4].__r_.__value_.__r.__words[2]; i; i = (uint64_t *)*i)
  {
    v6 = *(_QWORD *)(a2 + 24);
    if (!v6)
      std::__throw_bad_function_call[abi:ne180100]();
    result = (std::string *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v6 + 48))(v6, i + 2);
    if ((_DWORD)result)
    {
      v8 = (__int128 *)(i + 2);
      v7 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (unsigned __int8 *)i + 16, (uint64_t)&std::piecewise_construct, &v8);
      result = std::string::operator=((std::string *)(v7 + 40), (const std::string *)(i + 5));
    }
  }
  return result;
}

void sub_1E05D2834(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void MIL::Attributes::BuildInfo::GetPublicInformation(std::string **this@<X0>, uint64_t a2@<X8>)
{
  std::string::const_iterator v4;
  std::string *v5;
  __int128 v6;
  std::string::const_iterator v7;
  std::string *v8;
  __int128 v9;
  std::string::const_iterator v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  std::string *v14;
  std::string *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::regex_traits<char> v26[2];
  std::__shared_weak_count *v27;
  std::regex_traits<char> __p[2];
  std::__shared_weak_count *v29;
  std::regex_traits<char> v30[2];
  std::__shared_weak_count *v31;
  void *v32[2];
  char v33;
  std::string v34;
  std::string v35;
  std::string __s;
  std::string v37;
  std::string *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  *((_BYTE *)&v37.__r_.__value_.__s + 23) = 13;
  strcpy((char *)&v37, "[[:alpha:]-]+");
  v4.__i_ = (std::__wrap_iter<const char *>::iterator_type)&v37;
  std::string::insert(&v37, v4, 94);
  v26[0] = (std::regex_traits<char>)v37;
  memset(&v37, 0, sizeof(v37));
  *((_BYTE *)&__s.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&__s, "-component-");
  v5 = std::string::append((std::string *)v26, (const std::string::value_type *)&__s, 0xBuLL);
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  __p[0].__col_ = (const std::collate<char> *)v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p[0].__loc_.__locale_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>(v30, (uint64_t)__p, 32);
  if (SHIBYTE(__p[0].__col_) < 0)
    operator delete(__p[0].__loc_.__locale_);
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__s.__r_.__value_.__l.__data_);
  if (SHIBYTE(v26[0].__col_) < 0)
    operator delete(v26[0].__loc_.__locale_);
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v37.__r_.__value_.__l.__data_);
  *((_BYTE *)&__s.__r_.__value_.__s + 23) = 13;
  strcpy((char *)&__s, "[[:alpha:]-]+");
  v7.__i_ = (std::__wrap_iter<const char *>::iterator_type)&__s;
  std::string::insert(&__s, v7, 94);
  v37 = __s;
  memset(&__s, 0, sizeof(__s));
  *((_BYTE *)&v35.__r_.__value_.__s + 23) = 6;
  strcpy((char *)&v35, "-misc-");
  v8 = std::string::append(&v37, (const std::string::value_type *)&v35, 6uLL);
  v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v26[0].__col_ = (const std::collate<char> *)v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26[0].__loc_.__locale_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>(__p, (uint64_t)v26, 32);
  if (SHIBYTE(v26[0].__col_) < 0)
    operator delete(v26[0].__loc_.__locale_);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v37.__r_.__value_.__l.__data_);
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__s.__r_.__value_.__l.__data_);
  *((_BYTE *)&v34.__r_.__value_.__s + 23) = 13;
  strcpy((char *)&v34, "[[:alpha:]-]+");
  v10.__i_ = (std::__wrap_iter<const char *>::iterator_type)&v34;
  std::string::insert(&v34, v10, 94);
  v35 = v34;
  memset(&v34, 0, sizeof(v34));
  v33 = 8;
  strcpy((char *)v32, "-version");
  v11 = std::string::append(&v35, (const std::string::value_type *)v32, 8uLL);
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  __s.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__s.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  std::string::push_back(&__s, 36);
  v37 = __s;
  memset(&__s, 0, sizeof(__s));
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>(v26, (uint64_t)&v37, 32);
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v37.__r_.__value_.__l.__data_);
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__s.__r_.__value_.__l.__data_);
  if (v33 < 0)
    operator delete(v32[0]);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
  v13 = *this;
  v14 = (std::string *)operator new(0x20uLL);
  v14->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1EA99A190;
  v14->__r_.__value_.__l.__size_ = (std::string::size_type)v30;
  v14->__r_.__value_.__r.__words[2] = (std::string::size_type)__p;
  v14[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v26;
  v38 = v14;
  MIL::Attributes::BuildInfo::Impl::TryGetValues(v13, (uint64_t)&v37, a2);
  v15 = v38;
  if (v38 == &v37)
  {
    v16 = 4;
    v15 = &v37;
    goto LABEL_31;
  }
  if (v38)
  {
    v16 = 5;
LABEL_31:
    (*(void (**)(void))(v15->__r_.__value_.__r.__words[0] + 8 * v16))();
  }
  v17 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  std::locale::~locale(&v26[0].__loc_);
  v20 = v29;
  if (v29)
  {
    v21 = (unint64_t *)&v29->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  std::locale::~locale(&__p[0].__loc_);
  v23 = v31;
  if (v31)
  {
    v24 = (unint64_t *)&v31->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  std::locale::~locale(&v30[0].__loc_);
}

void sub_1E05D2CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::locale a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::locale a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  _QWORD *v41;
  uint64_t v42;
  _QWORD *v44;
  uint64_t v45;

  v44 = *(_QWORD **)(v42 - 72);
  if (v44 == v41)
  {
    v45 = 4;
    v44 = (_QWORD *)(v42 - 96);
  }
  else
  {
    if (!v44)
      goto LABEL_6;
    v45 = 5;
  }
  (*(void (**)(void))(*v44 + 8 * v45))();
LABEL_6:
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  std::locale::~locale((std::locale *)&a9);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a25);
  std::locale::~locale(&a20);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a33);
  std::locale::~locale(&a28);
  _Unwind_Resume(a1);
}

void sub_1E05D2DEC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;

  if (a25 < 0)
    operator delete(__p);
  if (*(char *)(v25 - 105) < 0)
    operator delete(*(void **)(v25 - 128));
  if (a14 < 0)
    operator delete(a9);
  if (*(char *)(v25 - 73) < 0)
    operator delete(*(void **)(v25 - 96));
  JUMPOUT(0x1E05D2DE4);
}

void MIL::Attributes::BuildInfo::SetField(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::string::size_type v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  std::string __p;
  void *v13[2];
  char v14;
  std::string v15;
  std::string v16;
  std::string v17;

  switch((_DWORD)a2)
  {
    case 3:
      if (*(char *)(a3 + 23) < 0)
        std::string::__init_copy_ctor_external(&v16, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
      else
        v16 = *(std::string *)a3;
      v6 = *a1;
      v7 = *a1 + 48;
      if (*(char *)(v6 + 71) < 0)
        operator delete(*(void **)v7);
      *(_OWORD *)v7 = *(_OWORD *)&v16.__r_.__value_.__l.__data_;
      v8 = v16.__r_.__value_.__r.__words[2];
      goto LABEL_20;
    case 2:
      if (*(char *)(a3 + 23) < 0)
        std::string::__init_copy_ctor_external(&v15, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
      else
        v15 = *(std::string *)a3;
      v9 = *a1;
      v7 = *a1 + 24;
      if (*(char *)(v9 + 47) < 0)
        operator delete(*(void **)v7);
      *(_OWORD *)v7 = *(_OWORD *)&v15.__r_.__value_.__l.__data_;
      v8 = v15.__r_.__value_.__r.__words[2];
LABEL_20:
      *(_QWORD *)(v7 + 16) = v8;
      return;
    case 1:
      if (*(char *)(a3 + 23) < 0)
        std::string::__init_copy_ctor_external(&v17, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
      else
        v17 = *(std::string *)a3;
      v10 = *a1;
      if (*(char *)(v10 + 23) < 0)
        operator delete(*(void **)v10);
      v11 = *(_OWORD *)&v17.__r_.__value_.__l.__data_;
      *(_QWORD *)(v10 + 16) = *((_QWORD *)&v17.__r_.__value_.__l + 2);
      *(_OWORD *)v10 = v11;
      break;
    default:
      v5 = *a1;
      MIL::Attributes::ModelInfoToString(a2, v13);
      if (*(char *)(a3 + 23) < 0)
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
      else
        __p = *(std::string *)a3;
      MIL::Attributes::BuildInfo::Impl::SetValue(v5, (__int128 *)v13, (__n128 *)&__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (v14 < 0)
        operator delete(v13[0]);
      break;
  }
}

void sub_1E05D2FE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

__n128 MIL::Attributes::BuildInfo::Impl::SetValue(uint64_t a1, __int128 *a2, __n128 *a3)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  __n128 result;
  __int128 *v7;

  v7 = a2;
  v4 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1 + 96, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, &v7);
  v5 = v4 + 40;
  if ((char)v4[63] < 0)
    operator delete(*(void **)v5);
  result = *a3;
  *((_QWORD *)v5 + 2) = a3[1].n128_u64[0];
  *(__n128 *)v5 = result;
  a3[1].n128_u8[7] = 0;
  a3->n128_u8[0] = 0;
  return result;
}

void MIL::Attributes::BuildInfo::GetField(uint64_t *a1@<X0>, void *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v4;
  const std::string::value_type *v5;
  std::string::size_type v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  void *__p[2];
  char v12;

  switch((_DWORD)a2)
  {
    case 3:
      v7 = *a1;
      if (*(char *)(*a1 + 71) < 0)
      {
        v5 = *(const std::string::value_type **)(v7 + 48);
        v6 = *(_QWORD *)(v7 + 56);
        goto LABEL_16;
      }
      v4 = v7 + 48;
LABEL_10:
      v9 = *(_OWORD *)v4;
      a3->__r_.__value_.__r.__words[2] = *(_QWORD *)(v4 + 16);
      *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v9;
      return;
    case 2:
      v8 = *a1;
      if (*(char *)(*a1 + 47) < 0)
      {
        v5 = *(const std::string::value_type **)(v8 + 24);
        v6 = *(_QWORD *)(v8 + 32);
        goto LABEL_16;
      }
      v4 = v8 + 24;
      goto LABEL_10;
    case 1:
      v4 = *a1;
      if (*(char *)(*a1 + 23) < 0)
      {
        v5 = *(const std::string::value_type **)v4;
        v6 = *(_QWORD *)(v4 + 8);
LABEL_16:
        std::string::__init_copy_ctor_external(a3, v5, v6);
        return;
      }
      goto LABEL_10;
  }
  v10 = *a1;
  MIL::Attributes::ModelInfoToString(a2, __p);
  MIL::Attributes::BuildInfo::Impl::TryGetValue(v10, (unsigned __int8 *)__p, a3);
  if (v12 < 0)
    operator delete(__p[0]);
}

void sub_1E05D3158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIL::Attributes::BuildInfo::Replace(MIL::Attributes::BuildInfo *this, MIL::IRProgram *a2)
{
  MIL::MILContext *Scalar;
  const MIL::IRValueType *v5;
  uint64_t v6;
  __int128 *v7;
  uint64_t *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  std::string::size_type v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const std::string::value_type **v27;
  std::string::size_type v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const std::string::value_type **v37;
  std::string::size_type v38;
  _QWORD *v39;
  uint64_t v40;
  _QWORD *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  MIL::IRDictionaryValue *v48;
  MIL::IRDictionaryValue *v49;
  uint64_t v50;
  uint64_t Attributes;
  uint64_t v52;
  unsigned __int8 *v53;
  MIL::IRDictionaryValue *v54;
  std::__shared_weak_count *v55;
  unint64_t *p_shared_owners;
  unint64_t v57;
  uint64_t v58[2];
  char v59;
  void *v60[2];
  char v61;
  std::string v62;
  void *v63[2];
  char v64;
  std::string v65;
  void *__p[2];
  char v67;
  std::string v68;
  std::string v69;
  uint64_t v70;
  std::string v71;
  uint64_t v72;
  _OWORD v73[2];
  int v74;
  MIL::IRDictionaryValue *v75;
  void (***v76)(MIL::MILContextImpl *__hidden);
  std::__shared_weak_count *v77;
  __int128 *v78;

  (*(void (**)(void (****__return_ptr)(MIL::MILContextImpl *__hidden), MIL::IRProgram *))(*(_QWORD *)a2 + 48))(&v76, a2);
  Scalar = (MIL::MILContext *)MIL::IRTensorValueType::MakeScalar(v76, 3);
  v6 = MIL::IRDictionaryValueType::Make(v76, Scalar, Scalar, v5);
  v75 = 0;
  memset(v73, 0, sizeof(v73));
  v74 = 1065353216;
  v7 = *(__int128 **)this;
  v8 = *(uint64_t **)(*(_QWORD *)this + 112);
  if (v8)
  {
    do
    {
      if (*((char *)v8 + 63) < 0)
        std::string::__init_copy_ctor_external(&v71, (const std::string::value_type *)v8[5], v8[6]);
      else
        v71 = *(std::string *)(v8 + 5);
      MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)&v71, &v72);
      if (*((char *)v8 + 39) < 0)
        std::string::__init_copy_ctor_external(&v69, (const std::string::value_type *)v8[2], v8[3]);
      else
        v69 = *(std::string *)(v8 + 2);
      MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)&v69, &v70);
      v58[0] = v70;
      if (v70)
      {
        v9 = (_QWORD *)operator new();
        v10 = v70;
        *v9 = &unk_1EA992A68;
        v9[1] = 0;
        v9[2] = 0;
        v9[3] = v10;
      }
      else
      {
        v9 = 0;
      }
      v58[1] = (uint64_t)v9;
      v70 = 0;
      v78 = (__int128 *)v58;
      v11 = std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::shared_ptr<MIL::IRValue const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::IRValue const>&&>,std::tuple<>>((uint64_t)v73, v58, (uint64_t)&std::piecewise_construct, &v78);
      std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>(v11 + 4, &v72);
      v12 = (std::__shared_weak_count *)v58[1];
      if (v58[1])
      {
        v13 = (unint64_t *)(v58[1] + 8);
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      v15 = v70;
      v70 = 0;
      if (v15)
        (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
      if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v69.__r_.__value_.__l.__data_);
      v16 = v72;
      v72 = 0;
      if (v16)
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
      if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v71.__r_.__value_.__l.__data_);
      v8 = (uint64_t *)*v8;
    }
    while (v8);
    v7 = *(__int128 **)this;
  }
  if (*((char *)v7 + 23) < 0)
  {
    v18 = *((_QWORD *)v7 + 1);
    if (!v18)
      goto LABEL_48;
    std::string::__init_copy_ctor_external(&v68, *(const std::string::value_type **)v7, v18);
  }
  else
  {
    if (!*((_BYTE *)v7 + 23))
      goto LABEL_48;
    v17 = *v7;
    v68.__r_.__value_.__r.__words[2] = *((_QWORD *)v7 + 2);
    *(_OWORD *)&v68.__r_.__value_.__l.__data_ = v17;
  }
  MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)&v68, &v72);
  v67 = 10;
  strcpy((char *)__p, "model-name");
  MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)__p, &v70);
  v58[0] = v70;
  if (v70)
  {
    v19 = (_QWORD *)operator new();
    v20 = v70;
    *v19 = &unk_1EA992A68;
    v19[1] = 0;
    v19[2] = 0;
    v19[3] = v20;
  }
  else
  {
    v19 = 0;
  }
  v58[1] = (uint64_t)v19;
  v70 = 0;
  v78 = (__int128 *)v58;
  v21 = std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::shared_ptr<MIL::IRValue const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::IRValue const>&&>,std::tuple<>>((uint64_t)v73, v58, (uint64_t)&std::piecewise_construct, &v78);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>(v21 + 4, &v72);
  v22 = (std::__shared_weak_count *)v58[1];
  if (v58[1])
  {
    v23 = (unint64_t *)(v58[1] + 8);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v70;
  v70 = 0;
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
  if (v67 < 0)
    operator delete(__p[0]);
  v26 = v72;
  v72 = 0;
  if (v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v68.__r_.__value_.__l.__data_);
  v7 = *(__int128 **)this;
LABEL_48:
  v27 = (const std::string::value_type **)v7 + 3;
  if (*((char *)v7 + 47) < 0)
  {
    v28 = *((_QWORD *)v7 + 4);
    if (!v28)
      goto LABEL_70;
    std::string::__init_copy_ctor_external(&v65, *v27, v28);
  }
  else
  {
    if (!*((_BYTE *)v7 + 47))
      goto LABEL_70;
    *(_OWORD *)&v65.__r_.__value_.__l.__data_ = *(_OWORD *)v27;
    v65.__r_.__value_.__r.__words[2] = *((_QWORD *)v7 + 5);
  }
  MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)&v65, &v72);
  v64 = 11;
  strcpy((char *)v63, "model-owner");
  MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)v63, &v70);
  v58[0] = v70;
  if (v70)
  {
    v29 = (_QWORD *)operator new();
    v30 = v70;
    *v29 = &unk_1EA992A68;
    v29[1] = 0;
    v29[2] = 0;
    v29[3] = v30;
  }
  else
  {
    v29 = 0;
  }
  v58[1] = (uint64_t)v29;
  v70 = 0;
  v78 = (__int128 *)v58;
  v31 = std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::shared_ptr<MIL::IRValue const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::IRValue const>&&>,std::tuple<>>((uint64_t)v73, v58, (uint64_t)&std::piecewise_construct, &v78);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>(v31 + 4, &v72);
  v32 = (std::__shared_weak_count *)v58[1];
  if (v58[1])
  {
    v33 = (unint64_t *)(v58[1] + 8);
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v70;
  v70 = 0;
  if (v35)
    (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
  if (v64 < 0)
    operator delete(v63[0]);
  v36 = v72;
  v72 = 0;
  if (v36)
    (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
  if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v65.__r_.__value_.__l.__data_);
  v7 = *(__int128 **)this;
LABEL_70:
  v37 = (const std::string::value_type **)(v7 + 3);
  if (*((char *)v7 + 71) < 0)
  {
    v38 = *((_QWORD *)v7 + 7);
    if (!v38)
      goto LABEL_91;
    std::string::__init_copy_ctor_external(&v62, *v37, v38);
  }
  else
  {
    if (!*((_BYTE *)v7 + 71))
      goto LABEL_91;
    *(_OWORD *)&v62.__r_.__value_.__l.__data_ = *(_OWORD *)v37;
    v62.__r_.__value_.__r.__words[2] = *((_QWORD *)v7 + 8);
  }
  MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)&v62, &v72);
  v61 = 10;
  strcpy((char *)v60, "model-path");
  MIL::IRTensorValueType::MakeStringValue(Scalar, (const MIL::IRTensorValueType *)v60, &v70);
  v58[0] = v70;
  if (v70)
  {
    v39 = (_QWORD *)operator new();
    v40 = v70;
    *v39 = &unk_1EA992A68;
    v39[1] = 0;
    v39[2] = 0;
    v39[3] = v40;
  }
  else
  {
    v39 = 0;
  }
  v58[1] = (uint64_t)v39;
  v70 = 0;
  v78 = (__int128 *)v58;
  v41 = std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::shared_ptr<MIL::IRValue const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::IRValue const>&&>,std::tuple<>>((uint64_t)v73, v58, (uint64_t)&std::piecewise_construct, &v78);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRTensorValue const,std::default_delete<MIL::IRTensorValue const>,void>(v41 + 4, &v72);
  v42 = (std::__shared_weak_count *)v58[1];
  if (v58[1])
  {
    v43 = (unint64_t *)(v58[1] + 8);
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v45 = v70;
  v70 = 0;
  if (v45)
    (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
  if (v61 < 0)
    operator delete(v60[0]);
  v46 = v72;
  v72 = 0;
  if (v46)
    (*(void (**)(uint64_t))(*(_QWORD *)v46 + 8))(v46);
  if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v62.__r_.__value_.__l.__data_);
LABEL_91:
  MIL::IRDictionaryValueType::MakeValue(v6, (uint64_t)v73, v58);
  v47 = v58[0];
  v58[0] = 0;
  v48 = v75;
  v75 = (MIL::IRDictionaryValue *)v47;
  if (v48)
  {
    MIL::IRDictionaryValue::~IRDictionaryValue(v48);
    MEMORY[0x1E0C023A0]();
    v49 = (MIL::IRDictionaryValue *)v58[0];
    v58[0] = 0;
    if (v49)
    {
      MIL::IRDictionaryValue::~IRDictionaryValue(v49);
      MEMORY[0x1E0C023A0](v50);
    }
  }
  std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v73);
  Attributes = MIL::IRObject::GetAttributes(a2);
  v52 = std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)v73, Attributes);
  v59 = 9;
  strcpy((char *)v58, "buildInfo");
  v78 = (__int128 *)v58;
  v53 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v52, (unsigned __int8 *)v58, (uint64_t)&std::piecewise_construct, &v78);
  std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRDictionaryValue const,std::default_delete<MIL::IRDictionaryValue const>,void>((_QWORD *)v53 + 5, (uint64_t *)&v75);
  if (v59 < 0)
    operator delete((void *)v58[0]);
  MIL::IRObject::SetAttributes((uint64_t)a2, (uint64_t *)v73);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)v73);
  v54 = v75;
  v75 = 0;
  if (v54)
  {
    MIL::IRDictionaryValue::~IRDictionaryValue(v54);
    MEMORY[0x1E0C023A0]();
  }
  v55 = v77;
  if (v77)
  {
    p_shared_owners = (unint64_t *)&v77->__shared_owners_;
    do
      v57 = __ldaxr(p_shared_owners);
    while (__stlxr(v57 - 1, p_shared_owners));
    if (!v57)
    {
      ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
      std::__shared_weak_count::__release_weak(v55);
    }
  }
}

void sub_1E05D3970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58)
{
  uint64_t v58;

  std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapHasher,MIL::IRValueMapEq,true>,std::__unordered_map_equal<std::shared_ptr<MIL::IRValue const>,std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>,MIL::IRValueMapEq,MIL::IRValueMapHasher,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::IRValue const>,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v58 - 160);
  std::unique_ptr<MIL::IRDictionaryValue const>::reset[abi:ne180100]((MIL::IRDictionaryValue **)(v58 - 120), 0);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100](v58 - 112);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<MIL::IRValue const>::operator=[abi:ne180100]<MIL::IRDictionaryValue const,std::default_delete<MIL::IRDictionaryValue const>,void>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  if (*a2)
  {
    v5 = (_QWORD *)operator new();
    v6 = *a2;
    *v5 = &unk_1EA999830;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  *a2 = 0;
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void MIL::Attributes::BuildInfo::Rewrite(MIL::Attributes::BuildInfo *this@<X0>, const MIL::IRProgram *a2@<X1>, MIL::IRProgram **a3@<X8>)
{
  (*(void (**)(MIL::IRProgram **__return_ptr, const MIL::IRProgram *))(*(_QWORD *)a2 + 32))(a3, a2);
  MIL::Attributes::BuildInfo::Replace(this, *a3);
}

void sub_1E05D3CAC(_Unwind_Exception *exception_object)
{
  uint64_t *v1;
  uint64_t v3;

  v3 = *v1;
  *v1 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

_OWORD *std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>(uint64_t **a1, const void **a2, uint64_t a3)
{
  void **v5;
  _OWORD *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = (void **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, &v9, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = operator new(0x38uLL);
    v6[2] = *(_OWORD *)a3;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a3 + 16);
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

uint64_t *std::set<std::string>::set[abi:ne180100](uint64_t *a1, const void ***a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::set<std::string>::insert[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(a1, *a2, a2 + 1);
  return a1;
}

void sub_1E05D3D9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::set<std::string>::insert[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(uint64_t *result, const void **a2, const void ***a3)
{
  const void **v4;
  uint64_t **v5;
  uint64_t *v6;
  const void **v7;
  const void ***v8;
  BOOL v9;

  if (a2 != (const void **)a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<std::string>::__emplace_hint_unique_key_args<std::string,std::string const&>(v5, v6, v4 + 4, (uint64_t)(v4 + 4));
      v7 = (const void **)v4[1];
      if (v7)
      {
        do
        {
          v8 = (const void ***)v7;
          v7 = (const void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (const void ***)v4[2];
          v9 = *v8 == v4;
          v4 = (const void **)v8;
        }
        while (!v9);
      }
      v4 = (const void **)v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<std::string>::__emplace_hint_unique_key_args<std::string,std::string const&>(uint64_t **a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;
  const void **v10;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__find_equal<std::string>(a1, a2, &v10, &v9, a3);
  result = *v6;
  if (!*v6)
  {
    std::__tree<std::string>::__construct_node<std::string const&>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

void std::__tree<std::string>::__construct_node<std::string const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x38uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v7->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 16);
  }
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_1E05D3F38(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,MIL::IRValueType const*>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void std::__function::__func<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1},std::allocator<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1}>,BOOL ()(std::string const&)>::~__func()
{
  JUMPOUT(0x1E0C023A0);
}

_QWORD *std::__function::__func<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1},std::allocator<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1}>,BOOL ()(std::string const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA999968;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1},std::allocator<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1}>,BOOL ()(std::string const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA999968;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1},std::allocator<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1}>,BOOL ()(std::string const&)>::operator()(uint64_t a1, char **a2)
{
  return std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:ne180100]<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1} &,std::string const&>((char ***)(a1 + 8), a2);
}

uint64_t std::__function::__func<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1},std::allocator<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1}>,BOOL ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1},std::allocator<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1}>,BOOL ()(std::string const&)>::target_type()
{
}

uint64_t std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:ne180100]<MIL::Attributes::BuildInfo::Impl::TryGetValuesMatching(std::string const&)::{lambda(std::string const&)#1} &,std::string const&>(char ***a1, char **a2)
{
  char **v2;
  char *v3;
  char *v4;
  int v5;
  char **v6;
  int64_t v7;
  char *v8;
  char *v9;
  int v12;
  void *v13;
  char *v14;
  char *v15;

  v2 = *a1;
  v3 = (char *)*((unsigned __int8 *)a2 + 23);
  if ((char)v3 >= 0)
    v4 = (char *)a2;
  else
    v4 = *a2;
  v5 = *((char *)v2 + 23);
  if (v5 >= 0)
    v6 = *a1;
  else
    v6 = (char **)*v2;
  if (v5 >= 0)
    v7 = *((unsigned __int8 *)v2 + 23);
  else
    v7 = (int64_t)v2[1];
  if (!v7)
    return 1;
  if ((char)v3 < 0)
    v3 = a2[1];
  v8 = &v3[(_QWORD)v4];
  if ((uint64_t)v3 >= v7)
  {
    v12 = *(char *)v6;
    v13 = v4;
    do
    {
      v14 = &v3[-v7];
      if (v14 == (char *)-1)
        break;
      v15 = (char *)memchr(v13, v12, (size_t)(v14 + 1));
      if (!v15)
        break;
      v9 = v15;
      if (!memcmp(v15, v6, v7))
        return v9 != v8 && v9 == v4;
      v13 = v9 + 1;
      v3 = (char *)(v8 - (v9 + 1));
    }
    while ((uint64_t)v3 >= v7);
  }
  v9 = v8;
  return v9 != v8 && v9 == v4;
}

std::regex_traits<char> *std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>(std::regex_traits<char> *a1, uint64_t a2, int a3)
{
  std::regex_traits<char> *v6;
  uint64_t v7;
  std::basic_regex<char> *v8;

  v6 = std::regex_traits<char>::regex_traits(a1);
  LODWORD(v6[1].__loc_.__locale_) = a3;
  *(_OWORD *)((char *)&v6[1].__loc_.__locale_ + 4) = 0u;
  *(_OWORD *)((char *)&v6[1].__col_ + 4) = 0u;
  HIDWORD(v6[2].__ct_) = 0;
  v7 = *(unsigned __int8 *)(a2 + 23);
  if ((v7 & 0x80u) == 0)
    v8 = (std::basic_regex<char> *)a2;
  else
    v8 = *(std::basic_regex<char> **)a2;
  if ((v7 & 0x80u) != 0)
    v7 = *(_QWORD *)(a2 + 8);
  if ((std::basic_regex<char> *)((char *)v8 + v7) != std::basic_regex<char,std::regex_traits<char>>::__parse<std::__wrap_iter<char const*>>((uint64_t)v6, v8, (std::basic_regex<char> *)((char *)v8 + v7)))std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)17>();
  return a1;
}

void sub_1E05D4160(_Unwind_Exception *a1)
{
  std::locale *v1;

  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&v1[5]);
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

std::regex_traits<char> *__cdecl std::regex_traits<char>::regex_traits(std::regex_traits<char> *this)
{
  const std::locale *v2;

  v2 = (const std::locale *)MEMORY[0x1E0C02298]();
  this->__ct_ = (const std::ctype<char> *)std::locale::use_facet(v2, MEMORY[0x1E0DE4A90]);
  this->__col_ = (const std::collate<char> *)std::locale::use_facet(&this->__loc_, MEMORY[0x1E0DE4C08]);
  return this;
}

void sub_1E05D41C4(_Unwind_Exception *a1)
{
  std::locale *v1;

  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse<std::__wrap_iter<char const*>>(uint64_t a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  unsigned int v8;

  v6 = (_QWORD *)operator new();
  *v6 = &unk_1EA9999F8;
  v7 = (_QWORD *)operator new();
  v7[1] = v6;
  std::shared_ptr<std::__empty_state<char>>::reset[abi:ne180100]<std::__empty_state<char>,void>((_QWORD *)(a1 + 40), (uint64_t)v7);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a1 + 40);
  v8 = *(_DWORD *)(a1 + 24) & 0x1F0;
  if (v8 > 0x3F)
  {
    switch(v8)
    {
      case 0x40u:
        return std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<std::__wrap_iter<char const*>>((std::basic_regex<char> *)a1, a2, a3);
      case 0x80u:
        return (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_grep<std::__wrap_iter<char const*>>((std::basic_regex<char> *)a1, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
      case 0x100u:
        return std::basic_regex<char,std::regex_traits<char>>::__parse_egrep<std::__wrap_iter<char const*>>((std::basic_regex<char> *)a1, a2, a3);
      default:
        goto LABEL_14;
    }
  }
  else if (v8)
  {
    if (v8 != 16)
    {
      if (v8 != 32)
LABEL_14:
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)14>();
      return std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<std::__wrap_iter<char const*>>((std::basic_regex<char> *)a1, a2, a3);
    }
    return (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<std::__wrap_iter<char const*>>(a1, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
  }
  else
  {
    return (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<std::__wrap_iter<char const*>>((std::basic_regex<char> *)a1, (unsigned __int8 *)a2, (char *)a3);
  }
}

void sub_1E05D432C(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)17>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1E0C01FC8](exception, 17);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1E05D4380(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::shared_ptr<std::__empty_state<char>>::reset[abi:ne180100]<std::__empty_state<char>,void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  std::shared_ptr<std::__empty_state<char>>::shared_ptr[abi:ne180100]<std::__empty_state<char>,void>(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<std::__wrap_iter<char const*>>(std::basic_regex<char> *a1, unsigned __int8 *a2, char *a3)
{
  std::__owns_one_state<char> *end;
  unsigned __int8 *v7;
  std::__node<char> *v8;
  std::__owns_one_state<char> *v9;
  std::__node<char> *first;
  std::__owns_one_state<char> *v11;
  unsigned __int8 *v12;
  std::__node<char> *v13;
  std::__owns_one_state<char> *v14;
  std::__node<char> *v15;

  end = a1->__end_;
  v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_alternative<std::__wrap_iter<char const*>>(a1, a2, a3);
  if (v7 == a2)
  {
    v8 = (std::__node<char> *)operator new();
    v9 = a1->__end_;
    first = v9->__first_;
    v8[1].__vftable = (std::__node<char>_vtbl *)first;
    v9->__first_ = v8;
    a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
  }
  if (v7 == (unsigned __int8 *)a3)
    return a3;
  while (*v7 == 124)
  {
    v11 = a1->__end_;
    v12 = v7 + 1;
    v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_alternative<std::__wrap_iter<char const*>>(a1, v7 + 1, a3);
    if (v12 == v7)
    {
      v13 = (std::__node<char> *)operator new();
      v14 = a1->__end_;
      v15 = v14->__first_;
      v13[1].__vftable = (std::__node<char>_vtbl *)v15;
      v14->__first_ = v13;
      a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v11);
    if (v7 == (unsigned __int8 *)a3)
      return a3;
  }
  return (char *)v7;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<std::__wrap_iter<char const*>>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  char *v4;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;

  v3 = a2;
  if (a2 == a3)
    return (char *)a2;
  v4 = (char *)a3;
  if (*a2 == 94)
  {
    v6 = operator new();
    v7 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
    v8 = *(_QWORD *)(a1 + 56);
    v9 = *(_QWORD *)(v8 + 8);
    *(_QWORD *)v6 = &unk_1EA999B70;
    *(_QWORD *)(v6 + 8) = v9;
    *(_BYTE *)(v6 + 16) = v7;
    *(_QWORD *)(v8 + 8) = v6;
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    ++v3;
  }
  if (v3 != (unsigned __int8 *)v4)
  {
    do
    {
      v10 = v3;
      v3 = std::basic_regex<char,std::regex_traits<char>>::__parse_simple_RE<std::__wrap_iter<char const*>>((std::basic_regex<char> *)a1, (char *)v3, v4);
    }
    while (v10 != v3);
    if (v10 != v4)
    {
      if (v10 + 1 != v4 || *v10 != 36)
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
      v11 = operator new();
      v12 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
      v13 = *(_QWORD *)(a1 + 56);
      v14 = *(_QWORD *)(v13 + 8);
      *(_QWORD *)v11 = &unk_1EA999BB8;
      *(_QWORD *)(v11 + 8) = v14;
      *(_BYTE *)(v11 + 16) = v12;
      *(_QWORD *)(v13 + 8) = v11;
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    }
  }
  return v4;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<std::__wrap_iter<char const*>>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  std::__owns_one_state<char> *end;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  std::__owns_one_state<char> *v9;
  unsigned __int8 *v10;

  end = a1->__end_;
  v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<std::__wrap_iter<char const*>>((uint64_t)a1, a2, a3);
  if (v7 == (unsigned __int8 *)a2)
LABEL_9:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
  v8 = v7;
  while (v8 != (unsigned __int8 *)a3)
  {
    if (*v8 != 124)
      return (std::basic_regex<char> *)v8;
    v9 = a1->__end_;
    v10 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<std::__wrap_iter<char const*>>((uint64_t)a1, (std::basic_regex<char> *)(v8 + 1), a3);
    if (v8 + 1 == v10)
      goto LABEL_9;
    v8 = v10;
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v9);
  }
  return a3;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_grep<std::__wrap_iter<char const*>>(std::basic_regex<char> *a1, unsigned __int8 *__s, unsigned __int8 *a3)
{
  std::__owns_one_state<char> *end;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  std::__node<char> *v9;
  std::__owns_one_state<char> *v10;
  std::__node<char> *first;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  std::__owns_one_state<char> *v15;
  std::__node<char> *v16;
  std::__owns_one_state<char> *v17;
  std::__node<char> *v18;

  end = a1->__end_;
  v7 = (unsigned __int8 *)memchr(__s, 10, a3 - __s);
  if (v7)
    v8 = v7;
  else
    v8 = a3;
  if (v8 == __s)
  {
    v9 = (std::__node<char> *)operator new();
    v10 = a1->__end_;
    first = v10->__first_;
    v9[1].__vftable = (std::__node<char>_vtbl *)first;
    v10->__first_ = v9;
    a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
  }
  else
  {
    std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<std::__wrap_iter<char const*>>((uint64_t)a1, __s, v8);
  }
  if (v8 == a3)
    v12 = v8;
  else
    v12 = v8 + 1;
  while (v12 != a3)
  {
    v13 = (unsigned __int8 *)memchr(v12, 10, a3 - v12);
    if (v13)
      v14 = v13;
    else
      v14 = a3;
    v15 = a1->__end_;
    if (v14 == v12)
    {
      v16 = (std::__node<char> *)operator new();
      v17 = a1->__end_;
      v18 = v17->__first_;
      v16[1].__vftable = (std::__node<char>_vtbl *)v18;
      v17->__first_ = v16;
      a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
    }
    else
    {
      std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<std::__wrap_iter<char const*>>((uint64_t)a1, v12, v14);
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v15);
    if (v14 == a3)
      v12 = v14;
    else
      v12 = v14 + 1;
  }
  return a3;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_egrep<std::__wrap_iter<char const*>>(std::basic_regex<char> *a1, std::basic_regex<char> *__s, std::basic_regex<char> *a3)
{
  std::__owns_one_state<char> *end;
  std::basic_regex<char> *v7;
  std::basic_regex<char> *v8;
  std::__node<char> *v9;
  std::__owns_one_state<char> *v10;
  std::__node<char> *first;
  std::basic_regex<char> *v12;
  std::basic_regex<char> *v13;
  std::basic_regex<char> *v14;
  std::__owns_one_state<char> *v15;
  std::__node<char> *v16;
  std::__owns_one_state<char> *v17;
  std::__node<char> *v18;

  end = a1->__end_;
  v7 = (std::basic_regex<char> *)memchr(__s, 10, (char *)a3 - (char *)__s);
  if (v7)
    v8 = v7;
  else
    v8 = a3;
  if (v8 == __s)
  {
    v9 = (std::__node<char> *)operator new();
    v10 = a1->__end_;
    first = v10->__first_;
    v9[1].__vftable = (std::__node<char>_vtbl *)first;
    v10->__first_ = v9;
    a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
  }
  else
  {
    std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<std::__wrap_iter<char const*>>(a1, __s, v8);
  }
  if (v8 == a3)
    v12 = v8;
  else
    v12 = (std::basic_regex<char> *)((char *)&v8->__traits_.__loc_.__locale_ + 1);
  while (v12 != a3)
  {
    v13 = (std::basic_regex<char> *)memchr(v12, 10, (char *)a3 - (char *)v12);
    if (v13)
      v14 = v13;
    else
      v14 = a3;
    v15 = a1->__end_;
    if (v14 == v12)
    {
      v16 = (std::__node<char> *)operator new();
      v17 = a1->__end_;
      v18 = v17->__first_;
      v16[1].__vftable = (std::__node<char>_vtbl *)v18;
      v17->__first_ = v16;
      a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
    }
    else
    {
      std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<std::__wrap_iter<char const*>>(a1, v12, v14);
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v15);
    if (v14 == a3)
      v12 = v14;
    else
      v12 = (std::basic_regex<char> *)((char *)&v14->__traits_.__loc_.__locale_ + 1);
  }
  return a3;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)14>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1E0C01FC8](exception, 14);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1E05D49F8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__end_state<char>::~__end_state()
{
  JUMPOUT(0x1E0C023A0);
}

void std::__end_state<char>::__exec(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

_QWORD *std::shared_ptr<std::__empty_state<char>>::shared_ptr[abi:ne180100]<std::__empty_state<char>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1EA999A50;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1E05D4A90(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<std::__empty_state<char> *,std::shared_ptr<std::__empty_state<char>>::__shared_ptr_default_delete<std::__empty_state<char>,std::__empty_state<char>>,std::allocator<std::__empty_state<char>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__shared_ptr_pointer<std::__empty_state<char> *,std::shared_ptr<std::__empty_state<char>>::__shared_ptr_default_delete<std::__empty_state<char>,std::__empty_state<char>>,std::allocator<std::__empty_state<char>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<std::__empty_state<char> *,std::shared_ptr<std::__empty_state<char>>::__shared_ptr_default_delete<std::__empty_state<char>,std::__empty_state<char>>,std::allocator<std::__empty_state<char>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void (__cdecl ***std::__empty_state<char>::~__empty_state(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__empty_state<char>::~__empty_state(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1E0C023A0);
}

void std::__empty_state<char>::__exec(const std::__empty_state<char> *this, std::__empty_state<char>::__state *a2)
{
  a2->__do_ = -994;
  a2->__node_ = this->__first_;
}

void std::__owns_one_state<char>::~__owns_one_state(std::__owns_one_state<char> *this)
{
  std::__node<char> *first;

  first = this->__first_;
  if (first)
    ((void (*)(std::__node<char> *))first->~__node_0)(first);
}

{
  std::__node<char> *first;

  first = this->__first_;
  if (first)
    ((void (*)(std::__node<char> *))first->~__node_0)(first);
  JUMPOUT(0x1E0C023A0);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_alternative<std::__wrap_iter<char const*>>(std::basic_regex<char> *a1, unsigned __int8 *a2, char *a3)
{
  unsigned __int8 *v5;

  do
  {
    v5 = a2;
    a2 = std::basic_regex<char,std::regex_traits<char>>::__parse_term<std::__wrap_iter<char const*>>(a1, (char *)a2, a3);
  }
  while (v5 != a2);
  return v5;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_alternation(std::basic_regex<char> *this, std::__owns_one_state<char> *__sa, std::__owns_one_state<char> *__sb)
{
  std::__node<char> *v6;
  std::__node<char> *first;
  std::__node<char> *v8;
  std::__node<char> *v9;
  std::__node<char> *v10;
  std::__node<char> *v11;

  v6 = (std::__node<char> *)operator new();
  first = __sb->__first_;
  v6[1].__vftable = (std::__node<char>_vtbl *)__sa->__first_;
  v6[2].__vftable = (std::__node<char>_vtbl *)first;
  v6->__vftable = (std::__node<char>_vtbl *)&unk_1EA99A038;
  __sa->__first_ = v6;
  __sb->__first_ = 0;
  v8 = (std::__node<char> *)operator new();
  v9 = this->__end_->__first_;
  v8[1].__vftable = (std::__node<char>_vtbl *)v9;
  __sb->__first_ = v8;
  this->__end_->__first_ = 0;
  v10 = (std::__node<char> *)operator new();
  v11 = __sb->__first_;
  v10->__vftable = (std::__node<char>_vtbl *)&unk_1EA99A080;
  v10[1].__vftable = (std::__node<char>_vtbl *)v11;
  this->__end_->__first_ = v10;
  this->__end_ = (std::__owns_one_state<char> *)__sb->__first_;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_term<std::__wrap_iter<char const*>>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  unsigned __int8 *result;
  std::__owns_one_state<char> *end;
  unsigned int marked_count;
  unsigned __int8 *v9;

  result = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<std::__wrap_iter<char const*>>(a1, a2, a3);
  if (result == (unsigned __int8 *)a2)
  {
    end = a1->__end_;
    marked_count = a1->__marked_count_;
    v9 = std::basic_regex<char,std::regex_traits<char>>::__parse_atom<std::__wrap_iter<char const*>>(a1, (unsigned __int8 *)a2, a3);
    result = (unsigned __int8 *)a2;
    if (v9 != (unsigned __int8 *)a2)
      return std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<std::__wrap_iter<char const*>>((uint64_t)a1, v9, (unsigned __int8 *)a3, end, marked_count + 1, a1->__marked_count_ + 1);
  }
  return result;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<std::__wrap_iter<char const*>>(std::basic_regex<char> *this, char *a2, char *a3)
{
  char *v3;
  int v6;
  int v7;
  char *v8;
  unsigned int v9;
  uint64_t v10;
  BOOL v11;
  std::__owns_one_state<char> *end;
  std::__node<char> *first;
  char *v14;
  int v16;
  BOOL v17;
  unsigned int marked_count;
  std::basic_regex<char> v19;

  v3 = a2;
  if (a2 == a3)
    return v3;
  v6 = *a2;
  if (v6 <= 91)
  {
    if (v6 != 36)
    {
      if (v6 == 40 && a2 + 1 != a3 && a2[1] == 63 && a2 + 2 != a3)
      {
        v7 = a2[2];
        if (v7 == 33)
        {
          std::regex_traits<char>::regex_traits(&v19.__traits_);
          memset(&v19.__flags_, 0, 40);
          v19.__flags_ = this->__flags_;
          v8 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse<std::__wrap_iter<char const*>>(&v19, v3 + 3, a3);
          marked_count = v19.__marked_count_;
          std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(this, &v19, 1, this->__marked_count_);
          this->__marked_count_ += marked_count;
          if (v8 == a3 || *v8 != 41)
            std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
          goto LABEL_27;
        }
        if (v7 == 61)
        {
          std::regex_traits<char>::regex_traits(&v19.__traits_);
          memset(&v19.__flags_, 0, 40);
          v19.__flags_ = this->__flags_;
          v8 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse<std::__wrap_iter<char const*>>(&v19, v3 + 3, a3);
          v9 = v19.__marked_count_;
          std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(this, &v19, 0, this->__marked_count_);
          this->__marked_count_ += v9;
          if (v8 == a3 || *v8 != 41)
            std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
LABEL_27:
          v3 = v8 + 1;
          std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&v19.__start_);
          std::locale::~locale(&v19.__traits_.__loc_);
          return v3;
        }
      }
      return v3;
    }
    v10 = operator new();
    v11 = (this->__flags_ & 0x5F0) == 1024;
    end = this->__end_;
    first = end->__first_;
LABEL_17:
    *(_QWORD *)v10 = v14 + 16;
    *(_QWORD *)(v10 + 8) = first;
    *(_BYTE *)(v10 + 16) = v11;
    end->__first_ = (std::__node<char> *)v10;
    this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
    return ++v3;
  }
  if (v6 != 92)
  {
    if (v6 != 94)
      return v3;
    v10 = operator new();
    v11 = (this->__flags_ & 0x5F0) == 1024;
    end = this->__end_;
    first = end->__first_;
    goto LABEL_17;
  }
  if (a2 + 1 != a3)
  {
    v16 = a2[1];
    if (v16 == 66)
    {
      v17 = 1;
    }
    else
    {
      if (v16 != 98)
        return v3;
      v17 = 0;
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_word_boundary(this, v17);
    v3 += 2;
  }
  return v3;
}

void sub_1E05D50B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)&a14);
  std::locale::~locale(&a9);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_atom<std::__wrap_iter<char const*>>(std::basic_regex<char> *this, unsigned __int8 *a2, char *a3)
{
  unsigned __int8 *v3;
  int v6;
  std::__node<char> *v7;
  std::__owns_one_state<char> *end;
  std::__node<char> *first;
  _BYTE *v11;
  char *v12;
  unsigned int marked_count;
  char *v14;
  char *v15;

  v3 = a2;
  if (a2 != (unsigned __int8 *)a3)
  {
    v6 = (char)*a2;
    if (v6 <= 62)
    {
      if (v6 == 40)
      {
        v11 = a2 + 1;
        if (a2 + 1 != (unsigned __int8 *)a3)
        {
          if (a2 + 2 != (unsigned __int8 *)a3 && *v11 == 63 && a2[2] == 58)
          {
            ++this->__open_count_;
            v12 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<std::__wrap_iter<char const*>>(this, a2 + 3, a3);
            if (v12 != a3 && *v12 == 41)
            {
              --this->__open_count_;
              return (unsigned __int8 *)(v12 + 1);
            }
          }
          else
          {
            std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(this);
            marked_count = this->__marked_count_;
            ++this->__open_count_;
            v14 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<std::__wrap_iter<char const*>>(this, v11, a3);
            if (v14 != a3)
            {
              v15 = v14;
              if (*v14 == 41)
              {
                std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(this, marked_count);
                --this->__open_count_;
                return (unsigned __int8 *)(v15 + 1);
              }
            }
          }
        }
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
      }
      if (v6 == 46)
      {
        v7 = (std::__node<char> *)operator new();
        end = this->__end_;
        first = end->__first_;
        v7->__vftable = (std::__node<char>_vtbl *)&unk_1EA999C90;
        v7[1].__vftable = (std::__node<char>_vtbl *)first;
        end->__first_ = v7;
        this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
        return ++v3;
      }
      if ((v6 - 42) >= 2)
        return std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<std::__wrap_iter<char const*>>(this, a2, a3);
LABEL_28:
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)11>();
    }
    if (v6 > 91)
    {
      if (v6 == 92)
        return std::basic_regex<char,std::regex_traits<char>>::__parse_atom_escape<std::__wrap_iter<char const*>>(this, a2, (unsigned __int8 *)a3);
      if (v6 == 123)
        goto LABEL_28;
    }
    else
    {
      if (v6 == 91)
        return (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<std::__wrap_iter<char const*>>((uint64_t)this, (char *)a2, a3);
      if (v6 == 63)
        goto LABEL_28;
    }
    return std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<std::__wrap_iter<char const*>>(this, a2, a3);
  }
  return v3;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<std::__wrap_iter<char const*>>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, std::__owns_one_state<char> *__s, size_t a5, size_t a6)
{
  unsigned int v6;
  unsigned int v7;
  uint64_t v10;
  int v11;
  int v12;
  unsigned __int8 *v13;
  size_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v17;
  size_t v18;
  BOOL v19;
  BOOL v20;
  std::__owns_one_state<char> *v21;
  BOOL v22;
  unsigned __int8 *v23;
  unsigned __int8 *v25;
  int v26;
  int v27;
  size_t __max;

  if (a2 == a3)
    return a2;
  v6 = a6;
  v7 = a5;
  v10 = a1;
  v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  v12 = (char)*a2;
  if (v12 > 62)
  {
    if (v12 == 63)
    {
      v13 = a2 + 1;
      if (v11)
        v20 = 1;
      else
        v20 = v13 == a3;
      if (!v20 && *v13 == 63)
      {
        v13 = a2 + 2;
        a5 = a5;
        a6 = a6;
        v14 = 0;
        v18 = 1;
        goto LABEL_33;
      }
      a5 = a5;
      a6 = a6;
      v14 = 0;
      v18 = 1;
      goto LABEL_45;
    }
    v13 = a2;
    if (v12 != 123)
      return v13;
    v15 = a2 + 1;
    v16 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<std::__wrap_iter<char const*>>(a1, a2 + 1, a3, (int *)&__max);
    if (v15 != v16)
    {
      if (v16 != a3)
      {
        v17 = (char)*v16;
        if (v17 != 44)
        {
          if (v17 == 125)
          {
            v13 = v16 + 1;
            if (!v11 && v13 != a3 && *v13 == 63)
            {
              v13 = v16 + 2;
              v14 = (int)__max;
              a5 = v7;
              a6 = v6;
              a1 = v10;
              v18 = (int)__max;
LABEL_33:
              v21 = __s;
              v22 = 0;
LABEL_46:
              std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, v14, v18, v21, a5, a6, v22);
              return v13;
            }
            v14 = (int)__max;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            v18 = (int)__max;
LABEL_45:
            v21 = __s;
            v22 = 1;
            goto LABEL_46;
          }
          goto LABEL_58;
        }
        v23 = v16 + 1;
        if (v16 + 1 == a3)
          goto LABEL_58;
        if (*v23 == 125)
        {
          v13 = v16 + 2;
          if (!v11 && v13 != a3 && *v13 == 63)
          {
            v13 = v16 + 3;
            v14 = (int)__max;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            goto LABEL_26;
          }
          v14 = (int)__max;
          a5 = v7;
          a6 = v6;
          a1 = v10;
LABEL_36:
          v18 = -1;
          goto LABEL_45;
        }
        v27 = -1;
        v25 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<std::__wrap_iter<char const*>>(v10, v23, a3, &v27);
        if (v23 != v25 && v25 != a3 && *v25 == 125)
        {
          v18 = v27;
          v14 = (int)__max;
          if (v27 >= (int)__max)
          {
            v13 = v25 + 1;
            v22 = 1;
            if (!v11 && v13 != a3)
            {
              v26 = v25[1];
              v22 = v26 != 63;
              if (v26 == 63)
                v13 = v25 + 2;
            }
            a5 = v7;
            a6 = v6;
            a1 = v10;
            v21 = __s;
            goto LABEL_46;
          }
          goto LABEL_58;
        }
      }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)7>();
    }
LABEL_58:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>();
  }
  if (v12 == 42)
  {
    v13 = a2 + 1;
    if (v11)
      v19 = 1;
    else
      v19 = v13 == a3;
    if (!v19 && *v13 == 63)
    {
      v13 = a2 + 2;
      a5 = a5;
      a6 = a6;
      v14 = 0;
      goto LABEL_26;
    }
    a5 = a5;
    a6 = a6;
    v14 = 0;
    goto LABEL_36;
  }
  v13 = a2;
  if (v12 == 43)
  {
    v13 = a2 + 1;
    if (!v11 && v13 != a3 && *v13 == 63)
    {
      v13 = a2 + 2;
      a5 = a5;
      a6 = a6;
      v14 = 1;
LABEL_26:
      v18 = -1;
      goto LABEL_33;
    }
    a5 = a5;
    a6 = a6;
    v14 = 1;
    goto LABEL_36;
  }
  return v13;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_word_boundary(std::basic_regex<char> *this, BOOL a2)
{
  uint64_t v4;
  std::__node<char> *first;

  v4 = operator new();
  first = this->__end_->__first_;
  *(_QWORD *)v4 = &unk_1EA999C00;
  *(_QWORD *)(v4 + 8) = first;
  std::locale::locale((std::locale *)(v4 + 16), &this->__traits_.__loc_);
  *(_OWORD *)(v4 + 24) = *(_OWORD *)&this->__traits_.__ct_;
  *(_BYTE *)(v4 + 40) = a2;
  this->__end_->__first_ = (std::__node<char> *)v4;
  this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(std::basic_regex<char> *this, const std::basic_regex<char> *a2, BOOL a3, unsigned int a4)
{
  std::__node<char> *v8;

  v8 = (std::__node<char> *)operator new();
  std::__lookahead<char,std::regex_traits<char>>::__lookahead[abi:ne180100]((uint64_t)v8, (uint64_t)a2, a3, (uint64_t)this->__end_->__first_, a4);
  this->__end_->__first_ = v8;
  this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
}

void sub_1E05D56D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1E0C023A0](v1, 0x10E1C4030FC3181);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1E0C01FC8](exception, 6);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1E05D5730(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void (__cdecl ***std::__l_anchor_multiline<char>::~__l_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__l_anchor_multiline<char>::~__l_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__l_anchor_multiline<char>::__exec(uint64_t result, uint64_t a2)
{
  int v2;
  uint64_t v4;

  if (*(_BYTE *)(a2 + 92))
  {
    if (*(_QWORD *)(a2 + 16) != *(_QWORD *)(a2 + 8) || (*(_BYTE *)(a2 + 88) & 1) != 0)
    {
LABEL_12:
      v4 = 0;
      *(_DWORD *)a2 = -993;
      goto LABEL_13;
    }
  }
  else
  {
    if (!*(_BYTE *)(result + 16))
      goto LABEL_12;
    v2 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 16) - 1);
    if (v2 != 13 && v2 != 10)
      goto LABEL_12;
  }
  *(_DWORD *)a2 = -994;
  v4 = *(_QWORD *)(result + 8);
LABEL_13:
  *(_QWORD *)(a2 + 80) = v4;
  return result;
}

void (__cdecl ***std::__r_anchor_multiline<char>::~__r_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  void (__cdecl **v2)(std::__owns_one_state<char> *__hidden);

  v2 = a1[1];
  if (v2)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  return a1;
}

void std::__r_anchor_multiline<char>::~__r_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  void (__cdecl **v1)(std::__owns_one_state<char> *__hidden);

  v1 = a1[1];
  if (v1)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__r_anchor_multiline<char>::__exec(uint64_t result, uint64_t a2)
{
  unsigned __int8 *v2;
  int v3;
  BOOL v4;
  uint64_t v5;

  v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) && (*(_BYTE *)(a2 + 88) & 2) == 0
    || *(_BYTE *)(result + 16) && ((v3 = *v2, v3 != 13) ? (v4 = v3 == 10) : (v4 = 1), v4))
  {
    *(_DWORD *)a2 = -994;
    v5 = *(_QWORD *)(result + 8);
  }
  else
  {
    v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(_QWORD *)(a2 + 80) = v5;
  return result;
}

std::locale *std::__word_boundary<char,std::regex_traits<char>>::~__word_boundary(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1EA999C00;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  return a1;
}

void std::__word_boundary<char,std::regex_traits<char>>::~__word_boundary(std::locale *a1)
{
  std::locale::__imp *locale;

  a1->__locale_ = (std::locale::__imp *)&unk_1EA999C00;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale)
    (*(void (**)(std::locale::__imp *))(*(_QWORD *)locale + 8))(locale);
  JUMPOUT(0x1E0C023A0);
}

uint64_t std::__word_boundary<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;

  v2 = *(unsigned __int8 **)(a2 + 8);
  v3 = *(unsigned __int8 **)(a2 + 24);
  if (v2 == v3)
    goto LABEL_17;
  v4 = *(unsigned __int8 **)(a2 + 16);
  if (v4 == v3)
  {
    if ((*(_BYTE *)(a2 + 88) & 8) == 0)
    {
      v6 = *(v3 - 1);
      goto LABEL_13;
    }
LABEL_17:
    v10 = 0;
    goto LABEL_25;
  }
  if (v4 == v2)
  {
    v5 = *(_DWORD *)(a2 + 88);
    if ((v5 & 0x80) == 0)
    {
      if ((v5 & 4) == 0)
      {
        v6 = *v2;
LABEL_13:
        if (v6 == 95
          || (v6 & 0x80) == 0 && (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 24) + 16) + 4 * v6) & 0x500) != 0)
        {
          v10 = 1;
          goto LABEL_25;
        }
        goto LABEL_17;
      }
      goto LABEL_17;
    }
  }
  v7 = *(v4 - 1);
  v8 = *v4;
  v9 = v7 == 95 || (v7 & 0x80) == 0 && (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 24) + 16) + 4 * v7) & 0x500) != 0;
  v11 = (_DWORD)v8 == 95
     || (v8 & 0x80) == 0 && (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 24) + 16) + 4 * v8) & 0x500) != 0;
  v10 = v9 != v11;
LABEL_25:
  if (*(unsigned __int8 *)(result + 40) == v10)
  {
    v12 = 0;
    v13 = -993;
  }
  else
  {
    v12 = *(_QWORD *)(result + 8);
    v13 = -994;
  }
  *(_DWORD *)a2 = v13;
  *(_QWORD *)(a2 + 80) = v12;
  return result;
}

uint64_t std::__lookahead<char,std::regex_traits<char>>::__lookahead[abi:ne180100](uint64_t a1, uint64_t a2, char a3, uint64_t a4, int a5)
{
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  *(_QWORD *)a1 = &unk_1EA999C48;
  *(_QWORD *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 24);
  v9 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 64) = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 80) = a5;
  *(_BYTE *)(a1 + 84) = a3;
  return a1;
}

void (__cdecl ***std::__lookahead<char,std::regex_traits<char>>::~__lookahead(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  std::locale *v2;
  void (__cdecl **v3)(std::__owns_one_state<char> *__hidden);

  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1EA999C48;
  v2 = (std::locale *)(a1 + 2);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 7));
  std::locale::~locale(v2);
  v3 = a1[1];
  if (v3)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  return a1;
}

void std::__lookahead<char,std::regex_traits<char>>::~__lookahead(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  std::locale *v2;
  void (__cdecl **v3)(std::__owns_one_state<char> *__hidden);

  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1EA999C48;
  v2 = (std::locale *)(a1 + 2);
  std::shared_ptr<MIL::IRValue const>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 7));
  std::locale::~locale(v2);
  v3 = a1[1];
  if (v3)
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  JUMPOUT(0x1E0C023A0);
}

void std::__lookahead<char,std::regex_traits<char>>::__exec(uint64_t a1, uint64_t a2)
{
  std::vector<std::csub_match>::size_type v4;
  uint64_t v5;
  const char *v6;
  BOOL v7;
  char v8;
  std::sub_match<const char *> *begin;
  unint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  std::sub_match<const char *> *v15;
  uint64_t v16;
  std::vector<std::csub_match> __p;
  std::vector<std::csub_match>::value_type v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  std::vector<std::csub_match>::value_type v22;
  char v23;
  uint64_t v24;

  v19 = 0;
  v20 = 0;
  v21 = 0;
  memset(&v22, 0, 17);
  v23 = 0;
  v24 = 0;
  memset(&__p, 0, sizeof(__p));
  v4 = (*(_DWORD *)(a1 + 44) + 1);
  v5 = *(_QWORD *)(a2 + 16);
  v18.first = *(const char **)(a2 + 24);
  v18.second = v18.first;
  v18.matched = 0;
  std::vector<std::sub_match<char const*>>::assign(&__p, v4, &v18);
  v19 = v5;
  v20 = v5;
  v21 = 0;
  v22 = v18;
  v24 = v5;
  v23 = 1;
  v6 = *(const char **)(a2 + 16);
  if (*(_BYTE *)(a2 + 92))
    v7 = v6 == *(const char **)(a2 + 8);
  else
    v7 = 0;
  v8 = v7;
  if (*(unsigned __int8 *)(a1 + 84) == std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1 + 16, v6, *(const char **)(a2 + 24), (uint64_t *)&__p, *(_DWORD *)(a2 + 88) & 0xFBF | 0x40u, v8))
  {
    *(_DWORD *)a2 = -993;
    *(_QWORD *)(a2 + 80) = 0;
    begin = __p.__begin_;
    goto LABEL_13;
  }
  *(_DWORD *)a2 = -994;
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(a1 + 8);
  begin = __p.__begin_;
  v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p.__end_ - (char *)__p.__begin_) >> 3);
  if (v10 < 2)
  {
LABEL_13:
    if (!begin)
      return;
    goto LABEL_14;
  }
  v11 = 0;
  v12 = *(_DWORD *)(a1 + 80);
  v13 = *(_QWORD *)(a2 + 32);
  v14 = 1;
  do
  {
    v15 = &begin[v14];
    v16 = v13 + 24 * (v12 + v11);
    *(std::pair<const char *, const char *> *)v16 = v15->std::pair<const char *, const char *>;
    *(_BYTE *)(v16 + 16) = v15->matched;
    v14 = (v11 + 2);
    ++v11;
  }
  while (v10 > v14);
LABEL_14:
  __p.__end_ = begin;
  operator delete(begin);
}

void sub_1E05D5DCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::match_results<char const*>::__init(std::match_results<const char *> *this, unsigned int __s, const char *__f, const char *__l, BOOL __no_update_pos)
{
  std::match_results<const char *>::value_type *p_unmatched;

  this->__unmatched_.first = __l;
  p_unmatched = &this->__unmatched_;
  this->__unmatched_.second = __l;
  this->__unmatched_.matched = 0;
  std::vector<std::sub_match<char const*>>::assign(&this->__matches_, __s, &this->__unmatched_);
  this->__prefix_.first = __f;
  this->__prefix_.second = __f;
  this->__prefix_.matched = 0;
  this->__suffix_ = *p_unmatched;
  if (!__no_update_pos)
    this->__position_start_ = __f;
  this->__ready_ = 1;
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(uint64_t a1, const char *a2, const char *a3, uint64_t *a4, int a5, char a6)
{
  uint64_t v6;
  _OWORD *v11;
  _OWORD *v12;
  unsigned int v13;
  uint64_t v14;
  _QWORD *v15;
  _OWORD *v16;
  const char *v17;
  _OWORD *v18;
  __int128 v19;
  uint64_t v20;
  _OWORD *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  _BYTE *v29;
  unsigned int v30;
  uint64_t v31;
  char v32;
  uint64_t *v34;
  _BYTE v37[56];
  void *__p[2];
  _QWORD v39[4];
  std::vector<std::csub_match>::value_type __x;
  _OWORD *v41;
  _OWORD *v42;
  unint64_t v43;

  v41 = 0;
  v42 = 0;
  v43 = 0;
  v6 = *(_QWORD *)(a1 + 40);
  if (v6)
  {
    __x.first = a3;
    __x.second = a3;
    __x.matched = 0;
    *(_DWORD *)v37 = 0;
    memset(&v37[8], 0, 48);
    *(_OWORD *)__p = 0u;
    memset(v39, 0, 21);
    v42 = (_OWORD *)std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((uint64_t *)&v41, (uint64_t)v37);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (*(_QWORD *)&v37[32])
    {
      *(_QWORD *)&v37[40] = *(_QWORD *)&v37[32];
      operator delete(*(void **)&v37[32]);
    }
    v34 = a4;
    v11 = v42;
    *((_DWORD *)v42 - 24) = 0;
    *((_QWORD *)v11 - 11) = a2;
    *((_QWORD *)v11 - 10) = a2;
    *((_QWORD *)v11 - 9) = a3;
    std::vector<std::sub_match<char const*>>::resize((std::vector<std::csub_match> *)(v11 - 4), *(unsigned int *)(a1 + 28), &__x);
    std::vector<std::pair<unsigned long,char const*>>::resize((std::vector<std::pair<unsigned long, const char *>> *)((char *)v42 - 40), *(unsigned int *)(a1 + 32));
    v12 = v42;
    *((_QWORD *)v42 - 2) = v6;
    *((_DWORD *)v12 - 2) = a5;
    *((_BYTE *)v12 - 4) = a6;
    v13 = 1;
    while (2)
    {
      if ((v13 & 0xFFF) == 0 && (int)(v13 >> 12) >= (int)a3 - (int)a2)
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>();
      v15 = v12 - 1;
      v14 = *((_QWORD *)v12 - 2);
      v16 = v12 - 6;
      if (v14)
        (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v14 + 16))(v14, v12 - 6);
      switch(*(_DWORD *)v16)
      {
        case 0xFFFFFC18:
          v17 = (const char *)*((_QWORD *)v12 - 10);
          if ((a5 & 0x20) != 0 && v17 == a2 || (a5 & 0x1000) != 0 && v17 != a3)
            goto LABEL_16;
          v25 = *v34;
          *(_QWORD *)v25 = a2;
          *(_QWORD *)(v25 + 8) = v17;
          *(_BYTE *)(v25 + 16) = 1;
          v26 = *((_QWORD *)v12 - 8);
          v27 = *((_QWORD *)v12 - 7) - v26;
          if (v27)
          {
            v28 = 0xAAAAAAAAAAAAAAABLL * (v27 >> 3);
            v29 = (_BYTE *)(v26 + 16);
            v30 = 1;
            do
            {
              v31 = v25 + 24 * v30;
              *(_OWORD *)v31 = *((_OWORD *)v29 - 1);
              v32 = *v29;
              v29 += 24;
              *(_BYTE *)(v31 + 16) = v32;
            }
            while (v28 > v30++);
          }
          v6 = 1;
          break;
        case 0xFFFFFC1D:
        case 0xFFFFFC1E:
        case 0xFFFFFC21:
          goto LABEL_23;
        case 0xFFFFFC1F:
LABEL_16:
          v18 = v42 - 6;
          std::allocator<std::__state<char>>::destroy[abi:ne180100]((uint64_t)&v43, (_QWORD *)v42 - 12);
          v42 = v18;
          goto LABEL_23;
        case 0xFFFFFC20:
          v19 = *(v12 - 5);
          *(_OWORD *)v37 = *v16;
          *(_OWORD *)&v37[16] = v19;
          memset(&v37[32], 0, 24);
          std::vector<std::sub_match<char const*>>::__init_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(&v37[32], *((__int128 **)v12 - 8), *((__int128 **)v12 - 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)v12 - 7) - *((_QWORD *)v12 - 8)) >> 3));
          __p[0] = 0;
          __p[1] = 0;
          v39[0] = 0;
          std::vector<std::pair<unsigned long,char const*>>::__init_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>((char *)__p, *((__int128 **)v12 - 5), *((__int128 **)v12 - 4), (uint64_t)(*((_QWORD *)v12 - 4) - *((_QWORD *)v12 - 5)) >> 4);
          v20 = *v15;
          *(_QWORD *)((char *)&v39[1] + 5) = *(_QWORD *)((char *)v12 - 11);
          v39[1] = v20;
          (*(void (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)*v15 + 24))(*v15, 1, v12 - 6);
          (*(void (**)(_QWORD, _QWORD, _BYTE *))(*(_QWORD *)v39[1] + 24))(v39[1], 0, v37);
          v21 = v42;
          if ((unint64_t)v42 >= v43)
          {
            v42 = (_OWORD *)std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((uint64_t *)&v41, (uint64_t)v37);
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
          }
          else
          {
            v22 = *(_OWORD *)&v37[16];
            *v42 = *(_OWORD *)v37;
            v21[1] = v22;
            *((_QWORD *)v21 + 4) = 0;
            *((_QWORD *)v21 + 5) = 0;
            *((_QWORD *)v21 + 6) = 0;
            *((_QWORD *)v21 + 7) = 0;
            v21[2] = *(_OWORD *)&v37[32];
            *((_QWORD *)v21 + 6) = *(_QWORD *)&v37[48];
            memset(&v37[32], 0, 24);
            *((_QWORD *)v21 + 8) = 0;
            *((_QWORD *)v21 + 9) = 0;
            *(_OWORD *)((char *)v21 + 56) = *(_OWORD *)__p;
            *((_QWORD *)v21 + 9) = v39[0];
            __p[0] = 0;
            __p[1] = 0;
            v39[0] = 0;
            v23 = v39[1];
            *(_QWORD *)((char *)v21 + 85) = *(_QWORD *)((char *)&v39[1] + 5);
            *((_QWORD *)v21 + 10) = v23;
            v42 = v21 + 6;
          }
          if (*(_QWORD *)&v37[32])
          {
            *(_QWORD *)&v37[40] = *(_QWORD *)&v37[32];
            operator delete(*(void **)&v37[32]);
          }
LABEL_23:
          v12 = v42;
          ++v13;
          if (v41 != v42)
            continue;
          v6 = 0;
          break;
        default:
          std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>();
      }
      break;
    }
  }
  *(_QWORD *)v37 = &v41;
  std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)v37);
  return v6;
}

void sub_1E05D6204(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  uint64_t v18;

  std::__state<char>::~__state(&a13);
  a13 = v18 - 112;
  std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  _Unwind_Resume(a1);
}

void std::vector<std::sub_match<char const*>>::assign(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __n, std::vector<std::csub_match>::const_reference __u)
{
  std::sub_match<const char *> *value;
  std::sub_match<const char *> *begin;
  unint64_t v8;
  std::vector<std::csub_match>::size_type v9;
  unint64_t v10;
  std::vector<std::csub_match>::pointer v11;
  std::sub_match<const char *> *v12;
  std::vector<std::csub_match>::size_type v13;
  std::pair<const char *, const char *> v14;
  std::vector<std::csub_match>::pointer end;
  std::vector<std::csub_match>::size_type v16;
  std::vector<std::csub_match>::size_type v17;
  std::vector<std::csub_match>::value_type *v18;
  std::sub_match<const char *> *v19;
  std::vector<std::csub_match>::size_type v20;
  std::pair<const char *, const char *> v21;

  value = this->__end_cap_.__value_;
  begin = this->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)begin) >> 3) >= __n)
  {
    end = this->__end_;
    v16 = end - begin;
    if (v16 >= __n)
      v17 = __n;
    else
      v17 = end - begin;
    if (v17)
    {
      v18 = begin;
      do
      {
        *v18++ = *__u;
        --v17;
      }
      while (v17);
    }
    if (__n <= v16)
    {
      this->__end_ = &begin[__n];
    }
    else
    {
      v19 = &end[__n - v16];
      v20 = 24 * __n - 24 * v16;
      do
      {
        v21 = __u->std::pair<const char *, const char *>;
        *(_QWORD *)&end->matched = *(_QWORD *)&__u->matched;
        end->std::pair<const char *, const char *> = v21;
        ++end;
        v20 -= 24;
      }
      while (v20);
      this->__end_ = v19;
    }
  }
  else
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n > 0xAAAAAAAAAAAAAAALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)value >> 3);
    v9 = 2 * v8;
    if (2 * v8 <= __n)
      v9 = __n;
    if (v8 >= 0x555555555555555)
      v10 = 0xAAAAAAAAAAAAAAALL;
    else
      v10 = v9;
    std::vector<std::string>::__vallocate[abi:ne180100](this, v10);
    v11 = this->__end_;
    v12 = &v11[__n];
    v13 = 24 * __n;
    do
    {
      v14 = __u->std::pair<const char *, const char *>;
      *(_QWORD *)&v11->matched = *(_QWORD *)&__u->matched;
      v11->std::pair<const char *, const char *> = v14;
      ++v11;
      v13 -= 24;
    }
    while (v13);
    this->__end_ = v12;
  }
}

_QWORD *std::__state<char>::~__state(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  return a1;
}

void std::vector<std::sub_match<char const*>>::resize(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __sz, std::vector<std::csub_match>::const_reference __x)
{
  std::vector<std::csub_match>::size_type v3;
  BOOL v4;
  std::vector<std::csub_match>::size_type v5;

  v3 = 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3);
  v4 = __sz >= v3;
  v5 = __sz - v3;
  if (v5 != 0 && v4)
  {
    std::vector<std::sub_match<char const*>>::__append(this, v5, __x);
  }
  else if (!v4)
  {
    this->__end_ = &this->__begin_[__sz];
  }
}

void std::vector<std::pair<unsigned long,char const*>>::resize(std::vector<std::pair<unsigned long, const char *>> *this, std::vector<std::pair<unsigned long, const char *>>::size_type __sz)
{
  std::vector<std::pair<unsigned long, const char *>>::size_type v2;

  v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2)
      this->__end_ = &this->__begin_[__sz];
  }
  else
  {
    std::vector<std::pair<unsigned long,char const*>>::__append(this, __sz - v2);
  }
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1E0C01FC8](exception, 12);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1E05D64B4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>()
{
  void *exception;

  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1E0C01FC8](exception, 16);
  __cxa_throw(exception, MEMORY[0x1E0DE4E20], MEMORY[0x1E0DE43B8]);
}

void sub_1E05D6500(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  void *v16[5];

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  v5 = v4 + 1;
  if (v4 + 1 > 0x2AAAAAAAAAAAAAALL)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x155555555555555)
    v9 = 0x2AAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v16[4] = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::__state<char>>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[96 * v4];
  v16[0] = v10;
  v16[1] = v11;
  v16[3] = &v10[96 * v9];
  v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = v12;
  *((_QWORD *)v11 + 5) = 0;
  *((_QWORD *)v11 + 6) = 0;
  *((_QWORD *)v11 + 4) = 0;
  *((_OWORD *)v11 + 2) = *(_OWORD *)(a2 + 32);
  *((_QWORD *)v11 + 6) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *((_QWORD *)v11 + 7) = 0;
  *((_QWORD *)v11 + 8) = 0;
  *((_QWORD *)v11 + 9) = 0;
  *(_OWORD *)(v11 + 56) = *(_OWORD *)(a2 + 56);
  *((_QWORD *)v11 + 9) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  v13 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(v11 + 85) = *(_QWORD *)(a2 + 85);
  *((_QWORD *)v11 + 10) = v13;
  v16[2] = v11 + 96;
  std::vector<std::__state<char>>::__swap_out_circular_buffer(a1, v16);
  v14 = a1[1];
  std::__split_buffer<std::__state<char>>::~__split_buffer(v16);
  return v14;
}

void sub_1E05D664C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::__state<char>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::__state<char>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::__state<char>>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::__state<char>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(96 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::__state<char>>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    do
    {
      v8 = *(_OWORD *)(a3 - 80);
      *(_OWORD *)(v7 - 96) = *(_OWORD *)(a3 - 96);
      *(_OWORD *)(v7 - 80) = v8;
      *(_QWORD *)(v7 - 56) = 0;
      *(_QWORD *)(v7 - 48) = 0;
      *(_QWORD *)(v7 - 64) = 0;
      *(_OWORD *)(v7 - 64) = *(_OWORD *)(a3 - 64);
      *(_QWORD *)(v7 - 48) = *(_QWORD *)(a3 - 48);
      *(_QWORD *)(a3 - 64) = 0;
      *(_QWORD *)(a3 - 56) = 0;
      *(_QWORD *)(a3 - 48) = 0;
      *(_QWORD *)(v7 - 40) = 0;
      *(_QWORD *)(v7 - 32) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 40) = *(_OWORD *)(a3 - 40);
      *(_QWORD *)(v7 - 24) = *(_QWORD *)(a3 - 24);
      *(_QWORD *)(a3 - 40) = 0;
      *(_QWORD *)(a3 - 32) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v9 = *(_QWORD *)(a3 - 16);
      *(_QWORD *)(v7 - 11) = *(_QWORD *)(a3 - 11);
      *(_QWORD *)(v7 - 16) = v9;
      v7 = *((_QWORD *)&v15 + 1) - 96;
      *((_QWORD *)&v15 + 1) -= 96;
      a3 -= 96;
    }
    while (a3 != a5);
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::__state<char>>,std::reverse_iterator<std::__state<char>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::__state<char>>,std::reverse_iterator<std::__state<char>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::__state<char>>,std::reverse_iterator<std::__state<char>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::__state<char>>,std::reverse_iterator<std::__state<char>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  v1 = *(_QWORD **)(a1[2] + 8);
  v2 = *(_QWORD **)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<std::__state<char>>::destroy[abi:ne180100](v3, v1);
      v1 += 12;
    }
    while (v1 != v2);
  }
}

void std::allocator<std::__state<char>>::destroy[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;

  v3 = (void *)a2[7];
  if (v3)
  {
    a2[8] = v3;
    operator delete(v3);
  }
  v4 = (void *)a2[4];
  if (v4)
  {
    a2[5] = v4;
    operator delete(v4);
  }
}

void **std::__split_buffer<std::__state<char>>::~__split_buffer(void **a1)
{
  std::__split_buffer<std::__state<char>>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<std::__state<char>>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 96;
    std::allocator<std::__state<char>>::destroy[abi:ne180100](v4, (_QWORD *)(i - 96));
  }
}

void std::vector<std::sub_match<char const*>>::__append(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __n, std::vector<std::csub_match>::const_reference __x)
{
  std::__compressed_pair<std::csub_match *> *p_end_cap;
  std::sub_match<const char *> *v7;
  std::sub_match<const char *> *value;
  std::sub_match<const char *> *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  std::sub_match<const char *> *v15;
  std::vector<std::csub_match>::size_type v16;
  std::pair<const char *, const char *> v17;
  std::sub_match<const char *> *v18;
  std::sub_match<const char *> *v19;
  std::vector<std::csub_match>::size_type v20;
  std::pair<const char *, const char *> *v21;
  std::pair<const char *, const char *> v22;
  std::sub_match<const char *> *v23;
  std::sub_match<const char *> *end;
  std::vector<std::csub_match>::pointer begin;
  std::pair<const char *, const char *> v26;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v7 = value;
  v9 = p_end_cap[-1].__value_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)v9) >> 3) >= __n)
  {
    if (__n)
    {
      v15 = &v9[__n];
      v16 = 24 * __n;
      do
      {
        v17 = __x->std::pair<const char *, const char *>;
        *(_QWORD *)&v9->matched = *(_QWORD *)&__x->matched;
        v9->std::pair<const char *, const char *> = v17;
        ++v9;
        v16 -= 24;
      }
      while (v16);
      v9 = v15;
    }
    this->__end_ = v9;
  }
  else
  {
    v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v9 - (char *)this->__begin_) >> 3);
    v11 = v10 + __n;
    if (v10 + __n > 0xAAAAAAAAAAAAAAALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v12 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (char *)this->__begin_) >> 3);
    if (2 * v12 > v11)
      v11 = 2 * v12;
    if (v12 >= 0x555555555555555)
      v13 = 0xAAAAAAAAAAAAAAALL;
    else
      v13 = v11;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)p_end_cap, v13);
    else
      v14 = 0;
    v18 = (std::sub_match<const char *> *)&v14[24 * v10];
    v19 = &v18[__n];
    v20 = 24 * __n;
    v21 = v18;
    do
    {
      v22 = __x->std::pair<const char *, const char *>;
      v21[1].first = *(const char **)&__x->matched;
      *v21 = v22;
      v21 = (std::pair<const char *, const char *> *)((char *)v21 + 24);
      v20 -= 24;
    }
    while (v20);
    v23 = (std::sub_match<const char *> *)&v14[24 * v13];
    begin = this->__begin_;
    end = this->__end_;
    if (end != this->__begin_)
    {
      do
      {
        v26 = end[-1].std::pair<const char *, const char *>;
        *(_QWORD *)&v18[-1].matched = *(_QWORD *)&end[-1].matched;
        v18[-1].std::pair<const char *, const char *> = v26;
        --v18;
        --end;
      }
      while (end != begin);
      end = this->__begin_;
    }
    this->__begin_ = v18;
    this->__end_ = v19;
    this->__end_cap_.__value_ = v23;
    if (end)
      operator delete(end);
  }
}

void std::vector<std::pair<unsigned long,char const*>>::__append(std::vector<std::pair<unsigned long, const char *>> *this, std::vector<std::pair<unsigned long, const char *>>::size_type __n)
{
  std::__compressed_pair<std::pair<unsigned long, const char *> *, std::allocator<std::pair<unsigned long, const char *>>> *p_end_cap;
  std::pair<unsigned long, const char *> *v5;
  std::pair<unsigned long, const char *> *value;
  std::pair<unsigned long, const char *> *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  std::pair<unsigned long, const char *> *v14;
  std::pair<unsigned long, const char *> *v15;
  std::pair<unsigned long, const char *> *v16;
  std::pair<unsigned long, const char *> *end;
  std::vector<std::pair<unsigned long, const char *>>::pointer begin;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v5 = value;
  v7 = p_end_cap[-1].__value_;
  if (__n <= value - v7)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 16 * __n);
      v7 += __n;
    }
    this->__end_ = v7;
  }
  else
  {
    v8 = (char *)v7 - (char *)this->__begin_;
    v9 = __n + (v8 >> 4);
    if (v9 >> 60)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 4;
    v11 = (char *)v5 - (char *)this->__begin_;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)p_end_cap, v12);
    else
      v13 = 0;
    v14 = (std::pair<unsigned long, const char *> *)&v13[16 * v10];
    v15 = (std::pair<unsigned long, const char *> *)&v13[16 * v12];
    bzero(v14, 16 * __n);
    v16 = &v14[__n];
    begin = this->__begin_;
    end = this->__end_;
    if (end != this->__begin_)
    {
      do
      {
        v14[-1] = end[-1];
        --v14;
        --end;
      }
      while (end != begin);
      end = this->__begin_;
    }
    this->__begin_ = v14;
    this->__end_ = v16;
    this->__end_cap_.__value_ = v15;
    if (end)
      operator delete(end);
  }
}

char *std::vector<std::sub_match<char const*>>::__init_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  char *v6;
  uint64_t v7;
  __int128 v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    v7 = *((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2;
      *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
      *(_OWORD *)v7 = v8;
      v7 += 24;
      a2 = (__int128 *)((char *)a2 + 24);
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1E05D6C14(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<unsigned long,char const*>>::__init_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  char *v6;
  _OWORD *v7;
  __int128 v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vallocate[abi:ne180100](result, a4);
    v7 = (_OWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      *v7++ = v8;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1E05D6C84(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 12;
        std::allocator<std::__state<char>>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_atom_escape<std::__wrap_iter<char const*>>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v5;
  unsigned __int8 *result;

  if (a2 == a3 || *a2 != 92)
    return a2;
  v5 = a2 + 1;
  if (a2 + 1 == a3)
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
  result = std::basic_regex<char,std::regex_traits<char>>::__parse_decimal_escape<std::__wrap_iter<char const*>>(a1, a2 + 1, a3);
  if (v5 == result)
  {
    result = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_character_class_escape<std::__wrap_iter<char const*>>(a1, (char *)a2 + 1, (char *)a3);
    if (v5 == result)
    {
      result = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<std::__wrap_iter<char const*>>(a1, (std::basic_regex<char> *)(a2 + 1), (std::basic_regex<char> *)a3, 0);
      if (v5 == result)
        return a2;
    }
  }
  return result;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<std::__wrap_iter<char const*>>(uint64_t a1, char *a2, char *a3)
{
  char *v5;
  std::__bracket_expression<char, std::regex_traits<char>> *started;
  uint64_t *v7;
  char *v8;

  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 == a3)
      goto LABEL_20;
    v5 = a2[1] == 94 ? a2 + 2 : a2 + 1;
    started = std::basic_regex<char,std::regex_traits<char>>::__start_matching_list((std::basic_regex<char> *)a1, a2[1] == 94);
    if (v5 == a3)
      goto LABEL_20;
    v7 = (uint64_t *)started;
    if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0 && *v5 == 93)
    {
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)started, 93);
      ++v5;
    }
    if (v5 == a3)
      goto LABEL_20;
    do
    {
      v8 = v5;
      v5 = std::basic_regex<char,std::regex_traits<char>>::__parse_expression_term<std::__wrap_iter<char const*>>(a1, v5, a3, v7);
    }
    while (v8 != v5);
    if (v8 == a3)
      goto LABEL_20;
    if (*v8 == 45)
    {
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)v7, 45);
      ++v8;
    }
    if (v8 == a3 || *v8 != 93)
LABEL_20:
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
    return v8 + 1;
  }
  return a2;
}

